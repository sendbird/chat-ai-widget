var Ch = (e, n, t) => {
  if (!n.has(e))
    throw TypeError("Cannot " + t);
};
var _ = (e, n, t) => (Ch(e, n, "read from private field"), t ? t.call(e) : n.get(e)), Yt = (e, n, t) => {
  if (n.has(e))
    throw TypeError("Cannot add the same private member more than once");
  n instanceof WeakSet ? n.add(e) : n.set(e, t);
}, Tt = (e, n, t, l) => (Ch(e, n, "write to private field"), l ? l.call(e, t) : n.set(e, t), t), vU = (e, n, t, l) => ({
  set _(a) {
    Tt(e, n, a, t);
  },
  get _() {
    return _(e, n, l);
  }
}), Un = (e, n, t) => (Ch(e, n, "access private method"), t);
import * as z from "react";
import T, { useRef as Wt, useContext as Gt, createElement as na, useCallback as Pt, createContext as _l, useState as me, useEffect as _e, useLayoutEffect as ud, useMemo as nn, useReducer as zs, Component as sW, useInsertionEffect as qS, forwardRef as vV, useId as oW, cloneElement as $S, Children as ek, isValidElement as Pv, useImperativeHandle as Av, lazy as qv, Suspense as $v, Fragment as ez } from "react";
import * as tk from "react-dom";
import { createPortal as Yi } from "react-dom";
var Qle = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function nk(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var WT = { exports: {} }, qc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Vm;
function tz() {
  if (Vm)
    return qc;
  Vm = 1;
  var e = T, n = Symbol.for("react.element"), t = Symbol.for("react.fragment"), l = Object.prototype.hasOwnProperty, a = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, d = { key: !0, ref: !0, __self: !0, __source: !0 };
  function r(i, c, V) {
    var s, o = {}, U = null, N = null;
    V !== void 0 && (U = "" + V), c.key !== void 0 && (U = "" + c.key), c.ref !== void 0 && (N = c.ref);
    for (s in c)
      l.call(c, s) && !d.hasOwnProperty(s) && (o[s] = c[s]);
    if (i && i.defaultProps)
      for (s in c = i.defaultProps, c)
        o[s] === void 0 && (o[s] = c[s]);
    return { $$typeof: n, type: i, key: U, ref: N, props: o, _owner: a.current };
  }
  return qc.Fragment = t, qc.jsx = r, qc.jsxs = r, qc;
}
var $c = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cm;
function nz() {
  return cm || (cm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = T, n = Symbol.for("react.element"), t = Symbol.for("react.portal"), l = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), d = Symbol.for("react.profiler"), r = Symbol.for("react.provider"), i = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), V = Symbol.for("react.suspense"), s = Symbol.for("react.suspense_list"), o = Symbol.for("react.memo"), U = Symbol.for("react.lazy"), N = Symbol.for("react.offscreen"), R = Symbol.iterator, h = "@@iterator";
    function Z(X) {
      if (X === null || typeof X != "object")
        return null;
      var Ne = R && X[R] || X[h];
      return typeof Ne == "function" ? Ne : null;
    }
    var W = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function F(X) {
      {
        for (var Ne = arguments.length, pe = new Array(Ne > 1 ? Ne - 1 : 0), we = 1; we < Ne; we++)
          pe[we - 1] = arguments[we];
        m("error", X, pe);
      }
    }
    function m(X, Ne, pe) {
      {
        var we = W.ReactDebugCurrentFrame, Nt = we.getStackAddendum();
        Nt !== "" && (Ne += "%s", pe = pe.concat([Nt]));
        var Ee = pe.map(function(H) {
          return String(H);
        });
        Ee.unshift("Warning: " + Ne), Function.prototype.apply.call(console[X], console, Ee);
      }
    }
    var E = !1, u = !1, b = !1, k = !1, Q = !1, S;
    S = Symbol.for("react.module.reference");
    function v(X) {
      return !!(typeof X == "string" || typeof X == "function" || X === l || X === d || Q || X === a || X === V || X === s || k || X === N || E || u || b || typeof X == "object" && X !== null && (X.$$typeof === U || X.$$typeof === o || X.$$typeof === r || X.$$typeof === i || X.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      X.$$typeof === S || X.getModuleId !== void 0));
    }
    function G(X, Ne, pe) {
      var we = X.displayName;
      if (we)
        return we;
      var Nt = Ne.displayName || Ne.name || "";
      return Nt !== "" ? pe + "(" + Nt + ")" : pe;
    }
    function w(X) {
      return X.displayName || "Context";
    }
    function y(X) {
      if (X == null)
        return null;
      if (typeof X.tag == "number" && F("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof X == "function")
        return X.displayName || X.name || null;
      if (typeof X == "string")
        return X;
      switch (X) {
        case l:
          return "Fragment";
        case t:
          return "Portal";
        case d:
          return "Profiler";
        case a:
          return "StrictMode";
        case V:
          return "Suspense";
        case s:
          return "SuspenseList";
      }
      if (typeof X == "object")
        switch (X.$$typeof) {
          case i:
            var Ne = X;
            return w(Ne) + ".Consumer";
          case r:
            var pe = X;
            return w(pe._context) + ".Provider";
          case c:
            return G(X, X.render, "ForwardRef");
          case o:
            var we = X.displayName || null;
            return we !== null ? we : y(X.type) || "Memo";
          case U: {
            var Nt = X, Ee = Nt._payload, H = Nt._init;
            try {
              return y(H(Ee));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var g = Object.assign, f = 0, I, K, Ue, q, ae, se, le;
    function L() {
    }
    L.__reactDisabledLog = !0;
    function $() {
      {
        if (f === 0) {
          I = console.log, K = console.info, Ue = console.warn, q = console.error, ae = console.group, se = console.groupCollapsed, le = console.groupEnd;
          var X = {
            configurable: !0,
            enumerable: !0,
            value: L,
            writable: !0
          };
          Object.defineProperties(console, {
            info: X,
            log: X,
            warn: X,
            error: X,
            group: X,
            groupCollapsed: X,
            groupEnd: X
          });
        }
        f++;
      }
    }
    function ee() {
      {
        if (f--, f === 0) {
          var X = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: g({}, X, {
              value: I
            }),
            info: g({}, X, {
              value: K
            }),
            warn: g({}, X, {
              value: Ue
            }),
            error: g({}, X, {
              value: q
            }),
            group: g({}, X, {
              value: ae
            }),
            groupCollapsed: g({}, X, {
              value: se
            }),
            groupEnd: g({}, X, {
              value: le
            })
          });
        }
        f < 0 && F("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var O = W.ReactCurrentDispatcher, re;
    function te(X, Ne, pe) {
      {
        if (re === void 0)
          try {
            throw Error();
          } catch (Nt) {
            var we = Nt.stack.trim().match(/\n( *(at )?)/);
            re = we && we[1] || "";
          }
        return `
` + re + X;
      }
    }
    var Qe = !1, Ye;
    {
      var Se = typeof WeakMap == "function" ? WeakMap : Map;
      Ye = new Se();
    }
    function P(X, Ne) {
      if (!X || Qe)
        return "";
      {
        var pe = Ye.get(X);
        if (pe !== void 0)
          return pe;
      }
      var we;
      Qe = !0;
      var Nt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ee;
      Ee = O.current, O.current = null, $();
      try {
        if (Ne) {
          var H = function() {
            throw Error();
          };
          if (Object.defineProperty(H.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(H, []);
            } catch (bt) {
              we = bt;
            }
            Reflect.construct(X, [], H);
          } else {
            try {
              H.call();
            } catch (bt) {
              we = bt;
            }
            X.call(H.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (bt) {
            we = bt;
          }
          X();
        }
      } catch (bt) {
        if (bt && we && typeof bt.stack == "string") {
          for (var Ve = bt.stack.split(`
`), ye = we.stack.split(`
`), Zt = Ve.length - 1, Mt = ye.length - 1; Zt >= 1 && Mt >= 0 && Ve[Zt] !== ye[Mt]; )
            Mt--;
          for (; Zt >= 1 && Mt >= 0; Zt--, Mt--)
            if (Ve[Zt] !== ye[Mt]) {
              if (Zt !== 1 || Mt !== 1)
                do
                  if (Zt--, Mt--, Mt < 0 || Ve[Zt] !== ye[Mt]) {
                    var Ct = `
` + Ve[Zt].replace(" at new ", " at ");
                    return X.displayName && Ct.includes("<anonymous>") && (Ct = Ct.replace("<anonymous>", X.displayName)), typeof X == "function" && Ye.set(X, Ct), Ct;
                  }
                while (Zt >= 1 && Mt >= 0);
              break;
            }
        }
      } finally {
        Qe = !1, O.current = Ee, ee(), Error.prepareStackTrace = Nt;
      }
      var Ht = X ? X.displayName || X.name : "", Sn = Ht ? te(Ht) : "";
      return typeof X == "function" && Ye.set(X, Sn), Sn;
    }
    function ge(X, Ne, pe) {
      return P(X, !1);
    }
    function Me(X) {
      var Ne = X.prototype;
      return !!(Ne && Ne.isReactComponent);
    }
    function We(X, Ne, pe) {
      if (X == null)
        return "";
      if (typeof X == "function")
        return P(X, Me(X));
      if (typeof X == "string")
        return te(X);
      switch (X) {
        case V:
          return te("Suspense");
        case s:
          return te("SuspenseList");
      }
      if (typeof X == "object")
        switch (X.$$typeof) {
          case c:
            return ge(X.render);
          case o:
            return We(X.type, Ne, pe);
          case U: {
            var we = X, Nt = we._payload, Ee = we._init;
            try {
              return We(Ee(Nt), Ne, pe);
            } catch {
            }
          }
        }
      return "";
    }
    var De = Object.prototype.hasOwnProperty, Oe = {}, tt = W.ReactDebugCurrentFrame;
    function Be(X) {
      if (X) {
        var Ne = X._owner, pe = We(X.type, X._source, Ne ? Ne.type : null);
        tt.setExtraStackFrame(pe);
      } else
        tt.setExtraStackFrame(null);
    }
    function He(X, Ne, pe, we, Nt) {
      {
        var Ee = Function.call.bind(De);
        for (var H in X)
          if (Ee(X, H)) {
            var Ve = void 0;
            try {
              if (typeof X[H] != "function") {
                var ye = Error((we || "React class") + ": " + pe + " type `" + H + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof X[H] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ye.name = "Invariant Violation", ye;
              }
              Ve = X[H](Ne, H, we, pe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Zt) {
              Ve = Zt;
            }
            Ve && !(Ve instanceof Error) && (Be(Nt), F("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", we || "React class", pe, H, typeof Ve), Be(null)), Ve instanceof Error && !(Ve.message in Oe) && (Oe[Ve.message] = !0, Be(Nt), F("Failed %s type: %s", pe, Ve.message), Be(null));
          }
      }
    }
    var at = Array.isArray;
    function Ge(X) {
      return at(X);
    }
    function $e(X) {
      {
        var Ne = typeof Symbol == "function" && Symbol.toStringTag, pe = Ne && X[Symbol.toStringTag] || X.constructor.name || "Object";
        return pe;
      }
    }
    function fe(X) {
      try {
        return Xe(X), !1;
      } catch {
        return !0;
      }
    }
    function Xe(X) {
      return "" + X;
    }
    function pt(X) {
      if (fe(X))
        return F("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", $e(X)), Xe(X);
    }
    var Vt = W.ReactCurrentOwner, yt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, xe, At, kt;
    kt = {};
    function Kt(X) {
      if (De.call(X, "ref")) {
        var Ne = Object.getOwnPropertyDescriptor(X, "ref").get;
        if (Ne && Ne.isReactWarning)
          return !1;
      }
      return X.ref !== void 0;
    }
    function ln(X) {
      if (De.call(X, "key")) {
        var Ne = Object.getOwnPropertyDescriptor(X, "key").get;
        if (Ne && Ne.isReactWarning)
          return !1;
      }
      return X.key !== void 0;
    }
    function vt(X, Ne) {
      if (typeof X.ref == "string" && Vt.current && Ne && Vt.current.stateNode !== Ne) {
        var pe = y(Vt.current.type);
        kt[pe] || (F('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', y(Vt.current.type), X.ref), kt[pe] = !0);
      }
    }
    function Rt(X, Ne) {
      {
        var pe = function() {
          xe || (xe = !0, F("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ne));
        };
        pe.isReactWarning = !0, Object.defineProperty(X, "key", {
          get: pe,
          configurable: !0
        });
      }
    }
    function Ke(X, Ne) {
      {
        var pe = function() {
          At || (At = !0, F("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ne));
        };
        pe.isReactWarning = !0, Object.defineProperty(X, "ref", {
          get: pe,
          configurable: !0
        });
      }
    }
    var Je = function(X, Ne, pe, we, Nt, Ee, H) {
      var Ve = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: X,
        key: Ne,
        ref: pe,
        props: H,
        // Record the component responsible for creating this element.
        _owner: Ee
      };
      return Ve._store = {}, Object.defineProperty(Ve._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ve, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: we
      }), Object.defineProperty(Ve, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Nt
      }), Object.freeze && (Object.freeze(Ve.props), Object.freeze(Ve)), Ve;
    };
    function de(X, Ne, pe, we, Nt) {
      {
        var Ee, H = {}, Ve = null, ye = null;
        pe !== void 0 && (pt(pe), Ve = "" + pe), ln(Ne) && (pt(Ne.key), Ve = "" + Ne.key), Kt(Ne) && (ye = Ne.ref, vt(Ne, Nt));
        for (Ee in Ne)
          De.call(Ne, Ee) && !yt.hasOwnProperty(Ee) && (H[Ee] = Ne[Ee]);
        if (X && X.defaultProps) {
          var Zt = X.defaultProps;
          for (Ee in Zt)
            H[Ee] === void 0 && (H[Ee] = Zt[Ee]);
        }
        if (Ve || ye) {
          var Mt = typeof X == "function" ? X.displayName || X.name || "Unknown" : X;
          Ve && Rt(H, Mt), ye && Ke(H, Mt);
        }
        return Je(X, Ve, ye, Nt, we, Vt.current, H);
      }
    }
    var qe = W.ReactCurrentOwner, lt = W.ReactDebugCurrentFrame;
    function ct(X) {
      if (X) {
        var Ne = X._owner, pe = We(X.type, X._source, Ne ? Ne.type : null);
        lt.setExtraStackFrame(pe);
      } else
        lt.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function zt(X) {
      return typeof X == "object" && X !== null && X.$$typeof === n;
    }
    function cn() {
      {
        if (qe.current) {
          var X = y(qe.current.type);
          if (X)
            return `

Check the render method of \`` + X + "`.";
        }
        return "";
      }
    }
    function mt(X) {
      {
        if (X !== void 0) {
          var Ne = X.fileName.replace(/^.*[\\\/]/, ""), pe = X.lineNumber;
          return `

Check your code at ` + Ne + ":" + pe + ".";
        }
        return "";
      }
    }
    var sn = {};
    function hn(X) {
      {
        var Ne = cn();
        if (!Ne) {
          var pe = typeof X == "string" ? X : X.displayName || X.name;
          pe && (Ne = `

Check the top-level render call using <` + pe + ">.");
        }
        return Ne;
      }
    }
    function ft(X, Ne) {
      {
        if (!X._store || X._store.validated || X.key != null)
          return;
        X._store.validated = !0;
        var pe = hn(Ne);
        if (sn[pe])
          return;
        sn[pe] = !0;
        var we = "";
        X && X._owner && X._owner !== qe.current && (we = " It was passed a child from " + y(X._owner.type) + "."), ct(X), F('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', pe, we), ct(null);
      }
    }
    function qt(X, Ne) {
      {
        if (typeof X != "object")
          return;
        if (Ge(X))
          for (var pe = 0; pe < X.length; pe++) {
            var we = X[pe];
            zt(we) && ft(we, Ne);
          }
        else if (zt(X))
          X._store && (X._store.validated = !0);
        else if (X) {
          var Nt = Z(X);
          if (typeof Nt == "function" && Nt !== X.entries)
            for (var Ee = Nt.call(X), H; !(H = Ee.next()).done; )
              zt(H.value) && ft(H.value, Ne);
        }
      }
    }
    function jt(X) {
      {
        var Ne = X.type;
        if (Ne == null || typeof Ne == "string")
          return;
        var pe;
        if (typeof Ne == "function")
          pe = Ne.propTypes;
        else if (typeof Ne == "object" && (Ne.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ne.$$typeof === o))
          pe = Ne.propTypes;
        else
          return;
        if (pe) {
          var we = y(Ne);
          He(pe, X.props, "prop", we, X);
        } else if (Ne.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var Nt = y(Ne);
          F("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Nt || "Unknown");
        }
        typeof Ne.getDefaultProps == "function" && !Ne.getDefaultProps.isReactClassApproved && F("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Bt(X) {
      {
        for (var Ne = Object.keys(X.props), pe = 0; pe < Ne.length; pe++) {
          var we = Ne[pe];
          if (we !== "children" && we !== "key") {
            ct(X), F("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", we), ct(null);
            break;
          }
        }
        X.ref !== null && (ct(X), F("Invalid attribute `ref` supplied to `React.Fragment`."), ct(null));
      }
    }
    function Ie(X, Ne, pe, we, Nt, Ee) {
      {
        var H = v(X);
        if (!H) {
          var Ve = "";
          (X === void 0 || typeof X == "object" && X !== null && Object.keys(X).length === 0) && (Ve += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ye = mt(Nt);
          ye ? Ve += ye : Ve += cn();
          var Zt;
          X === null ? Zt = "null" : Ge(X) ? Zt = "array" : X !== void 0 && X.$$typeof === n ? (Zt = "<" + (y(X.type) || "Unknown") + " />", Ve = " Did you accidentally export a JSX literal instead of a component?") : Zt = typeof X, F("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Zt, Ve);
        }
        var Mt = de(X, Ne, pe, Nt, Ee);
        if (Mt == null)
          return Mt;
        if (H) {
          var Ct = Ne.children;
          if (Ct !== void 0)
            if (we)
              if (Ge(Ct)) {
                for (var Ht = 0; Ht < Ct.length; Ht++)
                  qt(Ct[Ht], X);
                Object.freeze && Object.freeze(Ct);
              } else
                F("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              qt(Ct, X);
        }
        return X === l ? Bt(Mt) : jt(Mt), Mt;
      }
    }
    function it(X, Ne, pe) {
      return Ie(X, Ne, pe, !0);
    }
    function ze(X, Ne, pe) {
      return Ie(X, Ne, pe, !1);
    }
    var ht = ze, Ft = it;
    $c.Fragment = l, $c.jsx = ht, $c.jsxs = Ft;
  }()), $c;
}
process.env.NODE_ENV === "production" ? WT.exports = tz() : WT.exports = nz();
var Y = WT.exports;
var mT = { exports: {} }, kn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sm;
function lz() {
  if (sm)
    return kn;
  sm = 1;
  var e = Symbol.for("react.element"), n = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), l = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), d = Symbol.for("react.provider"), r = Symbol.for("react.context"), i = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), V = Symbol.for("react.suspense"), s = Symbol.for("react.suspense_list"), o = Symbol.for("react.memo"), U = Symbol.for("react.lazy"), N = Symbol.for("react.offscreen"), R;
  R = Symbol.for("react.module.reference");
  function h(Z) {
    if (typeof Z == "object" && Z !== null) {
      var W = Z.$$typeof;
      switch (W) {
        case e:
          switch (Z = Z.type, Z) {
            case t:
            case a:
            case l:
            case V:
            case s:
              return Z;
            default:
              switch (Z = Z && Z.$$typeof, Z) {
                case i:
                case r:
                case c:
                case U:
                case o:
                case d:
                  return Z;
                default:
                  return W;
              }
          }
        case n:
          return W;
      }
    }
  }
  return kn.ContextConsumer = r, kn.ContextProvider = d, kn.Element = e, kn.ForwardRef = c, kn.Fragment = t, kn.Lazy = U, kn.Memo = o, kn.Portal = n, kn.Profiler = a, kn.StrictMode = l, kn.Suspense = V, kn.SuspenseList = s, kn.isAsyncMode = function() {
    return !1;
  }, kn.isConcurrentMode = function() {
    return !1;
  }, kn.isContextConsumer = function(Z) {
    return h(Z) === r;
  }, kn.isContextProvider = function(Z) {
    return h(Z) === d;
  }, kn.isElement = function(Z) {
    return typeof Z == "object" && Z !== null && Z.$$typeof === e;
  }, kn.isForwardRef = function(Z) {
    return h(Z) === c;
  }, kn.isFragment = function(Z) {
    return h(Z) === t;
  }, kn.isLazy = function(Z) {
    return h(Z) === U;
  }, kn.isMemo = function(Z) {
    return h(Z) === o;
  }, kn.isPortal = function(Z) {
    return h(Z) === n;
  }, kn.isProfiler = function(Z) {
    return h(Z) === a;
  }, kn.isStrictMode = function(Z) {
    return h(Z) === l;
  }, kn.isSuspense = function(Z) {
    return h(Z) === V;
  }, kn.isSuspenseList = function(Z) {
    return h(Z) === s;
  }, kn.isValidElementType = function(Z) {
    return typeof Z == "string" || typeof Z == "function" || Z === t || Z === a || Z === l || Z === V || Z === s || Z === N || typeof Z == "object" && Z !== null && (Z.$$typeof === U || Z.$$typeof === o || Z.$$typeof === d || Z.$$typeof === r || Z.$$typeof === c || Z.$$typeof === R || Z.getModuleId !== void 0);
  }, kn.typeOf = h, kn;
}
var bn = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var om;
function az() {
  return om || (om = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), n = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), l = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), d = Symbol.for("react.provider"), r = Symbol.for("react.context"), i = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), V = Symbol.for("react.suspense"), s = Symbol.for("react.suspense_list"), o = Symbol.for("react.memo"), U = Symbol.for("react.lazy"), N = Symbol.for("react.offscreen"), R = !1, h = !1, Z = !1, W = !1, F = !1, m;
    m = Symbol.for("react.module.reference");
    function E(Me) {
      return !!(typeof Me == "string" || typeof Me == "function" || Me === t || Me === a || F || Me === l || Me === V || Me === s || W || Me === N || R || h || Z || typeof Me == "object" && Me !== null && (Me.$$typeof === U || Me.$$typeof === o || Me.$$typeof === d || Me.$$typeof === r || Me.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Me.$$typeof === m || Me.getModuleId !== void 0));
    }
    function u(Me) {
      if (typeof Me == "object" && Me !== null) {
        var We = Me.$$typeof;
        switch (We) {
          case e:
            var De = Me.type;
            switch (De) {
              case t:
              case a:
              case l:
              case V:
              case s:
                return De;
              default:
                var Oe = De && De.$$typeof;
                switch (Oe) {
                  case i:
                  case r:
                  case c:
                  case U:
                  case o:
                  case d:
                    return Oe;
                  default:
                    return We;
                }
            }
          case n:
            return We;
        }
      }
    }
    var b = r, k = d, Q = e, S = c, v = t, G = U, w = o, y = n, g = a, f = l, I = V, K = s, Ue = !1, q = !1;
    function ae(Me) {
      return Ue || (Ue = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function se(Me) {
      return q || (q = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function le(Me) {
      return u(Me) === r;
    }
    function L(Me) {
      return u(Me) === d;
    }
    function $(Me) {
      return typeof Me == "object" && Me !== null && Me.$$typeof === e;
    }
    function ee(Me) {
      return u(Me) === c;
    }
    function O(Me) {
      return u(Me) === t;
    }
    function re(Me) {
      return u(Me) === U;
    }
    function te(Me) {
      return u(Me) === o;
    }
    function Qe(Me) {
      return u(Me) === n;
    }
    function Ye(Me) {
      return u(Me) === a;
    }
    function Se(Me) {
      return u(Me) === l;
    }
    function P(Me) {
      return u(Me) === V;
    }
    function ge(Me) {
      return u(Me) === s;
    }
    bn.ContextConsumer = b, bn.ContextProvider = k, bn.Element = Q, bn.ForwardRef = S, bn.Fragment = v, bn.Lazy = G, bn.Memo = w, bn.Portal = y, bn.Profiler = g, bn.StrictMode = f, bn.Suspense = I, bn.SuspenseList = K, bn.isAsyncMode = ae, bn.isConcurrentMode = se, bn.isContextConsumer = le, bn.isContextProvider = L, bn.isElement = $, bn.isForwardRef = ee, bn.isFragment = O, bn.isLazy = re, bn.isMemo = te, bn.isPortal = Qe, bn.isProfiler = Ye, bn.isStrictMode = Se, bn.isSuspense = P, bn.isSuspenseList = ge, bn.isValidElementType = E, bn.typeOf = u;
  }()), bn;
}
process.env.NODE_ENV === "production" ? mT.exports = lz() : mT.exports = az();
var UW = mT.exports;
function dz(e) {
  function n(le, L, $, ee, O) {
    for (var re = 0, te = 0, Qe = 0, Ye = 0, Se, P, ge = 0, Me = 0, We, De = We = Se = 0, Oe = 0, tt = 0, Be = 0, He = 0, at = $.length, Ge = at - 1, $e, fe = "", Xe = "", pt = "", Vt = "", yt; Oe < at; ) {
      if (P = $.charCodeAt(Oe), Oe === Ge && te + Ye + Qe + re !== 0 && (te !== 0 && (P = te === 47 ? 10 : 47), Ye = Qe = re = 0, at++, Ge++), te + Ye + Qe + re === 0) {
        if (Oe === Ge && (0 < tt && (fe = fe.replace(U, "")), 0 < fe.trim().length)) {
          switch (P) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              fe += $.charAt(Oe);
          }
          P = 59;
        }
        switch (P) {
          case 123:
            for (fe = fe.trim(), Se = fe.charCodeAt(0), We = 1, He = ++Oe; Oe < at; ) {
              switch (P = $.charCodeAt(Oe)) {
                case 123:
                  We++;
                  break;
                case 125:
                  We--;
                  break;
                case 47:
                  switch (P = $.charCodeAt(Oe + 1)) {
                    case 42:
                    case 47:
                      e: {
                        for (De = Oe + 1; De < Ge; ++De)
                          switch ($.charCodeAt(De)) {
                            case 47:
                              if (P === 42 && $.charCodeAt(De - 1) === 42 && Oe + 2 !== De) {
                                Oe = De + 1;
                                break e;
                              }
                              break;
                            case 10:
                              if (P === 47) {
                                Oe = De + 1;
                                break e;
                              }
                          }
                        Oe = De;
                      }
                  }
                  break;
                case 91:
                  P++;
                case 40:
                  P++;
                case 34:
                case 39:
                  for (; Oe++ < Ge && $.charCodeAt(Oe) !== P; )
                    ;
              }
              if (We === 0)
                break;
              Oe++;
            }
            switch (We = $.substring(He, Oe), Se === 0 && (Se = (fe = fe.replace(o, "").trim()).charCodeAt(0)), Se) {
              case 64:
                switch (0 < tt && (fe = fe.replace(U, "")), P = fe.charCodeAt(1), P) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    tt = L;
                    break;
                  default:
                    tt = I;
                }
                if (We = n(L, tt, We, P, O + 1), He = We.length, 0 < Ue && (tt = t(I, fe, Be), yt = i(3, We, tt, L, y, w, He, P, O, ee), fe = tt.join(""), yt !== void 0 && (He = (We = yt.trim()).length) === 0 && (P = 0, We = "")), 0 < He)
                  switch (P) {
                    case 115:
                      fe = fe.replace(b, r);
                    case 100:
                    case 109:
                    case 45:
                      We = fe + "{" + We + "}";
                      break;
                    case 107:
                      fe = fe.replace(F, "$1 $2"), We = fe + "{" + We + "}", We = f === 1 || f === 2 && d("@" + We, 3) ? "@-webkit-" + We + "@" + We : "@" + We;
                      break;
                    default:
                      We = fe + We, ee === 112 && (We = (Xe += We, ""));
                  }
                else
                  We = "";
                break;
              default:
                We = n(L, t(L, fe, Be), We, ee, O + 1);
            }
            pt += We, We = Be = tt = De = Se = 0, fe = "", P = $.charCodeAt(++Oe);
            break;
          case 125:
          case 59:
            if (fe = (0 < tt ? fe.replace(U, "") : fe).trim(), 1 < (He = fe.length))
              switch (De === 0 && (Se = fe.charCodeAt(0), Se === 45 || 96 < Se && 123 > Se) && (He = (fe = fe.replace(" ", ":")).length), 0 < Ue && (yt = i(1, fe, L, le, y, w, Xe.length, ee, O, ee)) !== void 0 && (He = (fe = yt.trim()).length) === 0 && (fe = "\0\0"), Se = fe.charCodeAt(0), P = fe.charCodeAt(1), Se) {
                case 0:
                  break;
                case 64:
                  if (P === 105 || P === 99) {
                    Vt += fe + $.charAt(Oe);
                    break;
                  }
                default:
                  fe.charCodeAt(He - 1) !== 58 && (Xe += a(fe, Se, P, fe.charCodeAt(2)));
              }
            Be = tt = De = Se = 0, fe = "", P = $.charCodeAt(++Oe);
        }
      }
      switch (P) {
        case 13:
        case 10:
          te === 47 ? te = 0 : 1 + Se === 0 && ee !== 107 && 0 < fe.length && (tt = 1, fe += "\0"), 0 < Ue * ae && i(0, fe, L, le, y, w, Xe.length, ee, O, ee), w = 1, y++;
          break;
        case 59:
        case 125:
          if (te + Ye + Qe + re === 0) {
            w++;
            break;
          }
        default:
          switch (w++, $e = $.charAt(Oe), P) {
            case 9:
            case 32:
              if (Ye + re + te === 0)
                switch (ge) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    $e = "";
                    break;
                  default:
                    P !== 32 && ($e = " ");
                }
              break;
            case 0:
              $e = "\\0";
              break;
            case 12:
              $e = "\\f";
              break;
            case 11:
              $e = "\\v";
              break;
            case 38:
              Ye + te + re === 0 && (tt = Be = 1, $e = "\f" + $e);
              break;
            case 108:
              if (Ye + te + re + g === 0 && 0 < De)
                switch (Oe - De) {
                  case 2:
                    ge === 112 && $.charCodeAt(Oe - 3) === 58 && (g = ge);
                  case 8:
                    Me === 111 && (g = Me);
                }
              break;
            case 58:
              Ye + te + re === 0 && (De = Oe);
              break;
            case 44:
              te + Qe + Ye + re === 0 && (tt = 1, $e += "\r");
              break;
            case 34:
            case 39:
              te === 0 && (Ye = Ye === P ? 0 : Ye === 0 ? P : Ye);
              break;
            case 91:
              Ye + te + Qe === 0 && re++;
              break;
            case 93:
              Ye + te + Qe === 0 && re--;
              break;
            case 41:
              Ye + te + re === 0 && Qe--;
              break;
            case 40:
              if (Ye + te + re === 0) {
                if (Se === 0)
                  switch (2 * ge + 3 * Me) {
                    case 533:
                      break;
                    default:
                      Se = 1;
                  }
                Qe++;
              }
              break;
            case 64:
              te + Qe + Ye + re + De + We === 0 && (We = 1);
              break;
            case 42:
            case 47:
              if (!(0 < Ye + re + Qe))
                switch (te) {
                  case 0:
                    switch (2 * P + 3 * $.charCodeAt(Oe + 1)) {
                      case 235:
                        te = 47;
                        break;
                      case 220:
                        He = Oe, te = 42;
                    }
                    break;
                  case 42:
                    P === 47 && ge === 42 && He + 2 !== Oe && ($.charCodeAt(He + 2) === 33 && (Xe += $.substring(He, Oe + 1)), $e = "", te = 0);
                }
          }
          te === 0 && (fe += $e);
      }
      Me = ge, ge = P, Oe++;
    }
    if (He = Xe.length, 0 < He) {
      if (tt = L, 0 < Ue && (yt = i(2, Xe, tt, le, y, w, He, ee, O, ee), yt !== void 0 && (Xe = yt).length === 0))
        return Vt + Xe + pt;
      if (Xe = tt.join(",") + "{" + Xe + "}", f * g !== 0) {
        switch (f !== 2 || d(Xe, 2) || (g = 0), g) {
          case 111:
            Xe = Xe.replace(E, ":-moz-$1") + Xe;
            break;
          case 112:
            Xe = Xe.replace(m, "::-webkit-input-$1") + Xe.replace(m, "::-moz-$1") + Xe.replace(m, ":-ms-input-$1") + Xe;
        }
        g = 0;
      }
    }
    return Vt + Xe + pt;
  }
  function t(le, L, $) {
    var ee = L.trim().split(Z);
    L = ee;
    var O = ee.length, re = le.length;
    switch (re) {
      case 0:
      case 1:
        var te = 0;
        for (le = re === 0 ? "" : le[0] + " "; te < O; ++te)
          L[te] = l(le, L[te], $).trim();
        break;
      default:
        var Qe = te = 0;
        for (L = []; te < O; ++te)
          for (var Ye = 0; Ye < re; ++Ye)
            L[Qe++] = l(le[Ye] + " ", ee[te], $).trim();
    }
    return L;
  }
  function l(le, L, $) {
    var ee = L.charCodeAt(0);
    switch (33 > ee && (ee = (L = L.trim()).charCodeAt(0)), ee) {
      case 38:
        return L.replace(W, "$1" + le.trim());
      case 58:
        return le.trim() + L.replace(W, "$1" + le.trim());
      default:
        if (0 < 1 * $ && 0 < L.indexOf("\f"))
          return L.replace(W, (le.charCodeAt(0) === 58 ? "" : "$1") + le.trim());
    }
    return le + L;
  }
  function a(le, L, $, ee) {
    var O = le + ";", re = 2 * L + 3 * $ + 4 * ee;
    if (re === 944) {
      le = O.indexOf(":", 9) + 1;
      var te = O.substring(le, O.length - 1).trim();
      return te = O.substring(0, le).trim() + te + ";", f === 1 || f === 2 && d(te, 1) ? "-webkit-" + te + te : te;
    }
    if (f === 0 || f === 2 && !d(O, 1))
      return O;
    switch (re) {
      case 1015:
        return O.charCodeAt(10) === 97 ? "-webkit-" + O + O : O;
      case 951:
        return O.charCodeAt(3) === 116 ? "-webkit-" + O + O : O;
      case 963:
        return O.charCodeAt(5) === 110 ? "-webkit-" + O + O : O;
      case 1009:
        if (O.charCodeAt(4) !== 100)
          break;
      case 969:
      case 942:
        return "-webkit-" + O + O;
      case 978:
        return "-webkit-" + O + "-moz-" + O + O;
      case 1019:
      case 983:
        return "-webkit-" + O + "-moz-" + O + "-ms-" + O + O;
      case 883:
        if (O.charCodeAt(8) === 45)
          return "-webkit-" + O + O;
        if (0 < O.indexOf("image-set(", 11))
          return O.replace(G, "$1-webkit-$2") + O;
        break;
      case 932:
        if (O.charCodeAt(4) === 45)
          switch (O.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + O.replace("-grow", "") + "-webkit-" + O + "-ms-" + O.replace("grow", "positive") + O;
            case 115:
              return "-webkit-" + O + "-ms-" + O.replace("shrink", "negative") + O;
            case 98:
              return "-webkit-" + O + "-ms-" + O.replace("basis", "preferred-size") + O;
          }
        return "-webkit-" + O + "-ms-" + O + O;
      case 964:
        return "-webkit-" + O + "-ms-flex-" + O + O;
      case 1023:
        if (O.charCodeAt(8) !== 99)
          break;
        return te = O.substring(O.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), "-webkit-box-pack" + te + "-webkit-" + O + "-ms-flex-pack" + te + O;
      case 1005:
        return R.test(O) ? O.replace(N, ":-webkit-") + O.replace(N, ":-moz-") + O : O;
      case 1e3:
        switch (te = O.substring(13).trim(), L = te.indexOf("-") + 1, te.charCodeAt(0) + te.charCodeAt(L)) {
          case 226:
            te = O.replace(u, "tb");
            break;
          case 232:
            te = O.replace(u, "tb-rl");
            break;
          case 220:
            te = O.replace(u, "lr");
            break;
          default:
            return O;
        }
        return "-webkit-" + O + "-ms-" + te + O;
      case 1017:
        if (O.indexOf("sticky", 9) === -1)
          break;
      case 975:
        switch (L = (O = le).length - 10, te = (O.charCodeAt(L) === 33 ? O.substring(0, L) : O).substring(le.indexOf(":", 7) + 1).trim(), re = te.charCodeAt(0) + (te.charCodeAt(7) | 0)) {
          case 203:
            if (111 > te.charCodeAt(8))
              break;
          case 115:
            O = O.replace(te, "-webkit-" + te) + ";" + O;
            break;
          case 207:
          case 102:
            O = O.replace(te, "-webkit-" + (102 < re ? "inline-" : "") + "box") + ";" + O.replace(te, "-webkit-" + te) + ";" + O.replace(te, "-ms-" + te + "box") + ";" + O;
        }
        return O + ";";
      case 938:
        if (O.charCodeAt(5) === 45)
          switch (O.charCodeAt(6)) {
            case 105:
              return te = O.replace("-items", ""), "-webkit-" + O + "-webkit-box-" + te + "-ms-flex-" + te + O;
            case 115:
              return "-webkit-" + O + "-ms-flex-item-" + O.replace(Q, "") + O;
            default:
              return "-webkit-" + O + "-ms-flex-line-pack" + O.replace("align-content", "").replace(Q, "") + O;
          }
        break;
      case 973:
      case 989:
        if (O.charCodeAt(3) !== 45 || O.charCodeAt(4) === 122)
          break;
      case 931:
      case 953:
        if (v.test(le) === !0)
          return (te = le.substring(le.indexOf(":") + 1)).charCodeAt(0) === 115 ? a(le.replace("stretch", "fill-available"), L, $, ee).replace(":fill-available", ":stretch") : O.replace(te, "-webkit-" + te) + O.replace(te, "-moz-" + te.replace("fill-", "")) + O;
        break;
      case 962:
        if (O = "-webkit-" + O + (O.charCodeAt(5) === 102 ? "-ms-" + O : "") + O, $ + ee === 211 && O.charCodeAt(13) === 105 && 0 < O.indexOf("transform", 10))
          return O.substring(0, O.indexOf(";", 27) + 1).replace(h, "$1-webkit-$2") + O;
    }
    return O;
  }
  function d(le, L) {
    var $ = le.indexOf(L === 1 ? ":" : "{"), ee = le.substring(0, L !== 3 ? $ : 10);
    return $ = le.substring($ + 1, le.length - 1), q(L !== 2 ? ee : ee.replace(S, "$1"), $, L);
  }
  function r(le, L) {
    var $ = a(L, L.charCodeAt(0), L.charCodeAt(1), L.charCodeAt(2));
    return $ !== L + ";" ? $.replace(k, " or ($1)").substring(4) : "(" + L + ")";
  }
  function i(le, L, $, ee, O, re, te, Qe, Ye, Se) {
    for (var P = 0, ge = L, Me; P < Ue; ++P)
      switch (Me = K[P].call(s, le, ge, $, ee, O, re, te, Qe, Ye, Se)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;
        default:
          ge = Me;
      }
    if (ge !== L)
      return ge;
  }
  function c(le) {
    switch (le) {
      case void 0:
      case null:
        Ue = K.length = 0;
        break;
      default:
        if (typeof le == "function")
          K[Ue++] = le;
        else if (typeof le == "object")
          for (var L = 0, $ = le.length; L < $; ++L)
            c(le[L]);
        else
          ae = !!le | 0;
    }
    return c;
  }
  function V(le) {
    return le = le.prefix, le !== void 0 && (q = null, le ? typeof le != "function" ? f = 1 : (f = 2, q = le) : f = 0), V;
  }
  function s(le, L) {
    var $ = le;
    if (33 > $.charCodeAt(0) && ($ = $.trim()), se = $, $ = [se], 0 < Ue) {
      var ee = i(-1, L, $, $, y, w, 0, 0, 0, 0);
      ee !== void 0 && typeof ee == "string" && (L = ee);
    }
    var O = n(I, $, L, 0, 0);
    return 0 < Ue && (ee = i(-2, O, $, $, y, w, O.length, 0, 0, 0), ee !== void 0 && (O = ee)), se = "", g = 0, w = y = 1, O;
  }
  var o = /^\0+/g, U = /[\0\r\f]/g, N = /: */g, R = /zoo|gra/, h = /([,: ])(transform)/g, Z = /,\r+?/g, W = /([\t\r\n ])*\f?&/g, F = /@(k\w+)\s*(\S*)\s*/, m = /::(place)/g, E = /:(read-only)/g, u = /[svh]\w+-[tblr]{2}/, b = /\(\s*(.*)\s*\)/g, k = /([\s\S]*?);/g, Q = /-self|flex-/g, S = /[^]*?(:[rp][el]a[\w-]+)[^]*/, v = /stretch|:\s*\w+\-(?:conte|avail)/, G = /([^-])(image-set\()/, w = 1, y = 1, g = 0, f = 1, I = [], K = [], Ue = 0, q = null, ae = 0, se = "";
  return s.use = c, s.set = V, e !== void 0 && V(e), s;
}
var rz = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function iz(e) {
  var n = /* @__PURE__ */ Object.create(null);
  return function(t) {
    return n[t] === void 0 && (n[t] = e(t)), n[t];
  };
}
var Vz = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Um = /* @__PURE__ */ iz(
  function(e) {
    return Vz.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), uT = { exports: {} }, Yn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Nm;
function cz() {
  if (Nm)
    return Yn;
  Nm = 1;
  var e = typeof Symbol == "function" && Symbol.for, n = e ? Symbol.for("react.element") : 60103, t = e ? Symbol.for("react.portal") : 60106, l = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, d = e ? Symbol.for("react.profiler") : 60114, r = e ? Symbol.for("react.provider") : 60109, i = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, V = e ? Symbol.for("react.concurrent_mode") : 60111, s = e ? Symbol.for("react.forward_ref") : 60112, o = e ? Symbol.for("react.suspense") : 60113, U = e ? Symbol.for("react.suspense_list") : 60120, N = e ? Symbol.for("react.memo") : 60115, R = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, Z = e ? Symbol.for("react.fundamental") : 60117, W = e ? Symbol.for("react.responder") : 60118, F = e ? Symbol.for("react.scope") : 60119;
  function m(u) {
    if (typeof u == "object" && u !== null) {
      var b = u.$$typeof;
      switch (b) {
        case n:
          switch (u = u.type, u) {
            case c:
            case V:
            case l:
            case d:
            case a:
            case o:
              return u;
            default:
              switch (u = u && u.$$typeof, u) {
                case i:
                case s:
                case R:
                case N:
                case r:
                  return u;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  function E(u) {
    return m(u) === V;
  }
  return Yn.AsyncMode = c, Yn.ConcurrentMode = V, Yn.ContextConsumer = i, Yn.ContextProvider = r, Yn.Element = n, Yn.ForwardRef = s, Yn.Fragment = l, Yn.Lazy = R, Yn.Memo = N, Yn.Portal = t, Yn.Profiler = d, Yn.StrictMode = a, Yn.Suspense = o, Yn.isAsyncMode = function(u) {
    return E(u) || m(u) === c;
  }, Yn.isConcurrentMode = E, Yn.isContextConsumer = function(u) {
    return m(u) === i;
  }, Yn.isContextProvider = function(u) {
    return m(u) === r;
  }, Yn.isElement = function(u) {
    return typeof u == "object" && u !== null && u.$$typeof === n;
  }, Yn.isForwardRef = function(u) {
    return m(u) === s;
  }, Yn.isFragment = function(u) {
    return m(u) === l;
  }, Yn.isLazy = function(u) {
    return m(u) === R;
  }, Yn.isMemo = function(u) {
    return m(u) === N;
  }, Yn.isPortal = function(u) {
    return m(u) === t;
  }, Yn.isProfiler = function(u) {
    return m(u) === d;
  }, Yn.isStrictMode = function(u) {
    return m(u) === a;
  }, Yn.isSuspense = function(u) {
    return m(u) === o;
  }, Yn.isValidElementType = function(u) {
    return typeof u == "string" || typeof u == "function" || u === l || u === V || u === d || u === a || u === o || u === U || typeof u == "object" && u !== null && (u.$$typeof === R || u.$$typeof === N || u.$$typeof === r || u.$$typeof === i || u.$$typeof === s || u.$$typeof === Z || u.$$typeof === W || u.$$typeof === F || u.$$typeof === h);
  }, Yn.typeOf = m, Yn;
}
var Qn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rm;
function sz() {
  return Rm || (Rm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, n = e ? Symbol.for("react.element") : 60103, t = e ? Symbol.for("react.portal") : 60106, l = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, d = e ? Symbol.for("react.profiler") : 60114, r = e ? Symbol.for("react.provider") : 60109, i = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, V = e ? Symbol.for("react.concurrent_mode") : 60111, s = e ? Symbol.for("react.forward_ref") : 60112, o = e ? Symbol.for("react.suspense") : 60113, U = e ? Symbol.for("react.suspense_list") : 60120, N = e ? Symbol.for("react.memo") : 60115, R = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, Z = e ? Symbol.for("react.fundamental") : 60117, W = e ? Symbol.for("react.responder") : 60118, F = e ? Symbol.for("react.scope") : 60119;
    function m(P) {
      return typeof P == "string" || typeof P == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      P === l || P === V || P === d || P === a || P === o || P === U || typeof P == "object" && P !== null && (P.$$typeof === R || P.$$typeof === N || P.$$typeof === r || P.$$typeof === i || P.$$typeof === s || P.$$typeof === Z || P.$$typeof === W || P.$$typeof === F || P.$$typeof === h);
    }
    function E(P) {
      if (typeof P == "object" && P !== null) {
        var ge = P.$$typeof;
        switch (ge) {
          case n:
            var Me = P.type;
            switch (Me) {
              case c:
              case V:
              case l:
              case d:
              case a:
              case o:
                return Me;
              default:
                var We = Me && Me.$$typeof;
                switch (We) {
                  case i:
                  case s:
                  case R:
                  case N:
                  case r:
                    return We;
                  default:
                    return ge;
                }
            }
          case t:
            return ge;
        }
      }
    }
    var u = c, b = V, k = i, Q = r, S = n, v = s, G = l, w = R, y = N, g = t, f = d, I = a, K = o, Ue = !1;
    function q(P) {
      return Ue || (Ue = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), ae(P) || E(P) === c;
    }
    function ae(P) {
      return E(P) === V;
    }
    function se(P) {
      return E(P) === i;
    }
    function le(P) {
      return E(P) === r;
    }
    function L(P) {
      return typeof P == "object" && P !== null && P.$$typeof === n;
    }
    function $(P) {
      return E(P) === s;
    }
    function ee(P) {
      return E(P) === l;
    }
    function O(P) {
      return E(P) === R;
    }
    function re(P) {
      return E(P) === N;
    }
    function te(P) {
      return E(P) === t;
    }
    function Qe(P) {
      return E(P) === d;
    }
    function Ye(P) {
      return E(P) === a;
    }
    function Se(P) {
      return E(P) === o;
    }
    Qn.AsyncMode = u, Qn.ConcurrentMode = b, Qn.ContextConsumer = k, Qn.ContextProvider = Q, Qn.Element = S, Qn.ForwardRef = v, Qn.Fragment = G, Qn.Lazy = w, Qn.Memo = y, Qn.Portal = g, Qn.Profiler = f, Qn.StrictMode = I, Qn.Suspense = K, Qn.isAsyncMode = q, Qn.isConcurrentMode = ae, Qn.isContextConsumer = se, Qn.isContextProvider = le, Qn.isElement = L, Qn.isForwardRef = $, Qn.isFragment = ee, Qn.isLazy = O, Qn.isMemo = re, Qn.isPortal = te, Qn.isProfiler = Qe, Qn.isStrictMode = Ye, Qn.isSuspense = Se, Qn.isValidElementType = m, Qn.typeOf = E;
  }()), Qn;
}
process.env.NODE_ENV === "production" ? uT.exports = cz() : uT.exports = sz();
var oz = uT.exports, NW = oz, Uz = {
  childContextTypes: !0,
  contextType: !0,
  contextTypes: !0,
  defaultProps: !0,
  displayName: !0,
  getDefaultProps: !0,
  getDerivedStateFromError: !0,
  getDerivedStateFromProps: !0,
  mixins: !0,
  propTypes: !0,
  type: !0
}, Nz = {
  name: !0,
  length: !0,
  prototype: !0,
  caller: !0,
  callee: !0,
  arguments: !0,
  arity: !0
}, Rz = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, lk = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, RW = {};
RW[NW.ForwardRef] = Rz;
RW[NW.Memo] = lk;
function hm(e) {
  return NW.isMemo(e) ? lk : RW[e.$$typeof] || Uz;
}
var hz = Object.defineProperty, Zz = Object.getOwnPropertyNames, Zm = Object.getOwnPropertySymbols, Tz = Object.getOwnPropertyDescriptor, Fz = Object.getPrototypeOf, Tm = Object.prototype;
function ak(e, n, t) {
  if (typeof n != "string") {
    if (Tm) {
      var l = Fz(n);
      l && l !== Tm && ak(e, l, t);
    }
    var a = Zz(n);
    Zm && (a = a.concat(Zm(n)));
    for (var d = hm(e), r = hm(n), i = 0; i < a.length; ++i) {
      var c = a[i];
      if (!Nz[c] && !(t && t[c]) && !(r && r[c]) && !(d && d[c])) {
        var V = Tz(n, c);
        try {
          hz(e, c, V);
        } catch {
        }
      }
    }
  }
  return e;
}
var Wz = ak;
const mz = /* @__PURE__ */ nk(Wz);
function Wr() {
  return (Wr = Object.assign || function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }).apply(this, arguments);
}
var Fm = function(e, n) {
  for (var t = [e[0]], l = 0, a = n.length; l < a; l += 1)
    t.push(n[l], e[l + 1]);
  return t;
}, pT = function(e) {
  return e !== null && typeof e == "object" && (e.toString ? e.toString() : Object.prototype.toString.call(e)) === "[object Object]" && !UW.typeOf(e);
}, IN = Object.freeze([]), si = Object.freeze({});
function Ro(e) {
  return typeof e == "function";
}
function MT(e) {
  return process.env.NODE_ENV !== "production" && typeof e == "string" && e || e.displayName || e.name || "Component";
}
function hW(e) {
  return e && typeof e.styledComponentId == "string";
}
var uc = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled", ZW = typeof window < "u" && "HTMLElement" in window, uz = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" ? process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY : process.env.NODE_ENV !== "production")), pz = process.env.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
` } : {};
function Mz() {
  for (var e = arguments.length <= 0 ? void 0 : arguments[0], n = [], t = 1, l = arguments.length; t < l; t += 1)
    n.push(t < 0 || arguments.length <= t ? void 0 : arguments[t]);
  return n.forEach(function(a) {
    e = e.replace(/%[a-z]/, a);
  }), e;
}
function fc(e) {
  for (var n = arguments.length, t = new Array(n > 1 ? n - 1 : 0), l = 1; l < n; l++)
    t[l - 1] = arguments[l];
  throw process.env.NODE_ENV === "production" ? new Error("An error occurred. See https://git.io/JUIaE#" + e + " for more information." + (t.length > 0 ? " Args: " + t.join(", ") : "")) : new Error(Mz.apply(void 0, [pz[e]].concat(t)).trim());
}
var Ez = function() {
  function e(t) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t;
  }
  var n = e.prototype;
  return n.indexOfGroup = function(t) {
    for (var l = 0, a = 0; a < t; a++)
      l += this.groupSizes[a];
    return l;
  }, n.insertRules = function(t, l) {
    if (t >= this.groupSizes.length) {
      for (var a = this.groupSizes, d = a.length, r = d; t >= r; )
        (r <<= 1) < 0 && fc(16, "" + t);
      this.groupSizes = new Uint32Array(r), this.groupSizes.set(a), this.length = r;
      for (var i = d; i < r; i++)
        this.groupSizes[i] = 0;
    }
    for (var c = this.indexOfGroup(t + 1), V = 0, s = l.length; V < s; V++)
      this.tag.insertRule(c, l[V]) && (this.groupSizes[t]++, c++);
  }, n.clearGroup = function(t) {
    if (t < this.length) {
      var l = this.groupSizes[t], a = this.indexOfGroup(t), d = a + l;
      this.groupSizes[t] = 0;
      for (var r = a; r < d; r++)
        this.tag.deleteRule(a);
    }
  }, n.getGroup = function(t) {
    var l = "";
    if (t >= this.length || this.groupSizes[t] === 0)
      return l;
    for (var a = this.groupSizes[t], d = this.indexOfGroup(t), r = d + a, i = d; i < r; i++)
      l += this.tag.getRule(i) + `/*!sc*/
`;
    return l;
  }, e;
}(), mN = /* @__PURE__ */ new Map(), LN = /* @__PURE__ */ new Map(), xs = 1, zU = function(e) {
  if (mN.has(e))
    return mN.get(e);
  for (; LN.has(xs); )
    xs++;
  var n = xs++;
  return process.env.NODE_ENV !== "production" && ((0 | n) < 0 || n > 1 << 30) && fc(16, "" + n), mN.set(e, n), LN.set(n, e), n;
}, Sz = function(e) {
  return LN.get(e);
}, kz = function(e, n) {
  n >= xs && (xs = n + 1), mN.set(e, n), LN.set(n, e);
}, bz = "style[" + uc + '][data-styled-version="5.3.11"]', Yz = new RegExp("^" + uc + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), Qz = function(e, n, t) {
  for (var l, a = t.split(","), d = 0, r = a.length; d < r; d++)
    (l = a[d]) && e.registerName(n, l);
}, Jz = function(e, n) {
  for (var t = (n.textContent || "").split(`/*!sc*/
`), l = [], a = 0, d = t.length; a < d; a++) {
    var r = t[a].trim();
    if (r) {
      var i = r.match(Yz);
      if (i) {
        var c = 0 | parseInt(i[1], 10), V = i[2];
        c !== 0 && (kz(V, c), Qz(e, V, i[3]), e.getTag().insertRules(c, l)), l.length = 0;
      } else
        l.push(r);
    }
  }
}, vz = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}, dk = function(e) {
  var n = document.head, t = e || n, l = document.createElement("style"), a = function(i) {
    for (var c = i.childNodes, V = c.length; V >= 0; V--) {
      var s = c[V];
      if (s && s.nodeType === 1 && s.hasAttribute(uc))
        return s;
    }
  }(t), d = a !== void 0 ? a.nextSibling : null;
  l.setAttribute(uc, "active"), l.setAttribute("data-styled-version", "5.3.11");
  var r = vz();
  return r && l.setAttribute("nonce", r), t.insertBefore(l, d), l;
}, zz = function() {
  function e(t) {
    var l = this.element = dk(t);
    l.appendChild(document.createTextNode("")), this.sheet = function(a) {
      if (a.sheet)
        return a.sheet;
      for (var d = document.styleSheets, r = 0, i = d.length; r < i; r++) {
        var c = d[r];
        if (c.ownerNode === a)
          return c;
      }
      fc(17);
    }(l), this.length = 0;
  }
  var n = e.prototype;
  return n.insertRule = function(t, l) {
    try {
      return this.sheet.insertRule(l, t), this.length++, !0;
    } catch {
      return !1;
    }
  }, n.deleteRule = function(t) {
    this.sheet.deleteRule(t), this.length--;
  }, n.getRule = function(t) {
    var l = this.sheet.cssRules[t];
    return l !== void 0 && typeof l.cssText == "string" ? l.cssText : "";
  }, e;
}(), xz = function() {
  function e(t) {
    var l = this.element = dk(t);
    this.nodes = l.childNodes, this.length = 0;
  }
  var n = e.prototype;
  return n.insertRule = function(t, l) {
    if (t <= this.length && t >= 0) {
      var a = document.createTextNode(l), d = this.nodes[t];
      return this.element.insertBefore(a, d || null), this.length++, !0;
    }
    return !1;
  }, n.deleteRule = function(t) {
    this.element.removeChild(this.nodes[t]), this.length--;
  }, n.getRule = function(t) {
    return t < this.length ? this.nodes[t].textContent : "";
  }, e;
}(), Gz = function() {
  function e(t) {
    this.rules = [], this.length = 0;
  }
  var n = e.prototype;
  return n.insertRule = function(t, l) {
    return t <= this.length && (this.rules.splice(t, 0, l), this.length++, !0);
  }, n.deleteRule = function(t) {
    this.rules.splice(t, 1), this.length--;
  }, n.getRule = function(t) {
    return t < this.length ? this.rules[t] : "";
  }, e;
}(), Wm = ZW, yz = { isServer: !ZW, useCSSOMInjection: !uz }, rk = function() {
  function e(t, l, a) {
    t === void 0 && (t = si), l === void 0 && (l = {}), this.options = Wr({}, yz, {}, t), this.gs = l, this.names = new Map(a), this.server = !!t.isServer, !this.server && ZW && Wm && (Wm = !1, function(d) {
      for (var r = document.querySelectorAll(bz), i = 0, c = r.length; i < c; i++) {
        var V = r[i];
        V && V.getAttribute(uc) !== "active" && (Jz(d, V), V.parentNode && V.parentNode.removeChild(V));
      }
    }(this));
  }
  e.registerId = function(t) {
    return zU(t);
  };
  var n = e.prototype;
  return n.reconstructWithOptions = function(t, l) {
    return l === void 0 && (l = !0), new e(Wr({}, this.options, {}, t), this.gs, l && this.names || void 0);
  }, n.allocateGSInstance = function(t) {
    return this.gs[t] = (this.gs[t] || 0) + 1;
  }, n.getTag = function() {
    return this.tag || (this.tag = (a = (l = this.options).isServer, d = l.useCSSOMInjection, r = l.target, t = a ? new Gz(r) : d ? new zz(r) : new xz(r), new Ez(t)));
    var t, l, a, d, r;
  }, n.hasNameForId = function(t, l) {
    return this.names.has(t) && this.names.get(t).has(l);
  }, n.registerName = function(t, l) {
    if (zU(t), this.names.has(t))
      this.names.get(t).add(l);
    else {
      var a = /* @__PURE__ */ new Set();
      a.add(l), this.names.set(t, a);
    }
  }, n.insertRules = function(t, l, a) {
    this.registerName(t, l), this.getTag().insertRules(zU(t), a);
  }, n.clearNames = function(t) {
    this.names.has(t) && this.names.get(t).clear();
  }, n.clearRules = function(t) {
    this.getTag().clearGroup(zU(t)), this.clearNames(t);
  }, n.clearTag = function() {
    this.tag = void 0;
  }, n.toString = function() {
    return function(t) {
      for (var l = t.getTag(), a = l.length, d = "", r = 0; r < a; r++) {
        var i = Sz(r);
        if (i !== void 0) {
          var c = t.names.get(i), V = l.getGroup(r);
          if (c && V && c.size) {
            var s = uc + ".g" + r + '[id="' + i + '"]', o = "";
            c !== void 0 && c.forEach(function(U) {
              U.length > 0 && (o += U + ",");
            }), d += "" + V + s + '{content:"' + o + `"}/*!sc*/
`;
          }
        }
      }
      return d;
    }(this);
  }, e;
}(), Bz = /(a)(d)/gi, mm = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function ET(e) {
  var n, t = "";
  for (n = Math.abs(e); n > 52; n = n / 52 | 0)
    t = mm(n % 52) + t;
  return (mm(n % 52) + t).replace(Bz, "$1-$2");
}
var gi = function(e, n) {
  for (var t = n.length; t; )
    e = 33 * e ^ n.charCodeAt(--t);
  return e;
}, ik = function(e) {
  return gi(5381, e);
};
function Dz(e) {
  for (var n = 0; n < e.length; n += 1) {
    var t = e[n];
    if (Ro(t) && !hW(t))
      return !1;
  }
  return !0;
}
var Xz = ik("5.3.11"), Oz = function() {
  function e(n, t, l) {
    this.rules = n, this.staticRulesId = "", this.isStatic = process.env.NODE_ENV === "production" && (l === void 0 || l.isStatic) && Dz(n), this.componentId = t, this.baseHash = gi(Xz, t), this.baseStyle = l, rk.registerId(t);
  }
  return e.prototype.generateAndInjectStyles = function(n, t, l) {
    var a = this.componentId, d = [];
    if (this.baseStyle && d.push(this.baseStyle.generateAndInjectStyles(n, t, l)), this.isStatic && !l.hash)
      if (this.staticRulesId && t.hasNameForId(a, this.staticRulesId))
        d.push(this.staticRulesId);
      else {
        var r = pc(this.rules, n, t, l).join(""), i = ET(gi(this.baseHash, r) >>> 0);
        if (!t.hasNameForId(a, i)) {
          var c = l(r, "." + i, void 0, a);
          t.insertRules(a, i, c);
        }
        d.push(i), this.staticRulesId = i;
      }
    else {
      for (var V = this.rules.length, s = gi(this.baseHash, l.hash), o = "", U = 0; U < V; U++) {
        var N = this.rules[U];
        if (typeof N == "string")
          o += N, process.env.NODE_ENV !== "production" && (s = gi(s, N + U));
        else if (N) {
          var R = pc(N, n, t, l), h = Array.isArray(R) ? R.join("") : R;
          s = gi(s, h + U), o += h;
        }
      }
      if (o) {
        var Z = ET(s >>> 0);
        if (!t.hasNameForId(a, Z)) {
          var W = l(o, "." + Z, void 0, a);
          t.insertRules(a, Z, W);
        }
        d.push(Z);
      }
    }
    return d.join(" ");
  }, e;
}(), jz = /^\s*\/\/.*$/gm, Hz = [":", "[", ".", "#"];
function fz(e) {
  var n, t, l, a, d = e === void 0 ? si : e, r = d.options, i = r === void 0 ? si : r, c = d.plugins, V = c === void 0 ? IN : c, s = new dz(i), o = [], U = function(h) {
    function Z(W) {
      if (W)
        try {
          h(W + "}");
        } catch {
        }
    }
    return function(W, F, m, E, u, b, k, Q, S, v) {
      switch (W) {
        case 1:
          if (S === 0 && F.charCodeAt(0) === 64)
            return h(F + ";"), "";
          break;
        case 2:
          if (Q === 0)
            return F + "/*|*/";
          break;
        case 3:
          switch (Q) {
            case 102:
            case 112:
              return h(m[0] + F), "";
            default:
              return F + (v === 0 ? "/*|*/" : "");
          }
        case -2:
          F.split("/*|*/}").forEach(Z);
      }
    };
  }(function(h) {
    o.push(h);
  }), N = function(h, Z, W) {
    return Z === 0 && Hz.indexOf(W[t.length]) !== -1 || W.match(a) ? h : "." + n;
  };
  function R(h, Z, W, F) {
    F === void 0 && (F = "&");
    var m = h.replace(jz, ""), E = Z && W ? W + " " + Z + " { " + m + " }" : m;
    return n = F, t = Z, l = new RegExp("\\" + t + "\\b", "g"), a = new RegExp("(\\" + t + "\\b){2,}"), s(W || !Z ? "" : Z, E);
  }
  return s.use([].concat(V, [function(h, Z, W) {
    h === 2 && W.length && W[0].lastIndexOf(t) > 0 && (W[0] = W[0].replace(l, N));
  }, U, function(h) {
    if (h === -2) {
      var Z = o;
      return o = [], Z;
    }
  }])), R.hash = V.length ? V.reduce(function(h, Z) {
    return Z.name || fc(15), gi(h, Z.name);
  }, 5381).toString() : "", R;
}
var Vk = T.createContext();
Vk.Consumer;
var ck = T.createContext(), wz = (ck.Consumer, new rk()), ST = fz();
function gz() {
  return Gt(Vk) || wz;
}
function Iz() {
  return Gt(ck) || ST;
}
var sk = function() {
  function e(n, t) {
    var l = this;
    this.inject = function(a, d) {
      d === void 0 && (d = ST);
      var r = l.name + d.hash;
      a.hasNameForId(l.id, r) || a.insertRules(l.id, r, d(l.rules, r, "@keyframes"));
    }, this.toString = function() {
      return fc(12, String(l.name));
    }, this.name = n, this.id = "sc-keyframes-" + n, this.rules = t;
  }
  return e.prototype.getName = function(n) {
    return n === void 0 && (n = ST), this.name + n.hash;
  }, e;
}(), Lz = /([A-Z])/, Cz = /([A-Z])/g, Kz = /^ms-/, _z = function(e) {
  return "-" + e.toLowerCase();
};
function um(e) {
  return Lz.test(e) ? e.replace(Cz, _z).replace(Kz, "-ms-") : e;
}
var pm = function(e) {
  return e == null || e === !1 || e === "";
};
function pc(e, n, t, l) {
  if (Array.isArray(e)) {
    for (var a, d = [], r = 0, i = e.length; r < i; r += 1)
      (a = pc(e[r], n, t, l)) !== "" && (Array.isArray(a) ? d.push.apply(d, a) : d.push(a));
    return d;
  }
  if (pm(e))
    return "";
  if (hW(e))
    return "." + e.styledComponentId;
  if (Ro(e)) {
    if (typeof (V = e) != "function" || V.prototype && V.prototype.isReactComponent || !n)
      return e;
    var c = e(n);
    return process.env.NODE_ENV !== "production" && UW.isElement(c) && console.warn(MT(e) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), pc(c, n, t, l);
  }
  var V;
  return e instanceof sk ? t ? (e.inject(t, l), e.getName(l)) : e : pT(e) ? function s(o, U) {
    var N, R, h = [];
    for (var Z in o)
      o.hasOwnProperty(Z) && !pm(o[Z]) && (Array.isArray(o[Z]) && o[Z].isCss || Ro(o[Z]) ? h.push(um(Z) + ":", o[Z], ";") : pT(o[Z]) ? h.push.apply(h, s(o[Z], Z)) : h.push(um(Z) + ": " + (N = Z, (R = o[Z]) == null || typeof R == "boolean" || R === "" ? "" : typeof R != "number" || R === 0 || N in rz || N.startsWith("--") ? String(R).trim() : R + "px") + ";"));
    return U ? [U + " {"].concat(h, ["}"]) : h;
  }(e) : e.toString();
}
var Mm = function(e) {
  return Array.isArray(e) && (e.isCss = !0), e;
};
function aa(e) {
  for (var n = arguments.length, t = new Array(n > 1 ? n - 1 : 0), l = 1; l < n; l++)
    t[l - 1] = arguments[l];
  return Ro(e) || pT(e) ? Mm(pc(Fm(IN, [e].concat(t)))) : t.length === 0 && e.length === 1 && typeof e[0] == "string" ? e : Mm(pc(Fm(e, t)));
}
var Em = /invalid hook call/i, xU = /* @__PURE__ */ new Set(), Pz = function(e, n) {
  if (process.env.NODE_ENV !== "production") {
    var t = "The component " + e + (n ? ' with the id of "' + n + '"' : "") + ` has been created dynamically.
You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, l = console.error;
    try {
      var a = !0;
      console.error = function(d) {
        if (Em.test(d))
          a = !1, xU.delete(t);
        else {
          for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), c = 1; c < r; c++)
            i[c - 1] = arguments[c];
          l.apply(void 0, [d].concat(i));
        }
      }, Wt(), a && !xU.has(t) && (console.warn(t), xU.add(t));
    } catch (d) {
      Em.test(d.message) && xU.delete(t);
    } finally {
      console.error = l;
    }
  }
}, Az = function(e, n, t) {
  return t === void 0 && (t = si), e.theme !== t.theme && e.theme || n || t.theme;
}, qz = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, $z = /(^-|-$)/g;
function Kh(e) {
  return e.replace(qz, "-").replace($z, "");
}
var ok = function(e) {
  return ET(ik(e) >>> 0);
};
function GU(e) {
  return typeof e == "string" && (process.env.NODE_ENV === "production" || e.charAt(0) === e.charAt(0).toLowerCase());
}
var kT = function(e) {
  return typeof e == "function" || typeof e == "object" && e !== null && !Array.isArray(e);
}, ex = function(e) {
  return e !== "__proto__" && e !== "constructor" && e !== "prototype";
};
function tx(e, n, t) {
  var l = e[t];
  kT(n) && kT(l) ? Uk(l, n) : e[t] = n;
}
function Uk(e) {
  for (var n = arguments.length, t = new Array(n > 1 ? n - 1 : 0), l = 1; l < n; l++)
    t[l - 1] = arguments[l];
  for (var a = 0, d = t; a < d.length; a++) {
    var r = d[a];
    if (kT(r))
      for (var i in r)
        ex(i) && tx(e, r[i], i);
  }
  return e;
}
var Nk = T.createContext();
Nk.Consumer;
var _h = {};
function Rk(e, n, t) {
  var l = hW(e), a = !GU(e), d = n.attrs, r = d === void 0 ? IN : d, i = n.componentId, c = i === void 0 ? function(F, m) {
    var E = typeof F != "string" ? "sc" : Kh(F);
    _h[E] = (_h[E] || 0) + 1;
    var u = E + "-" + ok("5.3.11" + E + _h[E]);
    return m ? m + "-" + u : u;
  }(n.displayName, n.parentComponentId) : i, V = n.displayName, s = V === void 0 ? function(F) {
    return GU(F) ? "styled." + F : "Styled(" + MT(F) + ")";
  }(e) : V, o = n.displayName && n.componentId ? Kh(n.displayName) + "-" + n.componentId : n.componentId || c, U = l && e.attrs ? Array.prototype.concat(e.attrs, r).filter(Boolean) : r, N = n.shouldForwardProp;
  l && e.shouldForwardProp && (N = n.shouldForwardProp ? function(F, m, E) {
    return e.shouldForwardProp(F, m, E) && n.shouldForwardProp(F, m, E);
  } : e.shouldForwardProp);
  var R, h = new Oz(t, o, l ? e.componentStyle : void 0), Z = h.isStatic && r.length === 0, W = function(F, m) {
    return function(E, u, b, k) {
      var Q = E.attrs, S = E.componentStyle, v = E.defaultProps, G = E.foldedComponentIds, w = E.shouldForwardProp, y = E.styledComponentId, g = E.target, f = function(ee, O, re) {
        ee === void 0 && (ee = si);
        var te = Wr({}, O, { theme: ee }), Qe = {};
        return re.forEach(function(Ye) {
          var Se, P, ge, Me = Ye;
          for (Se in Ro(Me) && (Me = Me(te)), Me)
            te[Se] = Qe[Se] = Se === "className" ? (P = Qe[Se], ge = Me[Se], P && ge ? P + " " + ge : P || ge) : Me[Se];
        }), [te, Qe];
      }(Az(u, Gt(Nk), v) || si, u, Q), I = f[0], K = f[1], Ue = function(ee, O, re, te) {
        var Qe = gz(), Ye = Iz(), Se = O ? ee.generateAndInjectStyles(si, Qe, Ye) : ee.generateAndInjectStyles(re, Qe, Ye);
        return process.env.NODE_ENV !== "production" && !O && te && te(Se), Se;
      }(S, k, I, process.env.NODE_ENV !== "production" ? E.warnTooManyClasses : void 0), q = b, ae = K.$as || u.$as || K.as || u.as || g, se = GU(ae), le = K !== u ? Wr({}, u, {}, K) : u, L = {};
      for (var $ in le)
        $[0] !== "$" && $ !== "as" && ($ === "forwardedAs" ? L.as = le[$] : (w ? w($, Um, ae) : !se || Um($)) && (L[$] = le[$]));
      return u.style && K.style !== u.style && (L.style = Wr({}, u.style, {}, K.style)), L.className = Array.prototype.concat(G, y, Ue !== y ? Ue : null, u.className, K.className).filter(Boolean).join(" "), L.ref = q, na(ae, L);
    }(R, F, m, Z);
  };
  return W.displayName = s, (R = T.forwardRef(W)).attrs = U, R.componentStyle = h, R.displayName = s, R.shouldForwardProp = N, R.foldedComponentIds = l ? Array.prototype.concat(e.foldedComponentIds, e.styledComponentId) : IN, R.styledComponentId = o, R.target = l ? e.target : e, R.withComponent = function(F) {
    var m = n.componentId, E = function(b, k) {
      if (b == null)
        return {};
      var Q, S, v = {}, G = Object.keys(b);
      for (S = 0; S < G.length; S++)
        Q = G[S], k.indexOf(Q) >= 0 || (v[Q] = b[Q]);
      return v;
    }(n, ["componentId"]), u = m && m + "-" + (GU(F) ? F : Kh(MT(F)));
    return Rk(F, Wr({}, E, { attrs: U, componentId: u }), t);
  }, Object.defineProperty(R, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(F) {
    this._foldedDefaultProps = l ? Uk({}, e.defaultProps, F) : F;
  } }), process.env.NODE_ENV !== "production" && (Pz(s, o), R.warnTooManyClasses = function(F, m) {
    var E = {}, u = !1;
    return function(b) {
      if (!u && (E[b] = !0, Object.keys(E).length >= 200)) {
        var k = m ? ' with the id of "' + m + '"' : "";
        console.warn("Over 200 classes were generated for component " + F + k + `.
Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), u = !0, E = {};
      }
    };
  }(s, o)), Object.defineProperty(R, "toString", { value: function() {
    return "." + R.styledComponentId;
  } }), a && mz(R, e, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0, withComponent: !0 }), R;
}
var bT = function(e) {
  return function n(t, l, a) {
    if (a === void 0 && (a = si), !UW.isValidElementType(l))
      return fc(1, String(l));
    var d = function() {
      return t(l, a, aa.apply(void 0, arguments));
    };
    return d.withConfig = function(r) {
      return n(t, l, Wr({}, a, {}, r));
    }, d.attrs = function(r) {
      return n(t, l, Wr({}, a, { attrs: Array.prototype.concat(a.attrs, r).filter(Boolean) }));
    }, d;
  }(Rk, e);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e) {
  bT[e] = bT(e);
});
function hk(e) {
  process.env.NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  for (var n = arguments.length, t = new Array(n > 1 ? n - 1 : 0), l = 1; l < n; l++)
    t[l - 1] = arguments[l];
  var a = aa.apply(void 0, [e].concat(t)).join(""), d = ok(a);
  return new sk(d, a);
}
process.env.NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`), process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && typeof window < "u" && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, window["__styled-components-init__"] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window["__styled-components-init__"] += 1);
const A = bT;
var YT = function(e, n) {
  return YT = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, l) {
    t.__proto__ = l;
  } || function(t, l) {
    for (var a in l)
      Object.prototype.hasOwnProperty.call(l, a) && (t[a] = l[a]);
  }, YT(e, n);
};
function nx(e, n) {
  if (typeof n != "function" && n !== null)
    throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
  YT(e, n);
  function t() {
    this.constructor = e;
  }
  e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
}
var ce = function() {
  return ce = Object.assign || function(n) {
    for (var t, l = 1, a = arguments.length; l < a; l++) {
      t = arguments[l];
      for (var d in t)
        Object.prototype.hasOwnProperty.call(t, d) && (n[d] = t[d]);
    }
    return n;
  }, ce.apply(this, arguments);
};
function ol(e, n, t, l) {
  function a(d) {
    return d instanceof t ? d : new t(function(r) {
      r(d);
    });
  }
  return new (t || (t = Promise))(function(d, r) {
    function i(s) {
      try {
        V(l.next(s));
      } catch (o) {
        r(o);
      }
    }
    function c(s) {
      try {
        V(l.throw(s));
      } catch (o) {
        r(o);
      }
    }
    function V(s) {
      s.done ? d(s.value) : a(s.value).then(i, c);
    }
    V((l = l.apply(e, n || [])).next());
  });
}
function Ul(e, n) {
  var t = { label: 0, sent: function() {
    if (d[0] & 1)
      throw d[1];
    return d[1];
  }, trys: [], ops: [] }, l, a, d, r;
  return r = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (r[Symbol.iterator] = function() {
    return this;
  }), r;
  function i(V) {
    return function(s) {
      return c([V, s]);
    };
  }
  function c(V) {
    if (l)
      throw new TypeError("Generator is already executing.");
    for (; r && (r = 0, V[0] && (t = 0)), t; )
      try {
        if (l = 1, a && (d = V[0] & 2 ? a.return : V[0] ? a.throw || ((d = a.return) && d.call(a), 0) : a.next) && !(d = d.call(a, V[1])).done)
          return d;
        switch (a = 0, d && (V = [V[0] & 2, d.value]), V[0]) {
          case 0:
          case 1:
            d = V;
            break;
          case 4:
            return t.label++, { value: V[1], done: !1 };
          case 5:
            t.label++, a = V[1], V = [0];
            continue;
          case 7:
            V = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (d = t.trys, !(d = d.length > 0 && d[d.length - 1]) && (V[0] === 6 || V[0] === 2)) {
              t = 0;
              continue;
            }
            if (V[0] === 3 && (!d || V[1] > d[0] && V[1] < d[3])) {
              t.label = V[1];
              break;
            }
            if (V[0] === 6 && t.label < d[1]) {
              t.label = d[1], d = V;
              break;
            }
            if (d && t.label < d[2]) {
              t.label = d[2], t.ops.push(V);
              break;
            }
            d[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        V = n.call(e, t);
      } catch (s) {
        V = [6, s], a = 0;
      } finally {
        l = d = 0;
      }
    if (V[0] & 5)
      throw V[1];
    return { value: V[0] ? V[1] : void 0, done: !0 };
  }
}
function Ut(e, n, t) {
  if (t || arguments.length === 2)
    for (var l = 0, a = n.length, d; l < a; l++)
      (d || !(l in n)) && (d || (d = Array.prototype.slice.call(n, 0, l)), d[l] = n[l]);
  return e.concat(d || Array.prototype.slice.call(n));
}
const es = {
  reactions: "reactions",
  message_search_v3: "message_search_v3",
  enable_og_tag: "enable_og_tag",
  enable_message_threading: "enable_message_threading",
  allow_broadcast_channel: "allow_broadcast_channel",
  allow_super_group_channel: "allow_super_group_channel"
};
var QT = function(e, n) {
  return QT = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, l) {
    t.__proto__ = l;
  } || function(t, l) {
    for (var a in l)
      Object.prototype.hasOwnProperty.call(l, a) && (t[a] = l[a]);
  }, QT(e, n);
};
function J(e, n) {
  if (typeof n != "function" && n !== null)
    throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
  function t() {
    this.constructor = e;
  }
  QT(e, n), e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
}
var x = function() {
  return x = Object.assign || function(e) {
    for (var n, t = 1, l = arguments.length; t < l; t++)
      for (var a in n = arguments[t])
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    return e;
  }, x.apply(this, arguments);
};
function lx(e, n) {
  var t = {};
  for (var l in e)
    Object.prototype.hasOwnProperty.call(e, l) && n.indexOf(l) < 0 && (t[l] = e[l]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") {
    var a = 0;
    for (l = Object.getOwnPropertySymbols(e); a < l.length; a++)
      n.indexOf(l[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, l[a]) && (t[l[a]] = e[l[a]]);
  }
  return t;
}
function M(e, n, t, l) {
  return new (t || (t = Promise))(function(a, d) {
    function r(V) {
      try {
        c(l.next(V));
      } catch (s) {
        d(s);
      }
    }
    function i(V) {
      try {
        c(l.throw(V));
      } catch (s) {
        d(s);
      }
    }
    function c(V) {
      var s;
      V.done ? a(V.value) : (s = V.value, s instanceof t ? s : new t(function(o) {
        o(s);
      })).then(r, i);
    }
    c((l = l.apply(e, n || [])).next());
  });
}
function p(e, n) {
  var t, l, a, d, r = { label: 0, sent: function() {
    if (1 & a[0])
      throw a[1];
    return a[1];
  }, trys: [], ops: [] };
  return d = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (d[Symbol.iterator] = function() {
    return this;
  }), d;
  function i(c) {
    return function(V) {
      return function(s) {
        if (t)
          throw new TypeError("Generator is already executing.");
        for (; d && (d = 0, s[0] && (r = 0)), r; )
          try {
            if (t = 1, l && (a = 2 & s[0] ? l.return : s[0] ? l.throw || ((a = l.return) && a.call(l), 0) : l.next) && !(a = a.call(l, s[1])).done)
              return a;
            switch (l = 0, a && (s = [2 & s[0], a.value]), s[0]) {
              case 0:
              case 1:
                a = s;
                break;
              case 4:
                return r.label++, { value: s[1], done: !1 };
              case 5:
                r.label++, l = s[1], s = [0];
                continue;
              case 7:
                s = r.ops.pop(), r.trys.pop();
                continue;
              default:
                if (a = r.trys, !((a = a.length > 0 && a[a.length - 1]) || s[0] !== 6 && s[0] !== 2)) {
                  r = 0;
                  continue;
                }
                if (s[0] === 3 && (!a || s[1] > a[0] && s[1] < a[3])) {
                  r.label = s[1];
                  break;
                }
                if (s[0] === 6 && r.label < a[1]) {
                  r.label = a[1], a = s;
                  break;
                }
                if (a && r.label < a[2]) {
                  r.label = a[2], r.ops.push(s);
                  break;
                }
                a[2] && r.ops.pop(), r.trys.pop();
                continue;
            }
            s = n.call(e, r);
          } catch (o) {
            s = [6, o], l = 0;
          } finally {
            t = a = 0;
          }
        if (5 & s[0])
          throw s[1];
        return { value: s[0] ? s[1] : void 0, done: !0 };
      }([c, V]);
    };
  }
}
function be(e) {
  var n = typeof Symbol == "function" && Symbol.iterator, t = n && e[n], l = 0;
  if (t)
    return t.call(e);
  if (e && typeof e.length == "number")
    return { next: function() {
      return e && l >= e.length && (e = void 0), { value: e && e[l++], done: !e };
    } };
  throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function et(e, n) {
  var t = typeof Symbol == "function" && e[Symbol.iterator];
  if (!t)
    return e;
  var l, a, d = t.call(e), r = [];
  try {
    for (; (n === void 0 || n-- > 0) && !(l = d.next()).done; )
      r.push(l.value);
  } catch (i) {
    a = { error: i };
  } finally {
    try {
      l && !l.done && (t = d.return) && t.call(d);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return r;
}
function ot(e, n, t) {
  if (t || arguments.length === 2)
    for (var l, a = 0, d = n.length; a < d; a++)
      !l && a in n || (l || (l = Array.prototype.slice.call(n, 0, a)), l[a] = n[a]);
  return e.concat(l || Array.prototype.slice.call(n));
}
var nt, Zk = "4.11.2", oi = function() {
  function e() {
  }
  return Object.defineProperty(e, "OS_VERSION", { get: function() {
    return typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.replace(/,/g, ".") : "noAgent";
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "SDK_VERSION", { get: function() {
    return Zk;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "SDK_MAJOR_VERSION", { get: function() {
    return e.SDK_VERSION.split(".")[0];
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "DEFAULT_MAX_UNREAD_COUNT_OF_SUPER_GROUP_CHANNEL", { get: function() {
    return 100;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "INTERNAL_CALL", { get: function() {
    return "ic";
  }, enumerable: !1, configurable: !0 }), e;
}();
(function(e) {
  e[e.NON_AUTHORIZED = 400108] = "NON_AUTHORIZED", e[e.INVALID_TOKEN = 400111] = "INVALID_TOKEN", e[e.NOT_FOUND_IN_DATABASE = 400201] = "NOT_FOUND_IN_DATABASE", e[e.USER_AUTH_DEACTIVATED = 400300] = "USER_AUTH_DEACTIVATED", e[e.USER_AUTH_DELETED_OR_NOT_FOUND = 400301] = "USER_AUTH_DELETED_OR_NOT_FOUND", e[e.SESSION_TOKEN_EXPIRED = 400302] = "SESSION_TOKEN_EXPIRED", e[e.APPLICATION_NOT_FOUND = 400304] = "APPLICATION_NOT_FOUND", e[e.SESSION_KEY_EXPIRED = 400309] = "SESSION_KEY_EXPIRED", e[e.SESSION_REVOKED = 400310] = "SESSION_REVOKED", e[e.INVALID_SESSION_TYPE = 400312] = "INVALID_SESSION_TYPE", e[e.STAT_UPLOAD_NOT_ALLOWED = 403200] = "STAT_UPLOAD_NOT_ALLOWED", e[e.NOT_SUPPORTED_PINNED_MESSAGE_IN_REVIEW_MESSAGE = 400940] = "NOT_SUPPORTED_PINNED_MESSAGE_IN_REVIEW_MESSAGE", e[e.INTERNAL_SERVER_ERROR = 500901] = "INTERNAL_SERVER_ERROR", e[e.RATE_LIMIT_EXCEEDED = 500910] = "RATE_LIMIT_EXCEEDED", e[e.INVALID_FORM_KEY = 400111] = "INVALID_FORM_KEY", e[e.INVALID_REQUIRED_FORM_VALUE = 400105] = "INVALID_REQUIRED_FORM_VALUE", e[e.UNKNOWN_SERVER_ERROR = 900200] = "UNKNOWN_SERVER_ERROR", e[e.NOT_SUPPORTED_FEATURE_IN_IN_REVIEW_MESSAGE = 901500] = "NOT_SUPPORTED_FEATURE_IN_IN_REVIEW_MESSAGE", e[e.ERR_DUPLICATED_DATA = 400202] = "ERR_DUPLICATED_DATA", e[e.DEBUG_MODE_REQUIRED = 7e5] = "DEBUG_MODE_REQUIRED", e[e.LOST_INSTANCE = 700100] = "LOST_INSTANCE", e[e.CONNECTION_RENEW = 700102] = "CONNECTION_RENEW", e[e.INVALID_CONNECTION_STATE_TRANSITION = 700200] = "INVALID_CONNECTION_STATE_TRANSITION", e[e.INVALID_COMMAND = 700700] = "INVALID_COMMAND", e[e.XMLHTTPREQUEST_NOT_SUPPORTED = 700800] = "XMLHTTPREQUEST_NOT_SUPPORTED", e[e.UNKNOWN_ERROR = 77e4] = "UNKNOWN_ERROR", e[e.INVALID_INITIALIZATION = 800100] = "INVALID_INITIALIZATION", e[e.CONNECTION_REQUIRED = 800101] = "CONNECTION_REQUIRED", e[e.CONNECTION_CANCELED = 800102] = "CONNECTION_CANCELED", e[e.INVALID_PARAMETER = 800110] = "INVALID_PARAMETER", e[e.NOT_SUPPORTED_ERROR = 800111] = "NOT_SUPPORTED_ERROR", e[e.NETWORK_ERROR = 800120] = "NETWORK_ERROR", e[e.NETWORK_ROUTING_ERROR = 800121] = "NETWORK_ROUTING_ERROR", e[e.MALFORMED_DATA = 800130] = "MALFORMED_DATA", e[e.MALFORMED_ERROR_DATA = 800140] = "MALFORMED_ERROR_DATA", e[e.WRONG_CHANNEL_TYPE = 800150] = "WRONG_CHANNEL_TYPE", e[e.MARK_AS_READ_RATE_LIMIT_EXCEEDED = 800160] = "MARK_AS_READ_RATE_LIMIT_EXCEEDED", e[e.QUERY_IN_PROGRESS = 800170] = "QUERY_IN_PROGRESS", e[e.ACK_TIMEOUT = 800180] = "ACK_TIMEOUT", e[e.LOGIN_TIMEOUT = 800190] = "LOGIN_TIMEOUT", e[e.WEBSOCKET_CONNECTION_CLOSED = 800200] = "WEBSOCKET_CONNECTION_CLOSED", e[e.WEBSOCKET_CONNECTION_FAILED = 800210] = "WEBSOCKET_CONNECTION_FAILED", e[e.REQUEST_FAILED = 800220] = "REQUEST_FAILED", e[e.FILE_UPLOAD_CANCEL_FAILED = 800230] = "FILE_UPLOAD_CANCEL_FAILED", e[e.REQUEST_CANCELED = 800240] = "REQUEST_CANCELED", e[e.REQUEST_DUPLICATED = 800250] = "REQUEST_DUPLICATED", e[e.FILE_SIZE_LIMIT_EXCEEDED = 800260] = "FILE_SIZE_LIMIT_EXCEEDED", e[e.SESSION_TOKEN_REQUEST_FAILED = 800500] = "SESSION_TOKEN_REQUEST_FAILED", e[e.SESSION_TOKEN_REFRESHED = 800501] = "SESSION_TOKEN_REFRESHED", e[e.SESSION_TOKEN_REFRESH_FAILED = 800502] = "SESSION_TOKEN_REFRESH_FAILED", e[e.COLLECTION_DISPOSED = 800600] = "COLLECTION_DISPOSED", e[e.DATABASE_ERROR = 800700] = "DATABASE_ERROR";
})(nt || (nt = {}));
var wl, $i, sl, JT, Gs, Il = function(e) {
  return !(e instanceof j && !e.shouldThrowOutside);
}, j = function(e) {
  function n(t) {
    var l = t.code, a = l === void 0 ? 0 : l, d = t.message, r = d === void 0 ? "" : d, i = e.call(this, r) || this;
    return i.shouldThrowOutside = !1, i._detail = "", i.name = "SendbirdError", i.code = a, Object.setPrototypeOf(i, n.prototype), i;
  }
  return J(n, e), Object.defineProperty(n.prototype, "detail", { get: function() {
    return this._detail;
  }, enumerable: !1, configurable: !0 }), n.prototype.setDetail = function(t) {
    this._detail = t;
  }, Object.defineProperty(n.prototype, "isInvalidTokenError", { get: function() {
    return this.code === nt.INVALID_TOKEN;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isSessionExpiredError", { get: function() {
    return this.isSessionTokenExpiredError || this.isSessionKeyExpiredError;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isSessionTokenExpiredError", { get: function() {
    return this.code === nt.SESSION_TOKEN_EXPIRED;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isSessionKeyExpiredError", { get: function() {
    return this.code === nt.SESSION_KEY_EXPIRED;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isSessionInvalidatedError", { get: function() {
    return this.isSessionRevokedError || this.isUserAuthDeactivedError || this.isUserAuthDeletedOrNotFoundError;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isSessionRevokedError", { get: function() {
    return this.code === nt.SESSION_REVOKED;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isUserAuthDeactivedError", { get: function() {
    return this.code === nt.USER_AUTH_DEACTIVATED;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isUserAuthDeletedOrNotFoundError", { get: function() {
    return this.code === nt.USER_AUTH_DELETED_OR_NOT_FOUND;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isNetworkError", { get: function() {
    return this.code === nt.NETWORK_ERROR || this.code === nt.NETWORK_ROUTING_ERROR;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "debugModeRequired", { get: function() {
    return new n({ code: nt.DEBUG_MODE_REQUIRED, message: "Cannot run this operation in production mode." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "lostInstance", { get: function() {
    return new n({ code: nt.LOST_INSTANCE, message: "Instance ID is missing. It should belong to an instance." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "invalidCommand", { get: function() {
    return new n({ code: nt.INVALID_COMMAND, message: "Cannot send invalid command." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "unknown", { get: function() {
    return new n({ code: nt.UNKNOWN_ERROR, message: "Unknown error occurred." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "connectionRenew", { get: function() {
    return new n({ code: nt.CONNECTION_RENEW, message: "Connection restarts." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "invalidConnectionStateTransition", { get: function() {
    return new n({ code: nt.INVALID_CONNECTION_STATE_TRANSITION, message: "Invalid connection state transition." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "xmlHttpRequestNotSupported", { get: function() {
    return new n({ code: nt.XMLHTTPREQUEST_NOT_SUPPORTED, message: "Cannot upload file. XMLHttpRequest is not defined in this environment." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "connectionRequired", { get: function() {
    return new n({ code: nt.CONNECTION_REQUIRED, message: "Connection is required." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "connectionCanceled", { get: function() {
    return new n({ code: nt.CONNECTION_CANCELED, message: "Connection is canceled." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "invalidParameters", { get: function() {
    return new n({ code: nt.INVALID_PARAMETER, message: "Invalid parameters." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "notSupportedError", { get: function() {
    return new n({ code: nt.NOT_SUPPORTED_ERROR, message: "Given parameters are not supported." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "channelTypeNotSupportedError", { get: function() {
    return new n({ code: nt.NOT_SUPPORTED_ERROR, message: "Called method is not supported in the current channel's channel type." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "networkError", { get: function() {
    return new n({ code: nt.NETWORK_ERROR, message: "There was a network error." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "markAsReadAllRateLimitExceeded", { get: function() {
    return new n({ code: nt.MARK_AS_READ_RATE_LIMIT_EXCEEDED, message: "markAsRead rate limit exceeded." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "queryInProgress", { get: function() {
    return new n({ code: nt.QUERY_IN_PROGRESS, message: "Query in progress." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "noAckTimeout", { get: function() {
    return new n({ code: nt.ACK_TIMEOUT, message: "Command received no ack." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "loginTimeout", { get: function() {
    return new n({ code: nt.LOGIN_TIMEOUT, message: "Connection timeout." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "connectionClosed", { get: function() {
    return new n({ code: nt.WEBSOCKET_CONNECTION_CLOSED, message: "Connection is closed. Please reconnect." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "requestFailed", { get: function() {
    return new n({ code: nt.REQUEST_FAILED, message: "Request failed." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "alreadyConnectedAsAnotherUser", { get: function() {
    return new n({ code: nt.REQUEST_FAILED, message: "Already logged in as a different user. Call disconnect() first." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "fileUploadCanceled", { get: function() {
    return new n({ code: nt.FILE_UPLOAD_CANCEL_FAILED, message: "File upload has been canceled." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "requestCanceled", { get: function() {
    return new n({ code: nt.REQUEST_CANCELED, message: "Request has been canceled." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "sessionTokenRefreshFailed", { get: function() {
    return new n({ code: nt.SESSION_TOKEN_REFRESH_FAILED, message: "Failed to refresh the session key." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "sessionTokenRequestFailed", { get: function() {
    return new n({ code: nt.SESSION_TOKEN_REQUEST_FAILED, message: "Failed to get the session token." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "databaseError", { get: function() {
    return new n({ code: nt.DATABASE_ERROR, message: "Database error." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "fileSizeLimitExceededError", { get: function() {
    return new n({ code: nt.FILE_SIZE_LIMIT_EXCEEDED, message: "File size exceeds the file size limit." });
  }, enumerable: !1, configurable: !0 }), n.prototype.throwOutside = function() {
    throw this.shouldThrowOutside = !0, this;
  }, n;
}(Error), ax = [nt.CONNECTION_REQUIRED, nt.NETWORK_ERROR, nt.ACK_TIMEOUT, nt.WEBSOCKET_CONNECTION_CLOSED, nt.WEBSOCKET_CONNECTION_FAILED, nt.FILE_UPLOAD_CANCEL_FAILED, nt.REQUEST_CANCELED, nt.INTERNAL_SERVER_ERROR, nt.RATE_LIMIT_EXCEEDED, nt.UNKNOWN_SERVER_ERROR], dx = [nt.WEBSOCKET_CONNECTION_CLOSED, nt.WEBSOCKET_CONNECTION_FAILED, nt.CONNECTION_REQUIRED], Tk = function(e, n) {
  if (e !== n) {
    var t = x({}, e), l = x({}, n);
    return (!t.hasOwnProperty("messageId") || !l.hasOwnProperty("messageId") || t.messageId === l.messageId) && (!t.hasOwnProperty("reqId") || !l.hasOwnProperty("reqId") || t.reqId === l.reqId) && (t.hasOwnProperty("messageId") && delete t.messageId, t.hasOwnProperty("reqId") && delete t.reqId, l.hasOwnProperty("messageId") && delete l.messageId, l.hasOwnProperty("reqId") && delete l.reqId, JSON.stringify(t) === JSON.stringify(l));
  }
  return !0;
}, B = function(e, n, t) {
  return t === void 0 && (t = !1), !(!t || !eU(n)) || (typeof e != "string" ? typeof e == "object" ? Qt(e, n) : rx(e, n) : typeof n === e);
}, Qt = function(e, n, t) {
  return t === void 0 && (t = !1), !(!t || !eU(n)) || Object.values(e).includes(n);
}, rx = function(e, n) {
  return n instanceof e;
}, Jt = function(e, n, t) {
  return t === void 0 && (t = !1), !(!t || !eU(n)) || Array.isArray(n) && n.every(function(l) {
    return B(e, l);
  });
}, Sm = function(e, n) {
  return n === void 0 && (n = !1), !(!n || !eU(e)) || typeof e == "number" && e.toString().length === 13;
}, ix = function(e) {
  return e > 0 && ax.indexOf(e) >= 0;
}, CN = function(e) {
  return e > 0 && dx.indexOf(e) >= 0;
}, Nl = function(e, n) {
  if (n === void 0 && (n = !1), n && eU(e))
    return !0;
  var t = typeof e == "object" && e !== null && e.hasOwnProperty("name") && typeof e.name == "string" && e.hasOwnProperty("uri") && typeof e.uri == "string" && e.hasOwnProperty("type") && typeof e.type == "string";
  if (!t) {
    if (typeof Blob < "u")
      return e instanceof Blob;
    if (typeof File < "u")
      return e instanceof File;
  }
  return t;
}, Vx = function(e, n) {
  if (e === n)
    return !0;
  if (e == null || n == null || e.length !== n.length)
    return !1;
  for (var t = ot([], et(e), !1).sort(), l = ot([], et(n), !1).sort(), a = 0; a < t.length; ++a)
    if (t[a] !== l[a])
      return !1;
  return !0;
}, eU = function(e) {
  return e == null;
}, Fk = function() {
  function e(n) {
    var t = n === void 0 ? {} : n, l = t.useMemberInfoInMessage, a = l === void 0 || l, d = t.typingIndicatorInvalidateTime, r = d === void 0 ? 1e4 : d, i = t.typingIndicatorThrottle, c = i === void 0 ? 1e3 : i, V = t.websocketResponseTimeout, s = V === void 0 ? 1e4 : V, o = t.websocketPayloadDecompression, U = o === void 0 || o, N = t.sessionTokenRefreshTimeout, R = N === void 0 ? 60 : N;
    this._useMemberInfoInMessage = !0, this._typingIndicatorInvalidateTime = 1e4, this._typingIndicatorThrottle = 1e3, this._websocketResponseTimeout = 1e4, this._sessionTokenRefreshTimeout = 60, this._useMemberInfoInMessage = a, this._typingIndicatorInvalidateTime = r, this._typingIndicatorThrottle = c, this._websocketResponseTimeout = s, this._sessionTokenRefreshTimeout = R, this.websocketPayloadDecompression = U;
  }
  return Object.defineProperty(e.prototype, "useMemberInfoInMessage", { get: function() {
    return this._useMemberInfoInMessage;
  }, set: function(n) {
    B("boolean", n) && (this._useMemberInfoInMessage = n);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "typingIndicatorInvalidateTime", { get: function() {
    return this._typingIndicatorInvalidateTime;
  }, set: function(n) {
    B("number", n) && (this._typingIndicatorInvalidateTime = n);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "typingIndicatorThrottle", { get: function() {
    return this._typingIndicatorThrottle;
  }, set: function(n) {
    B("number", n) && n >= 1e3 && n <= 9e3 && (this._typingIndicatorThrottle = n);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "websocketResponseTimeout", { get: function() {
    return this._websocketResponseTimeout;
  }, set: function(n) {
    B("number", n) && n >= 5e3 && n <= 3e4 && (this._websocketResponseTimeout = n);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "sessionTokenRefreshTimeout", { get: function() {
    return this._sessionTokenRefreshTimeout;
  }, set: function(n) {
    B("number", n) && (n < 60 ? n = 60 : n > 1800 && (n = 1800), this._sessionTokenRefreshTimeout = n);
  }, enumerable: !1, configurable: !0 }), e;
}(), Wk = { encrypt: function(e) {
  return e;
}, decrypt: function(e) {
  return e;
} }, km = function() {
  function e(n) {
    var t = n.store;
    this._preference = /* @__PURE__ */ new Map(), this._store = t;
  }
  return e.prototype._savePreferenceKeys = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, this._store.set({ key: this._keysAddress, value: ot([], et(this._preference.keys()), !1) })];
          case 1:
            return n.sent(), [2];
        }
      });
    });
  }, e.prototype.init = function(n, t) {
    var l;
    return t === void 0 && (t = 1), M(this, void 0, void 0, function() {
      var a, d, r, i, c, V, s, o, U, N;
      return p(this, function(R) {
        switch (R.label) {
          case 0:
            return this._version = t, this._keysAddress = n, a = "".concat(n, ".metadata.version"), [4, this._store.get(a)];
          case 1:
            return d = R.sent(), [4, this._store.get(n)];
          case 2:
            return r = (l = R.sent()) !== null && l !== void 0 ? l : [], !d || d.version < this._version ? [4, this._resetPreferenceData(r, a)] : [3, 4];
          case 3:
            return R.sent(), [3, 11];
          case 4:
            R.trys.push([4, 9, 10, 11]), i = be(r), c = i.next(), R.label = 5;
          case 5:
            return c.done ? [3, 8] : (V = c.value, [4, this._store.get(V)]);
          case 6:
            (s = R.sent()) && this._preference.set(V, s), R.label = 7;
          case 7:
            return c = i.next(), [3, 5];
          case 8:
            return [3, 11];
          case 9:
            return o = R.sent(), U = { error: o }, [3, 11];
          case 10:
            try {
              c && !c.done && (N = i.return) && N.call(i);
            } finally {
              if (U)
                throw U.error;
            }
            return [7];
          case 11:
            return [2];
        }
      });
    });
  }, e.prototype._resetPreferenceData = function(n, t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this._preference = /* @__PURE__ */ new Map(), [4, this._store.removeMany(n)];
          case 1:
            return l.sent(), [4, this._store.set({ key: t, value: { version: this._version } })];
          case 2:
            return l.sent(), [2];
        }
      });
    });
  }, e.prototype.get = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return [2, this._preference.get(n)];
      });
    });
  }, e.prototype.set = function(n, t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = !this._preference.has(n), [4, this._store.set({ key: n, value: t })];
          case 1:
            return a.sent(), this._preference.set(n, t), l ? [4, this._savePreferenceKeys()] : [3, 3];
          case 2:
            a.sent(), a.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, e.prototype.remove = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this._store.remove(n)];
          case 1:
            return t.sent(), this._preference.delete(n), [4, this._savePreferenceKeys()];
          case 2:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, this._store.removeMany(ot([], et(this._preference.keys()), !1))];
          case 1:
            return n.sent(), this._preference.clear(), [4, this._savePreferenceKeys()];
          case 2:
            return n.sent(), [2];
        }
      });
    });
  }, e;
}(), cx = function() {
  function e(n) {
    var t = n.encryption, l = n.store, a = n.localCacheEnabled, d = n.localCacheConfig;
    this.store = l, this.preference = new km({ store: l }), this.encryption = t ?? Wk, this.localCacheEnabled = a, this.localCacheConfig = d;
  }
  return e.prototype.replaceStore = function(n) {
    this.store = n, this.preference = new km({ store: n });
  }, e;
}();
(function(e) {
  e.SUCCESS = "success", e.PENDING = "pending", e.ERROR = "error";
})(wl || (wl = {})), function(e) {
  e.DEFAULT = "default", e.ALL = "all", e.MENTION_ONLY = "mention_only", e.OFF = "off";
}($i || ($i = {})), function(e) {
  e.FCM = "gcm", e.APNS = "apns", e.UNKNOWN = "unknown";
}(sl || (sl = {})), function(e) {
  e.ALTERNATIVE = "alternative", e.DEFAULT = "default";
}(JT || (JT = {})), function(e) {
  e.CUSTOM = "custom", e.MESSAGE_COLLECTION_ACCESSED_AT = "messagecollection_accessed_at";
}(Gs || (Gs = {}));
var ho, sx = function() {
  function e(n) {
    var t = n.channel, l = n.cachedMessageCount;
    this._cachedMessageCount = 0, this._channel = t, this._cachedMessageCount = l;
  }
  return Object.defineProperty(e.prototype, "channel", { get: function() {
    return this._channel;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "cachedMessageCount", { get: function() {
    return this._cachedMessageCount;
  }, enumerable: !1, configurable: !0 }), e;
}(), mk = function() {
  function e(n) {
    var t = n === void 0 ? {} : n, l = t.maxSize, a = l === void 0 ? 256 : l, d = t.clearOrder, r = d === void 0 ? Gs.MESSAGE_COLLECTION_ACCESSED_AT : d, i = t.customClearOrderComparator, c = t.enableAutoResend, V = c === void 0 || c;
    this._clearOrderComparatorUseMessageCollectionAccessedAt = function(s, o) {
      return s.channel.messageCollectionLastAccessedAt === o.channel.messageCollectionLastAccessedAt ? s.channel.lastMessage && !o.channel.lastMessage ? 1 : !s.channel.lastMessage && o.channel.lastMessage ? -1 : s.channel.lastMessage || o.channel.lastMessage ? s.channel.lastMessage.createdAt - o.channel.lastMessage.createdAt : 0 : s.channel.messageCollectionLastAccessedAt > o.channel.messageCollectionLastAccessedAt ? 1 : -1;
    }, this._maxSize = Math.max(a, 64), i ? (this._clearOrder = r, this._customClearOrderComparator = i) : this._clearOrder = Gs.MESSAGE_COLLECTION_ACCESSED_AT, this._enableAutoResend = V;
  }
  return Object.defineProperty(e.prototype, "maxSize", { get: function() {
    return this._maxSize;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "clearOrder", { get: function() {
    return this._clearOrder;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "clearOrderComparator", { get: function() {
    var n;
    return this._clearOrder === Gs.MESSAGE_COLLECTION_ACCESSED_AT ? this._clearOrderComparatorUseMessageCollectionAccessedAt : (n = this._customClearOrderComparator) !== null && n !== void 0 ? n : this._clearOrderComparatorUseMessageCollectionAccessedAt;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "enableAutoResend", { get: function() {
    return this._enableAutoResend;
  }, enumerable: !1, configurable: !0 }), e;
}();
(function(e) {
  e.FEED = "feed", e.CHAT = "chat";
})(ho || (ho = {}));
var Xt, ed, Od, Gn, bl, Mc, Jl, al, pd, $t, bm, vT, zT, ox = function() {
  function e() {
    this.isRefreshing = !1;
  }
  return Object.defineProperty(e.prototype, "hasSession", { get: function() {
    return !!this.sessionKey;
  }, enumerable: !1, configurable: !0 }), e.prototype.clear = function() {
    this.authToken = void 0, this.sessionKey = void 0, this.services = [];
  }, e;
}(), vr = function() {
  var e = (/* @__PURE__ */ new Date()).getTime();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(n) {
    var t = (e + 16 * Math.random()) % 16 | 0;
    return e = Math.floor(e / 16), (n === "x" ? t : 3 & t | 8).toString(16);
  });
}, Ym = function() {
  function e(n) {
    var t = n.container;
    this._container = {}, this._container = t, this.key = vr();
  }
  return e.prototype._register = function(n, t, l) {
    var a;
    return n in this._container || (this._container[n] = /* @__PURE__ */ new Map()), (a = this._container[n]) === null || a === void 0 || a.set(this.key, { occurence: t, handler: l }), this;
  }, e.prototype.on = function(n, t) {
    return this._register(n, -1, t);
  }, e.prototype.once = function(n, t) {
    return this._register(n, 1, t);
  }, e.prototype.close = function() {
    var n;
    for (var t in this._container)
      (n = this._container[t]) === null || n === void 0 || n.delete(this.key);
  }, e;
}(), zV = function() {
  function e() {
    this._container = {};
  }
  return e.prototype.on = function(n, t) {
    return new Ym({ container: this._container }).on(n, t);
  }, e.prototype.once = function(n, t) {
    return new Ym({ container: this._container }).once(n, t);
  }, e.prototype.dispatch = function(n, t) {
    var l, a, d = this._container[n];
    if (d) {
      var r = [];
      try {
        for (var i = be(d.keys()), c = i.next(); !c.done; c = i.next()) {
          var V = c.value, s = d.get(V);
          s.handler(t), s.occurence > 0 && (s.occurence--, s.occurence === 0 && r.push(V));
        }
      } catch (o) {
        l = { error: o };
      } finally {
        try {
          c && !c.done && (a = i.return) && a.call(i);
        } finally {
          if (l)
            throw l.error;
        }
      }
      r.forEach(function(o) {
        return d.delete(o);
      });
    }
  }, e;
}(), Ux = function() {
  function e() {
    this._dispatcher = new zV();
  }
  return e.prototype.on = function(n) {
    return this._dispatcher.on("event", n);
  }, e.prototype.once = function(n) {
    return this._dispatcher.once("event", n);
  }, e.prototype.dispatch = function(n) {
    this._dispatcher.dispatch("event", n);
  }, e;
}(), un = function() {
}, je = function(e) {
  var n = {};
  return e && Object.keys(e).forEach(function(t) {
    e[t] === void 0 || Number.isNaN(e[t]) || e[t] === null || (n[t] = e[t]);
  }), n;
}, Ae = function(e) {
  if (e != null) {
    if (typeof e == "object") {
      if (Array.isArray(e)) {
        var n = ot([], et(e), !1);
        for (var t in n)
          n[t] = Ae(n[t]);
        return n;
      }
      for (var l in e)
        e[l] === null && delete e[l];
      return e;
    }
    return e;
  }
};
(function(e) {
  e.BASE = "base", e.GROUP = "group", e.OPEN = "open", e.FEED = "feed";
})(Xt || (Xt = {})), function(e) {
  e.OPERATOR = "operator", e.NONE = "none";
}(ed || (ed = {})), function(e) {
  e.MUTED = "muted", e.UNMUTED = "unmuted";
}(Od || (Od = {})), function(e) {
  e.BASE = "base", e.USER = "user", e.FILE = "file", e.ADMIN = "admin";
}(Gn || (Gn = {})), function(e) {
  e.ALL = "", e.USER = "MESG", e.FILE = "FILE", e.ADMIN = "ADMM";
}(bl || (bl = {})), function(e) {
  e.USER = "MESG", e.FILE = "FILE", e.ADMIN = "ADMM";
}(Mc || (Mc = {})), function(e) {
  e.USERS = "users", e.CHANNEL = "channel";
}(Jl || (Jl = {})), function(e) {
  e.ALL = "all", e.NONE = "none", e.ONLY_REPLY_TO_CHANNEL = "only_reply_to_channel";
}(al || (al = {})), function(e) {
  e.DEFAULT = "default", e.SUPPRESS = "suppress";
}(pd || (pd = {})), function(e) {
  e.PENDING = "pending", e.SCHEDULED = "scheduled", e.SUCCEEDED = "succeeded", e.FAILED = "failed", e.CANCELED = "canceled";
}($t || ($t = {})), function(e) {
  e.INREVIEW = "InReview", e.APPROVED = "Approved";
}(bm || (bm = {})), function(e) {
  e.HIGH = "high", e.NORMAL = "normal", e.LOW = "low";
}(vT || (vT = {})), function(e) {
  e.CREATED_AT = "created_at", e.UPDATED_AT = "updated_at";
}(zT || (zT = {}));
var he, ia = "v3", It = "/".concat(ia, "/users"), Nx = "/".concat(ia, "/storage/file"), vl = "/".concat(ia, "/group_channels"), Rx = "/".concat(ia, "/sdk/group_channels"), xV = "/".concat(ia, "/open_channels"), hx = "/".concat(ia, "/sdk/open_channels"), Zx = "/".concat(ia, "/search"), xT = "/".concat(ia, "/report"), Tx = "/".concat(ia, "/emojis"), uk = "/".concat(ia, "/emoji_categories"), kd = "/".concat(ia, "/polls"), pk = "/".concat(ia, "/scheduled_messages"), Fx = "/".concat(ia, "/sdk/ui_kit/configuration"), Wx = "/".concat(ia, "/sdk/statistics"), Mk = "/".concat(ia, "/message_templates"), Lt = function(e) {
  switch (e) {
    case Xt.FEED:
    case Xt.GROUP:
      return vl;
    case Xt.OPEN:
      return xV;
    default:
      return null;
  }
}, Ek = function(e) {
  switch (e) {
    case Xt.GROUP:
      return "".concat(xT, "/group_channels");
    case Xt.OPEN:
      return "".concat(xT, "/open_channels");
    default:
      return null;
  }
}, Ec = function(e, n, t) {
  var l, a;
  switch (e) {
    case Jl.CHANNEL:
      return !0;
    case Jl.USERS:
      if (n)
        try {
          for (var d = be(n), r = d.next(); !r.done; r = d.next())
            if (r.value === t)
              return !0;
        } catch (i) {
          l = { error: i };
        } finally {
          try {
            r && !r.done && (a = d.return) && a.call(d);
          } finally {
            if (l)
              throw l.error;
          }
        }
  }
  return !1;
}, TW = function(e, n, t) {
  var l, a, d, r, i = Ec((l = e.mentionType) !== null && l !== void 0 ? l : null, (a = e.mentionedUserIds) !== null && a !== void 0 ? a : [], t), c = Ec((d = n.mentionType) !== null && d !== void 0 ? d : null, (r = n.mentionedUserIds) !== null && r !== void 0 ? r : [], t);
  return !i && c ? 1 : i && !c ? -1 : 0;
}, Sk = function(e, n, t) {
  var l, a = n || new FormData();
  for (var d in e)
    if (e.hasOwnProperty(d)) {
      var r = e[d], i = t ? "".concat(t, "[").concat(d, "]") : d;
      Nl(r) ? a.append(i, r, (l = r.name) !== null && l !== void 0 ? l : "filename") : typeof r != "object" || r === null || Array.isArray(r) || r instanceof Blob ? a.append(i, String(r)) : a = Sk(r, a, i);
    }
  return a;
};
(function(e) {
  e.GET = "GET", e.POST = "POST", e.PUT = "PUT", e.DELETE = "DELETE";
})(he || (he = {}));
var Mn, Te = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.params = {}, t.requireAuth = !0, t.headers = {}, t.requestId = vr(), t;
  }
  return J(n, e), n.prototype.encodeParams = function(t) {
    var l = this;
    return t == null || t === "" ? encodeURIComponent("") : Array.isArray(t) ? t.map(function(a) {
      return l.encodeParams(a);
    }).join(",") : encodeURIComponent(typeof t == "object" ? JSON.stringify(t) : String(t));
  }, Object.defineProperty(n.prototype, "query", { get: function() {
    var t = this, l = je(this.params);
    return "?".concat(Object.keys(l).map(function(a) {
      return "".concat(encodeURIComponent(a), "=").concat(t.encodeParams(l[a]));
    }).join("&"));
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "payload", { get: function() {
    var t = je(this.params);
    return Object.keys(t).some(function(l) {
      return Nl(t[l]);
    }) ? Sk(t) : JSON.stringify(t);
  }, enumerable: !1, configurable: !0 }), n;
}(un), ue = function(e) {
  function n(t, l) {
    var a = e.call(this) || this;
    return a._iid = t, a._payload = l, a;
  }
  return J(n, e), Object.defineProperty(n.prototype, "payload", { get: function() {
    return x({}, this._payload);
  }, enumerable: !1, configurable: !0 }), n.prototype.as = function(t) {
    return new t(this._iid, this.payload);
  }, n;
}(un), mx = function(e) {
  function n(t) {
    var l = e.call(this) || this;
    return l.requestId = t, l;
  }
  return J(n, e), n;
}(un), Sc = function(e) {
  function n(t) {
    var l = t.expires_in, a = t.reason, d = a === void 0 ? nt.SESSION_KEY_EXPIRED : a, r = e.call(this) || this;
    switch (r.expiresIn = l ?? 0, d) {
      case nt.SESSION_KEY_EXPIRED:
      case nt.SESSION_TOKEN_EXPIRED:
      case nt.SESSION_REVOKED:
      case nt.USER_AUTH_DEACTIVATED:
      case nt.USER_AUTH_DELETED_OR_NOT_FOUND:
        r.error = new j({ code: d });
    }
    return r;
  }
  return J(n, e), Object.defineProperty(n.prototype, "invalidateSessionToken", { get: function() {
    var t;
    return !!(!((t = this.error) === null || t === void 0) && t.isSessionTokenExpiredError);
  }, enumerable: !1, configurable: !0 }), n;
}(un), Wn = function(e) {
  function n(t, l, a, d) {
    d === void 0 && (d = "");
    var r, i = this;
    return (i = e.call(this) || this)._iid = t, i.code = l, i.payload = a, i.requestId = (r = a.req_id) !== null && r !== void 0 ? r : d, i;
  }
  return J(n, e), n.createFromRawMessage = function(t, l) {
    var a = l.substring(0, 4), d = {};
    try {
      d = JSON.parse(l.substring(4));
    } catch {
      a = "NOOP";
    } finally {
      return new n(t, a, d);
    }
  }, n.prototype.convertToMessage = function() {
    return "".concat(this.code).concat(JSON.stringify(this.payload), `
`);
  }, n.prototype.as = function(t) {
    return new t(this._iid, this.code, this.payload);
  }, n;
}(un), Yl = function(e) {
  function n(t) {
    var l, a = t.code, d = t.ackRequired, r = t.payload, i = r === void 0 ? {} : r, c = this;
    return (c = e.call(this) || this).code = a, c.payload = i, c.requestId = (l = c.payload.req_id) !== null && l !== void 0 ? l : vr(), c.ackRequired = d, c.payload.req_id = c.requestId, c;
  }
  return J(n, e), n.prototype.convertToMessage = function() {
    return "".concat(this.code).concat(JSON.stringify(this.payload), `
`);
  }, n;
}(un), FW = function(e) {
  function n(t) {
    var l = t.userId, a = t.authToken, d = t.services, r = t.expiringSession, i = r === void 0 || r, c = e.call(this) || this;
    return c.path = "".concat(It, "/").concat(l, "/session_key"), c.method = he.POST, c.params = je({ token: a, services: d, expiring_session: !!i }), c.requireAuth = !1, c;
  }
  return J(n, e), n;
}(Te), ux = function(e) {
  function n(t) {
    var l = t.authToken, a = t.expiringSession, d = a === void 0 || a, r = t.requestId, i = r === void 0 ? void 0 : r;
    return e.call(this, { code: "LOGI", payload: { token: l, expiring_session: d ? 1 : 0, req_id: i }, ackRequired: !0 }) || this;
  }
  return J(n, e), n;
}(Yl), px = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this, d = l.key, r = l.expires_at, i = l.services;
    return a.key = d, a.expiresAt = r, a.services = i, a;
  }
  return J(n, e), n;
}(ue), Mx = function(e) {
  function n(t, l, a) {
    var d, r = this;
    return (r = e.call(this, t, "LOGI", a) || this).error = null, r.newKey = null, r.newKey = (d = a.new_key) !== null && d !== void 0 ? d : null, r.error = a.error ? new j(a) : null, r;
  }
  return J(n, e), n;
}(Wn), WW = function(e) {
  function n(t) {
    var l = e.call(this) || this;
    return l.statLog = t, l;
  }
  return J(n, e), n;
}(un), kk = function(e) {
  function n(t) {
    var l = t.request, a = t.deferred, d = t.error, r = d === void 0 ? j.requestFailed : d, i = e.call(this) || this;
    return i.request = l, i.deferred = a, i.error = r, i;
  }
  return J(n, e), n;
}(un);
(function(e) {
  e.FEATURE_LOCALCACHE = "feature:local_cache", e.FEATURE_LOCALCACHE_EVENT = "feature:local_cache_event", e.NOTIFICATION = "noti:stats", e.WEBSOCKET_CONNECT = "ws:connect", e.API_RESULT = "api:result";
})(Mn || (Mn = {}));
var ys, ZV, Cr, Ml = function() {
  function e(n) {
    var t = n.type, l = n.data, a = n.ts, d = a === void 0 ? Date.now() : a;
    this.type = t, this.createdAt = d, this.data = l;
  }
  return e.payloadify = function(n) {
    return je({ stat_type: n.type, ts: n.createdAt, data: je(n.data) });
  }, e;
}(), GT = function() {
  return typeof document > "u" && typeof navigator < "u" && navigator.product == "ReactNative";
}, Qm = function() {
  return !(typeof navigator > "u" || !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone/i.test(navigator.userAgent));
};
(function(e) {
  e.CHAT = "chat", e.CALLS = "calls", e.DESK = "desk", e.LIVE = "live", e.UIKIT_CHAT = "uikit-chat", e.UIKIT_LIVE = "uikit-live";
})(ys || (ys = {})), function(e) {
  e.ANDROID = "android", e.IOS = "ios", e.JS = "js", e.UNREAL = "unreal", e.UNITY = "unity", e.REACT_NATIVE = "react-native", e.FLUTTER = "flutter";
}(ZV || (ZV = {})), function(e) {
  e.ANDROID = "android", e.IOS = "ios", e.WEB = "web", e.MOBILE_WEB = "mobile_web", e.WINDOWS = "windows";
}(Cr || (Cr = {}));
var Ex = "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$", KN = function() {
  function e() {
  }
  return e.sendbirdSdkUserAgentWithExtension = function(n) {
    var t = GT() ? ZV.REACT_NATIVE : ZV.JS, l = { main_sdk_info: "chat/".concat(t, "/").concat(oi.SDK_VERSION), device_os_platform: Qm() ? "mobile-web" : "web", os_version: oi.OS_VERSION };
    if (n) {
      var a = n.sendbirdExtensions, d = n.deviceOS, r = n.customData, i = r === void 0 ? {} : r;
      d.version && (l.os_version = d.version), d.platform && (l.device_os_platform = d.platform), a.length > 0 && (l.extension_sdk_info = a.map(function(c) {
        var V = c.product, s = c.platform, o = c.version;
        return "".concat(V, "/").concat(s, "/").concat(o);
      }).join(",")), Object.keys(l).forEach(function(c) {
        return delete i[c];
      }), Object.keys(i).length > 0 && (l = x(x({}, l), i));
    }
    return Object.entries(l).map(function(c) {
      var V = et(c, 2), s = V[0], o = V[1];
      return "".concat(s, "=").concat(o);
    }).join("&");
  }, e.userAgentWithExtension = function(n) {
    var t = GT() ? "reactnative" : "JS", l = n.sb_syncmanager ? "s".concat(n.sb_syncmanager) : "", a = n.sb_uikit ? "u".concat(n.sb_uikit) : "", d = n["device-os-platform"] ? "o".concat(n["device-os-platform"]) : Qm() ? "omobile-web" : "oweb";
    return "".concat(t, "/c").concat(oi.SDK_VERSION, "/").concat(l, "/").concat(a, "/").concat(d);
  }, e;
}(), Ll = function() {
  var e = this;
  this.promise = new Promise(function(n, t) {
    e.resolve = n, e.reject = function(l) {
      t(l);
    };
  });
}, _N = function(e) {
  function n(t) {
    var l = e.call(this) || this;
    return l.requestId = t.requestId, l;
  }
  return J(n, e), n;
}(un), Sx = function() {
  function e(n, t) {
    var l = t.session, a = t.sdkState, d = t.dispatcher, r = t.logger, i = t.useFetchCompat, c = i !== void 0 && i, V = this;
    this._abortControl = /* @__PURE__ */ new Map(), this._shouldImportFetchCompat = !1, this._iid = n, this._session = l, this._sdkState = a, this._dispatcher = d, this._dispatcher.on(function(s) {
      s instanceof mx && V.cancel(s.requestId);
    }), this._logger = r, this._shouldImportFetchCompat = c;
  }
  return e.prototype._createHeader = function(n, t) {
    var l = this._sdkState, a = l.appId, d = l.appVersion, r = l.sendbirdRuntimeEnvironment, i = x(x({}, n.headers), { SendBird: "JS,".concat(oi.OS_VERSION, ",").concat(oi.SDK_VERSION, ",").concat(a).concat(d ? ",".concat(d) : ""), "SB-User-Agent": KN.userAgentWithExtension(this._sdkState.extensions), "Request-Sent-Timestamp": Date.now().toString(), "SB-SDK-User-Agent": KN.sendbirdSdkUserAgentWithExtension(r) });
    return t || (i["Content-Type"] = "application/json; charset=utf-8"), n.requireAuth && this._session.hasSession && (i["Session-Key"] = this._session.sessionKey), this._session && this._session.authToken && (i["App-Id"] = a, i["Access-Token"] = this._session.authToken), i;
  }, e.prototype._statLogApiResult = function(n, t, l) {
    this._dispatcher.dispatch(new WW(new Ml({ type: Mn.API_RESULT, data: { endpoint: n.path, method: n.method, success: !l, latency: Date.now() - t, error_code: l == null ? void 0 : l.code, error_description: l == null ? void 0 : l.message } })));
  }, e.prototype.send = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u;
      return p(this, function(b) {
        switch (b.label) {
          case 0:
            t = n.path, l = n.method, a = n.uploadProgressHandler, d = ![he.GET, he.DELETE].includes(l), r = this._sdkState.api, i = "".concat(r.host).concat(t).concat(d ? "" : n.query), c = d ? n.payload : null, V = this._createHeader(n, c instanceof FormData ? c : void 0), s = new AbortController(), o = s.signal, this._abortControl.set(n.requestId, s), U = Date.now(), b.label = 1;
          case 1:
            return b.trys.push([1, 13, , 14]), a ? [4, import("./__bundle-aece11ae-7cd088c9.mjs")] : [3, 6];
          case 2:
            N = b.sent().xmlHttpRequest, b.label = 3;
          case 3:
            return b.trys.push([3, 5, , 6]), [4, N(this._iid, { requestId: n.requestId, method: n.method, url: i, headers: V, data: c ?? void 0, uploadProgressHandler: a })];
          case 4:
            return R = b.sent(), this._logger.debug("receive api response", n.requestId), this._statLogApiResult(n, U), [2, R];
          case 5:
            if (!((h = b.sent()) instanceof j && h.code === nt.XMLHTTPREQUEST_NOT_SUPPORTED))
              throw h;
            return this._logger.debug("XMLHttpRequest is not available in this environment. progressHandler is ignored."), [3, 6];
          case 6:
            return this._shouldImportFetchCompat && (this._shouldImportFetchCompat = !1, (typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof global < "u" && global || { fetch: null }).fetch = null), typeof AbortController < "u" ? [3, 8] : [4, import("./__bundle-2aa1a987-9f0a487f.mjs").then((k) => k._)];
          case 7:
            b.sent(), b.label = 8;
          case 8:
            return typeof fetch == "function" ? [3, 10] : [4, import("./__bundle-ba2b9764-dbc8194f.mjs").then((k) => k._)];
          case 9:
            b.sent(), b.label = 10;
          case 10:
            return [4, fetch(i, { method: l, body: c, headers: V, signal: o })];
          case 11:
            return [4, (Z = b.sent()).json()];
          case 12:
            if (W = b.sent(), Z.ok || Z.redirected)
              return this._logger.debug("receive api response", n.requestId), this._statLogApiResult(n, U), [2, new ue(this._iid, W)];
            if (W) {
              if ((F = new j(W)).isSessionExpiredError) {
                if (this._dispatcher.dispatch(new Sc({ reason: F.code })), !(n instanceof FW))
                  return m = new Ll(), this._dispatcher.dispatch(new kk({ request: n, deferred: m, error: F })), [2, m.promise];
                throw F;
              }
              throw F.isSessionInvalidatedError && this._dispatcher.dispatch(new Sc({ reason: F.code })), F;
            }
            throw j.requestFailed;
          case 13:
            throw E = b.sent(), this._statLogApiResult(n, U, E), E instanceof j ? (this._logger.debug("fail api request", E), E) : (E == null ? void 0 : E.name) === "AbortError" ? j.requestCanceled : (u = j.networkError, this._logger.debug("fail api request", u), u);
          case 14:
            return [2];
        }
      });
    });
  }, e.prototype.cancel = function(n) {
    this._abortControl.has(n) && (this._abortControl.get(n).abort(), this._abortControl.delete(n)), this._dispatcher.dispatch(new _N({ requestId: n }));
  }, e.prototype.cancelAll = function() {
    var n, t;
    try {
      for (var l = be(this._abortControl.values()), a = l.next(); !a.done; a = l.next())
        a.value.abort();
    } catch (d) {
      n = { error: d };
    } finally {
      try {
        a && !a.done && (t = l.return) && t.call(l);
      } finally {
        if (n)
          throw n.error;
      }
    }
    this._abortControl.clear(), this._dispatcher.dispatch(new _N({}));
  }, e;
}(), ut = function() {
};
function wc(e) {
  let n = e.length;
  for (; --n >= 0; )
    e[n] = 0;
}
const mW = 256, bk = 286, Bs = 30, Ds = 15, yT = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), uN = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), kx = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), Jm = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Ur = new Array(576);
wc(Ur);
const Xs = new Array(60);
wc(Xs);
const Zo = new Array(512);
wc(Zo);
const Os = new Array(256);
wc(Os);
const uW = new Array(29);
wc(uW);
const PN = new Array(Bs);
function Ph(e, n, t, l, a) {
  this.static_tree = e, this.extra_bits = n, this.extra_base = t, this.elems = l, this.max_length = a, this.has_stree = e && e.length;
}
let vm, zm, xm;
function Ah(e, n) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = n;
}
wc(PN);
const Yk = (e) => e < 256 ? Zo[e] : Zo[256 + (e >>> 7)], To = (e, n) => {
  e.pending_buf[e.pending++] = 255 & n, e.pending_buf[e.pending++] = n >>> 8 & 255;
}, Ra = (e, n, t) => {
  e.bi_valid > 16 - t ? (e.bi_buf |= n << e.bi_valid & 65535, To(e, e.bi_buf), e.bi_buf = n >> 16 - e.bi_valid, e.bi_valid += t - 16) : (e.bi_buf |= n << e.bi_valid & 65535, e.bi_valid += t);
}, jd = (e, n, t) => {
  Ra(e, t[2 * n], t[2 * n + 1]);
}, Qk = (e, n) => {
  let t = 0;
  do
    t |= 1 & e, e >>>= 1, t <<= 1;
  while (--n > 0);
  return t >>> 1;
}, Jk = (e, n, t) => {
  const l = new Array(16);
  let a, d, r = 0;
  for (a = 1; a <= Ds; a++)
    r = r + t[a - 1] << 1, l[a] = r;
  for (d = 0; d <= n; d++) {
    let i = e[2 * d + 1];
    i !== 0 && (e[2 * d] = Qk(l[i]++, i));
  }
}, vk = (e) => {
  let n;
  for (n = 0; n < bk; n++)
    e.dyn_ltree[2 * n] = 0;
  for (n = 0; n < Bs; n++)
    e.dyn_dtree[2 * n] = 0;
  for (n = 0; n < 19; n++)
    e.bl_tree[2 * n] = 0;
  e.dyn_ltree[512] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, zk = (e) => {
  e.bi_valid > 8 ? To(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, Gm = (e, n, t, l) => {
  const a = 2 * n, d = 2 * t;
  return e[a] < e[d] || e[a] === e[d] && l[n] <= l[t];
}, qh = (e, n, t) => {
  const l = e.heap[t];
  let a = t << 1;
  for (; a <= e.heap_len && (a < e.heap_len && Gm(n, e.heap[a + 1], e.heap[a], e.depth) && a++, !Gm(n, l, e.heap[a], e.depth)); )
    e.heap[t] = e.heap[a], t = a, a <<= 1;
  e.heap[t] = l;
}, ym = (e, n, t) => {
  let l, a, d, r, i = 0;
  if (e.sym_next !== 0)
    do
      l = 255 & e.pending_buf[e.sym_buf + i++], l += (255 & e.pending_buf[e.sym_buf + i++]) << 8, a = e.pending_buf[e.sym_buf + i++], l === 0 ? jd(e, a, n) : (d = Os[a], jd(e, d + mW + 1, n), r = yT[d], r !== 0 && (a -= uW[d], Ra(e, a, r)), l--, d = Yk(l), jd(e, d, t), r = uN[d], r !== 0 && (l -= PN[d], Ra(e, l, r)));
    while (i < e.sym_next);
  jd(e, 256, n);
}, $h = (e, n) => {
  const t = n.dyn_tree, l = n.stat_desc.static_tree, a = n.stat_desc.has_stree, d = n.stat_desc.elems;
  let r, i, c, V = -1;
  for (e.heap_len = 0, e.heap_max = 573, r = 0; r < d; r++)
    t[2 * r] !== 0 ? (e.heap[++e.heap_len] = V = r, e.depth[r] = 0) : t[2 * r + 1] = 0;
  for (; e.heap_len < 2; )
    c = e.heap[++e.heap_len] = V < 2 ? ++V : 0, t[2 * c] = 1, e.depth[c] = 0, e.opt_len--, a && (e.static_len -= l[2 * c + 1]);
  for (n.max_code = V, r = e.heap_len >> 1; r >= 1; r--)
    qh(e, t, r);
  c = d;
  do
    r = e.heap[1], e.heap[1] = e.heap[e.heap_len--], qh(e, t, 1), i = e.heap[1], e.heap[--e.heap_max] = r, e.heap[--e.heap_max] = i, t[2 * c] = t[2 * r] + t[2 * i], e.depth[c] = (e.depth[r] >= e.depth[i] ? e.depth[r] : e.depth[i]) + 1, t[2 * r + 1] = t[2 * i + 1] = c, e.heap[1] = c++, qh(e, t, 1);
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[1], ((s, o) => {
    const U = o.dyn_tree, N = o.max_code, R = o.stat_desc.static_tree, h = o.stat_desc.has_stree, Z = o.stat_desc.extra_bits, W = o.stat_desc.extra_base, F = o.stat_desc.max_length;
    let m, E, u, b, k, Q, S = 0;
    for (b = 0; b <= Ds; b++)
      s.bl_count[b] = 0;
    for (U[2 * s.heap[s.heap_max] + 1] = 0, m = s.heap_max + 1; m < 573; m++)
      E = s.heap[m], b = U[2 * U[2 * E + 1] + 1] + 1, b > F && (b = F, S++), U[2 * E + 1] = b, E > N || (s.bl_count[b]++, k = 0, E >= W && (k = Z[E - W]), Q = U[2 * E], s.opt_len += Q * (b + k), h && (s.static_len += Q * (R[2 * E + 1] + k)));
    if (S !== 0) {
      do {
        for (b = F - 1; s.bl_count[b] === 0; )
          b--;
        s.bl_count[b]--, s.bl_count[b + 1] += 2, s.bl_count[F]--, S -= 2;
      } while (S > 0);
      for (b = F; b !== 0; b--)
        for (E = s.bl_count[b]; E !== 0; )
          u = s.heap[--m], u > N || (U[2 * u + 1] !== b && (s.opt_len += (b - U[2 * u + 1]) * U[2 * u], U[2 * u + 1] = b), E--);
    }
  })(e, n), Jk(t, V, e.bl_count);
}, Bm = (e, n, t) => {
  let l, a, d = -1, r = n[1], i = 0, c = 7, V = 4;
  for (r === 0 && (c = 138, V = 3), n[2 * (t + 1) + 1] = 65535, l = 0; l <= t; l++)
    a = r, r = n[2 * (l + 1) + 1], ++i < c && a === r || (i < V ? e.bl_tree[2 * a] += i : a !== 0 ? (a !== d && e.bl_tree[2 * a]++, e.bl_tree[32]++) : i <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++, i = 0, d = a, r === 0 ? (c = 138, V = 3) : a === r ? (c = 6, V = 3) : (c = 7, V = 4));
}, Dm = (e, n, t) => {
  let l, a, d = -1, r = n[1], i = 0, c = 7, V = 4;
  for (r === 0 && (c = 138, V = 3), l = 0; l <= t; l++)
    if (a = r, r = n[2 * (l + 1) + 1], !(++i < c && a === r)) {
      if (i < V)
        do
          jd(e, a, e.bl_tree);
        while (--i != 0);
      else
        a !== 0 ? (a !== d && (jd(e, a, e.bl_tree), i--), jd(e, 16, e.bl_tree), Ra(e, i - 3, 2)) : i <= 10 ? (jd(e, 17, e.bl_tree), Ra(e, i - 3, 3)) : (jd(e, 18, e.bl_tree), Ra(e, i - 11, 7));
      i = 0, d = a, r === 0 ? (c = 138, V = 3) : a === r ? (c = 6, V = 3) : (c = 7, V = 4);
    }
};
let Xm = !1;
const xk = (e, n, t, l) => {
  Ra(e, 0 + (l ? 1 : 0), 3), zk(e), To(e, t), To(e, ~t), t && e.pending_buf.set(e.window.subarray(n, n + t), e.pending), e.pending += t;
};
var bx = (e, n, t, l) => {
  let a, d, r = 0;
  e.level > 0 ? (e.strm.data_type === 2 && (e.strm.data_type = ((i) => {
    let c, V = 4093624447;
    for (c = 0; c <= 31; c++, V >>>= 1)
      if (1 & V && i.dyn_ltree[2 * c] !== 0)
        return 0;
    if (i.dyn_ltree[18] !== 0 || i.dyn_ltree[20] !== 0 || i.dyn_ltree[26] !== 0)
      return 1;
    for (c = 32; c < mW; c++)
      if (i.dyn_ltree[2 * c] !== 0)
        return 1;
    return 0;
  })(e)), $h(e, e.l_desc), $h(e, e.d_desc), r = ((i) => {
    let c;
    for (Bm(i, i.dyn_ltree, i.l_desc.max_code), Bm(i, i.dyn_dtree, i.d_desc.max_code), $h(i, i.bl_desc), c = 18; c >= 3 && i.bl_tree[2 * Jm[c] + 1] === 0; c--)
      ;
    return i.opt_len += 3 * (c + 1) + 5 + 5 + 4, c;
  })(e), a = e.opt_len + 3 + 7 >>> 3, d = e.static_len + 3 + 7 >>> 3, d <= a && (a = d)) : a = d = t + 5, t + 4 <= a && n !== -1 ? xk(e, n, t, l) : e.strategy === 4 || d === a ? (Ra(e, 2 + (l ? 1 : 0), 3), ym(e, Ur, Xs)) : (Ra(e, 4 + (l ? 1 : 0), 3), ((i, c, V, s) => {
    let o;
    for (Ra(i, c - 257, 5), Ra(i, V - 1, 5), Ra(i, s - 4, 4), o = 0; o < s; o++)
      Ra(i, i.bl_tree[2 * Jm[o] + 1], 3);
    Dm(i, i.dyn_ltree, c - 1), Dm(i, i.dyn_dtree, V - 1);
  })(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, r + 1), ym(e, e.dyn_ltree, e.dyn_dtree)), vk(e), l && zk(e);
}, Yx = { _tr_init: (e) => {
  Xm || ((() => {
    let n, t, l, a, d;
    const r = new Array(16);
    for (l = 0, a = 0; a < 28; a++)
      for (uW[a] = l, n = 0; n < 1 << yT[a]; n++)
        Os[l++] = a;
    for (Os[l - 1] = a, d = 0, a = 0; a < 16; a++)
      for (PN[a] = d, n = 0; n < 1 << uN[a]; n++)
        Zo[d++] = a;
    for (d >>= 7; a < Bs; a++)
      for (PN[a] = d << 7, n = 0; n < 1 << uN[a] - 7; n++)
        Zo[256 + d++] = a;
    for (t = 0; t <= Ds; t++)
      r[t] = 0;
    for (n = 0; n <= 143; )
      Ur[2 * n + 1] = 8, n++, r[8]++;
    for (; n <= 255; )
      Ur[2 * n + 1] = 9, n++, r[9]++;
    for (; n <= 279; )
      Ur[2 * n + 1] = 7, n++, r[7]++;
    for (; n <= 287; )
      Ur[2 * n + 1] = 8, n++, r[8]++;
    for (Jk(Ur, 287, r), n = 0; n < Bs; n++)
      Xs[2 * n + 1] = 5, Xs[2 * n] = Qk(n, 5);
    vm = new Ph(Ur, yT, 257, bk, Ds), zm = new Ph(Xs, uN, 0, Bs, Ds), xm = new Ph(new Array(0), kx, 0, 19, 7);
  })(), Xm = !0), e.l_desc = new Ah(e.dyn_ltree, vm), e.d_desc = new Ah(e.dyn_dtree, zm), e.bl_desc = new Ah(e.bl_tree, xm), e.bi_buf = 0, e.bi_valid = 0, vk(e);
}, _tr_stored_block: xk, _tr_flush_block: bx, _tr_tally: (e, n, t) => (e.pending_buf[e.sym_buf + e.sym_next++] = n, e.pending_buf[e.sym_buf + e.sym_next++] = n >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = t, n === 0 ? e.dyn_ltree[2 * t]++ : (e.matches++, n--, e.dyn_ltree[2 * (Os[t] + mW + 1)]++, e.dyn_dtree[2 * Yk(n)]++), e.sym_next === e.sym_end), _tr_align: (e) => {
  Ra(e, 2, 3), jd(e, 256, Ur), ((n) => {
    n.bi_valid === 16 ? (To(n, n.bi_buf), n.bi_buf = 0, n.bi_valid = 0) : n.bi_valid >= 8 && (n.pending_buf[n.pending++] = 255 & n.bi_buf, n.bi_buf >>= 8, n.bi_valid -= 8);
  })(e);
} }, js = (e, n, t, l) => {
  let a = 65535 & e | 0, d = e >>> 16 & 65535 | 0, r = 0;
  for (; t !== 0; ) {
    r = t > 2e3 ? 2e3 : t, t -= r;
    do
      a = a + n[l++] | 0, d = d + a | 0;
    while (--r);
    a %= 65521, d %= 65521;
  }
  return a | d << 16 | 0;
};
const Qx = new Uint32Array((() => {
  let e, n = [];
  for (var t = 0; t < 256; t++) {
    e = t;
    for (var l = 0; l < 8; l++)
      e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
    n[t] = e;
  }
  return n;
})());
var El = (e, n, t, l) => {
  const a = Qx, d = l + t;
  e ^= -1;
  for (let r = l; r < d; r++)
    e = e >>> 8 ^ a[255 & (e ^ n[r])];
  return -1 ^ e;
}, EV = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, GV = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
const { _tr_init: Jx, _tr_stored_block: BT, _tr_flush_block: vx, _tr_tally: Ui, _tr_align: zx } = Yx, { Z_NO_FLUSH: Ni, Z_PARTIAL_FLUSH: xx, Z_FULL_FLUSH: Gx, Z_FINISH: qa, Z_BLOCK: Om, Z_OK: zl, Z_STREAM_END: jm, Z_STREAM_ERROR: Jd, Z_DATA_ERROR: yx, Z_BUF_ERROR: eZ, Z_DEFAULT_COMPRESSION: Bx, Z_FILTERED: Dx, Z_HUFFMAN_ONLY: yU, Z_RLE: Xx, Z_FIXED: Ox, Z_DEFAULT_STRATEGY: jx, Z_UNKNOWN: Hx, Z_DEFLATED: AN } = GV, eV = 258, Ld = 262, lc = 42, Ii = 113, Ms = 666, Li = (e, n) => (e.msg = EV[n], n), Hm = (e) => 2 * e - (e > 4 ? 9 : 0), qr = (e) => {
  let n = e.length;
  for (; --n >= 0; )
    e[n] = 0;
}, fx = (e) => {
  let n, t, l, a = e.w_size;
  n = e.hash_size, l = n;
  do
    t = e.head[--l], e.head[l] = t >= a ? t - a : 0;
  while (--n);
  n = a, l = n;
  do
    t = e.prev[--l], e.prev[l] = t >= a ? t - a : 0;
  while (--n);
};
let Ri = (e, n, t) => (n << e.hash_shift ^ t) & e.hash_mask;
const ka = (e) => {
  const n = e.state;
  let t = n.pending;
  t > e.avail_out && (t = e.avail_out), t !== 0 && (e.output.set(n.pending_buf.subarray(n.pending_out, n.pending_out + t), e.next_out), e.next_out += t, n.pending_out += t, e.total_out += t, e.avail_out -= t, n.pending -= t, n.pending === 0 && (n.pending_out = 0));
}, za = (e, n) => {
  vx(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, n), e.block_start = e.strstart, ka(e.strm);
}, pn = (e, n) => {
  e.pending_buf[e.pending++] = n;
}, ts = (e, n) => {
  e.pending_buf[e.pending++] = n >>> 8 & 255, e.pending_buf[e.pending++] = 255 & n;
}, DT = (e, n, t, l) => {
  let a = e.avail_in;
  return a > l && (a = l), a === 0 ? 0 : (e.avail_in -= a, n.set(e.input.subarray(e.next_in, e.next_in + a), t), e.state.wrap === 1 ? e.adler = js(e.adler, n, a, t) : e.state.wrap === 2 && (e.adler = El(e.adler, n, a, t)), e.next_in += a, e.total_in += a, a);
}, Gk = (e, n) => {
  let t, l, a = e.max_chain_length, d = e.strstart, r = e.prev_length, i = e.nice_match;
  const c = e.strstart > e.w_size - Ld ? e.strstart - (e.w_size - Ld) : 0, V = e.window, s = e.w_mask, o = e.prev, U = e.strstart + eV;
  let N = V[d + r - 1], R = V[d + r];
  e.prev_length >= e.good_match && (a >>= 2), i > e.lookahead && (i = e.lookahead);
  do
    if (t = n, V[t + r] === R && V[t + r - 1] === N && V[t] === V[d] && V[++t] === V[d + 1]) {
      d += 2, t++;
      do
        ;
      while (V[++d] === V[++t] && V[++d] === V[++t] && V[++d] === V[++t] && V[++d] === V[++t] && V[++d] === V[++t] && V[++d] === V[++t] && V[++d] === V[++t] && V[++d] === V[++t] && d < U);
      if (l = eV - (U - d), d = U - eV, l > r) {
        if (e.match_start = n, r = l, l >= i)
          break;
        N = V[d + r - 1], R = V[d + r];
      }
    }
  while ((n = o[n & s]) > c && --a != 0);
  return r <= e.lookahead ? r : e.lookahead;
}, AV = (e) => {
  const n = e.w_size;
  let t, l, a;
  do {
    if (l = e.window_size - e.lookahead - e.strstart, e.strstart >= n + (n - Ld) && (e.window.set(e.window.subarray(n, n + n - l), 0), e.match_start -= n, e.strstart -= n, e.block_start -= n, e.insert > e.strstart && (e.insert = e.strstart), fx(e), l += n), e.strm.avail_in === 0)
      break;
    if (t = DT(e.strm, e.window, e.strstart + e.lookahead, l), e.lookahead += t, e.lookahead + e.insert >= 3)
      for (a = e.strstart - e.insert, e.ins_h = e.window[a], e.ins_h = Ri(e, e.ins_h, e.window[a + 1]); e.insert && (e.ins_h = Ri(e, e.ins_h, e.window[a + 3 - 1]), e.prev[a & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = a, a++, e.insert--, !(e.lookahead + e.insert < 3)); )
        ;
  } while (e.lookahead < Ld && e.strm.avail_in !== 0);
}, yk = (e, n) => {
  let t, l, a, d = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, r = 0, i = e.strm.avail_in;
  do {
    if (t = 65535, a = e.bi_valid + 42 >> 3, e.strm.avail_out < a || (a = e.strm.avail_out - a, l = e.strstart - e.block_start, t > l + e.strm.avail_in && (t = l + e.strm.avail_in), t > a && (t = a), t < d && (t === 0 && n !== qa || n === Ni || t !== l + e.strm.avail_in)))
      break;
    r = n === qa && t === l + e.strm.avail_in ? 1 : 0, BT(e, 0, 0, r), e.pending_buf[e.pending - 4] = t, e.pending_buf[e.pending - 3] = t >> 8, e.pending_buf[e.pending - 2] = ~t, e.pending_buf[e.pending - 1] = ~t >> 8, ka(e.strm), l && (l > t && (l = t), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + l), e.strm.next_out), e.strm.next_out += l, e.strm.avail_out -= l, e.strm.total_out += l, e.block_start += l, t -= l), t && (DT(e.strm, e.strm.output, e.strm.next_out, t), e.strm.next_out += t, e.strm.avail_out -= t, e.strm.total_out += t);
  } while (r === 0);
  return i -= e.strm.avail_in, i && (i >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= i && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - i, e.strm.next_in), e.strstart), e.strstart += i, e.insert += i > e.w_size - e.insert ? e.w_size - e.insert : i), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), r ? 4 : n !== Ni && n !== qa && e.strm.avail_in === 0 && e.strstart === e.block_start ? 2 : (a = e.window_size - e.strstart, e.strm.avail_in > a && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, a += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), a > e.strm.avail_in && (a = e.strm.avail_in), a && (DT(e.strm, e.window, e.strstart, a), e.strstart += a, e.insert += a > e.w_size - e.insert ? e.w_size - e.insert : a), e.high_water < e.strstart && (e.high_water = e.strstart), a = e.bi_valid + 42 >> 3, a = e.pending_buf_size - a > 65535 ? 65535 : e.pending_buf_size - a, d = a > e.w_size ? e.w_size : a, l = e.strstart - e.block_start, (l >= d || (l || n === qa) && n !== Ni && e.strm.avail_in === 0 && l <= a) && (t = l > a ? a : l, r = n === qa && e.strm.avail_in === 0 && t === l ? 1 : 0, BT(e, e.block_start, t, r), e.block_start += t, ka(e.strm)), r ? 3 : 1);
}, tZ = (e, n) => {
  let t, l;
  for (; ; ) {
    if (e.lookahead < Ld) {
      if (AV(e), e.lookahead < Ld && n === Ni)
        return 1;
      if (e.lookahead === 0)
        break;
    }
    if (t = 0, e.lookahead >= 3 && (e.ins_h = Ri(e, e.ins_h, e.window[e.strstart + 3 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), t !== 0 && e.strstart - t <= e.w_size - Ld && (e.match_length = Gk(e, t)), e.match_length >= 3)
      if (l = Ui(e, e.strstart - e.match_start, e.match_length - 3), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= 3) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = Ri(e, e.ins_h, e.window[e.strstart + 3 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length != 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = Ri(e, e.ins_h, e.window[e.strstart + 1]);
    else
      l = Ui(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (l && (za(e, !1), e.strm.avail_out === 0))
      return 1;
  }
  return e.insert = e.strstart < 2 ? e.strstart : 2, n === qa ? (za(e, !0), e.strm.avail_out === 0 ? 3 : 4) : e.sym_next && (za(e, !1), e.strm.avail_out === 0) ? 1 : 2;
}, fV = (e, n) => {
  let t, l, a;
  for (; ; ) {
    if (e.lookahead < Ld) {
      if (AV(e), e.lookahead < Ld && n === Ni)
        return 1;
      if (e.lookahead === 0)
        break;
    }
    if (t = 0, e.lookahead >= 3 && (e.ins_h = Ri(e, e.ins_h, e.window[e.strstart + 3 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = 2, t !== 0 && e.prev_length < e.max_lazy_match && e.strstart - t <= e.w_size - Ld && (e.match_length = Gk(e, t), e.match_length <= 5 && (e.strategy === Dx || e.match_length === 3 && e.strstart - e.match_start > 4096) && (e.match_length = 2)), e.prev_length >= 3 && e.match_length <= e.prev_length) {
      a = e.strstart + e.lookahead - 3, l = Ui(e, e.strstart - 1 - e.prev_match, e.prev_length - 3), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= a && (e.ins_h = Ri(e, e.ins_h, e.window[e.strstart + 3 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length != 0);
      if (e.match_available = 0, e.match_length = 2, e.strstart++, l && (za(e, !1), e.strm.avail_out === 0))
        return 1;
    } else if (e.match_available) {
      if (l = Ui(e, 0, e.window[e.strstart - 1]), l && za(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return 1;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (l = Ui(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < 2 ? e.strstart : 2, n === qa ? (za(e, !0), e.strm.avail_out === 0 ? 3 : 4) : e.sym_next && (za(e, !1), e.strm.avail_out === 0) ? 1 : 2;
};
function Yd(e, n, t, l, a) {
  this.good_length = e, this.max_lazy = n, this.nice_length = t, this.max_chain = l, this.func = a;
}
const Es = [new Yd(0, 0, 0, 0, yk), new Yd(4, 4, 8, 4, tZ), new Yd(4, 5, 16, 8, tZ), new Yd(4, 6, 32, 32, tZ), new Yd(4, 4, 16, 16, fV), new Yd(8, 16, 32, 32, fV), new Yd(8, 16, 128, 128, fV), new Yd(8, 32, 128, 256, fV), new Yd(32, 128, 258, 1024, fV), new Yd(32, 258, 258, 4096, fV)];
function wx() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = AN, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), qr(this.dyn_ltree), qr(this.dyn_dtree), qr(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), qr(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), qr(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const Ss = (e) => {
  if (!e)
    return 1;
  const n = e.state;
  return !n || n.strm !== e || n.status !== lc && n.status !== 57 && n.status !== 69 && n.status !== 73 && n.status !== 91 && n.status !== 103 && n.status !== Ii && n.status !== Ms ? 1 : 0;
}, Bk = (e) => {
  if (Ss(e))
    return Li(e, Jd);
  e.total_in = e.total_out = 0, e.data_type = Hx;
  const n = e.state;
  return n.pending = 0, n.pending_out = 0, n.wrap < 0 && (n.wrap = -n.wrap), n.status = n.wrap === 2 ? 57 : n.wrap ? lc : Ii, e.adler = n.wrap === 2 ? 0 : 1, n.last_flush = -2, Jx(n), zl;
}, Dk = (e) => {
  const n = Bk(e);
  var t;
  return n === zl && ((t = e.state).window_size = 2 * t.w_size, qr(t.head), t.max_lazy_match = Es[t.level].max_lazy, t.good_match = Es[t.level].good_length, t.nice_match = Es[t.level].nice_length, t.max_chain_length = Es[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = 2, t.match_available = 0, t.ins_h = 0), n;
}, fm = (e, n, t, l, a, d) => {
  if (!e)
    return Jd;
  let r = 1;
  if (n === Bx && (n = 6), l < 0 ? (r = 0, l = -l) : l > 15 && (r = 2, l -= 16), a < 1 || a > 9 || t !== AN || l < 8 || l > 15 || n < 0 || n > 9 || d < 0 || d > Ox || l === 8 && r !== 1)
    return Li(e, Jd);
  l === 8 && (l = 9);
  const i = new wx();
  return e.state = i, i.strm = e, i.status = lc, i.wrap = r, i.gzhead = null, i.w_bits = l, i.w_size = 1 << i.w_bits, i.w_mask = i.w_size - 1, i.hash_bits = a + 7, i.hash_size = 1 << i.hash_bits, i.hash_mask = i.hash_size - 1, i.hash_shift = ~~((i.hash_bits + 3 - 1) / 3), i.window = new Uint8Array(2 * i.w_size), i.head = new Uint16Array(i.hash_size), i.prev = new Uint16Array(i.w_size), i.lit_bufsize = 1 << a + 6, i.pending_buf_size = 4 * i.lit_bufsize, i.pending_buf = new Uint8Array(i.pending_buf_size), i.sym_buf = i.lit_bufsize, i.sym_end = 3 * (i.lit_bufsize - 1), i.level = n, i.strategy = d, i.method = t, Dk(e);
};
var Hs = { deflateInit: (e, n) => fm(e, n, AN, 15, 8, jx), deflateInit2: fm, deflateReset: Dk, deflateResetKeep: Bk, deflateSetHeader: (e, n) => Ss(e) || e.state.wrap !== 2 ? Jd : (e.state.gzhead = n, zl), deflate: (e, n) => {
  if (Ss(e) || n > Om || n < 0)
    return e ? Li(e, Jd) : Jd;
  const t = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || t.status === Ms && n !== qa)
    return Li(e, e.avail_out === 0 ? eZ : Jd);
  const l = t.last_flush;
  if (t.last_flush = n, t.pending !== 0) {
    if (ka(e), e.avail_out === 0)
      return t.last_flush = -1, zl;
  } else if (e.avail_in === 0 && Hm(n) <= Hm(l) && n !== qa)
    return Li(e, eZ);
  if (t.status === Ms && e.avail_in !== 0)
    return Li(e, eZ);
  if (t.status === lc && t.wrap === 0 && (t.status = Ii), t.status === lc) {
    let a = AN + (t.w_bits - 8 << 4) << 8, d = -1;
    if (d = t.strategy >= yU || t.level < 2 ? 0 : t.level < 6 ? 1 : t.level === 6 ? 2 : 3, a |= d << 6, t.strstart !== 0 && (a |= 32), a += 31 - a % 31, ts(t, a), t.strstart !== 0 && (ts(t, e.adler >>> 16), ts(t, 65535 & e.adler)), e.adler = 1, t.status = Ii, ka(e), t.pending !== 0)
      return t.last_flush = -1, zl;
  }
  if (t.status === 57) {
    if (e.adler = 0, pn(t, 31), pn(t, 139), pn(t, 8), t.gzhead)
      pn(t, (t.gzhead.text ? 1 : 0) + (t.gzhead.hcrc ? 2 : 0) + (t.gzhead.extra ? 4 : 0) + (t.gzhead.name ? 8 : 0) + (t.gzhead.comment ? 16 : 0)), pn(t, 255 & t.gzhead.time), pn(t, t.gzhead.time >> 8 & 255), pn(t, t.gzhead.time >> 16 & 255), pn(t, t.gzhead.time >> 24 & 255), pn(t, t.level === 9 ? 2 : t.strategy >= yU || t.level < 2 ? 4 : 0), pn(t, 255 & t.gzhead.os), t.gzhead.extra && t.gzhead.extra.length && (pn(t, 255 & t.gzhead.extra.length), pn(t, t.gzhead.extra.length >> 8 & 255)), t.gzhead.hcrc && (e.adler = El(e.adler, t.pending_buf, t.pending, 0)), t.gzindex = 0, t.status = 69;
    else if (pn(t, 0), pn(t, 0), pn(t, 0), pn(t, 0), pn(t, 0), pn(t, t.level === 9 ? 2 : t.strategy >= yU || t.level < 2 ? 4 : 0), pn(t, 3), t.status = Ii, ka(e), t.pending !== 0)
      return t.last_flush = -1, zl;
  }
  if (t.status === 69) {
    if (t.gzhead.extra) {
      let a = t.pending, d = (65535 & t.gzhead.extra.length) - t.gzindex;
      for (; t.pending + d > t.pending_buf_size; ) {
        let i = t.pending_buf_size - t.pending;
        if (t.pending_buf.set(t.gzhead.extra.subarray(t.gzindex, t.gzindex + i), t.pending), t.pending = t.pending_buf_size, t.gzhead.hcrc && t.pending > a && (e.adler = El(e.adler, t.pending_buf, t.pending - a, a)), t.gzindex += i, ka(e), t.pending !== 0)
          return t.last_flush = -1, zl;
        a = 0, d -= i;
      }
      let r = new Uint8Array(t.gzhead.extra);
      t.pending_buf.set(r.subarray(t.gzindex, t.gzindex + d), t.pending), t.pending += d, t.gzhead.hcrc && t.pending > a && (e.adler = El(e.adler, t.pending_buf, t.pending - a, a)), t.gzindex = 0;
    }
    t.status = 73;
  }
  if (t.status === 73) {
    if (t.gzhead.name) {
      let a, d = t.pending;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > d && (e.adler = El(e.adler, t.pending_buf, t.pending - d, d)), ka(e), t.pending !== 0)
            return t.last_flush = -1, zl;
          d = 0;
        }
        a = t.gzindex < t.gzhead.name.length ? 255 & t.gzhead.name.charCodeAt(t.gzindex++) : 0, pn(t, a);
      } while (a !== 0);
      t.gzhead.hcrc && t.pending > d && (e.adler = El(e.adler, t.pending_buf, t.pending - d, d)), t.gzindex = 0;
    }
    t.status = 91;
  }
  if (t.status === 91) {
    if (t.gzhead.comment) {
      let a, d = t.pending;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > d && (e.adler = El(e.adler, t.pending_buf, t.pending - d, d)), ka(e), t.pending !== 0)
            return t.last_flush = -1, zl;
          d = 0;
        }
        a = t.gzindex < t.gzhead.comment.length ? 255 & t.gzhead.comment.charCodeAt(t.gzindex++) : 0, pn(t, a);
      } while (a !== 0);
      t.gzhead.hcrc && t.pending > d && (e.adler = El(e.adler, t.pending_buf, t.pending - d, d));
    }
    t.status = 103;
  }
  if (t.status === 103) {
    if (t.gzhead.hcrc) {
      if (t.pending + 2 > t.pending_buf_size && (ka(e), t.pending !== 0))
        return t.last_flush = -1, zl;
      pn(t, 255 & e.adler), pn(t, e.adler >> 8 & 255), e.adler = 0;
    }
    if (t.status = Ii, ka(e), t.pending !== 0)
      return t.last_flush = -1, zl;
  }
  if (e.avail_in !== 0 || t.lookahead !== 0 || n !== Ni && t.status !== Ms) {
    let a = t.level === 0 ? yk(t, n) : t.strategy === yU ? ((d, r) => {
      let i;
      for (; ; ) {
        if (d.lookahead === 0 && (AV(d), d.lookahead === 0)) {
          if (r === Ni)
            return 1;
          break;
        }
        if (d.match_length = 0, i = Ui(d, 0, d.window[d.strstart]), d.lookahead--, d.strstart++, i && (za(d, !1), d.strm.avail_out === 0))
          return 1;
      }
      return d.insert = 0, r === qa ? (za(d, !0), d.strm.avail_out === 0 ? 3 : 4) : d.sym_next && (za(d, !1), d.strm.avail_out === 0) ? 1 : 2;
    })(t, n) : t.strategy === Xx ? ((d, r) => {
      let i, c, V, s;
      const o = d.window;
      for (; ; ) {
        if (d.lookahead <= eV) {
          if (AV(d), d.lookahead <= eV && r === Ni)
            return 1;
          if (d.lookahead === 0)
            break;
        }
        if (d.match_length = 0, d.lookahead >= 3 && d.strstart > 0 && (V = d.strstart - 1, c = o[V], c === o[++V] && c === o[++V] && c === o[++V])) {
          s = d.strstart + eV;
          do
            ;
          while (c === o[++V] && c === o[++V] && c === o[++V] && c === o[++V] && c === o[++V] && c === o[++V] && c === o[++V] && c === o[++V] && V < s);
          d.match_length = eV - (s - V), d.match_length > d.lookahead && (d.match_length = d.lookahead);
        }
        if (d.match_length >= 3 ? (i = Ui(d, 1, d.match_length - 3), d.lookahead -= d.match_length, d.strstart += d.match_length, d.match_length = 0) : (i = Ui(d, 0, d.window[d.strstart]), d.lookahead--, d.strstart++), i && (za(d, !1), d.strm.avail_out === 0))
          return 1;
      }
      return d.insert = 0, r === qa ? (za(d, !0), d.strm.avail_out === 0 ? 3 : 4) : d.sym_next && (za(d, !1), d.strm.avail_out === 0) ? 1 : 2;
    })(t, n) : Es[t.level].func(t, n);
    if (a !== 3 && a !== 4 || (t.status = Ms), a === 1 || a === 3)
      return e.avail_out === 0 && (t.last_flush = -1), zl;
    if (a === 2 && (n === xx ? zx(t) : n !== Om && (BT(t, 0, 0, !1), n === Gx && (qr(t.head), t.lookahead === 0 && (t.strstart = 0, t.block_start = 0, t.insert = 0))), ka(e), e.avail_out === 0))
      return t.last_flush = -1, zl;
  }
  return n !== qa ? zl : t.wrap <= 0 ? jm : (t.wrap === 2 ? (pn(t, 255 & e.adler), pn(t, e.adler >> 8 & 255), pn(t, e.adler >> 16 & 255), pn(t, e.adler >> 24 & 255), pn(t, 255 & e.total_in), pn(t, e.total_in >> 8 & 255), pn(t, e.total_in >> 16 & 255), pn(t, e.total_in >> 24 & 255)) : (ts(t, e.adler >>> 16), ts(t, 65535 & e.adler)), ka(e), t.wrap > 0 && (t.wrap = -t.wrap), t.pending !== 0 ? zl : jm);
}, deflateEnd: (e) => {
  if (Ss(e))
    return Jd;
  const n = e.state.status;
  return e.state = null, n === Ii ? Li(e, yx) : zl;
}, deflateSetDictionary: (e, n) => {
  let t = n.length;
  if (Ss(e))
    return Jd;
  const l = e.state, a = l.wrap;
  if (a === 2 || a === 1 && l.status !== lc || l.lookahead)
    return Jd;
  if (a === 1 && (e.adler = js(e.adler, n, t, 0)), l.wrap = 0, t >= l.w_size) {
    a === 0 && (qr(l.head), l.strstart = 0, l.block_start = 0, l.insert = 0);
    let c = new Uint8Array(l.w_size);
    c.set(n.subarray(t - l.w_size, t), 0), n = c, t = l.w_size;
  }
  const d = e.avail_in, r = e.next_in, i = e.input;
  for (e.avail_in = t, e.next_in = 0, e.input = n, AV(l); l.lookahead >= 3; ) {
    let c = l.strstart, V = l.lookahead - 2;
    do
      l.ins_h = Ri(l, l.ins_h, l.window[c + 3 - 1]), l.prev[c & l.w_mask] = l.head[l.ins_h], l.head[l.ins_h] = c, c++;
    while (--V);
    l.strstart = c, l.lookahead = 2, AV(l);
  }
  return l.strstart += l.lookahead, l.block_start = l.strstart, l.insert = l.lookahead, l.lookahead = 0, l.match_length = l.prev_length = 2, l.match_available = 0, e.next_in = r, e.input = i, e.avail_in = d, l.wrap = a, zl;
}, deflateInfo: "pako deflate (from Nodeca project)" };
const gx = (e, n) => Object.prototype.hasOwnProperty.call(e, n);
var fR = { assign: function(e) {
  const n = Array.prototype.slice.call(arguments, 1);
  for (; n.length; ) {
    const t = n.shift();
    if (t) {
      if (typeof t != "object")
        throw new TypeError(t + "must be non-object");
      for (const l in t)
        gx(t, l) && (e[l] = t[l]);
    }
  }
  return e;
}, flattenChunks: (e) => {
  let n = 0;
  for (let l = 0, a = e.length; l < a; l++)
    n += e[l].length;
  const t = new Uint8Array(n);
  for (let l = 0, a = 0, d = e.length; l < d; l++) {
    let r = e[l];
    t.set(r, a), a += r.length;
  }
  return t;
} };
let Xk = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  Xk = !1;
}
const Fo = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  Fo[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
Fo[254] = Fo[254] = 1;
var Wo = { string2buf: (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let n, t, l, a, d, r = e.length, i = 0;
  for (a = 0; a < r; a++)
    t = e.charCodeAt(a), (64512 & t) == 55296 && a + 1 < r && (l = e.charCodeAt(a + 1), (64512 & l) == 56320 && (t = 65536 + (t - 55296 << 10) + (l - 56320), a++)), i += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
  for (n = new Uint8Array(i), d = 0, a = 0; d < i; a++)
    t = e.charCodeAt(a), (64512 & t) == 55296 && a + 1 < r && (l = e.charCodeAt(a + 1), (64512 & l) == 56320 && (t = 65536 + (t - 55296 << 10) + (l - 56320), a++)), t < 128 ? n[d++] = t : t < 2048 ? (n[d++] = 192 | t >>> 6, n[d++] = 128 | 63 & t) : t < 65536 ? (n[d++] = 224 | t >>> 12, n[d++] = 128 | t >>> 6 & 63, n[d++] = 128 | 63 & t) : (n[d++] = 240 | t >>> 18, n[d++] = 128 | t >>> 12 & 63, n[d++] = 128 | t >>> 6 & 63, n[d++] = 128 | 63 & t);
  return n;
}, buf2string: (e, n) => {
  const t = n || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, n));
  let l, a;
  const d = new Array(2 * t);
  for (a = 0, l = 0; l < t; ) {
    let r = e[l++];
    if (r < 128) {
      d[a++] = r;
      continue;
    }
    let i = Fo[r];
    if (i > 4)
      d[a++] = 65533, l += i - 1;
    else {
      for (r &= i === 2 ? 31 : i === 3 ? 15 : 7; i > 1 && l < t; )
        r = r << 6 | 63 & e[l++], i--;
      i > 1 ? d[a++] = 65533 : r < 65536 ? d[a++] = r : (r -= 65536, d[a++] = 55296 | r >> 10 & 1023, d[a++] = 56320 | 1023 & r);
    }
  }
  return ((r, i) => {
    if (i < 65534 && r.subarray && Xk)
      return String.fromCharCode.apply(null, r.length === i ? r : r.subarray(0, i));
    let c = "";
    for (let V = 0; V < i; V++)
      c += String.fromCharCode(r[V]);
    return c;
  })(d, a);
}, utf8border: (e, n) => {
  (n = n || e.length) > e.length && (n = e.length);
  let t = n - 1;
  for (; t >= 0 && (192 & e[t]) == 128; )
    t--;
  return t < 0 || t === 0 ? n : t + Fo[e[t]] > n ? t : n;
} }, Ok = function() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
};
const jk = Object.prototype.toString, { Z_NO_FLUSH: Ix, Z_SYNC_FLUSH: Lx, Z_FULL_FLUSH: Cx, Z_FINISH: Kx, Z_OK: qN, Z_STREAM_END: _x, Z_DEFAULT_COMPRESSION: Px, Z_DEFAULT_STRATEGY: Ax, Z_DEFLATED: qx } = GV;
function fs(e) {
  this.options = fR.assign({ level: Px, method: qx, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Ax }, e || {});
  let n = this.options;
  n.raw && n.windowBits > 0 ? n.windowBits = -n.windowBits : n.gzip && n.windowBits > 0 && n.windowBits < 16 && (n.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Ok(), this.strm.avail_out = 0;
  let t = Hs.deflateInit2(this.strm, n.level, n.method, n.windowBits, n.memLevel, n.strategy);
  if (t !== qN)
    throw new Error(EV[t]);
  if (n.header && Hs.deflateSetHeader(this.strm, n.header), n.dictionary) {
    let l;
    if (l = typeof n.dictionary == "string" ? Wo.string2buf(n.dictionary) : jk.call(n.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(n.dictionary) : n.dictionary, t = Hs.deflateSetDictionary(this.strm, l), t !== qN)
      throw new Error(EV[t]);
    this._dict_set = !0;
  }
}
function nZ(e, n) {
  const t = new fs(n);
  if (t.push(e, !0), t.err)
    throw t.msg || EV[t.err];
  return t.result;
}
fs.prototype.push = function(e, n) {
  const t = this.strm, l = this.options.chunkSize;
  let a, d;
  if (this.ended)
    return !1;
  for (d = n === ~~n ? n : n === !0 ? Kx : Ix, typeof e == "string" ? t.input = Wo.string2buf(e) : jk.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length; ; )
    if (t.avail_out === 0 && (t.output = new Uint8Array(l), t.next_out = 0, t.avail_out = l), (d === Lx || d === Cx) && t.avail_out <= 6)
      this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
    else {
      if (a = Hs.deflate(t, d), a === _x)
        return t.next_out > 0 && this.onData(t.output.subarray(0, t.next_out)), a = Hs.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === qN;
      if (t.avail_out !== 0) {
        if (d > 0 && t.next_out > 0)
          this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
        else if (t.avail_in === 0)
          break;
      } else
        this.onData(t.output);
    }
  return !0;
}, fs.prototype.onData = function(e) {
  this.chunks.push(e);
}, fs.prototype.onEnd = function(e) {
  e === qN && (this.result = fR.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
var $x = { Deflate: fs, deflate: nZ, deflateRaw: function(e, n) {
  return (n = n || {}).raw = !0, nZ(e, n);
}, gzip: function(e, n) {
  return (n = n || {}).gzip = !0, nZ(e, n);
}, constants: GV };
const BU = 16209;
var eG = function(e, n) {
  let t, l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S;
  const v = e.state;
  t = e.next_in, Q = e.input, l = t + (e.avail_in - 5), a = e.next_out, S = e.output, d = a - (n - e.avail_out), r = a + (e.avail_out - 257), i = v.dmax, c = v.wsize, V = v.whave, s = v.wnext, o = v.window, U = v.hold, N = v.bits, R = v.lencode, h = v.distcode, Z = (1 << v.lenbits) - 1, W = (1 << v.distbits) - 1;
  e:
    do {
      N < 15 && (U += Q[t++] << N, N += 8, U += Q[t++] << N, N += 8), F = R[U & Z];
      t:
        for (; ; ) {
          if (m = F >>> 24, U >>>= m, N -= m, m = F >>> 16 & 255, m === 0)
            S[a++] = 65535 & F;
          else {
            if (!(16 & m)) {
              if (!(64 & m)) {
                F = R[(65535 & F) + (U & (1 << m) - 1)];
                continue t;
              }
              if (32 & m) {
                v.mode = 16191;
                break e;
              }
              e.msg = "invalid literal/length code", v.mode = BU;
              break e;
            }
            E = 65535 & F, m &= 15, m && (N < m && (U += Q[t++] << N, N += 8), E += U & (1 << m) - 1, U >>>= m, N -= m), N < 15 && (U += Q[t++] << N, N += 8, U += Q[t++] << N, N += 8), F = h[U & W];
            n:
              for (; ; ) {
                if (m = F >>> 24, U >>>= m, N -= m, m = F >>> 16 & 255, !(16 & m)) {
                  if (!(64 & m)) {
                    F = h[(65535 & F) + (U & (1 << m) - 1)];
                    continue n;
                  }
                  e.msg = "invalid distance code", v.mode = BU;
                  break e;
                }
                if (u = 65535 & F, m &= 15, N < m && (U += Q[t++] << N, N += 8, N < m && (U += Q[t++] << N, N += 8)), u += U & (1 << m) - 1, u > i) {
                  e.msg = "invalid distance too far back", v.mode = BU;
                  break e;
                }
                if (U >>>= m, N -= m, m = a - d, u > m) {
                  if (m = u - m, m > V && v.sane) {
                    e.msg = "invalid distance too far back", v.mode = BU;
                    break e;
                  }
                  if (b = 0, k = o, s === 0) {
                    if (b += c - m, m < E) {
                      E -= m;
                      do
                        S[a++] = o[b++];
                      while (--m);
                      b = a - u, k = S;
                    }
                  } else if (s < m) {
                    if (b += c + s - m, m -= s, m < E) {
                      E -= m;
                      do
                        S[a++] = o[b++];
                      while (--m);
                      if (b = 0, s < E) {
                        m = s, E -= m;
                        do
                          S[a++] = o[b++];
                        while (--m);
                        b = a - u, k = S;
                      }
                    }
                  } else if (b += s - m, m < E) {
                    E -= m;
                    do
                      S[a++] = o[b++];
                    while (--m);
                    b = a - u, k = S;
                  }
                  for (; E > 2; )
                    S[a++] = k[b++], S[a++] = k[b++], S[a++] = k[b++], E -= 3;
                  E && (S[a++] = k[b++], E > 1 && (S[a++] = k[b++]));
                } else {
                  b = a - u;
                  do
                    S[a++] = S[b++], S[a++] = S[b++], S[a++] = S[b++], E -= 3;
                  while (E > 2);
                  E && (S[a++] = S[b++], E > 1 && (S[a++] = S[b++]));
                }
                break;
              }
          }
          break;
        }
    } while (t < l && a < r);
  E = N >> 3, t -= E, N -= E << 3, U &= (1 << N) - 1, e.next_in = t, e.next_out = a, e.avail_in = t < l ? l - t + 5 : 5 - (t - l), e.avail_out = a < r ? r - a + 257 : 257 - (a - r), v.hold = U, v.bits = N;
};
const DU = 15, tG = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), nG = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), lG = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), aG = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
var ws = (e, n, t, l, a, d, r, i) => {
  const c = i.bits;
  let V, s, o, U, N, R, h = 0, Z = 0, W = 0, F = 0, m = 0, E = 0, u = 0, b = 0, k = 0, Q = 0, S = null;
  const v = new Uint16Array(16), G = new Uint16Array(16);
  let w, y, g, f = null;
  for (h = 0; h <= DU; h++)
    v[h] = 0;
  for (Z = 0; Z < l; Z++)
    v[n[t + Z]]++;
  for (m = c, F = DU; F >= 1 && v[F] === 0; F--)
    ;
  if (m > F && (m = F), F === 0)
    return a[d++] = 20971520, a[d++] = 20971520, i.bits = 1, 0;
  for (W = 1; W < F && v[W] === 0; W++)
    ;
  for (m < W && (m = W), b = 1, h = 1; h <= DU; h++)
    if (b <<= 1, b -= v[h], b < 0)
      return -1;
  if (b > 0 && (e === 0 || F !== 1))
    return -1;
  for (G[1] = 0, h = 1; h < DU; h++)
    G[h + 1] = G[h] + v[h];
  for (Z = 0; Z < l; Z++)
    n[t + Z] !== 0 && (r[G[n[t + Z]]++] = Z);
  if (e === 0 ? (S = f = r, R = 20) : e === 1 ? (S = tG, f = nG, R = 257) : (S = lG, f = aG, R = 0), Q = 0, Z = 0, h = W, N = d, E = m, u = 0, o = -1, k = 1 << m, U = k - 1, e === 1 && k > 852 || e === 2 && k > 592)
    return 1;
  for (; ; ) {
    w = h - u, r[Z] + 1 < R ? (y = 0, g = r[Z]) : r[Z] >= R ? (y = f[r[Z] - R], g = S[r[Z] - R]) : (y = 96, g = 0), V = 1 << h - u, s = 1 << E, W = s;
    do
      s -= V, a[N + (Q >> u) + s] = w << 24 | y << 16 | g | 0;
    while (s !== 0);
    for (V = 1 << h - 1; Q & V; )
      V >>= 1;
    if (V !== 0 ? (Q &= V - 1, Q += V) : Q = 0, Z++, --v[h] == 0) {
      if (h === F)
        break;
      h = n[t + r[Z]];
    }
    if (h > m && (Q & U) !== o) {
      for (u === 0 && (u = m), N += W, E = h - u, b = 1 << E; E + u < F && (b -= v[E + u], !(b <= 0)); )
        E++, b <<= 1;
      if (k += 1 << E, e === 1 && k > 852 || e === 2 && k > 592)
        return 1;
      o = Q & U, a[o] = m << 24 | E << 16 | N - d | 0;
    }
  }
  return Q !== 0 && (a[N + Q] = h - u << 24 | 64 << 16 | 0), i.bits = m, 0;
};
const { Z_FINISH: wm, Z_BLOCK: dG, Z_TREES: XU, Z_OK: Ci, Z_STREAM_END: rG, Z_NEED_DICT: iG, Z_STREAM_ERROR: Aa, Z_DATA_ERROR: gm, Z_MEM_ERROR: Im, Z_BUF_ERROR: VG, Z_DEFLATED: Lm } = GV, wR = 16180, OU = 16190, Vr = 16191, lZ = 16192, aZ = 16194, jU = 16199, HU = 16200, dZ = 16206, In = 16209, Cm = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
function cG() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const tV = (e) => {
  if (!e)
    return 1;
  const n = e.state;
  return !n || n.strm !== e || n.mode < wR || n.mode > 16211 ? 1 : 0;
}, Hk = (e) => {
  if (tV(e))
    return Aa;
  const n = e.state;
  return e.total_in = e.total_out = n.total = 0, e.msg = "", n.wrap && (e.adler = 1 & n.wrap), n.mode = wR, n.last = 0, n.havedict = 0, n.flags = -1, n.dmax = 32768, n.head = null, n.hold = 0, n.bits = 0, n.lencode = n.lendyn = new Int32Array(852), n.distcode = n.distdyn = new Int32Array(592), n.sane = 1, n.back = -1, Ci;
}, fk = (e) => {
  if (tV(e))
    return Aa;
  const n = e.state;
  return n.wsize = 0, n.whave = 0, n.wnext = 0, Hk(e);
}, wk = (e, n) => {
  let t;
  if (tV(e))
    return Aa;
  const l = e.state;
  return n < 0 ? (t = 0, n = -n) : (t = 5 + (n >> 4), n < 48 && (n &= 15)), n && (n < 8 || n > 15) ? Aa : (l.window !== null && l.wbits !== n && (l.window = null), l.wrap = t, l.wbits = n, fk(e));
}, Km = (e, n) => {
  if (!e)
    return Aa;
  const t = new cG();
  e.state = t, t.strm = e, t.window = null, t.mode = wR;
  const l = wk(e, n);
  return l !== Ci && (e.state = null), l;
};
let rZ, iZ, _m = !0;
const sG = (e) => {
  if (_m) {
    rZ = new Int32Array(512), iZ = new Int32Array(32);
    let n = 0;
    for (; n < 144; )
      e.lens[n++] = 8;
    for (; n < 256; )
      e.lens[n++] = 9;
    for (; n < 280; )
      e.lens[n++] = 7;
    for (; n < 288; )
      e.lens[n++] = 8;
    for (ws(1, e.lens, 0, 288, rZ, 0, e.work, { bits: 9 }), n = 0; n < 32; )
      e.lens[n++] = 5;
    ws(2, e.lens, 0, 32, iZ, 0, e.work, { bits: 5 }), _m = !1;
  }
  e.lencode = rZ, e.lenbits = 9, e.distcode = iZ, e.distbits = 5;
}, Pm = (e, n, t, l) => {
  let a;
  const d = e.state;
  return d.window === null && (d.wsize = 1 << d.wbits, d.wnext = 0, d.whave = 0, d.window = new Uint8Array(d.wsize)), l >= d.wsize ? (d.window.set(n.subarray(t - d.wsize, t), 0), d.wnext = 0, d.whave = d.wsize) : (a = d.wsize - d.wnext, a > l && (a = l), d.window.set(n.subarray(t - l, t - l + a), d.wnext), (l -= a) ? (d.window.set(n.subarray(t - l, t), 0), d.wnext = l, d.whave = d.wsize) : (d.wnext += a, d.wnext === d.wsize && (d.wnext = 0), d.whave < d.wsize && (d.whave += a))), 0;
};
var Zr = { inflateReset: fk, inflateReset2: wk, inflateResetKeep: Hk, inflateInit: (e) => Km(e, 15), inflateInit2: Km, inflate: (e, n) => {
  let t, l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q = 0;
  const S = new Uint8Array(4);
  let v, G;
  const w = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (tV(e) || !e.output || !e.input && e.avail_in !== 0)
    return Aa;
  t = e.state, t.mode === Vr && (t.mode = lZ), r = e.next_out, a = e.output, c = e.avail_out, d = e.next_in, l = e.input, i = e.avail_in, V = t.hold, s = t.bits, o = i, U = c, k = Ci;
  e:
    for (; ; )
      switch (t.mode) {
        case wR:
          if (t.wrap === 0) {
            t.mode = lZ;
            break;
          }
          for (; s < 16; ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          if (2 & t.wrap && V === 35615) {
            t.wbits === 0 && (t.wbits = 15), t.check = 0, S[0] = 255 & V, S[1] = V >>> 8 & 255, t.check = El(t.check, S, 2, 0), V = 0, s = 0, t.mode = 16181;
            break;
          }
          if (t.head && (t.head.done = !1), !(1 & t.wrap) || (((255 & V) << 8) + (V >> 8)) % 31) {
            e.msg = "incorrect header check", t.mode = In;
            break;
          }
          if ((15 & V) !== Lm) {
            e.msg = "unknown compression method", t.mode = In;
            break;
          }
          if (V >>>= 4, s -= 4, b = 8 + (15 & V), t.wbits === 0 && (t.wbits = b), b > 15 || b > t.wbits) {
            e.msg = "invalid window size", t.mode = In;
            break;
          }
          t.dmax = 1 << t.wbits, t.flags = 0, e.adler = t.check = 1, t.mode = 512 & V ? 16189 : Vr, V = 0, s = 0;
          break;
        case 16181:
          for (; s < 16; ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          if (t.flags = V, (255 & t.flags) !== Lm) {
            e.msg = "unknown compression method", t.mode = In;
            break;
          }
          if (57344 & t.flags) {
            e.msg = "unknown header flags set", t.mode = In;
            break;
          }
          t.head && (t.head.text = V >> 8 & 1), 512 & t.flags && 4 & t.wrap && (S[0] = 255 & V, S[1] = V >>> 8 & 255, t.check = El(t.check, S, 2, 0)), V = 0, s = 0, t.mode = 16182;
        case 16182:
          for (; s < 32; ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          t.head && (t.head.time = V), 512 & t.flags && 4 & t.wrap && (S[0] = 255 & V, S[1] = V >>> 8 & 255, S[2] = V >>> 16 & 255, S[3] = V >>> 24 & 255, t.check = El(t.check, S, 4, 0)), V = 0, s = 0, t.mode = 16183;
        case 16183:
          for (; s < 16; ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          t.head && (t.head.xflags = 255 & V, t.head.os = V >> 8), 512 & t.flags && 4 & t.wrap && (S[0] = 255 & V, S[1] = V >>> 8 & 255, t.check = El(t.check, S, 2, 0)), V = 0, s = 0, t.mode = 16184;
        case 16184:
          if (1024 & t.flags) {
            for (; s < 16; ) {
              if (i === 0)
                break e;
              i--, V += l[d++] << s, s += 8;
            }
            t.length = V, t.head && (t.head.extra_len = V), 512 & t.flags && 4 & t.wrap && (S[0] = 255 & V, S[1] = V >>> 8 & 255, t.check = El(t.check, S, 2, 0)), V = 0, s = 0;
          } else
            t.head && (t.head.extra = null);
          t.mode = 16185;
        case 16185:
          if (1024 & t.flags && (N = t.length, N > i && (N = i), N && (t.head && (b = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)), t.head.extra.set(l.subarray(d, d + N), b)), 512 & t.flags && 4 & t.wrap && (t.check = El(t.check, l, N, d)), i -= N, d += N, t.length -= N), t.length))
            break e;
          t.length = 0, t.mode = 16186;
        case 16186:
          if (2048 & t.flags) {
            if (i === 0)
              break e;
            N = 0;
            do
              b = l[d + N++], t.head && b && t.length < 65536 && (t.head.name += String.fromCharCode(b));
            while (b && N < i);
            if (512 & t.flags && 4 & t.wrap && (t.check = El(t.check, l, N, d)), i -= N, d += N, b)
              break e;
          } else
            t.head && (t.head.name = null);
          t.length = 0, t.mode = 16187;
        case 16187:
          if (4096 & t.flags) {
            if (i === 0)
              break e;
            N = 0;
            do
              b = l[d + N++], t.head && b && t.length < 65536 && (t.head.comment += String.fromCharCode(b));
            while (b && N < i);
            if (512 & t.flags && 4 & t.wrap && (t.check = El(t.check, l, N, d)), i -= N, d += N, b)
              break e;
          } else
            t.head && (t.head.comment = null);
          t.mode = 16188;
        case 16188:
          if (512 & t.flags) {
            for (; s < 16; ) {
              if (i === 0)
                break e;
              i--, V += l[d++] << s, s += 8;
            }
            if (4 & t.wrap && V !== (65535 & t.check)) {
              e.msg = "header crc mismatch", t.mode = In;
              break;
            }
            V = 0, s = 0;
          }
          t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = !0), e.adler = t.check = 0, t.mode = Vr;
          break;
        case 16189:
          for (; s < 32; ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          e.adler = t.check = Cm(V), V = 0, s = 0, t.mode = OU;
        case OU:
          if (t.havedict === 0)
            return e.next_out = r, e.avail_out = c, e.next_in = d, e.avail_in = i, t.hold = V, t.bits = s, iG;
          e.adler = t.check = 1, t.mode = Vr;
        case Vr:
          if (n === dG || n === XU)
            break e;
        case lZ:
          if (t.last) {
            V >>>= 7 & s, s -= 7 & s, t.mode = dZ;
            break;
          }
          for (; s < 3; ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          switch (t.last = 1 & V, V >>>= 1, s -= 1, 3 & V) {
            case 0:
              t.mode = 16193;
              break;
            case 1:
              if (sG(t), t.mode = jU, n === XU) {
                V >>>= 2, s -= 2;
                break e;
              }
              break;
            case 2:
              t.mode = 16196;
              break;
            case 3:
              e.msg = "invalid block type", t.mode = In;
          }
          V >>>= 2, s -= 2;
          break;
        case 16193:
          for (V >>>= 7 & s, s -= 7 & s; s < 32; ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          if ((65535 & V) != (V >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", t.mode = In;
            break;
          }
          if (t.length = 65535 & V, V = 0, s = 0, t.mode = aZ, n === XU)
            break e;
        case aZ:
          t.mode = 16195;
        case 16195:
          if (N = t.length, N) {
            if (N > i && (N = i), N > c && (N = c), N === 0)
              break e;
            a.set(l.subarray(d, d + N), r), i -= N, d += N, c -= N, r += N, t.length -= N;
            break;
          }
          t.mode = Vr;
          break;
        case 16196:
          for (; s < 14; ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          if (t.nlen = 257 + (31 & V), V >>>= 5, s -= 5, t.ndist = 1 + (31 & V), V >>>= 5, s -= 5, t.ncode = 4 + (15 & V), V >>>= 4, s -= 4, t.nlen > 286 || t.ndist > 30) {
            e.msg = "too many length or distance symbols", t.mode = In;
            break;
          }
          t.have = 0, t.mode = 16197;
        case 16197:
          for (; t.have < t.ncode; ) {
            for (; s < 3; ) {
              if (i === 0)
                break e;
              i--, V += l[d++] << s, s += 8;
            }
            t.lens[w[t.have++]] = 7 & V, V >>>= 3, s -= 3;
          }
          for (; t.have < 19; )
            t.lens[w[t.have++]] = 0;
          if (t.lencode = t.lendyn, t.lenbits = 7, v = { bits: t.lenbits }, k = ws(0, t.lens, 0, 19, t.lencode, 0, t.work, v), t.lenbits = v.bits, k) {
            e.msg = "invalid code lengths set", t.mode = In;
            break;
          }
          t.have = 0, t.mode = 16198;
        case 16198:
          for (; t.have < t.nlen + t.ndist; ) {
            for (; Q = t.lencode[V & (1 << t.lenbits) - 1], Z = Q >>> 24, W = Q >>> 16 & 255, F = 65535 & Q, !(Z <= s); ) {
              if (i === 0)
                break e;
              i--, V += l[d++] << s, s += 8;
            }
            if (F < 16)
              V >>>= Z, s -= Z, t.lens[t.have++] = F;
            else {
              if (F === 16) {
                for (G = Z + 2; s < G; ) {
                  if (i === 0)
                    break e;
                  i--, V += l[d++] << s, s += 8;
                }
                if (V >>>= Z, s -= Z, t.have === 0) {
                  e.msg = "invalid bit length repeat", t.mode = In;
                  break;
                }
                b = t.lens[t.have - 1], N = 3 + (3 & V), V >>>= 2, s -= 2;
              } else if (F === 17) {
                for (G = Z + 3; s < G; ) {
                  if (i === 0)
                    break e;
                  i--, V += l[d++] << s, s += 8;
                }
                V >>>= Z, s -= Z, b = 0, N = 3 + (7 & V), V >>>= 3, s -= 3;
              } else {
                for (G = Z + 7; s < G; ) {
                  if (i === 0)
                    break e;
                  i--, V += l[d++] << s, s += 8;
                }
                V >>>= Z, s -= Z, b = 0, N = 11 + (127 & V), V >>>= 7, s -= 7;
              }
              if (t.have + N > t.nlen + t.ndist) {
                e.msg = "invalid bit length repeat", t.mode = In;
                break;
              }
              for (; N--; )
                t.lens[t.have++] = b;
            }
          }
          if (t.mode === In)
            break;
          if (t.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", t.mode = In;
            break;
          }
          if (t.lenbits = 9, v = { bits: t.lenbits }, k = ws(1, t.lens, 0, t.nlen, t.lencode, 0, t.work, v), t.lenbits = v.bits, k) {
            e.msg = "invalid literal/lengths set", t.mode = In;
            break;
          }
          if (t.distbits = 6, t.distcode = t.distdyn, v = { bits: t.distbits }, k = ws(2, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, v), t.distbits = v.bits, k) {
            e.msg = "invalid distances set", t.mode = In;
            break;
          }
          if (t.mode = jU, n === XU)
            break e;
        case jU:
          t.mode = HU;
        case HU:
          if (i >= 6 && c >= 258) {
            e.next_out = r, e.avail_out = c, e.next_in = d, e.avail_in = i, t.hold = V, t.bits = s, eG(e, U), r = e.next_out, a = e.output, c = e.avail_out, d = e.next_in, l = e.input, i = e.avail_in, V = t.hold, s = t.bits, t.mode === Vr && (t.back = -1);
            break;
          }
          for (t.back = 0; Q = t.lencode[V & (1 << t.lenbits) - 1], Z = Q >>> 24, W = Q >>> 16 & 255, F = 65535 & Q, !(Z <= s); ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          if (W && !(240 & W)) {
            for (m = Z, E = W, u = F; Q = t.lencode[u + ((V & (1 << m + E) - 1) >> m)], Z = Q >>> 24, W = Q >>> 16 & 255, F = 65535 & Q, !(m + Z <= s); ) {
              if (i === 0)
                break e;
              i--, V += l[d++] << s, s += 8;
            }
            V >>>= m, s -= m, t.back += m;
          }
          if (V >>>= Z, s -= Z, t.back += Z, t.length = F, W === 0) {
            t.mode = 16205;
            break;
          }
          if (32 & W) {
            t.back = -1, t.mode = Vr;
            break;
          }
          if (64 & W) {
            e.msg = "invalid literal/length code", t.mode = In;
            break;
          }
          t.extra = 15 & W, t.mode = 16201;
        case 16201:
          if (t.extra) {
            for (G = t.extra; s < G; ) {
              if (i === 0)
                break e;
              i--, V += l[d++] << s, s += 8;
            }
            t.length += V & (1 << t.extra) - 1, V >>>= t.extra, s -= t.extra, t.back += t.extra;
          }
          t.was = t.length, t.mode = 16202;
        case 16202:
          for (; Q = t.distcode[V & (1 << t.distbits) - 1], Z = Q >>> 24, W = Q >>> 16 & 255, F = 65535 & Q, !(Z <= s); ) {
            if (i === 0)
              break e;
            i--, V += l[d++] << s, s += 8;
          }
          if (!(240 & W)) {
            for (m = Z, E = W, u = F; Q = t.distcode[u + ((V & (1 << m + E) - 1) >> m)], Z = Q >>> 24, W = Q >>> 16 & 255, F = 65535 & Q, !(m + Z <= s); ) {
              if (i === 0)
                break e;
              i--, V += l[d++] << s, s += 8;
            }
            V >>>= m, s -= m, t.back += m;
          }
          if (V >>>= Z, s -= Z, t.back += Z, 64 & W) {
            e.msg = "invalid distance code", t.mode = In;
            break;
          }
          t.offset = F, t.extra = 15 & W, t.mode = 16203;
        case 16203:
          if (t.extra) {
            for (G = t.extra; s < G; ) {
              if (i === 0)
                break e;
              i--, V += l[d++] << s, s += 8;
            }
            t.offset += V & (1 << t.extra) - 1, V >>>= t.extra, s -= t.extra, t.back += t.extra;
          }
          if (t.offset > t.dmax) {
            e.msg = "invalid distance too far back", t.mode = In;
            break;
          }
          t.mode = 16204;
        case 16204:
          if (c === 0)
            break e;
          if (N = U - c, t.offset > N) {
            if (N = t.offset - N, N > t.whave && t.sane) {
              e.msg = "invalid distance too far back", t.mode = In;
              break;
            }
            N > t.wnext ? (N -= t.wnext, R = t.wsize - N) : R = t.wnext - N, N > t.length && (N = t.length), h = t.window;
          } else
            h = a, R = r - t.offset, N = t.length;
          N > c && (N = c), c -= N, t.length -= N;
          do
            a[r++] = h[R++];
          while (--N);
          t.length === 0 && (t.mode = HU);
          break;
        case 16205:
          if (c === 0)
            break e;
          a[r++] = t.length, c--, t.mode = HU;
          break;
        case dZ:
          if (t.wrap) {
            for (; s < 32; ) {
              if (i === 0)
                break e;
              i--, V |= l[d++] << s, s += 8;
            }
            if (U -= c, e.total_out += U, t.total += U, 4 & t.wrap && U && (e.adler = t.check = t.flags ? El(t.check, a, U, r - U) : js(t.check, a, U, r - U)), U = c, 4 & t.wrap && (t.flags ? V : Cm(V)) !== t.check) {
              e.msg = "incorrect data check", t.mode = In;
              break;
            }
            V = 0, s = 0;
          }
          t.mode = 16207;
        case 16207:
          if (t.wrap && t.flags) {
            for (; s < 32; ) {
              if (i === 0)
                break e;
              i--, V += l[d++] << s, s += 8;
            }
            if (4 & t.wrap && V !== (4294967295 & t.total)) {
              e.msg = "incorrect length check", t.mode = In;
              break;
            }
            V = 0, s = 0;
          }
          t.mode = 16208;
        case 16208:
          k = rG;
          break e;
        case In:
          k = gm;
          break e;
        case 16210:
          return Im;
        default:
          return Aa;
      }
  return e.next_out = r, e.avail_out = c, e.next_in = d, e.avail_in = i, t.hold = V, t.bits = s, (t.wsize || U !== e.avail_out && t.mode < In && (t.mode < dZ || n !== wm)) && Pm(e, e.output, e.next_out, U - e.avail_out), o -= e.avail_in, U -= e.avail_out, e.total_in += o, e.total_out += U, t.total += U, 4 & t.wrap && U && (e.adler = t.check = t.flags ? El(t.check, a, U, e.next_out - U) : js(t.check, a, U, e.next_out - U)), e.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === Vr ? 128 : 0) + (t.mode === jU || t.mode === aZ ? 256 : 0), (o === 0 && U === 0 || n === wm) && k === Ci && (k = VG), k;
}, inflateEnd: (e) => {
  if (tV(e))
    return Aa;
  let n = e.state;
  return n.window && (n.window = null), e.state = null, Ci;
}, inflateGetHeader: (e, n) => {
  if (tV(e))
    return Aa;
  const t = e.state;
  return 2 & t.wrap ? (t.head = n, n.done = !1, Ci) : Aa;
}, inflateSetDictionary: (e, n) => {
  const t = n.length;
  let l, a, d;
  return tV(e) ? Aa : (l = e.state, l.wrap !== 0 && l.mode !== OU ? Aa : l.mode === OU && (a = 1, a = js(a, n, t, 0), a !== l.check) ? gm : (d = Pm(e, n, t, t), d ? (l.mode = 16210, Im) : (l.havedict = 1, Ci)));
}, inflateInfo: "pako inflate (from Nodeca project)" }, oG = function() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
};
const gk = Object.prototype.toString, { Z_NO_FLUSH: UG, Z_FINISH: NG, Z_OK: gs, Z_STREAM_END: VZ, Z_NEED_DICT: cZ, Z_STREAM_ERROR: RG, Z_DATA_ERROR: Am, Z_MEM_ERROR: hG } = GV;
function Is(e) {
  this.options = fR.assign({ chunkSize: 65536, windowBits: 15, to: "" }, e || {});
  const n = this.options;
  n.raw && n.windowBits >= 0 && n.windowBits < 16 && (n.windowBits = -n.windowBits, n.windowBits === 0 && (n.windowBits = -15)), !(n.windowBits >= 0 && n.windowBits < 16) || e && e.windowBits || (n.windowBits += 32), n.windowBits > 15 && n.windowBits < 48 && !(15 & n.windowBits) && (n.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Ok(), this.strm.avail_out = 0;
  let t = Zr.inflateInit2(this.strm, n.windowBits);
  if (t !== gs)
    throw new Error(EV[t]);
  if (this.header = new oG(), Zr.inflateGetHeader(this.strm, this.header), n.dictionary && (typeof n.dictionary == "string" ? n.dictionary = Wo.string2buf(n.dictionary) : gk.call(n.dictionary) === "[object ArrayBuffer]" && (n.dictionary = new Uint8Array(n.dictionary)), n.raw && (t = Zr.inflateSetDictionary(this.strm, n.dictionary), t !== gs)))
    throw new Error(EV[t]);
}
function sZ(e, n) {
  const t = new Is(n);
  if (t.push(e), t.err)
    throw t.msg || EV[t.err];
  return t.result;
}
Is.prototype.push = function(e, n) {
  const t = this.strm, l = this.options.chunkSize, a = this.options.dictionary;
  let d, r, i;
  if (this.ended)
    return !1;
  for (r = n === ~~n ? n : n === !0 ? NG : UG, gk.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length; ; ) {
    for (t.avail_out === 0 && (t.output = new Uint8Array(l), t.next_out = 0, t.avail_out = l), d = Zr.inflate(t, r), d === cZ && a && (d = Zr.inflateSetDictionary(t, a), d === gs ? d = Zr.inflate(t, r) : d === Am && (d = cZ)); t.avail_in > 0 && d === VZ && t.state.wrap > 0 && e[t.next_in] !== 0; )
      Zr.inflateReset(t), d = Zr.inflate(t, r);
    switch (d) {
      case RG:
      case Am:
      case cZ:
      case hG:
        return this.onEnd(d), this.ended = !0, !1;
    }
    if (i = t.avail_out, t.next_out && (t.avail_out === 0 || d === VZ))
      if (this.options.to === "string") {
        let c = Wo.utf8border(t.output, t.next_out), V = t.next_out - c, s = Wo.buf2string(t.output, c);
        t.next_out = V, t.avail_out = l - V, V && t.output.set(t.output.subarray(c, c + V), 0), this.onData(s);
      } else
        this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));
    if (d !== gs || i !== 0) {
      if (d === VZ)
        return d = Zr.inflateEnd(this.strm), this.onEnd(d), this.ended = !0, !0;
      if (t.avail_in === 0)
        break;
    }
  }
  return !0;
}, Is.prototype.onData = function(e) {
  this.chunks.push(e);
}, Is.prototype.onEnd = function(e) {
  e === gs && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = fR.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
var ZG = { Inflate: Is, inflate: sZ, inflateRaw: function(e, n) {
  return (n = n || {}).raw = !0, sZ(e, n);
}, ungzip: sZ, constants: GV };
const { Deflate: TG, deflate: FG, deflateRaw: WG, gzip: mG } = $x, { Inflate: uG, inflate: pG, inflateRaw: MG, ungzip: EG } = ZG;
var Hd, SG = { Deflate: TG, deflate: FG, deflateRaw: WG, gzip: mG, Inflate: uG, inflate: pG, inflateRaw: MG, ungzip: EG, constants: GV }, qm = function(e) {
  return M(void 0, void 0, void 0, function() {
    var n;
    return p(this, function(t) {
      return n = SG.ungzip(e), [2, String.fromCharCode.apply(null, n)];
    });
  });
};
(function(e) {
  e.CONNECTING = "CONNECTING", e.OPEN = "OPEN", e.CLOSED = "CLOSED";
})(Hd || (Hd = {}));
var tn, kG = function(e) {
  function n(t, l) {
    var a = l.sdkState, d = l.dispatcher, r = l.logger, i = e.call(this) || this;
    return i.lastActive = 0, i._iid = t, i._sdkState = a, i._dispatcher = d, i._logger = r, i;
  }
  return J(n, e), Object.defineProperty(n.prototype, "isOpen", { get: function() {
    return this.connectionState === Hd.OPEN;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "connectionState", { get: function() {
    if (this._ws)
      switch (this._ws.readyState) {
        case 0:
          return Hd.CONNECTING;
        case 1:
          return Hd.OPEN;
      }
    return Hd.CLOSED;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "ws", { get: function() {
    var t;
    return (t = this._ws) !== null && t !== void 0 ? t : null;
  }, enumerable: !1, configurable: !0 }), n.prototype._handleMessage = function(t) {
    var l = this;
    t.split(`
`).forEach(function(a) {
      if (a) {
        var d = Wn.createFromRawMessage(l._iid, a);
        if (l._logger.debug("receive websocket event", d), d.code === "LOGI")
          l.dispatch("message", d);
        else if (d.code === "PONG")
          l.dispatch("pong");
        else if (d.code === "EXPR") {
          if (d.payload) {
            var r = new Sc(d.payload);
            r.expiresIn >= 0 && l._dispatcher.dispatch(r);
          }
        } else
          d.code === "NOOP" || l.dispatch("message", d);
      }
    });
  }, n.prototype.connect = function(t, l) {
    var a = this;
    l === void 0 && (l = ""), this._ws = new WebSocket(t, encodeURIComponent(l)), this._ws.onopen = function() {
      a._logger.debug("websocket open"), a.dispatch("open");
    }, this._ws.onmessage = function(d) {
      return M(a, void 0, void 0, function() {
        var r, i, c, V, s = this;
        return p(this, function(o) {
          switch (o.label) {
            case 0:
              return !((V = this._sdkState.websocket) === null || V === void 0) && V.compression ? d.data instanceof Blob ? ((r = new FileReader()).readAsArrayBuffer(d.data), r.onloadend = function() {
                return M(s, void 0, void 0, function() {
                  var U, N;
                  return p(this, function(R) {
                    switch (R.label) {
                      case 0:
                        return R.trys.push([0, 2, , 3]), [4, qm(r.result)];
                      case 1:
                        return U = R.sent(), this._handleMessage(U), [3, 3];
                      case 2:
                        return N = R.sent(), this.error(N), [3, 3];
                      case 3:
                        return [2];
                    }
                  });
                });
              }, [3, 7]) : [3, 1] : [3, 8];
            case 1:
              if (!(d.data instanceof ArrayBuffer))
                return [3, 6];
              o.label = 2;
            case 2:
              return o.trys.push([2, 4, , 5]), [4, qm(new Uint8Array(d.data))];
            case 3:
              return i = o.sent(), this._handleMessage(i), [3, 5];
            case 4:
              return c = o.sent(), this.error(c), [3, 5];
            case 5:
              return [3, 7];
            case 6:
              typeof d.data == "string" && this._handleMessage(d.data), o.label = 7;
            case 7:
              return [3, 9];
            case 8:
              this._handleMessage(d.data), o.label = 9;
            case 9:
              return [2];
          }
        });
      });
    }, this._ws.onerror = function() {
      a._logger.debug("websocket error"), a.dispatch("error", j.networkError);
    }, this._ws.onclose = function() {
      a._logger.debug("websocket close"), a.dispatch("close");
    }, this.lastActive = Date.now();
  }, n.prototype.disconnect = function() {
    var t = this;
    return new Promise(function(l) {
      t._logger.debug("websocket disconnect"), t._ws ? (t._ws.onopen = ut, t._ws.onmessage = ut, t._ws.onerror = ut, t.connectionState !== Hd.CLOSED ? (t._ws.onclose = function() {
        t.dispatch("close"), l();
      }, t._ws.close(), t._ws = void 0) : l()) : l();
    });
  }, n.prototype.send = function(t) {
    if (!this._ws)
      throw j.connectionClosed;
    t.code !== "PING" ? this.dispatch("ping-refresh") : this._logger.debug("send ping", t), this._ws.send(t.convertToMessage());
  }, n.prototype.error = function(t) {
    this._logger.debug("websocket error", t), this.dispatch("error", t);
  }, n;
}(zV), Ik = function(e) {
  function n(t) {
    var l = t.all, a = t.feed, d = t.custom_types, r = t.ts, i = e.call(this) || this;
    return i.all = l, i.feed = a, i.customTypes = d, i.ts = r, i;
  }
  return J(n, e), n;
}(un), bG = function() {
  function e(n, t) {
    var l = t.session, a = t.sdkState, d = t.dispatcher, r = t.logger, i = t.useFetchCompat, c = i !== void 0 && i, V = this;
    this._ackStateMap = /* @__PURE__ */ new Map(), this._sdkState = a, this._dispatcher = d, this._logger = r, this.apiClient = new Sx(n, { session: l, sdkState: a, dispatcher: d, logger: r, useFetchCompat: c }), this.websocketClient = new kG(n, { sdkState: a, dispatcher: d, logger: r }), this.websocketClient.on("message", function(s) {
      if (s.payload.unread_cnt && V._dispatcher.dispatch(new Ik(s.payload.unread_cnt)), s.requestId) {
        if (V._ackStateMap.has(s.requestId)) {
          var o = V._ackStateMap.get(s.requestId);
          s.code !== "EROR" ? o.resolve(s) : o.reject(new j({ code: s.payload.code, message: s.payload.message }));
        }
      } else
        V._dispatcher.dispatch(s);
    }).on("close", function() {
      V._ackStateMap.forEach(function(s) {
        s.reject(j.connectionClosed);
      }), V._ackStateMap.clear();
    });
  }
  return e.prototype._sendApiRequest = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.apiClient.send(n)];
          case 1:
            return [2, t.sent()];
        }
      });
    });
  }, e.prototype._sendWebsocketRequest = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d = this;
      return p(this, function(r) {
        if (!this._sdkState.websocket)
          throw j.connectionRequired;
        if (t = new Ll(), n.ackRequired) {
          a = function(i, c) {
            d._ackStateMap.has(n.requestId) && (d._ackStateMap.delete(n.requestId), l && (clearTimeout(l), l = null), i ? (d._logger.debug("fail websocket request", n.requestId, i), t.reject(i)) : (d._logger.debug("receive websocket ack", n.requestId, n), d._logger.debug("receive websocket ack", c), t.resolve(c)));
          };
          try {
            l = setTimeout(function() {
              return a(j.noAckTimeout);
            }, this._sdkState.websocket.responseTimeout), this._ackStateMap.set(n.requestId, { resolve: function(i) {
              return a(void 0, i);
            }, reject: function(i) {
              return a(i);
            } }), this.websocketClient.send(n);
          } catch (i) {
            a(i);
          }
        } else
          try {
            this.websocketClient.send(n), t.resolve();
          } catch (i) {
            t.reject(i);
          }
        return [2, t.promise];
      });
    });
  }, e.prototype.send = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return n instanceof Te ? [4, this._sendApiRequest(n)] : [3, 2];
          case 1:
          case 3:
            return [2, t.sent()];
          case 2:
            return n instanceof Yl ? [4, this._sendWebsocketRequest(n)] : [3, 4];
          case 4:
            throw j.invalidParameters;
        }
      });
    });
  }, e.prototype.cancel = function(n) {
    this.apiClient.cancel(n);
  }, e.prototype.cancelAll = function() {
    this.apiClient.cancelAll();
  }, e;
}();
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.INITIALIZED = 1] = "INITIALIZED", e[e.CONNECTING = 2] = "CONNECTING", e[e.CONNECTED = 3] = "CONNECTED", e[e.RECONNECTING = 4] = "RECONNECTING", e[e.INTERNAL_DISCONNECTED = 5] = "INTERNAL_DISCONNECTED", e[e.EXTERNAL_DISCONNECTED = 6] = "EXTERNAL_DISCONNECTED", e[e.LOGOUT = 7] = "LOGOUT";
})(tn || (tn = {}));
var ua = function(e) {
  function n(t) {
    var l = t.stateType, a = e.call(this) || this;
    return a.stateType = l, a;
  }
  return J(n, e), n;
}(un), Lk = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return J(n, e), n;
}(un), XT = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return J(n, e), n;
}(un), Ck = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return J(n, e), n;
}(un), $m = function() {
  function e(n) {
    var t, l, a, d;
    this.isEnabled = (t = n.enabled) !== null && t !== void 0 && t, this.feedChannels = (l = n.feed_channels) !== null && l !== void 0 ? l : {}, this.templateListToken = (a = n.template_list_token) !== null && a !== void 0 ? a : null, this.settingsUpdatedAt = (d = n.settings_updated_at) !== null && d !== void 0 ? d : 0;
  }
  return e.payloadify = function(n) {
    return je(Ae({ enabled: n.isEnabled, feed_channels: n.feedChannels, template_list_token: n.templateListToken, settings_updated_at: n.settingsUpdatedAt }));
  }, e;
}(), pW = function(e) {
  return "sendbird@".concat(e, "/changelog_include_chat_notifications");
}, eu = function() {
  function e(n) {
    var t;
    this.lastUpdatedAt = (t = n.last_updated_at) !== null && t !== void 0 ? t : 0;
  }
  return e.payloadify = function(n) {
    return je(Ae({ last_updated_at: n.lastUpdatedAt }));
  }, e;
}(), tu = function() {
  function e(n) {
    var t;
    this.token = (t = n.template_list_token) !== null && t !== void 0 ? t : "";
  }
  return e.payloadify = function(n) {
    return je(Ae({ template_list_token: n.token }));
  }, e;
}(), nu = 1048576, YG = 5, lu = function() {
  function e(n) {
    var t, l, a, d, r;
    n === void 0 && (n = {}), this.emojiHash = n.emoji_hash || "", this.uploadSizeLimit = n.file_upload_size_limit ? n.file_upload_size_limit * nu : Number.MAX_SAFE_INTEGER, this.useReaction = !!n.use_reaction, this.applicationAttributes = (t = n.application_attributes) !== null && t !== void 0 ? t : [], this.premiumFeatureList = (l = n.premium_feature_list) !== null && l !== void 0 ? l : [], this.deviceTokenCache = this.applicationAttributes.includes("sdk_device_token_cache"), this.enabledChannelMemberShipHistory = this.applicationAttributes.includes("channel_membership_history"), this.multipleFilesMessageFileCountLimit = (a = n.multiple_file_send_max_size) !== null && a !== void 0 ? a : 5, this.allowSdkStatsUpload = (d = n.allow_sdk_log_ingestion) === null || d === void 0 || d, this.uikitConfigInfo = new eu((r = n.uikit_config) !== null && r !== void 0 ? r : {}), this.notificationInfo = n.notifications ? new $m(n.notifications) : null, this.messageTemplateInfo = n.message_template ? new tu(n.message_template) : null;
  }
  return e.payloadify = function(n) {
    return je(Ae({ emoji_hash: n.emojiHash, file_upload_size_limit: n.uploadSizeLimit / nu, application_attributes: n.applicationAttributes, premium_feature_list: n.premiumFeatureList, use_reaction: n.useReaction, allow_sdk_log_ingestion: n.allowSdkStatsUpload, uikit_config: n.uikitConfigInfo ? eu.payloadify(n.uikitConfigInfo) : null, notifications: n.notificationInfo ? $m.payloadify(n.notificationInfo) : null, message_template: n.messageTemplateInfo ? tu.payloadify(n.messageTemplateInfo) : null }));
  }, e;
}(), ml = function() {
  function e(n) {
    this._iid = "", this._iid = n;
  }
  return e.payloadify = function(n) {
    return {};
  }, e;
}(), QG = function(e) {
  function n(t) {
    var l = t.userId, a = t.metadata, d = e.call(this) || this;
    return d.method = he.POST, d.path = "".concat(It, "/").concat(l, "/metadata"), d.params = { metadata: a }, d;
  }
  return J(n, e), n;
}(Te), JG = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.metaData = l, a;
  }
  return J(n, e), n;
}(ue), vG = function(e) {
  function n(t) {
    var l = t.userId, a = t.metadata, d = t.upsert, r = e.call(this) || this;
    return r.method = he.PUT, r.path = "".concat(It, "/").concat(l, "/metadata"), r.params = { metadata: a, upsert: d }, r;
  }
  return J(n, e), n;
}(Te), zG = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.metadata = l, a;
  }
  return J(n, e), n;
}(ue), xG = function(e) {
  function n(t) {
    var l = t.userId, a = t.metadataKey, d = e.call(this) || this;
    return d.method = he.DELETE, d.path = "".concat(It, "/").concat(l, "/metadata/").concat(a), d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var GG = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.DELETE, a.path = "".concat(It, "/").concat(l, "/metadata"), a;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var qV, gc = function(e, n) {
  var t = JSON.parse(JSON.stringify(e));
  return t._iid && delete t._iid, n && n(t), t;
}, hi = function(e, n) {
  var t = JSON.parse(JSON.stringify(e));
  return n && n(t), t;
}, Ze = function(e) {
  return { do: function(n) {
    e || n();
  }, throw: function(n) {
    if (!e)
      throw n;
  } };
};
(function(e) {
  e.ONLINE = "online", e.OFFLINE = "offline", e.NON_AVAILABLE = "nonavailable";
})(qV || (qV = {}));
var kc, xt = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o, U, N, R, h, Z = this;
    return (Z = e.call(this, t) || this).userId = (d = (a = l.guest_id) !== null && a !== void 0 ? a : l.user_id) !== null && d !== void 0 ? d : "", Z.nickname = (i = (r = l.nickname) !== null && r !== void 0 ? r : l.name) !== null && i !== void 0 ? i : "", Z.plainProfileUrl = (V = (c = l.profile_url) !== null && c !== void 0 ? c : l.image) !== null && V !== void 0 ? V : "", Z.requireAuth = (s = l.require_auth_for_profile_image) !== null && s !== void 0 && s, Z.metaData = (o = l.metadata) !== null && o !== void 0 ? o : {}, Z.connectionStatus = qV.NON_AVAILABLE, Qt(qV, l.is_online) ? Z.connectionStatus = l.is_online : B("boolean", l.is_online) && (Z.connectionStatus = l.is_online ? qV.ONLINE : qV.OFFLINE), Z.isActive = (U = l.is_active) === null || U === void 0 || U, Z.lastSeenAt = (N = l.last_seen_at) !== null && N !== void 0 ? N : null, Z.preferredLanguages = l.preferred_languages ? ot([], et(l.preferred_languages), !1) : null, Z.friendDiscoveryKey = (R = l.friend_discovery_key) !== null && R !== void 0 ? R : null, Z.friendName = (h = l.friend_name) !== null && h !== void 0 ? h : null, Z;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { user_id: t.userId, nickname: t.nickname, profile_url: t.plainProfileUrl, require_auth_for_profile_image: t.requireAuth, metadata: t.metaData, is_online: t.connectionStatus, is_active: t.isActive, last_seen_at: t.lastSeenAt, preferred_languages: t.preferredLanguages, friend_discovery_key: t.friendDiscoveryKey, friend_name: t.friendName })));
  }, Object.defineProperty(n.prototype, "profileUrl", { get: function() {
    var t = D.of(this._iid).sessionManager;
    return this.requireAuth && t.ekey ? "".concat(this.plainProfileUrl, "?auth=").concat(t.ekey) : this.plainProfileUrl;
  }, enumerable: !1, configurable: !0 }), n.prototype.serialize = function() {
    return gc(this);
  }, n.prototype._isValidMetaData = function(t) {
    return !Array.isArray(t) && Object.keys(t).length > 0 && Object.keys(t).map(function(l) {
      return t[l];
    }).every(function(l) {
      return B("string", l);
    });
  }, n.prototype._applyMetaData = function(t, l) {
    var a = this;
    l === void 0 && (l = !1), Object.keys(t).forEach(function(d) {
      l ? delete a.metaData[d] : a.metaData[d] = t[d];
    });
  }, n.prototype.createMetaData = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return Ze(this._isValidMetaData(t)).throw(j.invalidParameters), l = D.of(this._iid), a = l.sdkState, d = l.requestQueue, r = new QG({ userId: a.userId, metadata: t }), [4, d.send(r)];
          case 1:
            return i = V.sent(), c = i.as(JG).metaData, this._applyMetaData(c), [2, this.metaData];
        }
      });
    });
  }, n.prototype.updateMetaData = function(t, l) {
    return l === void 0 && (l = !1), M(this, void 0, void 0, function() {
      var a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return Ze(this._isValidMetaData(t)).throw(j.invalidParameters), a = D.of(this._iid), d = a.sdkState, r = a.requestQueue, i = new vG({ userId: d.userId, metadata: t, upsert: l }), [4, r.send(i)];
          case 1:
            return c = s.sent(), V = c.as(zG).metadata, this._applyMetaData(V), [2, this.metaData];
        }
      });
    });
  }, n.prototype.deleteMetaData = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return Ze(B("string", t)).throw(j.invalidParameters), l = D.of(this._iid), a = l.sdkState, d = l.requestQueue, r = new xG({ userId: a.userId, metadataKey: t }), [4, d.send(r)];
          case 1:
            return c.sent(), this._applyMetaData(((i = {})[t] = !0, i), !0), [2, this.metaData];
        }
      });
    });
  }, n.prototype.deleteAllMetaData = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new GG({ userId: l.userId }), [4, a.send(d)];
          case 1:
            return r.sent(), this.metaData = {}, [2];
        }
      });
    });
  }, n;
}(ml), Kk = function(e) {
  function n(t) {
    var l = t.userProfile, a = e.call(this) || this;
    return a.userProfile = l, a;
  }
  return J(n, e), n;
}(un), OT = function() {
  function e(n, t) {
    var l, a, d, r, i, c, V, s, o, U, N, R, h, Z;
    this._iid = n, this.appInfo = new lu(t), this.user = new xt(n, t), this.connectedAt = (l = t.login_ts) !== null && l !== void 0 ? l : 0, this.firstConnectedAt = 0, this.pingInterval = (a = t.ping_interval) !== null && a !== void 0 ? a : 15e3, this.pongTimeout = (d = t.pong_timeout) !== null && d !== void 0 ? d : 5e3, this.reconnectInterval = (i = (r = t.reconnect) === null || r === void 0 ? void 0 : r.interval) !== null && i !== void 0 ? i : 3e3, this.reconnectMaxInterval = (V = (c = t.reconnect) === null || c === void 0 ? void 0 : c.max_interval) !== null && V !== void 0 ? V : 6e4, this.reconnectRetryCount = (o = (s = t.reconnect) === null || s === void 0 ? void 0 : s.retry_cnt) !== null && o !== void 0 ? o : 5, this.reconnectIntervalMultiple = (N = (U = t.reconnect) === null || U === void 0 ? void 0 : U.mul) !== null && N !== void 0 ? N : 2, this.maxUnreadCountOnSuperGroup = (R = t.max_unread_cnt_on_super_group) !== null && R !== void 0 ? R : 100, this.profileImageEncryption = !!t.profile_image_encryption, this.concurrentCallLimit = (h = t.concurrent_call_limit) !== null && h !== void 0 ? h : 5, this.backOffDelay = (Z = t.back_off_delay) !== null && Z !== void 0 ? Z : 100;
  }
  return e.payloadify = function(n) {
    return je(Ae(x(x(x({}, xt.payloadify(n.user)), lu.payloadify(n.appInfo)), { login_ts: n.connectedAt, ping_interval: n.pingInterval, pong_timeout: n.pongTimeout, reconnect: { interval: n.reconnectInterval, max_interval: n.reconnectMaxInterval, retry_cnt: n.reconnectRetryCount, mul: n.reconnectIntervalMultiple }, max_unread_cnt_on_super_group: n.maxUnreadCountOnSuperGroup, profile_image_encryption: n.profileImageEncryption, concurrent_call_limit: n.concurrentCallLimit, back_off_delay: n.backOffDelay })));
  }, e.prototype.apply = function() {
    var n = this.reconnectInterval, t = this.reconnectMaxInterval, l = this.reconnectIntervalMultiple, a = D.of(this._iid);
    a.sdkState.websocket && (a.sdkState.websocket.pingInterval = 1e3 * this.pingInterval, a.sdkState.websocket.pongTimeout = 1e3 * this.pongTimeout, a.sdkState.websocket.reconnectMaxRetry = this.reconnectRetryCount, a.sdkState.websocket.reconnectRetryStrategy = { calcTimeout: function(d) {
      return d > 0 ? 1e3 * Math.min(n * Math.pow(l, d - 1), t) : 10;
    } }), a.appInfo = this.appInfo, a.sessionManager.currentUser = this.user, a.connectedAt = this.connectedAt, this.firstConnectedAt || (a.firstConnectedAt = this.connectedAt), a.maxSuperGroupChannelUnreadCount = this.maxUnreadCountOnSuperGroup, a.concurrentCallLimit = this.concurrentCallLimit, a.backOffDelay = this.backOffDelay, a.dispatcher.dispatch(new Kk({ userProfile: this }));
  }, e;
}(), _k = function(e) {
  function n(t) {
    var l = t.request, a = l === void 0 || l, d = t.features, r = d === void 0 ? {} : d, i = t.options, c = i === void 0 ? {} : i, V = e.call(this) || this;
    return V.request = a, V.features = x({ localCache: !0, notification: !0 }, r), V.options = x({ ingestion: !0 }, c), V;
  }
  return J(n, e), n;
}(un), pN = function(e) {
  function n(t, l, a) {
    var d, r, i, c, V = this;
    return (V = e.call(this, t, l, a) || this).error = null, V.services = [], V.userProfile = new OT(t, a), V.deviceTokenLastDeletedAt = (d = a.device_token_last_deleted_at) !== null && d !== void 0 ? d : 0, V.key = (r = a.key) !== null && r !== void 0 ? r : "", V.ekey = (i = a.ekey) !== null && i !== void 0 ? i : "", V.error = a.error ? new j(a) : null, V.services = (c = a.services) !== null && c !== void 0 ? c : [], V;
  }
  return J(n, e), n.asError = function(t) {
    return new n("", "LOGI", x({ user_id: "", error: !0 }, t));
  }, n.prototype.applyTo = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return this.error ? [3, 4] : (l = D.of(t)) ? (a = l.sessionManager, d = l.dispatcher, [4, a.login(this)]) : [3, 2];
          case 1:
            return r.sent(), this.userProfile.apply(), d.dispatch(new _k({ request: this.userProfile.appInfo.applicationAttributes.includes("allow_sdk_request_log_publish"), features: { localCache: this.userProfile.appInfo.applicationAttributes.includes("allow_sdk_feature_local_cache_log_publish"), notification: this.userProfile.appInfo.applicationAttributes.includes("allow_sdk_noti_stats_log_publish") }, options: { ingestion: this.userProfile.appInfo.allowSdkStatsUpload } })), [3, 3];
          case 2:
            throw j.lostInstance;
          case 3:
            return [3, 5];
          case 4:
            throw this.error;
          case 5:
            return [2];
        }
      });
    });
  }, n;
}(Wn), yV = function() {
  function e() {
    this.type = tn.NONE, this.name = "none";
  }
  return e.prototype.run = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return [2];
      });
    });
  }, e.prototype.onConnect = function(n, t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2];
      });
    });
  }, e.prototype.onReconnect = function(n, t) {
    return t.resetReconnectCount, M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2];
      });
    });
  }, e.prototype.onDisconnect = function(n, t) {
    return t.error, t.autoReconnect, t.cause, M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2];
      });
    });
  }, e.prototype.onDisconnectWebSocket = function(n, t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2];
      });
    });
  }, e.prototype.onLogout = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return [2];
      });
    });
  }, e;
}(), Ce = function(e) {
  return M(void 0, void 0, void 0, function() {
    var n;
    return p(this, function(t) {
      switch (t.label) {
        case 0:
          return t.trys.push([0, 2, , 3]), [4, e()];
        case 1:
          return t.sent(), [3, 3];
        case 2:
          if (!((n = t.sent()) instanceof j))
            throw n;
          return n.throwOutside(), [3, 3];
        case 3:
          return [2];
      }
    });
  });
}, yn = function(e) {
  return M(void 0, void 0, void 0, function() {
    return p(this, function(n) {
      switch (n.label) {
        case 0:
          return n.trys.push([0, 2, , 3]), [4, e()];
        case 1:
        case 2:
          return n.sent(), [3, 3];
        case 3:
          return [2];
      }
    });
  });
}, Zi = function(e) {
  function n(t) {
    t === void 0 && (t = {});
    var l, a = this;
    return (a = e.call(this) || this).type = tn.LOGOUT, a.name = "logout", a._wasPreviouslyConnected = (l = t.wasPreviouslyConnected) === null || l === void 0 || l, a;
  }
  return J(n, e), n.prototype.run = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d = this;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return l = Date.now(), a = t.sdkState.userId, [4, t.logout()];
          case 1:
            return r.sent(), [4, t.changeState(new MW(), l)];
          case 2:
            return r.sent(), this._wasPreviouslyConnected && Ce(function() {
              return M(d, void 0, void 0, function() {
                return p(this, function(i) {
                  return t.connectionHandlers.forEach(function(c) {
                    c.onDisconnected && c.onDisconnected(a);
                  }), [2];
                });
              });
            }), [2];
        }
      });
    });
  }, n;
}(yV), gR = function(e) {
  function n() {
    var t = e.call(this) || this;
    return t.type = tn.EXTERNAL_DISCONNECTED, t.name = "externaldisconnected", t;
  }
  return J(n, e), n.prototype.run = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, t.disconnect()];
          case 1:
            return l.sent(), [2];
        }
      });
    });
  }, n.prototype.onConnect = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = Date.now(), [4, t.disconnect()];
          case 1:
            return d.sent(), [4, t.changeState(new LR({ authToken: l }), a)];
          case 2:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype.onReconnect = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.changeState(new eR(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.onLogout = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.changeState(new Zi(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n;
}(yV), $N = function(e) {
  function n(t) {
    var l = t.autoReconnect, a = e.call(this) || this;
    return a.type = tn.INTERNAL_DISCONNECTED, a.name = "internaldisconnected", a._autoReconnect = !1, a._autoReconnect = l, a;
  }
  return J(n, e), n.prototype.run = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.disconnect()];
          case 1:
            return a.sent(), this._autoReconnect ? [4, t.changeState(new eR(), l)] : [3, 3];
          case 2:
            a.sent(), a.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, n.prototype.onConnect = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = Date.now(), [4, t.disconnect()];
          case 1:
            return d.sent(), [4, t.changeState(new LR({ authToken: l }), a)];
          case 2:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype.onReconnect = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.changeState(new eR(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.onDisconnectWebSocket = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.changeState(new gR(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.onLogout = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.changeState(new Zi(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n;
}(yV), Qa = function(e) {
  return M(void 0, void 0, void 0, function() {
    return p(this, function(n) {
      return [2, new Promise(function(t) {
        return setTimeout(t, e);
      })];
    });
  });
}, Pk = function() {
  function e() {
  }
  return e.prototype.calcTimeout = function() {
    return 0;
  }, e;
}(), IR = function(e, n, t) {
  return t === void 0 && (t = new Pk()), M(void 0, void 0, void 0, function() {
    var l, a, d, r, i, c;
    return p(this, function(V) {
      switch (V.label) {
        case 0:
          l = 0, a = null, d = function(s) {
            return a = s ?? new Error("Halted");
          }, r = function() {
            l = 0;
          }, V.label = 1;
        case 1:
          if (!(n === -1 || l < n))
            return [3, 9];
          V.label = 2;
        case 2:
          return V.trys.push([2, 4, , 8]), [4, e(d, r)];
        case 3:
          if (i = V.sent(), a)
            throw a;
          return [2, i];
        case 4:
          if (c = V.sent(), a)
            return [3, 6];
          if (++l === n)
            throw c;
          return [4, Qa(t.calcTimeout(l))];
        case 5:
          return V.sent(), [3, 7];
        case 6:
          throw a;
        case 7:
          return [3, 8];
        case 8:
          return [3, 1];
        case 9:
          throw "It should not happen.";
      }
    });
  });
}, eR = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.type = tn.RECONNECTING, t.name = "reconnecting", t._callbacks = [], t;
  }
  return J(n, e), n.prototype._halt = function(t) {
    this._haltConnect && (this._haltConnect(t), this._haltConnect = void 0);
  }, n.prototype._flushCallbacks = function(t) {
    this._haltConnect = void 0, this._resetConnect = void 0, this._callbacks.forEach(function(l) {
      return l(t);
    });
  }, n.prototype.run = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V = this;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            l = Date.now(), a = new Ll(), this._callbacks.push(function(o) {
              return o ? a.reject(o) : a.resolve();
            }), Ce(function() {
              return M(V, void 0, void 0, function() {
                return p(this, function(o) {
                  return t.connectionHandlers.forEach(function(U) {
                    U.onReconnectStarted && U.onReconnectStarted();
                  }), [2];
                });
              });
            }), s.label = 1;
          case 1:
            return s.trys.push([1, 4, , 9]), d = t.sdkState.websocket, r = d.reconnectMaxRetry, i = d.reconnectRetryStrategy, [4, IR(function(o, U) {
              return M(V, void 0, void 0, function() {
                var N;
                return p(this, function(R) {
                  switch (R.label) {
                    case 0:
                      this._haltConnect = o, this._resetConnect = U, R.label = 1;
                    case 1:
                      return R.trys.push([1, 3, , 4]), [4, t.connect()];
                    case 2:
                      return R.sent(), [3, 4];
                    case 3:
                      if (N = R.sent(), t.clearLoginTimer(), N instanceof j) {
                        if (N.code === nt.CONNECTION_CANCELED)
                          return o(N), [2];
                        if (N.isSessionExpiredError || N.isSessionInvalidatedError)
                          return o(N), [2];
                      }
                      throw N;
                    case 4:
                      return [2];
                  }
                });
              });
            }, r, i)];
          case 2:
            return s.sent(), [4, t.changeState(new Ak(), l)];
          case 3:
            return s.sent(), this._flushCallbacks(), Ce(function() {
              return M(V, void 0, void 0, function() {
                return p(this, function(o) {
                  return t.connectionHandlers.forEach(function(U) {
                    U.onReconnectSucceeded && U.onReconnectSucceeded();
                  }), [2];
                });
              });
            }), [3, 9];
          case 4:
            return c = s.sent(), Il(c) ? [3, 7] : c instanceof j ? c.code === nt.CONNECTION_CANCELED ? [3, 6] : [4, t.changeState(new $N({ autoReconnect: !1 }), l)] : [3, 6];
          case 5:
            s.sent(), s.label = 6;
          case 6:
            return this._flushCallbacks(c), Ce(function() {
              return M(V, void 0, void 0, function() {
                return p(this, function(o) {
                  return t.connectionHandlers.forEach(function(U) {
                    U.onReconnectFailed && U.onReconnectFailed();
                  }), [2];
                });
              });
            }), [3, 8];
          case 7:
            throw c;
          case 8:
            return [3, 9];
          case 9:
            return [2, a.promise];
        }
      });
    });
  }, n.prototype.onConnect = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        return a = new Ll(), this._halt(j.connectionCanceled), t.cancelConnectForRetry(), this._callbacks.push(function() {
          var r = Date.now();
          t.changeState(new LR({ authToken: l }), r).then(function() {
            a.resolve();
          }).catch(function(i) {
            a.reject(i);
          });
        }), [2, a.promise];
      });
    });
  }, n.prototype.onReconnect = function(t, l) {
    var a = l.resetReconnectCount, d = a !== void 0 && a;
    return M(this, void 0, void 0, function() {
      var r;
      return p(this, function(i) {
        return r = new Ll(), this._resetConnect && d && this._resetConnect(), this._callbacks.push(function(c) {
          return c ? r.reject(c) : r.resolve();
        }), [2, r.promise];
      });
    });
  }, n.prototype.onDisconnect = function(t, l) {
    l.error;
    var a = l.autoReconnect, d = a === void 0 || a;
    return M(this, void 0, void 0, function() {
      var r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return r = Date.now(), this._halt(j.connectionCanceled), [4, t.changeState(new $N({ autoReconnect: d }), r)];
          case 1:
            return i.sent(), [2];
        }
      });
    });
  }, n.prototype.onDisconnectWebSocket = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), this._halt(j.connectionCanceled), [4, t.changeState(new gR(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.onLogout = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), this._halt(j.connectionCanceled), [4, t.changeState(new Zi(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n;
}(yV), Ak = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.type = tn.CONNECTED, t.name = "connected", t;
  }
  return J(n, e), n.prototype.onReconnect = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.disconnect()];
          case 1:
            return a.sent(), [4, t.changeState(new eR(), l)];
          case 2:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.onDisconnect = function(t, l) {
    var a = l.autoReconnect;
    return M(this, void 0, void 0, function() {
      var d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return d = Date.now(), [4, t.changeState(new $N({ autoReconnect: a }), d)];
          case 1:
            return r.sent(), [2];
        }
      });
    });
  }, n.prototype.onDisconnectWebSocket = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.changeState(new gR(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.onLogout = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.changeState(new Zi(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n;
}(yV);
(function(e) {
  e.ExternalSetBackground = "ExternalSetBackground", e.ExternalDisconnectWebSocket = "ExternalDisconnectWebSocket";
})(kc || (kc = {}));
var yG = function() {
  function e(n, t) {
    var l = t.sdkState, a = t.cacheContext, d = t.connectionHandlers, r = t.sessionManager, i = t.websocketClient, c = t.dispatcher, V = t.logger, s = t.disableWebSocketCloseEventHandling, o = s !== void 0 && s;
    this._disableWebSocketCloseEventHandling = !1, this._webSocketClosedCause = null, this._logger = V, this._disableWebSocketCloseEventHandling = o, this._context = new XG(n, { sdkState: l, cacheContext: a, connectionHandlers: d, sessionManager: r, websocketClient: i, dispatcher: c, logger: V }), this._sdkState = l, this._sessionManager = r, this._websocketClient = i;
  }
  return e.prototype._registerEventDispatcher = function() {
    var n = this;
    this._disableWebSocketCloseEventHandling || (this._clearEventDispatcher(), this._sessionEventDispatcherContext = this._sessionManager.on("refresh", function() {
      n.isConnecting || n.isConnected || (n._logger.debug("try reconnect by session key refresh"), yn(function() {
        return M(n, void 0, void 0, function() {
          return p(this, function(t) {
            switch (t.label) {
              case 0:
                return [4, this.reconnect()];
              case 1:
                return t.sent(), [2];
            }
          });
        });
      }));
    }), this._websocketEventDispatcherContext = this._websocketClient.on("close", function() {
      n._sdkState.appState !== "foreground" || n._webSocketClosedCause || yn(function() {
        return M(n, void 0, void 0, function() {
          return p(this, function(t) {
            switch (t.label) {
              case 0:
                return this._sessionManager.isSessionKeyRefreshing ? [3, 2] : (this._logger.debug("try reconnect by websocket connection closed"), [4, this.reconnect()]);
              case 1:
                return t.sent(), [3, 4];
              case 2:
                return [4, this.disconnectWebSocket()];
              case 3:
                t.sent(), t.label = 4;
              case 4:
                return [2];
            }
          });
        });
      });
    }));
  }, e.prototype._clearEventDispatcher = function() {
    this._sessionEventDispatcherContext && (this._sessionEventDispatcherContext.close(), this._sessionEventDispatcherContext = void 0), this._websocketEventDispatcherContext && (this._websocketEventDispatcherContext.close(), this._websocketEventDispatcherContext = void 0);
  }, Object.defineProperty(e.prototype, "isConnected", { get: function() {
    return this._context.currentState.type === tn.CONNECTED;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "isConnecting", { get: function() {
    var n = this._context.currentState;
    return n.type === tn.CONNECTING || n.type === tn.RECONNECTING;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "websocketClient", { get: function() {
    return this._websocketClient;
  }, enumerable: !1, configurable: !0 }), e.prototype.connect = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return t = this._context.currentState, this._webSocketClosedCause = null, [4, t.onConnect(this._context, n)];
          case 1:
            return l.sent(), this._registerEventDispatcher(), [2];
        }
      });
    });
  }, e.prototype.reconnect = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return n = this._context.currentState, this._webSocketClosedCause = null, [4, n.onReconnect(this._context, {})];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.resetAndReconnect = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return n = this._context.currentState, this._webSocketClosedCause = null, [4, n.onReconnect(this._context, { resetReconnectCount: !0 })];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.background = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return n = this._context.currentState, this._webSocketClosedCause = kc.ExternalSetBackground, [4, n.onDisconnect(this._context, { autoReconnect: !1, cause: this._webSocketClosedCause })];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.disconnect = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this._context.currentState.onDisconnect(this._context, { error: n, autoReconnect: !0, cause: this._webSocketClosedCause })];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.disconnectWebSocket = function(n) {
    return n === void 0 && (n = !1), M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return t = this._context.currentState, n && (this._webSocketClosedCause = kc.ExternalDisconnectWebSocket), [4, t.onDisconnectWebSocket(this._context, { cause: this._webSocketClosedCause })];
          case 1:
            return l.sent(), [2];
        }
      });
    });
  }, e.prototype.logout = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return n = this._context.currentState, this._clearEventDispatcher(), [4, n.onLogout(this._context)];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e;
}(), LR = function(e) {
  function n(t) {
    var l = t.authToken, a = e.call(this) || this;
    return a.type = tn.CONNECTING, a.name = "connecting", a._authToken = "", a._callbacks = [], a._authToken = l, a;
  }
  return J(n, e), n.prototype._halt = function(t) {
    this._haltConnect && (this._haltConnect(t), this._haltConnect = void 0);
  }, n.prototype._flushCallbacks = function(t) {
    this._haltConnect = void 0, this._callbacks.forEach(function(l) {
      return l(t);
    });
  }, n.prototype.run = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r = this;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            l = Date.now(), a = new Ll(), this._callbacks.push(function(c) {
              return c ? a.reject(c) : a.resolve();
            }), i.label = 1;
          case 1:
            return i.trys.push([1, 4, , 10]), [4, IR(function(c) {
              return M(r, void 0, void 0, function() {
                var V;
                return p(this, function(s) {
                  switch (s.label) {
                    case 0:
                      this._haltConnect = c, s.label = 1;
                    case 1:
                      return s.trys.push([1, 3, , 4]), [4, t.connect(this._authToken)];
                    case 2:
                      return s.sent(), [3, 4];
                    case 3:
                      if (V = s.sent(), t.clearLoginTimer(), V instanceof j && V.code === nt.CONNECTION_CANCELED)
                        return c(V), [2];
                      throw V;
                    case 4:
                      return [2];
                  }
                });
              });
            }, t.sdkState.websocket.connectMaxRetry)];
          case 2:
            return i.sent(), [4, t.changeState(new Ak(), l)];
          case 3:
            return i.sent(), Ce(function() {
              return M(r, void 0, void 0, function() {
                return p(this, function(c) {
                  return this._flushCallbacks(), t.connectionHandlers.forEach(function(V) {
                    V.onConnected && V.onConnected(t.sdkState.userId);
                  }), [2];
                });
              });
            }), [3, 10];
          case 4:
            return d = i.sent(), Il(d) ? [3, 8] : [4, t.disconnect()];
          case 5:
            return i.sent(), d instanceof j ? d.code === nt.CONNECTION_CANCELED ? [3, 7] : [4, t.changeState(new MW(), l)] : [3, 7];
          case 6:
            i.sent(), i.label = 7;
          case 7:
            return Ce(function() {
              return M(r, void 0, void 0, function() {
                return p(this, function(c) {
                  return this._flushCallbacks(d), [2];
                });
              });
            }), [3, 9];
          case 8:
            throw d;
          case 9:
            return [3, 10];
          case 10:
            return [2, a.promise];
        }
      });
    });
  }, n.prototype.onConnect = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        return l = new Ll(), this._callbacks.push(function(d) {
          return d ? l.reject(d) : l.resolve();
        }), [2, l.promise];
      });
    });
  }, n.prototype.onDisconnect = function(t, l) {
    var a = l.error, d = a === void 0 ? null : a, r = l.autoReconnect, i = r !== void 0 && r, c = l.cause, V = c === void 0 ? null : c;
    return M(this, void 0, void 0, function() {
      var s;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            return s = Date.now(), this._halt(d ?? au(V)), t.hasSession ? [4, t.changeState(new $N({ autoReconnect: i }), s)] : [3, 2];
          case 1:
            return o.sent(), [3, 4];
          case 2:
            return [4, t.changeState(new Zi(), s)];
          case 3:
            o.sent(), o.label = 4;
          case 4:
            return [2];
        }
      });
    });
  }, n.prototype.onDisconnectWebSocket = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return this._halt(au((l == null ? void 0 : l.cause) || null)), a = Date.now(), t.hasSession ? [4, t.changeState(new gR(), a)] : [3, 2];
          case 1:
            return d.sent(), [3, 4];
          case 2:
            return [4, t.changeState(new Zi(), a)];
          case 3:
            d.sent(), d.label = 4;
          case 4:
            return [2];
        }
      });
    });
  }, n.prototype.onLogout = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), this._halt(j.connectionCanceled), [4, t.changeState(new Zi(), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n;
}(yV);
function au(e) {
  var n = j.connectionCanceled;
  if (e) {
    var t = null;
    switch (e) {
      case kc.ExternalSetBackground:
        t = "Connection has been canceled due to the application having externally moved to background while in ConnectingState.";
        break;
      case kc.ExternalDisconnectWebSocket:
        t = "Connection has been canceled because sb.disconnectWebSocket() was called while in ConnectingState.";
    }
    t && n.setDetail(t);
  }
  return n;
}
var Kr, MW = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.type = tn.INITIALIZED, t.name = "initialized", t;
  }
  return J(n, e), n.prototype.onConnect = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = Date.now(), [4, t.changeState(new LR({ authToken: l }), a)];
          case 1:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype.onLogout = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = Date.now(), [4, t.changeState(new Zi({ wasPreviouslyConnected: !1 }), l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n;
}(yV), BG = function(e) {
  function n() {
    return e.call(this, { code: "PING", payload: { id: Date.now(), active: 1 }, ackRequired: !1 }) || this;
  }
  return J(n, e), n;
}(Yl), DG = function() {
  function e(n) {
    var t = n.pingDelegate, l = n.sdkState, a = n.logger;
    this.pingDelegate = t, this.sdkState = l, this._logger = a;
  }
  return Object.defineProperty(e.prototype, "isWaiting", { get: function() {
    return !!this._pingTimeoutTimer;
  }, enumerable: !1, configurable: !0 }), e.prototype.ping = function() {
    var n, t = this;
    if (!this.sdkState.websocket)
      throw j.connectionRequired;
    var l = new BG();
    try {
      var a = (n = this.sdkState.websocket.pongTimeout) !== null && n !== void 0 ? n : 5e3;
      this._pingTimeoutTimer = setTimeout(function() {
        t._logger.debug("pinger.ping() timeout"), t.pingDelegate.error();
      }, a), this.pingDelegate.send(l), this._logger.debug("pinger.ping()");
    } catch (d) {
      this._logger.debug("pinger.ping() error", d), this._pingTimeoutTimer && (clearTimeout(this._pingTimeoutTimer), this._pingTimeoutTimer = void 0), this.pingDelegate.error();
    }
    return l;
  }, e.prototype.pong = function() {
    this._logger.debug("pinger.pong()"), this._pingTimeoutTimer && (clearTimeout(this._pingTimeoutTimer), this._pingTimeoutTimer = void 0);
  }, e.prototype.refreshTimer = function() {
    var n, t = this;
    if (!this.sdkState.websocket)
      throw j.connectionRequired;
    this._logger.debug("pinger.refreshTimer()");
    var l = (n = this.sdkState.websocket.pingInterval) !== null && n !== void 0 ? n : 15e3;
    this.stop(), this._pingTimer = setInterval(function() {
      t.ping();
    }, l);
  }, e.prototype.start = function() {
    this._logger.debug("pinger.start()"), this.refreshTimer(), this.ping();
  }, e.prototype.stop = function() {
    this._logger.debug("pinger.stop()"), this._pingTimer && (clearInterval(this._pingTimer), this._pingTimer = void 0), this._pingTimeoutTimer && (clearTimeout(this._pingTimeoutTimer), this._pingTimeoutTimer = void 0);
  }, e;
}(), qk = ["premium_feature_list", "file_upload_size_limit", "application_attributes", "emoji_hash", "multiple_file_send_max_size", "notifications", "message_template"], XG = function(e) {
  function n(t, l) {
    var a, d = l.sdkState, r = l.cacheContext, i = l.connectionHandlers, c = l.sessionManager, V = l.websocketClient, s = l.dispatcher, o = l.logger, U = l.entryState, N = U === void 0 ? new MW() : U, R = this;
    return (R = e.call(this) || this)._stateUpdatedAt = 0, R._connectingAt = 0, R._connectionRequestQueue = [], R._iid = t, R.sdkState = d, R.cacheContext = r, R.connectionHandlers = i, R._sessionManager = c, R._websocketClient = V, R._dispatcher = s, R._logger = o, R._currentState = N, !((a = R.sdkState.websocket) === null || a === void 0) && a.pingerDisabled || (R._pinger = new DG({ pingDelegate: { send: function(h) {
      return R._websocketClient.send(h);
    }, error: function(h) {
      return R._websocketClient.error(h);
    } }, sdkState: R.sdkState, logger: o })), R._websocketClient.on("open", function() {
      R._tryResolveConnectionRequest();
    }).on("message", function(h) {
      h.code === "LOGI" && (R.clearLoginTimer(), R._dispatcher.dispatch(h.as(pN)));
    }).on("ping-refresh", function() {
      var h;
      return (h = R._pinger) === null || h === void 0 ? void 0 : h.refreshTimer();
    }).on("pong", function() {
      var h;
      return (h = R._pinger) === null || h === void 0 ? void 0 : h.pong();
    }).on("error", function() {
      var h;
      return (h = R._pinger) === null || h === void 0 ? void 0 : h.stop();
    }).on("close", function() {
      R._logiProcessingTimer = setTimeout(function() {
        R._logiProcessingTimer = void 0, R._unresolvedLogi || R._rejectConnectionRequest(j.networkError);
      }, 500);
    }), R._dispatcher.on(function(h) {
      h instanceof pN && (R._unresolvedLogi = h, R._tryResolveConnectionRequest());
    }), R;
  }
  return J(n, e), Object.defineProperty(n.prototype, "currentState", { get: function() {
    return this._currentState;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "hasSession", { get: function() {
    return this._sessionManager.session.hasSession;
  }, enumerable: !1, configurable: !0 }), n.prototype.changeState = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l >= this._stateUpdatedAt ? (this._currentState = t, this._stateUpdatedAt = l, this._dispatcher.dispatch(new ua({ stateType: t.type })), this._logger.debug("connection state changes to ".concat(t.name)), [4, this._currentState.run(this)]) : [3, 2];
          case 1:
            return a.sent(), [2, !0];
          case 2:
            return [2, !1];
        }
      });
    });
  }, n.prototype._tryResolveConnectionRequest = function() {
    var t;
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = this._unresolvedLogi, this._websocketClient.isOpen && l ? (this._unresolvedLogi = void 0, l.error ? [3, 2] : [4, l.applyTo(this._iid)]) : [3, 3];
          case 1:
            return a.sent(), this._statLogConnection(), (t = this._pinger) === null || t === void 0 || t.start(), this._connectionRequestQueue.forEach(function(d) {
              return d.resolve();
            }), this._connectionRequestQueue = [], this.sdkState.appState = "foreground", [3, 3];
          case 2:
            this._sessionManager.session.authToken = void 0, (l.error.isSessionExpiredError || l.error.isSessionInvalidatedError) && this._dispatcher.dispatch(new Sc({ reason: l.error.code })), this._rejectConnectionRequest(l.error), a.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, n.prototype._rejectConnectionRequest = function(t) {
    var l;
    if ((l = this._pinger) === null || l === void 0 || l.stop(), this.clearLoginTimer(), this._connectionRequestQueue.length > 0) {
      var a = this._connectionRequestQueue;
      this._connectionRequestQueue = [], a.forEach(function(d) {
        return d.reject(t);
      }), this._statLogConnection(t);
    }
  }, n.prototype._url = function() {
    var t, l = this.sdkState, a = l.appId, d = l.appVersion, r = l.userId, i = l.extensions, c = l.sendbirdRuntimeEnvironment, V = this.cacheContext.localCacheEnabled, s = this._sessionManager.session, o = (t = this.sdkState.websocket) === null || t === void 0 ? void 0 : t.compression, U = !!(i ?? {}).sb_uikit, N = KN.userAgentWithExtension(i);
    return "".concat(this.sdkState.websocket.host, "/?p=JS&pv=").concat(encodeURIComponent(oi.OS_VERSION), "&sv=").concat(encodeURIComponent(oi.SDK_VERSION), "&ai=").concat(a).concat(d ? "&av=".concat(d) : "").concat(s.hasSession ? "" : "&user_id=".concat(encodeURIComponent(r)), "&pmce=").concat(o ? 1 : 0, "&active=1&device_token_types=").concat(encodeURIComponent(["gcm", "huawei", "apns"].join(",")), "&SB-User-Agent=").concat(N, "&SB-SDK-User-Agent=").concat(encodeURIComponent(KN.sendbirdSdkUserAgentWithExtension(c)), "&Request-Sent-Timestamp=").concat(Date.now().toString(), "&include_extra_data=").concat(encodeURIComponent(String(qk))).concat(this._sessionManager.handler ? "&expiring_session=1" : "", "&use_local_cache=").concat(V ? 1 : 0, "&include_poll_details=1").concat(U ? "&uikit_config=1" : "");
  }, n.prototype._statLogConnection = function(t) {
    var l;
    this._dispatcher.dispatch(new WW(new Ml({ type: Mn.WEBSOCKET_CONNECT, data: { host_url: (l = this.sdkState.websocket) === null || l === void 0 ? void 0 : l.host, success: !t, latency: Date.now() - this._connectingAt, error_code: t == null ? void 0 : t.code, error_description: t == null ? void 0 : t.message } })));
  }, n.prototype.connect = function(t) {
    var l;
    return t === void 0 && (t = ""), M(this, void 0, void 0, function() {
      var a, d, r, i = this;
      return p(this, function(c) {
        return this._logiProcessingTimer && (clearTimeout(this._logiProcessingTimer), this._logiProcessingTimer = void 0, this._rejectConnectionRequest(j.connectionCanceled)), a = this._url(), d = new Ll(), this._connectionRequestQueue.push(d), this._connectionRequestQueue.length === 1 && (this._connectingAt = Date.now(), this._loginTimer = setTimeout(function() {
          i._loginTimer = void 0, i._rejectConnectionRequest(j.loginTimeout);
        }, (l = this.sdkState.websocket) === null || l === void 0 ? void 0 : l.responseTimeout), r = this._sessionManager.session, t && (r.authToken = t), this._websocketClient.connect(a, JSON.stringify(r.hasSession ? { auth: r.sessionKey } : { token: t }))), [2, d.promise];
      });
    });
  }, n.prototype.cancelConnectForRetry = function() {
    this._dispatcher.dispatch(pN.asError(j.connectionRenew));
  }, n.prototype.disconnect = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this._websocketClient.disconnect()];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, n.prototype.logout = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this.sdkState.userId = void 0, this._unresolvedLogi = void 0, [4, this.disconnect()];
          case 1:
            return t.sent(), [4, this._sessionManager.clear()];
          case 2:
            return t.sent(), [2];
        }
      });
    });
  }, n.prototype.clearLoginTimer = function() {
    this._loginTimer && (clearTimeout(this._loginTimer), this._loginTimer = void 0);
  }, n;
}(zV), $k = function(e) {
  function n(t) {
    var l = t.appId, a = t.userId, d = t.services, r = t.includeUIKitConfig, i = r !== void 0 && r, c = t.localCacheEnabled, V = c === void 0 || c, s = t.expiringSession, o = s === void 0 || s, U = e.call(this) || this;
    return U.path = "".concat(It, "/").concat(a, "/login"), U.method = he.POST, U.params = je({ expiring_session: !!o, services: d, include_logi: !0, include_extra_data: String(qk), uikit_config: i, use_local_cache: V, app_id: l }), U.requireAuth = !1, U;
  }
  return J(n, e), n;
}(Te), OG = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.logi = new pN(t, "LOGI", l), a;
  }
  return J(n, e), n;
}(ue);
(function(e) {
  e[e.ALL = 0] = "ALL", e[e.WEBSOCKET = 1] = "WEBSOCKET", e[e.API = 2] = "API";
})(Kr || (Kr = {}));
var Qd, jG = [FW, $k], HG = function() {
  function e(n, t) {
    var l = t.session, a = t.sdkState, d = t.dispatcher, r = t.logger, i = t.useFetchCompat, c = i !== void 0 && i, V = this;
    this._currentConnectionStateType = tn.INITIALIZED, this._lazyCallQueue = [], this.commandRouter = new bG(n, { session: l, sdkState: a, dispatcher: d, logger: r, useFetchCompat: c }), this._session = l, this._logger = r, this._dispatcher = d, this._dispatcher.on(function(s) {
      var o, U, N, R;
      if (s instanceof ua) {
        var h = s.stateType;
        switch (V._currentConnectionStateType = h, h) {
          case tn.CONNECTED:
            V._resolveLazyCallQueue();
            break;
          case tn.INITIALIZED:
          case tn.INTERNAL_DISCONNECTED:
          case tn.EXTERNAL_DISCONNECTED:
          case tn.LOGOUT:
            V._rejectLazyCallQueue(!((N = V._session) === null || N === void 0) && N.hasSession ? j.connectionClosed : j.connectionRequired);
        }
      } else if (s instanceof Lk)
        !((R = V._session.services) === null || R === void 0) && R.includes(ho.CHAT) || V._resolveLazyCallQueue(Kr.API);
      else if (s instanceof XT || s instanceof Ck)
        V._rejectLazyCallQueue(j.connectionClosed);
      else if (s instanceof kk) {
        var Z = s.request, W = s.deferred, F = s.error;
        try {
          for (var m = be(jG), E = m.next(); !E.done; E = m.next())
            if (Z instanceof E.value)
              return void W.reject(F);
        } catch (u) {
          o = { error: u };
        } finally {
          try {
            E && !E.done && (U = m.return) && U.call(m);
          } finally {
            if (o)
              throw o.error;
          }
        }
        V._lazyCallQueue.push({ command: Z, deferred: W });
      }
    });
  }
  return Object.defineProperty(e.prototype, "isReady", { get: function() {
    return this._currentConnectionStateType === tn.CONNECTED;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "isLazyCallActivated", { get: function() {
    return this._currentConnectionStateType === tn.CONNECTING || this._currentConnectionStateType === tn.RECONNECTING || this._session.isRefreshing;
  }, enumerable: !1, configurable: !0 }), e.prototype._classifyLazyCallQueueByScope = function(n) {
    var t, l = [], a = [];
    switch (n) {
      case Kr.ALL:
        t = null;
        break;
      case Kr.WEBSOCKET:
        t = Yl;
        break;
      case Kr.API:
        t = Te;
    }
    var d = !1;
    return this._lazyCallQueue.forEach(function(r) {
      !t || r.command instanceof t || (d = !0), d ? a.push(r) : l.push(r);
    }), [l, a];
  }, e.prototype._resolveLazyCallQueue = function(n) {
    var t = this;
    n === void 0 && (n = Kr.ALL);
    var l = et(this._classifyLazyCallQueueByScope(n), 2), a = l[0], d = l[1];
    this._lazyCallQueue = d, a.forEach(function(r) {
      return M(t, void 0, void 0, function() {
        var i, c, V, s, o;
        return p(this, function(U) {
          switch (U.label) {
            case 0:
              i = r.command, c = r.deferred, (V = r.timeout) && clearTimeout(V), U.label = 1;
            case 1:
              return U.trys.push([1, 3, , 4]), [4, this.send(i)];
            case 2:
              return s = U.sent(), c.resolve(s), [3, 4];
            case 3:
              return o = U.sent(), c.reject(o), [3, 4];
            case 4:
              return [2];
          }
        });
      });
    });
  }, e.prototype._rejectLazyCallQueue = function(n, t) {
    var l = this;
    t === void 0 && (t = Kr.ALL);
    var a = et(this._classifyLazyCallQueueByScope(t), 2), d = a[0], r = a[1];
    this._lazyCallQueue = r, d.forEach(function(i) {
      return M(l, void 0, void 0, function() {
        var c, V;
        return p(this, function(s) {
          return c = i.deferred, V = i.timeout, clearTimeout(V), c.reject(n), [2];
        });
      });
    });
  }, e.prototype.send = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a = this;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return n instanceof Yl ? this.isReady ? (this._logger.debug("send websocket request", n), [4, this.commandRouter.send(n)]) : [3, 2] : [3, 4];
          case 1:
          case 5:
            return [2, d.sent()];
          case 2:
            if (this.isLazyCallActivated)
              return this._logger.debug("wait websocket request", n), t = new Ll(), this._lazyCallQueue.push({ command: n, deferred: t, timeout: setTimeout(function() {
                return a.timeout(n.requestId);
              }, 1e4) }), [2, t.promise];
            throw this._logger.debug("fail websocket request"), j.connectionRequired;
          case 3:
          case 7:
            return [3, 9];
          case 4:
            return n instanceof Te ? this._session.hasSession ? (this._logger.debug("send api request", n), [4, this.commandRouter.send(n)]) : [3, 6] : [3, 8];
          case 6:
            if (this.isLazyCallActivated)
              return this._logger.debug("wait api request", n), t = new Ll(), this._lazyCallQueue.push({ command: n, deferred: t, timeout: setTimeout(function() {
                return a.timeout(n.requestId);
              }, 1e4) }), [2, t.promise];
            throw l = j.connectionRequired, this._logger.debug("fail api request", l), l;
          case 8:
            throw j.invalidCommand;
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype.forceSend = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this._logger.debug("send forced request", n), n instanceof Yl || n instanceof Te ? [4, this.commandRouter.send(n)] : [3, 2];
          case 1:
            return [2, t.sent()];
          case 2:
            throw j.invalidCommand;
        }
      });
    });
  }, e.prototype.timeout = function(n) {
    this._logger.debug("timeout request", n);
    var t = this._lazyCallQueue.findIndex(function(l) {
      return l.command.requestId === n;
    });
    t > -1 && (this._lazyCallQueue[t].deferred.reject(j.connectionRequired), this._lazyCallQueue.splice(t, 1));
  }, e.prototype.cancel = function(n) {
    this._logger.debug("cancel api request", n), this.commandRouter.cancel(n);
  }, e.prototype.cancelAll = function() {
    this._logger.debug("cancel all api requests"), this.commandRouter.cancelAll();
  }, e;
}(), oZ = "sendbird@devicetokens", UZ = function() {
  function e(n) {
    var t = n.type, l = n.token;
    this.type = t, this.token = l;
  }
  return e.payloadify = function(n) {
    return je(Ae({ type: n.type, token: n.token }));
  }, e;
}(), NZ = /* @__PURE__ */ new WeakMap(), fG = function(e) {
  function n(t) {
    var l = t._iid, a = t.session, d = t.cacheContext, r = t.sdkState, i = t.dispatcher, c = t.requestQueue, V = t.logger, s = e.call(this) || this;
    return s._currentConnectionStateType = tn.INITIALIZED, s._isRefreshingAuthToken = !1, s.currentUser = null, s.session = a, s._iid = l, s._cacheContext = d, s._sdkState = r, s._dispatcher = i, s._requestQueue = c, s._logger = V, s._deviceTokens = [], s._dispatcher.on(function(o) {
      var U, N;
      if (o instanceof ua) {
        var R = o.stateType;
        s._currentConnectionStateType = R;
      } else
        o instanceof Sc && s.handler && !s.isSessionKeyRefreshing && (o.invalidateSessionToken && (s.session.authToken = void 0), !((U = o.error) === null || U === void 0) && U.isSessionInvalidatedError ? s.handler.onSessionClosed && s.handler.onSessionClosed() : !((N = o.error) === null || N === void 0) && N.isSessionExpiredError && (s._logger.debug("session expired"), s.handler.onSessionExpired && s.handler.onSessionExpired(), s.refresh().catch(function(h) {
          if (Il(h) && s._sdkState.appState === "foreground")
            throw h;
        })));
    }), s;
  }
  return J(n, e), Object.defineProperty(n.prototype, "ekey", { get: function() {
    return NZ.get(this);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "deviceTokens", { get: function() {
    return this._deviceTokens;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "deviceTokenLastDeletedAt", { get: function() {
    return this._deviceTokenLastDeletedAt;
  }, enumerable: !1, configurable: !0 }), n.prototype.indexOfDeviceToken = function(t, l) {
    return this._deviceTokens.findIndex(function(a) {
      return a.type === t && a.token === l;
    });
  }, n.prototype.hasDeviceToken = function(t, l) {
    return this.indexOfDeviceToken(t, l) >= 0;
  }, n.prototype.createRefreshWebsocketCommand = function(t, l) {
    return new ux({ authToken: t, expiringSession: !0, requestId: l });
  }, n.prototype._refreshSessionKeyByWebSocket = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return l = this.createRefreshWebsocketCommand(t), [4, this._requestQueue.forceSend(l)];
          case 1:
            if (a = c.sent(), d = a.as(Mx), r = d.newKey, i = d.error)
              throw i;
            return this.session.sessionKey = r ?? this.session.sessionKey, [2];
        }
      });
    });
  }, n.prototype._refreshSessionKeyByApi = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a = this;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return l = new FW({ userId: this._sdkState.userId, authToken: t, services: this.session.services && this.session.services.length > 0 ? this.session.services : void 0, expiringSession: !0 }), [4, IR(function(r) {
              return M(a, void 0, void 0, function() {
                var i, c, V, s, o;
                return p(this, function(U) {
                  switch (U.label) {
                    case 0:
                      return U.trys.push([0, 2, , 3]), [4, this._requestQueue.forceSend(l)];
                    case 1:
                      return i = U.sent(), c = i.as(px), V = c.key, s = c.services, this.session.sessionKey = V, this.session.services = s, [3, 3];
                    case 2:
                      if (o = U.sent(), !this._isSessionRelatedError(o))
                        throw o;
                      return r(o), [3, 3];
                    case 3:
                      return [2];
                  }
                });
              });
            }, 3)];
          case 1:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype._refreshSessionKey = function(t, l) {
    return l === void 0 && (l = !0), M(this, void 0, void 0, function() {
      var a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            if (this._currentConnectionStateType !== tn.CONNECTED)
              return [3, 8];
            r.label = 1;
          case 1:
            return r.trys.push([1, 3, , 8]), [4, this._refreshSessionKeyByWebSocket(t)];
          case 2:
            return r.sent(), this.complete(), [2];
          case 3:
            a = r.sent(), r.label = 4;
          case 4:
            return r.trys.push([4, 6, , 7]), [4, this._handleSessionRefreshError(a, l)];
          case 5:
            return r.sent(), [2];
          case 6:
            return r.sent(), [3, 7];
          case 7:
            return [3, 8];
          case 8:
            return r.trys.push([8, 10, , 12]), [4, this._refreshSessionKeyByApi(t)];
          case 9:
            return r.sent(), this.complete(), [3, 12];
          case 10:
            return d = r.sent(), [4, this._handleSessionRefreshError(d, l)];
          case 11:
            return r.sent(), [3, 12];
          case 12:
            return [2];
        }
      });
    });
  }, n.prototype._receiveNewAuthToken = function() {
    var t, l = this, a = new Ll();
    if (this._isRefreshingAuthToken = !0, this.session.sessionKey = void 0, this.session.authToken = void 0, (t = this.handler) === null || t === void 0 ? void 0 : t.onSessionTokenRequired) {
      var d = null, r = function() {
        d && (clearTimeout(d), d = null);
      }, i = function(V) {
        r(), l._isRefreshingAuthToken && (l._isRefreshingAuthToken = !1, a.resolve(V));
      }, c = function(V) {
        r(), l._isRefreshingAuthToken && (l._isRefreshingAuthToken = !1, a.reject(V));
      };
      d = setTimeout(function() {
        return c();
      }, 1e3 * this._sdkState.sessionTokenRefreshTimeout), Ce(function() {
        return M(l, void 0, void 0, function() {
          var V;
          return p(this, function(s) {
            return !((V = this.handler) === null || V === void 0) && V.onSessionTokenRequired && this.handler.onSessionTokenRequired(i, c), [2];
          });
        });
      });
    } else
      a.resolve(null);
    return a.promise;
  }, n.prototype._handleSessionRefreshError = function(t, l) {
    return l === void 0 && (l = !1), M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return t instanceof j && (t.isSessionTokenExpiredError || t.code === nt.APPLICATION_NOT_FOUND) ? (this.session.authToken = void 0, l ? [4, this._receiveNewAuthToken()] : [3, 6]) : [3, 6];
          case 1:
            return (a = d.sent()) ? (this.session.authToken = a, [4, this._refreshSessionKey(this.session.authToken, !1)]) : [3, 3];
          case 2:
            return d.sent(), this.complete(), [3, 5];
          case 3:
            return [4, this.clear()];
          case 4:
            d.sent(), d.label = 5;
          case 5:
            return [2];
          case 6:
            throw t;
        }
      });
    });
  }, n.prototype._isSessionRelatedError = function(t) {
    return t instanceof j && (t.isSessionExpiredError || t.isSessionInvalidatedError);
  }, Object.defineProperty(n.prototype, "isSessionKeyRefreshing", { get: function() {
    return this.session.isRefreshing;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isRefreshingAuthToken", { get: function() {
    return this._isRefreshingAuthToken;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isSessionExpiring", { get: function() {
    return !!this.handler;
  }, enumerable: !1, configurable: !0 }), n.prototype.authenticateFeed = function(t, l) {
    var a;
    return M(this, void 0, void 0, function() {
      var d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this.session.authToken = l, d = new $k({ appId: this._sdkState.appId, userId: t, services: [ho.FEED], includeUIKitConfig: !!((a = this._sdkState.extensions) !== null && a !== void 0 ? a : {}).sb_uikit, localCacheEnabled: this._cacheContext.localCacheEnabled, expiringSession: !l || this.isSessionExpiring }), [4, this._requestQueue.commandRouter.send(d)];
          case 1:
            return r = c.sent(), (i = r.as(OG).logi).error ? [3, 3] : [4, i.applyTo(this._iid)];
          case 2:
            return c.sent(), [3, 4];
          case 3:
            throw i.error;
          case 4:
            return [2];
        }
      });
    });
  }, n.prototype.login = function(t) {
    var l;
    return M(this, void 0, void 0, function() {
      var a, d, r, i, c, V, s, o;
      return p(this, function(U) {
        switch (U.label) {
          case 0:
            return a = t.key, d = t.ekey, r = t.services, i = t.userProfile, c = t.deviceTokenLastDeletedAt, V = c === void 0 ? 0 : c, this.session.sessionKey = a, this.session.services = r, NZ.set(this, d), this._deviceTokenCacheEnabled = (l = i == null ? void 0 : i.appInfo) === null || l === void 0 ? void 0 : l.deviceTokenCache, s = this._cacheContext.preference, this._deviceTokenCacheEnabled ? [4, s.get(oZ)] : [3, 5];
          case 1:
            return !(o = U.sent()) || o.lastDeletedAt < V ? (this._deviceTokens = [], this._deviceTokenLastDeletedAt = V, [4, this.saveDeviceToken()]) : [3, 3];
          case 2:
            return U.sent(), [3, 4];
          case 3:
            this._deviceTokens = o.tokens.map(function(N) {
              return new UZ(UZ.payloadify(N));
            }), this._deviceTokenLastDeletedAt = o.lastDeletedAt, U.label = 4;
          case 4:
            return [3, 7];
          case 5:
            return [4, s.remove(oZ)];
          case 6:
            U.sent(), U.label = 7;
          case 7:
            return [2];
        }
      });
    });
  }, n.prototype.complete = function() {
    var t = this;
    this.dispatch("refresh"), this._dispatcher.dispatch(new Lk()), Ce(function() {
      return M(t, void 0, void 0, function() {
        var l;
        return p(this, function(a) {
          return this._logger.debug("session refreshed"), !((l = this.handler) === null || l === void 0) && l.onSessionRefreshed && this.handler.onSessionRefreshed(), [2];
        });
      });
    });
  }, n.prototype.error = function(t) {
    var l = this;
    Ce(function() {
      return M(l, void 0, void 0, function() {
        var a;
        return p(this, function(d) {
          return !((a = this.handler) === null || a === void 0) && a.onSessionError && this.handler.onSessionError(t), [2];
        });
      });
    });
  }, n.prototype.close = function() {
    var t = this;
    this.dispatch("close"), this._dispatcher.dispatch(new Ck()), Ce(function() {
      return M(t, void 0, void 0, function() {
        var l;
        return p(this, function(a) {
          return this._logger.debug("session closed"), !((l = this.handler) === null || l === void 0) && l.onSessionClosed && this.handler.onSessionClosed(), [2];
        });
      });
    });
  }, n.prototype.refresh = function() {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            if (!this.isSessionExpiring)
              return [3, 10];
            if (this.session.isRefreshing)
              return [3, 10];
            if (this.session.isRefreshing = !0, this.session.authToken)
              return [3, 7];
            a.label = 1;
          case 1:
            return a.trys.push([1, 6, , 7]), [4, this._receiveNewAuthToken()];
          case 2:
            return (t = a.sent()) ? (this._logger.debug("session refreshing.."), this.session.authToken = t, [3, 5]) : [3, 3];
          case 3:
            return [4, this.clear()];
          case 4:
            return a.sent(), this.session.isRefreshing = !1, [2];
          case 5:
            return [3, 7];
          case 6:
            throw a.sent(), l = j.sessionTokenRequestFailed, this._dispatcher.dispatch(new XT()), this.error(l), this.session.isRefreshing = !1, this._logger.debug("refresh auth token error = ", l), l;
          case 7:
            return a.trys.push([7, 9, , 10]), [4, this._refreshSessionKey(this.session.authToken)];
          case 8:
            return a.sent(), this.session.isRefreshing = !1, [3, 10];
          case 9:
            throw a.sent(), this.session.isRefreshing = !1, l = j.sessionTokenRefreshFailed, this._dispatcher.dispatch(new XT()), this.error(l), l;
          case 10:
            return [2];
        }
      });
    });
  }, n.prototype.setDeviceToken = function(t, l) {
    return this._deviceTokenCacheEnabled && this.indexOfDeviceToken(t, l) < 0 ? (this._deviceTokens.push(new UZ({ type: t, token: l })), !0) : !1;
  }, n.prototype.unsetDeviceToken = function(t, l) {
    if (this._deviceTokenCacheEnabled) {
      var a = this.indexOfDeviceToken(t, l);
      a >= 0 && this._deviceTokens.splice(a, 1);
    }
  }, n.prototype.unsetDeviceTokens = function(t) {
    this._deviceTokenCacheEnabled && (this._deviceTokens = t ? this._deviceTokens.filter(function(l) {
      return l.type !== t;
    }) : []);
  }, n.prototype.setDeviceTokenDeletedAt = function(t) {
    t > 0 && (this._deviceTokenLastDeletedAt = t);
  }, n.prototype.saveDeviceToken = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this._deviceTokenCacheEnabled ? [4, this._cacheContext.preference.set(oZ, { tokens: this._deviceTokens, lastDeletedAt: this._deviceTokenLastDeletedAt })] : [3, 2];
          case 1:
            t.sent(), t.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this.currentUser = null, this.session.clear(), this.close(), NZ.delete(this), this._deviceTokens = [], this._deviceTokenLastDeletedAt = 0, [4, this.saveDeviceToken()];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, n;
}(zV), nV = function(e) {
  function n(t) {
    var l, a, d, r, i = t.type, c = t.data, V = t.ts, s = V === void 0 ? Date.now() : V, o = e.call(this, { type: i, data: c, ts: s }) || this;
    return o.date = new Date(s), o.key = "".concat((l = o.date, a = l.getFullYear(), d = String(l.getMonth() + 1).padStart(2, "0"), r = String(l.getDate()).padStart(2, "0"), "".concat(a).concat(d).concat(r)), "_").concat(i), o;
  }
  return J(n, e), n;
}(Ml), wG = function(e) {
  function n(t) {
    var l = t.deviceId, a = t.statLogs, d = e.call(this) || this;
    return d.method = he.POST, d.path = "".concat(Wx), d.params = { device_id: l, log_entries: a.map(function(r) {
      return Ml.payloadify(r);
    }) }, d;
  }
  return J(n, e), n;
}(Te), e3 = function(e, n) {
  var t, l;
  if (e !== null && n !== null) {
    var a = Object.keys(e), d = Object.keys(n), r = ot([], et(new Set(ot(ot([], et(a), !1), et(d), !1))), !1), i = {};
    try {
      for (var c = be(r), V = c.next(); !V.done; V = c.next()) {
        var s = V.value, o = typeof e[s], U = typeof n[s];
        o === "undefined" ? i[s] = n[s] : U === "undefined" ? i[s] = e[s] : o !== U ? i[s] = n[s] : o === "object" && e[s] && n[s] ? i[s] = e3(e[s], n[s]) : i[s] = n[s];
      }
    } catch (N) {
      t = { error: N };
    } finally {
      try {
        V && !V.done && (l = c.return) && l.call(c);
      } finally {
        if (t)
          throw t.error;
      }
    }
    return i;
  }
  return n;
};
(function(e) {
  e[e.PENDING = 0] = "PENDING", e[e.COLLECT_ONLY = 1] = "COLLECT_ONLY", e[e.ENABLED = 2] = "ENABLED", e[e.DISABLED = 3] = "DISABLED";
})(Qd || (Qd = {}));
var Tr, gG = function(e) {
  function n(t) {
    var l = t.cacheContext, a = t.requestQueue, d = t.dispatcher, r = t.baseLimit, i = r === void 0 ? 100 : r, c = t.maxLimit, V = c === void 0 ? 1e3 : c, s = t.minLimit, o = s === void 0 ? 10 : s, U = e.call(this) || this;
    return U.queue = [], U.flushWaitQueue = [], U.enabledState = Qd.PENDING, U.isFlushing = !1, U.generation = 1, U.lastFlushedAt = Date.now(), U._collectRequestStat = !0, U._collectFeatureLocalCacheStat = !0, U._collectionNotificationStat = !0, U.deviceId = vr(), U.cacheContext = l, U.requestQueue = a, U.dispatcher = d, U.baseLimit = i, U.limit = i, U.maxLimit = V, U.minLimit = o, U;
  }
  return J(n, e), Object.defineProperty(n.prototype, "isEnabled", { get: function() {
    return this.enabledState === Qd.ENABLED;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isReadyToFlush", { get: function() {
    return this.queue.length >= this.limit || Date.now() - this.lastFlushedAt >= 108e5 && this.queue.length >= this.minLimit;
  }, enumerable: !1, configurable: !0 }), n.prototype._arrangeStat = function() {
    var t = ot([], et(this.queue), !1);
    this._collectRequestStat || (t = t.filter(function(l) {
      return l.type !== Mn.API_RESULT && l.type !== Mn.WEBSOCKET_CONNECT;
    })), this._collectFeatureLocalCacheStat || (t = t.filter(function(l) {
      return l.type !== Mn.FEATURE_LOCALCACHE && l.type !== Mn.FEATURE_LOCALCACHE_EVENT;
    })), this._collectionNotificationStat || (t = t.filter(function(l) {
      return l.type !== Mn.NOTIFICATION;
    })), this.queue = t;
  }, n.prototype._save = function() {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.isEnabled ? (t = ot(ot([], et(this.queue), !1), et(this.flushWaitQueue), !1), [4, this.cacheContext.preference.set(this.key, { deviceId: this.deviceId, statLogs: t.map(function(a) {
              return Ml.payloadify(a);
            }), generation: this.generation++, lastFlushedAt: this.lastFlushedAt })]) : [3, 2];
          case 1:
            l.sent(), this.dispatch("save", t), l.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype._flush = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            if (!this.isEnabled)
              return [3, 10];
            if (this.isFlushing)
              return [3, 10];
            this.isFlushing = !0, i.label = 1;
          case 1:
            return i.trys.push([1, 5, 9, 10]), this._arrangeStat(), t = this.queue.filter(function(c) {
              if (c instanceof nV) {
                var V = /* @__PURE__ */ new Date(), s = et([c.date.getFullYear(), V.getFullYear()], 2), o = s[0], U = s[1];
                if (o < U)
                  return !0;
                if (o === U) {
                  var N = et([c.date.getMonth(), V.getMonth()], 2), R = N[0], h = N[1];
                  if (R < h)
                    return !0;
                  if (R === h) {
                    var Z = et([c.date.getDate(), V.getDate()], 2);
                    return Z[0] < Z[1];
                  }
                }
              }
              return !1;
            }), l = this.queue.filter(function(c) {
              return !(c instanceof nV);
            }), (a = ot(ot([], et(t), !1), et(l), !1).slice(0, Math.min(this.limit, this.maxLimit))).length > 0 ? (d = new wG({ deviceId: this.deviceId, statLogs: a }), [4, this.requestQueue.send(d)]) : [3, 4];
          case 2:
            return i.sent(), this.dispatch("flush", a), this.queue = ot(ot([], et(t), !1), et(l), !1).slice(a.length).concat(this.flushWaitQueue), this.flushWaitQueue = [], this.limit = this.baseLimit, this.lastFlushedAt = Date.now(), [4, this._save()];
          case 3:
            i.sent(), i.label = 4;
          case 4:
            return [3, 10];
          case 5:
            return (r = i.sent()) instanceof j ? r.code !== nt.NON_AUTHORIZED ? [3, 7] : [4, this.clear()] : [3, 8];
          case 6:
            return i.sent(), this.enabledState = Qd.DISABLED, [3, 8];
          case 7:
            r.code === nt.STAT_UPLOAD_NOT_ALLOWED && (this.enabledState = Qd.COLLECT_ONLY), i.label = 8;
          case 8:
            return this.limit = this.limit + 20, [3, 10];
          case 9:
            return this.isFlushing = !1, [7];
          case 10:
            return [2];
        }
      });
    });
  }, n.prototype.init = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d = this;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return this.key = t, [4, this.cacheContext.preference.get(this.key)];
          case 1:
            return (l = r.sent()) ? (this.deviceId = l.deviceId, this.queue = l.statLogs.map(function(i) {
              var c;
              return i.stat_type === Mn.FEATURE_LOCALCACHE_EVENT && (i.data = x({ message_init_policy: "", starting_point: 0 }, i.data)), i.stat_type === Mn.NOTIFICATION && (i.data = je(x(x({}, i.data), { message_id: (c = i.data.notificationId) !== null && c !== void 0 ? c : i.data.message_id, notificationId: void 0 }))), new Ml({ type: i.stat_type, ts: i.ts, data: i.data });
            }), this.generation = l.generation, this.lastFlushedAt = l.lastFlushedAt, this.isReadyToFlush ? (a = Math.min(Math.floor(18e4 * Math.random()), 100), [4, Qa(a)]) : [3, 4]) : [3, 4];
          case 2:
            return r.sent(), [4, this._flush()];
          case 3:
            r.sent(), r.label = 4;
          case 4:
            return this.commandEventContext || (this.commandEventContext = this.dispatcher.on(function(i) {
              if (i instanceof WW) {
                var c = i.statLog;
                d.put(c);
              } else if (i instanceof _k) {
                var V = i.request, s = i.features, o = i.options;
                d._collectRequestStat = V, d._collectFeatureLocalCacheStat = s == null ? void 0 : s.localCache, d._collectionNotificationStat = s == null ? void 0 : s.notification, d._arrangeStat(), d._collectRequestStat || d._collectFeatureLocalCacheStat || d._collectionNotificationStat ? d.enabledState = o.ingestion ? Qd.ENABLED : Qd.COLLECT_ONLY : d.enabledState = Qd.DISABLED, d.isEnabled ? d.isReadyToFlush && d._flush() : d.clear();
              }
            })), [2];
        }
      });
    });
  }, n.prototype.put = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            if (this.enabledState === Qd.DISABLED)
              return [3, 3];
            if (l = this.isFlushing ? this.flushWaitQueue : this.queue, t instanceof nV)
              this._collectFeatureLocalCacheStat && (a = et(this.queue.filter(function(i) {
                return i instanceof nV && i.key === t.key;
              }), 1), (d = a[0]) ? d.data = e3(d.data, t.data) : l.push(t));
            else
              switch (t.type) {
                case Mn.API_RESULT:
                case Mn.WEBSOCKET_CONNECT:
                  this._collectRequestStat && l.push(t);
                  break;
                case Mn.FEATURE_LOCALCACHE:
                case Mn.FEATURE_LOCALCACHE_EVENT:
                  this._collectFeatureLocalCacheStat && l.push(t);
                  break;
                case Mn.NOTIFICATION:
                  this._collectionNotificationStat && l.push(t);
              }
            return [4, this._save()];
          case 1:
            return r.sent(), this.isReadyToFlush ? [4, this._flush()] : [3, 3];
          case 2:
            r.sent(), r.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this.queue = [], this.flushWaitQueue = [], this.generation = 1, [4, this._save()];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, n.prototype.close = function() {
    this.commandEventContext && (this.commandEventContext.close(), this.commandEventContext = void 0);
  }, n;
}(zV);
(function(e) {
  e[e.VERBOSE = 0] = "VERBOSE", e[e.DEBUG = 1] = "DEBUG", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.NONE = 5] = "NONE";
})(Tr || (Tr = {}));
var ne, IG = function() {
  function e() {
    this.level = Tr.WARN;
  }
  return e.prototype.verbose = function() {
    for (var n = [], t = 0; t < arguments.length; t++)
      n[t] = arguments[t];
    this.level <= Tr.VERBOSE && console.log.apply(console, ot(["[verbose]"], et(n), !1));
  }, e.prototype.debug = function() {
    for (var n = [], t = 0; t < arguments.length; t++)
      n[t] = arguments[t];
    this.level <= Tr.DEBUG && console.log.apply(console, ot(["[debug]"], et(n), !1));
  }, e.prototype.info = function() {
    for (var n = [], t = 0; t < arguments.length; t++)
      n[t] = arguments[t];
    this.level <= Tr.INFO && console.log.apply(console, ot(["[info]"], et(n), !1));
  }, e.prototype.warn = function() {
    for (var n = [], t = 0; t < arguments.length; t++)
      n[t] = arguments[t];
    this.level <= Tr.WARN && console.warn.apply(console, ot(["[warn]"], et(n), !1));
  }, e.prototype.error = function() {
    for (var n = [], t = 0; t < arguments.length; t++)
      n[t] = arguments[t];
    this.level <= Tr.ERROR && console.error.apply(console, ot(["[error]"], et(n), !1));
  }, e;
}(), yi = {}, D = function() {
  function e(n, t) {
    var l, a, d, r, i, c, V, s, o, U;
    if (this.connectedAt = 0, this.firstConnectedAt = 0, this.connectionHandlers = /* @__PURE__ */ new Map(), this.userEventHandlers = /* @__PURE__ */ new Map(), !yi[n]) {
      yi[n] = this;
      var N = (l = t.options) !== null && l !== void 0 ? l : new Fk(), R = this.sdkState = { appId: t.appId, appVersion: (a = t.appVersion) !== null && a !== void 0 ? a : "", appState: "foreground", userId: void 0, extensions: {}, api: { host: (d = t.apiHost) !== null && d !== void 0 ? d : "https://api-".concat(t.appId, ".sendbird.com") }, websocket: { host: (r = t.websocketHost) !== null && r !== void 0 ? r : "wss://ws-".concat(t.appId, ".sendbird.com"), pingerDisabled: !!t.noPingpong, pingInterval: void 0, pongTimeout: void 0, connectMaxRetry: 2, compression: !0, reconnectMaxRetry: -1, reconnectRetryStrategy: new Pk(), responseTimeout: N.websocketResponseTimeout }, sessionTokenRefreshTimeout: N.sessionTokenRefreshTimeout };
      this.appInfo = void 0, this.subscribedUnreadMessageCount = { all: 0, feed: 0, customTypes: {}, ts: 0 };
      var h = this.logger = new IG();
      this.logger.level = (i = t.logLevel) !== null && i !== void 0 ? i : Tr.WARN, this.connectedAt = 0, this.firstConnectedAt = 0, this.connectionHandlers = /* @__PURE__ */ new Map(), this.userEventHandlers = /* @__PURE__ */ new Map();
      var Z = this.cacheContext = new cx({ encryption: t.encryption, store: t.store, localCacheEnabled: (c = t.localCacheEnabled) !== null && c !== void 0 && c, localCacheConfig: (V = t.localCacheConfig) !== null && V !== void 0 ? V : new mk() });
      this.debugMode = (s = t.debugMode) !== null && s !== void 0 && s, this.maxSuperGroupChannelUnreadCount = oi.DEFAULT_MAX_UNREAD_COUNT_OF_SUPER_GROUP_CHANNEL, this.useMemberInfoInMessage = N.useMemberInfoInMessage, this.typingIndicatorInvalidateTime = N.typingIndicatorInvalidateTime, this.typingIndicatorThrottle = N.typingIndicatorThrottle, this.concurrentCallLimit = void 0, this.backOffDelay = void 0;
      var W = this.dispatcher = new Ux(), F = new ox();
      this.requestQueue = new HG(n, { session: F, sdkState: R, dispatcher: W, logger: h, useFetchCompat: t.useFetchCompat }), this.sessionManager = new fG({ _iid: n, session: F, cacheContext: Z, sdkState: R, dispatcher: W, requestQueue: this.requestQueue, logger: h }), this.connectionManager = new yG(n, { sdkState: R, cacheContext: this.cacheContext, connectionHandlers: this.connectionHandlers, dispatcher: W, sessionManager: this.sessionManager, websocketClient: this.requestQueue.commandRouter.websocketClient, disableWebSocketCloseEventHandling: (o = t.disableWebSocketCloseEventHandling) !== null && o !== void 0 && o, logger: h }), this.statLogCollector = new gG({ cacheContext: this.cacheContext, requestQueue: this.requestQueue, dispatcher: W }), this.appStateToggleEnabled = (U = t.appStateToggleEnabled) === null || U === void 0 || U;
    }
    return yi[n];
  }
  return e.of = function(n) {
    if (yi[n])
      return yi[n];
    throw j.lostInstance;
  }, e.clear = function(n) {
    yi[n] && delete yi[n];
  }, e.prototype.hasExtension = function(n) {
    return this.sdkState.extensions && this.sdkState.extensions[n];
  }, e;
}(), CR = function() {
  function e() {
  }
  return e.prototype.init = function(n, t) {
    var l = t.sdkState, a = t.dispatcher, d = t.sessionManager, r = t.requestQueue, i = t.logger;
    t.onlineDetector;
    var c = t.cacheContext;
    this._iid = n, this._cacheContext = c, this._sdkState = l, this._dispatcher = a, this._sessionManager = d, this._requestQueue = r, this._logger = i;
  }, e;
}();
(function(e) {
  e.UNKNOWN = "UNKNOWN", e.EVENT_CHANNEL_CREATED = "EVENT_CHANNEL_CREATED", e.EVENT_CHANNEL_UPDATED = "EVENT_CHANNEL_UPDATED", e.EVENT_CHANNEL_DELETED = "EVENT_CHANNEL_DELETED", e.EVENT_CHANNEL_READ = "EVENT_CHANNEL_READ", e.EVENT_CHANNEL_DELIVERED = "EVENT_CHANNEL_DELIVERED", e.EVENT_CHANNEL_INVITED = "EVENT_CHANNEL_INVITED", e.EVENT_CHANNEL_JOINED = "EVENT_CHANNEL_JOINED", e.EVENT_CHANNEL_LEFT = "EVENT_CHANNEL_LEFT", e.EVENT_CHANNEL_ACCEPTED_INVITE = "EVENT_CHANNEL_ACCEPTED_INVITE", e.EVENT_CHANNEL_DECLINED_INVITE = "EVENT_CHANNEL_DECLINED_INVITE", e.EVENT_CHANNEL_OPERATOR_UPDATED = "EVENT_CHANNEL_OPERATOR_UPDATED", e.EVENT_CHANNEL_BANNED = "EVENT_CHANNEL_BANNED", e.EVENT_CHANNEL_UNBANNED = "EVENT_CHANNEL_UNBANNED", e.EVENT_CHANNEL_MUTED = "EVENT_CHANNEL_MUTED", e.EVENT_CHANNEL_UNMUTED = "EVENT_CHANNEL_UNMUTED", e.EVENT_CHANNEL_FROZEN = "EVENT_CHANNEL_FROZEN", e.EVENT_CHANNEL_UNFROZEN = "EVENT_CHANNEL_UNFROZEN", e.EVENT_CHANNEL_HIDDEN = "EVENT_CHANNEL_HIDDEN", e.EVENT_CHANNEL_UNHIDDEN = "EVENT_CHANNEL_UNHIDDEN", e.EVENT_CHANNEL_RESET_HISTORY = "EVENT_CHANNEL_RESET_HISTORY", e.EVENT_CHANNEL_TYPING_STATUS_UPDATE = "EVENT_CHANNEL_TYPING_STATUS_UPDATE", e.EVENT_CHANNEL_MEMBER_COUNT_UPDATED = "EVENT_CHANNEL_MEMBER_COUNT_UPDATED", e.EVENT_CHANNEL_METADATA_CREATED = "EVENT_CHANNEL_METADATA_CREATED", e.EVENT_CHANNEL_METADATA_UPDATED = "EVENT_CHANNEL_METADATA_UPDATED", e.EVENT_CHANNEL_METADATA_DELETED = "EVENT_CHANNEL_METADATA_DELETED", e.EVENT_CHANNEL_METACOUNTER_CREATED = "EVENT_CHANNEL_METACOUNTER_CREATED", e.EVENT_CHANNEL_METACOUNTER_UPDATED = "EVENT_CHANNEL_METACOUNTER_UPDATED", e.EVENT_CHANNEL_METACOUNTER_DELETED = "EVENT_CHANNEL_METACOUNTER_DELETED", e.EVENT_THREAD_INFO_UPDATED = "EVENT_THREAD_INFO_UPDATED", e.EVENT_MESSAGE_SENT = "EVENT_MESSAGE_SENT", e.EVENT_MESSAGE_RECEIVED = "EVENT_MESSAGE_RECEIVED", e.EVENT_MESSAGE_UPDATED = "EVENT_MESSAGE_UPDATED", e.EVENT_PINNED_MESSAGE_UPDATED = "EVENT_PINNED_MESSAGE_UPDATED", e.REQUEST_CHANNEL = "REQUEST_CHANNEL", e.REQUEST_CHANNEL_CHANGELOGS = "REQUEST_CHANNEL_CHANGELOGS", e.REFRESH_CHANNEL = "REFRESH_CHANNEL", e.CHANNEL_LASTACCESSEDAT_UPDATED = "CHANNEL_LASTACCESSEDAT_UPDATED", e.SYNC_CHANNEL_BACKGROUND = "SYNC_CHANNEL_BACKGROUND", e.SYNC_CHANNEL_CHANGELOGS = "SYNC_CHANNEL_CHANGELOGS", e.EVENT_MESSAGE_SENT_SUCCESS = "EVENT_MESSAGE_SENT_SUCCESS", e.EVENT_MESSAGE_SENT_FAILED = "EVENT_MESSAGE_SENT_FAILED", e.EVENT_MESSAGE_SENT_PENDING = "EVENT_MESSAGE_SENT_PENDING", e.EVENT_MESSAGE_DELETED = "EVENT_MESSAGE_DELETED", e.EVENT_MESSAGE_FEEDBACK_ADDED = "EVENT_MESSAGE_FEEDBACK_ADDED", e.EVENT_MESSAGE_FEEDBACK_UPDATED = "EVENT_MESSAGE_FEEDBACK_UPDATED", e.EVENT_MESSAGE_FEEDBACK_DELETED = "EVENT_MESSAGE_FEEDBACK_DELETED", e.EVENT_MESSAGE_READ = "EVENT_MESSAGE_READ", e.EVENT_MESSAGE_DELIVERED = "EVENT_MESSAGE_DELIVERED", e.EVENT_MESSAGE_REACTION_UPDATED = "EVENT_MESSAGE_REACTION_UPDATED", e.EVENT_MESSAGE_THREADINFO_UPDATED = "EVENT_MESSAGE_THREADINFO_UPDATED", e.EVENT_MESSAGE_OFFSET_UPDATED = "EVENT_MESSAGE_OFFSET_UPDATED", e.REQUEST_MESSAGE = "REQUEST_MESSAGE", e.EVENT_POLL_UPDATED = "EVENT_POLL_UPDATED", e.EVENT_POLL_VOTED = "EVENT_POLL_VOTED", e.SYNC_POLL_CHANGELOGS = "SYNC_POLL_CHANGELOGS", e.REQUEST_RESEND_MESSAGE = "REQUEST_RESEND_MESSAGE", e.REQUEST_THREADED_MESSAGE = "REQUEST_THREADED_MESSAGE", e.REQUEST_MESSAGE_CHANGELOGS = "REQUEST_MESSAGE_CHANGELOGS", e.SYNC_MESSAGE_FILL = "SYNC_MESSAGE_FILL", e.SYNC_MESSAGE_BACKGROUND = "SYNC_MESSAGE_BACKGROUND", e.SYNC_MESSAGE_CHANGELOGS = "SYNC_MESSAGE_CHANGELOGS", e.LOCAL_MESSAGE_PENDING_CREATED = "LOCAL_MESSAGE_PENDING_CREATED", e.LOCAL_MESSAGE_FAILED = "LOCAL_MESSAGE_FAILED", e.LOCAL_MESSAGE_CANCELED = "LOCAL_MESSAGE_CANCELED", e.LOCAL_MESSAGE_RESEND_STARTED = "LOCAL_MESSAGE_RESEND_STARTED";
})(ne || (ne = {}));
var bc;
x({}, ne);
var Nr = function(e) {
  return e.startsWith("EVENT_") || e.startsWith("LOCAL_MESSAGE_") || e === ne.SYNC_MESSAGE_FILL || e === ne.SYNC_MESSAGE_CHANGELOGS || e === ne.SYNC_POLL_CHANGELOGS;
}, En = function(e) {
  function n(t) {
    var l = t.messages, a = t.source, d = t.isWebSocketEventComing, r = d !== void 0 && d, i = e.call(this) || this;
    return i.messages = l, i.source = a, i.isWebSocketEventComing = r, i;
  }
  return J(n, e), n;
}(un), EW = function(e) {
  function n(t) {
    var l = t.messageIds, a = t.source, d = t.isWebSocketEventComing, r = d !== void 0 && d, i = e.call(this) || this;
    return i.messageIds = l, i.source = a, i.isWebSocketEventComing = r, i;
  }
  return J(n, e), n;
}(un), t3 = function(e) {
  function n(t) {
    var l = t.event, a = t.source, d = t.isWebSocketEventComing, r = d !== void 0 && d, i = e.call(this) || this;
    return i.event = l, i.source = a, i.isWebSocketEventComing = r, i;
  }
  return J(n, e), n;
}(un), n3 = function(e) {
  function n(t) {
    var l = t.event, a = t.source, d = t.isWebSocketEventComing, r = d !== void 0 && d, i = e.call(this) || this;
    return i.event = l, i.source = a, i.isWebSocketEventComing = r, i;
  }
  return J(n, e), n;
}(un), l3 = function(e) {
  function n(t) {
    var l = t.reqId, a = t.source, d = e.call(this) || this;
    return d.reqId = l, d.source = a, d;
  }
  return J(n, e), n;
}(un), a3 = function(e) {
  function n(t) {
    var l = t.polls, a = t.source, d = e.call(this) || this;
    return d.polls = l, d.source = a, d;
  }
  return J(n, e), n;
}(un), SW = function(e) {
  function n(t) {
    var l = t.event, a = t.source, d = e.call(this) || this;
    return d.event = l, d.source = a, d;
  }
  return J(n, e), n;
}(un), KR = function(e) {
  function n(t) {
    var l = t.event, a = t.source, d = e.call(this) || this;
    return d.event = l, d.source = a, d;
  }
  return J(n, e), n;
}(un);
(function(e) {
  e.OPEN = "open", e.CLOSED = "closed";
})(bc || (bc = {}));
var d3 = "removed", jT = function(e) {
  switch (e) {
    case "open":
      return bc.OPEN;
    case "closed":
      return bc.CLOSED;
    default:
      return null;
  }
}, r3 = function(e) {
  return !e || !!e.text && B("string", e.text);
}, MN = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o = this;
    return (o = e.call(this, t) || this).pollId = 0, o.id = 0, o.text = null, o.voteCount = 0, o.createdBy = null, o.createdAt = 0, o.updatedAt = 0, o._lastVotedAt = 0, o.pollId = (a = l.poll_id) !== null && a !== void 0 ? a : 0, o.id = (d = l.id) !== null && d !== void 0 ? d : 0, o.text = (r = l.text) !== null && r !== void 0 ? r : null, o.voteCount = (i = l.vote_count) !== null && i !== void 0 ? i : 0, o.createdBy = (c = l.created_by) !== null && c !== void 0 ? c : null, o.createdAt = (V = l.created_at) !== null && V !== void 0 ? V : 0, o.updatedAt = (s = l.updated_at) !== null && s !== void 0 ? s : 0, o;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { vote_count: t.voteCount, poll_id: t.pollId, text: t.text, created_at: t.createdAt, id: t.id, created_by: t.createdBy, updated_at: t.updatedAt })));
  }, n;
}(ml), ld = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o, U, N, R, h, Z, W = this;
    return (W = e.call(this, t) || this).id = 0, W.title = null, W.createdAt = 0, W.updatedAt = 0, W.closeAt = -1, W.status = bc.CLOSED, W.messageId = 0, W.data = null, W.voterCount = -1, W.options = [], W.createdBy = null, W.allowUserSuggestion = !1, W.allowMultipleVotes = !1, W.votedPollOptionIds = [], W.id = (a = l.id) !== null && a !== void 0 ? a : 0, W.title = (d = l.title) !== null && d !== void 0 ? d : null, W.createdAt = (r = l.created_at) !== null && r !== void 0 ? r : 0, W.updatedAt = (i = l.updated_at) !== null && i !== void 0 ? i : 0, W.closeAt = (c = l.close_at) !== null && c !== void 0 ? c : -1, W.status = (V = jT(l.status)) !== null && V !== void 0 ? V : bc.CLOSED, W.messageId = (s = l.message_id) !== null && s !== void 0 ? s : 0, W.data = (o = l.data) !== null && o !== void 0 ? o : null, W.voterCount = (U = l.voter_count) !== null && U !== void 0 ? U : -1, W.options = l.options ? l.options.map(function(F) {
      return new MN(W._iid, F);
    }) : [], W.createdBy = (N = l.created_by) !== null && N !== void 0 ? N : null, W.allowUserSuggestion = (R = l.allow_user_suggestion) !== null && R !== void 0 && R, W.allowMultipleVotes = (h = l.allow_multiple_votes) !== null && h !== void 0 && h, W.votedPollOptionIds = (Z = l.voted_option_ids) !== null && Z !== void 0 ? Z : [], W;
  }
  return J(n, e), n.prototype._applyPollUpdatePayload = function(t) {
    var l, a, d, r, i, c, V, s, o = this;
    this.title = (l = t.title) !== null && l !== void 0 ? l : this.title, this.updatedAt = (a = t.updated_at) !== null && a !== void 0 ? a : this.updatedAt, this.closeAt = (d = t.close_at) !== null && d !== void 0 ? d : this.closeAt, this.status = (r = jT(t.status)) !== null && r !== void 0 ? r : this.status, this.data = (i = t.data) !== null && i !== void 0 ? i : this.data, this.voterCount = (c = t.voter_count) !== null && c !== void 0 ? c : this.voterCount, t.options && (this.options = t.options.map(function(U) {
      return new MN(o._iid, U);
    }), this.votedPollOptionIds = t.options.filter(function(U) {
      return U.vote_count > 0;
    }).map(function(U) {
      return U.id;
    })), this.allowUserSuggestion = (V = t.allow_user_suggestion) !== null && V !== void 0 ? V : this.allowUserSuggestion, this.allowMultipleVotes = (s = t.allow_multiple_votes) !== null && s !== void 0 ? s : this.allowMultipleVotes;
  }, n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { id: t.id, title: t.title, created_at: t.createdAt, updated_at: t.updatedAt, close_at: t.closeAt, status: t.status, message_id: t.messageId, data: t.data, voter_count: t.voterCount, options: t.options.map(function(l) {
      return MN.payloadify(l);
    }), created_by: t.createdBy, allow_user_suggestion: t.allowUserSuggestion, allow_multiple_votes: t.allowMultipleVotes, voted_option_ids: t.votedPollOptionIds })));
  }, n.prototype.applyPollUpdateEvent = function(t) {
    var l = t._payload.poll;
    return !(!l || this.id !== l.id || l.updated_at < this.updatedAt) && (this._applyPollUpdatePayload(l), !0);
  }, n.prototype.applyPollVoteEvent = function(t) {
    if (this.id !== t.pollId)
      return !1;
    var l = this.options, a = l.map(function(i) {
      return i.id;
    }), d = t._payload, r = Math.floor(d.ts / 1e3);
    return d.updated_vote_counts.forEach(function(i) {
      var c = a.indexOf(i.option_id);
      if (c > -1) {
        var V = l[c];
        r >= V._lastVotedAt && (V.voteCount = i.vote_count, V._lastVotedAt = r);
      }
    }), d.req_id && d.voted_option_ids && (this.votedPollOptionIds = d.voted_option_ids), typeof d.voter_count == "number" && (this.voterCount = d.voter_count), !0;
  }, n.prototype.serialize = function() {
    return gc(this);
  }, n;
}(ml), yr = function() {
  function e(n, t) {
    var l;
    this.limit = 20, this._isLoading = !1, this._hasNext = !0, this._token = "", this._iid = n, this.limit = (l = t.limit) !== null && l !== void 0 ? l : 20;
  }
  return Object.defineProperty(e.prototype, "hasNext", { get: function() {
    return this._hasNext;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "isLoading", { get: function() {
    return this._isLoading;
  }, enumerable: !1, configurable: !0 }), e.prototype._validate = function() {
    return B("number", this.limit) && this.limit > 0;
  }, e;
}(), ar = function(e) {
  function n(t, l, a, d) {
    var r = e.call(this, t, d) || this;
    return r.channelUrl = l, r.channelType = a, r;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && B("string", this.channelUrl) && Qt(Xt, this.channelType);
  }, n;
}(yr), LG = function(e) {
  this.pollId = 0, this.messageId = 0, this.pollId = e.poll_id, this.messageId = e.message_id, this._payload = e;
}, CG = function(e) {
  function n(t) {
    var l = t.title, a = t.optionTexts, d = t.data, r = t.allowUserSuggestion, i = t.allowMultipleVotes, c = t.closeAt, V = e.call(this) || this;
    return V.method = he.POST, V.path = kd, V.params = { title: l, options: a, data: d, allow_user_suggestion: r, allow_multiple_votes: i, close_at: c }, V;
  }
  return J(n, e), n;
}(Te), KG = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.poll = new ld(t, l), a;
  }
  return J(n, e), n;
}(ue), _G = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.channelType, d = t.pollId, r = e.call(this) || this;
    return r.method = he.GET, r.path = "".concat(kd, "/").concat(encodeURIComponent(d)), r.params = { channel_url: l, channel_type: a }, r;
  }
  return J(n, e), n;
}(Te), PG = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.poll = new ld(t, l), a;
  }
  return J(n, e), n;
}(ue), AG = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.channelType, d = t.pollId, r = t.pollOptionId, i = e.call(this) || this;
    return i.method = he.GET, i.path = "".concat(kd, "/").concat(encodeURIComponent(d), "/options/").concat(encodeURIComponent(r)), i.params = { channel_url: l, channel_type: a }, i;
  }
  return J(n, e), n;
}(Te), qG = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.pollOption = new MN(t, l), a;
  }
  return J(n, e), n;
}(ue), $G = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.timestamp, r = t.token, i = e.call(this) || this;
    return i.method = he.GET, i.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/polls/changelogs"), i.params = je({ change_ts: d, token: r }), i;
  }
  return J(n, e), n;
}(Te), ey = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.updatedPolls = l.updated.map(function(d) {
      return function(r, i) {
        return new ld(r, i);
      }(t, d);
    }), a.deletedPollIds = l.deleted.map(function(d) {
      return d;
    }), a.hasMore = l.has_more, a.nextToken = l.next, a;
  }
  return J(n, e), n;
}(ue), ty = { title: "", optionTexts: [], data: void 0, allowUserSuggestion: void 0, allowMultipleVotes: void 0, closeAt: -1 }, i3 = function(e) {
  return B("string", e.title) && (n = e.optionTexts, Jt("string", n) && n.every(function(t) {
    return t.trim() !== "";
  })) && r3(e.data) && B("boolean", e.allowUserSuggestion, !0) && B("boolean", e.allowMultipleVotes, !0) && B("number", e.closeAt, !0);
  var n;
}, ny = { channelUrl: "", channelType: Xt.BASE, pollId: 0, pollOptionId: 0 }, V3 = function(e) {
  return B("string", e.channelUrl) && e.channelUrl !== "" && Qt(Xt, e.channelType) && B("number", e.pollId) && e.pollId > 0 && B("number", e.pollOptionId) && e.pollOptionId > 0;
}, ly = { channelUrl: "", channelType: Xt.BASE, pollId: 0 }, c3 = function(e) {
  return B("string", e.channelUrl) && e.channelUrl !== "" && Qt(Xt, e.channelType) && B("number", e.pollId);
}, du = {}, tR = function() {
  function e(n, t) {
    var l = t.sdkState, a = t.dispatcher, d = t.sessionManager, r = t.requestQueue, i = t.logger;
    this._iid = n, this._sdkState = l, this._sessionManager = d, this._requestQueue = r, this._dispatcher = a, this._logger = i, du[n] = this;
  }
  return e.of = function(n) {
    return du[n];
  }, e.prototype.buildPollFromSerializedData = function(n) {
    var t = hi(n);
    return new ld(this._iid, ld.payloadify(t));
  }, e.prototype.get = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return Ze(c3(n)).throw(j.invalidParameters), t = new _G(x({}, n)), [4, this._requestQueue.send(t)];
          case 1:
            return l = a.sent(), [2, l.as(PG).poll];
        }
      });
    });
  }, e.prototype.create = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return Ze(i3(n)).throw(j.invalidParameters), t = new CG(x({}, n)), [4, this._requestQueue.send(t)];
          case 1:
            return l = a.sent(), [2, l.as(KG).poll];
        }
      });
    });
  }, e.prototype.getOption = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return Ze(V3(n)).throw(j.invalidParameters), t = new AG(x({}, n)), [4, this._requestQueue.send(t)];
          case 1:
            return l = a.sent(), [2, l.as(qG).pollOption];
        }
      });
    });
  }, e.prototype.getPollChangeLogs = function(n, t, l, a) {
    return a === void 0 && (a = ne.SYNC_POLL_CHANGELOGS), M(this, void 0, void 0, function() {
      var d, r, i, c, V, s, o;
      return p(this, function(U) {
        switch (U.label) {
          case 0:
            return d = new $G(Ae({ channelType: t, channelUrl: n, timestamp: typeof l == "number" ? l : null, token: typeof l == "string" ? l : null })), [4, this._requestQueue.send(d)];
          case 1:
            return r = U.sent(), i = r.as(ey), c = i.updatedPolls, V = i.deletedPollIds, s = i.hasMore, o = i.nextToken, c.length > 0 && this._dispatcher.dispatch(new a3({ polls: c, source: a })), [2, { updatedPolls: c, deletedPollIds: V, hasMore: s, token: o }];
        }
      });
    });
  }, e;
}(), ay = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.channelType, d = t.token, r = t.limit, i = e.call(this) || this;
    return i.method = he.GET, i.path = kd, i.params = { channel_url: l, channel_type: a, token: d, limit: r }, i;
  }
  return J(n, e), n;
}(Te), dy = function(e) {
  function n(t, l) {
    var a, d = this;
    return (d = e.call(this, t, l) || this).polls = ((a = l.polls) !== null && a !== void 0 ? a : []).map(function(r) {
      return new ld(t, r);
    }), d.token = l.next, d;
  }
  return J(n, e), n;
}(ue), s3 = function(e) {
  function n(t, l) {
    return e.call(this, t, l.channelUrl, l.channelType, l) || this;
  }
  return J(n, e), n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new ay(x(x({}, this), { token: this._token })), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = c.sent(), d = a.as(dy), r = d.polls, i = d.token, this._token = i, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar), ry = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.channelType, d = t.pollId, r = t.pollOptionId, i = t.token, c = t.limit, V = e.call(this) || this;
    return V.method = he.GET, V.path = "".concat(kd, "/").concat(encodeURIComponent(d), "/options/").concat(encodeURIComponent(r), "/voters"), V.params = { channel_url: l, channel_type: a, token: i, limit: c }, V;
  }
  return J(n, e), n;
}(Te), iy = function(e) {
  function n(t, l) {
    var a, d = this;
    return (d = e.call(this, t, l) || this).voters = ((a = l.voters) !== null && a !== void 0 ? a : []).map(function(r) {
      return new xt(t, r);
    }), d.token = l.next, d;
  }
  return J(n, e), n;
}(ue), o3 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l.channelUrl, l.channelType, l) || this;
    return a.pollId = l.pollId, a.pollOptionId = l.pollOptionId, a;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && B("number", this.pollId) && B("number", this.pollOptionId);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new ry(x(x({}, this), { pollId: this.pollId, pollOptionId: this.pollOptionId, token: this._token })), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = c.sent(), d = a.as(iy), r = d.voters, i = d.token, this._token = i, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar), mo, Br = function() {
  function e(n, t, l) {
    var a, d;
    this.width = 0, this.height = 0, this.realWidth = 0, this.realHeight = 0, this._requireAuth = !1, this._iid = n, this.plainUrl = t.url, this.width = t.width, this.height = t.height, this.realWidth = (a = t.real_width) !== null && a !== void 0 ? a : t.width, this.realHeight = (d = t.real_height) !== null && d !== void 0 ? d : t.height, this._requireAuth = l;
  }
  return e.payloadify = function(n) {
    return je(Ae(n instanceof e ? { url: n.plainUrl, width: n.width, height: n.height, real_width: n.realWidth, real_height: n.realHeight } : { url: "", width: n.maxWidth, height: n.maxHeight, real_width: 0, real_height: 0 }));
  }, Object.defineProperty(e.prototype, "url", { get: function() {
    var n = D.of(this._iid).sessionManager;
    return this._requireAuth && n.ekey ? "".concat(this.plainUrl, "?auth=").concat(n.ekey) : this.plainUrl;
  }, enumerable: !1, configurable: !0 }), e;
}(), nR = function(e) {
  function n(t) {
    var l = e.call(this) || this;
    if (l.method = he.POST, l.path = "".concat(Nx), l.params = je({ file: t.file, channel_url: t.channelUrl }), t.thumbnailSizes)
      for (var a = 0; a < t.thumbnailSizes.length; a++) {
        var d = t.thumbnailSizes[a], r = d.maxWidth, i = d.maxHeight;
        l.params["thumbnail".concat(a + 1)] = "".concat(r, ",").concat(i);
      }
    return l.requestId = t.requestId, l;
  }
  return J(n, e), n;
}(Te), lR = function(e) {
  function n(t, l) {
    var a, d, r, i, c = this;
    return (c = e.call(this, t, l) || this).url = l.url, c.fileSize = (a = l.file_size) !== null && a !== void 0 ? a : 0, c.thumbnails = (r = (d = l.thumbnails) === null || d === void 0 ? void 0 : d.map(function(V) {
      return new Br(t, V, !1);
    })) !== null && r !== void 0 ? r : [], c.requireAuth = (i = l.require_auth) !== null && i !== void 0 && i, c;
  }
  return J(n, e), n;
}(ue), aR = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V = this;
    return (V = e.call(this, t) || this).replyCount = 0, V.memberCount = 0, V.lastRepliedAt = 0, V.updatedAt = 0, V.replyCount = (a = l.reply_count) !== null && a !== void 0 ? a : 0, V.memberCount = (d = l.member_count) !== null && d !== void 0 ? d : 0, V.mostRepliedUsers = l.most_replies && Jt("object", l.most_replies) ? l.most_replies.map(function(s) {
      return new xt(V._iid, s);
    }) : [], V.unreadReplyCount = (r = l.unread_message_count) !== null && r !== void 0 ? r : 0, V.isPushNotificationEnabled = typeof l.push_enabled == "number" ? l.push_enabled > 0 : void 0, V.lastRepliedAt = (i = l.last_replied_at) !== null && i !== void 0 ? i : 0, V.updatedAt = (c = l.updated_at) !== null && c !== void 0 ? c : 0, V;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { reply_count: t.replyCount, unread_message_count: t.unreadReplyCount, member_count: t.memberCount, most_replies: Array.isArray(t.mostRepliedUsers) ? t.mostRepliedUsers.map(function(l) {
      return xt.payloadify(l);
    }) : [], push_enabled: typeof t.isPushNotificationEnabled == "boolean" ? t.isPushNotificationEnabled ? 1 : 0 : void 0, last_replied_at: t.lastRepliedAt, updated_at: t.updatedAt })));
  }, Object.defineProperty(n.prototype, "_isUpdateRequired", { get: function() {
    return this.unreadReplyCount === void 0 || this.isPushNotificationEnabled === void 0;
  }, enumerable: !1, configurable: !0 }), n.prototype._updateFrom = function(t) {
    var l, a;
    this.unreadReplyCount = (l = t.unreadReplyCount) !== null && l !== void 0 ? l : this.unreadReplyCount, this.isPushNotificationEnabled = (a = t.isPushNotificationEnabled) !== null && a !== void 0 ? a : this.isPushNotificationEnabled;
  }, n;
}(ml);
(function(e) {
  e.ADD = "add", e.DELETE = "delete";
})(mo || (mo = {}));
var _r, kW = function(e) {
  this.messageId = 0, this.operation = null, this.updatedAt = 0;
  var n = B("string", e.msg_id) ? parseInt(e.msg_id) : e.msg_id, t = e.user_id, l = e.operation ? e.operation.toLowerCase() : null, a = e.reaction, d = e.updated_at;
  n && B("string", t) && B("string", l) && Qt(mo, l) && B("string", a) && a && B("number", d) && (this.messageId = n, this.userId = t, this.key = a, this.operation = l, this.updatedAt = d);
}, fU = function() {
  function e(n) {
    var t, l, a, d = n.key, r = (a = ot([], et(n.user_ids), !1)) !== null && a !== void 0 ? a : [], i = n.updated_at;
    B("string", d) && d && Jt("string", r) && r.length > 0 && B("number", i) && (this.key = d, this.userIds = r, this.updatedAt = i);
    var c = {};
    try {
      for (var V = be(this.userIds), s = V.next(); !s.done; s = V.next())
        c[s.value] = this.updatedAt;
    } catch (o) {
      t = { error: o };
    } finally {
      try {
        s && !s.done && (l = V.return) && l.call(V);
      } finally {
        if (t)
          throw t.error;
      }
    }
    this._version = c;
  }
  return Object.defineProperty(e.prototype, "isEmpty", { get: function() {
    return this.userIds.length === 0;
  }, enumerable: !1, configurable: !0 }), e.payloadify = function(n) {
    return je(Ae({ key: n.key, user_ids: n.userIds, updated_at: n.updatedAt }));
  }, e.prototype.applyEvent = function(n) {
    if (n.key === this.key && this.updatedAt <= n.updatedAt) {
      if (!this._version[n.userId] || this._version[n.userId] <= n.updatedAt) {
        var t = this.userIds.indexOf(n.userId);
        switch (n.operation) {
          case mo.ADD:
            t < 0 && this.userIds.push(n.userId);
            break;
          case mo.DELETE:
            t >= 0 && this.userIds.splice(t, 1);
        }
        this._version[n.userId] = n.updatedAt;
      }
      this.updatedAt = Math.max(this.updatedAt, n.updatedAt);
    }
  }, e;
}(), ru = function() {
  function e(n) {
    this.secureUrl = null, this.type = null, this.width = 0, this.height = 0, this.alt = null, this.url = n.url, n.secure_url && (this.secureUrl = n.secure_url), n.type && (this.type = n.type), n.width && (this.width = n.width), n.height && (this.height = n.height), n.alt && (this.alt = n.alt);
  }
  return e.payloadify = function(n) {
    var t, l;
    return je(Ae({ url: n.url, secure_url: n.secureUrl, type: n.type, width: (t = n.width) !== null && t !== void 0 ? t : 0, height: (l = n.height) !== null && l !== void 0 ? l : 0, alt: n.alt }));
  }, e;
}(), iu = function() {
  function e(n) {
    this.title = null, this.url = null, this.description = null, this.defaultImage = null, n["og:title"] && (this.title = n["og:title"]), n["og:url"] && (this.url = n["og:url"]), n["og:description"] && (this.description = n["og:description"]), n["og:image"] && (this.defaultImage = new ru(n["og:image"]));
  }
  return e.payloadify = function(n) {
    return je(Ae({ "og:title": n.title, "og:url": n.url, "og:description": n.description, "og:image": n.defaultImage ? ru.payloadify(n.defaultImage) : null }));
  }, e;
}(), ad = function() {
  function e(n) {
    var t, l;
    this.volume = 0, this.name = (t = n.name) !== null && t !== void 0 ? t : "default", this.volume = (l = n.volume) !== null && l !== void 0 ? l : 1;
  }
  return e.prototype.serialize = function() {
    return { name: this.name, volume: this.volume };
  }, e.payloadify = function(n) {
    return je(Ae({ name: n.name, volume: n.volume }));
  }, e;
}();
(function(e) {
  e.GOOD = "good", e.BAD = "bad";
})(_r || (_r = {}));
var Vu, TV = function() {
  function e(n) {
    this.id = n.id, this.rating = n.rating, this.comment = n.comment;
  }
  return e.parseFeedbackStatusFromPayload = function(n) {
    return n && n.id !== null && n.rating !== null ? "SUBMITTED" : "NOT_APPLICABLE";
  }, e.payloadify = function(n) {
    return je(Ae({ id: n.id, rating: n.rating, comment: n.comment }));
  }, e;
}(), Yc = function(e) {
  function n(t, l) {
    var a, d = this;
    return (d = e.call(this, t, l) || this).isBlockedByMe = !1, d.role = Qt(ed, l.role) ? l.role : ed.NONE, d.isBlockedByMe = (a = l.is_blocked_by_me) !== null && a !== void 0 && a, d;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { role: t.role, is_blocked_by_me: t.isBlockedByMe })));
  }, n;
}(xt), Ol = function() {
  function e(n) {
    this.key = n.key, this.value = Jt("string", n.value) ? ot([], et(n.value), !1) : [];
  }
  return e.payloadify = function(n) {
    var t;
    return je(Ae({ key: n.key, value: (t = n.value) !== null && t !== void 0 ? t : [] }));
  }, e;
}(), U3 = function(e) {
  switch (e) {
    case Gn.BASE:
      return "";
    case Gn.USER:
      return "MESG";
    case Gn.FILE:
      return "FILE";
    case Gn.ADMIN:
      return "ADMM";
  }
}, N3 = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o, U, N, R = this;
    (R = e.call(this, t) || this).channelType = Xt.BASE, R.messageType = Gn.BASE, R.mentionType = null, R.mentionedUsers = null, R.mentionedUserIds = null, R.metaArrays = [], R.extendedMessage = {}, R.createdAt = 0, R.updatedAt = 0, R.channelUrl = l.channel_url, R.channelType = Qt(Xt, l.channel_type) ? l.channel_type : Xt.GROUP, l.channel && (l.channel.channel_url && (R.channelUrl = l.channel.channel_url), l.channel.channel_type && (R.channelType = l.channel.channel_type)), R.data = (a = l.data) !== null && a !== void 0 ? a : "", R.customType = (d = l.custom_type) !== null && d !== void 0 ? d : "", R.mentionType = Qt(Jl, l.mention_type) ? l.mention_type : null, R.mentionedUsers = l.mentioned_users ? l.mentioned_users.map(function(m) {
      return new xt(R._iid, m);
    }) : null, R.mentionedUserIds = (r = l.mentioned_user_ids) !== null && r !== void 0 ? r : null, R.mentionedUsers && !R.mentionedUserIds && (R.mentionedUserIds = R.mentionedUsers.map(function(m) {
      return m.userId;
    })), R.mentionedMessageTemplate = (i = l.mentioned_message_template) !== null && i !== void 0 ? i : "";
    var h = (c = l.metaarray) !== null && c !== void 0 ? c : {}, Z = (V = l.metaarray_key_order) !== null && V !== void 0 ? V : Object.keys(h).sort(function(m, E) {
      return m.localeCompare(E);
    });
    R.metaArrays = [];
    for (var W = 0; W < Z.length; W++) {
      var F = Z[W];
      R.metaArrays.push(new Ol({ key: F, value: h[F] || [] }));
    }
    return l.sorted_metaarray && (R.metaArrays = l.sorted_metaarray.map(function(m) {
      return new Ol(m);
    })), R.extendedMessage = (s = l.extended_message) !== null && s !== void 0 ? s : {}, R.extendedMessagePayload = l.extended_message_payload, R.createdAt = (U = (o = l.created_at) !== null && o !== void 0 ? o : l.ts) !== null && U !== void 0 ? U : 0, R.updatedAt = (N = l.updated_at) !== null && N !== void 0 ? N : 0, R;
  }
  return J(n, e), n.payloadify = function(t) {
    var l, a;
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { channel_url: t.channelUrl, channel_type: t.channelType, type: U3(t.messageType), data: t.data, custom_type: t.customType, mention_type: t.mentionType, mentioned_user_ids: t.mentionedUserIds, mentioned_users: (l = t.mentionedUsers) === null || l === void 0 ? void 0 : l.map(function(d) {
      return xt.payloadify(d);
    }), mentioned_message_template: t.mentionedMessageTemplate, sorted_metaarray: (a = t.metaArrays) === null || a === void 0 ? void 0 : a.map(function(d) {
      return Ol.payloadify(d);
    }), extended_message: t.extendedMessage, extended_message_payload: t.extendedMessagePayload, created_at: t.createdAt, updated_at: t.updatedAt })));
  }, n.prototype.isIdentical = function(t) {
    return !0;
  }, n.prototype.isEqual = function(t) {
    return Tk(this, t);
  }, n.prototype.isUserMessage = function() {
    return this.messageType === Gn.USER;
  }, n.prototype.isFileMessage = function() {
    return this.messageType === Gn.FILE && !Object.prototype.hasOwnProperty.call(this, "fileInfoList");
  }, n.prototype.isMultipleFilesMessage = function() {
    return this.messageType === Gn.FILE && Object.prototype.hasOwnProperty.call(this, "fileInfoList");
  }, n.prototype.isAdminMessage = function() {
    return this.messageType === Gn.ADMIN;
  }, n.prototype.hasForm = function() {
    var t, l;
    return !!(!((l = (t = this.extendedMessagePayload) === null || t === void 0 ? void 0 : t.forms) === null || l === void 0) && l[0]);
  }, n.prototype.serialize = function() {
    return gc(this);
  }, n.prototype.getMetaArraysByKeys = function(t) {
    return this.metaArrays.filter(function(l) {
      return t.includes(l.key);
    });
  }, n;
}(ml);
(function(e) {
  e.Text = "text", e.Phone = "phone", e.Email = "email", e.Password = "password";
})(Vu || (Vu = {}));
var wU = function() {
  function e(n, t, l) {
    this.messageId = n, this.key = t, this.fields = l, this.formKey = t;
  }
  return Object.defineProperty(e.prototype, "isSubmitted", { get: function() {
    return this.answers !== void 0 && Object.keys(this.answers).length > 0;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "isSubmittable", { get: function() {
    return this.fields.every(function(n) {
      return n.isSubmittable;
    });
  }, enumerable: !1, configurable: !0 }), e.prototype.getFieldAnswer = function(n) {
    var t;
    return (t = this.answers) === null || t === void 0 ? void 0 : t[n];
  }, e.payloadify = function(n) {
    var t;
    return je(Ae({ key: (t = n.formKey) !== null && t !== void 0 ? t : n.key, fields: n.fields.map(function(l) {
      return R3.payloadify(l);
    }) }));
  }, e.isFormPayload = function(n) {
    var t;
    return !!(!((t = n == null ? void 0 : n.forms) === null || t === void 0) && t[0]);
  }, e;
}(), R3 = function() {
  function e(n) {
    this.key = n.key, this.inputType = n.input_type, this.title = n.title, this.required = n.required, this.regex = n.regex, this.placeholder = n.placeholder, this.fieldKey = n.key;
  }
  return e.prototype.isValid = function(n) {
    if (!this.regex)
      return !0;
    try {
      return new RegExp(this.regex).test(n);
    } catch {
      return !0;
    }
  }, Object.defineProperty(e.prototype, "isSubmittable", { get: function() {
    return !(this.temporaryAnswer != null && !this.isValid(this.temporaryAnswer) || this.required && this.temporaryAnswer == null);
  }, enumerable: !1, configurable: !0 }), e.payloadify = function(n) {
    var t;
    return je(Ae({ key: (t = n.fieldKey) !== null && t !== void 0 ? t : n.key, input_type: n.inputType, title: n.title, required: n.required, regex: n.regex, placeholder: n.placeholder }));
  }, e;
}(), h3 = function(e) {
  function n(t, l) {
    var a, d, r = this;
    return (r = e.call(this, t) || this).channelUrl = (a = l.channel_url) !== null && a !== void 0 ? a : "", r.channelType = (d = l.channel_type) !== null && d !== void 0 ? d : Xt.GROUP, r.reader = new xt(r._iid, l.user), r.readAt = l.ts, r;
  }
  return J(n, e), n;
}(ml), Vy = function(e) {
  function n(t) {
    var l = t.channelUrl;
    return e.call(this, { code: "READ", ackRequired: !0, payload: { channel_url: l } }) || this;
  }
  return J(n, e), n;
}(Yl);
(function(e) {
  function n(t) {
    var l = e.call(this) || this, a = t.channelUrl, d = t.channelType, r = t.userId, i = t.notificationIds;
    return l.method = he.PUT, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/messages/mark_as_read"), l.params = je(Ae({ user_id: r, message_ids: i })), l;
  }
  return J(n, e), n;
})(Te);
var Z3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "READ", a) || this;
    return d.readStatus = new h3(t, a), d;
  }
  return J(n, e), n;
}(Wn);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.readAt = l.ts, a.unreadMessageCount = l.unread_message_count, a;
  }
  return J(n, e), n;
})(ue);
var cy = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.messageId;
    return e.call(this, { code: "READ", ackRequired: !0, payload: { channel_url: l, parent_message_id: a } }) || this;
  }
  return J(n, e), n;
}(Yl), sy = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = t.pushEnabled, i = e.call(this) || this;
    return i.method = he.PUT, i.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(d, "/thread_push"), i.params = { push_enabled: r }, i;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    return e.call(this, t, l) || this;
  }
  J(n, e);
})(ue);
var cu = function(e) {
  function n(t) {
    var l = e.call(this) || this;
    return l.method = he.POST, l.path = "".concat(vl, "/").concat(encodeURIComponent(t.channelUrl), "/messages/").concat(t.messageId, "/submit_forms"), l.params = je({ forms: t.forms }), l;
  }
  return J(n, e), n;
}(Te), oy = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = t.rating, i = t.comment, c = e.call(this) || this;
    return c.method = he.POST, c.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(d, "/feedbacks"), c.params = { rating: r, comment: i }, c;
  }
  return J(n, e), n;
}(Te), Uy = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.feedback = new TV(l), a;
  }
  return J(n, e), n;
}(ue), Ny = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = t.feedbackId, i = t.rating, c = t.comment, V = e.call(this) || this;
    return V.method = he.PUT, V.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(d, "/feedbacks/").concat(r), V.params = { rating: i, comment: c }, V;
  }
  return J(n, e), n;
}(Te), Ry = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.feedback = new TV(l), a;
  }
  return J(n, e), n;
}(ue), hy = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = t.feedbackId, i = e.call(this) || this;
    return i.method = he.DELETE, i.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(d, "/feedbacks/").concat(r), i;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.feedback = new TV(l), a;
  }
  J(n, e);
})(ue);
var ii, xa, HT = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V = this;
    return (V = e.call(this, t) || this).plainUrl = "", V.fileName = null, V.mimeType = null, V.fileSize = 0, V.thumbnails = [], V._requireAuth = !1, V.plainUrl = (a = l.url) !== null && a !== void 0 ? a : "", V.fileName = (d = l.file_name) !== null && d !== void 0 ? d : null, V.mimeType = (r = l.file_type) !== null && r !== void 0 ? r : null, V.fileSize = (i = l.file_size) !== null && i !== void 0 ? i : 0, V._requireAuth = (c = l.require_auth) !== null && c !== void 0 && c, V.thumbnails = l.thumbnails ? l.thumbnails.map(function(s) {
      var o;
      return new Br(V._iid, typeof s == "string" ? { url: s, width: 0, height: 0 } : x(x({}, s), { url: ((o = s.url) !== null && o !== void 0 ? o : "").split("auth=")[0] }), V._requireAuth);
    }) : [], V;
  }
  return J(n, e), n.payloadify = function(t) {
    var l;
    return je(Ae({ url: t.plainUrl, file_name: t.fileName, file_type: t.mimeType, file_size: t.fileSize, thumbnails: (l = t.thumbnails) === null || l === void 0 ? void 0 : l.map(function(a) {
      var d;
      return { url: ((d = a.plainUrl) !== null && d !== void 0 ? d : "").split("auth=")[0], width: a.width, height: a.height, real_width: a.realWidth, real_height: a.realHeight };
    }), require_auth: t._requireAuth }));
  }, Object.defineProperty(n.prototype, "url", { get: function() {
    var t = D.of(this._iid).sessionManager;
    return this._requireAuth && t.ekey ? "".concat(this.plainUrl, "?auth=").concat(t.ekey) : this.plainUrl;
  }, enumerable: !1, configurable: !0 }), n;
}(ml), T3 = function(e) {
  var n = e.channelUrl, t = e.channelType, l = e.parentMessage;
  this.channelUrl = n, this.channelType = t, this.parentMessage = l;
};
(function(e) {
  e.PENDING = "pending", e.SENT = "sent", e.FAILED = "failed", e.CANCELED = "canceled";
})(ii || (ii = {})), function(e) {
  e.PENDING = "pending", e.IN_QUEUE = "in_queue", e.SENT = "sent", e.FAILED = "failed", e.CANCELED = "canceled", e.REMOVED = "removed";
}(xa || (xa = {}));
var lV, Bl = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o, U, N, R = this;
    return (R = e.call(this, t, l) || this).parentMessage = null, R.silent = !1, R.isOperatorMessage = !1, R.threadInfo = null, R.reactions = [], R.appleCriticalAlertOptions = null, R.scheduledInfo = null, R.suggestedReplies = null, R.myFeedback = null, R.myFeedbackStatus = "NOT_APPLICABLE", R.forms = null, R._isContinuousMessages = !1, R._scheduledStatus = null, R.messageId = (d = (a = l.msg_id) !== null && a !== void 0 ? a : l.message_id) !== null && d !== void 0 ? d : 0, R.parentMessageId = (r = typeof l.parent_message_id == "string" ? parseInt(l.parent_message_id) : l.parent_message_id) !== null && r !== void 0 ? r : 0, R.threadInfo = l.thread_info ? new aR(R._iid, l.thread_info) : null, R.reactions = l.reactions ? l.reactions.map(function(h) {
      return new fU(h);
    }) : [], R.ogMetaData = l.og_tag ? new iu(l.og_tag) : null, R.silent = (i = l.silent) !== null && i !== void 0 && i, R.isOperatorMessage = (c = l.is_op_msg) !== null && c !== void 0 && c, R.appleCriticalAlertOptions = l.apple_critical_alert_options ? new ad(l.apple_critical_alert_options) : null, typeof l.scheduled_message_id == "number" && typeof l.scheduled_at == "number" && l.scheduled_status && (R.scheduledInfo = { scheduledMessageId: l.scheduled_message_id, scheduledAt: l.scheduled_at }, R._scheduledStatus = l.scheduled_status), R._isContinuousMessages = (V = l.is_continuous_messages) !== null && V !== void 0 && V, R.myFeedback = !((s = l.feedback) === null || s === void 0) && s.id ? new TV(l.feedback) : null, R.myFeedbackStatus = (o = l.my_feedback_status) !== null && o !== void 0 ? o : TV.parseFeedbackStatusFromPayload(l.feedback), R.suggestedReplies = (N = (U = l.extended_message_payload) === null || U === void 0 ? void 0 : U.suggested_replies) !== null && N !== void 0 ? N : null, R.forms = wU.isFormPayload(l.extended_message_payload) ? l.extended_message_payload.forms.map(function(h) {
      return new wU(R.messageId, h.key, h.fields.map(function(Z) {
        return new R3(Z);
      }));
    }) : null, R;
  }
  return J(n, e), n.payloadify = function(t) {
    var l, a;
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { message_id: t.messageId, parent_message_id: t.parentMessageId, thread_info: t.threadInfo ? aR.payloadify(t.threadInfo) : null, reactions: t.reactions.map(function(d) {
      return fU.payloadify(d);
    }), og_tag: t.ogMetaData ? iu.payloadify(t.ogMetaData) : null, silent: t.silent, is_op_msg: t.isOperatorMessage, apple_critical_alert_options: t.appleCriticalAlertOptions ? ad.payloadify(t.appleCriticalAlertOptions) : null, scheduled_message_id: (l = t.scheduledInfo) === null || l === void 0 ? void 0 : l.scheduledMessageId, scheduled_at: (a = t.scheduledInfo) === null || a === void 0 ? void 0 : a.scheduledAt, scheduled_status: t._scheduledStatus, feedback: t.myFeedback ? TV.payloadify(t.myFeedback) : null, my_feedback_status: t.myFeedbackStatus, forms: t.forms ? t.forms.map(function(d) {
      return wU.payloadify(d);
    }) : null })));
  }, n._getParentMessageInfoPayload = function(t) {
    return je(Ae({ type: U3(t.messageType), ts: t.createdAt, user: t.sender ? Yc.payloadify(t.sender) : null, message: t.message, file: { url: t.plainUrl, name: t.name, type: t.type, require_auth: t.requireAuth }, files: Array.isArray(t.fileInfoList) ? t.fileInfoList.map(function(l) {
      return HT.payloadify(l);
    }) : null }));
  }, n.prototype.isIdentical = function(t) {
    return this.messageId === t.messageId;
  }, n.prototype.applyThreadInfoUpdateEvent = function(t) {
    return this.messageId === t.targetMessageId && (t.threadInfo._isUpdateRequired && this.threadInfo && t.threadInfo._updateFrom(this.threadInfo), this.threadInfo = t.threadInfo, !0);
  }, n.prototype.applyReactionEvent = function(t) {
    if (this.messageId === t.messageId) {
      for (var l = !1, a = 0; a < this.reactions.length; a++)
        if (this.reactions[a].key === t.key) {
          this.reactions[a].applyEvent(t), this.reactions[a].isEmpty && this.reactions.splice(a, 1), l = !0;
          break;
        }
      l || t.operation !== "add" || this.reactions.push(new fU(fU.payloadify({ key: t.key, userIds: [t.userId], updatedAt: t.updatedAt })));
    }
  }, n.prototype.applyParentMessage = function(t) {
    if (!this.parentMessage)
      return this.parentMessage = t, !0;
    if (this.parentMessageId === t.messageId) {
      var l = this.parentMessage.updatedAt;
      if (t.updatedAt >= l)
        return this.parentMessage = t, !0;
    }
    return !1;
  }, n.prototype._triggerThreadInfoUpdatedEvent = function() {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        return (t = D.of(this._iid).dispatcher).dispatch(new T3({ channelType: Xt.GROUP, channelUrl: this.channelUrl, parentMessage: this })), t.dispatch(new En({ messages: [this], source: ne.EVENT_THREAD_INFO_UPDATED })), [2];
      });
    });
  }, n.prototype.markThreadAsRead = function() {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new cy({ channelUrl: this.channelUrl, messageId: this.messageId }), [4, t.send(l)];
          case 1:
            return a.sent(), this.threadInfo && this.threadInfo.unreadReplyCount !== 0 ? (this.threadInfo.unreadReplyCount = 0, [4, this._triggerThreadInfoUpdatedEvent()]) : [3, 3];
          case 2:
            a.sent(), a.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, n.prototype.setPushNotificationEnabled = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return l = D.of(this._iid).requestQueue, a = new sy({ channelUrl: this.channelUrl, channelType: this.channelType, messageId: this.messageId, pushEnabled: t }), [4, l.send(a)];
          case 1:
            return d.sent(), this.threadInfo && this.threadInfo.isPushNotificationEnabled !== t && (this.threadInfo.isPushNotificationEnabled = t), [2];
        }
      });
    });
  }, n.prototype.submitForm = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            if (Ze(t.form && t.form instanceof wU || B("string", t.formId) && B("object", t.answers)).throw(j.invalidParameters), l = D.of(this._iid), a = l.requestQueue, d = l.sdkState, r = l.logger, !t.form)
              return [3, 2];
            if (!(i = t.form).isSubmittable)
              throw new j({ code: nt.INVALID_PARAMETER, message: "The given form is not submittable." });
            if (i.isSubmitted)
              throw new j({ code: nt.INVALID_PARAMETER, message: "The given form is already submitted." });
            if (i.messageId != this.messageId)
              throw new j({ code: nt.INVALID_PARAMETER, message: "This form does not belong to the message." });
            return c = i.fields.reduce(function(o, U) {
              return o[U.key] = U.temporaryAnswer, o;
            }, {}), V = new cu({ userId: d.userId, channelUrl: this.channelUrl, channelType: this.channelType, messageId: this.messageId, forms: [{ form_key: i.key, data: c }] }), [4, a.send(V)];
          case 1:
            return s.sent(), [3, 4];
          case 2:
            return t.formId && t.answers ? (r.warn("The submitForm method with formId and answers is deprecated. Use submitForm({ form: Form }) instead."), V = new cu({ userId: d.userId, channelUrl: this.channelUrl, channelType: this.channelType, messageId: this.messageId, forms: [{ form_key: t.formId, data: t.answers }] }), [4, a.send(V)]) : [3, 4];
          case 3:
            s.sent(), s.label = 4;
          case 4:
            return [2];
        }
      });
    });
  }, n.prototype.submitFeedback = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return l = D.of(this._iid), a = l.requestQueue, d = l.dispatcher, r = new oy({ channelUrl: this.channelUrl, channelType: this.channelType, messageId: this.messageId, rating: t.rating, comment: t.comment }), [4, a.send(r)];
          case 1:
            return i = V.sent(), c = i.as(Uy), this.myFeedback = c.feedback, this.myFeedbackStatus = "SUBMITTED", d.dispatch(new En({ messages: [this], source: ne.EVENT_MESSAGE_FEEDBACK_ADDED })), [2];
        }
      });
    });
  }, n.prototype.updateFeedback = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return l = D.of(this._iid), a = l.requestQueue, d = l.dispatcher, r = new Ny({ channelUrl: this.channelUrl, channelType: this.channelType, messageId: this.messageId, feedbackId: t.id, rating: t.rating, comment: t.comment }), [4, a.send(r)];
          case 1:
            return i = V.sent(), c = i.as(Ry), this.myFeedback = c.feedback, this.myFeedbackStatus = "SUBMITTED", d.dispatch(new En({ messages: [this], source: ne.EVENT_MESSAGE_FEEDBACK_UPDATED })), [2];
        }
      });
    });
  }, n.prototype.deleteFeedback = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return l = D.of(this._iid), a = l.requestQueue, d = l.dispatcher, r = new hy({ channelUrl: this.channelUrl, channelType: this.channelType, messageId: this.messageId, feedbackId: t }), [4, a.send(r)];
          case 1:
            return i.sent(), this.myFeedback = null, this.myFeedbackStatus = "NO_FEEDBACK", d.dispatch(new En({ messages: [this], source: ne.EVENT_MESSAGE_FEEDBACK_DELETED })), [2];
        }
      });
    });
  }, n;
}(N3), wn = function(e) {
  function n(t, l) {
    var a, d, r, i, c = this;
    if ((c = e.call(this, t, l) || this).reqId = "", c.replyToChannel = !1, c.errorCode = 0, c.sender = l.user ? new Yc(c._iid, l.user) : l.sender_id, c.reqId = (d = (a = l.req_id) !== null && a !== void 0 ? a : l.request_id) !== null && d !== void 0 ? d : "", c.replyToChannel = (r = l.is_reply_to_channel) !== null && r !== void 0 && r, l.request_state && Qt($t, l.request_state) && (c.sendingStatus = l.request_state), !c.sendingStatus)
      if (c.messageId > 0)
        c.sendingStatus = $t.SUCCEEDED;
      else if (c.scheduledInfo)
        switch (l.scheduled_status && (c._scheduledStatus = l.scheduled_status), l.scheduled_status) {
          case xa.SENT:
          case xa.IN_QUEUE:
            c.sendingStatus = $t.SUCCEEDED;
            break;
          case xa.PENDING:
            c.sendingStatus = $t.SCHEDULED;
            break;
          case xa.FAILED:
          case xa.REMOVED:
            c.sendingStatus = $t.FAILED;
            break;
          case xa.CANCELED:
            c.sendingStatus = $t.CANCELED;
        }
      else
        c.sendingStatus = $t.PENDING;
    return c.errorCode = (i = l.error_code) !== null && i !== void 0 ? i : 0, c;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { user: Yc.payloadify(t.sender), req_id: t.reqId, is_reply_to_channel: t.replyToChannel, request_state: t.sendingStatus, error_code: t.errorCode })));
  }, Object.defineProperty(n.prototype, "isResendable", { get: function() {
    return (this.sendingStatus === $t.FAILED || this.sendingStatus === $t.CANCELED) && ix(this.errorCode);
  }, enumerable: !1, configurable: !0 }), n.prototype.isIdentical = function(t) {
    return this.messageId > 0 && t.messageId > 0 ? this.messageId === t.messageId : this.reqId === t.reqId;
  }, n;
}(Bl), tU = { prevResultSize: 0, nextResultSize: 0, isInclusive: !1, reverse: !1, messageTypeFilter: bl.ALL, customTypesFilter: void 0, senderUserIdsFilter: void 0, includeReactions: !1, includeMetaArray: !1, includeParentMessageInfo: !1 }, _R = function(e) {
  return B("number", e.prevResultSize) && B("number", e.nextResultSize) && B("boolean", e.isInclusive) && B("boolean", e.reverse) && B("string", e.messageTypeFilter) && Qt(bl, e.messageTypeFilter) && Jt("string", e.customTypesFilter, !0) && Jt("string", e.senderUserIdsFilter, !0) && B("boolean", e.includeMetaArray) && B("boolean", e.includeReactions) && B("boolean", e.includeParentMessageInfo);
}, Qc = function(e) {
  function n(t, l) {
    var a, d, r, i, c = this;
    if ((c = e.call(this, t, l) || this).translations = {}, c.message = (a = l.message) !== null && a !== void 0 ? a : "", c.messageType = Gn.ADMIN, c.translations = (d = l.translations) !== null && d !== void 0 ? d : {}, l.parent_message_info) {
      var V = l.parent_message_info;
      c.parentMessage = Hl(t, je(Ae(x(x({}, V), { message_id: c.parentMessageId, channel_url: c.channelUrl, channel_type: c.channelType, file: V.file, url: (r = V.file) === null || r === void 0 ? void 0 : r.url, require_auth: (i = V.file) === null || i === void 0 ? void 0 : i.require_auth }))));
    }
    return c;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { message: t.message, translations: t.translations, parent_message_info: t.parentMessage ? e._getParentMessageInfoPayload.call(this, t.parentMessage) : null })));
  }, n.prototype.getThreadedMessagesByTimestamp = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, tU), l), Ze(this.messageId > 0 && B("number", t) && _R(a)).throw(j.invalidParameters), [4, tl.of(this._iid).getThreadedMessagesByTimestamp(this, t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n;
}(Bl), su = function() {
  function e(n) {
    var t, l;
    this.detail = {}, this.type = (t = n.type) !== null && t !== void 0 ? t : "", this.vendor = (l = n.vendor) !== null && l !== void 0 ? l : "", n.detail && B("object", n.detail) && !Array.isArray(n.detail) && (this.detail = n.detail);
  }
  return e.payloadify = function(n) {
    return je(Ae({ type: n.type, vendor: n.vendor, detail: n.detail }));
  }, e;
}(), ou = function() {
  function e(n) {
    this.status = n.status, n.original_message_info && (this.originalMessageInfo = { createdAt: n.original_message_info.ts, messageId: n.original_message_info.id });
  }
  return e.payloadify = function(n) {
    return je({ status: n.status, original_message_info: n.originalMessageInfo ? { id: n.originalMessageInfo.messageId, ts: n.originalMessageInfo.createdAt } : void 0 });
  }, e;
}(), kl = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o = this;
    if ((o = e.call(this, t, l) || this).message = "", o.messageParams = null, o.translations = {}, o.translationTargetLanguages = [], o.messageSurvivalSeconds = -1, o.plugins = [], o._poll = null, o.message = l.message, o.messageType = Gn.USER, o.translations = (r = l.translations) !== null && r !== void 0 ? r : {}, o.translationTargetLanguages = (i = l.target_langs) !== null && i !== void 0 ? i : [], Object.keys(o.translations).length === 0 && o.translationTargetLanguages.length > 0)
      try {
        for (var U = be(o.translationTargetLanguages), N = U.next(); !N.done; N = U.next()) {
          var R = N.value;
          o.translations[R] = "";
        }
      } catch (Z) {
        a = { error: Z };
      } finally {
        try {
          N && !N.done && (d = U.return) && d.call(U);
        } finally {
          if (a)
            throw a.error;
        }
      }
    if (o.messageSurvivalSeconds = (c = l.message_survival_seconds) !== null && c !== void 0 ? c : -1, o.plugins = l.plugins ? l.plugins.map(function(Z) {
      return new su(Z);
    }) : [], o._poll = l.poll ? new ld(o._iid, l.poll) : null, l.parent_message_info) {
      var h = l.parent_message_info;
      o.parentMessage = Hl(t, je(Ae(x(x({}, h), { created_at: h.ts, message_id: o.parentMessageId, channel_url: o.channelUrl, channel_type: o.channelType, file: h.file, url: (V = h.file) === null || V === void 0 ? void 0 : V.url, require_auth: (s = h.file) === null || s === void 0 ? void 0 : s.require_auth }))));
    }
    return l.review_info && (o.messageReviewInfo = new ou(l.review_info)), o;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { message: t.message, translations: t.translations, message_survival_seconds: t.messageSurvivalSeconds, plugins: t.plugins.map(function(l) {
      return su.payloadify(l);
    }), poll: t._poll ? ld.payloadify(t._poll) : null, parent_message_info: t.parentMessage ? e._getParentMessageInfoPayload.call(this, t.parentMessage) : null, review_info: t.messageReviewInfo ? ou.payloadify(t.messageReviewInfo) : void 0 })));
  }, n.prototype.getThreadedMessagesByTimestamp = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, tU), l), Ze(this.messageId > 0 && B("number", t) && _R(a)).throw(j.invalidParameters), [4, tl.of(this._iid).getThreadedMessagesByTimestamp(this, t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype.applyPoll = function(t) {
    return !(this._poll && this._poll.id === t.id && this._poll.updatedAt > t.updatedAt) && (this._poll = t, !0);
  }, Object.defineProperty(n.prototype, "poll", { get: function() {
    return this._poll;
  }, enumerable: !1, configurable: !0 }), n;
}(wn), Da = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V = this;
    if ((V = e.call(this, t, l) || this).messageParams = null, V.fileInfoList = [], V.messageSurvivalSeconds = -1, V.messageType = Gn.FILE, V.fileInfoList = (d = (a = l.files) === null || a === void 0 ? void 0 : a.map(function(o) {
      return new HT(t, o);
    })) !== null && d !== void 0 ? d : [], V.messageSurvivalSeconds = (r = l.message_survival_seconds) !== null && r !== void 0 ? r : -1, l.parent_message_info) {
      var s = l.parent_message_info;
      V.parentMessage = Hl(t, je(Ae(x(x({}, s), { created_at: s.ts, message_id: V.parentMessageId, channel_url: V.channelUrl, channel_type: V.channelType, file: s.file, url: (i = s.file) === null || i === void 0 ? void 0 : i.url, require_auth: (c = s.file) === null || c === void 0 ? void 0 : c.require_auth }))));
    }
    return V;
  }
  return J(n, e), n.prototype.getThreadedMessagesByTimestamp = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, tU), l), Ze(this.messageId > 0 && B("number", t) && _R(a)).throw(j.invalidParameters), [4, tl.of(this._iid).getThreadedMessagesByTimestamp(this, t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { files: Array.isArray(t.fileInfoList) ? t.fileInfoList.map(function(l) {
      return HT.payloadify(l);
    }) : null, message_survival_seconds: t.messageSurvivalSeconds, parent_message_info: t.parentMessage ? e._getParentMessageInfoPayload.call(this, t.parentMessage) : null })));
  }, n._isMultipleFilesMessagePayload = function(t) {
    var l = t.files;
    return Array.isArray(l) && l.length >= 2;
  }, n._isMultipleFilesMessageSerializedData = function(t) {
    var l = t.fileInfoList;
    return Array.isArray(l);
  }, n;
}(wn);
(function(e) {
  e.SENT = "SENT", e.READ = "READ";
})(lV || (lV = {}));
var SV = function(e) {
  function n(t, l) {
    var a, d, r = this;
    if ((r = e.call(this, t, l) || this).notificationData = null, r.notificationId = l.notification_message_id, r.messageType = Gn.ADMIN, r.messageStatus = (a = l.message_status) !== null && a !== void 0 ? a : lV.SENT, r.priority = (d = l.priority) !== null && d !== void 0 ? d : vT.NORMAL, r.extendedMessage.sub_type === 0)
      try {
        var i = JSON.parse(r.extendedMessage.sub_data), c = i.label, V = i.tags, s = V === void 0 ? [] : V, o = i.template_key, U = i.template_variables;
        r.notificationData = { label: c, tags: s, templateKey: o, templateVariables: U };
      } catch {
      }
    return r;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { notification_message_id: t.notificationId, message_status: t.messageStatus, priority: t.priority })));
  }, n.prototype.isIdentical = function(t) {
    return this.notificationId === t.notificationId;
  }, n;
}(N3), Uu = function(e) {
  if (e.notificationId)
    return SV.payloadify(e);
  switch (e.messageType) {
    case Gn.USER:
      return kl.payloadify(e);
    case Gn.FILE:
      return e.fileInfoList ? Da.payloadify(e) : Ln.payloadify(e);
    case Gn.ADMIN:
      return Qc.payloadify(e);
    default:
      throw j.unknown;
  }
}, Hl = function(e, n) {
  if (n.notification_message_id)
    return new SV(e, n);
  switch (n.type) {
    case "MESG":
      return new kl(e, n);
    case "FILE":
      return Da._isMultipleFilesMessagePayload(n) ? new Da(e, n) : new Ln(e, n);
    case "ADMM":
    case "BRDM":
      return new Qc(e, n);
    default:
      return null;
  }
}, Ln = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F = this;
    (F = e.call(this, t, l) || this).messageParams = null, F.plainUrl = "", F.requireAuth = !1, F.thumbnails = [], F.messageSurvivalSeconds = -1, F.messageType = Gn.FILE;
    var m = l.file;
    if (F.plainUrl = ((d = (a = m == null ? void 0 : m.url) !== null && a !== void 0 ? a : l.url) !== null && d !== void 0 ? d : "").split("?auth=")[0], F.name = (i = (r = m == null ? void 0 : m.name) !== null && r !== void 0 ? r : l.name) !== null && i !== void 0 ? i : "File", F.size = (V = (c = m == null ? void 0 : m.size) !== null && c !== void 0 ? c : l.size) !== null && V !== void 0 ? V : 0, F.data = (o = (s = m == null ? void 0 : m.data) !== null && s !== void 0 ? s : l.custom) !== null && o !== void 0 ? o : "", F.type = m ? (U = m.type) !== null && U !== void 0 ? U : "" : (N = l.type) !== null && N !== void 0 ? N : "", F.requireAuth = (R = l.require_auth) !== null && R !== void 0 && R, F.thumbnails = l.thumbnails ? l.thumbnails.map(function(u) {
      var b;
      return new Br(F._iid, typeof u == "string" ? { url: u, width: 0, height: 0 } : x(x({}, u), { url: ((b = u.url) !== null && b !== void 0 ? b : "").split("auth=")[0] }), F.requireAuth);
    }) : [], F.messageSurvivalSeconds = (h = l.message_survival_seconds) !== null && h !== void 0 ? h : -1, l.parent_message_info) {
      var E = l.parent_message_info;
      F.parentMessage = Hl(t, je(Ae(x(x({}, E), { created_at: E.ts, message_id: F.parentMessageId, channel_url: F.channelUrl, channel_type: F.channelType, file: E.file, url: (Z = E.file) === null || Z === void 0 ? void 0 : Z.url, require_auth: (W = E.file) === null || W === void 0 ? void 0 : W.require_auth }))));
    }
    return F;
  }
  return J(n, e), n.payloadify = function(t) {
    var l;
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { url: t.plainUrl, require_auth: t.requireAuth, file: { name: t.name, size: t.size, type: t.type, data: t.data }, thumbnails: (l = t.thumbnails) === null || l === void 0 ? void 0 : l.map(function(a) {
      return { url: a.plainUrl, width: a.width, height: a.height, real_width: a.realWidth, real_height: a.realHeight };
    }), message_survival_seconds: t.messageSurvivalSeconds, parent_message_info: t.parentMessage ? e._getParentMessageInfoPayload.call(this, t.parentMessage) : null })));
  }, Object.defineProperty(n.prototype, "url", { get: function() {
    var t = D.of(this._iid).sessionManager;
    return this.requireAuth && t.ekey ? "".concat(this.plainUrl, "?auth=").concat(t.ekey) : this.plainUrl;
  }, enumerable: !1, configurable: !0 }), n.prototype.getThreadedMessagesByTimestamp = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, tU), l), Ze(this.messageId > 0 && B("number", t) && _R(a)).throw(j.invalidParameters), [4, tl.of(this._iid).getThreadedMessagesByTimestamp(this, t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n;
}(wn), dR = function(e) {
  function n(t, l) {
    var a = l.file, d = l.fileUrl, r = l.fileName, i = l.fileSize, c = l.mimeType, V = l.thumbnailSizes, s = l._uploadedMetaData, o = l._thumbnails, U = e.call(this, t) || this;
    return U._plainUrl = d, U.file = a, U.fileName = r, U.fileSize = i, U.mimeType = c, U.thumbnailSizes = V, U._uploadedMetaData = s, U._thumbnails = o, U;
  }
  return J(n, e), n.getPlainUrl = function(t) {
    return t instanceof n ? t._plainUrl : t.fileUrl;
  }, Object.defineProperty(n.prototype, "fileUrl", { get: function() {
    var t, l = D.of(this._iid).sessionManager;
    return this._plainUrl && (!((t = this._uploadedMetaData) === null || t === void 0) && t.requireAuth) && l.ekey ? "".concat(this._plainUrl, "?auth=").concat(l.ekey) : this._plainUrl;
  }, set: function(t) {
    this._plainUrl = t;
  }, enumerable: !1, configurable: !0 }), n.prototype.toJSON = function() {
    return { file: this.file, fileUrl: this._plainUrl, fileName: this.fileName, fileSize: this.fileSize, mimeType: this.mimeType, thumbnailSizes: this.thumbnailSizes, _thumbnails: this._thumbnails, _uploadedMetaData: this._uploadedMetaData };
  }, n;
}(ml), Zy = function(e) {
  function n(t) {
    var l, a, d, r, i = [];
    return t.mentionType === Jl.USERS && (t.mentionedUserIds ? i = t.mentionedUserIds : t.mentionedUsers && (i = t.mentionedUsers.map(function(c) {
      return c.userId;
    }))), e.call(this, { code: "FILE", ackRequired: !0, payload: je(Ae({ channel_url: t.channelUrl, files: t.files ? F3(t.files) : null, url: t.url, name: (l = t.fileName) !== null && l !== void 0 ? l : "", type: (a = t.mimeType) !== null && a !== void 0 ? a : "", size: (d = t.fileSize) !== null && d !== void 0 ? d : 0, custom: t.data, custom_type: t.customType, thumbnails: (r = t._thumbnails) === null || r === void 0 ? void 0 : r.map(function(c) {
      return Br.payloadify(c);
    }), require_auth: t.requireAuth, metaarray: t.metaArrays, mention_type: t.mentionType, mentioned_user_ids: i, push_option: t.pushNotificationDeliveryOption && t.pushNotificationDeliveryOption !== pd.DEFAULT ? t.pushNotificationDeliveryOption : void 0, apple_critical_alert_options: t.appleCriticalAlertOptions ? ad.payloadify(t.appleCriticalAlertOptions) : null, silent: t.silent, reply_to_channel: t.isReplyToChannel, parent_message_id: t.parentMessageId ? t.parentMessageId : null, req_id: t.reqId, pin_message: t.isPinnedMessage })) }) || this;
  }
  return J(n, e), n;
}(Yl), Ty = function(e) {
  function n(t) {
    var l, a, d = this;
    d = e.call(this) || this;
    var r = [];
    return t.mentionType === Jl.USERS && (t.mentionedUserIds ? r = t.mentionedUserIds : t.mentionedUsers && (r = t.mentionedUsers.map(function(i) {
      return i.userId;
    }))), d.method = he.POST, d.path = "".concat(Lt(t.channelType), "/").concat(encodeURIComponent(t.channelUrl), "/messages"), d.params = je(Ae({ message_type: Gn.FILE, user_id: t.userId, files: t.files ? F3(t.files) : null, url: t.fileUrl, mention_type: t.mentionType, mentioned_user_ids: r, file_name: t.fileName, file_size: t.fileSize, file_type: t.mimeType, data: t.data, custom_type: t.customType, thumbnails: (l = t._thumbnails) === null || l === void 0 ? void 0 : l.map(function(i) {
      return Br.payloadify(i);
    }), require_auth: t.requireAuth, sorted_metaarray: (a = t.metaArrays) === null || a === void 0 ? void 0 : a.map(function(i) {
      return Ol.payloadify(i);
    }), push_option: t.pushNotificationDeliveryOption, parent_message_id: t.parentMessageId ? t.parentMessageId : null, apple_critical_alert_options: t.appleCriticalAlertOptions ? ad.payloadify(t.appleCriticalAlertOptions) : null, reply_to_channel: t.isReplyToChannel, req_id: t.reqId, pin_message: t.isPinnedMessage })), d;
  }
  return J(n, e), n;
}(Te), bW = function(e) {
  function n(t, l, a) {
    var d, r, i, c, V = this;
    (V = e.call(this, t, "FILE", a) || this).message = a.files && a.files.length >= 2 ? new Da(t, a) : new Ln(t, a);
    var s = D.of(t).sdkState;
    return V.isMentioned = Ec(V.message.mentionType, (i = (d = V.message.mentionedUserIds) !== null && d !== void 0 ? d : (r = V.message.mentionedUsers) === null || r === void 0 ? void 0 : r.map(function(o) {
      return o.userId;
    })) !== null && i !== void 0 ? i : [], s.userId), V.forceUpdateLastMessage = (c = a.force_update_last_message) !== null && c !== void 0 && c, V;
  }
  return J(n, e), n;
}(Wn), Fy = function(e) {
  function n(t, l) {
    var a, d, r, i, c = this;
    (c = e.call(this, t, l) || this).message = l.files && l.files.length >= 2 ? new Da(t, l) : new Ln(t, l);
    var V = D.of(t).sdkState;
    return c.isMentioned = Ec(c.message.mentionType, (r = (a = c.message.mentionedUserIds) !== null && a !== void 0 ? a : (d = c.message.mentionedUsers) === null || d === void 0 ? void 0 : d.map(function(s) {
      return s.userId;
    })) !== null && r !== void 0 ? r : [], V.userId), c.forceUpdateLastMessage = (i = l.force_update_last_message) !== null && i !== void 0 && i, c;
  }
  return J(n, e), n;
}(ue);
function F3(e) {
  return e.map(function(n) {
    var t, l;
    return je(Ae({ url: dR.getPlainUrl(n), file_name: n.fileName, file_type: n.mimeType, file_size: n.fileSize, thumbnails: (t = n._thumbnails) === null || t === void 0 ? void 0 : t.map(function(a) {
      return Br.payloadify(a);
    }), require_auth: (l = n._uploadedMetaData) === null || l === void 0 ? void 0 : l.requireAuth }));
  });
}
var rl;
(function(e) {
  e[e.PENDING = 0] = "PENDING", e[e.UPLOADING = 1] = "UPLOADING", e[e.UPLOADED = 2] = "UPLOADED", e[e.SENDING = 3] = "SENDING", e[e.FAILED = 4] = "FAILED";
})(rl || (rl = {}));
var Wy = function() {
  function e(n, t) {
    var l = t.sdkState, a = t.dispatcher, d = t.requestQueue, r = t.onlineDetector, i = t.cacheContext, c = this;
    this._queueMap = /* @__PURE__ */ new Map(), this._iid = n, this._sdkState = l, this._requestQueue = d, this._cacheContext = i, this._dispatcher = a, this._dispatcher.on(function(V) {
      V instanceof ua && (c._connectionState = V.stateType);
    }), this._onlineDetector = r;
  }
  return Object.defineProperty(e.prototype, "_shouldSendThroughWebSocket", { get: function() {
    return this._connectionState === tn.CONNECTED || this._connectionState === tn.CONNECTING || this._connectionState === tn.RECONNECTING;
  }, enumerable: !1, configurable: !0 }), e.prototype._sendFileMessage = function(n, t) {
    return M(this, void 0, void 0, function() {
      var l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return l = this._createSendFileMessageRequestParams(n, t), this._shouldSendThroughWebSocket ? (a = new Zy(l), [4, this._requestQueue.send(a)]) : [3, 2];
          case 1:
            return d = r.sent(), [2, d.as(bW).message];
          case 2:
            return a = new Ty(x(x({}, l), { userId: this._sdkState.userId })), [4, this._requestQueue.send(a)];
          case 3:
            return d = r.sent(), [2, d.as(Fy).message];
        }
      });
    });
  }, e.prototype._createSendFileMessageRequestParams = function(n, t) {
    var l = x(x({}, t.params), { channelUrl: n.url, channelType: n.channelType, reqId: t.requestId, url: "" });
    if (t.multipleFileUploadInfo) {
      var a = t.params;
      l.files = a.fileInfoList;
    } else
      a = t.params, l.url = a.fileUrl, l.requireAuth = a.requireAuth;
    return l;
  }, e.prototype._resolveMessageQueue = function(n) {
    var t;
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s, o, U, N, R, h;
      return p(this, function(Z) {
        switch (Z.label) {
          case 0:
            if (!(l = this._queueMap.get(n.url)))
              return [3, 21];
            if (l.isResolving)
              return [3, 20];
            l.isResolving = !0, a = [], d = !0, Z.label = 1;
          case 1:
            Z.trys.push([1, 15, 16, 17]), r = be(l.messageQueue), i = r.next(), Z.label = 2;
          case 2:
            if (i.done)
              return [3, 14];
            switch (c = i.value, c.state) {
              case rl.PENDING:
              case rl.UPLOADING:
                return [3, 3];
              case rl.UPLOADED:
                return [3, 4];
              case rl.FAILED:
                return [3, 12];
            }
            return [3, 13];
          case 3:
            return d = !1, a.push(c), [3, 13];
          case 4:
            if (!d)
              return [3, 10];
            Z.label = 5;
          case 5:
            return Z.trys.push([5, 8, , 9]), c.state = rl.SENDING, [4, this._sendFileMessage(n, c)];
          case 6:
            return V = Z.sent(), c.deferred.resolve(V), [4, Qa(100)];
          case 7:
            return Z.sent(), [3, 9];
          case 8:
            return s = Z.sent(), c.deferred.reject(s), [3, 9];
          case 9:
            return [3, 11];
          case 10:
            a.push(c), Z.label = 11;
          case 11:
            return [3, 13];
          case 12:
            return o = (t = c.error) !== null && t !== void 0 ? t : j.unknown, c.deferred.reject(o.code === nt.REQUEST_CANCELED ? j.fileUploadCanceled : o), [3, 13];
          case 13:
            return i = r.next(), [3, 2];
          case 14:
            return [3, 17];
          case 15:
            return U = Z.sent(), R = { error: U }, [3, 17];
          case 16:
            try {
              i && !i.done && (h = r.return) && h.call(r);
            } finally {
              if (R)
                throw R.error;
            }
            return [7];
          case 17:
            return N = l.isResolveRequestPending, l.messageQueue = a, l.isResolving = !1, l.isResolveRequestPending = !1, N ? [4, this._resolveMessageQueue(n)] : [3, 19];
          case 18:
            Z.sent(), Z.label = 19;
          case 19:
            return [3, 21];
          case 20:
            l.isResolveRequestPending = !0, Z.label = 21;
          case 21:
            return [2];
        }
      });
    });
  }, e.prototype._uploadNextPendingItem = function(n) {
    var t;
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s, o, U;
      return p(this, function(N) {
        switch (N.label) {
          case 0:
            return (l = this._queueMap.get(n.url)) && (a = l.messageQueue.find(function(R) {
              return R.state === rl.PENDING;
            })) ? a.multipleFileUploadInfo ? (d = a.multipleFileUploadInfo, r = d.uploadIndex, i = d.uploadCount, c = d.requestHandler, U = a.params, V = U.fileInfoList[r], !Nl(V.file) || !((t = V._uploadedMetaData) === null || t === void 0) && t.isUploaded ? [3, 2] : [4, this._tryUploadNextItemAndUpdateItemState(n, l, a)]) : [3, 4] : [3, 9];
          case 1:
            return N.sent(), [3, 3];
          case 2:
            a.state = r < i - 1 ? rl.PENDING : rl.UPLOADED, N.label = 3;
          case 3:
            return s = U.fileInfoList[r], o = a.multipleFileUploadInfo.uploadIndex++, a.multipleFileUploadInfo.isCopy || c == null || c._triggerOnFileUploaded(a.requestId, o, s, a.error), [3, 7];
          case 4:
            return U = a.params, Nl(U.file) ? [4, this._tryUploadNextItemAndUpdateItemState(n, l, a)] : [3, 6];
          case 5:
            return N.sent(), [3, 7];
          case 6:
            U.thumbnailSizes = [], a.state = rl.UPLOADED, N.label = 7;
          case 7:
            return this._uploadNextPendingItem(n), [4, this._resolveMessageQueue(n)];
          case 8:
            N.sent(), N.label = 9;
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype._tryUploadNextItemAndUpdateItemState = function(n, t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return [4, this._onlineDetector.isOnline()];
          case 1:
            if (a = s.sent(), !D.of(this._iid).sessionManager.currentUser || !a)
              return l.error = j.connectionRequired, l.state = rl.FAILED, [2];
            if (!(t.uploadQueue.length < 6))
              return [3, 9];
            l.state = rl.UPLOADING, t.uploadQueue.push(l), s.label = 2;
          case 2:
            return s.trys.push([2, 7, , 8]), l.multipleFileUploadInfo ? (d = l.multipleFileUploadInfo, r = d.uploadIndex, i = d.uploadCount, c = l.params, [4, this._uploadNextFileForMultipleFilesItemAndUpdateParams(n, l, c)]) : [3, 4];
          case 3:
            return s.sent(), l.state = r < i - 1 ? rl.PENDING : rl.UPLOADED, [3, 6];
          case 4:
            return c = l.params, [4, this._uploadNextFileForSingleFileItemAndUpdateParams(n, l, c)];
          case 5:
            s.sent(), l.state = rl.UPLOADED, s.label = 6;
          case 6:
            return [3, 8];
          case 7:
            switch ((V = s.sent()).code) {
              case nt.REQUEST_FAILED:
                l.error = new j({ code: nt.NETWORK_ERROR, message: "Failed to upload a file." });
                break;
              case nt.REQUEST_CANCELED:
                l.error = j.fileUploadCanceled;
                break;
              default:
                l.error = V;
            }
            return l.state = rl.FAILED, [3, 8];
          case 8:
            this._dequeueUploadItem(t, l), s.label = 9;
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype._dequeueUploadItem = function(n, t) {
    var l = n.uploadQueue.findIndex(function(a) {
      return a.requestId === t.requestId;
    });
    l >= 0 && n.uploadQueue.splice(l, 1);
  }, e.prototype._uploadNextFileForSingleFileItemAndUpdateParams = function(n, t, l) {
    var a, d, r;
    return M(this, void 0, void 0, function() {
      var i, c, V, s, o, U, N, R, h, Z;
      return p(this, function(W) {
        switch (W.label) {
          case 0:
            return i = new nR({ file: l.file, channelUrl: n.url, thumbnailSizes: l.thumbnailSizes, requestId: t.requestId }), [4, this._requestQueue.send(i)];
          case 1:
            return c = W.sent(), V = c.as(lR), s = V.url, o = V.fileSize, U = o === void 0 ? l.fileSize : o, N = V.thumbnails, R = N === void 0 ? [] : N, h = V.requireAuth, Z = h !== void 0 && h, l.fileName = (a = l.fileName) !== null && a !== void 0 ? a : l.file.name, l.mimeType = (d = l.mimeType) !== null && d !== void 0 ? d : l.file.type, l.fileSize = (r = l.fileSize) !== null && r !== void 0 ? r : l.file.size, l.fileUrl = s, l.fileSize = U, l.requireAuth = Z, l._thumbnails = R, [2];
        }
      });
    });
  }, e.prototype._uploadNextFileForMultipleFilesItemAndUpdateParams = function(n, t, l) {
    var a, d, r;
    return M(this, void 0, void 0, function() {
      var i, c, V, s, o, U, N, R, h, Z, W;
      return p(this, function(F) {
        switch (F.label) {
          case 0:
            return i = t.multipleFileUploadInfo.uploadIndex, c = l.fileInfoList[i], V = new nR({ file: c.file, channelUrl: n.url, thumbnailSizes: c.thumbnailSizes, requestId: t.requestId }), [4, this._requestQueue.send(V)];
          case 1:
            return s = F.sent(), o = s.as(lR), U = o.url, N = o.fileSize, R = N === void 0 ? c.fileSize : N, h = o.thumbnails, Z = o.requireAuth, W = Z !== void 0 && Z, c.fileName = (a = c.fileName) !== null && a !== void 0 ? a : c.file.name, c.mimeType = (d = c.mimeType) !== null && d !== void 0 ? d : c.file.type, c.fileSize = (r = c.fileSize) !== null && r !== void 0 ? r : c.file.size, c.file = void 0, c.fileUrl = U, c.fileSize = R, c._thumbnails = h, c._uploadedMetaData = x(x({}, c._uploadedMetaData), { requireAuth: W, isUploaded: !0 }), c instanceof dR || (l.fileInfoList[i] = new dR(this._iid, c)), [2];
        }
      });
    });
  }, e.prototype.request = function(n, t, l, a) {
    return a === void 0 && (a = {}), M(this, void 0, void 0, function() {
      var d, r, i, c, V;
      return p(this, function(s) {
        return this._queueMap.has(n.url) || (d = { messageQueue: [], uploadQueue: [], isResolving: !1, isResolveRequestPending: !1 }, this._queueMap.set(n.url, d)), r = this._queueMap.get(n.url), i = new Ll(), c = { requestId: t, params: l, state: rl.PENDING, deferred: i }, function(o) {
          return "fileInfoList" in o;
        }(l) && (V = x({ uploadIndex: 0, uploadCount: l.fileInfoList.length }, a), c.multipleFileUploadInfo = V), r.messageQueue.push(c), this._uploadNextPendingItem(n), [2, i.promise];
      });
    });
  }, e.prototype.cancel = function(n, t) {
    var l, a, d = this._queueMap.get(n.url);
    if (d) {
      var r = t ? [d.messageQueue.find(function(R) {
        return R.requestId === t;
      })] : ot([], et(d.messageQueue), !1);
      try {
        for (var i = be(r), c = i.next(); !c.done; c = i.next()) {
          var V = c.value;
          if (V)
            switch (V.state) {
              case rl.PENDING:
                if (V.state = rl.FAILED, V.error = j.requestCanceled, V.multipleFileUploadInfo && !V.multipleFileUploadInfo.isCopy) {
                  var s = V.multipleFileUploadInfo, o = s.uploadIndex, U = s.requestHandler, N = V.params.fileInfoList[o];
                  U == null || U._triggerOnFileUploaded(V.requestId, o, N, j.fileUploadCanceled);
                }
                this._resolveMessageQueue(n);
                break;
              case rl.UPLOADING:
                this._requestQueue.cancel(V.requestId), this._dispatcher.dispatch(new _N({ requestId: V.requestId }));
            }
        }
      } catch (R) {
        l = { error: R };
      } finally {
        try {
          c && !c.done && (a = i.return) && a.call(i);
        } finally {
          if (l)
            throw l.error;
        }
      }
    } else
      t && (this._requestQueue.cancel(t), this._dispatcher.dispatch(new _N({ requestId: t })));
  }, e;
}(), fT, Ls = { prevResultSize: 0, nextResultSize: 0, isInclusive: !1, reverse: !1, messageTypeFilter: bl.ALL, customTypesFilter: void 0, senderUserIdsFilter: void 0, replyType: al.NONE, includeReactions: !1, includeMetaArray: !1, includeParentMessageInfo: !1, includeThreadInfo: !1, showSubchannelMessagesOnly: !1 }, Nu = function(e) {
  return B("number", e.prevResultSize) && B("number", e.nextResultSize) && B("boolean", e.isInclusive) && B("boolean", e.reverse) && B("string", e.messageTypeFilter) && Qt(bl, e.messageTypeFilter) && Jt("string", e.customTypesFilter, !0) && Jt("string", e.senderUserIdsFilter, !0) && Qt(al, e.replyType) && B("boolean", e.includeMetaArray) && B("boolean", e.includeReactions) && B("boolean", e.includeParentMessageInfo) && B("boolean", e.includeThreadInfo) && B("boolean", e.showSubchannelMessagesOnly);
}, wT = { replyType: al.NONE, includeReactions: !1, includeThreadInfo: !1, includeMetaArray: !1, includeParentMessageInfo: !1 }, Ru = function(e) {
  return Qt(al, e.replyType) && B("boolean", e.includeReactions) && B("boolean", e.includeMetaArray) && B("boolean", e.includeParentMessageInfo) && B("boolean", e.includeThreadInfo);
}, my = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = t.includeMetaArray, i = t.includeReactions, c = t.includeThreadInfo, V = t.includeParentMessageInfo, s = e.call(this) || this;
    return s.method = he.GET, s.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(encodeURIComponent(d)), s.params = { is_sdk: !0, with_sorted_meta_array: r, include_reactions: i, include_thread_info: c, include_parent_message_info: V, include_poll_details: !0 }, s;
  }
  return J(n, e), n;
}(Te), uy = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.message = l ? Hl(t, x({}, l)) : null, a;
  }
  return J(n, e), n;
}(ue), gU = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.timestamp, r = t.token, i = t.prevResultSize, c = t.nextResultSize, V = t.isInclusive, s = t.reverse, o = t.messageTypeFilter, U = t.customTypesFilter, N = t.senderUserIdsFilter, R = t.replyType, h = t.includeMetaArray, Z = t.includeReactions, W = t.parentMessageId, F = t.includeThreadInfo, m = t.includeParentMessageInfo, E = t.showSubchannelMessagesOnly, u = t.checkingHasNext, b = t.checkingContinuousMessages, k = e.call(this) || this;
    return k.method = he.GET, k.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages"), k.params = je(Ae({ is_sdk: !0, prev_limit: i, next_limit: c, include: V, reverse: s, message_ts: d, message_id: r, message_type: o ?? null, custom_types: U, sender_ids: N, include_reply_type: R, with_sorted_meta_array: h, include_reactions: Z, parent_message_id: W, include_thread_info: F, include_parent_message_info: m, show_subchannel_message_only: E, include_poll_details: !0, checking_has_next: u, checking_continuous_messages: b })), k;
  }
  return J(n, e), n;
}(Te), IU = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return l.is_continuous_messages !== void 0 && (a.isContinuousMessages = l.is_continuous_messages), l.has_next !== void 0 && (a.hasNext = l.has_next), a.messages = l.messages.map(function(d) {
      return Hl(t, d);
    }), a;
  }
  return J(n, e), n;
}(ue), py = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.timestamp, r = t.token, i = t.replyType, c = t.includeMetaArray, V = t.includeReactions, s = t.includeThreadInfo, o = t.includeParentMessageInfo, U = e.call(this) || this;
    return U.method = he.GET, U.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/changelogs"), U.params = { change_ts: d, token: r, with_sorted_meta_array: c, include_reactions: V, include_thread_info: s, include_reply_type: i, include_parent_message_info: o, include_poll_details: !0 }, U;
  }
  return J(n, e), n;
}(Te), My = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.updatedMessages = l.updated.map(function(d) {
      return Hl(t, d);
    }), a.deletedMessagesInfo = l.deleted.map(function(d) {
      return { messageId: d.message_id, deletedAt: d.deleted_at };
    }), a.hasMore = l.has_more, a.nextToken = l.next, a;
  }
  return J(n, e), n;
}(ue), Ey = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.scheduledMessageId, d = e.call(this) || this;
    return d.method = he.GET, d.path = "".concat(vl, "/").concat(encodeURIComponent(l), "/scheduled_messages/").concat(encodeURIComponent(a)), d.params = {}, d;
  }
  return J(n, e), n;
}(Te), Sy = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.message = l ? Hl(t, x({}, l)) : null, a;
  }
  return J(n, e), n;
}(ue);
(function(e) {
  e.MUTED = "muted", e.BANNED = "banned";
})(fT || (fT = {}));
var hu = function() {
  function e(n) {
    var t, l, a, d;
    this.restrictionType = null, Qt(fT, n.restriction_type) && (this.restrictionType = n.restriction_type), this.description = (t = n.description) !== null && t !== void 0 ? t : null, this.endAt = (a = (l = n.end_at) !== null && l !== void 0 ? l : n.muted_end_at) !== null && a !== void 0 ? a : -1, this.remainingDuration = (d = n.remaining_duration) !== null && d !== void 0 ? d : -1;
  }
  return e.payloadify = function(n) {
    return je(Ae({ restriction_type: n.restrictionType, description: n.description, end_at: n.endAt, remaining_duration: n.remainingDuration }));
  }, e;
}(), BV = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.restrictionInfo = new hu(l), a;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), hu.payloadify(t.restrictionInfo))));
  }, n;
}(xt), ky = function(e) {
  function n(t, l) {
    var a, d = this;
    return (d = e.call(this, t, l) || this).isMuted = !1, d.isMuted = (a = l.is_muted) !== null && a !== void 0 && a, d;
  }
  return J(n, e), n;
}(xt), oa = function() {
  function e() {
    this._onPending = ut, this._onFailed = ut, this._onSucceeded = ut;
  }
  return e.prototype._trigger = function(n) {
    switch (n == null ? void 0 : n.sendingStatus) {
      case $t.PENDING:
        n.errorCode === 0 && this._onPending(n);
        break;
      case $t.SCHEDULED:
      case $t.SUCCEEDED:
        this._onSucceeded(n);
    }
  }, e.prototype._triggerFailed = function(n, t) {
    switch (t == null ? void 0 : t.sendingStatus) {
      case $t.FAILED:
      case $t.CANCELED:
        this._onFailed(n, t.scheduledInfo ? null : t);
    }
  }, e.prototype.onPending = function(n) {
    return this._onPending = n, this;
  }, e.prototype.onFailed = function(n) {
    return this._onFailed = n, this;
  }, e.prototype.onSucceeded = function(n) {
    return this._onSucceeded = n, this;
  }, e;
}(), PR = { data: void 0, customType: void 0, mentionType: Jl.USERS, mentionedUserIds: void 0, mentionedUsers: void 0, mentionedMessageTemplate: void 0, metaArrays: void 0, parentMessageId: void 0, isReplyToChannel: !1, pushNotificationDeliveryOption: void 0, appleCriticalAlertOptions: void 0, isPinnedMessage: !1 }, AR = function(e) {
  return B("string", e.data, !0) && B("string", e.customType, !0) && Qt(Jl, e.mentionType) && Jt("string", e.mentionedUserIds, !0) && Jt(xt, e.mentionedUsers, !0) && B("string", e.mentionedMessageTemplate, !0) && Jt(Ol, e.metaArrays, !0) && B("number", e.parentMessageId, !0) && B("boolean", e.isReplyToChannel) && Qt(pd, e.pushNotificationDeliveryOption, !0) && B(ad, e.appleCriticalAlertOptions, !0) && B("boolean", e.isPinnedMessage, !0);
}, Zu = function(e) {
  return { isReplyToChannel: e.isReplyToChannel, pushNotificationDeliveryOption: e.pushNotificationDeliveryOption, pollId: e.pollId };
}, W3 = x(x({}, PR), { message: "", translationTargetLanguages: void 0, pollId: void 0, extendedMessagePayload: void 0 });
function m3(e) {
  var n, t, l;
  return (n = e.messageParams) !== null && n !== void 0 ? n : Ae(x(x({}, e), { mentionType: e.mentionType, mentionedUserIds: (t = e.mentionedUserIds) !== null && t !== void 0 ? t : (l = e.mentionedUsers) === null || l === void 0 ? void 0 : l.map(function(a) {
    return a.userId;
  }), translationTargetLanguages: Object.keys(e.translations), pushNotificationDeliveryOption: pd.DEFAULT, parentMessageId: null, isReplyToChannel: !1, isPinnedMessage: !1 }));
}
var FV, gT = function(e) {
  var n;
  return je(Ae({ data: e.data, customType: e.customType, mentionType: e.mentionType, mentionedUsers: e.mentionedUsers, mentionedUserIds: e.mentionedUserIds, mentionedMessageTemplate: e.mentionedMessageTemplate, metaArrays: e.metaArrays, pollId: (n = e.poll) === null || n === void 0 ? void 0 : n.id, parentMessageId: e.parentMessageId, appleCriticalAlertOptions: e.appleCriticalAlertOptions, message: e.message, translationTargetLanguages: Object.keys(e.translations), extendedMessagePayload: e.extendedMessagePayload }));
}, u3 = function(e) {
  return AR(e) && B("string", e.message) && Jt("string", e.translationTargetLanguages, !0) && B("number", e.pollId, !0) && B("object", e.extendedMessagePayload, !0);
};
(function(e) {
  e.FILE = "file", e.BLOB = "blob", e.BLOB_LIKE_OBJECT = "blobLikeObject", e.URL = "url";
})(FV || (FV = {}));
var EN = function(e) {
  return typeof window < "u" && "Blob" in window && typeof Blob < "u" && e instanceof Blob;
}, RZ = function(e) {
  return e === FV.BLOB || e === FV.FILE;
}, Tu = function(e) {
  return { file: e.file, fileKey: e.fileKey, fileType: e.fileType, isReplyToChannel: e.isReplyToChannel, pushNotificationDeliveryOption: e.pushNotificationDeliveryOption };
}, Fu = x(x({}, PR), { file: void 0, fileKey: void 0, fileUrl: void 0, fileName: void 0, fileType: void 0, fileSize: void 0, mimeType: void 0, thumbnailSizes: void 0, requireAuth: !1 });
function p3(e) {
  var n, t, l, a;
  return (n = e.messageParams) !== null && n !== void 0 ? n : Ae(x(x({}, e), { fileUrl: e.plainUrl, fileName: e.name, fileSize: e.size, mimeType: e.type, mentionType: e.mentionType, mentionedUserIds: (t = e.mentionedUserIds) !== null && t !== void 0 ? t : (l = e.mentionedUsers) === null || l === void 0 ? void 0 : l.map(function(d) {
    return d.userId;
  }), pushNotificationDeliveryOption: pd.DEFAULT, parentMessageId: null, isReplyToChannel: !1, thumbnailSizes: (a = e.thumbnails) === null || a === void 0 ? void 0 : a.map(function(d) {
    return { maxWidth: d.width, maxHeight: d.height };
  }), requireAuth: e.requireAuth, isPinnedMessage: !1, _thumbnails: e.thumbnails }));
}
var Cs, IT = function(e, n) {
  var t;
  return e.messageParams ? (!e.url && Nl(n) && (e.messageParams.file = n), e.messageParams) : je(Ae({ data: e.data, customType: e.customType, mentionType: e.mentionType, mentionedUsers: e.mentionedUsers, mentionedUserIds: e.mentionedUserIds, metaArrays: e.metaArrays, parentMessageId: e.parentMessageId, appleCriticalAlertOptions: e.appleCriticalAlertOptions, file: n, fileUrl: e.url, fileName: e.name, fileSize: e.size, mimeType: e.type, thumbnailSizes: (t = e.thumbnails) === null || t === void 0 ? void 0 : t.map(function(l) {
    return { maxWidth: l.width, maxHeight: l.height };
  }) }));
}, Wu = function(e) {
  return AR(e) && (Nl(e.file) || B("string", e.fileUrl)) && B("string", e.fileName, !0) && B("string", e.mimeType, !0) && B("number", e.fileSize, !0) && (e.thumbnailSizes === null || e.thumbnailSizes === void 0 || Array.isArray(e.thumbnailSizes) && e.thumbnailSizes.every(function(n) {
    return B("object", n) && n.maxWidth > 0 && n.maxHeight > 0;
  }));
}, YW = { data: void 0, customType: void 0, mentionType: Jl.USERS, mentionedUserIds: void 0, mentionedUsers: void 0, mentionedMessageTemplate: void 0, metaArrays: void 0, pushNotificationDeliveryOption: void 0, appleCriticalAlertOptions: void 0 }, QW = function(e) {
  return B("string", e.data, !0) && B("string", e.customType, !0) && Qt(Jl, e.mentionType) && Jt("string", e.mentionedUserIds, !0) && Jt(xt, e.mentionedUsers, !0) && B("string", e.mentionedMessageTemplate, !0) && Jt(Ol, e.metaArrays, !0) && Qt(pd, e.pushNotificationDeliveryOption, !0) && B(ad, e.appleCriticalAlertOptions, !0);
}, M3 = x(x({}, YW), { message: void 0, translationTargetLanguages: void 0, pollId: void 0 }), E3 = function(e) {
  return QW(e) && B("string", e.message, !0) && Jt("string", e.translationTargetLanguages, !0) && B("number", e.pollId, !0);
}, by = x({}, YW), Yy = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.channelType, d = t.token, r = t.limit, i = e.call(this) || this;
    return i.method = he.GET, i.path = "".concat(Lt(a), "/").concat(encodeURIComponent(l), "/operators"), i.params = { token: d, limit: r }, i;
  }
  return J(n, e), n;
}(Te), Qy = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.operators = l.operators.map(function(d) {
      return new xt(t, d);
    }), a.token = l.next, a;
  }
  return J(n, e), n;
}(ue), Jy = function(e) {
  function n(t, l, a, d) {
    return e.call(this, t, l, a, d) || this;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : (t = [], this._hasNext ? (this._isLoading = !0, l = D.of(this._iid).requestQueue, a = new Yy(x(x({}, this), { channelUrl: this.channelUrl, token: this._token })), [4, l.send(a)]) : [3, 2]) : [3, 5];
          case 1:
            return d = V.sent(), r = d.as(Qy), i = r.operators, c = r.token, this._token = c, this._hasNext = !!c, this._isLoading = !1, [2, i];
          case 2:
            return [2, t];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar), vy = function(e) {
  function n(t, l, a, d) {
    var r, i, c, V, s, o, U, N, R, h, Z = this;
    return (Z = e.call(this, t, l, a, d) || this).reverse = !1, Z.messageTypeFilter = bl.ALL, Z.customTypesFilter = null, Z.senderUserIdsFilter = null, Z.replyType = al.NONE, Z.includeMetaArray = !1, Z.includeReactions = !1, Z.includeParentMessageInfo = !1, Z.includeThreadInfo = !1, Z.showSubchannelMessagesOnly = !1, Z._edge = Number.MAX_SAFE_INTEGER, Z.reverse = (r = d.reverse) !== null && r !== void 0 && r, Z.messageTypeFilter = (i = d.messageTypeFilter) !== null && i !== void 0 ? i : bl.ALL, Z.customTypesFilter = (c = d.customTypesFilter) !== null && c !== void 0 ? c : null, Z.senderUserIdsFilter = (V = d.senderUserIdsFilter) !== null && V !== void 0 ? V : null, Z.replyType = (s = d.replyType) !== null && s !== void 0 ? s : al.NONE, Z.includeMetaArray = (o = d.includeMetaArray) !== null && o !== void 0 && o, Z.includeReactions = (U = d.includeReactions) !== null && U !== void 0 && U, Z.includeParentMessageInfo = (N = d.includeParentMessageInfo) !== null && N !== void 0 && N, Z.includeThreadInfo = (R = d.includeThreadInfo) !== null && R !== void 0 && R, Z.showSubchannelMessagesOnly = (h = d.showSubchannelMessagesOnly) !== null && h !== void 0 && h, Z;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && B("boolean", this.reverse) && Qt(bl, this.messageTypeFilter) && Qt(al, this.replyType) && Jt("string", this.customTypesFilter, !0) && Jt("string", this.senderUserIdsFilter, !0) && B("boolean", this.includeMetaArray) && B("boolean", this.includeReactions) && B("boolean", this.includeParentMessageInfo) && B("boolean", this.includeThreadInfo) && B("boolean", this.showSubchannelMessagesOnly);
  }, n.prototype.load = function() {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, [4, tl.of(this._iid).getMessagesByTimestamp(this.channelUrl, this.channelType, this._edge, Ae({ prevResultSize: this.limit, nextResultSize: 0, isInclusive: !1, reverse: this.reverse, messageTypeFilter: this.messageTypeFilter, customTypesFilter: this.customTypesFilter, replyType: this.replyType, senderUserIdsFilter: this.senderUserIdsFilter, includeReactions: this.includeReactions, includeMetaArray: this.includeMetaArray, includeParentMessageInfo: this.includeParentMessageInfo, includeThreadInfo: this.includeThreadInfo, showSubchannelMessagesOnly: this.showSubchannelMessagesOnly }))]) : [3, 2] : [3, 5];
          case 1:
            return t = l.sent(), this._edge = Math.min.apply(Math, ot([Number.MAX_SAFE_INTEGER], et(t.map(function(a) {
              return a.createdAt;
            })), !1)), this._hasNext = t.length >= this.limit, this._isLoading = !1, [2, t];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar), zy = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.limit, i = t.token;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/mute"), l.params = { limit: r, token: i }, l;
  }
  return J(n, e), n;
}(Te), xy = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    a.mutedUsers = [];
    var d = l.next, r = l.muted_list;
    return a.token = d, r && r.length > 0 && (a.mutedUsers = r.map(function(i) {
      return new BV(t, i);
    })), a;
  }
  return J(n, e), n;
}(ue), Gy = function(e) {
  function n(t, l, a, d) {
    return e.call(this, t, l, a, d) || this;
  }
  return J(n, e), n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new zy(x(x({}, this), { token: this._token })), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = c.sent(), d = a.as(xy), r = d.mutedUsers, i = d.token, this._token = i, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar), yy = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.limit, i = t.token;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/ban"), l.params = je({ limit: r, token: i }), l;
  }
  return J(n, e), n;
}(Te), By = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    a.bannedUsers = [];
    var d = l.next, r = l.banned_list;
    return a.token = d, r && r.length > 0 && (a.bannedUsers = r.map(function(i) {
      return new BV(t, i.user);
    })), a;
  }
  return J(n, e), n;
}(ue), Dy = function(e) {
  function n(t, l, a, d) {
    return e.call(this, t, l, a, d) || this;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new yy(x(x({}, this), { token: this._token })), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = c.sent(), d = a.as(By), r = d.bannedUsers, i = d.token, this._token = i, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar);
(function(e) {
  e.SPAM = "spam", e.HARASSING = "harassing", e.SUSPICIOUS = "suspicious", e.INAPPROPRIATE = "inappropriate";
})(Cs || (Cs = {}));
var Xy = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.operatorUserIds;
    return (l = e.call(this) || this).method = he.POST, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/operators"), l.params = { operator_ids: r }, l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var Oy = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.operatorUserIds;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/operators"), l.params = { operator_ids: r }, l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    return e.call(this, t, l) || this;
  }
  J(n, e);
})(ue);
var jy = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.userId;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/mute/").concat(r), l;
  }
  return J(n, e), n;
}(Te), Hy = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    a.isMuted = !1, a.startAt = 0, a.endAt = 0;
    var d = l.is_muted, r = l.start_at, i = l.end_at, c = l.remaining_duration, V = l.description;
    return a.isMuted = d, a.startAt = r, a.endAt = i, a.remainingDuration = c, a.description = V, a;
  }
  return J(n, e), n;
}(ue), mu = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.keys;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metadata"), l.params = { keys: r, include_ts: !0 }, l;
  }
  return J(n, e), n;
}(Te), uu = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this, d = l.metadata, r = l.ts;
    return a.metadata = d, a.ts = r, a;
  }
  return J(n, e), n;
}(ue), fy = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.metadata;
    return (l = e.call(this) || this).method = he.POST, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metadata"), l.params = { metadata: r, include_ts: !0 }, l;
  }
  return J(n, e), n;
}(Te), wy = function(e) {
  function n(t, l) {
    var a, d, r = this;
    return (r = e.call(this, t, l) || this).metaData = (a = l.metadata) !== null && a !== void 0 ? a : {}, r.ts = (d = l.ts) !== null && d !== void 0 ? d : null, r;
  }
  return J(n, e), n;
}(ue), gy = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.metadata, i = t.upsert;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metadata"), l.params = { metadata: r, include_ts: !0, upsert: i != null && i }, l;
  }
  return J(n, e), n;
}(Te), Iy = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this, d = l.metadata, r = l.ts;
    return a.metadata = d, a.ts = r, a;
  }
  return J(n, e), n;
}(ue), S3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return a.data && (d.created = a.data.created, d.updated = a.data.updated, d.deleted = a.data.deleted), d;
  }
  return J(n, e), n;
}(Wn), Ly = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.key;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metadata/").concat(r), l.params = { include_ts: !0 }, l;
  }
  return J(n, e), n;
}(Te), Cy = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this, d = l.ts;
    return a.ts = d, a;
  }
  return J(n, e), n;
}(ue), Ky = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metadata"), l.params = { include_ts: !0 }, l;
  }
  return J(n, e), n;
}(Te), _y = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this, d = l.ts;
    return a.ts = d, a;
  }
  return J(n, e), n;
}(ue), pu = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.keys;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metacounter"), l.params = { keys: r }, l;
  }
  return J(n, e), n;
}(Te), Mu = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.metaCounter = l, a;
  }
  return J(n, e), n;
}(ue), Py = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.metaCounter;
    return (l = e.call(this) || this).method = he.POST, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metacounter"), l.params = { metacounter: r }, l;
  }
  return J(n, e), n;
}(Te), Ay = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.metaCounter = l, a;
  }
  return J(n, e), n;
}(ue), hZ = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.metaCounter, i = t.upsert, c = i !== void 0 && i, V = t.mode, s = V === void 0 ? "set" : V;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metacounter"), l.params = { metacounter: r, upsert: c, mode: s }, l;
  }
  return J(n, e), n;
}(Te), ZZ = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.metaCounter = l, a;
  }
  return J(n, e), n;
}(ue), k3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return a.data && (d.created = a.data.created, d.updated = a.data.updated, d.deleted = a.data.deleted), d;
  }
  return J(n, e), n;
}(Wn), qy = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.key;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metacounter/").concat(r), l.params = {}, l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    return e.call(this, t, l) || this;
  }
  J(n, e);
})(ue);
var $y = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/metacounter"), l.params = {}, l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var e5 = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.userId, i = t.seconds, c = t.description;
    return (l = e.call(this) || this).method = he.POST, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/mute"), l.params = { user_id: r, seconds: i, description: c }, l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    return e.call(this, t, l) || this;
  }
  J(n, e);
})(ue);
var b3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return d.user = new BV(t, a.data), d;
  }
  return J(n, e), n;
}(Wn), t5 = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.userId;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/mute/").concat(encodeURIComponent(r)), l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var Y3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return d.user = new BV(t, a.data), d;
  }
  return J(n, e), n;
}(Wn), n5 = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.userId, i = t.seconds, c = t.description;
    return (l = e.call(this) || this).method = he.POST, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/ban"), l.params = je({ user_id: r, seconds: i, description: c }), l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var Q3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return d.user = new BV(t, a.data), a.data.member_count && (d.memberCount = a.data.member_count), a.data.joined_member_count && (d.joinedMemberCount = a.data.joined_member_count), d;
  }
  return J(n, e), n;
}(Wn), l5 = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.userId;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/ban/").concat(encodeURIComponent(r)), l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var J3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return d.user = new BV(t, a.data), d;
  }
  return J(n, e), n;
}(Wn), Eu = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.freezing;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(Lt(d), "/").concat(encodeURIComponent(a), "/freeze"), l.params = { freeze: r }, l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var v3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return d.freeze = a.data.freeze, d;
  }
  return J(n, e), n;
}(Wn), a5 = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.category, i = t.userId, c = t.description;
    return (l = e.call(this) || this).method = he.POST, l.path = "".concat(Ek(d), "/").concat(encodeURIComponent(a)), l.params = { report_category: r, reporting_user_id: i, report_description: c }, l;
  }
  return J(n, e), n;
}(Te), d5 = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.category, i = t.userId, c = t.offendingUserId, V = t.description;
    return (l = e.call(this) || this).method = he.POST, l.path = "".concat(xT, "/users/").concat(c), l.params = { channel_url: a, channel_type: d === Xt.OPEN ? "open_channels" : "group_channels", report_category: r, reporting_user_id: i, report_description: V }, l;
  }
  return J(n, e), n;
}(Te), r5 = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.channelType, r = t.category, i = t.userId, c = t.offendingUserId, V = t.messageId, s = t.description;
    return (l = e.call(this) || this).method = he.POST, l.path = "".concat(Ek(d), "/").concat(encodeURIComponent(a), "/messages/").concat(V), l.params = { report_category: r, reporting_user_id: i, report_description: s, offending_user_id: c }, l;
  }
  return J(n, e), n;
}(Te), i5 = function(e) {
  function n(t) {
    var l = [];
    return t.mentionType === Jl.USERS && (t.mentionedUserIds ? l = t.mentionedUserIds : t.mentionedUsers && (l = t.mentionedUsers.map(function(a) {
      return a.userId;
    }))), e.call(this, { code: "MESG", ackRequired: !0, payload: je(Ae({ channel_url: t.channelUrl, message: t.message, data: t.data, custom_type: t.customType, metaarray: t.metaArrays, mention_type: t.mentionType, mentioned_user_ids: l, mentioned_message_template: t.mentionedMessageTemplate, target_langs: t.translationTargetLanguages, push_option: t.pushNotificationDeliveryOption && t.pushNotificationDeliveryOption !== pd.DEFAULT ? t.pushNotificationDeliveryOption : void 0, apple_critical_alert_options: t.appleCriticalAlertOptions, silent: t.silent, reply_to_channel: t.isReplyToChannel, parent_message_id: t.parentMessageId ? t.parentMessageId : null, req_id: t.reqId, poll_id: t.pollId, pin_message: t.isPinnedMessage, extended_message_payload: t.extendedMessagePayload })) }) || this;
  }
  return J(n, e), n;
}(Yl), JW = function(e) {
  function n(t, l, a) {
    var d, r, i, c, V = this;
    (V = e.call(this, t, "MESG", a) || this).message = new kl(t, a);
    var s = D.of(t).sdkState;
    return V.isMentioned = Ec(V.message.mentionType, (i = (d = V.message.mentionedUserIds) !== null && d !== void 0 ? d : (r = V.message.mentionedUsers) === null || r === void 0 ? void 0 : r.map(function(o) {
      return o.userId;
    })) !== null && i !== void 0 ? i : [], s.userId), V.forceUpdateLastMessage = (c = a.force_update_last_message) !== null && c !== void 0 && c, V;
  }
  return J(n, e), n;
}(Wn), Su = function(e) {
  function n(t) {
    var l = null;
    return t.mentionType === Jl.USERS && (t.mentionedUserIds ? l = t.mentionedUserIds : t.mentionedUsers && (l = t.mentionedUsers.map(function(a) {
      return a.userId;
    }))), e.call(this, { code: "MEDI", ackRequired: !0, payload: je(Ae({ channel_url: t.channelUrl, msg_id: t.messageId, message: t.message, data: t.data, custom_type: t.customType, metaarray: t.metaArrayParams, mention_type: t.mentionType, mentioned_user_ids: l, mentioned_message_template: t.mentionedMessageTemplate, apple_critical_alert_options: t.appleCriticalAlertOptions ? ad.payloadify(t.appleCriticalAlertOptions) : null, poll_id: t.pollId })) }) || this;
  }
  return J(n, e), n;
}(Yl), rR = function(e) {
  function n(t, l, a) {
    var d, r, i, c, V, s = this;
    (s = e.call(this, t, "MEDI", a) || this).message = new kl(t, a);
    var o = D.of(t).sdkState;
    return s.mentionCountChange = TW({ mentionType: (d = a.old_values) === null || d === void 0 ? void 0 : d.mention_type, mentionedUserIds: (i = (r = a.old_values) === null || r === void 0 ? void 0 : r.mentioned_user_ids) !== null && i !== void 0 ? i : [] }, Ae({ mentionType: s.message.mentionType, mentionedUserIds: (c = s.message.mentionedUserIds) !== null && c !== void 0 ? c : (V = s.message.mentionedUsers) === null || V === void 0 ? void 0 : V.map(function(U) {
      return U.userId;
    }) }), o.userId), s;
  }
  return J(n, e), n;
}(Wn), ku = function(e) {
  function n(t) {
    var l = null;
    return t.mentionType === Jl.USERS && (t.mentionedUserIds ? l = t.mentionedUserIds : t.mentionedUsers && (l = t.mentionedUsers.map(function(a) {
      return a.userId;
    }))), e.call(this, { code: "FEDI", ackRequired: !0, payload: je(Ae({ channel_url: t.channelUrl, msg_id: t.messageId, data: t.data, custom_type: t.customType, metaarray: t.metaArrayParams, mention_type: t.mentionType, mentioned_user_ids: l, apple_critical_alert_options: t.appleCriticalAlertOptions })) }) || this;
  }
  return J(n, e), n;
}(Yl), iR = function(e) {
  function n(t, l, a) {
    var d, r, i, c, V, s = this;
    (s = e.call(this, t, "FEDI", a) || this).message = new Ln(t, a);
    var o = D.of(t).sdkState;
    return s.mentionCountChange = TW({ mentionType: (d = a.old_values) === null || d === void 0 ? void 0 : d.mention_type, mentionedUserIds: (i = (r = a.old_values) === null || r === void 0 ? void 0 : r.mentioned_user_ids) !== null && i !== void 0 ? i : [] }, Ae({ mentionType: s.message.mentionType, mentionedUserIds: (c = s.message.mentionedUserIds) !== null && c !== void 0 ? c : (V = s.message.mentionedUsers) === null || V === void 0 ? void 0 : V.map(function(U) {
      return U.userId;
    }) }), o.userId), s;
  }
  return J(n, e), n;
}(Wn), V5 = function(e) {
  function n(t) {
    var l = e.call(this) || this;
    return l.method = he.DELETE, l.path = "".concat(Lt(t.channelType), "/").concat(t.channelUrl, "/messages/").concat(t.messageId), l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var z3 = function(e) {
  function n(t, l, a) {
    var d, r = this;
    return (r = e.call(this, t, "DELM", a) || this).channelUrl = a.channel_url, r.channelType = a.channel_type, r.messageId = Number(a.msg_id), r.silent = a.silent, r.messageCreatedAt = a.message_created_at ? Number(a.message_created_at) : -1, r.senderId = (d = a.sender_id) !== null && d !== void 0 ? d : void 0, r;
  }
  return J(n, e), n;
}(Wn), c5 = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = t.reactionKey, i = e.call(this) || this;
    return i.method = he.POST, i.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(d, "/reactions"), i.params = { reaction: r }, i;
  }
  return J(n, e), n;
}(Te), s5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.reactionEvent = new kW(l), a;
  }
  return J(n, e), n;
}(ue), o5 = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = t.reactionKey, i = e.call(this) || this;
    return i.method = he.DELETE, i.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(d, "/reactions"), i.params = { reaction: r }, i;
  }
  return J(n, e), n;
}(Te), U5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.reactionEvent = new kW(x({}, l)), a;
  }
  return J(n, e), n;
}(ue), N5 = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = t.translationTargetLanguages, i = e.call(this) || this;
    return i.method = he.POST, i.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(encodeURIComponent(d), "/translation"), i.params = { target_langs: r }, i;
  }
  return J(n, e), n;
}(Te), R5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.message = new kl(t, l), a;
  }
  return J(n, e), n;
}(ue), h5 = function(e) {
  function n(t) {
    var l, a = this;
    a = e.call(this) || this;
    var d = [];
    t.mentionType === Jl.USERS && (t.mentionedUserIds ? d = t.mentionedUserIds : t.mentionedUsers && (d = t.mentionedUsers.map(function(c) {
      return c.userId;
    })));
    var r = t.channelType, i = t.channelUrl;
    return a.method = he.POST, a.path = "".concat(Lt(r), "/").concat(encodeURIComponent(i), "/scheduled_messages"), a.params = je(Ae({ req_id: t.reqId, scheduled_at: t.scheduledAt, message_type: Mc.USER, message: t.message, custom_type: t.customType, data: t.data, mention_type: t.mentionType, mentioned_user_ids: d, sorted_metaarray: (l = t.metaArrays) === null || l === void 0 ? void 0 : l.map(function(c) {
      return Ol.payloadify(c);
    }), apple_critical_alert_options: t.appleCriticalAlertOptions ? ad.payloadify(t.appleCriticalAlertOptions) : null, target_langs: t.translationTargetLanguages, push_option: t.pushNotificationDeliveryOption })), a;
  }
  return J(n, e), n;
}(Te), x3 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.message = new kl(t, l), a;
  }
  return J(n, e), n;
}(ue), Z5 = function(e) {
  function n(t) {
    var l, a, d = this;
    d = e.call(this) || this;
    var r = [];
    t.mentionType === Jl.USERS && (t.mentionedUserIds ? r = t.mentionedUserIds : t.mentionedUsers && (r = t.mentionedUsers.map(function(V) {
      return V.userId;
    })));
    var i = t.channelType, c = t.channelUrl;
    return d.method = he.POST, d.path = "".concat(Lt(i), "/").concat(encodeURIComponent(c), "/scheduled_messages"), d.params = Ae({ req_id: t.reqId, scheduled_at: t.scheduledAt, message_type: Mc.FILE, url: t.fileUrl, file_name: t.fileName, file_size: t.fileSize, file_type: t.mimeType, thumbnails: (l = t._thumbnails) === null || l === void 0 ? void 0 : l.map(function(V) {
      return Br.payloadify(V);
    }), custom_type: t.customType, data: t.data, require_auth: t.requireAuth, mention_type: t.mentionType, mentioned_user_ids: r, sorted_metaarray: (a = t.metaArrays) === null || a === void 0 ? void 0 : a.map(function(V) {
      return Ol.payloadify(V);
    }), apple_critical_alert_options: t.appleCriticalAlertOptions ? ad.payloadify(t.appleCriticalAlertOptions) : null, push_option: t.pushNotificationDeliveryOption }), d;
  }
  return J(n, e), n;
}(Te), T5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.message = new Ln(t, l), a;
  }
  return J(n, e), n;
}(ue), F5 = function(e) {
  function n(t) {
    var l = t.pollId, a = t.title, d = t.data, r = t.allowUserSuggestion, i = t.allowMultipleVotes, c = t.closeAt, V = e.call(this) || this;
    return V.method = he.PUT, V.path = "".concat(kd, "/").concat(encodeURIComponent(l)), V.params = { title: a, data: d, allow_user_suggestion: r, allow_multiple_votes: i, close_at: c }, V;
  }
  return J(n, e), n;
}(Te), W5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.poll = new ld(t, l), a;
  }
  return J(n, e), n;
}(ue), m5 = function(e) {
  function n(t) {
    var l = t.pollId, a = e.call(this) || this;
    return a.method = he.DELETE, a.path = "".concat(kd, "/").concat(encodeURIComponent(l)), a;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var u5 = function(e) {
  function n(t) {
    var l = t.pollId, a = e.call(this) || this;
    return a.method = he.PUT, a.path = "".concat(kd, "/").concat(encodeURIComponent(l), "/close"), a;
  }
  return J(n, e), n;
}(Te), p5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.poll = new ld(t, l), a;
  }
  return J(n, e), n;
}(ue), M5 = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.channelType, d = t.pollId, r = t.optionText, i = e.call(this) || this;
    return i.method = he.POST, i.path = "".concat(kd, "/").concat(encodeURIComponent(d), "/options"), i.params = { channel_url: l, channel_type: a, text: r }, i;
  }
  return J(n, e), n;
}(Te), E5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.poll = new ld(t, l), a;
  }
  return J(n, e), n;
}(ue), S5 = function(e) {
  function n(t) {
    var l = t.pollId, a = t.pollOptionId, d = t.optionText, r = e.call(this) || this;
    return r.method = he.PUT, r.path = "".concat(kd, "/").concat(encodeURIComponent(l), "/options/").concat(encodeURIComponent(a)), r.params = { text: d }, r;
  }
  return J(n, e), n;
}(Te), k5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.poll = new ld(t, l), a;
  }
  return J(n, e), n;
}(ue), b5 = function(e) {
  function n(t) {
    var l = t.pollId, a = t.pollOptionId, d = e.call(this) || this;
    return d.method = he.DELETE, d.path = "".concat(kd, "/").concat(encodeURIComponent(l), "/options/").concat(encodeURIComponent(a)), d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var Y5 = function(e) {
  function n(t) {
    var l = t.reqId, a = t.channelType, d = t.channelUrl, r = t.pollId, i = t.pollOptionIds;
    return e.call(this, { code: "VOTE", ackRequired: !0, payload: je({ req_id: l, channel_type: a === Xt.OPEN ? "open_channels" : "group_channels", channel_url: d, poll_id: r, option_ids: i }) }) || this;
  }
  return J(n, e), n;
}(Yl), vW = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "VOTE", a) || this;
    return d.event = new LG(a), d.channelUrl = a.channel_url, d.channelType = a.channel_type, d;
  }
  return J(n, e), n;
}(Wn), G3 = 100, y3 = "GroupChannel", Q5 = "url", B3 = 100, LT = "Message", J5 = "messageId", D3 = "NotificationMessage", v5 = "notificationId", z5 = "Poll", x5 = "pollId", G5 = "FeedChannel", y5 = "url";
function B5(e) {
  var n, t, l;
  return (n = e.messageParams) !== null && n !== void 0 ? n : Ae(x(x({}, e), { isReplyToChannel: !1, mentionedUserIds: (t = e.mentionedUserIds) !== null && t !== void 0 ? t : (l = e.mentionedUsers) === null || l === void 0 ? void 0 : l.map(function(a) {
    return a.userId;
  }), pushNotificationDeliveryOption: pd.DEFAULT, isPinnedMessage: !1, fileInfoList: e.fileInfoList.map(function(a) {
    var d;
    return { fileUrl: a.plainUrl, fileName: a.fileName, fileSize: a.fileSize, mimeType: a.mimeType, thumbnailSizes: (d = a.thumbnails) === null || d === void 0 ? void 0 : d.map(function(r) {
      return { maxWidth: r.width, maxHeight: r.height };
    }), _thumbnails: a.thumbnails, _uploadedMetaData: { requireAuth: a._requireAuth, isUploaded: !0 } };
  }) }));
}
var pl, D5 = x(x({}, PR), { fileInfoList: [] }), X5 = function(e) {
  return (Nl(e.file) || B("string", e.fileUrl)) && B("string", e.fileName, !0) && B("string", e.mimeType, !0) && B("number", e.fileSize, !0) && (e.thumbnailSizes === void 0 || Array.isArray(e.thumbnailSizes) && e.thumbnailSizes.every(function(n) {
    return n.maxWidth > 0 && n.maxHeight > 0;
  }));
}, SN = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t._onFileUploaded = ut, t;
  }
  return J(n, e), n.prototype._triggerOnFileUploaded = function(t, l, a, d) {
    this._onFileUploaded(t, l, a, d);
  }, n.prototype.onFileUploaded = function(t) {
    return this._onFileUploaded = t, this;
  }, n.prototype.onPending = function(t) {
    return e.prototype.onPending.call(this, t), this;
  }, n.prototype.onFailed = function(t) {
    return e.prototype.onFailed.call(this, t), this;
  }, n.prototype.onSucceeded = function(t) {
    return e.prototype.onSucceeded.call(this, t), this;
  }, n;
}(oa), O5 = 2;
(function(e) {
  e.SEND = "send", e.RESEND = "resend", e.COPY = "copy";
})(pl || (pl = {}));
var Jn, VR = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s = this;
    return (s = e.call(this, t) || this)._name = "", s._createdAt = 0, s.channelType = Xt.BASE, s.coverUrl = "", s.customType = "", s.data = "", s.isFrozen = !1, s.isEphemeral = !1, s.creator = null, s._messageCollectionLastAccessedAt = 0, s._url = l.channel_url, s._name = (a = l.name) !== null && a !== void 0 ? a : "", s._createdAt = 1e3 * l.created_at, s.coverUrl = (d = l.cover_url) !== null && d !== void 0 ? d : "", s.customType = (r = l.custom_type) !== null && r !== void 0 ? r : "", s.data = (i = l.data) !== null && i !== void 0 ? i : "", s.isFrozen = (c = l.freeze) !== null && c !== void 0 && c, s.isEphemeral = (V = l.is_ephemeral) !== null && V !== void 0 && V, s.creator = l.created_by ? new xt(s._iid, l.created_by) : null, l.metadata && Object.keys(l.metadata).length > 0 && l.ts && (s._cachedMetaData = /* @__PURE__ */ new Map(), Object.keys(l.metadata).forEach(function(o) {
      s._cachedMetaData.set(o, { value: l.metadata[o], isRemoved: !1, updatedAt: l.ts });
    })), s;
  }
  return J(n, e), Object.defineProperty(n.prototype, "url", { get: function() {
    return this._url;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "name", { get: function() {
    return this._name;
  }, set: function(t) {
    this._name = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "createdAt", { get: function() {
    return this._createdAt;
  }, enumerable: !1, configurable: !0 }), n.prototype.toJSON = function() {
    return x(x({}, this), { url: this._url, name: this._name, createdAt: this._createdAt });
  }, n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { channel_url: t.url, name: t.name, cover_url: t.coverUrl, custom_type: t.customType, data: t.data, freeze: t.isFrozen, is_ephemeral: t.isEphemeral, created_by: t.creator ? xt.payloadify(t.creator) : null, created_at: t.createdAt / 1e3 })));
  }, n.prototype.isGroupChannel = function() {
    return this.channelType === Xt.GROUP;
  }, n.prototype.isOpenChannel = function() {
    return this.channelType === Xt.OPEN;
  }, n.prototype.isFeedChannel = function() {
    return this.channelType === Xt.FEED;
  }, Object.defineProperty(n.prototype, "cachedMetaData", { get: function() {
    var t = {};
    return this._cachedMetaData && this._cachedMetaData.forEach(function(l, a) {
      l.isRemoved || (t[a] = l.value);
    }), t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "messageCollectionLastAccessedAt", { get: function() {
    return this._messageCollectionLastAccessedAt;
  }, enumerable: !1, configurable: !0 }), n.prototype._updateMessageCollectionLastAccessedAt = function() {
    this._messageCollectionLastAccessedAt = Date.now();
  }, n.prototype._update = function(t) {
    var l = je(t);
    Object.assign(this, l);
  }, n.prototype._upsertCachedMetaData = function(t, l) {
    var a = this;
    Object.keys(t).forEach(function(d) {
      a._cachedMetaData || (a._cachedMetaData = /* @__PURE__ */ new Map());
      var r = a._cachedMetaData.get(d);
      (!r || r.updatedAt <= l) && a._cachedMetaData.set(d, { value: t[d], isRemoved: !1, updatedAt: l });
    });
  }, n.prototype._updateCachedMetaData = function(t, l) {
    var a = this;
    this._cachedMetaData ? this._cachedMetaData.forEach(function(d, r) {
      var i;
      d.updatedAt <= l && a._cachedMetaData.set(r, { value: (i = t[r]) !== null && i !== void 0 ? i : d.value, isRemoved: !t[r], updatedAt: l });
    }) : (this._cachedMetaData = /* @__PURE__ */ new Map(), Object.keys(t).forEach(function(d) {
      a._cachedMetaData.set(d, { value: t[d], isRemoved: !1, updatedAt: l });
    }));
  }, n.prototype._removeFromCachedMetaData = function(t, l) {
    var a = this;
    this._cachedMetaData && t.forEach(function(d) {
      var r = a._cachedMetaData.get(d);
      r && r.updatedAt < l && (r.isRemoved = !0, r.updatedAt = l);
    });
  }, n.prototype._runIfHandleableWithGroupChannel = function(t) {
    this.isGroupChannel() ? t(this) : this.isFeedChannel() && t(this.groupChannel);
  }, n.prototype._generateRequestId = function() {
    return "rq-".concat(vr());
  }, n.prototype.isIdentical = function(t) {
    return t && this.url === t.url;
  }, n.prototype.isEqual = function(t) {
    return Tk(this, t);
  }, n.prototype.createOperatorListQuery = function(t) {
    return t === void 0 && (t = {}), new Jy(this._iid, this.url, this.channelType, t);
  }, n.prototype.createMutedUserListQuery = function(t) {
    return t === void 0 && (t = {}), new Gy(this._iid, this.url, this.channelType, t);
  }, n.prototype.createBannedUserListQuery = function(t) {
    return t === void 0 && (t = {}), new Dy(this._iid, this.url, this.channelType, t);
  }, n.prototype.createPreviousMessageListQuery = function(t) {
    return t === void 0 && (t = {}), new vy(this._iid, this.url, this.channelType, t);
  }, n.prototype.addOperators = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return Ze(Jt("string", t)).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new Xy({ channelUrl: this.url, channelType: this.channelType, operatorUserIds: t }), [4, l.send(a)];
          case 1:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype.removeOperators = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return Ze(Jt("string", t)).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new Oy({ channelUrl: this.url, channelType: this.channelType, operatorUserIds: t }), [4, l.send(a)];
          case 1:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype.getMyMutedInfo = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V, s, o, U;
      return p(this, function(N) {
        switch (N.label) {
          case 0:
            return t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new jy({ channelUrl: this.url, channelType: this.channelType, userId: l.userId }), [4, a.send(d)];
          case 1:
            return r = N.sent(), i = r.as(Hy), c = i.isMuted, V = i.startAt, s = i.endAt, o = i.remainingDuration, U = i.description, [2, { isMuted: c, startAt: V, endAt: s, remainingDuration: o, description: U }];
        }
      });
    });
  }, n.prototype.getMetaData = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return Ze(Jt("string", t)).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new mu({ channelUrl: this.url, channelType: this.channelType, keys: t }), [4, l.send(a)];
          case 1:
            return d = V.sent(), r = d.as(uu), i = r.metadata, c = r.ts, this._upsertCachedMetaData(i, c), [2, i];
        }
      });
    });
  }, n.prototype.getAllMetaData = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new mu({ channelUrl: this.url, channelType: this.channelType, keys: [] }), [4, t.send(l)];
          case 1:
            return a = c.sent(), d = a.as(uu), r = d.metadata, i = d.ts, this._updateCachedMetaData(r, i), [2, r];
        }
      });
    });
  }, n.prototype.createMetaData = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return l = D.of(this._iid).requestQueue, a = new fy({ channelUrl: this.url, channelType: this.channelType, metadata: t }), [4, l.send(a)];
          case 1:
            return d = i.sent(), r = d.as(wy).metaData, this._upsertCachedMetaData(r, 0), [2, r];
        }
      });
    });
  }, n.prototype.updateMetaData = function(t, l) {
    return l === void 0 && (l = !1), M(this, void 0, void 0, function() {
      var a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return a = D.of(this._iid).requestQueue, d = new gy({ channelUrl: this.url, channelType: this.channelType, metadata: t, upsert: l }), [4, a.send(d)];
          case 1:
            return r = s.sent(), i = r.as(Iy), c = i.metadata, V = i.ts, this._upsertCachedMetaData(c, V), [2, c];
        }
      });
    });
  }, n.prototype.deleteMetaData = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(B("string", t)).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new Ly({ channelUrl: this.url, channelType: this.channelType, key: t }), [4, l.send(a)];
          case 1:
            return d = i.sent(), r = d.as(Cy).ts, this._removeFromCachedMetaData([t], r), [2];
        }
      });
    });
  }, n.prototype.deleteAllMetaData = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new Ky({ channelUrl: this.url, channelType: this.channelType }), [4, t.send(l)];
          case 1:
            return a = r.sent(), d = a.as(_y).ts, this._removeFromCachedMetaData(ot([], et(this._cachedMetaData.keys()), !1), d), [2];
        }
      });
    });
  }, n.prototype.getMetaCounters = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return Ze(Jt("string", t)).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new pu({ channelUrl: this.url, channelType: this.channelType, keys: t }), [4, l.send(a)];
          case 1:
            return d = r.sent(), [2, d.as(Mu).metaCounter];
        }
      });
    });
  }, n.prototype.getAllMetaCounters = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new pu({ channelUrl: this.url, channelType: this.channelType, keys: [] }), [4, t.send(l)];
          case 1:
            return a = d.sent(), [2, a.as(Mu).metaCounter];
        }
      });
    });
  }, n.prototype.createMetaCounters = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return l = D.of(this._iid).requestQueue, a = new Py({ channelUrl: this.url, channelType: this.channelType, metaCounter: t }), [4, l.send(a)];
          case 1:
            return d = r.sent(), [2, d.as(Ay).metaCounter];
        }
      });
    });
  }, n.prototype.updateMetaCounters = function(t, l) {
    return l === void 0 && (l = !1), M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return a = D.of(this._iid).requestQueue, d = new hZ({ channelUrl: this.url, channelType: this.channelType, metaCounter: t, upsert: l }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(ZZ).metaCounter];
        }
      });
    });
  }, n.prototype.increaseMetaCounters = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return l = D.of(this._iid).requestQueue, a = new hZ({ channelUrl: this.url, channelType: this.channelType, metaCounter: t, upsert: !1, mode: "increase" }), [4, l.send(a)];
          case 1:
            return d = r.sent(), [2, d.as(ZZ).metaCounter];
        }
      });
    });
  }, n.prototype.decreaseMetaCounters = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return l = D.of(this._iid).requestQueue, a = new hZ({ channelUrl: this.url, channelType: this.channelType, metaCounter: t, upsert: !1, mode: "decrease" }), [4, l.send(a)];
          case 1:
            return d = r.sent(), [2, d.as(ZZ).metaCounter];
        }
      });
    });
  }, n.prototype.deleteMetaCounter = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return Ze(B("string", t)).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new qy({ channelUrl: this.url, channelType: this.channelType, key: t }), [4, l.send(a)];
          case 1:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype.deleteAllMetaCounters = function() {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new $y({ channelUrl: this.url, channelType: this.channelType }), [4, t.send(l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.muteUser = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      return p(this, function(d) {
        return [2, this.muteUserWithUserId(t.userId, l, a)];
      });
    });
  }, n.prototype.muteUserWithUserId = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      var d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(B("string", t) && B("number", l, !0) && B("string", a, !0)).throw(j.invalidParameters), d = D.of(this._iid).requestQueue, r = new e5({ channelUrl: this.url, channelType: this.channelType, userId: t, seconds: l, description: a }), [4, d.send(r)];
          case 1:
            return i.sent(), [2];
        }
      });
    });
  }, n.prototype.unmuteUser = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2, this.unmuteUserWithUserId(t.userId)];
      });
    });
  }, n.prototype.unmuteUserWithUserId = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return Ze(B("string", t)).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new t5({ channelUrl: this.url, channelType: this.channelType, userId: t }), [4, l.send(a)];
          case 1:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype.banUser = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      return p(this, function(d) {
        return [2, this.banUserWithUserId(t.userId, l, a)];
      });
    });
  }, n.prototype.banUserWithUserId = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      var d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(B("string", t) && B("number", l, !0) && B("string", a, !0)).throw(j.invalidParameters), d = D.of(this._iid).requestQueue, r = new n5({ channelUrl: this.url, channelType: this.channelType, userId: t, seconds: l, description: a }), [4, d.send(r)];
          case 1:
            return i.sent(), [2];
        }
      });
    });
  }, n.prototype.unbanUser = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2, this.unbanUserWithUserId(t.userId)];
      });
    });
  }, n.prototype.unbanUserWithUserId = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return Ze(B("string", t)).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new l5({ channelUrl: this.url, channelType: this.channelType, userId: t }), [4, l.send(a)];
          case 1:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype.freeze = function() {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new Eu({ channelUrl: this.url, channelType: this.channelType, freezing: !0 }), [4, t.send(l)];
          case 1:
            return a.sent(), this.isFrozen = !0, [2];
        }
      });
    });
  }, n.prototype.unfreeze = function() {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new Eu({ channelUrl: this.url, channelType: this.channelType, freezing: !1 }), [4, t.send(l)];
          case 1:
            return a.sent(), this.isFrozen = !1, [2];
        }
      });
    });
  }, n.prototype.getMessagesByMessageId = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, Ls), l), Ze(B("number", t) && Nu(a)).throw(j.invalidParameters), [4, tl.of(this._iid).getMessagesByMessageId(this.url, this.channelType, t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype.getMessagesByTimestamp = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, Ls), l), Ze(B("number", t) && Nu(a)).throw(j.invalidParameters), [4, tl.of(this._iid).getMessagesByTimestamp(this.url, this.channelType, t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype.getMessageChangeLogsSinceTimestamp = function(t, l) {
    return l === void 0 && (l = {}), M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, wT), l), Ze(B("number", t) && Ru(a)).throw(j.invalidParameters), [4, tl.of(this._iid).getMessageChangelogs(this.url, this.channelType, t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype.getMessageChangeLogsSinceToken = function(t, l) {
    return l === void 0 && (l = {}), M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, wT), l), Ze(B("string", t) && Ru(a)).throw(j.invalidParameters), [4, tl.of(this._iid).getMessageChangelogs(this.url, this.channelType, t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype._createPendingSendableMessagePayload = function(t, l, a) {
    var d, r = D.of(this._iid).sessionManager;
    return je(Ae({ channel_url: this.url, channel_type: this.channelType, msg_id: 0, parent_message_id: t.parentMessageId, data: t.data, custom_type: t.customType, mention_type: t.mentionType, sorted_metaarray: t.metaArrays ? t.metaArrays.map(function(i) {
      return Ol.payloadify(i);
    }) : null, apple_critical_alert_options: t.appleCriticalAlertOptions ? ad.payloadify(t.appleCriticalAlertOptions) : null, created_at: a, user: r.currentUser ? Yc.payloadify(r.currentUser) : null, req_id: l, request_state: $t.PENDING, mentioned_user_ids: t.mentionedUserIds, mentioned_users: (d = t.mentionedUsers) === null || d === void 0 ? void 0 : d.map(function(i) {
      return xt.payloadify(i);
    }) }));
  }, n.prototype._createPendingUserMessage = function(t, l, a) {
    var d, r, i = {};
    if (t.translationTargetLanguages)
      try {
        for (var c = be(t.translationTargetLanguages), V = c.next(); !V.done; V = c.next())
          i[V.value] = "";
      } catch (U) {
        d = { error: U };
      } finally {
        try {
          V && !V.done && (r = c.return) && r.call(c);
        } finally {
          if (d)
            throw d.error;
        }
      }
    var s = je(x(x({}, this._createPendingSendableMessagePayload(t, l, a)), { type: Gn.USER, message: t.message, translations: i, extended_message_payload: t.extendedMessagePayload })), o = new kl(this._iid, s);
    return o.messageParams = t, o;
  }, n.prototype._createPendingScheduledUserMessage = function(t, l, a) {
    var d = this._createPendingUserMessage(t, l, a);
    return d.scheduledInfo = { scheduledMessageId: 0, scheduledAt: t.scheduledAt, scheduledMessageParams: t }, d;
  }, n.prototype._createPendingFileMessage = function(t, l, a) {
    var d, r, i, c, V, s, o, U = je(x(x({}, this._createPendingSendableMessagePayload(t, l, a)), { type: Gn.FILE, url: t.fileUrl, file: { name: (d = t.fileName) !== null && d !== void 0 ? d : (r = t.file) === null || r === void 0 ? void 0 : r.name, size: (i = t.fileSize) !== null && i !== void 0 ? i : (c = t.file) === null || c === void 0 ? void 0 : c.size, type: (V = t.mimeType) !== null && V !== void 0 ? V : (s = t.file) === null || s === void 0 ? void 0 : s.type, data: t.data }, thumbnails: (o = t._thumbnails) === null || o === void 0 ? void 0 : o.map(function(R) {
      return Br.payloadify(R);
    }) })), N = new Ln(this._iid, U);
    return N.messageParams = t, N;
  }, n.prototype._createPendingMultipleFilesMessage = function(t, l, a) {
    var d = je(x(x({}, this._createPendingSendableMessagePayload(t, l, a)), { type: Gn.FILE })), r = new Da(this._iid, d);
    return r.messageParams = t, r;
  }, n.prototype._validateFailedFileMessageHasFile = function(t, l) {
    var a;
    return !!t.url || Nl(l) || Nl((a = t.messageParams) === null || a === void 0 ? void 0 : a.file);
  }, n.prototype._createPendingScheduledFileMessage = function(t, l, a) {
    var d = this._createPendingFileMessage(t, l, a);
    return d.scheduledInfo = { scheduledMessageId: 0, scheduledAt: t.scheduledAt, scheduledMessageParams: t }, d;
  }, n.prototype._markMessageAsFailed = function(t, l, a) {
    a === void 0 && (a = !1), t.errorCode = l.code, l.code === nt.REQUEST_CANCELED || l.code === nt.FILE_UPLOAD_CANCEL_FAILED ? t.sendingStatus = $t.CANCELED : a || (t.sendingStatus = $t.FAILED);
  }, n.prototype.sendUserMessage = function(t) {
    var l = x(x({}, W3), t);
    return Ze(u3(l)).throw(j.invalidParameters), this._sendUserMessage(l);
  }, n.prototype._sendUserMessage = function(t, l, a) {
    var d = this;
    l === void 0 && (l = pl.SEND);
    var r = D.of(this._iid), i = r.dispatcher, c = r.requestQueue, V = a ?? this._generateRequestId(), s = Date.now(), o = new oa();
    return Qa(2).then(function() {
      var U = d._createPendingUserMessage(t, V, s);
      i.dispatch(new En({ messages: [U], source: l === pl.RESEND ? ne.LOCAL_MESSAGE_RESEND_STARTED : ne.EVENT_MESSAGE_SENT_PENDING })), Ce(function() {
        return M(d, void 0, void 0, function() {
          return p(this, function(R) {
            return [2, o._trigger(U)];
          });
        });
      });
      var N = new i5(x(x({}, t), { channelUrl: d.url, channelType: d.channelType, reqId: V }));
      c.send(N).then(function(R) {
        var h = R.as(JW).message;
        i.dispatch(new En({ messages: [h], source: ne.EVENT_MESSAGE_SENT_SUCCESS })), Ce(function() {
          return M(d, void 0, void 0, function() {
            return p(this, function(Z) {
              return [2, o._trigger(h)];
            });
          });
        });
      }).catch(function(R) {
        if (Il(R))
          throw R;
        Qa(2).then(function() {
          var h = d._createPendingUserMessage(t, V, s), Z = D.of(d._iid).cacheContext, W = Z.localCacheEnabled && Z.localCacheConfig.enableAutoResend && CN(R.code);
          d._markMessageAsFailed(h, R, W), i.dispatch(new En({ messages: [h], source: h.sendingStatus === $t.PENDING ? ne.REQUEST_RESEND_MESSAGE : ne.EVENT_MESSAGE_SENT_FAILED })), Ce(function() {
            return M(d, void 0, void 0, function() {
              return p(this, function(F) {
                return [2, o._triggerFailed(R, h)];
              });
            });
          });
        });
      });
    }), o;
  }, n.prototype._autoResendUserMessage = function(t) {
    return Ze(t instanceof kl && !!t.messageParams).throw(j.invalidParameters), this._sendUserMessage(t.messageParams, pl.SEND, t.reqId);
  }, n.prototype.resendUserMessage = function(t) {
    var l;
    return M(this, void 0, void 0, function() {
      var a, d;
      return p(this, function(r) {
        return Ze(t instanceof kl && !t.scheduledInfo).throw(j.invalidParameters), a = new Ll(), d = (l = t.messageParams) !== null && l !== void 0 ? l : gT(t), this._sendUserMessage(d, pl.RESEND, t.reqId).onFailed(function(i) {
          return a.reject(i);
        }).onSucceeded(function(i) {
          return a.resolve(i);
        }), [2, a.promise];
      });
    });
  }, n.prototype.updateUserMessage = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return a = x(x({}, M3), l), Ze(B("number", t) && E3(a)).throw(j.invalidParameters), d = D.of(this._iid).requestQueue, r = new Su(x({ channelType: this.channelType, channelUrl: this.url, messageId: t, metaArrayParams: a.metaArrays ? { array: a.metaArrays, mode: "add", upsert: !0 } : void 0 }, a)), [4, d.send(r)];
          case 1:
            return i = c.sent(), [2, i.as(rR).message];
        }
      });
    });
  }, n.prototype.copyUserMessage = function(t, l) {
    var a, d, r;
    return M(this, void 0, void 0, function() {
      var i, c;
      return p(this, function(V) {
        return Ze(t instanceof n && l instanceof kl && l.sendingStatus === $t.SUCCEEDED && this.url === l.channelUrl && !l.scheduledInfo).throw(j.invalidParameters), Ze(!l.poll).throw(j.notSupportedError), i = new Ll(), c = (a = l.messageParams) !== null && a !== void 0 ? a : Ae(x(x({}, l), { mentionType: l.mentionType, mentionedUserIds: (d = l.mentionedUserIds) !== null && d !== void 0 ? d : (r = l.mentionedUsers) === null || r === void 0 ? void 0 : r.map(function(s) {
          return s.userId;
        }), translationTargetLanguages: Object.keys(l.translations), pushNotificationDeliveryOption: pd.DEFAULT, parentMessageId: null, isReplyToChannel: !1, isPinnedMessage: !1 })), t._sendUserMessage(c).onSucceeded(function(s) {
          i.resolve(s);
        }).onFailed(function(s) {
          return i.reject(s);
        }), [2, i.promise];
      });
    });
  }, n.prototype.translateUserMessage = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(t instanceof kl && t.messageId > 0 && Jt("string", l)).throw(j.invalidParameters), a = D.of(this._iid).requestQueue, d = new N5({ channelType: this.channelType, channelUrl: this.url, messageId: t.messageId, translationTargetLanguages: l }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(R5).message];
        }
      });
    });
  }, n.prototype._createScheduledUserMessage = function(t, l) {
    var a = this, d = D.of(this._iid).requestQueue, r = Date.now(), i = this._generateRequestId();
    Qa(2).then(function() {
      var V = a._createPendingScheduledUserMessage(t, i, r);
      Ce(function() {
        return M(a, void 0, void 0, function() {
          return p(this, function(s) {
            return [2, l._trigger(V)];
          });
        });
      });
    });
    var c = new h5(x({ reqId: i, channelType: this.channelType, channelUrl: this.url }, t));
    d.send(c).then(function(V) {
      var s = V.as(x3).message;
      Ce(function() {
        return M(a, void 0, void 0, function() {
          return p(this, function(o) {
            return [2, l._trigger(s)];
          });
        });
      });
    }).catch(function(V) {
      if (Il(V))
        throw V;
      Qa(2).then(function() {
        var s = a._createPendingScheduledUserMessage(t, i, r);
        a._markMessageAsFailed(s, V), Ce(function() {
          return M(a, void 0, void 0, function() {
            return p(this, function(o) {
              return [2, l._triggerFailed(V, s)];
            });
          });
        });
      });
    });
  }, n.prototype.sendFileMessage = function(t) {
    var l = x(x({}, Fu), t);
    return Ze(Wu(l)).throw(j.invalidParameters), this._sendFileMessage(l);
  }, n.prototype.sendMultipleFilesMessage = function(t) {
    var l, a = x(x({}, D5), t), d = D.of(this._iid);
    Ze(function(i, c) {
      return c === void 0 && (c = YG), AR(i) && Array.isArray(i.fileInfoList) && i.fileInfoList.length >= 2 && i.fileInfoList.length <= c && i.fileInfoList.every(function(V) {
        return X5(V);
      });
    }(a, (l = d.appInfo) === null || l === void 0 ? void 0 : l.multipleFilesMessageFileCountLimit)).throw(j.invalidParameters);
    var r = !!t.fileInfoList.find(function(i) {
      var c = d.appInfo.uploadSizeLimit;
      return i.file instanceof Blob && i.file.size > c || i.fileSize > c;
    });
    return Ze(!r).throw(j.fileSizeLimitExceededError), this._sendMultipleFilesMessage(a);
  }, n.prototype._sendFileMessage = function(t, l, a) {
    var d = this;
    l === void 0 && (l = pl.SEND);
    var r = D.of(this._iid).dispatcher, i = tl.of(this._iid).fileMessageQueue, c = a ?? this._generateRequestId(), V = Date.now(), s = new oa();
    return Qa(2).then(function() {
      var o = d._createPendingFileMessage(t, c, V);
      r.dispatch(new En({ messages: [o], source: l === pl.RESEND ? ne.LOCAL_MESSAGE_RESEND_STARTED : ne.EVENT_MESSAGE_SENT_PENDING })), Ce(function() {
        return M(d, void 0, void 0, function() {
          return p(this, function(U) {
            return [2, s._trigger(o)];
          });
        });
      }), i.request(d, c, t).then(function(U) {
        r.dispatch(new En({ messages: [U], source: ne.EVENT_MESSAGE_SENT_SUCCESS })), Ce(function() {
          return M(d, void 0, void 0, function() {
            return p(this, function(N) {
              return [2, s._trigger(U)];
            });
          });
        });
      }).catch(function(U) {
        if (Il(U))
          throw U;
        Qa(2).then(function() {
          var N = d._createPendingFileMessage(t, c, V), R = D.of(d._iid).cacheContext, h = R.localCacheEnabled && R.localCacheConfig.enableAutoResend && CN(U.code);
          d._markMessageAsFailed(N, U, h), r.dispatch(new En({ messages: [N], source: N.sendingStatus === $t.PENDING ? ne.REQUEST_RESEND_MESSAGE : U.code === nt.FILE_UPLOAD_CANCEL_FAILED ? ne.LOCAL_MESSAGE_CANCELED : ne.EVENT_MESSAGE_SENT_FAILED })), Ce(function() {
            return M(d, void 0, void 0, function() {
              return p(this, function(Z) {
                return [2, s._triggerFailed(U, N)];
              });
            });
          });
        });
      });
    }), s;
  }, n.prototype._autoResendFileMessage = function(t) {
    Ze(t instanceof Ln && !!t.messageParams).throw(j.invalidParameters);
    var l = D.of(this._iid).logger;
    return l.debug("autoResendFileMessage pending", t), this._sendFileMessage(t.messageParams, pl.SEND, t.reqId).onFailed(function(a) {
      l.debug("autoResendFileMessage failed", a);
    }).onSucceeded(function(a) {
      l.debug("autoResendFileMessage success", a);
    });
  }, n.prototype._sendMultipleFilesMessage = function(t, l, a) {
    var d = this, r = D.of(this._iid).dispatcher, i = tl.of(this._iid).fileMessageQueue, c = a ?? this._generateRequestId(), V = Date.now(), s = new SN();
    return Qa(2).then(function() {
      var o = d._createPendingMultipleFilesMessage(t, c, V);
      r.dispatch(new En({ messages: [o], source: l === pl.RESEND ? ne.LOCAL_MESSAGE_RESEND_STARTED : ne.EVENT_MESSAGE_SENT_PENDING })), Ce(function() {
        return M(d, void 0, void 0, function() {
          return p(this, function(U) {
            return [2, s._trigger(o)];
          });
        });
      }), i.request(d, c, t, { requestHandler: s, isCopy: l === pl.COPY }).then(function(U) {
        r.dispatch(new En({ messages: [U], source: ne.EVENT_MESSAGE_SENT_SUCCESS })), Ce(function() {
          return M(d, void 0, void 0, function() {
            return p(this, function(N) {
              return [2, s._trigger(U)];
            });
          });
        });
      }).catch(function(U) {
        if (Il(U))
          throw U;
        Qa(2).then(function() {
          var N = d._createPendingMultipleFilesMessage(t, c, V);
          d._markMessageAsFailed(N, U), r.dispatch(new En({ messages: [N], source: ne.EVENT_MESSAGE_SENT_FAILED })), Ce(function() {
            return M(d, void 0, void 0, function() {
              return p(this, function(R) {
                return [2, s._triggerFailed(U, N)];
              });
            });
          });
        });
      });
    }), s;
  }, n.prototype._createScheduledFileMessage = function(t, l, a, d) {
    var r = this, i = D.of(this._iid).requestQueue, c = new Z5(x(x({ reqId: a, channelType: this.channelType, channelUrl: this.url }, t), { fileUrl: t.fileUrl, requireAuth: t.requireAuth }));
    i.send(c).then(function(V) {
      var s = V.as(T5).message;
      Ce(function() {
        return M(r, void 0, void 0, function() {
          return p(this, function(o) {
            return [2, l._trigger(s)];
          });
        });
      });
    }).catch(function(V) {
      if (Il(V))
        throw V;
      Qa(2).then(function() {
        var s = r._createPendingScheduledFileMessage(t, a, d);
        r._markMessageAsFailed(s, V), Ce(function() {
          return M(r, void 0, void 0, function() {
            return p(this, function(o) {
              return [2, l._triggerFailed(V, s)];
            });
          });
        });
      });
    });
  }, n.prototype.sendFileMessages = function(t) {
    var l, a;
    Ze(t.every(function(V) {
      return Wu(x(x({}, Fu), V));
    })).throw(j.invalidParameters);
    var d = new oa();
    try {
      for (var r = be(t), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        this.sendFileMessage(c).onPending(function(V) {
          return d._trigger(V);
        }).onFailed(function(V, s) {
          return d._triggerFailed(V, s);
        }).onSucceeded(function(V) {
          return d._trigger(V);
        });
      }
    } catch (V) {
      l = { error: V };
    } finally {
      try {
        i && !i.done && (a = r.return) && a.call(r);
      } finally {
        if (l)
          throw l.error;
      }
    }
    return d;
  }, n.prototype.resendFileMessage = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        return a = this._validateFailedFileMessageHasFile(t, l), Ze(t instanceof Ln && a && !t.scheduledInfo).throw(j.invalidParameters), d = new Ll(), r = IT(t, l), this._sendFileMessage(r, pl.RESEND, t.reqId).onFailed(function(c) {
          return d.reject(c);
        }).onSucceeded(function(c) {
          return d.resolve(c);
        }), [2, d.promise];
      });
    });
  }, n.prototype.resendMessage = function(t, l) {
    var a, d;
    if (Ze(t instanceof wn && !t.scheduledInfo && t.isResendable).throw(j.invalidParameters), t.isUserMessage()) {
      var r = (a = t.messageParams) !== null && a !== void 0 ? a : gT(t);
      return this._sendUserMessage(r, pl.RESEND, t.reqId);
    }
    if (t.isFileMessage()) {
      var i = this._validateFailedFileMessageHasFile(t, l);
      return Ze(i).throw(j.invalidParameters), r = (d = t.messageParams) !== null && d !== void 0 ? d : IT(t, l), this._sendFileMessage(r, pl.RESEND, t.reqId);
    }
    if (t.isMultipleFilesMessage())
      throw j.channelTypeNotSupportedError;
  }, n.prototype.updateFileMessage = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return a = x(x({}, by), l), Ze(B("number", t) && function(V) {
              return QW(V);
            }(a)).throw(j.invalidParameters), d = D.of(this._iid).requestQueue, r = new ku(x({ channelType: this.channelType, channelUrl: this.url, messageId: t, metaArrayParams: a.metaArrays ? { array: a.metaArrays, mode: "add", upsert: !0 } : void 0 }, a)), [4, d.send(r)];
          case 1:
            return i = c.sent(), [2, i.as(iR).message];
        }
      });
    });
  }, n.prototype.uploadFile = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return l = D.of(this._iid).requestQueue, a = vr(), (d = new nR({ file: t.file, channelUrl: this.url, thumbnailSizes: t.thumbnailSizes, requestId: a })).uploadProgressHandler = t.progressHandler, t.uploadStartedHandler && t.uploadStartedHandler(a), [4, l.send(d)];
          case 1:
            return r = s.sent(), i = r.as(lR), c = i.url, V = i.thumbnails, [2, { requestId: a, url: c, thumbnails: V }];
        }
      });
    });
  }, n.prototype.cancelUploadingFileMessage = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return Ze(B("string", t)).throw(j.invalidParameters), tl.of(this._iid).fileMessageQueue.cancel(this, t), [2, !0];
      });
    });
  }, n.prototype.copyFileMessage = function(t, l) {
    var a, d, r;
    return M(this, void 0, void 0, function() {
      var i, c;
      return p(this, function(V) {
        return Ze(t instanceof n && l instanceof Ln && l.sendingStatus === $t.SUCCEEDED && this.url === l.channelUrl && !l.scheduledInfo).throw(j.invalidParameters), i = new Ll(), c = Ae(x(x({}, l), { fileUrl: l.url, fileName: l.name, fileSize: l.size, mimeType: l.type, mentionType: l.mentionType, mentionedUserIds: (a = l.mentionedUserIds) !== null && a !== void 0 ? a : (d = l.mentionedUsers) === null || d === void 0 ? void 0 : d.map(function(s) {
          return s.userId;
        }), pushNotificationDeliveryOption: pd.DEFAULT, parentMessageId: null, isReplyToChannel: !1, thumbnailSizes: (r = l.thumbnails) === null || r === void 0 ? void 0 : r.map(function(s) {
          return { maxWidth: s.width, maxHeight: s.height };
        }), requireAuth: l.requireAuth, isPinnedMessage: !1 })), t._sendFileMessage(c).onSucceeded(function(s) {
          return i.resolve(s);
        }).onFailed(function(s) {
          return i.reject(s);
        }), [2, i.promise];
      });
    });
  }, n.prototype.copyMessage = function(t, l) {
    Ze(t instanceof n && l instanceof wn && l.sendingStatus === $t.SUCCEEDED && this.url === l.channelUrl && !l.scheduledInfo).throw(j.invalidParameters);
    var a = l, d = t;
    if (a.isUserMessage()) {
      Ze(!a.poll).throw(j.notSupportedError);
      var r = m3(a);
      return d._sendUserMessage(r);
    }
    if (a.isFileMessage())
      return r = p3(a), d._sendFileMessage(r);
    if (l.isMultipleFilesMessage())
      throw j.channelTypeNotSupportedError;
  }, n.prototype.deleteMessage = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return Ze(t instanceof Bl).throw(j.invalidParameters), t.messageId > 0 ? (l = D.of(this._iid).requestQueue, a = new V5({ channelType: this.channelType, channelUrl: this.url, messageId: t.messageId }), [4, l.send(a)]) : [3, 2];
          case 1:
            d.sent(), d.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.addReaction = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(t instanceof Bl && t.messageId > 0 && B("string", l)).throw(j.invalidParameters), a = D.of(this._iid).requestQueue, d = new c5({ channelType: this.channelType, channelUrl: this.url, messageId: t.messageId, reactionKey: l }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(s5).reactionEvent];
        }
      });
    });
  }, n.prototype.deleteReaction = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(t instanceof Bl && t.messageId > 0 && B("string", l)).throw(j.invalidParameters), a = D.of(this._iid).requestQueue, d = new o5({ channelType: this.channelType, channelUrl: this.url, messageId: t.messageId, reactionKey: l }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(U5).reactionEvent];
        }
      });
    });
  }, n.prototype._updateUserMessageMetaArray = function(t, l, a, d) {
    return M(this, void 0, void 0, function() {
      var r, i, c, V, s, o;
      return p(this, function(U) {
        switch (U.label) {
          case 0:
            return r = D.of(this._iid), i = r.dispatcher, c = r.requestQueue, V = new Su({ channelType: this.channelType, channelUrl: this.url, messageId: t, metaArrayParams: { array: l, mode: a, upsert: d } }), [4, c.send(V)];
          case 1:
            return s = U.sent(), o = s.as(rR).message, i.dispatch(new En({ messages: [o], source: ne.EVENT_MESSAGE_UPDATED })), [2, o];
        }
      });
    });
  }, n.prototype._updateFileMessageMetaArray = function(t, l, a, d) {
    return M(this, void 0, void 0, function() {
      var r, i, c, V, s, o;
      return p(this, function(U) {
        switch (U.label) {
          case 0:
            return r = D.of(this._iid), i = r.dispatcher, c = r.requestQueue, V = new ku({ channelType: this.channelType, channelUrl: this.url, messageId: t, metaArrayParams: { array: l, mode: a, upsert: d } }), [4, c.send(V)];
          case 1:
            return s = U.sent(), o = s.as(iR).message, i.dispatch(new En({ messages: [o], source: ne.EVENT_MESSAGE_UPDATED })), [2, o];
        }
      });
    });
  }, n.prototype.createMessageMetaArrayKeys = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        return Ze(t instanceof Bl && t.messageId > 0 && Jt("string", l)).throw(j.invalidParameters), a = l.map(function(r) {
          return new Ol({ key: r });
        }), t instanceof Ln ? [2, this._updateFileMessageMetaArray(t.messageId, a, "add", !0)] : [2, this._updateUserMessageMetaArray(t.messageId, a, "add", !0)];
      });
    });
  }, n.prototype.deleteMessageMetaArrayKeys = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        return Ze(t instanceof Bl && t.messageId > 0 && Jt("string", l)).throw(j.invalidParameters), a = l.map(function(r) {
          return new Ol({ key: r });
        }), t instanceof Ln ? [2, this._updateFileMessageMetaArray(t.messageId, a, "remove", !0)] : [2, this._updateUserMessageMetaArray(t.messageId, a, "remove", !0)];
      });
    });
  }, n.prototype.addMessageMetaArrayValues = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        return Ze(t instanceof Bl && t.messageId > 0 && l.every(function(d) {
          return d instanceof Ol;
        })).throw(j.invalidParameters), t instanceof Ln ? [2, this._updateFileMessageMetaArray(t.messageId, l, "add", !0)] : [2, this._updateUserMessageMetaArray(t.messageId, l, "add", !0)];
      });
    });
  }, n.prototype.removeMessageMetaArrayValues = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        return Ze(t instanceof Bl && t.messageId > 0 && l.every(function(d) {
          return d instanceof Ol;
        })).throw(j.invalidParameters), t instanceof Ln ? [2, this._updateFileMessageMetaArray(t.messageId, l, "remove", !0)] : [2, this._updateUserMessageMetaArray(t.messageId, l, "remove", !0)];
      });
    });
  }, n.prototype.report = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return Ze(Qt(Cs, t) && B("string", l)).throw(j.invalidParameters), a = D.of(this._iid), d = a.sdkState, r = a.requestQueue, i = new a5({ channelUrl: this.url, channelType: this.channelType, userId: d.userId, category: t, description: l }), [4, r.send(i)];
          case 1:
            return c.sent(), [2];
        }
      });
    });
  }, n.prototype.reportUser = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      var d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return Ze(t instanceof xt && Qt(Cs, l) && B("string", a)).throw(j.invalidParameters), d = D.of(this._iid), r = d.sdkState, i = d.requestQueue, c = new d5({ channelUrl: this.url, channelType: this.channelType, userId: r.userId, offendingUserId: t.userId, category: l, description: a }), [4, i.send(c)];
          case 1:
            return V.sent(), [2];
        }
      });
    });
  }, n.prototype.reportMessage = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      var d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return Ze(t instanceof wn && Qt(Cs, l) && B("string", a)).throw(j.invalidParameters), d = D.of(this._iid), r = d.sdkState, i = d.requestQueue, c = new r5({ channelUrl: this.url, channelType: this.channelType, userId: r.userId, offendingUserId: t.sender.userId, messageId: t.messageId, category: l, description: a }), [4, i.send(c)];
          case 1:
            return V.sent(), [2];
        }
      });
    });
  }, n.prototype.updatePoll = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(B("number", t) && function(c) {
              return B("string", c.title, !0) && r3(c.data) && B("boolean", c.allowUserSuggestion, !0) && B("boolean", c.allowMultipleVotes, !0) && B("number", c.closeAt, !0);
            }(l)).throw(j.invalidParameters), a = D.of(this._iid).requestQueue, d = new F5(x({ pollId: t }, l)), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(W5).poll];
        }
      });
    });
  }, n.prototype.deletePoll = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return l = B("number", t), Ze(l).throw(j.invalidParameters), a = D.of(this._iid).requestQueue, d = new m5({ pollId: t }), [4, a.send(d)];
          case 1:
            return r.sent(), [2];
        }
      });
    });
  }, n.prototype.closePoll = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return l = B("number", t), Ze(l).throw(j.invalidParameters), a = D.of(this._iid).requestQueue, d = new u5({ pollId: t }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(p5).poll];
        }
      });
    });
  }, n.prototype.addPollOption = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return a = B("number", t) && B("string", l) && l.trim() !== "", Ze(a).throw(j.invalidParameters), d = D.of(this._iid).requestQueue, r = new M5({ channelUrl: this.url, channelType: this.channelType, pollId: t, optionText: l }), [4, d.send(r)];
          case 1:
            return i = c.sent(), [2, i.as(E5).poll];
        }
      });
    });
  }, n.prototype.updatePollOption = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      var d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return d = B("number", t) && B("number", l) && B("string", a) && a.trim() !== "", Ze(d).throw(j.invalidParameters), r = D.of(this._iid).requestQueue, i = new S5({ pollId: t, pollOptionId: l, optionText: a }), [4, r.send(i)];
          case 1:
            return c = V.sent(), [2, c.as(k5).poll];
        }
      });
    });
  }, n.prototype.deletePollOption = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return a = B("number", t) && B("number", l), Ze(a).throw(j.invalidParameters), d = D.of(this._iid).requestQueue, r = new b5({ pollId: t, pollOptionId: l }), [4, d.send(r)];
          case 1:
            return i.sent(), [2];
        }
      });
    });
  }, n.prototype.votePoll = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i, c, V, s;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            return a = B("number", t) && Jt("number", l), Ze(a).throw(j.invalidParameters), d = D.of(this._iid), r = d.requestQueue, i = d.dispatcher, c = new Y5({ reqId: this._generateRequestId(), channelUrl: this.url, channelType: this.channelType, pollId: t, pollOptionIds: l }), [4, r.send(c)];
          case 1:
            return V = o.sent(), s = V.as(vW).event, i.dispatch(new KR({ event: s, source: ne.EVENT_POLL_VOTED })), [2, s];
        }
      });
    });
  }, n.prototype.getPollChangeLogsSinceTimestamp = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return Ze(B("number", t)).throw(j.invalidParameters), [4, tR.of(this._iid).getPollChangeLogs(this.url, this.channelType, t)];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, n.prototype.getPollChangeLogsSinceToken = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return Ze(B("string", t, !0)), [4, tR.of(this._iid).getPollChangeLogs(this.url, this.channelType, t)];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, n.prototype.createPollListQuery = function(t) {
    return t === void 0 && (t = 10), new s3(this._iid, { channelUrl: this.url, channelType: this.channelType, limit: t });
  }, n.prototype.createPollVoterListQuery = function(t, l, a) {
    return a === void 0 && (a = 20), new o3(this._iid, { channelUrl: this.url, channelType: this.channelType, pollId: t, pollOptionId: l, limit: a });
  }, n;
}(ml), X3 = function(e) {
  function n(t) {
    t === void 0 && (t = {});
    var l = e.call(this) || this;
    return Object.keys(t).forEach(function(a) {
      l.hasOwnProperty(a) && (l[a] = t[a]);
    }), l;
  }
  return J(n, e), n;
}(function() {
  this.onConnected = ut, this.onReconnectStarted = ut, this.onReconnectSucceeded = ut, this.onReconnectFailed = ut, this.onDisconnected = ut;
}), j5 = function(e) {
  function n(t) {
    t === void 0 && (t = {});
    var l = e.call(this) || this;
    return Object.keys(t).forEach(function(a) {
      l.hasOwnProperty(a) && (l[a] = t[a]);
    }), l;
  }
  return J(n, e), n;
}(function() {
  this.onSessionExpired = ut, this.onSessionTokenRequired = function(e) {
    return e(null);
  }, this.onSessionError = ut, this.onSessionRefreshed = ut, this.onSessionClosed = ut;
}), H5 = function(e) {
  function n(t) {
    t === void 0 && (t = {});
    var l = e.call(this) || this;
    return Object.keys(t).forEach(function(a) {
      l.hasOwnProperty(a) && (l[a] = t[a]);
    }), l;
  }
  return J(n, e), n;
}(function() {
  this.onFriendsDiscovered = ut, this.onTotalUnreadMessageCountChanged = ut, this.onTotalUnreadMessageCountUpdated = ut;
}), f5 = function(e) {
  function n(t) {
    var l = t.limit, a = t.token, d = t.userIdsFilter, r = t.metaDataKeyFilter, i = t.metaDataValuesFilter, c = t.nicknameStartsWithFilter, V = e.call(this) || this;
    return V.method = he.GET, V.path = It, V.params = je({ limit: l, token: a, user_ids: d, metadatakey: r, metadatavalues_in: i, nickname_startswith: c }), V;
  }
  return J(n, e), n;
}(Te), w5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.users = l.users.map(function(d) {
      return new xt(t, d);
    }), a.next = l.next, a;
  }
  return J(n, e), n;
}(ue), g5 = function(e) {
  function n(t, l) {
    var a, d, r, i = this;
    return (i = e.call(this, t, l) || this).userIdsFilter = null, i.metaDataKeyFilter = null, i.metaDataValuesFilter = null, i.nicknameStartsWithFilter = null, i.userIdsFilter = (a = l.userIdsFilter) !== null && a !== void 0 ? a : null, i.metaDataKeyFilter = (d = l.metaDataKeyFilter) !== null && d !== void 0 ? d : null, i.metaDataValuesFilter = (r = l.metaDataValuesFilter) !== null && r !== void 0 ? r : null, i.nicknameStartsWithFilter = l.nicknameStartsWithFilter || null, i;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && Jt("string", this.userIdsFilter, !0) && B("string", this.metaDataKeyFilter, !0) && Jt("string", this.metaDataValuesFilter, !0) && B("string", this.nicknameStartsWithFilter, !0);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new f5(Ae(x(x({}, this), { token: this._token }))), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = c.sent(), d = a.as(w5), r = d.users, i = d.next, this._token = i, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(yr), I5 = function(e) {
  function n(t) {
    var l = t.userId, a = t.limit, d = t.token, r = t.userIdsFilter, i = e.call(this) || this;
    return i.method = he.GET, i.path = "".concat(It, "/").concat(l, "/block"), i.params = je({ limit: a, token: d, user_ids: r }), i;
  }
  return J(n, e), n;
}(Te), L5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.users = l.users.map(function(d) {
      return new xt(t, d);
    }), a.next = l.next, a;
  }
  return J(n, e), n;
}(ue), C5 = function(e) {
  function n(t, l) {
    var a, d = this;
    return (d = e.call(this, t, l) || this).userIdsFilter = null, d.userIdsFilter = (a = l.userIdsFilter) !== null && a !== void 0 ? a : null, d;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && Jt("string", this.userIdsFilter, !0);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new I5(Ae(x(x({}, this), { userId: l.userId, token: this._token }))), [4, a.send(d)]) : [3, 2] : [3, 5];
          case 1:
            return r = s.sent(), i = r.as(L5), c = i.users, V = i.next, this._token = V, this._hasNext = !!V, this._isLoading = !1, [2, c];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(yr), K5 = function(e) {
  function n(t) {
    var l = t.userId, a = t.limit, d = t.token, r = e.call(this) || this;
    return r.method = he.GET, r.path = "".concat(It, "/").concat(encodeURIComponent(l), "/friends"), r.params = { limit: a, token: d }, r;
  }
  return J(n, e), n;
}(Te), _5 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.hasMore = l.has_more, a.users = l.users.map(function(d) {
      return new xt(t, d);
    }), a.next = l.next, a;
  }
  return J(n, e), n;
}(ue), P5 = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V, s;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new K5(x(x({}, this), { userId: l.userId, token: this._token })), [4, a.send(d)]) : [3, 2] : [3, 5];
          case 1:
            return r = o.sent(), i = r.as(_5), c = i.users, V = i.hasMore, s = i.next, this._token = s, this._hasNext = V, this._isLoading = !1, [2, c];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(yr), LU = {}, nU = function() {
  function e(n) {
    var t = n.dbname, l = n.itemSizeLimit, a = l === void 0 ? 1048576 : l, d = n.cacheLimit, r = d === void 0 ? 256 : d, i = n.blockHashBase, c = i === void 0 ? 2 : i, V = n.blockHashMultiplier, s = V === void 0 ? 10 : V, o = n.blockHashConstant, U = o === void 0 ? 11 : o, N = n.transactionApplyDelay, R = N === void 0 ? 200 : N, h = n.disableLogger, Z = h !== void 0 && h;
    return LU[t] || (this.itemSizeLimit = a, this.cacheLimit = r, this.blockHashBase = c, this.blockHashMultiplier = s, this.blockHashConstant = U, this.transactionApplyDelay = R, this.disableLogger = Z, LU[t] = this), LU[t];
  }
  return e.get = function(n) {
    return LU[n];
  }, e;
}();
(function(e) {
  e[e.UNKNOWN_ERROR = 6e7] = "UNKNOWN_ERROR", e[e.STORE_NOT_DEFINED = 61001e3] = "STORE_NOT_DEFINED", e[e.STORE_NOT_AVAILABLE = 61001001] = "STORE_NOT_AVAILABLE", e[e.STORE_NOT_AVAILABLE_IN_PRIVATE_BROWSING = 61001002] = "STORE_NOT_AVAILABLE_IN_PRIVATE_BROWSING", e[e.STORE_IS_FULL = 61001003] = "STORE_IS_FULL", e[e.STORE_NOT_INITIALIZED = 61001004] = "STORE_NOT_INITIALIZED", e[e.STORE_INVALID_KEY_TYPE = 61002e3] = "STORE_INVALID_KEY_TYPE", e[e.STORE_BROKEN_INTEGRITY = 61002001] = "STORE_BROKEN_INTEGRITY", e[e.STORE_BROKEN_BLOB = 61002002] = "STORE_BROKEN_BLOB", e[e.STORE_ENCRYPTION_INVALID = 61002003] = "STORE_ENCRYPTION_INVALID", e[e.STORE_ITEM_SIZE_LIMIT_EXCEEDED = 61017e3] = "STORE_ITEM_SIZE_LIMIT_EXCEEDED", e[e.STORE_READ_FAILED = 61017001] = "STORE_READ_FAILED", e[e.STORE_WRITE_FAILED = 61017002] = "STORE_WRITE_FAILED", e[e.DATABASE_SCHEMA_NOT_ON_UPGRADE = 62002e3] = "DATABASE_SCHEMA_NOT_ON_UPGRADE", e[e.COLLECTION_NOT_READY = 63001e3] = "COLLECTION_NOT_READY", e[e.COLLECTION_KEY_NOT_MATCH = 63002e3] = "COLLECTION_KEY_NOT_MATCH", e[e.COLLECTION_QUERY_NOT_VALID = 63002001] = "COLLECTION_QUERY_NOT_VALID", e[e.COLLECTION_KEY_NOT_FOUND = 63004e3] = "COLLECTION_KEY_NOT_FOUND", e[e.COLLECTION_KEY_NOT_GIVEN = 63004001] = "COLLECTION_KEY_NOT_GIVEN", e[e.COLLECTION_INSERT_DUPLICATE = 63009e3] = "COLLECTION_INSERT_DUPLICATE", e[e.COLLECTION_WRITE_FAILED = 63017e3] = "COLLECTION_WRITE_FAILED", e[e.COLLECTION_ITEM_SIZE_LIMIT_EXCEEDED = 63017001] = "COLLECTION_ITEM_SIZE_LIMIT_EXCEEDED", e[e.INDEX_TABLE_IS_REQUIRED = 65001e3] = "INDEX_TABLE_IS_REQUIRED", e[e.INDEX_TYPE_NOT_MATCH = 65002e3] = "INDEX_TYPE_NOT_MATCH", e[e.COMPARE_TYPE_NOT_MATCH = 69002001] = "COMPARE_TYPE_NOT_MATCH", e[e.CIRCULAR_REFERENCE_FOUND = 69002002] = "CIRCULAR_REFERENCE_FOUND";
})(Jn || (Jn = {}));
var aV, dn = function(e) {
  function n(t) {
    var l = t.code, a = l === void 0 ? Jn.UNKNOWN_ERROR : l, d = t.message, r = d === void 0 ? "Unknown error occurred." : d, i = e.call(this, r) || this;
    return i.code = a, Object.setPrototypeOf(i, n.prototype), i;
  }
  return J(n, e), Object.defineProperty(n, "storeNotDefined", { get: function() {
    return new n({ code: Jn.STORE_NOT_DEFINED, message: "Store is not defined. Specify the store on NestDB()" });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeNotAvailable", { get: function() {
    return new n({ code: Jn.STORE_NOT_AVAILABLE, message: "Store is not available. Check your environment settings." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeNotAvailableInPrivateBrowsing", { get: function() {
    return new n({ code: Jn.STORE_NOT_AVAILABLE_IN_PRIVATE_BROWSING, message: "Store is not available because it is in private browsing." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeIsFull", { get: function() {
    return new n({ code: Jn.STORE_IS_FULL, message: "Store is full." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeNotInitialized", { get: function() {
    return new n({ code: Jn.STORE_NOT_INITIALIZED, message: "Store is not initialized." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeKeyTypeIsInvalid", { get: function() {
    return new n({ code: Jn.STORE_INVALID_KEY_TYPE, message: "Store key should be string type." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeBrokenIntegrity", { get: function() {
    return new n({ code: Jn.STORE_BROKEN_INTEGRITY, message: "Data should be in a store but it does not. Integrity is broken." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeBrokenBlob", { get: function() {
    return new n({ code: Jn.STORE_BROKEN_BLOB, message: "Data should be in a store but it does not. Blob data is broken." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeEncryptionInvalid", { get: function() {
    return new n({ code: Jn.STORE_ENCRYPTION_INVALID, message: "Encryption algorithm has changed. All the store should reset." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeItemSizeExceeded", { get: function() {
    return new n({ code: Jn.STORE_ITEM_SIZE_LIMIT_EXCEEDED, message: "The size of the item exceeds the limit that the store allows." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeReadFailed", { get: function() {
    return new n({ code: Jn.STORE_READ_FAILED, message: "Failed to read from store." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "storeWriteFailed", { get: function() {
    return new n({ code: Jn.STORE_WRITE_FAILED, message: "Failed to write to store." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "databaseSchemaNotOnUpgrade", { get: function() {
    return new n({ code: Jn.DATABASE_SCHEMA_NOT_ON_UPGRADE, message: "Committing schema is not allowed when upgrade is not running." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "collectionNotReady", { get: function() {
    return new n({ code: Jn.COLLECTION_NOT_READY, message: "Collection is not ready due to an error during initialization." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "collectionKeyNotMatch", { get: function() {
    return new n({ code: Jn.COLLECTION_KEY_NOT_MATCH, message: "keyName of collection could not change." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "collectionQueryNotValid", { get: function() {
    return new n({ code: Jn.COLLECTION_QUERY_NOT_VALID, message: "Query parameter is not a valid format." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "collectionInsertDuplicate", { get: function() {
    return new n({ code: Jn.COLLECTION_INSERT_DUPLICATE, message: "The key already exists." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "collectionKeyNotFound", { get: function() {
    return new n({ code: Jn.COLLECTION_KEY_NOT_FOUND, message: "The key is not found." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "collectionKeyNotGiven", { get: function() {
    return new n({ code: Jn.COLLECTION_KEY_NOT_GIVEN, message: "The item should contain [keyName] property." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "collectionWriteFailed", { get: function() {
    return new n({ code: Jn.COLLECTION_WRITE_FAILED, message: "Failed to write an item." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "collectionItemSizeExceeded", { get: function() {
    return new n({ code: Jn.COLLECTION_ITEM_SIZE_LIMIT_EXCEEDED, message: "The size of the item exceeds the limit that a collection allows." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "indexTableIsRequired", { get: function() {
    return new n({ code: Jn.INDEX_TABLE_IS_REQUIRED, message: "Index table is required." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "indexTypesNotMatch", { get: function() {
    return new n({ code: Jn.INDEX_TYPE_NOT_MATCH, message: "Indexed column should have primitive type." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "compareTypesNotMatch", { get: function() {
    return new n({ code: Jn.COMPARE_TYPE_NOT_MATCH, message: "Values to compare have different types." });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "circularReferenceFound", { get: function() {
    return new n({ code: Jn.CIRCULAR_REFERENCE_FOUND, message: "Cannot handle circular referenced object." });
  }, enumerable: !1, configurable: !0 }), n;
}(Error);
(function(e) {
  e.INIT = "init", e.READY = "ready", e.CLOSED = "closed";
})(aV || (aV = {}));
var bu, ea = function(e, n) {
  if (n === void 0 && (n = /* @__PURE__ */ new WeakMap()), typeof e == "object" && e !== null) {
    if (n.has(e))
      throw dn.circularReferenceFound;
    n.set(e, !0);
    var t = void 0;
    if (Array.isArray(e))
      t = e.map(function(a) {
        return ea(a, n);
      });
    else if (e instanceof RegExp)
      t = e;
    else if (e instanceof Date)
      t = e;
    else
      for (var l in t = {}, e)
        t[l] = ea(e[l], n);
    return n.delete(e), t;
  }
  return e;
}, mr = function(e, n) {
  if (n == null)
    return 1;
  if (e == null)
    return -1;
  if (typeof e != typeof n)
    throw dn.compareTypesNotMatch;
  var t = 0;
  switch (typeof e) {
    case "boolean":
    case "number":
      t = e - n;
      break;
    case "string":
      t = e.localeCompare(n);
  }
  return t;
}, Yu = function(e, n) {
  for (var t = 0, l = 0; l < e.length; l++)
    t = e.charCodeAt(l) + (t << 6) + (t << 16) - t;
  return (t >>> 0) % n;
}, CU = function(e) {
  return new Promise(function(n) {
    setTimeout(function() {
      return n();
    }, e);
  });
}, WV = function(e, n) {
  if (!n)
    return !1;
  if (typeof e != "function") {
    for (var t in e)
      if (["/and", "&&"].includes(t)) {
        if (e[t].some(function(c) {
          return !WV(c, n);
        }))
          return !1;
      } else if (["/or", "||"].includes(t)) {
        if (e[t].every(function(c) {
          return !WV(c, n);
        }))
          return !1;
      } else if (t === "/where") {
        if (!(0, e[t])(n))
          return !1;
      } else {
        var l = t;
        if (typeof e[l] == "object") {
          var a = e[l];
          for (var d in a)
            switch (d) {
              case "/eq":
              case "=":
                if ((r = n[l]) !== (i = a[d]))
                  return !1;
                break;
              case "/neq":
              case "!=":
                if ((r = n[l]) === (i = a[d]))
                  return !1;
                break;
              case "/gt":
              case ">":
                var r = n[l], i = a[d];
                if (!(mr(r, i) > 0))
                  return !1;
                break;
              case "/gte":
              case ">=":
                if (r = n[l], i = a[d], !(mr(r, i) >= 0))
                  return !1;
                break;
              case "/lt":
              case "<":
                if (r = n[l], i = a[d], !(mr(r, i) < 0))
                  return !1;
                break;
              case "/lte":
              case "<=":
                if (r = n[l], i = a[d], !(mr(r, i) <= 0))
                  return !1;
                break;
              case "/in":
                if (r = n[l], !(i = a[d]).includes(r))
                  return !1;
                break;
              case "/nin":
                if (r = n[l], (i = a[d]).includes(r))
                  return !1;
                break;
              case "/contain":
                if (r = n[l], i = a[d], !r.includes(i))
                  return !1;
                break;
              case "/regex":
                if (r = n[l], !(i = a[d]).test(r))
                  return !1;
                break;
              case "/where":
                if (r = n[l], !(0, a[d])(r))
                  return !1;
            }
        } else if (typeof e[l] == "function") {
          if (!e[l](n[l]))
            return !1;
        } else if (e[l] !== n[l])
          return !1;
      }
    return !0;
  }
  return e(n);
}, ks = function() {
}, Qu = function() {
  return Promise.resolve();
}, A5 = function(e) {
  return e;
}, Ju = function(e, n) {
  n();
};
(function(e) {
  e[e.FORWARD = 0] = "FORWARD", e[e.BACKWARD = 1] = "BACKWARD";
})(bu || (bu = {}));
var mV, Dl, Bd, q5 = function() {
  function e(n) {
    var t = n.initialPrevValue, l = t === void 0 ? null : t, a = n.initialNextValue, d = a === void 0 ? null : a, r = n.iterator, i = n.map, c = i === void 0 ? A5 : i, V = n.backward, s = V === void 0 ? Qu : V, o = n.forward, U = o === void 0 ? Qu : o, N = n.complete, R = N === void 0 ? ks : N;
    this._prevValue = l, this._nextValue = d, this._error = null, this._map = c, this._backward = s, this._forward = U, this._iterator = r, this._complete = R;
  }
  return Object.defineProperty(e.prototype, "prevValue", { get: function() {
    return this._map(this._prevValue);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "nextValue", { get: function() {
    return this._map(this._nextValue);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "error", { get: function() {
    return this._error;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "hasPrevious", { get: function() {
    return !!this._prevValue;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "hasNext", { get: function() {
    return !!this._nextValue;
  }, enumerable: !1, configurable: !0 }), e.prototype.prev = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            if (!this.hasPrevious)
              return [3, 6];
            a.label = 1;
          case 1:
            return a.trys.push([1, 3, , 4]), n = this._prevValue, t = this, [4, this._backward()];
          case 2:
            return t._prevValue = a.sent() || null, this._nextValue = n, [3, 4];
          case 3:
            return l = a.sent(), this._error = l, [3, 4];
          case 4:
            return [4, this._iterator(this)];
          case 5:
            return [2, a.sent()];
          case 6:
            this._complete(), a.label = 7;
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            if (!this.hasNext)
              return [3, 6];
            a.label = 1;
          case 1:
            return a.trys.push([1, 3, , 4]), n = this._nextValue, t = this, [4, this._forward()];
          case 2:
            return t._nextValue = a.sent() || null, this._prevValue = n, [3, 4];
          case 3:
            return l = a.sent(), this._error = l, [3, 4];
          case 4:
            return [4, this._iterator(this)];
          case 5:
            return [2, a.sent()];
          case 6:
            this._complete(), a.label = 7;
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.stop = function() {
    this._prevValue = null, this._nextValue = null, this._complete();
  }, e;
}(), CT = function() {
  function e(n) {
    var t = n.condition, l = t === void 0 ? {} : t, a = n.backward, d = a !== void 0 && a, r = n.blockManager, i = n.indexer;
    this.condition = l, this.backward = d, this._blockManager = r, this._indexer = i;
  }
  return e.prototype.findOptimizedStartPosition = function() {
    var n = this, t = ["=", "/eq", ">", ">=", "/gt", "/gte"], l = ["=", "/eq", "<", "<=", "/lt", "/lte"];
    if (this.backward) {
      var a = this._indexer.origin.length - 1;
      if (typeof this.condition != "function")
        for (var d in this._indexer.fields) {
          var r = this._indexer.fields[d], i = 1;
          if (r[0] === "-" && (r = r.slice(1), i = -1), this.condition[r]) {
            if (typeof this.condition[r] == "object") {
              var c = i > 0 ? l : t;
              for (var V in this.condition[r])
                if (c.includes(V)) {
                  for (var s = a; s >= 0; s--)
                    if (i * mr(this._indexer.origin[s].columnValues[d], this.condition[r][V]) <= 0) {
                      a = s;
                      break;
                    }
                }
            } else
              for (s = a; s >= 0; s--)
                if (i * mr(this._indexer.origin[s].columnValues[d], this.condition[r]) <= 0) {
                  a = s;
                  break;
                }
          }
        }
      return Math.min(a + 1, this._indexer.origin.length - 1);
    }
    var o = 0;
    if (typeof this.condition != "function")
      for (var U = function(h) {
        var Z = N._indexer.fields[h], W = 1;
        if (Z[0] === "-" && (Z = Z.slice(1), W = -1), N.condition[Z]) {
          if (typeof N.condition[Z] == "object")
            Object.keys(N.condition[Z]).forEach(function(m) {
              if ((W > 0 ? t : l).includes(m)) {
                for (var E = o; E < n._indexer.origin.length; E++)
                  if (W * mr(n._indexer.origin[E].columnValues[h], n.condition[Z][m]) >= 0) {
                    o = E;
                    break;
                  }
              }
            });
          else
            for (var F = o; F < N._indexer.origin.length; F++)
              if (W * mr(N._indexer.origin[F].columnValues[h], N.condition[Z]) >= 0) {
                o = F;
                break;
              }
        }
      }, N = this, d = 0; d < this._indexer.fields.length; d++)
        U(d);
    return Math.max(o - 1, 0);
  }, e.prototype.each = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V = this;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            if (t = this.findOptimizedStartPosition(), l = 0, this.backward && this._indexer.origin[t] && (l = this._indexer.origin[t].keys.length - 1), a = function() {
              if (V._indexer.origin[t]) {
                if (!V._indexer.origin[t].keys[++l]) {
                  if (!V._indexer.origin[++t])
                    return !1;
                  l = 0;
                }
                return !0;
              }
              return !1;
            }, d = function() {
              if (V._indexer.origin[t]) {
                if (!V._indexer.origin[t].keys[--l]) {
                  if (!V._indexer.origin[--t])
                    return !1;
                  l = V._indexer.origin[t].keys.length - 1;
                }
                return !0;
              }
              return !1;
            }, r = null, !this._indexer.origin[t])
              return [3, 4];
            i = this.backward ? d : a, s.label = 1;
          case 1:
            return [4, this._blockManager.getFromBlock(this._indexer.origin[t].keys[l])];
          case 2:
            if ((c = s.sent()) && WV(this.condition, c))
              return r = c, [3, 4];
            s.label = 3;
          case 3:
            if (i())
              return [3, 1];
            s.label = 4;
          case 4:
            return [4, new Promise(function(o) {
              var U = new q5({ initialNextValue: ea(r), iterator: n, forward: function() {
                return M(V, void 0, void 0, function() {
                  var N, R;
                  return p(this, function(h) {
                    switch (h.label) {
                      case 0:
                        N = this.backward ? d : a, h.label = 1;
                      case 1:
                        return N() ? [4, this._blockManager.getFromBlock(this._indexer.origin[t].keys[l])] : [3, 3];
                      case 2:
                        return (R = h.sent()) && WV(this.condition, R) ? [2, ea(R)] : [3, 1];
                      case 3:
                        return [2, null];
                    }
                  });
                });
              }, backward: function() {
                return M(V, void 0, void 0, function() {
                  var N, R;
                  return p(this, function(h) {
                    switch (h.label) {
                      case 0:
                        N = this.backward ? a : d, h.label = 1;
                      case 1:
                        return N() ? [4, this._blockManager.getFromBlock(this._indexer.origin[t].keys[l])] : [3, 3];
                      case 2:
                        return (R = h.sent()) && WV(this.condition, R) ? [2, ea(R)] : [3, 1];
                      case 3:
                        return [2, null];
                    }
                  });
                });
              }, complete: o });
              n(U);
            })];
          case 5:
            return [2, s.sent()];
        }
      });
    });
  }, e;
}(), $5 = function() {
  function e(n) {
    var t = n.condition, l = t === void 0 ? {} : t, a = n.backward, d = a !== void 0 && a, r = n.mutex, i = n.blockManager, c = n.indexer;
    this._mutex = r, this._iterator = new CT({ condition: l, backward: d, blockManager: i, indexer: c });
  }
  return e.prototype.fetch = function(n) {
    return n === void 0 && (n = {}), M(this, void 0, void 0, function() {
      var t, l, a, d, r = this;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            if (t = Math.max(n.offset || 0, 0), (l = typeof n.limit == "number" ? n.limit : Number.MAX_SAFE_INTEGER) === 0)
              return [2, []];
            if (l < 0)
              throw dn.collectionQueryNotValid;
            i.label = 1;
          case 1:
            return i.trys.push([1, 4, , 5]), a = [], [4, this._mutex.lock()];
          case 2:
            return i.sent(), [4, this._iterator.each(function(c) {
              return M(r, void 0, void 0, function() {
                return p(this, function(V) {
                  return c.error ? c.stop() : c.hasNext ? t === 0 ? (a.push(c.nextValue), 0 < l && l <= a.length ? c.stop() : c.next()) : (t--, c.next()) : c.stop(), [2];
                });
              });
            })];
          case 3:
            return i.sent(), this._mutex.unlock(), [2, a];
          case 4:
            throw d = i.sent(), this._mutex.unlock(), d;
          case 5:
            return [2];
        }
      });
    });
  }, e.prototype.count = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return a.trys.push([0, 3, , 4]), n = 0, [4, this._mutex.lock()];
          case 1:
            return a.sent(), [4, this._iterator.each(function(d) {
              return M(l, void 0, void 0, function() {
                return p(this, function(r) {
                  return d.error ? d.stop() : d.hasNext ? (n++, d.next()) : d.stop(), [2];
                });
              });
            })];
          case 2:
            return a.sent(), this._mutex.unlock(), [2, n];
          case 3:
            throw t = a.sent(), this._mutex.unlock(), t;
          case 4:
            return [2];
        }
      });
    });
  }, e;
}(), KT = function(e) {
  return "".concat("nest", "@").concat(e);
}, kV = function(e, n) {
  return "".concat(KT(e), "/").concat(n);
}, TZ = function(e, n) {
  return "".concat(kV(e, n), ".metadata");
}, _T = function(e, n) {
  return "".concat(kV(e, n), "/block.");
}, vu = function(e, n) {
  return "".concat(kV(e, n), "/blob.");
}, eB = function() {
  function e(n) {
    var t = n.dbname, l = n.collectionName, a = n.store;
    this.dbname = t, this.collectionName = l, this.store = a;
  }
  return e.prototype.get = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V, s;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, this.store.get(n)];
          case 1:
            return (t = o.sent()) ? (l = t.data, a = t.type, typeof fetch > "u" ? [3, 4] : [4, fetch(l)]) : [3, 5];
          case 2:
            return [4, o.sent().blob()];
          case 3:
            return [2, o.sent()];
          case 4:
            for (d = [], r = atob(l.split(",")[1]), i = 0; i < r.length; i += 512) {
              for (c = r.slice(i, i + 512), V = new Array(c.length), s = 0; s < c.length; s++)
                V[s] = c.charCodeAt(s);
              d.push(new Uint8Array(V));
            }
            return [2, new Blob(d, { type: a })];
          case 5:
            return [2, null];
        }
      });
    });
  }, e.prototype.save = function(n, t) {
    return t === void 0 && (t = "".concat(Date.now())), M(this, void 0, void 0, function() {
      var l, a, d, r, i = this;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return [4, new Promise(function(V) {
              var s = function(U, N, R, h) {
                return h === void 0 && (h = 0), "".concat(vu(U, N)).concat(R, ".").concat(h);
              }(i.dbname, i.collectionName, t), o = new FileReader();
              o.onload = function() {
                V({ blobId: s, data: o.result, type: n.type });
              }, o.readAsDataURL(n);
            })];
          case 1:
            return l = c.sent(), a = l.blobId, d = l.data, r = l.type, [4, this.store.set({ key: a, value: { data: d, type: r } })];
          case 2:
            return c.sent(), [2, a];
        }
      });
    });
  }, e.prototype.remove = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.store.remove(n)];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return n = vu(this.dbname, this.collectionName), [4, this.store.getAllKeys()];
          case 1:
            return t = a.sent(), [4, Promise.all(t.filter(function(d) {
              return d.startsWith(n);
            }).map(function(d) {
              return M(l, void 0, void 0, function() {
                return p(this, function(r) {
                  switch (r.label) {
                    case 0:
                      return [4, this.store.remove(d)];
                    case 1:
                      return [2, r.sent()];
                  }
                });
              });
            }))];
          case 2:
            return a.sent(), [2];
        }
      });
    });
  }, e;
}();
(function(e) {
  e[e.COMMIT = 0] = "COMMIT", e[e.WRITE = 1] = "WRITE", e[e.ERROR = 2] = "ERROR";
})(mV || (mV = {})), function(e) {
  e.PENDING = "pending", e.PERSISTENT = "persistent", e.VOLATILE = "volatile";
}(Dl || (Dl = {})), function(e) {
  e[e.NO_CACHE = 0] = "NO_CACHE", e[e.DEFAULT = 1] = "DEFAULT", e[e.PERSISTENT = 2] = "PERSISTENT";
}(Bd || (Bd = {}));
var Ks, xl, zu = [Dl.PENDING, Dl.VOLATILE], KU = {}, $a = function() {
  function e(n) {
    var t = n.dbname, l = n.limit, a = l === void 0 ? 256 : l;
    return KU[t] || (this.dbname = t, this._items = [], this._limit = a, KU[t] = this), KU[t];
  }
  return e.get = function(n) {
    return KU[n];
  }, Object.defineProperty(e.prototype, "items", { get: function() {
    return this._items;
  }, enumerable: !1, configurable: !0 }), e.prototype.find = function(n, t, l) {
    return l === void 0 && (l = Bd.DEFAULT), M(this, void 0, void 0, function() {
      var a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return (a = this.get(t)) ? [3, 2] : [4, n.get(t)];
          case 1:
            return (d = r.sent()) && (a = { key: t, value: d, state: l === Bd.PERSISTENT ? Dl.PERSISTENT : Dl.VOLATILE }, this.put(a)), [3, 3];
          case 2:
            l === Bd.PERSISTENT && (a.state = Dl.PERSISTENT), r.label = 3;
          case 3:
            return [2, a];
        }
      });
    });
  }, e.prototype.get = function(n, t) {
    t === void 0 && (t = Bd.DEFAULT);
    var l = this._items.map(function(d) {
      return d.key;
    }).indexOf(n);
    if (l > -1) {
      var a = this._items[l];
      return t === Bd.PERSISTENT && (a.state = Dl.PERSISTENT), t !== Bd.NO_CACHE && this.put(a), a;
    }
    return null;
  }, e.prototype.put = function(n) {
    var t, l;
    if (this._limit > 0) {
      var a = this._items.map(function(o) {
        return o.key;
      }).indexOf(n.key);
      if (a > -1)
        zu.includes(this._items[a].state) && zu.includes(n.state) ? (this._items.splice(a, 1), this._items.push(n)) : (this._items[a].state = n.state, this._items[a].value = n.value);
      else {
        this._items.push(n);
        var d = this._items.filter(function(o) {
          return o.state === Dl.VOLATILE;
        }), r = d.length - this._limit;
        if (r > 0) {
          var i = [];
          try {
            for (var c = be(this._items), V = c.next(); !V.done; V = c.next()) {
              var s = V.value;
              s.state === Dl.VOLATILE && r > 0 ? r-- : i.push(s);
            }
          } catch (o) {
            t = { error: o };
          } finally {
            try {
              V && !V.done && (l = c.return) && l.call(c);
            } finally {
              if (t)
                throw t.error;
            }
          }
          this._items = i;
        }
      }
    }
  }, e.prototype.remove = function(n) {
    var t = this._items.map(function(l) {
      return l.key;
    }).indexOf(n);
    t > -1 && this._items.splice(t, 1);
  }, e.prototype.clearByCondition = function(n) {
    this._items = this._items.filter(function(t) {
      return !n(t);
    });
  }, e.prototype.clear = function(n) {
    n === void 0 && (n = !1), this._items = n ? [] : this._items.filter(function(t) {
      return t.state !== Dl.VOLATILE;
    });
  }, e;
}(), tB = function() {
  function e(n) {
    var t = n.dbname, l = n.collectionName, a = n.store;
    this._requests = [], this._onCommit = /* @__PURE__ */ new Map(), this._onWrite = /* @__PURE__ */ new Map(), this._onError = /* @__PURE__ */ new Map(), this.dbname = t, this.collectionName = l, this.metadataKey = function(d, r) {
      return "".concat(kV(d, r), "/trans.metadata");
    }(t, l), this.recordsetKey = function(d, r) {
      return "".concat(kV(d, r), "/trans.recordset");
    }(t, l), this._store = a;
  }
  return Object.defineProperty(e.prototype, "generation", { get: function() {
    return this._metadata ? this._metadata.generation : 0;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "requestCount", { get: function() {
    return this._requests.length;
  }, enumerable: !1, configurable: !0 }), e.prototype._getReducedRecordset = function(n) {
    return n === void 0 && (n = []), M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._store.get(this.recordsetKey)];
          case 1:
            return (t = l.sent() || []).push.apply(t, ot([], et(n), !1)), [2, this._reduceRecordSet(t)];
        }
      });
    });
  }, e.prototype._reduceRecordSet = function(n) {
    for (var t = [], l = {}, a = n.length - 1; a >= 0; a--) {
      for (var d = n[a], r = [], i = d.requests.length - 1; i >= 0; i--) {
        var c = d.requests[i], V = c.data;
        l[V.key] || (r.unshift(c), l[V.key] = !0);
      }
      r.length > 0 && (d.requests = r, t.unshift(d));
    }
    return t;
  }, e.prototype._applyRecord = function(n, t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s, o;
      return p(this, function(U) {
        switch (U.label) {
          case 0:
            l = $a.get(this.dbname), a = t.generation, d = t.requests, r = null, U.label = 1;
          case 1:
            return U.trys.push([1, 3, , 4]), [4, this._store.setMany(d.map(function(N) {
              return x(x({}, N.data), { generation: a });
            }))];
          case 2:
            for (i = U.sent(), c = 0; c < d.length; c++)
              i[c] instanceof Error && (r || (r = i[c]), V = d[c].data, l.put(x(x({}, V), { state: Dl.PERSISTENT })));
            return [3, 4];
          case 3:
            return s = U.sent(), r = s, [3, 4];
          case 4:
            return r ? [3, 6] : (o = n.filter(function(N) {
              return N.generation !== a;
            }), [4, this._store.set({ key: this.recordsetKey, value: o })]);
          case 5:
            return U.sent(), this._onWrite.forEach(function(N) {
              N(d.map(function(R) {
                return R.data;
              }));
            }), [3, 7];
          case 6:
            this._onError.forEach(function(N) {
              r && N(r);
            }), U.label = 7;
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.init = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return n = this, [4, this._store.get(this.metadataKey)];
          case 1:
            return n._metadata = V.sent() || { generation: 1 }, [4, this._getReducedRecordset()];
          case 2:
            t = V.sent(), V.label = 3;
          case 3:
            V.trys.push([3, 8, 9, 10]), l = be(t), a = l.next(), V.label = 4;
          case 4:
            return a.done ? [3, 7] : (d = a.value, [4, this._applyRecord(t, d)]);
          case 5:
            V.sent(), V.label = 6;
          case 6:
            return a = l.next(), [3, 4];
          case 7:
            return [3, 10];
          case 8:
            return r = V.sent(), i = { error: r }, [3, 10];
          case 9:
            try {
              a && !a.done && (c = l.return) && c.call(l);
            } finally {
              if (i)
                throw i.error;
            }
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }, e.prototype.on = function(n, t, l) {
    switch (n) {
      case mV.COMMIT:
        this._onCommit.set(t, l);
        break;
      case mV.WRITE:
        this._onWrite.set(t, l);
        break;
      case mV.ERROR:
        this._onError.set(t, l);
    }
  }, e.prototype.requestWrite = function(n, t) {
    this._requests.push({ data: n, options: t }), $a.get(this.dbname).put(x({ state: Dl.PENDING }, n));
  }, e.prototype.requestMultipleWrite = function(n, t) {
    var l, a, d = $a.get(this.dbname);
    try {
      for (var r = be(n), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        this._requests.push({ data: c, options: t }), d.put(x({ state: Dl.PENDING }, c));
      }
    } catch (V) {
      l = { error: V };
    } finally {
      try {
        i && !i.done && (a = r.return) && a.call(r);
      } finally {
        if (l)
          throw l.error;
      }
    }
  }, e.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        return $a.get(this.dbname).clearByCondition(function(t) {
          return t.state === Dl.PENDING;
        }), this._requests = [], [2];
      });
    });
  }, e.prototype.commit = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r, i, c, V, s, o, U, N = this;
      return p(this, function(R) {
        switch (R.label) {
          case 0:
            if (!((n = this._requests).length > 0))
              return [3, 4];
            for (t = [], l = {}, c = n.length - 1; c >= 0; c--)
              a = n[c], s = a.data, l[s.key] || (l[s.key] = !0, t.unshift(a));
            return d = { generation: this.generation, requests: t }, [4, this._getReducedRecordset([d])];
          case 1:
            return r = R.sent(), [4, this._store.set({ key: this.recordsetKey, value: r })];
          case 2:
            return R.sent(), this._metadata.generation++, [4, this._store.set({ key: this.metadataKey, value: this._metadata })];
          case 3:
            for (R.sent(), i = $a.get(this.dbname), c = 0; c < t.length; c++)
              V = t[c], s = V.data, o = V.options, i.put(x(x({}, s), { state: o && o.persistent ? Dl.PERSISTENT : Dl.VOLATILE }));
            this._requests = [], this._onCommit.forEach(function(h) {
              h(n.map(function(Z) {
                return Z.data;
              }));
            }), U = nU.get(this.dbname), setTimeout(function() {
              try {
                N._applyRecord(r, d);
              } catch (h) {
                N._onError.forEach(function(Z) {
                  return Z(h);
                });
              }
            }, U.transactionApplyDelay), R.label = 4;
          case 4:
            return [2];
        }
      });
    });
  }, e;
}(), kN = function() {
  function e(n) {
    var t = n.blockId, l = n.keyName, a = n.items, d = a === void 0 ? [] : a, r = n.limit;
    this.blockId = t, this.keyName = l, this.limit = r, this._items = ot([], et(d), !1);
  }
  return e.createFromCacheItem = function(n) {
    return n ? new e(n.value) : null;
  }, Object.defineProperty(e.prototype, "isEmpty", { get: function() {
    return this._items.length === 0;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "items", { get: function() {
    return this._items;
  }, enumerable: !1, configurable: !0 }), e.prototype.serialize = function() {
    return { blockId: this.blockId, keyName: this.keyName, limit: this.limit, items: this._items };
  }, e.prototype.getItemByKey = function(n) {
    var t = this, l = this._items.find(function(a) {
      var d = a[t.keyName];
      return n === d;
    });
    return l ?? null;
  }, e.prototype.has = function(n) {
    var t = this;
    return this._items.map(function(l) {
      return l[t.keyName];
    }).includes(n);
  }, e.prototype.add = function(n) {
    var t = this, l = this._items.map(function(a) {
      return a[t.keyName];
    }).indexOf(n[this.keyName]);
    return l < 0 ? this._items.length < this.limit && (this._items.push(n), !0) : (this._items[l] = n, !0);
  }, e.prototype.remove = function(n) {
    for (var t in this._items)
      if (this._items[t][this.keyName] === n)
        return this._items.splice(parseInt(t), 1), !0;
    return !1;
  }, e.prototype.clear = function() {
    this._items = [];
  }, e;
}(), nB = function() {
  function e(n) {
    var t = n.dbname, l = n.collectionName, a = n.metadata, d = n.hashFunction, r = d === void 0 ? Yu : d, i = n.transaction, c = n.store;
    this.dbname = t, this.collectionName = l, this.hashFunction = r, this.metadata = a, this._transaction = i, this._store = c;
  }
  return Object.defineProperty(e.prototype, "keyName", { get: function() {
    return this.metadata.keyName;
  }, enumerable: !1, configurable: !0 }), e.prototype.createBlockId = function(n, t) {
    return t === void 0 && (t = this.metadata.blockLevel), l = this.dbname, a = this.collectionName, d = t, r = "".concat(function(i, c, V) {
      var s = V.base * Math.pow(V.multiplier, c) + V.constant;
      return (V.hashFunction || Yu)(i, s);
    }(n, t, { hashFunction: this.hashFunction, base: this.metadata.blockHashBase, multiplier: this.metadata.blockHashMultiplier, constant: this.metadata.blockHashConstant })), "".concat(_T(l, a)).concat(d, ".").concat(r);
    var l, a, d, r;
  }, e.prototype._findBlock = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            t = $a.get(this.dbname), l = this.metadata.blockLevel, i.label = 1;
          case 1:
            return l > 0 ? (a = this.createBlockId(n, l), [4, t.find(this._store, a)]) : [3, 4];
          case 2:
            if ((d = i.sent()) && (r = kN.createFromCacheItem(d), r == null ? void 0 : r.getItemByKey(n)))
              return [2, r];
            i.label = 3;
          case 3:
            return l--, [3, 1];
          case 4:
            return [2, null];
        }
      });
    });
  }, e.prototype.getFromBlock = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._findBlock(n)];
          case 1:
            return [2, (t = l.sent()) ? t.getItemByKey(n) : null];
        }
      });
    });
  }, e.prototype.putToBlock = function(n, t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return l = nU.get(this.dbname), a = this.createBlockId(n), d = Math.floor(this._store.itemSizeLimit / l.itemSizeLimit), [4, $a.get(this.dbname).find(this._store, a)];
          case 1:
            return r = c.sent(), (i = r ? kN.createFromCacheItem(r) : new kN({ blockId: a, keyName: this.keyName, items: [], limit: d })) != null && i.add(t) ? (this._transaction.requestWrite({ key: i.blockId, value: i.serialize() }), [2, !0]) : [2, !1];
        }
      });
    });
  }, e.prototype.removeFromBlock = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._findBlock(n)];
          case 1:
            return (t = l.sent()) && t.remove(n) ? (this._transaction.requestWrite({ key: t.blockId, value: t.serialize() }), [2, !0]) : [2, !1];
        }
      });
    });
  }, e.prototype.clearAllBlocks = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return n = _T(this.dbname, this.collectionName), [4, this._store.getAllKeys()];
          case 1:
            return t = a.sent(), l = t.filter(function(d) {
              return d.startsWith(n);
            }), [4, this._store.removeMany(l)];
          case 2:
            return a.sent(), [4, this._transaction.clear()];
          case 3:
            return a.sent(), $a.get(this.dbname).clearByCondition(function(d) {
              return d.key.startsWith(n);
            }), [2];
        }
      });
    });
  }, e;
}(), wV = {}, Or = function() {
  function e(n) {
    var t = n.dbname, l = n.collectionName, a = n.keyName, d = n.fields, r = n.transaction, i = n.store, c = this;
    this._origin = [], this._table = [];
    var V = function(s, o, U) {
      return "".concat(kV(s, o), "/index.").concat(U);
    }(t, l, d.join(">"));
    return wV[V] || (this.dbname = t, this.collectionName = l, this.keyName = a, this.fields = d, this.indexerKey = V, this._transaction = r, this._store = i, this._transaction.on(mV.COMMIT, this.indexerKey, function() {
      return c.commit();
    }), this._transaction.on(mV.ERROR, this.indexerKey, function() {
      return c.abort();
    })), wV[V];
  }
  return e.createKey = function(n) {
    return n.join(">");
  }, e.parseKey = function(n) {
    return n.split(">");
  }, e.clearIndexerMap = function() {
    for (var n in wV)
      delete wV[n];
  }, e.prototype._addItem = function(n) {
    var t = n[this.keyName], l = this.getColumnValues(n), a = et(this.indexOf(l), 2), d = a[0];
    return a[1] ? !this._table[d].keys.includes(t) && (this._table[d].keys.push(t), !0) : (this._table.splice(d, 0, { columnValues: l, keys: [t] }), !0);
  }, e.prototype._removeItem = function(n) {
    var t = n[this.keyName], l = this.getColumnValues(n), a = et(this.indexOf(l), 2), d = a[0];
    if (a[1]) {
      var r = this._table[d].keys.indexOf(t);
      if (r > -1)
        return this._table[d].keys.splice(r, 1), this._table[d].keys.length === 0 && this._table.splice(d, 1), !0;
    }
    return !1;
  }, Object.defineProperty(e.prototype, "origin", { get: function() {
    return this._origin;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "table", { get: function() {
    return this._table;
  }, enumerable: !1, configurable: !0 }), e.prototype.getColumnValues = function(n) {
    var t, l, a, d, r = [];
    try {
      for (var i = be(this.fields), c = i.next(); !c.done; c = i.next()) {
        var V = c.value;
        if (V[0] === "-" && (V = V.slice(1)), a = n[V], d = void 0, d = typeof a, a !== null && d !== "undefined" && d !== "boolean" && d !== "number" && d !== "string")
          throw dn.indexTypesNotMatch;
        r.push(n[V]);
      }
    } catch (s) {
      t = { error: s };
    } finally {
      try {
        c && !c.done && (l = i.return) && l.call(i);
      } finally {
        if (t)
          throw t.error;
      }
    }
    return r;
  }, e.prototype.diff = function(n, t) {
    for (var l in this.fields) {
      var a = this.fields[l][0] === "-" ? -1 : 1, d = mr(n[l], t[l]);
      if (d !== 0)
        return a * d;
    }
    return 0;
  }, e.prototype.indexOf = function(n) {
    if (this._table.length > 0) {
      for (var t = 0, l = this._table.length - 1; t <= l; ) {
        var a = Math.floor((t + l) / 2), d = this.diff(n, this._table[a].columnValues);
        if (d > 0)
          t = a + 1;
        else {
          if (!(d < 0))
            return [a, !0];
          l = a - 1;
        }
      }
      return [t, !1];
    }
    return [0, !1];
  }, e.prototype.ensure = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W;
      return p(this, function(F) {
        switch (F.label) {
          case 0:
            return [4, (n = $a.get(this.dbname)).find(this._store, this.indexerKey, Bd.PERSISTENT)];
          case 1:
            return (t = F.sent()) ? [3, 11] : (l = _T(this.dbname, this.collectionName), [4, this._store.getAllKeys()]);
          case 2:
            a = F.sent(), F.label = 3;
          case 3:
            F.trys.push([3, 8, 9, 10]), d = be(a), r = d.next(), F.label = 4;
          case 4:
            return r.done ? [3, 7] : (i = r.value).startsWith(l) ? [4, n.find(this._store, i, Bd.NO_CACHE)] : [3, 6];
          case 5:
            if (c = F.sent(), V = kN.createFromCacheItem(c))
              try {
                for (Z = void 0, s = be(V.items), o = s.next(); !o.done; o = s.next())
                  U = o.value, this._addItem(U);
              } catch (m) {
                Z = { error: m };
              } finally {
                try {
                  o && !o.done && (W = s.return) && W.call(s);
                } finally {
                  if (Z)
                    throw Z.error;
                }
              }
            F.label = 6;
          case 6:
            return r = d.next(), [3, 4];
          case 7:
            return [3, 10];
          case 8:
            return N = F.sent(), R = { error: N }, [3, 10];
          case 9:
            try {
              r && !r.done && (h = d.return) && h.call(d);
            } finally {
              if (R)
                throw R.error;
            }
            return [7];
          case 10:
            return this._transaction.requestWrite({ key: this.indexerKey, value: this._table }, { persistent: !0 }), [3, 12];
          case 11:
            this._origin = t.value, this._table = ea(this._origin), F.label = 12;
          case 12:
            return wV[this.indexerKey] = this, [2];
        }
      });
    });
  }, e.prototype.drop = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return $a.get(this.dbname).remove(this.indexerKey), [4, this._store.remove(this.indexerKey)];
          case 1:
            return n.sent(), delete wV[this.indexerKey], [2];
        }
      });
    });
  }, e.prototype.addItem = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return this._addItem(n) && this._transaction.requestWrite({ key: this.indexerKey, value: this._table }, { persistent: !0 }), [2];
      });
    });
  }, e.prototype.removeItem = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return this._removeItem(n) && this._transaction.requestWrite({ key: this.indexerKey, value: this._table }, { persistent: !0 }), [2];
      });
    });
  }, e.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        return this._table = [], this._transaction.requestWrite({ key: this.indexerKey, value: this._table }, { persistent: !0 }), [2];
      });
    });
  }, e.prototype.commit = function() {
    this._origin = this._table, this._table = ea(this._origin);
  }, e.prototype.abort = function() {
    this._table = ea(this._origin);
  }, e;
}(), cR = function() {
  return typeof document < "u" && typeof navigator < "u" && navigator.product !== "ReactNative";
}, xu = function() {
  var e = (/* @__PURE__ */ new Date()).getTime();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(n) {
    var t = (e + 16 * Math.random()) % 16 | 0;
    return e = Math.floor(e / 16), (n === "x" ? t : 3 & t | 8).toString(16);
  });
};
(function(e) {
  e[e.PROCESSING = 0] = "PROCESSING", e[e.DONE = 1] = "DONE";
})(Ks || (Ks = {})), function(e) {
  e.NEWNODE = "newnode", e.REMOVENODE = "removenode", e.CLAIM_HOST = "claimhost", e.SYNC_HOST = "synchost", e.REQUEST_LOCK = "requestlock", e.ACQUIRE_LOCK = "acquirelock", e.RELEASE_LOCK = "releaselock";
}(xl || (xl = {}));
var Nd, FZ = {}, zW = function() {
  function e(n, t) {
    t === void 0 && (t = {});
    var l = this;
    return this._state = Ks.PROCESSING, this._queue = [], this._activationQueue = [], FZ[n] && !t.forceCreate || (this.nodeId = xu(), this.key = n, cR() && (t.startAsInvisible ? this.registerNode() : document.visibilityState === "visible" ? this.claimHost() : this.registerNode(), document.addEventListener("visibilitychange", function() {
      document.visibilityState === "visible" && l.claimHost();
    }), window.addEventListener("message", function(a) {
      var d, r, i = a.data, c = i.nodeId, V = i.requestId, s = i.key, o = i.op, U = i.data;
      if (c !== l.nodeId && s === l.key)
        switch (o) {
          case xl.NEWNODE:
            l._sendSync();
            break;
          case xl.CLAIM_HOST:
            l._sendSync(), l._hostId = c;
            break;
          case xl.SYNC_HOST:
            if (!l.isInSync) {
              l._activationTimeout && clearTimeout(l._activationTimeout);
              var N = U, R = N.currentItemRequestId, h = N.queue, Z = function(E) {
                var u = l._queue.findIndex(function(b) {
                  return b.requestId === E.requestId;
                });
                u < 0 && l._requestLock({ nodeId: E.nodeId, requestId: E.requestId, key: l.key, op: xl.REQUEST_LOCK, ts: E.ts });
              };
              try {
                for (var W = be(h), F = W.next(); !F.done; F = W.next())
                  Z(F.value);
              } catch (E) {
                d = { error: E };
              } finally {
                try {
                  F && !F.done && (r = W.return) && r.call(W);
                } finally {
                  if (d)
                    throw d.error;
                }
              }
              l._currentItem = l._queue.find(function(E) {
                return E.requestId === R;
              }), l._completeSync();
            }
            break;
          case xl.REMOVENODE:
            l._queue = l._queue.filter(function(E) {
              return E.nodeId !== i.nodeId;
            }), l._currentItem && l._currentItem.nodeId === i.nodeId && (l._currentItem = void 0, l._acquire(l._queue[0]));
            break;
          case xl.REQUEST_LOCK:
            l._requestLock(i);
            break;
          case xl.ACQUIRE_LOCK:
            var m = l._queue.find(function(E) {
              return E.requestId === V;
            });
            l._acquire(m);
            break;
          case xl.RELEASE_LOCK:
            l._release(V);
        }
    }), window.addEventListener("beforeunload", function() {
      l._send(xl.REMOVENODE);
    })), FZ[n] = this), FZ[n];
  }
  return Object.defineProperty(e.prototype, "locked", { get: function() {
    return !!this._currentItem;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "isHost", { get: function() {
    return this._hostId === this.nodeId;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "isInSync", { get: function() {
    return this._state == Ks.DONE;
  }, enumerable: !1, configurable: !0 }), e.prototype._send = function(n, t) {
    var l;
    t === void 0 && (t = {});
    var a = { nodeId: this.nodeId, requestId: (l = t == null ? void 0 : t.requestId) !== null && l !== void 0 ? l : xu(), key: this.key, op: n, data: t.data, ts: Date.now() };
    return cR() && window.postMessage(a, "*"), a;
  }, e.prototype._acquire = function(n) {
    n ? (this._currentItem = n, this._currentItem.onAcquired && this._currentItem.onAcquired(n.requestId)) : this._currentItem = void 0;
  }, e.prototype._release = function(n) {
    if (this._currentItem && this._currentItem.requestId === n) {
      var t = this._currentItem;
      this._currentItem = void 0, t.nodeId === this.nodeId && this._send(xl.RELEASE_LOCK, { requestId: t.requestId });
      var l = this._queue.findIndex(function(a) {
        return a.requestId === n;
      });
      l > -1 && this._queue.splice(l, 1), t.onReleased && t.onReleased(n);
    }
  }, e.prototype._requestLock = function(n) {
    var t = this;
    return new Promise(function(l) {
      var a = { nodeId: n.nodeId, requestId: n.requestId, ts: n.ts, onAcquired: function(i) {
        t.isHost && t._send(xl.ACQUIRE_LOCK, { requestId: i }), l();
      }, onReleased: function() {
        t._acquire(t._queue[0]);
      } }, d = !1;
      for (var r in t._queue)
        if (t._queue[r].ts > a.ts) {
          t._queue.splice(parseInt(r), 0, a), d = !0;
          break;
        }
      d || t._queue.push(a), t._currentItem || t._acquire(t._queue[0]);
    });
  }, e.prototype._sendSync = function() {
    var n;
    this.isHost && this._send(xl.SYNC_HOST, { data: { currentItemRequestId: (n = this._currentItem) === null || n === void 0 ? void 0 : n.requestId, queue: this._queue.map(function(t) {
      return { nodeId: t.nodeId, requestId: t.requestId, ts: t.ts };
    }) } });
  }, e.prototype._waitUntilSyncCompleted = function() {
    return M(this, void 0, void 0, function() {
      var n = this;
      return p(this, function(t) {
        return this.isHost && !this.isInSync ? [2, new Promise(function(l) {
          n._activationQueue.push(l);
        })] : [2];
      });
    });
  }, e.prototype._waitSync = function() {
    var n = this;
    this.isInSync || (this._activationTimeout = setTimeout(function() {
      n._completeSync();
    }, 8));
  }, e.prototype._completeSync = function() {
    this.isInSync || (this._state = Ks.DONE, this._activationQueue.forEach(function(n) {
      return n();
    }), this._activationQueue = []);
  }, e.prototype.registerNode = function() {
    this._send(xl.NEWNODE), this._waitSync();
  }, e.prototype.claimHost = function() {
    this._hostId = this.nodeId, this._send(xl.CLAIM_HOST), this._waitSync();
  }, e.prototype.lock = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this._waitUntilSyncCompleted()];
          case 1:
            return t.sent(), n = this._send(xl.REQUEST_LOCK), [4, this._requestLock(n)];
          case 2:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.unlock = function() {
    var n;
    !((n = this._currentItem) === null || n === void 0) && n.requestId && this._release(this._currentItem.requestId);
  }, e;
}(), WZ = function() {
  function e(n) {
    var t = n.dbname, l = n.collectionName, a = n.keyName, d = n.keyHash, r = n.indexes, i = n.store, c = this;
    this._state = aV.INIT, this._indexers = [], this.dbname = t, this.name = l, this.keyName = a, this.indexes = ot([[a]], et(r.filter(function(V) {
      return Or.createKey(V) !== c.keyName;
    })), !1), this._keyHash = d, this._store = i, this._mutex = new zW(function(V, s) {
      return "".concat(kV(V, s), ".lock");
    }(t, l)), this._blobContainer = new eB({ dbname: t, collectionName: l, store: i }), this._transaction = new tB({ dbname: t, collectionName: l, store: i });
  }
  return e.metadataOf = function(n, t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = TZ(n, t), [4, l.get(a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, Object.defineProperty(e.prototype, "state", { get: function() {
    return this._state;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "isReady", { get: function() {
    return this._state === aV.READY;
  }, enumerable: !1, configurable: !0 }), e.prototype.init = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r, i, c, V, s, o, U, N, R, h = this;
      return p(this, function(Z) {
        switch (Z.label) {
          case 0:
            return [4, this._mutex.lock()];
          case 1:
            Z.sent(), Z.label = 2;
          case 2:
            return Z.trys.push([2, 9, , 10]), n = nU.get(this.dbname), [4, e.metadataOf(this.dbname, this.name, this._store)];
          case 3:
            return t = Z.sent(), this._metadata = t || { keyName: this.keyName, blockLevel: 1, blockHashBase: n.blockHashBase, blockHashMultiplier: n.blockHashMultiplier, blockHashConstant: n.blockHashConstant, indexes: this.indexes }, [4, this._transaction.init()];
          case 4:
            Z.sent(), this._blockManager = new nB({ dbname: this.dbname, collectionName: this.name, hashFunction: this._keyHash, metadata: this._metadata, transaction: this._transaction, store: this._store }), l = ot([], et(this.indexes), !1), a = [], d = l.map(function(W) {
              return Or.createKey(W);
            }), r = t ? t.indexes.map(function(W) {
              return Or.createKey(W);
            }) : [];
            try {
              for (i = be(r), c = i.next(); !c.done; c = i.next())
                V = c.value, d.includes(V) || a.push(Or.parseKey(V));
            } catch (W) {
              N = { error: W };
            } finally {
              try {
                c && !c.done && (R = i.return) && R.call(i);
              } finally {
                if (N)
                  throw N.error;
              }
            }
            return (s = []).push.apply(s, ot([], et(l.map(function(W) {
              var F = new Or({ dbname: h.dbname, collectionName: h.name, keyName: h.keyName, fields: W, transaction: h._transaction, store: h._store });
              return h._indexers.push(F), F.ensure();
            })), !1)), s.push.apply(s, ot([], et(a.map(function(W) {
              return new Or({ dbname: h.dbname, collectionName: h.name, keyName: h.keyName, fields: W, transaction: h._transaction, store: h._store }).drop();
            })), !1)), [4, Promise.all(s)];
          case 5:
            return Z.sent(), [4, this._transaction.commit()];
          case 6:
            return Z.sent(), d.sort().join(",") === r.sort().join(",") ? [3, 8] : (o = TZ(this.dbname, this.name), this._metadata.indexes = l, [4, this._store.set({ key: o, value: this._metadata })]);
          case 7:
            Z.sent(), Z.label = 8;
          case 8:
            return this._state = aV.READY, this._mutex.unlock(), [3, 10];
          case 9:
            throw U = Z.sent(), this._mutex.unlock(), U;
          case 10:
            return [2];
        }
      });
    });
  }, e.prototype.close = function() {
    this._state = aV.CLOSED;
  }, e.prototype._hasPropertyOfKeyName = function(n) {
    var t = n[this.keyName];
    return typeof t == "string" && !!t;
  }, e.prototype._getIndexerBy = function(n) {
    var t, l;
    n === void 0 && (n = null), n || (n = [this.keyName]);
    var a = Or.createKey(n);
    try {
      for (var d = be(this._indexers), r = d.next(); !r.done; r = d.next()) {
        var i = r.value;
        if (a === Or.createKey(i.fields))
          return i;
      }
    } catch (c) {
      t = { error: c };
    } finally {
      try {
        r && !r.done && (l = d.return) && l.call(d);
      } finally {
        if (t)
          throw t.error;
      }
    }
    throw dn.indexTableIsRequired;
  }, e.prototype._upgradeBlockLevel = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return n = TZ(this.dbname, this.name), this._metadata.blockLevel++, [4, this._store.set({ key: n, value: this._metadata })];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype._requestInsert = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return t = n[this.keyName], [4, this._blockManager.getFromBlock(t)];
          case 1:
            return c.sent() ? [3, 13] : [4, this._blockManager.putToBlock(t, n)];
          case 2:
            return c.sent() ? [3, 5] : [4, this._upgradeBlockLevel()];
          case 3:
            return c.sent(), [4, this._blockManager.putToBlock(t, n)];
          case 4:
            c.sent(), c.label = 5;
          case 5:
            c.trys.push([5, 10, 11, 12]), l = be(this._indexers), a = l.next(), c.label = 6;
          case 6:
            return a.done ? [3, 9] : [4, a.value.addItem(n)];
          case 7:
            c.sent(), c.label = 8;
          case 8:
            return a = l.next(), [3, 6];
          case 9:
            return [3, 12];
          case 10:
            return d = c.sent(), r = { error: d }, [3, 12];
          case 11:
            try {
              a && !a.done && (i = l.return) && i.call(l);
            } finally {
              if (r)
                throw r.error;
            }
            return [7];
          case 12:
            return [3, 14];
          case 13:
            throw dn.collectionInsertDuplicate;
          case 14:
            return [2];
        }
      });
    });
  }, e.prototype._requestUpsert = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V, s, o, U, N, R;
      return p(this, function(h) {
        switch (h.label) {
          case 0:
            return t = n[this.keyName], [4, this._blockManager.getFromBlock(t)];
          case 1:
            return (l = h.sent()) ? [3, 13] : [4, this._blockManager.putToBlock(t, n)];
          case 2:
            return h.sent() ? [3, 5] : [4, this._upgradeBlockLevel()];
          case 3:
            return h.sent(), [4, this._blockManager.putToBlock(t, n)];
          case 4:
            h.sent(), h.label = 5;
          case 5:
            h.trys.push([5, 10, 11, 12]), a = be(this._indexers), d = a.next(), h.label = 6;
          case 6:
            return d.done ? [3, 9] : [4, (V = d.value).addItem(n)];
          case 7:
            h.sent(), h.label = 8;
          case 8:
            return d = a.next(), [3, 6];
          case 9:
            return [3, 12];
          case 10:
            return r = h.sent(), o = { error: r }, [3, 12];
          case 11:
            try {
              d && !d.done && (U = a.return) && U.call(a);
            } finally {
              if (o)
                throw o.error;
            }
            return [7];
          case 12:
            return [3, 23];
          case 13:
            return [4, this._blockManager.putToBlock(t, n)];
          case 14:
            h.sent(), h.label = 15;
          case 15:
            h.trys.push([15, 21, 22, 23]), i = be(this._indexers), c = i.next(), h.label = 16;
          case 16:
            return c.done ? [3, 20] : (V = c.value).diff(V.getColumnValues(l), V.getColumnValues(n)) === 0 ? [3, 19] : [4, V.removeItem(l)];
          case 17:
            return h.sent(), [4, V.addItem(n)];
          case 18:
            h.sent(), h.label = 19;
          case 19:
            return c = i.next(), [3, 16];
          case 20:
            return [3, 23];
          case 21:
            return s = h.sent(), N = { error: s }, [3, 23];
          case 22:
            try {
              c && !c.done && (R = i.return) && R.call(i);
            } finally {
              if (N)
                throw N.error;
            }
            return [7];
          case 23:
            return [2];
        }
      });
    });
  }, e.prototype._requestUpdate = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return t = n[this.keyName], [4, this._blockManager.getFromBlock(t)];
          case 1:
            return (l = s.sent()) ? [4, this._blockManager.putToBlock(t, n)] : [3, 11];
          case 2:
            s.sent(), s.label = 3;
          case 3:
            s.trys.push([3, 9, 10, 11]), a = be(this._indexers), d = a.next(), s.label = 4;
          case 4:
            return d.done ? [3, 8] : (r = d.value).diff(r.getColumnValues(l), r.getColumnValues(n)) === 0 ? [3, 7] : [4, r.removeItem(l)];
          case 5:
            return s.sent(), [4, r.addItem(n)];
          case 6:
            s.sent(), s.label = 7;
          case 7:
            return d = a.next(), [3, 4];
          case 8:
            return [3, 11];
          case 9:
            return i = s.sent(), c = { error: i }, [3, 11];
          case 10:
            try {
              d && !d.done && (V = a.return) && V.call(a);
            } finally {
              if (c)
                throw c.error;
            }
            return [7];
          case 11:
            return [2];
        }
      });
    });
  }, e.prototype._requestRemove = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return [4, this._blockManager.getFromBlock(n)];
          case 1:
            return (t = c.sent()) ? [4, this._blockManager.removeFromBlock(n)] : [3, 10];
          case 2:
            c.sent(), c.label = 3;
          case 3:
            c.trys.push([3, 8, 9, 10]), l = be(this._indexers), a = l.next(), c.label = 4;
          case 4:
            return a.done ? [3, 7] : [4, a.value.removeItem(t)];
          case 5:
            c.sent(), c.label = 6;
          case 6:
            return a = l.next(), [3, 4];
          case 7:
            return [3, 10];
          case 8:
            return d = c.sent(), r = { error: d }, [3, 10];
          case 9:
            try {
              a && !a.done && (i = l.return) && i.call(l);
            } finally {
              if (r)
                throw r.error;
            }
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }, e.prototype._requestClear = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this._blockManager.clearAllBlocks()];
          case 1:
            r.sent(), r.label = 2;
          case 2:
            r.trys.push([2, 7, 8, 9]), n = be(this._indexers), t = n.next(), r.label = 3;
          case 3:
            return t.done ? [3, 6] : [4, t.value.clear()];
          case 4:
            r.sent(), r.label = 5;
          case 5:
            return t = n.next(), [3, 3];
          case 6:
            return [3, 9];
          case 7:
            return l = r.sent(), a = { error: l }, [3, 9];
          case 8:
            try {
              t && !t.done && (d = n.return) && d.call(n);
            } finally {
              if (a)
                throw a.error;
            }
            return [7];
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype.getByKey = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 6];
          case 1:
            a.sent(), a.label = 2;
          case 2:
            return a.trys.push([2, 4, , 5]), [4, this._blockManager.getFromBlock(n)];
          case 3:
            return t = a.sent(), this._mutex.unlock(), [2, ea(t)];
          case 4:
            throw l = a.sent(), this._mutex.unlock(), l;
          case 5:
            return [3, 7];
          case 6:
            throw dn.collectionNotReady;
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.query = function(n) {
    if (n === void 0 && (n = {}), this.isReady)
      return new $5({ condition: n.where, mutex: this._mutex, blockManager: this._blockManager, indexer: this._getIndexerBy(n.index), backward: !!n.backward });
    throw dn.collectionNotReady;
  }, e.prototype.insertOne = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 8];
          case 1:
            l.sent(), l.label = 2;
          case 2:
            if (l.trys.push([2, 5, , 7]), !this._hasPropertyOfKeyName(n))
              throw dn.collectionKeyNotGiven;
            return [4, this._requestInsert(ea(n))];
          case 3:
            return l.sent(), [4, this._transaction.commit()];
          case 4:
            return l.sent(), this._mutex.unlock(), [2, n];
          case 5:
            return t = l.sent(), [4, this._transaction.clear()];
          case 6:
            throw l.sent(), this._mutex.unlock(), t;
          case 7:
            return [3, 9];
          case 8:
            throw dn.collectionNotReady;
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype.insertMany = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V = this;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 15];
          case 1:
            s.sent(), s.label = 2;
          case 2:
            if (s.trys.push([2, 12, , 14]), n.some(function(o) {
              return !V._hasPropertyOfKeyName(o);
            }))
              throw dn.collectionKeyNotGiven;
            s.label = 3;
          case 3:
            s.trys.push([3, 8, 9, 10]), t = be(n), l = t.next(), s.label = 4;
          case 4:
            return l.done ? [3, 7] : (a = l.value, [4, this._requestInsert(ea(a))]);
          case 5:
            s.sent(), s.label = 6;
          case 6:
            return l = t.next(), [3, 4];
          case 7:
            return [3, 10];
          case 8:
            return d = s.sent(), i = { error: d }, [3, 10];
          case 9:
            try {
              l && !l.done && (c = t.return) && c.call(t);
            } finally {
              if (i)
                throw i.error;
            }
            return [7];
          case 10:
            return [4, this._transaction.commit()];
          case 11:
            return s.sent(), this._mutex.unlock(), [2, n];
          case 12:
            return r = s.sent(), [4, this._transaction.clear()];
          case 13:
            throw s.sent(), this._mutex.unlock(), r;
          case 14:
            return [3, 16];
          case 15:
            throw dn.collectionNotReady;
          case 16:
            return [2];
        }
      });
    });
  }, e.prototype.upsertOne = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 8];
          case 1:
            l.sent(), l.label = 2;
          case 2:
            if (l.trys.push([2, 5, , 7]), !this._hasPropertyOfKeyName(n))
              throw dn.collectionKeyNotGiven;
            return [4, this._requestUpsert(ea(n))];
          case 3:
            return l.sent(), [4, this._transaction.commit()];
          case 4:
            return l.sent(), this._mutex.unlock(), [2, n];
          case 5:
            return t = l.sent(), [4, this._transaction.clear()];
          case 6:
            throw l.sent(), this._mutex.unlock(), t;
          case 7:
            return [3, 9];
          case 8:
            throw dn.collectionNotReady;
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype.upsertMany = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V = this;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 15];
          case 1:
            s.sent(), s.label = 2;
          case 2:
            if (s.trys.push([2, 12, , 14]), n.some(function(o) {
              return !V._hasPropertyOfKeyName(o);
            }))
              throw dn.collectionKeyNotGiven;
            s.label = 3;
          case 3:
            s.trys.push([3, 8, 9, 10]), t = be(n), l = t.next(), s.label = 4;
          case 4:
            return l.done ? [3, 7] : (a = l.value, [4, this._requestUpsert(ea(a))]);
          case 5:
            s.sent(), s.label = 6;
          case 6:
            return l = t.next(), [3, 4];
          case 7:
            return [3, 10];
          case 8:
            return d = s.sent(), i = { error: d }, [3, 10];
          case 9:
            try {
              l && !l.done && (c = t.return) && c.call(t);
            } finally {
              if (i)
                throw i.error;
            }
            return [7];
          case 10:
            return [4, this._transaction.commit()];
          case 11:
            return s.sent(), this._mutex.unlock(), [2, n];
          case 12:
            return r = s.sent(), [4, this._transaction.clear()];
          case 13:
            throw s.sent(), this._mutex.unlock(), r;
          case 14:
            return [3, 16];
          case 15:
            throw dn.collectionNotReady;
          case 16:
            return [2];
        }
      });
    });
  }, e.prototype.update = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 8];
          case 1:
            l.sent(), l.label = 2;
          case 2:
            if (l.trys.push([2, 5, , 7]), !this._hasPropertyOfKeyName(n))
              throw dn.collectionKeyNotGiven;
            return [4, this._requestUpdate(ea(n))];
          case 3:
            return l.sent(), [4, this._transaction.commit()];
          case 4:
            return l.sent(), this._mutex.unlock(), [2, n];
          case 5:
            return t = l.sent(), [4, this._transaction.clear()];
          case 6:
            throw l.sent(), this._mutex.unlock(), t;
          case 7:
            return [3, 9];
          case 8:
            throw dn.collectionNotReady;
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype.updateIf = function(n, t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W = this;
      return p(this, function(F) {
        switch (F.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 16];
          case 1:
            F.sent(), F.label = 2;
          case 2:
            return F.trys.push([2, 13, , 15]), l = n.where, a = l === void 0 ? {} : l, d = n.index, r = d === void 0 ? null : d, i = n.backward, c = i !== void 0 && i, V = [], [4, new CT({ condition: a, blockManager: this._blockManager, backward: c, indexer: this._getIndexerBy(r) }).each(function(m) {
              return M(W, void 0, void 0, function() {
                var E, u;
                return p(this, function(b) {
                  if (m.error)
                    throw m.stop(), m.error;
                  if (m.hasNext) {
                    if (E = m.nextValue, WV(a, E) && t.set) {
                      if (typeof t.set != "function")
                        for (u in t.set)
                          E[u] = t.set[u];
                      else
                        t.set(E);
                      V.push(E);
                    }
                    m.next();
                  } else
                    m.stop();
                  return [2];
                });
              });
            })];
          case 3:
            F.sent(), F.label = 4;
          case 4:
            F.trys.push([4, 9, 10, 11]), s = be(V), o = s.next(), F.label = 5;
          case 5:
            return o.done ? [3, 8] : (U = o.value, [4, this._requestUpdate(ea(U))]);
          case 6:
            F.sent(), F.label = 7;
          case 7:
            return o = s.next(), [3, 5];
          case 8:
            return [3, 11];
          case 9:
            return N = F.sent(), h = { error: N }, [3, 11];
          case 10:
            try {
              o && !o.done && (Z = s.return) && Z.call(s);
            } finally {
              if (h)
                throw h.error;
            }
            return [7];
          case 11:
            return [4, this._transaction.commit()];
          case 12:
            return F.sent(), this._mutex.unlock(), [2, V];
          case 13:
            return R = F.sent(), [4, this._transaction.clear()];
          case 14:
            throw F.sent(), this._mutex.unlock(), R;
          case 15:
            return [3, 17];
          case 16:
            throw this._transaction.clear(), dn.collectionNotReady;
          case 17:
            return [2];
        }
      });
    });
  }, e.prototype.remove = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 8];
          case 1:
            l.sent(), l.label = 2;
          case 2:
            return l.trys.push([2, 5, , 7]), [4, this._requestRemove(n)];
          case 3:
            return l.sent(), [4, this._transaction.commit()];
          case 4:
            return l.sent(), this._mutex.unlock(), [3, 7];
          case 5:
            return t = l.sent(), [4, this._transaction.clear()];
          case 6:
            throw l.sent(), this._mutex.unlock(), t;
          case 7:
            return [3, 9];
          case 8:
            throw dn.collectionNotReady;
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype.removeIf = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V, s, o, U, N, R, h, Z = this;
      return p(this, function(W) {
        switch (W.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 15];
          case 1:
            W.sent(), W.label = 2;
          case 2:
            return W.trys.push([2, 13, , 14]), t = n.where, l = t === void 0 ? {} : t, a = n.index, d = a === void 0 ? null : a, r = n.backward, i = r !== void 0 && r, c = [], [4, new CT({ condition: l, blockManager: this._blockManager, backward: i, indexer: this._getIndexerBy(d) }).each(function(F) {
              return M(Z, void 0, void 0, function() {
                var m, E;
                return p(this, function(u) {
                  if (F.error)
                    throw F.stop(), F.error;
                  return F.hasNext ? (m = F.nextValue, WV(l, m) && (E = m[this.keyName], c.push(E)), F.next()) : F.stop(), [2];
                });
              });
            })];
          case 3:
            W.sent(), W.label = 4;
          case 4:
            W.trys.push([4, 9, 10, 11]), V = be(c), s = V.next(), W.label = 5;
          case 5:
            return s.done ? [3, 8] : (o = s.value, [4, this._requestRemove(o)]);
          case 6:
            W.sent(), W.label = 7;
          case 7:
            return s = V.next(), [3, 5];
          case 8:
            return [3, 11];
          case 9:
            return U = W.sent(), R = { error: U }, [3, 11];
          case 10:
            try {
              s && !s.done && (h = V.return) && h.call(V);
            } finally {
              if (R)
                throw R.error;
            }
            return [7];
          case 11:
            return [4, this._transaction.commit()];
          case 12:
            return W.sent(), this._mutex.unlock(), [2, c];
          case 13:
            throw N = W.sent(), this._mutex.unlock(), N;
          case 14:
            return [3, 16];
          case 15:
            throw this._transaction.clear(), dn.collectionNotReady;
          case 16:
            return [2];
        }
      });
    });
  }, e.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this.isReady ? [4, this._mutex.lock()] : [3, 8];
          case 1:
            t.sent(), t.label = 2;
          case 2:
            return t.trys.push([2, 5, , 7]), [4, this._requestClear()];
          case 3:
            return t.sent(), [4, this._transaction.commit()];
          case 4:
            return t.sent(), this._mutex.unlock(), [3, 7];
          case 5:
            return n = t.sent(), [4, this._transaction.clear()];
          case 6:
            throw t.sent(), this._mutex.unlock(), n;
          case 7:
            return [3, 9];
          case 8:
            throw dn.collectionNotReady;
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype.getBlob = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this._blobContainer.get(n)];
          case 1:
            return [2, t.sent()];
        }
      });
    });
  }, e.prototype.saveBlob = function(n, t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._blobContainer.save(n, t)];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, e.prototype.removeBlob = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this._blobContainer.remove(n)];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.removeAllBlobs = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, this._blobContainer.clear()];
          case 1:
            return n.sent(), [2];
        }
      });
    });
  }, e;
}(), mZ = "[NESTDB]", _U = !0, Oi = function() {
  function e() {
  }
  return e.off = function() {
    _U = !1;
  }, e.log = function() {
    for (var n = [], t = 0; t < arguments.length; t++)
      n[t] = arguments[t];
    _U && console.log.apply(console, ot(["".concat(mZ, "[LOG]")], et(n), !1));
  }, e.warning = function() {
    for (var n = [], t = 0; t < arguments.length; t++)
      n[t] = arguments[t];
    _U && console.warn.apply(console, ot(["".concat(mZ, "[WARNING]")], et(n), !1));
  }, e.error = function() {
    for (var n = [], t = 0; t < arguments.length; t++)
      n[t] = arguments[t];
    _U && console.error.apply(console, ot(["".concat(mZ, "[ERROR]")], et(n), !1));
  }, e;
}(), lB = [{}, { a: 700400, n: "error" }], qR = function() {
  function e(n) {
    var t, l, a;
    this.encryption = (t = n.encryption) !== null && t !== void 0 ? t : Wk, this.itemSizeLimit = (l = n.itemSizeLimit) !== null && l !== void 0 ? l : 4194304, this.metadataBuffer = (a = n.metadataBuffer) !== null && a !== void 0 ? a : 256;
  }
  return Object.defineProperty(e.prototype, "_encryptionCheckKey", { get: function() {
    return "".concat(this.dbname, ".encrypt");
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "_reservedKeys", { get: function() {
    return [this._encryptionCheckKey];
  }, enumerable: !1, configurable: !0 }), e.prototype._getRawKey = function(n, t) {
    return t === void 0 && (t = ""), "".concat(n).concat(t);
  }, e.prototype._generateShardPostfixArray = function(n) {
    return n === void 0 && (n = 1), ot([], et(Array(n).keys()), !1);
  }, e.prototype._shardify = function(n) {
    var t = this, l = n.key, a = n.value, d = JSON.stringify(this.encryption.encrypt(a)), r = Math.ceil(d.length / this.adjustedItemSizeLimit);
    return this._generateShardPostfixArray(r).map(function(i) {
      var c = { key: t._getRawKey(l, ".".concat(i)), data: d.substring(i * t.adjustedItemSizeLimit, (i + 1) * t.adjustedItemSizeLimit) };
      return i === 0 && (c.metadata = { shards: r }), c;
    });
  }, e.prototype._resetIfEncryptionChanged = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r, i, c, V, s = this;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, this.get(this._encryptionCheckKey)];
          case 1:
            if (n = o.sent(), t = { encrypted: lB.map(function(U) {
              var N;
              return (N = s.encryption) === null || N === void 0 ? void 0 : N.encrypt(U);
            }) }, !(n && n.encrypted && Array.isArray(n.encrypted)))
              return [3, 6];
            for (d in l = n.encrypted, a = [], l)
              a.push(d);
            r = 0, o.label = 2;
          case 2:
            return r < a.length ? (d = a[r]) in l ? (i = d, c = JSON.stringify(n.encrypted[i]), V = JSON.stringify(t.encrypted[i]), c === V ? [3, 4] : (Oi.warning("Encryption algorithm has changed. Stored data would be cleared."), [4, this.clear()])) : [3, 4] : [3, 5];
          case 3:
            return o.sent(), [3, 5];
          case 4:
            return r++, [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return [4, this.clear()];
          case 7:
            o.sent(), o.label = 8;
          case 8:
            return [4, this.set({ key: this._encryptionCheckKey, value: t })];
          case 9:
            return o.sent(), [2];
        }
      });
    });
  }, Object.defineProperty(e.prototype, "adjustedItemSizeLimit", { get: function() {
    return Math.max(this.itemSizeLimit - this.metadataBuffer, 4);
  }, enumerable: !1, configurable: !0 }), e.prototype.usage = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return n = 0, [4, this._getAllRawKeys()];
          case 1:
            t = s.sent(), s.label = 2;
          case 2:
            s.trys.push([2, 7, 8, 9]), l = be(t), a = l.next(), s.label = 3;
          case 3:
            return a.done ? [3, 6] : (d = a.value, [4, this._getRaw(d)]);
          case 4:
            (r = s.sent()) && (n += JSON.stringify(r).length), s.label = 5;
          case 5:
            return a = l.next(), [3, 3];
          case 6:
            return [3, 9];
          case 7:
            return i = s.sent(), c = { error: i }, [3, 9];
          case 8:
            try {
              a && !a.done && (V = l.return) && V.call(l);
            } finally {
              if (c)
                throw c.error;
            }
            return [7];
          case 9:
            return [2, n];
        }
      });
    });
  }, e.prototype.getAllKeys = function() {
    return M(this, void 0, void 0, function() {
      var n = this;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this._getAllRawKeys()];
          case 1:
            return [2, t.sent().filter(function(l) {
              return l.endsWith(".0");
            }).map(function(l) {
              return l.replace(/\.0$/, "");
            }).filter(function(l) {
              return !n._reservedKeys.includes(l);
            })];
        }
      });
    });
  }, e.prototype.get = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c = this;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return t = this._getRawKey(n, ".0"), [4, this._getRaw(t)];
          case 1:
            if (!(l = V.sent()))
              return [3, 7];
            V.label = 2;
          case 2:
            return V.trys.push([2, 6, , 7]), a = l.data, (d = l.metadata) != null && d.shards && d.shards > 1 ? [4, Promise.all(this._generateShardPostfixArray(d == null ? void 0 : d.shards).map(function(s) {
              return M(c, void 0, void 0, function() {
                var o, U;
                return p(this, function(N) {
                  switch (N.label) {
                    case 0:
                      return s > 0 ? (o = this._getRawKey(n, ".".concat(s)), [4, this._getRaw(o)]) : [3, 2];
                    case 1:
                      if (!(U = N.sent()))
                        throw dn.storeBrokenIntegrity;
                      return [2, U.data];
                    case 2:
                      return [2, a];
                  }
                });
              });
            }))] : [3, 4];
          case 3:
            return i = V.sent(), [3, 5];
          case 4:
            i = [a], V.label = 5;
          case 5:
            return r = i, [2, this.encryption.decrypt(JSON.parse(r.join("")))];
          case 6:
            return V.sent(), [2, null];
          case 7:
            return [2, null];
        }
      });
    });
  }, e.prototype.set = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return t = this._shardify(n), [4, this._setRaw(t)];
          case 1:
            return l.sent(), [2, x({}, n.value)];
        }
      });
    });
  }, e.prototype.setMany = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = [], [4, this._setRaw(t.concat.apply(t, ot([], et(n.map(function(d) {
              return l._shardify(d);
            })), !1)))];
          case 1:
            return a.sent(), [2, n.map(function(d) {
              return d.value;
            })];
        }
      });
    });
  }, e.prototype.remove = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d = this;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return t = this._getRawKey(n, ".0"), [4, this._getRaw(t)];
          case 1:
            return (l = r.sent()) ? (a = l.metadata, [4, this._removeRaw(this._generateShardPostfixArray(a == null ? void 0 : a.shards).map(function(i) {
              return d._getRawKey(n, ".".concat(i));
            }))]) : [3, 3];
          case 2:
            return r.sent(), [2, !0];
          case 3:
            return [2, !1];
        }
      });
    });
  }, e.prototype.removeMany = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V, s, o = this;
      return p(this, function(U) {
        switch (U.label) {
          case 0:
            t = [], l = function(N) {
              var R, h, Z;
              return p(this, function(W) {
                switch (W.label) {
                  case 0:
                    return R = a._getRawKey(N, ".0"), [4, a._getRaw(R)];
                  case 1:
                    return (h = W.sent()) && (Z = h.metadata, t.push.apply(t, ot([], et(a._generateShardPostfixArray(Z == null ? void 0 : Z.shards).map(function(F) {
                      return o._getRawKey(N, ".".concat(F));
                    })), !1))), [2];
                }
              });
            }, a = this, U.label = 1;
          case 1:
            U.trys.push([1, 6, 7, 8]), d = be(n), r = d.next(), U.label = 2;
          case 2:
            return r.done ? [3, 5] : (i = r.value, [5, l(i)]);
          case 3:
            U.sent(), U.label = 4;
          case 4:
            return r = d.next(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return c = U.sent(), V = { error: c }, [3, 8];
          case 7:
            try {
              r && !r.done && (s = d.return) && s.call(d);
            } finally {
              if (V)
                throw V.error;
            }
            return [7];
          case 8:
            return t.length > 0 ? [4, this._removeRaw(t)] : [3, 10];
          case 9:
            U.sent(), U.label = 10;
          case 10:
            return [2, n];
        }
      });
    });
  }, e;
}(), Pl = {}, Pr = function(e) {
  function n(t) {
    t === void 0 && (t = {});
    var l, a = this;
    a = e.call(this, x(x({}, t), { itemSizeLimit: (l = t.itemSizeLimit) !== null && l !== void 0 ? l : 4194304 })) || this;
    var d = t.delay, r = d === void 0 ? 1 : d;
    return a.delay = r, a.observer = {}, a;
  }
  return J(n, e), Object.defineProperty(n.prototype, "rawData", { get: function() {
    return Pl[this.dbname];
  }, set: function(t) {
    Pl[this.dbname] = t;
  }, enumerable: !1, configurable: !0 }), n.prototype._getAllRawKeys = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        if (Pl[this.dbname])
          return [2, Object.keys(Pl[this.dbname])];
        throw dn.storeNotAvailable;
      });
    });
  }, n.prototype._getRaw = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return Pl[this.dbname] ? [4, CU(this.delay)] : [3, 2];
          case 1:
            return l.sent(), [2, Pl[this.dbname][t] ? x({ key: t }, Pl[this.dbname][t]) : null];
          case 2:
            throw dn.storeNotAvailable;
        }
      });
    });
  }, n.prototype._setRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            return Pl[this.dbname] ? [4, CU(this.delay)] : [3, 2];
          case 1:
            o.sent();
            try {
              for (l = be(t), a = l.next(); !a.done; a = l.next())
                d = a.value, r = d.key, i = d.data, c = d.metadata, Pl[this.dbname][r] = Object.freeze({ data: i, metadata: c });
            } catch (U) {
              V = { error: U };
            } finally {
              try {
                a && !a.done && (s = l.return) && s.call(l);
              } finally {
                if (V)
                  throw V.error;
              }
            }
            return [3, 3];
          case 2:
            throw dn.storeNotAvailable;
          case 3:
            return [2];
        }
      });
    });
  }, n.prototype._removeRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return Pl[this.dbname] ? [4, CU(this.delay)] : [3, 2];
          case 1:
            c.sent();
            try {
              for (l = be(t), a = l.next(); !a.done; a = l.next())
                d = a.value, Pl[this.dbname][d] && delete Pl[this.dbname][d];
            } catch (V) {
              r = { error: V };
            } finally {
              try {
                a && !a.done && (i = l.return) && i.call(l);
              } finally {
                if (r)
                  throw r.error;
              }
            }
            return [3, 3];
          case 2:
            throw dn.storeNotAvailable;
          case 3:
            return [2];
        }
      });
    });
  }, n.prototype.observe = function(t, l, a) {
    var d = this;
    this.observer[t] || (this.observer[t] = {}), l.forEach(function(r) {
      return d.observer[t][r] = a;
    });
  }, n.prototype.checkAvailability = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return [2];
      });
    });
  }, n.prototype.init = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.dbname = t, Pl[this.dbname] || (Pl[this.dbname] = {}), [4, this._resetIfEncryptionChanged()];
          case 1:
            return l.sent(), [2];
        }
      });
    });
  }, n.prototype.set = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        if ((l = this.observer[t.key]) && typeof l.set == "function" && (a = l.set()))
          throw a;
        return [2, e.prototype.set.call(this, t)];
      });
    });
  }, n.prototype.setMany = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V;
      return p(this, function(s) {
        try {
          for (l = be(t), a = l.next(); !a.done; a = l.next())
            if (d = a.value, (r = this.observer[d.key]) && typeof r.set == "function" && (i = r.set()))
              throw i;
        } catch (o) {
          c = { error: o };
        } finally {
          try {
            a && !a.done && (V = l.return) && V.call(l);
          } finally {
            if (c)
              throw c.error;
          }
        }
        return [2, e.prototype.setMany.call(this, t)];
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, CU(this.delay)];
          case 1:
            return t.sent(), Pl[this.dbname] = {}, [2];
        }
      });
    });
  }, n;
}(qR), Gu = "NestDBStore";
(function(e) {
  e[e.UNINITIALIZED = 0] = "UNINITIALIZED", e[e.OPENING = 1] = "OPENING", e[e.OPEN = 2] = "OPEN", e[e.CLOSED = 3] = "CLOSED";
})(Nd || (Nd = {}));
var aB = function(e) {
  function n(t) {
    t === void 0 && (t = {});
    var l, a = this;
    return (a = e.call(this, x(x({}, t), { itemSizeLimit: (l = t.itemSizeLimit) !== null && l !== void 0 ? l : 104857600 })) || this)._storeName = Gu, a._state = Nd.UNINITIALIZED, a._openJobQueue = [], a._window = typeof window < "u" ? window : void 0, a._indexedDb = a._window ? a._window.indexedDB || a._window.mozIndexedDB || a._window.webkitIndexedDB || a._window.msIndexedDB : void 0, a;
  }
  return J(n, e), Object.defineProperty(n.prototype, "state", { get: function() {
    return this._state;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isTransactionReusable", { get: function() {
    var t = navigator == null ? void 0 : navigator.userAgent;
    if (t) {
      var l = "15.0.0";
      if (t.includes("Safari/") ? l = t.split("Safari/")[0].trim().split("Version/")[1] : t.includes("AppleWebKit/") && (l = t.split("AppleWebKit/")[0].trim().split("Version/")[1]), (l ? parseInt(l.split(".")[0]) : 0) <= 14)
        return !1;
    }
    return !0;
  }, enumerable: !1, configurable: !0 }), n.prototype._putToObjectStore = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        return [2, new Promise(function(d, r) {
          var i = t.put(l);
          i.addEventListener("success", function(c) {
            d(c.target.result);
          }), i.addEventListener("error", function() {
            r("Failed to write.");
          });
        })];
      });
    });
  }, n.prototype._deleteFromObjectStore = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        return [2, new Promise(function(d, r) {
          var i = t.delete(l);
          i.addEventListener("success", function() {
            return d(l);
          }), i.addEventListener("error", function(c) {
            return r(c.target.error);
          });
        })];
      });
    });
  }, n.prototype._openDatabase = function(t) {
    var l = this;
    return new Promise(function(a, d) {
      if (l._indexedDb) {
        l._state = Nd.OPENING;
        var r = l._indexedDb.open(t);
        r.addEventListener("upgradeneeded", function(i) {
          i.target.result.createObjectStore(Gu, { keyPath: "key" });
        }), r.addEventListener("success", function(i) {
          l._state = Nd.OPEN, l._database = i.target.result, l._openJobQueue.forEach(function(c) {
            return c();
          }), l._openJobQueue = [], l._database.onclose = function() {
            l._database = void 0, l._state = Nd.OPENING, setTimeout(function() {
              l._openDatabase(t);
            }, 5);
          }, a(l._database);
        }), r.addEventListener("error", function(i) {
          l._state = Nd.UNINITIALIZED, d(i.target.error);
        });
      } else
        d(dn.storeNotAvailable);
    });
  }, n.prototype._getObjectStore = function(t) {
    return M(this, void 0, void 0, function() {
      var l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this._database ? [2, this._database.transaction(this._storeName, t).objectStore(this._storeName)] : [3, 1];
          case 1:
            switch (this._state) {
              case Nd.UNINITIALIZED:
              case Nd.OPEN:
                return [3, 2];
              case Nd.OPENING:
              case Nd.CLOSED:
                return [3, 3];
            }
            return [3, 4];
          case 2:
            throw dn.storeNotInitialized;
          case 3:
            return [2, new Promise(function(d) {
              l._openJobQueue.push(function() {
                return d(l._getObjectStore(t));
              });
            })];
          case 4:
            return [4, this._getObjectStore(t)];
          case 5:
            return [2, a.sent()];
        }
      });
    });
  }, n.prototype._getAllRawKeys = function() {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._getObjectStore("readonly")];
          case 1:
            return t = l.sent(), [4, new Promise(function(a, d) {
              var r = t.getAllKeys();
              r.addEventListener("success", function(i) {
                a(i.target.result);
              }), r.addEventListener("error", function(i) {
                return d(i.target.error);
              });
            })];
          case 2:
            return [2, l.sent()];
        }
      });
    });
  }, n.prototype._getRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._getObjectStore("readonly")];
          case 1:
            return l = a.sent(), [4, new Promise(function(d, r) {
              var i = l.get(t);
              i.addEventListener("success", function(c) {
                var V;
                d((V = c == null ? void 0 : c.target) === null || V === void 0 ? void 0 : V.result);
              }), i.addEventListener("error", function(c) {
                return r(c.target.error);
              });
            })];
          case 2:
            return [2, a.sent()];
        }
      });
    });
  }, n.prototype._setRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s = this;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, this._getObjectStore("readwrite")];
          case 1:
            return l = o.sent(), this.isTransactionReusable ? [4, Promise.all(t.map(function(U) {
              return s._putToObjectStore(l, U);
            }))] : [3, 3];
          case 2:
            return o.sent(), [3, 10];
          case 3:
            o.trys.push([3, 8, 9, 10]), a = be(t), d = a.next(), o.label = 4;
          case 4:
            return d.done ? [3, 7] : (r = d.value, [4, this._putToObjectStore(l, r)]);
          case 5:
            o.sent(), o.label = 6;
          case 6:
            return d = a.next(), [3, 4];
          case 7:
            return [3, 10];
          case 8:
            return i = o.sent(), c = { error: i }, [3, 10];
          case 9:
            try {
              d && !d.done && (V = a.return) && V.call(a);
            } finally {
              if (c)
                throw c.error;
            }
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }, n.prototype._removeRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s = this;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, this._getObjectStore("readwrite")];
          case 1:
            return l = o.sent(), this.isTransactionReusable ? [4, Promise.all(t.map(function(U) {
              return s._deleteFromObjectStore(l, U);
            }))] : [3, 3];
          case 2:
            return o.sent(), [3, 10];
          case 3:
            o.trys.push([3, 8, 9, 10]), a = be(t), d = a.next(), o.label = 4;
          case 4:
            return d.done ? [3, 7] : (r = d.value, [4, this._deleteFromObjectStore(l, r)]);
          case 5:
            o.sent(), o.label = 6;
          case 6:
            return d = a.next(), [3, 4];
          case 7:
            return [3, 10];
          case 8:
            return i = o.sent(), c = { error: i }, [3, 10];
          case 9:
            try {
              d && !d.done && (V = a.return) && V.call(a);
            } finally {
              if (c)
                throw c.error;
            }
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }, n.prototype._triggerDatabaseClose = function() {
    this._database && this._database.onclose && this._database.onclose(new Event("dummy"));
  }, n.prototype.checkAvailability = function() {
    return M(this, void 0, void 0, function() {
      var t, l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            if (!((t = typeof window < "u" ? window : null) != null && t.indexedDB || t != null && t.mozIndexedDB || t != null && t.webkitIndexedDB || t != null && t.msIndexedDB))
              return [3, 6];
            if (this._indexedDb = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB, !this._window || !cR())
              return [3, 4];
            if (!(cR() && navigator.userAgent && navigator.userAgent.includes("Edge/")))
              return [3, 1];
            if (!this._window.indexedDB && (t.PointerEvent || t.MSPointerEvent))
              throw dn.storeNotAvailableInPrivateBrowsing;
            return [3, 3];
          case 1:
            return [4, new Promise(function(d, r) {
              if (l._indexedDb)
                try {
                  var i = l._indexedDb.open("_testMozilla");
                  i.onerror = function() {
                    return r(dn.storeNotAvailableInPrivateBrowsing);
                  }, i.onsuccess = function(c) {
                    if (c.target.result.close(), l._indexedDb) {
                      var V = l._indexedDb.deleteDatabase("_testMozilla");
                      V.onerror = function() {
                        return d();
                      }, V.onsuccess = function() {
                        return d();
                      };
                    } else
                      r(dn.storeNotAvailable);
                  };
                } catch {
                  r(dn.storeNotAvailableInPrivateBrowsing);
                }
              else
                r(dn.storeNotAvailable);
            })];
          case 2:
            a.sent(), a.label = 3;
          case 3:
            return [3, 5];
          case 4:
            throw dn.storeNotAvailable;
          case 5:
            return [3, 7];
          case 6:
            throw dn.storeNotAvailable;
          case 7:
            return [2];
        }
      });
    });
  }, n.prototype.init = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.dbname = t, [4, this.checkAvailability()];
          case 1:
            return l.sent(), [4, this._openDatabase(t)];
          case 2:
            return l.sent(), [4, this._resetIfEncryptionChanged()];
          case 3:
            return l.sent(), [2];
        }
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._getObjectStore("readwrite")];
          case 1:
            return t = l.sent(), [4, new Promise(function(a, d) {
              var r = t.clear();
              r.addEventListener("success", function() {
                return a();
              }), r.addEventListener("error", function(i) {
                return d(i.target.error);
              });
            })];
          case 2:
            return [2, l.sent()];
        }
      });
    });
  }, n;
}(qR), dB = function(e) {
  function n(t) {
    var l = this, a = t.AsyncStorage, d = t.itemSizeLimit, r = d === void 0 ? 6291456 : d, i = lx(t, ["AsyncStorage", "itemSizeLimit"]);
    return (l = e.call(this, x(x({}, i), { itemSizeLimit: r })) || this)._asyncStorage = a, l;
  }
  return J(n, e), n.prototype._isBelonging = function(t) {
    return t.startsWith("".concat(this.dbname, "/"));
  }, n.prototype._getActualKey = function(t) {
    return "".concat(this.dbname, "/").concat(t);
  }, n.prototype._getAllRawKeys = function() {
    return M(this, void 0, void 0, function() {
      var t, l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._asyncStorage.getAllKeys()];
          case 1:
            return t = a.sent(), [2, t.filter(function(d) {
              return l._isBelonging(d);
            }).map(function(d) {
              return d.substring("".concat(l.dbname, "/").length);
            })];
        }
      });
    });
  }, n.prototype._getRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._asyncStorage.getItem(this._getActualKey(t))];
          case 1:
            return [2, (l = a.sent()) ? JSON.parse(l) : null];
        }
      });
    });
  }, n.prototype._setRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            l = [];
            try {
              for (a = be(t), d = a.next(); !d.done; d = a.next())
                r = d.value, i = r.key, r.data.length <= this.adjustedItemSizeLimit && l.push([this._getActualKey(i), JSON.stringify(r)]);
            } catch (o) {
              c = { error: o };
            } finally {
              try {
                d && !d.done && (V = a.return) && V.call(a);
              } finally {
                if (c)
                  throw c.error;
              }
            }
            return [4, this._asyncStorage.multiSet(l)];
          case 1:
            return s.sent(), [2];
        }
      });
    });
  }, n.prototype._removeRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._asyncStorage.multiRemove(t.map(function(d) {
              return l._getActualKey(d);
            }))];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.checkAvailability = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        if (!this._asyncStorage)
          throw dn.storeNotAvailable;
        return [2];
      });
    });
  }, n.prototype.init = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.dbname = t, [4, this._resetIfEncryptionChanged()];
          case 1:
            return l.sent(), [2];
        }
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this.getAllKeys()];
          case 1:
            return t = l.sent(), [4, this.removeMany(t)];
          case 2:
            return l.sent(), [2];
        }
      });
    });
  }, n;
}(qR);
(function(e) {
  function n(t) {
    var l, a = this;
    return (a = e.call(this, x(x({}, t), { itemSizeLimit: (l = t.itemSizeLimit) !== null && l !== void 0 ? l : 6291456 })) || this)._mmkv = t.MMKV, a;
  }
  J(n, e), n.prototype._isBelonging = function(t) {
    return t.startsWith("".concat(this.dbname, "/"));
  }, n.prototype._getActualKey = function(t) {
    return "".concat(this.dbname, "/").concat(t);
  }, n.prototype._getAllRawKeys = function() {
    return M(this, void 0, void 0, function() {
      var t, l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._mmkv.getAllKeys()];
          case 1:
            return t = a.sent(), [2, t.filter(function(d) {
              return l._isBelonging(d);
            }).map(function(d) {
              return d.substring("".concat(l.dbname, "/").length);
            })];
        }
      });
    });
  }, n.prototype._getRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._mmkv.getString(this._getActualKey(t))];
          case 1:
            return [2, (l = a.sent()) ? JSON.parse(l) : null];
        }
      });
    });
  }, n.prototype._setRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        try {
          for (l = be(t), a = l.next(); !a.done; a = l.next())
            d = a.value, r = d.key, d.data.length <= this.adjustedItemSizeLimit && this._mmkv.set(this._getActualKey(r), JSON.stringify(d));
        } catch (s) {
          i = { error: s };
        } finally {
          try {
            a && !a.done && (c = l.return) && c.call(l);
          } finally {
            if (i)
              throw i.error;
          }
        }
        return [2];
      });
    });
  }, n.prototype._removeRaw = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i;
      return p(this, function(c) {
        try {
          for (l = be(t), a = l.next(); !a.done; a = l.next())
            d = a.value, this._mmkv.delete(this._getActualKey(d));
        } catch (V) {
          r = { error: V };
        } finally {
          try {
            a && !a.done && (i = l.return) && i.call(l);
          } finally {
            if (r)
              throw r.error;
          }
        }
        return [2];
      });
    });
  }, n.prototype.checkAvailability = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        if (!this._mmkv)
          throw dn.storeNotAvailable;
        return [2];
      });
    });
  }, n.prototype.init = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.dbname = t, [4, this._resetIfEncryptionChanged()];
          case 1:
            return l.sent(), [2];
        }
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this.getAllKeys()];
          case 1:
            return t = l.sent(), [4, this.removeMany(t)];
          case 2:
            return l.sent(), [2];
        }
      });
    });
  };
})(qR);
var Dd;
(function(e) {
  e.INIT = "INIT", e.OPENING = "OPENING", e.OPENED = "OPENED", e.CLOSED = "CLOSED";
})(Dd || (Dd = {}));
var Wl, rB = function() {
  function e(n) {
    var t = n.name, l = n.version, a = n.store, d = n.config;
    this.name = t, this._version = l, this._state = Dd.INIT, this._config = d || new nU({ dbname: t }), this._store = a, this._event = { success: ks, error: ks, storeReplaced: ks, upgrade: Ju }, this._collections = /* @__PURE__ */ new Map(), this._globalMutex = new zW("".concat(this.name, ".lock")), this._config.disableLogger && Oi.off(), new $a({ dbname: t, limit: this._config.cacheLimit });
  }
  return Object.defineProperty(e.prototype, "version", { get: function() {
    return this._version;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "state", { get: function() {
    return this._state;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "store", { get: function() {
    return this._store;
  }, enumerable: !1, configurable: !0 }), e.prototype.estimateUsage = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, (t = this._store, M(void 0, void 0, void 0, function() {
              return p(this, function(l) {
                switch (l.label) {
                  case 0:
                    return [4, t.usage()];
                  case 1:
                    return [2, l.sent()];
                }
              });
            }))];
          case 1:
            return [2, n.sent()];
        }
        var t;
      });
    });
  }, e.prototype.commitSchema = function(n) {
    return M(this, void 0, void 0, function() {
      var t = this;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this._state !== Dd.OPENING ? [3, 2] : [4, Promise.all(n.map(function(a) {
              return M(t, void 0, void 0, function() {
                var d, r, i, c, V;
                return p(this, function(s) {
                  switch (s.label) {
                    case 0:
                      return d = a.collectionName, r = a.keyName, i = a.index, c = i === void 0 ? [] : i, this._collections.has(d) || this._collections.set(d, new WZ({ dbname: this.name, collectionName: d, keyName: r, indexes: c, store: this._store })), (V = this._collections.get(d)) ? [4, V.init()] : [3, 2];
                    case 1:
                      s.sent(), s.label = 2;
                    case 2:
                      return [2];
                  }
                });
              });
            }))];
          case 1:
            return l.sent(), [3, 3];
          case 2:
            throw dn.databaseSchemaNotOnUpgrade;
          case 3:
            return [2];
        }
      });
    });
  }, e.prototype.open = function() {
    var n;
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r = this;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return [4, this._globalMutex.lock()];
          case 1:
            if (i.sent(), this._state === Dd.OPENED)
              return [3, 12];
            this._state = Dd.OPENING, i.label = 2;
          case 2:
            return i.trys.push([2, 5, , 12]), [4, this._store.init(this.name)];
          case 3:
            return i.sent(), c = this.name, t = "".concat(KT(c), ".metadata"), l = { version: 0, collectionNames: [] }, [4, this._store.get(t)];
          case 4:
            return a = (n = i.sent()) !== null && n !== void 0 ? n : l, [2, new Promise(function(V, s) {
              var o = function(N) {
                a.version < r._version ? r._event.upgrade(a.version, function(R) {
                  return M(r, void 0, void 0, function() {
                    var h;
                    return p(this, function(Z) {
                      switch (Z.label) {
                        case 0:
                          if (R)
                            return [3, 5];
                          a.version++, a.collectionNames = Array.from(this._collections.keys()), Z.label = 1;
                        case 1:
                          return Z.trys.push([1, 3, , 4]), [4, this._store.set({ key: t, value: a })];
                        case 2:
                          return Z.sent(), N({ continued: !0 }), [3, 4];
                        case 3:
                          return h = Z.sent(), N({ continued: !1, err: h }), [3, 4];
                        case 4:
                          return [3, 6];
                        case 5:
                          N({ continued: !1, err: R }), Z.label = 6;
                        case 6:
                          return [2];
                      }
                    });
                  });
                }) : N({ continued: !1 });
              }, U = function(N) {
                var R = N.continued, h = R !== void 0 && R, Z = N.err, W = Z === void 0 ? null : Z;
                if (h)
                  setTimeout(function() {
                    return o(U);
                  }, 10);
                else if (W)
                  Oi.error(W.message), r._globalMutex.unlock(), r._event.error(W), s(W);
                else {
                  var F = [];
                  a.collectionNames.forEach(function(m) {
                    var E = r._collections.get(m);
                    E && E.state === aV.READY || F.push(M(r, void 0, void 0, function() {
                      var u, b;
                      return p(this, function(k) {
                        switch (k.label) {
                          case 0:
                            return [4, WZ.metadataOf(this.name, m, this._store)];
                          case 1:
                            return (u = k.sent()) ? (b = new WZ({ dbname: this.name, collectionName: m, keyName: u.keyName, indexes: u.indexes, store: this._store }), this._collections.set(m, b), [4, b.init()]) : [3, 3];
                          case 2:
                            k.sent(), k.label = 3;
                          case 3:
                            return [2];
                        }
                      });
                    }));
                  }), Promise.all(F).then(function() {
                    r._state = Dd.OPENED, r._globalMutex.unlock(), r._event.success(), V();
                  }).catch(function(m) {
                    Oi.error(m.message), r._globalMutex.unlock(), r._event.error(m), s(m);
                  });
                }
              };
              o(U);
            })];
          case 5:
            switch (d = i.sent(), d.code) {
              case Jn.STORE_NOT_AVAILABLE_IN_PRIVATE_BROWSING:
                return [3, 6];
              case Jn.STORE_NOT_AVAILABLE:
                return [3, 8];
            }
            return [3, 10];
          case 6:
            return Oi.warning("Access to the local storage is not allowed. Switched to MemoryStore automatically."), this._store = new Pr({}), this._globalMutex.unlock(), this._event.error(d), this._event.storeReplaced(this._store), [4, this.open()];
          case 7:
            return i.sent(), [3, 11];
          case 8:
            return Oi.warning("IndexedDB is not available in this environment. Switched to MemoryStore automatically. Consider using other store to save data persistently (e.g. AsyncStorage)."), this._store = new Pr({}), this._globalMutex.unlock(), this._event.error(d), this._event.storeReplaced(this._store), [4, this.open()];
          case 9:
            return i.sent(), [3, 11];
          case 10:
            throw Oi.error(d.message), this._globalMutex.unlock(), this._event.error(d), d;
          case 11:
            return [3, 12];
          case 12:
            return [2];
        }
        var c;
      });
    });
  }, e.prototype.close = function() {
    this._collections.forEach(function(n) {
      return n.close();
    }), this._state = Dd.CLOSED;
  }, e.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, Promise.all(Array.from(this._collections.values()).map(function(t) {
              return t.clear();
            }))];
          case 1:
            return n.sent(), [2];
        }
      });
    });
  }, e.prototype.reset = function() {
    return M(this, void 0, void 0, function() {
      var n, t = this;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.close(), (n = $a.get(this.name)) && n.clearByCondition(function(a) {
              return a.key.startsWith(KT(t.name));
            }), [4, this._store.clear()];
          case 1:
            return l.sent(), [2];
        }
      });
    });
  }, e.prototype.on = function(n, t) {
    this._event[n] = t;
  }, e.prototype.off = function(n) {
    typeof this._event[n] == "function" && (n === "upgrade" ? this._event[n] = Ju : this._event[n] = ks);
  }, e.prototype.collection = function(n) {
    var t = this._collections.get(n);
    if (t)
      return t;
    throw dn.collectionNotReady;
  }, e;
}(), mi = function() {
  function e(n) {
    var t, l, a, d;
    this.messageTypeFilter = (t = n == null ? void 0 : n.messageTypeFilter) !== null && t !== void 0 ? t : bl.ALL, this.customTypesFilter = (l = n == null ? void 0 : n.customTypesFilter) !== null && l !== void 0 ? l : null, this.senderUserIdsFilter = (a = n == null ? void 0 : n.senderUserIdsFilter) !== null && a !== void 0 ? a : null, this.replyType = (d = n == null ? void 0 : n.replyType) !== null && d !== void 0 ? d : al.NONE;
  }
  return e.prototype.clone = function() {
    var n = new e(), t = JSON.parse(JSON.stringify(this));
    return Object.keys(t).forEach(function(l) {
      n[l] = t[l];
    }), n;
  }, e.prototype.match = function(n) {
    switch (this.messageTypeFilter) {
      case bl.USER:
        if (n.messageType !== Gn.USER)
          return !1;
        break;
      case bl.FILE:
        if (n.messageType !== Gn.FILE)
          return !1;
        break;
      case bl.ADMIN:
        if (n.messageType !== Gn.ADMIN)
          return !1;
    }
    if (this.customTypesFilter && this.customTypesFilter.length > 0 && !this.customTypesFilter.includes("*") && !this.customTypesFilter.includes(n.customType) || this.senderUserIdsFilter && this.senderUserIdsFilter.length > 0 && (!(n instanceof wn) || !this.senderUserIdsFilter.includes(n.sender.userId)))
      return !1;
    if (n instanceof Bl)
      switch (this.replyType) {
        case al.NONE:
          if (n.parentMessageId > 0)
            return !1;
          break;
        case al.ONLY_REPLY_TO_CHANNEL:
          if (n instanceof wn && n.parentMessageId > 0 && !n.replyToChannel)
            return !1;
      }
    return !0;
  }, e;
}();
(function(e) {
  e.CHANNEL_LATEST = "channel_latest", e.NEWEST_CHILD_MESSAGE = "newest_child_message";
})(Wl || (Wl = {}));
var _s, wd = function(e) {
  switch (e) {
    case Wl.CHANNEL_LATEST:
      return ["channelUrl", "-createdAt", "-messageId"];
    case Wl.NEWEST_CHILD_MESSAGE:
      return ["channelUrl", "-parentMessageId", "-createdAt", "-messageId"];
  }
}, iB = function() {
  return ["channelUrl", "-createdAt", "-notificationId"];
}, VB = x(x({}, W3), { scheduledAt: void 0 }), cB = function(e) {
  return u3(e) && B("number", e.scheduledAt, !0);
}, sB = x(x({}, PR), { scheduledAt: 0, file: void 0, fileUrl: void 0, fileName: void 0, mimeType: void 0, fileSize: void 0, thumbnailSizes: void 0, requireAuth: !1 }), oB = function(e) {
  return AR(e) && B("number", e.scheduledAt) && (Nl(e.file) || B("string", e.fileUrl)) && B("string", e.fileName, !0) && B("string", e.mimeType, !0) && B("number", e.fileSize, !0) && (e.thumbnailSizes === null || e.thumbnailSizes === void 0 || e.thumbnailSizes.every(function(n) {
    return B("object", n) && n.maxWidth > 0 && n.maxHeight > 0;
  }));
}, O3 = "UnsentMessage", UB = "reqId", PU = {}, bV = function(e) {
  function n(t) {
    var l = e.call(this, t) || this;
    return l._mutex = new zW("unsendmessagecache.lock"), PU[t] = l, l;
  }
  return J(n, e), Object.defineProperty(n.prototype, "_cacheContext", { get: function() {
    return D.of(this._iid).cacheContext;
  }, enumerable: !1, configurable: !0 }), n.of = function(t, l) {
    return l === void 0 && (l = !1), PU[t] && !l || (PU[t] = new n(t)), PU[t];
  }, Object.defineProperty(n.prototype, "collection", { get: function() {
    var t = this._cacheContext.nestdb, l = t == null ? void 0 : t.collection(O3);
    if (!l)
      throw j.databaseError;
    return l;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "localCacheEnabled", { get: function() {
    return this._cacheContext.localCacheEnabled && !!this.collection;
  }, enumerable: !1, configurable: !0 }), n.prototype._serialize = function(t) {
    if (t.messageId > 0)
      throw j.invalidParameters;
    var l, a = x({}, t.serialize());
    return t instanceof kl ? (t.messageParams && (a.messageParams = Zu(t.messageParams)), t.scheduledInfo && t.scheduledInfo.scheduledMessageParams && (a.scheduledInfo.scheduledMessageParams = (l = t.scheduledInfo.scheduledMessageParams, x(x({}, Zu(l)), { scheduledAt: l.scheduledAt })))) : t instanceof Ln ? (t.messageParams && (a.messageParams = Tu(t.messageParams)), t.scheduledInfo && t.scheduledInfo.scheduledMessageParams && (a.scheduledInfo.scheduledMessageParams = function(d) {
      return x(x({}, Tu(d)), { scheduledAt: d.scheduledAt });
    }(t.scheduledInfo.scheduledMessageParams))) : t instanceof Da && t.messageParams && (a.messageParams = function(d) {
      return je({ fileInfoList: d.fileInfoList, isReplyToChannel: d.isReplyToChannel, pushNotificationDeliveryOption: d.pushNotificationDeliveryOption });
    }(t.messageParams)), a;
  }, n.prototype._deserialize = function(t) {
    return t = x(x({}, t), { messageId: parseInt(t.messageId) }), tl.of(this._iid).buildMessageFromSerializedData(t);
  }, n.prototype._deserializeWithMessageCreateParams = function(t) {
    var l, a, d;
    return M(this, void 0, void 0, function() {
      var r, i, c, V, s, o, U = this;
      return p(this, function(N) {
        switch (N.label) {
          case 0:
            return r = tl.of(this._iid), i = this._deserialize(t), t.messageParams ? i instanceof kl ? (V = t.messageParams, i.messageParams = r.buildUserMessageCreateParamsFromSerializedData(V, i), [3, 6]) : [3, 1] : [3, 6];
          case 1:
            return i instanceof Ln ? (V = t.messageParams).fileKey && typeof V.fileKey == "string" && RZ((l = V.fileType) !== null && l !== void 0 ? l : "") ? (c = V, [4, this.collection.getBlob(V.fileKey)]) : [3, 3] : [3, 4];
          case 2:
            c.file = (a = N.sent()) !== null && a !== void 0 ? a : void 0, N.label = 3;
          case 3:
            return i.messageParams = r.buildFileMessageCreateParamsFromSerializedData(V, i), [3, 6];
          case 4:
            return i instanceof Da && (V = t.messageParams) && V.fileInfoList ? (i.messageParams = r.buildMultipleFilesMessageCreateParamsFromSerializedData(V, i), [4, Promise.all(i.messageParams.fileInfoList.map(function(R) {
              return M(U, void 0, void 0, function() {
                var h, Z, W, F, m;
                return p(this, function(E) {
                  switch (E.label) {
                    case 0:
                      return typeof ((Z = R._uploadedMetaData) === null || Z === void 0 ? void 0 : Z.fileKey) == "string" && RZ((F = (W = R._uploadedMetaData) === null || W === void 0 ? void 0 : W.fileType) !== null && F !== void 0 ? F : "") ? (h = R, [4, this.collection.getBlob(R._uploadedMetaData.fileKey)]) : [3, 2];
                    case 1:
                      h.file = (m = E.sent()) !== null && m !== void 0 ? m : void 0, E.label = 2;
                    case 2:
                      return [2];
                  }
                });
              });
            }))]) : [3, 6];
          case 5:
            N.sent(), N.label = 6;
          case 6:
            return i.scheduledInfo && t.scheduledInfo && t.scheduledInfo.scheduledMessageParams ? i instanceof kl ? (s = t.scheduledInfo.scheduledMessageParams, i.scheduledInfo.scheduledMessageParams = r.buildScheduledUserMessageCreateParamsFromSerializedData(s, i), [3, 10]) : [3, 7] : [3, 10];
          case 7:
            return i instanceof Ln ? (s = t.scheduledInfo.scheduledMessageParams).fileKey && typeof s.fileKey == "string" && typeof s.fileType == "string" && RZ(s.fileType) ? (o = s, [4, this.collection.getBlob(s.fileKey)]) : [3, 9] : [3, 10];
          case 8:
            o.file = (d = N.sent()) !== null && d !== void 0 ? d : void 0, N.label = 9;
          case 9:
            i.scheduledInfo.scheduledMessageParams = r.buildScheduledFileMessageCreateParamsFromSerializedData(s, i), N.label = 10;
          case 10:
            return [2, i];
        }
      });
    });
  }, n.prototype._getFileInfoBlobKey = function(t, l) {
    return "".concat(t, ".").concat(l);
  }, n.prototype.get = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.getByKey("".concat(t))] : [3, 2];
          case 1:
            if (l = a.sent())
              return [2, this._deserializeWithMessageCreateParams(l)];
            a.label = 2;
          case 2:
            return [2, void 0];
        }
      });
    });
  }, n.prototype.fetch = function(t) {
    var l = t.channelUrl, a = t.filter, d = a === void 0 ? new mi() : a, r = t.order, i = r === void 0 ? Wl.CHANNEL_LATEST : r, c = t.sendingStatus, V = t.backward, s = V !== void 0 && V, o = t.parentMessageId;
    return M(this, void 0, void 0, function() {
      var U, N, R, h, Z = this;
      return p(this, function(W) {
        switch (W.label) {
          case 0:
            return this.localCacheEnabled ? (U = wd(i), N = { "/where": function(F) {
              return !!(i !== Wl.NEWEST_CHILD_MESSAGE || o && F.parentMessageId !== 0 && F.parentMessageId === o) && d.match(Z._deserialize(F));
            } }, l && (N.channelUrl = l), c && (N.sendingStatus = c), R = { where: N, index: U, backward: s }, [4, this.collection.query(R)]) : [3, 3];
          case 1:
            return [4, W.sent().fetch({})];
          case 2:
            return h = W.sent(), [2, Promise.all(h.map(function(F) {
              return M(Z, void 0, void 0, function() {
                return p(this, function(m) {
                  switch (m.label) {
                    case 0:
                      return [4, this._deserializeWithMessageCreateParams(F)];
                    case 1:
                      return [2, m.sent()];
                  }
                });
              });
            }))];
          case 3:
            return [2, []];
        }
      });
    });
  }, n.prototype.getAllChildMessages = function(t, l) {
    return l === void 0 && (l = new mi()), M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this.fetch({ filter: l, order: Wl.NEWEST_CHILD_MESSAGE, channelUrl: t.channelUrl, backward: !1, parentMessageId: t.messageId })];
          case 1:
            return [2, a.sent()];
        }
      });
    });
  }, n.prototype.upsert = function(t) {
    return M(this, void 0, void 0, function() {
      var l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, Promise.all(t.map(function(d) {
              return M(l, void 0, void 0, function() {
                var r;
                return p(this, function(i) {
                  switch (i.label) {
                    case 0:
                      return d instanceof Ln || d instanceof Da ? [4, this._mutex.lock()] : [3, 4];
                    case 1:
                      return i.sent(), [4, this.saveBlob(d)];
                    case 2:
                      return i.sent(), [4, this._mutex.unlock()];
                    case 3:
                      i.sent(), i.label = 4;
                    case 4:
                      return r = this._serialize(d), [4, this.collection.upsertOne(r)];
                    case 5:
                      return i.sent(), [2];
                  }
                });
              });
            }))] : [3, 2];
          case 1:
            a.sent(), a.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.upsertChildMessages = function(t) {
    return M(this, void 0, void 0, function() {
      var l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, Promise.all(t.map(function(d) {
              return M(l, void 0, void 0, function() {
                var r;
                return p(this, function(i) {
                  switch (i.label) {
                    case 0:
                      return r = [], d.threadInfo && d.threadInfo.replyCount > 0 ? [4, this.getAllChildMessages(d)] : [3, 2];
                    case 1:
                      r = i.sent(), i.label = 2;
                    case 2:
                      return r.length > 0 ? (r.forEach(function(c) {
                        return c.applyParentMessage(d);
                      }), [4, this.upsert(r)]) : [3, 4];
                    case 3:
                      i.sent(), i.label = 4;
                    case 4:
                      return [2];
                  }
                });
              });
            }))] : [3, 2];
          case 1:
            a.sent(), a.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.remove = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            if (!this.localCacheEnabled)
              return [3, 8];
            V.label = 1;
          case 1:
            V.trys.push([1, 6, 7, 8]), l = be(t), a = l.next(), V.label = 2;
          case 2:
            return a.done ? [3, 5] : (d = a.value, [4, this.collection.remove(d)]);
          case 3:
            V.sent(), V.label = 4;
          case 4:
            return a = l.next(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return r = V.sent(), i = { error: r }, [3, 8];
          case 7:
            try {
              a && !a.done && (c = l.return) && c.call(l);
            } finally {
              if (i)
                throw i.error;
            }
            return [7];
          case 8:
            return [2];
        }
      });
    });
  }, n.prototype.removeMessagesOfChannel = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.removeIf({ where: { channelUrl: t } })] : [3, 2];
          case 1:
            l.sent(), l.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.clear()] : [3, 2];
          case 1:
            t.sent(), t.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.saveBlob = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r = this;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return t instanceof Ln ? t.messageParams && (d = t.messageParams).file && EN(d.file) ? [4, this.collection.saveBlob(d.file, t.reqId)] : [3, 2] : [3, 5];
          case 1:
            a = i.sent(), d.fileKey = a, d.fileType = FV.BLOB, i.label = 2;
          case 2:
            return t.scheduledInfo && t.scheduledInfo.scheduledMessageParams && (l = t.scheduledInfo.scheduledMessageParams).file && EN(l.file) ? [4, this.collection.saveBlob(l.file, t.reqId)] : [3, 4];
          case 3:
            a = i.sent(), l.fileKey = a, l.fileType = FV.BLOB, i.label = 4;
          case 4:
            return [3, 7];
          case 5:
            return t instanceof Da && (d = t.messageParams) && d.fileInfoList && Array.isArray(d.fileInfoList) ? [4, Promise.all(d.fileInfoList.map(function(c, V) {
              return M(r, void 0, void 0, function() {
                var s;
                return p(this, function(o) {
                  switch (o.label) {
                    case 0:
                      return c.file && EN(c.file) ? [4, this.collection.saveBlob(c.file, this._getFileInfoBlobKey(t.reqId, V))] : [3, 2];
                    case 1:
                      s = o.sent(), c._uploadedMetaData || (c._uploadedMetaData = {}), c._uploadedMetaData.fileKey = s, c._uploadedMetaData.fileType = FV.BLOB, o.label = 2;
                    case 2:
                      return [2];
                  }
                });
              });
            }))] : [3, 7];
          case 6:
            i.sent(), i.label = 7;
          case 7:
            return [2];
        }
      });
    });
  }, n;
}(ml), AU = {}, ac = function(e) {
  function n(t) {
    var l = e.call(this, t) || this;
    return AU[t] = l, l;
  }
  return J(n, e), Object.defineProperty(n.prototype, "_sdkState", { get: function() {
    return D.of(this._iid).sdkState;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "_cacheContext", { get: function() {
    return D.of(this._iid).cacheContext;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "_unsentMessageCache", { get: function() {
    return bV.of(this._iid);
  }, enumerable: !1, configurable: !0 }), n.of = function(t, l) {
    return l === void 0 && (l = !1), AU[t] && !l || (AU[t] = new n(t)), AU[t];
  }, Object.defineProperty(n.prototype, "collection", { get: function() {
    var t = this._cacheContext.nestdb;
    return Ze(!!t).throw(j.databaseError), t.collection(LT);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "localCacheEnabled", { get: function() {
    return this._cacheContext.localCacheEnabled && !!this.collection;
  }, enumerable: !1, configurable: !0 }), n.prototype._serialize = function(t) {
    return x(x({}, t.serialize()), { messageId: "".concat(t.messageId) });
  }, n.prototype._deserialize = function(t) {
    return t = x(x({}, t), { messageId: parseInt(t.messageId) }), tl.of(this._iid).buildMessageFromSerializedData(t);
  }, n.prototype.get = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.getByKey("".concat(t))] : [3, 2];
          case 1:
            if (l = a.sent())
              return [2, this._deserialize(l)];
            a.label = 2;
          case 2:
            return [2, void 0];
        }
      });
    });
  }, n.prototype.fetch = function(t) {
    var l = t.channelUrl, a = t.token, d = t.limit, r = d === void 0 ? 100 : d, i = t.filter, c = i === void 0 ? new mi() : i, V = t.order, s = V === void 0 ? Wl.CHANNEL_LATEST : V, o = t.backward, U = o !== void 0 && o, N = t.parentMessageId, R = t.isPollOnly, h = R !== void 0 && R, Z = t.exactMatch, W = Z !== void 0 && Z, F = t.inclusive, m = F === void 0 || F;
    return M(this, void 0, void 0, function() {
      var E, u, b, k = this;
      return p(this, function(Q) {
        switch (Q.label) {
          case 0:
            return this.localCacheEnabled ? (E = wd(s), u = { where: { channelUrl: l, "/where": function(S) {
              if (a)
                switch (s) {
                  case Wl.CHANNEL_LATEST:
                    if (W && S.createdAt !== a)
                      return !1;
                    if (U) {
                      if (m && S.createdAt < a || !m && S.createdAt <= a)
                        return !1;
                    } else if (m && S.createdAt > a || !m && S.createdAt >= a)
                      return !1;
                    break;
                  case Wl.NEWEST_CHILD_MESSAGE:
                    if (!N || S.parentMessageId === 0 || S.parentMessageId !== N)
                      return !1;
                }
              return !(h && !S._poll) && c.match(k._deserialize(S));
            } }, index: E, backward: U }, [4, this.collection.query(u)]) : [3, 3];
          case 1:
            return [4, Q.sent().fetch({ limit: r ?? void 0 })];
          case 2:
            return b = Q.sent(), [2, Promise.all(b.map(function(S) {
              return M(k, void 0, void 0, function() {
                return p(this, function(v) {
                  return [2, this._deserialize(S)];
                });
              });
            }))];
          case 3:
            return [2, []];
        }
      });
    });
  }, n.prototype.getAllChildMessages = function(t, l) {
    return l === void 0 && (l = new mi()), M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this.fetch({ channelUrl: t.channelUrl, token: Date.now(), limit: null, backward: !1, filter: l, order: Wl.NEWEST_CHILD_MESSAGE, parentMessageId: t.messageId })];
          case 1:
            return [2, a.sent()];
        }
      });
    });
  }, n.prototype.upsert = function(t) {
    var l;
    return M(this, void 0, void 0, function() {
      var a, d, r, i, c, V, s, o, U = this;
      return p(this, function(N) {
        switch (N.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.saveBlobs(t)] : [3, 13];
          case 1:
            N.sent(), N.label = 2;
          case 2:
            N.trys.push([2, 7, 8, 9]), a = be(t), d = a.next(), N.label = 3;
          case 3:
            return d.done ? [3, 6] : (r = d.value, !((l = r.threadInfo) === null || l === void 0) && l._isUpdateRequired ? [4, this.get(r.messageId)] : [3, 5]);
          case 4:
            (i = N.sent()) != null && i.threadInfo && r.threadInfo._updateFrom(i.threadInfo), N.label = 5;
          case 5:
            return d = a.next(), [3, 3];
          case 6:
            return [3, 9];
          case 7:
            return c = N.sent(), s = { error: c }, [3, 9];
          case 8:
            try {
              d && !d.done && (o = a.return) && o.call(a);
            } finally {
              if (s)
                throw s.error;
            }
            return [7];
          case 9:
            return V = t.map(function(R) {
              return U._serialize(R);
            }), [4, this.collection.upsertMany(V)];
          case 10:
            return N.sent(), [4, this.upsertChildMessages(t)];
          case 11:
            return N.sent(), [4, this._unsentMessageCache.upsertChildMessages(t)];
          case 12:
            N.sent(), N.label = 13;
          case 13:
            return [2];
        }
      });
    });
  }, n.prototype.upsertChildMessages = function(t) {
    return M(this, void 0, void 0, function() {
      var l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, Promise.all(t.map(function(d) {
              return M(l, void 0, void 0, function() {
                var r, i;
                return p(this, function(c) {
                  switch (c.label) {
                    case 0:
                      return r = [], !((i = d.threadInfo) === null || i === void 0) && i.replyCount && d.threadInfo.replyCount > 0 ? [4, this.getAllChildMessages(d)] : [3, 2];
                    case 1:
                      r = c.sent(), c.label = 2;
                    case 2:
                      return r.length > 0 ? (r.forEach(function(V) {
                        return V.applyParentMessage(d);
                      }), [4, this.upsert(r)]) : [3, 4];
                    case 3:
                      c.sent(), c.label = 4;
                    case 4:
                      return [2];
                  }
                });
              });
            }))] : [3, 2];
          case 1:
            a.sent(), a.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.remove = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            if (!this.localCacheEnabled)
              return [3, 8];
            V.label = 1;
          case 1:
            V.trys.push([1, 6, 7, 8]), l = be(t), a = l.next(), V.label = 2;
          case 2:
            return a.done ? [3, 5] : (d = a.value, [4, this.collection.remove("".concat(d))]);
          case 3:
            V.sent(), V.label = 4;
          case 4:
            return a = l.next(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return r = V.sent(), i = { error: r }, [3, 8];
          case 7:
            try {
              a && !a.done && (c = l.return) && c.call(l);
            } finally {
              if (i)
                throw i.error;
            }
            return [7];
          case 8:
            return [2];
        }
      });
    });
  }, n.prototype.removeMessagesOfChannel = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.removeIf({ where: { channelUrl: t }, index: wd(Wl.CHANNEL_LATEST) })] : [3, 6];
          case 1:
            return a.sent(), [4, (l = this._cacheContext.preference).remove("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/sync"))];
          case 2:
            return a.sent(), [4, l.remove("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/sync.meta"))];
          case 3:
            return a.sent(), [4, l.remove("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/changelogs"))];
          case 4:
            return a.sent(), [4, l.remove("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/changelogs.meta"))];
          case 5:
            a.sent(), a.label = 6;
          case 6:
            return [2];
        }
      });
    });
  }, n.prototype.removeUnderOffset = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.removeIf({ where: { channelUrl: t, createdAt: { "<": l } }, index: wd(Wl.CHANNEL_LATEST) })] : [3, 2];
          case 1:
            a.sent(), a.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.clear()] : [3, 2];
          case 1:
            t.sent(), t.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.countBetween = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      var d, r = this;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return this.localCacheEnabled ? (d = wd(Wl.CHANNEL_LATEST), [4, this.collection.query({ where: { channelUrl: t, "/where": function(c) {
              var V = r._deserialize(c);
              return a.includes(V.createdAt) && l.match(V);
            } }, index: d }).count()]) : [3, 2];
          case 1:
            return [2, i.sent()];
          case 2:
            return [2, 0];
        }
      });
    });
  }, n.prototype.saveBlobs = function(t) {
    return M(this, void 0, void 0, function() {
      var l = this;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, Promise.all(t.map(function(d) {
              return M(l, void 0, void 0, function() {
                var r, i;
                return p(this, function(c) {
                  switch (c.label) {
                    case 0:
                      return d instanceof Ln && d.messageParams && (r = d.messageParams).file && EN(r.file) ? [4, this.collection.saveBlob(r.file, d.reqId)] : [3, 2];
                    case 1:
                      i = c.sent(), r.fileKey = i, c.label = 2;
                    case 2:
                      return [2];
                  }
                });
              });
            }))];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype._getGroupChannelPreferenceSize = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return l = 0, [4, (a = this._cacheContext.preference).get("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/sync"))];
          case 1:
            return d = V.sent(), [4, a.get("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/sync.meta"))];
          case 2:
            return r = V.sent(), [4, a.get("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/changelogs"))];
          case 3:
            return i = V.sent(), [4, a.get("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/changelogs.meta"))];
          case 4:
            return c = V.sent(), d && (l += JSON.stringify(d).length), r && (l += JSON.stringify(r).length), i && (l += JSON.stringify(i).length), c && (l += JSON.stringify(c).length), [2, l];
        }
      });
    });
  }, n;
}(ml), qU = {}, NB = function(e) {
  function n(t) {
    var l = e.call(this, t) || this;
    return qU[t] = l, l;
  }
  return J(n, e), Object.defineProperty(n.prototype, "_sdkState", { get: function() {
    return D.of(this._iid).sdkState;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "_cacheContext", { get: function() {
    return D.of(this._iid).cacheContext;
  }, enumerable: !1, configurable: !0 }), n.of = function(t, l) {
    return l === void 0 && (l = !1), qU[t] && !l || (qU[t] = new n(t)), qU[t];
  }, Object.defineProperty(n.prototype, "collection", { get: function() {
    var t = this._cacheContext.nestdb;
    return Ze(!!t).throw(j.databaseError), t.collection(D3);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "localCacheEnabled", { get: function() {
    return this._cacheContext.localCacheEnabled && !!this.collection;
  }, enumerable: !1, configurable: !0 }), n.prototype._serialize = function(t) {
    return x({}, t.serialize());
  }, n.prototype._deserialize = function(t) {
    return tl.of(this._iid).buildMessageFromSerializedData(t);
  }, n.prototype.get = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.getByKey(t)] : [3, 2];
          case 1:
            if (l = a.sent())
              return [2, this._deserialize(l)];
            a.label = 2;
          case 2:
            return [2, void 0];
        }
      });
    });
  }, n.prototype.fetch = function(t) {
    var l = t.channelUrl, a = t.token, d = t.limit, r = d === void 0 ? 100 : d, i = t.filter, c = i === void 0 ? new mi() : i, V = t.backward, s = V !== void 0 && V, o = t.exactMatch, U = o !== void 0 && o, N = t.inclusive, R = N === void 0 || N;
    return M(this, void 0, void 0, function() {
      var h, Z = this;
      return p(this, function(W) {
        switch (W.label) {
          case 0:
            return this.localCacheEnabled ? (h = { where: { channelUrl: l, "/where": function(F) {
              if (a) {
                if (U && F.createdAt !== a)
                  return !1;
                if (s) {
                  if (R && F.createdAt < a || !R && F.createdAt <= a)
                    return !1;
                } else if (R && F.createdAt > a || !R && F.createdAt >= a)
                  return !1;
              }
              return c.match(Z._deserialize(F));
            } }, index: ["channelUrl", "-createdAt", "-notificationId"], backward: s }, [4, this.collection.query(h)]) : [3, 3];
          case 1:
            return [4, W.sent().fetch({ limit: r ?? void 0 })];
          case 2:
            return [2, W.sent().map(function(F) {
              return Z._deserialize(F);
            })];
          case 3:
            return [2, []];
        }
      });
    });
  }, n.prototype.upsert = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a = this;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return this.localCacheEnabled ? (l = t.map(function(r) {
              return a._serialize(r);
            }), [4, this.collection.upsertMany(l)]) : [3, 2];
          case 1:
            d.sent(), d.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.remove = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            if (!this.localCacheEnabled)
              return [3, 8];
            V.label = 1;
          case 1:
            V.trys.push([1, 6, 7, 8]), l = be(t), a = l.next(), V.label = 2;
          case 2:
            return a.done ? [3, 5] : (d = a.value, [4, this.collection.remove(d)]);
          case 3:
            V.sent(), V.label = 4;
          case 4:
            return a = l.next(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return r = V.sent(), i = { error: r }, [3, 8];
          case 7:
            try {
              a && !a.done && (c = l.return) && c.call(l);
            } finally {
              if (i)
                throw i.error;
            }
            return [7];
          case 8:
            return [2];
        }
      });
    });
  }, n.prototype.markAsReadByTimestamp = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.updateIf({ where: { channelUrl: t, messageStatus: lV.SENT, createdAt: { "<": l } } }, { set: { messageStatus: lV.READ } })] : [3, 2];
          case 1:
            a.sent(), a.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.markAsReadByMessageIds = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.updateIf({ where: { channelUrl: t, notificationId: { "/in": l }, messageStatus: lV.SENT } }, { set: { messageStatus: lV.READ } })] : [3, 2];
          case 1:
            return [2, a.sent().length];
          case 2:
            return [2, 0];
        }
      });
    });
  }, n.prototype.removeMessagesOfChannel = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.removeIf({ where: { channelUrl: t }, index: ["channelUrl", "-createdAt", "-notificationId"] })] : [3, 6];
          case 1:
            return a.sent(), [4, (l = this._cacheContext.preference).remove("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/sync"))];
          case 2:
            return a.sent(), [4, l.remove("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/sync.meta"))];
          case 3:
            return a.sent(), [4, l.remove("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/changelogs"))];
          case 4:
            return a.sent(), [4, l.remove("sendbird:".concat(this._sdkState.userId, "@groupchannel/").concat(t, "/message/changelogs.meta"))];
          case 5:
            a.sent(), a.label = 6;
          case 6:
            return [2];
        }
      });
    });
  }, n.prototype.removeUnderOffset = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.removeIf({ where: { channelUrl: t, createdAt: { "<": l } }, index: wd(Wl.CHANNEL_LATEST) })] : [3, 2];
          case 1:
            a.sent(), a.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this.localCacheEnabled ? [4, this.collection.clear()] : [3, 2];
          case 1:
            t.sent(), t.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.countBetween = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      var d, r = this;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return this.localCacheEnabled ? (d = ["channelUrl", "-createdAt", "-notificationId"], [4, this.collection.query({ where: { channelUrl: t, "/where": function(c) {
              var V = r._deserialize(c);
              return a.includes(V.createdAt) && l.match(V);
            } }, index: d }).count()]) : [3, 2];
          case 1:
            return [2, i.sent()];
          case 2:
            return [2, 0];
        }
      });
    });
  }, n;
}(ml), ns = {}, j3 = function(e) {
  function n(t) {
    var l = e.call(this, t) || this;
    return l._observers = /* @__PURE__ */ new Map(), l._dispatcherContext = l._dispatcher.on(function(a) {
      return M(l, void 0, void 0, function() {
        var d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q = this;
        return p(this, function(S) {
          switch (S.label) {
            case 0:
              return a instanceof En ? (d = a.messages, k = a.source, s = a.isWebSocketEventComing, r = d.filter(function(v) {
                return v instanceof Bl && v.channelType !== Xt.OPEN && v.messageId > 0;
              }), i = d.filter(function(v) {
                return v instanceof Bl && v.channelType !== Xt.OPEN && v.messageId === 0;
              }), c = d.filter(function(v) {
                return v instanceof SV;
              }), r.length > 0 ? [4, yn(function() {
                return M(Q, void 0, void 0, function() {
                  return p(this, function(v) {
                    switch (v.label) {
                      case 0:
                        return [4, this._messageCache.upsert(r)];
                      case 1:
                        return v.sent(), [4, this._unsentMessageCache.remove(r.map(function(G) {
                          return G instanceof wn ? G.reqId : null;
                        }).filter(function(G) {
                          return G !== null;
                        }))];
                      case 2:
                        return v.sent(), [2];
                    }
                  });
                });
              })] : [3, 2]) : [3, 7];
            case 1:
              S.sent(), s || this._broadcastUpdateEvent(r, k), S.label = 2;
            case 2:
              return i.length > 0 ? [4, yn(function() {
                return M(Q, void 0, void 0, function() {
                  return p(this, function(v) {
                    switch (v.label) {
                      case 0:
                        return [4, this._unsentMessageCache.upsert(i)];
                      case 1:
                        return v.sent(), [2];
                    }
                  });
                });
              })] : [3, 4];
            case 3:
              S.sent(), s || this._broadcastUpdateEvent(i, k), S.label = 4;
            case 4:
              return c.length > 0 ? [4, yn(function() {
                return M(Q, void 0, void 0, function() {
                  return p(this, function(v) {
                    switch (v.label) {
                      case 0:
                        return [4, this._notificationCache.upsert(c)];
                      case 1:
                        return v.sent(), [2];
                    }
                  });
                });
              })] : [3, 6];
            case 5:
              S.sent(), s || this._broadcastUpdateEvent(c, k), S.label = 6;
            case 6:
              return [3, 24];
            case 7:
              return a instanceof EW ? (V = a.messageIds, k = a.source, s = a.isWebSocketEventComing, o = V.filter(function(v) {
                return typeof v == "number";
              }), U = V.filter(function(v) {
                return typeof v == "string";
              }), [4, yn(function() {
                return M(Q, void 0, void 0, function() {
                  return p(this, function(v) {
                    switch (v.label) {
                      case 0:
                        return o.length > 0 ? [4, this._messageCache.remove(o)] : [3, 2];
                      case 1:
                        v.sent(), v.label = 2;
                      case 2:
                        return U.length > 0 ? [4, this._notificationCache.remove(U)] : [3, 4];
                      case 3:
                        v.sent(), v.label = 4;
                      case 4:
                        return [2];
                    }
                  });
                });
              })]) : [3, 9];
            case 8:
              return S.sent(), s || this._broadcastRemoveEvent(V, k), [3, 24];
            case 9:
              return a instanceof l3 ? (N = a.reqId, k = a.source, [4, yn(function() {
                return M(Q, void 0, void 0, function() {
                  return p(this, function(v) {
                    switch (v.label) {
                      case 0:
                        return [4, this._unsentMessageCache.remove([N])];
                      case 1:
                        return v.sent(), [2];
                    }
                  });
                });
              })]) : [3, 11];
            case 10:
              return S.sent(), this._broadcastRemoveUnsentEvent(N, k), [3, 24];
            case 11:
              return a instanceof a3 ? (R = a.polls, k = a.source, this._cacheContext.localCacheEnabled ? (h = R.map(function(v) {
                return v.messageId;
              }), [4, Promise.all(h.map(function(v) {
                return Q._messageCache.get(v);
              }))]) : [3, 14]) : [3, 15];
            case 12:
              return (Z = S.sent().filter(function(v) {
                return v;
              })).length > 0 && R.forEach(function(v) {
                var G = Z.find(function(w) {
                  return w.messageId === v.messageId;
                });
                G && G.applyPoll(v);
              }), [4, yn(function() {
                return M(Q, void 0, void 0, function() {
                  return p(this, function(v) {
                    switch (v.label) {
                      case 0:
                        return [4, this._messageCache.upsert(Z)];
                      case 1:
                        return [2, v.sent()];
                    }
                  });
                });
              })];
            case 13:
              S.sent(), S.label = 14;
            case 14:
              return this._broadcastPollChangeLogEvent(R, k), [3, 24];
            case 15:
              return a instanceof SW ? (W = a.event, k = a.source, [4, this._messageCache.get(W.messageId)]) : [3, 19];
            case 16:
              return (F = S.sent()) && F.isUserMessage() && F.poll && F.poll.applyPollUpdateEvent(W) ? [4, yn(function() {
                return M(Q, void 0, void 0, function() {
                  return p(this, function(v) {
                    switch (v.label) {
                      case 0:
                        return [4, this._messageCache.upsert([F])];
                      case 1:
                        return [2, v.sent()];
                    }
                  });
                });
              })] : [3, 18];
            case 17:
              S.sent(), S.label = 18;
            case 18:
              return this._broadcastPollUpdateEvent(W, k), [3, 24];
            case 19:
              return a instanceof KR ? (m = a.event, k = a.source, [4, this._messageCache.get(m.messageId)]) : [3, 23];
            case 20:
              return (E = S.sent()) && E.isUserMessage() && E.poll && E.poll.applyPollVoteEvent(m) ? [4, yn(function() {
                return M(Q, void 0, void 0, function() {
                  return p(this, function(v) {
                    switch (v.label) {
                      case 0:
                        return [4, this._messageCache.upsert([E])];
                      case 1:
                        return [2, v.sent()];
                    }
                  });
                });
              })] : [3, 22];
            case 21:
              S.sent(), S.label = 22;
            case 22:
              return this._broadcastPollVoteEvent(m, k), [3, 24];
            case 23:
              a instanceof t3 ? (u = a.event, k = a.source, u.messageId > 0 && this._broadcastReactionUpdateEvent(u, k)) : a instanceof n3 && (b = a.event, k = a.source, this._broadcastThreadUpdateEvent(b, k)), S.label = 24;
            case 24:
              return [2];
          }
        });
      });
    }), l;
  }
  return J(n, e), Object.defineProperty(n.prototype, "_cacheContext", { get: function() {
    return D.of(this._iid).cacheContext;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "_dispatcher", { get: function() {
    return D.of(this._iid).dispatcher;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "_messageCache", { get: function() {
    return ac.of(this._iid);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "_unsentMessageCache", { get: function() {
    return bV.of(this._iid);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "_notificationCache", { get: function() {
    return NB.of(this._iid);
  }, enumerable: !1, configurable: !0 }), n.of = function(t, l) {
    var a;
    return l === void 0 && (l = !1), ns[t] && !l || (ns[t] && ((a = ns[t]._dispatcherContext) === null || a === void 0 || a.close()), ns[t] = new n(t)), ns[t];
  }, n.prototype._broadcastUpdateEvent = function(t, l) {
    var a, d;
    try {
      for (var r = be(this._observers.values()), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        c.onUpdate && c.onUpdate(t, l);
      }
    } catch (V) {
      a = { error: V };
    } finally {
      try {
        i && !i.done && (d = r.return) && d.call(r);
      } finally {
        if (a)
          throw a.error;
      }
    }
  }, n.prototype._broadcastPollChangeLogEvent = function(t, l) {
    var a, d;
    try {
      for (var r = be(this._observers.values()), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        c.onPollChangeLogUpdate && c.onPollChangeLogUpdate(t, l);
      }
    } catch (V) {
      a = { error: V };
    } finally {
      try {
        i && !i.done && (d = r.return) && d.call(r);
      } finally {
        if (a)
          throw a.error;
      }
    }
  }, n.prototype._broadcastPollUpdateEvent = function(t, l) {
    var a, d;
    try {
      for (var r = be(this._observers.values()), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        c.onPollUpdate && c.onPollUpdate(t, l);
      }
    } catch (V) {
      a = { error: V };
    } finally {
      try {
        i && !i.done && (d = r.return) && d.call(r);
      } finally {
        if (a)
          throw a.error;
      }
    }
  }, n.prototype._broadcastPollVoteEvent = function(t, l) {
    var a, d;
    try {
      for (var r = be(this._observers.values()), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        c.onPollVote && c.onPollVote(t, l);
      }
    } catch (V) {
      a = { error: V };
    } finally {
      try {
        i && !i.done && (d = r.return) && d.call(r);
      } finally {
        if (a)
          throw a.error;
      }
    }
  }, n.prototype._broadcastRemoveEvent = function(t, l) {
    var a, d;
    try {
      for (var r = be(this._observers.values()), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        c.onRemove && c.onRemove(t, l);
      }
    } catch (V) {
      a = { error: V };
    } finally {
      try {
        i && !i.done && (d = r.return) && d.call(r);
      } finally {
        if (a)
          throw a.error;
      }
    }
  }, n.prototype._broadcastRemoveUnsentEvent = function(t, l) {
    var a, d;
    try {
      for (var r = be(this._observers.values()), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        c.onRemoveUnsent && c.onRemoveUnsent(t, l);
      }
    } catch (V) {
      a = { error: V };
    } finally {
      try {
        i && !i.done && (d = r.return) && d.call(r);
      } finally {
        if (a)
          throw a.error;
      }
    }
  }, n.prototype._broadcastReactionUpdateEvent = function(t, l) {
    var a, d;
    try {
      for (var r = be(this._observers.values()), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        c.onReactionUpdate && c.onReactionUpdate(t, l);
      }
    } catch (V) {
      a = { error: V };
    } finally {
      try {
        i && !i.done && (d = r.return) && d.call(r);
      } finally {
        if (a)
          throw a.error;
      }
    }
  }, n.prototype._broadcastThreadUpdateEvent = function(t, l) {
    var a, d;
    try {
      for (var r = be(this._observers.values()), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        c.onThreadInfoUpdate && c.onThreadInfoUpdate(t, l);
      }
    } catch (V) {
      a = { error: V };
    } finally {
      try {
        i && !i.done && (d = r.return) && d.call(r);
      } finally {
        if (a)
          throw a.error;
      }
    }
  }, n.prototype.subscribe = function(t, l) {
    this._observers.set(t, l);
  }, n.prototype.unsubscribe = function(t) {
    this._observers.delete(t);
  }, n.prototype.unsubscribeAll = function() {
    this._observers.clear();
  }, n;
}(ml), RB = function(e) {
  function n(t) {
    var l = this, a = t.reverse, d = a !== void 0 && a, r = t.limit, i = r === void 0 ? 20 : r, c = t.token;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(Mk), l.params = je({ token: c, limit: i, reverse: d, order: zT.UPDATED_AT, show_ui_template: !0, show_color_variables: !0 }), l;
  }
  return J(n, e), n;
}(Te), hB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this, d = l.next, r = l.has_more, i = r !== void 0 && r, c = l.templates;
    return a.nextToken = d, a.hasMore = i, a.templates = c.map(function(V) {
      return { template: JSON.stringify(V) };
    }), a;
  }
  return J(n, e), n;
}(ue), ZB = function(e) {
  function n(t) {
    var l = this, a = t.key;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(Mk, "/").concat(a), l;
  }
  return J(n, e), n;
}(Te), TB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.template = JSON.stringify(l), a;
  }
  return J(n, e), n;
}(ue), yu = {}, tl = function() {
  function e(n, t) {
    var l = t.sdkState, a = t.dispatcher, d = t.requestQueue, r = t.onlineDetector, i = t.cacheContext;
    this._iid = n, this._sdkState = l, this._requestQueue = d, this._dispatcher = a, this._cacheContext = i, ac.of(n), bV.of(n), j3.of(n), this.fileMessageQueue = new Wy(n, { sdkState: l, dispatcher: a, requestQueue: d, onlineDetector: r, cacheContext: i }), yu[n] = this;
  }
  return e.of = function(n) {
    return yu[n];
  }, e.prototype.buildMessageFromSerializedData = function(n) {
    var t = hi(n);
    if (t.notificationId)
      return new SV(this._iid, SV.payloadify(t));
    switch (t.messageType) {
      case Gn.USER:
        return new kl(this._iid, kl.payloadify(t));
      case Gn.FILE:
        return Da._isMultipleFilesMessageSerializedData(t) ? new Da(this._iid, Da.payloadify(t)) : new Ln(this._iid, Ln.payloadify(t));
      case Gn.ADMIN:
        return new Qc(this._iid, Qc.payloadify(t));
    }
    throw j.invalidParameters;
  }, e.prototype.buildUserMessageCreateParamsFromSerializedData = function(n, t) {
    return je(Ae({ data: t.data, customType: t.customType, mentionType: t.mentionType, mentionedUserIds: t.mentionedUserIds, mentionedUsers: t.mentionedUsers, mentionedMessageTemplate: t.mentionedMessageTemplate, metaArrays: t.metaArrays, parentMessageId: t.parentMessageId, isReplyToChannel: n.isReplyToChannel, pushNotificationDeliveryOption: n.pushNotificationDeliveryOption, appleCriticalAlertOptions: t.appleCriticalAlertOptions, reqId: t.reqId, message: t.message, translationTargetLanguages: Object.keys(t.translations), pollId: n.pollId }));
  }, e.prototype.buildFileMessageCreateParamsFromSerializedData = function(n, t) {
    var l;
    return je(Ae({ data: t.data, customType: t.customType, mentionType: t.mentionType, mentionedUserIds: t.mentionedUserIds, mentionedUsers: t.mentionedUsers, mentionedMessageTemplate: t.mentionedMessageTemplate, metaArrays: t.metaArrays, parentMessageId: t.parentMessageId, isReplyToChannel: n.isReplyToChannel, pushNotificationDeliveryOption: n.pushNotificationDeliveryOption, appleCriticalAlertOptions: t.appleCriticalAlertOptions, reqId: t.reqId, file: n.file, fileKey: n.fileKey, fileUrl: t.plainUrl, fileName: t.name, fileSize: t.size, mimeType: t.type, thumbnailSizes: (l = t.thumbnails) === null || l === void 0 ? void 0 : l.map(function(a) {
      return { maxWidth: a.width, maxHeight: a.height };
    }), fileType: n.fileType, requireAuth: t.requireAuth }));
  }, e.prototype.buildMultipleFilesMessageCreateParamsFromSerializedData = function(n, t) {
    var l = this;
    return je({ data: t.data, customType: t.customType, mentionType: t.mentionType, mentionedUserIds: t.mentionedUserIds, mentionedUsers: t.mentionedUsers, mentionedMessageTemplate: t.mentionedMessageTemplate, metaArrays: t.metaArrays, parentMessageId: t.parentMessageId, isReplyToChannel: n.isReplyToChannel, pushNotificationDeliveryOption: n.pushNotificationDeliveryOption, appleCriticalAlertOptions: t.appleCriticalAlertOptions, reqId: t.reqId, fileInfoList: n.fileInfoList.map(function(a) {
      return new dR(l._iid, a);
    }) });
  }, e.prototype.buildScheduledUserMessageCreateParamsFromSerializedData = function(n, t) {
    return x(x({}, this.buildUserMessageCreateParamsFromSerializedData(n, t)), { scheduledAt: n.scheduledAt });
  }, e.prototype.buildScheduledFileMessageCreateParamsFromSerializedData = function(n, t) {
    return x(x({}, this.buildFileMessageCreateParamsFromSerializedData(n, t)), { scheduledAt: n.scheduledAt });
  }, e.prototype.buildSenderFromSerializedData = function(n) {
    var t = hi(n);
    return new Yc(this._iid, Yc.payloadify(t));
  }, e.prototype.getMessage = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = new my(n), [4, this._requestQueue.send(t)];
          case 1:
            return l = a.sent(), [2, l.as(uy).message];
        }
      });
    });
  }, e.prototype.getScheduledMessage = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = new Ey(n), [4, this._requestQueue.send(t)];
          case 1:
            return l = a.sent(), [2, l.as(Sy).message];
        }
      });
    });
  }, e.prototype.getMessagesByMessageId = function(n, t, l, a, d) {
    return d === void 0 && (d = ne.REQUEST_MESSAGE), M(this, void 0, void 0, function() {
      var r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return r = new gU(x(x({ channelType: t, channelUrl: n, token: String(l) }, Ls), a)), [4, this._requestQueue.send(r)];
          case 1:
            return i = V.sent(), c = i.as(IU).messages, this._dispatcher.dispatch(new En({ messages: c, source: d })), [2, c];
        }
      });
    });
  }, e.prototype.getMessagesByTimestamp = function(n, t, l, a, d) {
    return d === void 0 && (d = ne.REQUEST_MESSAGE), M(this, void 0, void 0, function() {
      var r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return r = new gU(x(x({ channelType: t, channelUrl: n, timestamp: l }, Ls), a)), [4, this._requestQueue.send(r)];
          case 1:
            return i = V.sent(), c = i.as(IU).messages, this._dispatcher.dispatch(new En({ messages: c, source: d })), [2, c];
        }
      });
    });
  }, e.prototype._getMessagesByTimestampForCollection = function(n, t, l, a, d, r, i) {
    return d === void 0 && (d = ne.REQUEST_MESSAGE), M(this, void 0, void 0, function() {
      var c, V, s, o, U, N;
      return p(this, function(R) {
        switch (R.label) {
          case 0:
            return c = new gU(x(x(x({ channelType: t, channelUrl: n, timestamp: l }, Ls), a), { checkingHasNext: r, checkingContinuousMessages: i })), [4, this._requestQueue.send(c)];
          case 1:
            return V = R.sent(), s = V.as(IU), o = s.messages, U = s.isContinuousMessages, N = s.hasNext, this._dispatcher.dispatch(new En({ messages: o, source: d })), [2, { messages: o, isContinuousMessages: U, hasNext: N }];
        }
      });
    });
  }, e.prototype.getThreadedMessagesByTimestamp = function(n, t, l, a) {
    return a === void 0 && (a = ne.REQUEST_THREADED_MESSAGE), M(this, void 0, void 0, function() {
      var d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return d = new gU(x(x(x({ channelUrl: n.channelUrl, channelType: n.channelType, timestamp: t }, tU), l), { replyType: al.ALL, parentMessageId: n.messageId, includeThreadInfo: !0 })), [4, this._requestQueue.send(d)];
          case 1:
            return r = V.sent(), i = r.as(IU).messages, (c = i.slice(1)).forEach(function(s) {
              s.parentMessage = n;
            }), this._dispatcher.dispatch(new En({ messages: c, source: a })), [2, { parentMessage: i[0], threadedMessages: c }];
        }
      });
    });
  }, e.prototype.getMessageTemplatesByToken = function(n, t) {
    return t === void 0 && (t = {}), M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return l = new RB(x({ token: n }, t)), [4, this._requestQueue.send(l)];
          case 1:
            return a = V.sent(), d = a.as(hB), r = d.hasMore, i = d.nextToken, c = d.templates, [2, { hasMore: r, token: i, templates: c }];
        }
      });
    });
  }, e.prototype.getMessageTemplate = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = new ZB({ key: n }), [4, this._requestQueue.send(t)];
          case 1:
            return l = a.sent(), [2, { template: l.as(TB).template }];
        }
      });
    });
  }, e.prototype.getMessageChangelogs = function(n, t, l, a, d) {
    return d === void 0 && (d = ne.REQUEST_MESSAGE_CHANGELOGS), M(this, void 0, void 0, function() {
      var r, i, c, V, s, o, U, N;
      return p(this, function(R) {
        switch (R.label) {
          case 0:
            return r = new py(je(Ae(x(x({ channelType: t, channelUrl: n, timestamp: typeof l == "number" ? l : null, token: typeof l == "string" ? l : null }, wT), a)))), [4, this._requestQueue.send(r)];
          case 1:
            return i = R.sent(), c = i.as(My), V = c.updatedMessages, s = c.deletedMessagesInfo, o = c.hasMore, U = c.nextToken, N = s.map(function(h) {
              return h.messageId;
            }), V.length > 0 && this._dispatcher.dispatch(new En({ messages: V, source: d })), N.length > 0 && this._dispatcher.dispatch(new EW({ messageIds: N, source: d })), [2, { updatedMessages: V, deletedMessageIds: N, hasMore: o, token: U }];
        }
      });
    });
  }, e;
}(), H3 = function(e) {
  function n(t, l) {
    var a = e.call(this, t) || this;
    a.targetMessageId = 0;
    var d = l.thread_info, r = l.parent_message_id, i = l.channel_url, c = l.channel_type;
    return d && B("object", d) && B("number", r) && B("string", i) && B("string", c) && (a.threadInfo = new aR(t, d), a.targetMessageId = r, a.channelUrl = i, a.channelType = c), a;
  }
  return J(n, e), n;
}(ml), FB = { channelUrl: "", channelType: Xt.BASE, messageId: 0, includeReactions: !1, includeMetaArray: !1, includeParentMessageInfo: !1, includeThreadInfo: !1 }, WB = function(e) {
  function n(t) {
    var l = t.channelCustomType, a = t.keyword, d = t.limit, r = t.reverse, i = t.exactMatch, c = t.channelUrl, V = t.order, s = t.messageTimestampFrom, o = t.messageTimestampTo, U = t.advancedQuery, N = t.targetFields, R = t.nextToken, h = e.call(this) || this;
    return h.method = he.GET, h.path = "".concat(Zx, "/messages"), h.params = { custom_type: l, query: a, limit: d, reverse: r, exact_match: i, channel_url: c, message_ts_from: s, message_ts_to: o, sort_field: V, advanced_query: U, target_fields: N, after: R }, h;
  }
  return J(n, e), n;
}(Te), mB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.messages = l.results.map(function(d) {
      return Hl(t, d);
    }), a.hasNext = l.has_next, a.nextToken = l.end_cursor, a.totalCount = l.total_count, a;
  }
  return J(n, e), n;
}(ue);
(function(e) {
  e.SCORE = "score", e.TIMESTAMP = "ts";
})(_s || (_s = {}));
var uB = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o, U, N = this;
    return (N = e.call(this, t, l) || this).keyword = "", N.reverse = !1, N.exactMatch = !1, N.channelUrl = "", N.channelCustomType = "", N.messageTimestampFrom = null, N.messageTimestampTo = null, N.order = _s.SCORE, N.advancedQuery = !1, N.targetFields = null, N._nextToken = "", N.totalCount = -1, N.keyword = l.keyword, N.reverse = (a = l.reverse) !== null && a !== void 0 && a, N.exactMatch = (d = l.exactMatch) !== null && d !== void 0 && d, N.channelUrl = (r = l.channelUrl) !== null && r !== void 0 ? r : "", N.channelCustomType = (i = l.channelCustomType) !== null && i !== void 0 ? i : "", N.messageTimestampFrom = (c = l.messageTimestampFrom) !== null && c !== void 0 ? c : null, N.messageTimestampTo = (V = l.messageTimestampTo) !== null && V !== void 0 ? V : null, N.order = (s = l.order) !== null && s !== void 0 ? s : _s.SCORE, N.advancedQuery = (o = l.advancedQuery) !== null && o !== void 0 && o, N.targetFields = (U = l.targetFields) !== null && U !== void 0 ? U : null, N;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && B("string", this.keyword) && this.keyword.length > 0 && B("boolean", this.reverse) && B("boolean", this.exactMatch) && B("string", this.channelUrl) && B("string", this.channelCustomType) && (B("number", this.messageTimestampFrom) || this.messageTimestampFrom === null) && (B("number", this.messageTimestampTo) || this.messageTimestampTo === null) && Qt(_s, this.order) && B("boolean", this.advancedQuery) && Jt("string", this.targetFields, !0);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new WB(Ae(x(x({}, this), { nextToken: this._nextToken ? this._nextToken : null }))), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = s.sent(), d = a.as(mB), r = d.messages, i = d.hasNext, c = d.nextToken, V = d.totalCount, this._nextToken = c, this._hasNext = i, this._isLoading = !1, this.totalCount = V, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(yr), pB = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.limit, r = t.token, i = e.call(this) || this;
    return i.method = he.GET, i.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/parent_thread_message"), i.params = je(Ae({ limit: d, token: r })), i;
  }
  return J(n, e), n;
}(Te), MB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.token = l.next, a.messages = l.messages.map(function(d) {
      return Hl(t, d);
    }), a;
  }
  return J(n, e), n;
}(ue), EB = function(e) {
  function n(t, l, a, d) {
    var r = e.call(this, t, l, a, d) || this;
    return r._edge = "", r;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this);
  }, n.prototype.load = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new pB({ channelType: this.channelType, channelUrl: this.channelUrl, token: this._edge, limit: this.limit }), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = c.sent(), d = a.as(MB), r = d.messages, i = d.token, this._edge = i, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar), SB = { channelUrl: "", scheduledMessageId: 0 }, kB = { reverse: !1, limit: 20 }, bB = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.name = "message", t;
  }
  return J(n, e), n.prototype.init = function(t, l) {
    var a = l.sdkState, d = l.dispatcher, r = l.sessionManager, i = l.requestQueue, c = l.logger, V = l.onlineDetector, s = l.cacheContext;
    e.prototype.init.call(this, t, { sdkState: a, dispatcher: d, sessionManager: r, requestQueue: i, logger: c, onlineDetector: V, cacheContext: s }), this._manager = new tl(t, { sdkState: a, dispatcher: d, requestQueue: i, onlineDetector: V, cacheContext: s });
  }, n.prototype.buildMessageFromSerializedData = function(t) {
    return this._manager.buildMessageFromSerializedData(t);
  }, n.prototype.buildSenderFromSerializedData = function(t) {
    return this._manager.buildSenderFromSerializedData(t);
  }, n.prototype.getMessage = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return l = x(x({}, FB), t), Ze(function(r) {
              return B("string", r.channelUrl) && Qt(Xt, r.channelType) && B("number", r.messageId) && B("boolean", r.includeReactions, !0) && B("boolean", r.includeMetaArray, !0) && B("boolean", r.includeParentMessageInfo, !0) && B("boolean", r.includeThreadInfo, !0);
            }(l)).throw(j.invalidParameters), [4, this._manager.getMessage(l)];
          case 1:
            if ((a = d.sent()) instanceof Bl || a instanceof SV || a === null)
              return [2, a];
            throw "Unknown message type is given.";
        }
      });
    });
  }, n.prototype.getScheduledMessage = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        return l = x(x({}, SB), t), Ze(function(d) {
          return B("string", d.channelUrl) && d.channelUrl !== "" && B("number", d.scheduledMessageId) && d.scheduledMessageId > 0;
        }(l)).throw(j.invalidParameters), [2, this._manager.getScheduledMessage(l)];
      });
    });
  }, n.prototype.getMessageTemplatesByToken = function(t, l) {
    return l === void 0 && (l = {}), M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        return a = x(x({}, kB), l), Ze(B("string", t, !0) && function(r) {
          return B("boolean", r.reverse, !0) && B("number", r.limit, !0);
        }(a)).throw(j.invalidParameters), [2, this._manager.getMessageTemplatesByToken(t, a)];
      });
    });
  }, n.prototype.getMessageTemplate = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return Ze(B("string", t)).throw(j.invalidParameters), [2, this._manager.getMessageTemplate(t)];
      });
    });
  }, n;
}(CR), Xn, Ps, PT;
(function(e) {
  e.LATEST_LAST_MESSAGE = "latest_last_message", e.CHRONOLOGICAL = "chronological", e.CHANNEL_NAME_ALPHABETICAL = "channel_name_alphabetical", e.METADATA_VALUE_ALPHABETICAL = "metadata_value_alphabetical";
})(Xn || (Xn = {})), function(e) {
  e.CHRONOLOGICAL = "chronological", e.CHANNEL_NAME_ALPHABETICAL = "channel_name_alphabetical", e.METADATA_VALUE_ALPHABETICAL = "metadata_value_alphabetical";
}(Ps || (Ps = {})), function(e) {
  e.CREATED_AT = "created_at", e.SCHEDULED_AT = "scheduled_at";
}(PT || (PT = {}));
var uo, bN = function(e) {
  switch (e) {
    case Xn.LATEST_LAST_MESSAGE:
      return ["-lastMessageUpdatedAt", "-createdAt", "syncIndex"];
    case Xn.CHRONOLOGICAL:
      return ["-createdAt", "syncIndex"];
    case Xn.CHANNEL_NAME_ALPHABETICAL:
      return ["name"];
    default:
      return ["-lastMessageUpdatedAt", "-createdAt", "syncIndex"];
  }
}, f3 = function(e) {
  function n(t) {
    var l = t.message, a = e.call(this) || this;
    return a.message = l, a;
  }
  return J(n, e), n;
}(un), Bu = {}, bs = function() {
  function e(n, t) {
    var l = t.localCacheEnabled, a = t.enableAutoResend, d = t.dispatcher, r = t.sdkState, i = t.logger, c = this;
    this._iid = n, Bu[n] = this, this._localCacheEnabled = l, this._enableAutoResend = a, this._isProcessingAutoResend = !1, this._autoResendQueue = [], this._dispatcher = d, this._logger = i, this._sdkState = r, this._localCacheEnabled && d.on(function(V) {
      if (V instanceof ua)
        switch (V.stateType) {
          case tn.CONNECTED:
            c._isProcessingAutoResend || c.processAutoResendRegisteredPendingMessages().then(function() {
              return c._processNextAutoResend();
            });
            break;
          case tn.INTERNAL_DISCONNECTED:
          case tn.EXTERNAL_DISCONNECTED:
            c._isProcessingAutoResend = !1;
        }
    });
  }
  return e.of = function(n) {
    return Bu[n];
  }, e.prototype.processNonAutoResendRegisteredPendingMessages = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return this._enableAutoResend ? [4, this._fetchAllCachedPendingMessages()] : [2];
          case 1:
            n = i.sent();
            try {
              for (t = be(n), l = t.next(); !l.done; l = t.next())
                (a = l.value).errorCode === 0 && (this._logger.debug("cached pending message is not auto-resend registered. changing its sending status to failed: ", a.reqId), a.sendingStatus = $t.FAILED, a.errorCode = nt.ACK_TIMEOUT, this._dispatcher.dispatch(new En({ messages: [a], source: ne.LOCAL_MESSAGE_FAILED })));
            } catch (c) {
              d = { error: c };
            } finally {
              try {
                l && !l.done && (r = t.return) && r.call(t);
              } finally {
                if (d)
                  throw d.error;
              }
            }
            return [2];
        }
      });
    });
  }, e.prototype.processAutoResendRegisteredPendingMessages = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return [4, this._fetchAllCachedPendingMessages()];
          case 1:
            n = V.sent();
            try {
              for (t = be(n), l = t.next(); !l.done; l = t.next())
                a = l.value, this._enableAutoResend && a.errorCode && CN(a.errorCode) && (d = (/* @__PURE__ */ new Date()).getTime(), r = a.createdAt + 2592e5, this._enableAutoResend && d <= r ? this._autoResendQueue.map(function(s) {
                  return s.reqId;
                }).indexOf(a.reqId) < 0 && this._autoResendQueue.push(a) : (this._logger.debug("auto-resend registered pending messaged expired. expiration date: ", new Date(r).toLocaleString()), a.sendingStatus = $t.FAILED, this._dispatcher.dispatch(new En({ messages: [a], source: ne.LOCAL_MESSAGE_FAILED }))));
            } catch (s) {
              i = { error: s };
            } finally {
              try {
                l && !l.done && (c = t.return) && c.call(t);
              } finally {
                if (i)
                  throw i.error;
              }
            }
            return [2];
        }
      });
    });
  }, e.prototype.completeCurrentAndProcessNextAutoResend = function(n) {
    if (this._localCacheEnabled && this._enableAutoResend && (n.sendingStatus === $t.SUCCEEDED || n.sendingStatus === $t.FAILED && !CN(n.errorCode))) {
      var t = this.indexOf(n);
      t >= 0 && this._autoResendQueue.splice(t, 1), t === 0 && this._processNextAutoResend();
    }
  }, e.prototype._fetchAllCachedPendingMessages = function() {
    return M(this, void 0, void 0, function() {
      var n, t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return n = bV.of(this._iid), (t = new mi()).replyType = al.ALL, [4, n.fetch({ sendingStatus: $t.PENDING, backward: !0, filter: t })];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, e.prototype.indexOf = function(n) {
    return this._autoResendQueue.length > 0 ? this._autoResendQueue.map(function(t) {
      return t.reqId;
    }).indexOf(n.reqId) : -1;
  }, e.prototype._isNotInQueue = function(n) {
    return this._autoResendQueue.map(function(t) {
      return t.reqId;
    }).indexOf(n.reqId) === -1;
  }, e.prototype._processNextAutoResend = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        if (this._localCacheEnabled && this._enableAutoResend && this._sdkState.appState === "foreground")
          try {
            this._autoResendQueue.length > 0 ? (this._isProcessingAutoResend || (this._logger.debug("auto-resend queue started."), this._isProcessingAutoResend = !0), n = this._autoResendQueue[0], this._dispatcher.dispatch(new f3({ message: n })), this._logger.debug("processing auto-resend for message request id: ", n.reqId)) : (this._logger.debug("auto-resend queue finished."), this._isProcessingAutoResend = !1);
          } catch (l) {
            this._logger.warn("process auto-resend error: ", l), this._isProcessingAutoResend = !1;
          }
        return [2];
      });
    });
  }, e;
}();
(function(e) {
  e[e.USER_BLOCK = 20001] = "USER_BLOCK", e[e.USER_UNBLOCK = 2e4] = "USER_UNBLOCK", e[e.FRIEND_DISCOVERED = 20900] = "FRIEND_DISCOVERED";
})(uo || (uo = {}));
var sR = function() {
  function e(n) {
    this.category = n.cat, this.data = n.data;
  }
  return e.getDataAsUserBlockEvent = function(n, t) {
    var l = t.data, a = l.blocker, d = l.blockee;
    return { blocker: new xt(n, a), blockee: new xt(n, d) };
  }, e.getDataAsFriendDiscoveredEvent = function(n, t) {
    var l = t.data.friend_discoveries;
    return { friendDiscoveries: Array.isArray(l) ? l.map(function(a) {
      return new xt(n, a);
    }) : [] };
  }, e;
}(), w3 = function(e) {
  function n(t, l) {
    var a = l.userId, d = e.call(this) || this;
    return d._iid = t, d.userId = a, d;
  }
  return J(n, e), n;
}(un), g3 = function(e) {
  function n() {
    return e.call(this) || this;
  }
  return J(n, e), n;
}(un), I3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "USEV", a) || this;
    return d.event = new sR(a), d;
  }
  return J(n, e), n;
}(Wn), YB = function(e, n) {
  this.pollId = 0, this.messageId = 0, this.pollId = n.poll.id, this.messageId = n.poll.message_id, this._iid = e, this._payload = n;
}, Vn;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.CHANNEL_ENTER = 10102] = "CHANNEL_ENTER", e[e.CHANNEL_EXIT = 10103] = "CHANNEL_EXIT", e[e.USER_CHANNEL_MUTE = 10201] = "USER_CHANNEL_MUTE", e[e.USER_CHANNEL_UNMUTE = 10200] = "USER_CHANNEL_UNMUTE", e[e.USER_CHANNEL_BAN = 10601] = "USER_CHANNEL_BAN", e[e.USER_CHANNEL_UNBAN = 10600] = "USER_CHANNEL_UNBAN", e[e.CHANNEL_FREEZE = 10701] = "CHANNEL_FREEZE", e[e.CHANNEL_UNFREEZE = 10700] = "CHANNEL_UNFREEZE", e[e.TYPING_START = 10900] = "TYPING_START", e[e.TYPING_END = 10901] = "TYPING_END", e[e.CHANNEL_JOIN = 1e4] = "CHANNEL_JOIN", e[e.CHANNEL_LEAVE = 10001] = "CHANNEL_LEAVE", e[e.CHANNEL_OPERATOR_UPDATE = 10002] = "CHANNEL_OPERATOR_UPDATE", e[e.CHANNEL_INVITE = 10020] = "CHANNEL_INVITE", e[e.CHANNEL_ACCEPT_INVITE = 10021] = "CHANNEL_ACCEPT_INVITE", e[e.CHANNEL_DECLINE_INVITE = 10022] = "CHANNEL_DECLINE_INVITE", e[e.CHANNEL_PROP_CHANGED = 11e3] = "CHANNEL_PROP_CHANGED", e[e.CHANNEL_DELETED = 12e3] = "CHANNEL_DELETED", e[e.CHANNEL_META_DATA_CHANGED = 11100] = "CHANNEL_META_DATA_CHANGED", e[e.CHANNEL_META_COUNTERS_CHANGED = 11200] = "CHANNEL_META_COUNTERS_CHANGED", e[e.CHANNEL_HIDE = 13e3] = "CHANNEL_HIDE", e[e.CHANNEL_UNHIDE = 13001] = "CHANNEL_UNHIDE", e[e.PINNED_MESSAGE_CHANGED = 11300] = "PINNED_MESSAGE_CHANGED";
})(Vn || (Vn = {}));
var QB = function() {
  function e(n) {
    var t;
    this.channelUrl = n.channel_url, this.channelType = n.channel_type, this.category = n.cat, this.data = (t = n.data) !== null && t !== void 0 ? t : {}, this.ts = n.ts;
  }
  return Object.defineProperty(e.prototype, "isGroupChannelEvent", { get: function() {
    return this.channelType === Xt.GROUP;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "isOpenChannelEvent", { get: function() {
    return this.channelType === Xt.OPEN;
  }, enumerable: !1, configurable: !0 }), e;
}(), Dr = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return d.event = new QB(a), d;
  }
  return J(n, e), n;
}(Wn), L3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, l, a) || this, r = a.data.operators, i = r === void 0 ? [] : r;
    return d.operators = i.map(function(c) {
      return new xt(d._iid, c);
    }), d;
  }
  return J(n, e), n;
}(Dr), C3 = function(e) {
  function n(t, l) {
    var a = e.call(this, t) || this;
    return a._logger = l.logger, a._sdkState = l.sdkState, a._sessionManager = l.sessionManager, a._requestQueue = l.requestQueue, a._dispatcher = l.dispatcher, a._cacheContext = l.cacheContext, a._channelType = l.channelType, a;
  }
  return J(n, e), Object.defineProperty(n.prototype, "_messageBroadcast", { get: function() {
    return j3.of(this._iid);
  }, enumerable: !1, configurable: !0 }), n.prototype.subscribeMessageEvent = function(t, l) {
    this._messageBroadcast.subscribe(t, l);
  }, n.prototype.unsubscribeMessageEvent = function(t) {
    this._messageBroadcast.unsubscribe(t);
  }, n.prototype.getMessageFromCache = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2, null];
      });
    });
  }, n.prototype.getExactlyMatchingMessagesForTokenFromCache = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      return p(this, function(d) {
        return [2, []];
      });
    });
  }, n.prototype.getMessagesFromCache = function(t, l, a, d, r, i) {
    return M(this, void 0, void 0, function() {
      return p(this, function(c) {
        return [2, []];
      });
    });
  }, n.prototype.getPollMessagesFromCache = function(t, l, a, d) {
    return M(this, void 0, void 0, function() {
      return p(this, function(r) {
        return [2, []];
      });
    });
  }, n.prototype.getCachedMessageCountBetween = function(t, l, a, d) {
    return M(this, void 0, void 0, function() {
      return p(this, function(r) {
        return [2, 0];
      });
    });
  }, n.prototype.getUnsentMessagesFromCache = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        return [2, []];
      });
    });
  }, n.prototype.removeFailedMessageFromCache = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2];
      });
    });
  }, n;
}(ml), K3 = function(e) {
  function n(t, l, a) {
    var d, r, i, c, V = this;
    (V = e.call(this, t, "ADMM", a) || this).message = new Qc(t, a);
    var s = D.of(t).sdkState;
    return V.isMentioned = Ec(V.message.mentionType, (i = (d = V.message.mentionedUserIds) !== null && d !== void 0 ? d : (r = V.message.mentionedUsers) === null || r === void 0 ? void 0 : r.map(function(o) {
      return o.userId;
    })) !== null && i !== void 0 ? i : [], s.userId), V.forceUpdateLastMessage = (c = a.force_update_last_message) !== null && c !== void 0 && c, V;
  }
  return J(n, e), n;
}(Wn), _3 = function(e) {
  function n(t, l, a) {
    var d, r, i, c, V, s = this;
    (s = e.call(this, t, "AEDI", a) || this).message = new Qc(t, a);
    var o = D.of(t).sdkState;
    return s.mentionCountChange = TW({ mentionType: (d = a.old_values) === null || d === void 0 ? void 0 : d.mention_type, mentionedUserIds: (i = (r = a.old_values) === null || r === void 0 ? void 0 : r.mentioned_user_ids) !== null && i !== void 0 ? i : [] }, Ae({ mentionType: s.message.mentionType, mentionedUserIds: (c = s.message.mentionedUserIds) !== null && c !== void 0 ? c : (V = s.message.mentionedUsers) === null || V === void 0 ? void 0 : V.map(function(U) {
      return U.userId;
    }) }), o.userId), s;
  }
  return J(n, e), n;
}(Wn), P3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "MRCT", a) || this;
    return d.channelUrl = a.channel_url, d.channelType = a.channel_type, d.event = new kW(a), d;
  }
  return J(n, e), n;
}(Wn), A3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "MTHD", a) || this;
    return d.event = new H3(t, a), d;
  }
  return J(n, e), n;
}(Wn), q3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "MCNT", a) || this;
    return d.groupChannelMemberCounts = a.group_channels.map(function(r) {
      return { channelUrl: r.channel_url, memberCount: r.member_count, joinedMemberCount: r.joined_member_count, updatedAt: r.ts };
    }), d.openChannelMemberCounts = a.open_channels.map(function(r) {
      return { channelUrl: r.channel_url, participantCount: r.participant_count, updatedAt: r.ts };
    }), d;
  }
  return J(n, e), n;
}(Wn), $3 = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "PEDI", a) || this;
    return d.event = new YB(t, a), d.status = jT(a.poll.status) || a.poll.status, d.channelUrl = a.channel_url, d.channelType = a.channel_type, d;
  }
  return J(n, e), n;
}(Wn), On;
(function(e) {
  e.NONE = "none", e.JOINED = "joined", e.INVITED = "invited", e.LEFT = "left";
})(On || (On = {}));
var Cd, ta, la, Ti, Zd, oR, Er, po, Ga = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.state = null, a.role = null, a.isMuted = !1, a.isBlockedByMe = !1, a.isBlockingMe = !1, a.state = Qt(On, l.state) ? l.state : null, a.role = Qt(ed, l.role) ? l.role : null, typeof l.is_muted == "boolean" && (a.isMuted = l.is_muted), typeof l.is_blocked_by_me == "boolean" && (a.isBlockedByMe = l.is_blocked_by_me), typeof l.is_blocking_me == "boolean" && (a.isBlockingMe = l.is_blocking_me), a;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { state: t.state, role: t.role, is_muted: t.isMuted, is_blocked_by_me: t.isBlockedByMe, is_blocking_me: t.isBlockingMe })));
  }, n;
}(BV);
(function(e) {
  e.ALL = "all", e.PUBLIC = "public", e.PRIVATE = "private";
})(Cd || (Cd = {})), function(e) {
  e.ALL = "all", e.JOINED = "joined_only", e.INVITED = "invited_only", e.INVITED_BY_FRIEND = "invited_by_friend", e.INVITED_BY_NON_FRIEND = "invited_by_non_friend";
}(ta || (ta = {})), function(e) {
  e.ALL = "all", e.SUPER = "super", e.NON_SUPER = "nonsuper", e.BROADCAST_ONLY = "broadcast_only", e.EXCLUSIVE_ONLY = "exclusive_only";
}(la || (la = {})), function(e) {
  e.ALL = "all", e.UNREAD_MESSAGE = "unread_message";
}(Ti || (Ti = {})), function(e) {
  e.ALL = "all", e.UNHIDDEN = "unhidden_only", e.HIDDEN = "hidden_only", e.HIDDEN_ALLOW_AUTO_UNHIDE = "hidden_allow_auto_unhide", e.HIDDEN_PREVENT_AUTO_UNHIDE = "hidden_prevent_auto_unhide";
}(Zd || (Zd = {})), function(e) {
  e.ALL = "all", e.OPERATOR = "operator", e.NONOPERATOR = "nonoperator";
}(oR || (oR = {})), function(e) {
  e.AND = "AND", e.OR = "OR";
}(Er || (Er = {})), function(e) {
  e.MEMBER_NICKNAME = "member_nickname", e.CHANNEL_NAME = "channel_name";
}(po || (po = {}));
var il, eb = function() {
  function e(n) {
    var t, l, a, d, r, i, c, V, s, o, U, N, R, h;
    this._searchFilter = null, this._userIdsFilter = null, this.includeEmpty = (t = n == null ? void 0 : n.includeEmpty) !== null && t !== void 0 && t, this.nicknameContainsFilter = (l = n == null ? void 0 : n.nicknameContainsFilter) !== null && l !== void 0 ? l : null, this.nicknameStartsWithFilter = (a = n == null ? void 0 : n.nicknameStartsWithFilter) !== null && a !== void 0 ? a : null, this.nicknameExactMatchFilter = (d = n == null ? void 0 : n.nicknameExactMatchFilter) !== null && d !== void 0 ? d : null, this.channelNameContainsFilter = (r = n == null ? void 0 : n.channelNameContainsFilter) !== null && r !== void 0 ? r : "", this.myMemberStateFilter = (i = n == null ? void 0 : n.myMemberStateFilter) !== null && i !== void 0 ? i : ta.ALL, this.customTypesFilter = (c = n == null ? void 0 : n.customTypesFilter) !== null && c !== void 0 ? c : null, this.channelUrlsFilter = (V = n == null ? void 0 : n.channelUrlsFilter) !== null && V !== void 0 ? V : null, this.superChannelFilter = (s = n == null ? void 0 : n.superChannelFilter) !== null && s !== void 0 ? s : la.ALL, this.publicChannelFilter = (o = n == null ? void 0 : n.publicChannelFilter) !== null && o !== void 0 ? o : Cd.ALL, this.customTypeStartsWithFilter = (U = n == null ? void 0 : n.customTypeStartsWithFilter) !== null && U !== void 0 ? U : null, this.unreadChannelFilter = (N = n == null ? void 0 : n.unreadChannelFilter) !== null && N !== void 0 ? N : Ti.ALL, this.hiddenChannelFilter = (R = n == null ? void 0 : n.hiddenChannelFilter) !== null && R !== void 0 ? R : Zd.UNHIDDEN, this.includeFrozen = (h = n == null ? void 0 : n.includeFrozen) === null || h === void 0 || h, n != null && n.createdAfter && (this.createdAfter = n.createdAfter), n != null && n.createdBefore && (this.createdBefore = n.createdBefore);
  }
  return e.prototype._isFriend = function(n) {
    return !(!n || !n.friendDiscoveryKey && !n.friendName);
  }, Object.defineProperty(e.prototype, "searchFilter", { get: function() {
    return this._searchFilter;
  }, enumerable: !1, configurable: !0 }), e.prototype.setSearchFilter = function(n, t) {
    Array.isArray(n) && n.length !== 0 && typeof t == "string" && t && (this._searchFilter = { query: t, fields: n });
  }, Object.defineProperty(e.prototype, "userIdsFilter", { get: function() {
    return this._userIdsFilter;
  }, enumerable: !1, configurable: !0 }), e.prototype.setUserIdsFilter = function(n, t, l) {
    l === void 0 && (l = Er.AND), this._userIdsFilter = { userIds: n, includeMode: t, queryType: l };
  }, e.prototype.clone = function() {
    var n, t = new e();
    this.searchFilter && t.setSearchFilter(this.searchFilter.fields, (n = this.searchFilter.query) !== null && n !== void 0 ? n : void 0), this.userIdsFilter && t.setUserIdsFilter(this.userIdsFilter.userIds, this.userIdsFilter.includeMode, this.userIdsFilter.queryType);
    var l = JSON.parse(JSON.stringify(this));
    return Object.keys(l).forEach(function(a) {
      t[a] = l[a];
    }), t;
  }, e.prototype.match = function(n, t) {
    if (this._searchFilter) {
      var l = this._searchFilter, a = l.query, d = l.fields;
      if (a && d && d.length > 0 && !d.some(function(R) {
        switch (R) {
          case po.CHANNEL_NAME:
            return n.name.toLowerCase().includes(a.toLowerCase());
          case po.MEMBER_NICKNAME:
            return n.members.some(function(h) {
              return h.nickname.toLowerCase().includes(a.toLowerCase());
            });
          default:
            return !0;
        }
      }))
        return !1;
    }
    if (this._userIdsFilter) {
      var r = this._userIdsFilter, i = r.userIds, c = r.includeMode, V = r.queryType, s = n.members.map(function(R) {
        return R.userId;
      });
      if (c) {
        if (i.length > 0)
          switch (V) {
            case Er.AND:
              if (i.some(function(R) {
                return !s.includes(R);
              }))
                return !1;
              break;
            case Er.OR:
              if (i.every(function(R) {
                return !s.includes(R);
              }))
                return !1;
          }
      } else if (i.includes(t) || i.push(t), n.members.length > i.length || !Vx(i, s))
        return !1;
    }
    if (!this.includeEmpty && !n.lastMessage || !this.includeFrozen && n.isFrozen || this.customTypesFilter && this.customTypesFilter.length > 0 && !this.customTypesFilter.includes("*") && !this.customTypesFilter.includes(n.customType) || this.customTypeStartsWithFilter && !new RegExp("^".concat(this.customTypeStartsWithFilter)).test(n.customType) || this.channelNameContainsFilter && !n.name.toLowerCase().includes(this.channelNameContainsFilter.toLowerCase()))
      return !1;
    if (this.nicknameContainsFilter) {
      var o = this.nicknameContainsFilter.toLowerCase();
      if (!n.members.some(function(R) {
        return R.userId !== t && R.nickname.toLowerCase().includes(o);
      }))
        return !1;
    }
    if (this.nicknameStartsWithFilter) {
      var U = this.nicknameStartsWithFilter.toLowerCase();
      if (!n.members.some(function(R) {
        return R.userId !== t && R.nickname.toLowerCase().startsWith(U);
      }))
        return !1;
    }
    if (this.nicknameExactMatchFilter) {
      var N = this.nicknameExactMatchFilter.toLowerCase();
      if (!n.members.some(function(R) {
        return R.userId !== t && R.nickname.toLowerCase() != N;
      }))
        return !1;
    }
    if (this.channelUrlsFilter && this.channelUrlsFilter.length > 0 && !this.channelUrlsFilter.includes(n.url))
      return !1;
    if (this.myMemberStateFilter)
      switch (this.myMemberStateFilter) {
        case ta.ALL:
          if (n.myMemberState === "none")
            return !1;
          break;
        case ta.JOINED:
          if (n.myMemberState !== "joined")
            return !1;
          break;
        case ta.INVITED:
          if (n.myMemberState !== "invited")
            return !1;
          break;
        case ta.INVITED_BY_FRIEND:
          if (n.myMemberState !== "invited" || !this._isFriend(n.inviter))
            return !1;
          break;
        case ta.INVITED_BY_NON_FRIEND:
          if (n.myMemberState !== "invited" || this._isFriend(n.inviter))
            return !1;
      }
    if (this.hiddenChannelFilter)
      switch (this.hiddenChannelFilter) {
        case Zd.UNHIDDEN:
          if (n.isHidden || n.hiddenState !== "unhidden")
            return !1;
          break;
        case Zd.HIDDEN:
          if (!n.isHidden)
            return !1;
          break;
        case Zd.HIDDEN_ALLOW_AUTO_UNHIDE:
          if (!n.isHidden || n.hiddenState !== "hidden_allow_auto_unhide")
            return !1;
          break;
        case Zd.HIDDEN_PREVENT_AUTO_UNHIDE:
          if (!n.isHidden || n.hiddenState !== "hidden_prevent_auto_unhide")
            return !1;
      }
    if (this.unreadChannelFilter && this.unreadChannelFilter === Ti.UNREAD_MESSAGE && n.unreadMessageCount === 0)
      return !1;
    if (this.publicChannelFilter)
      switch (this.publicChannelFilter) {
        case Cd.PUBLIC:
          if (!n.isPublic)
            return !1;
          break;
        case Cd.PRIVATE:
          if (n.isPublic)
            return !1;
      }
    if (this.superChannelFilter)
      switch (this.superChannelFilter) {
        case la.SUPER:
          if (!n.isSuper)
            return !1;
          break;
        case la.NON_SUPER:
          if (n.isSuper)
            return !1;
      }
    return !(this.createdAfter && n.createdAt < this.createdAfter) && !(this.createdBefore && n.createdAt > this.createdBefore);
  }, e;
}(), JB = function(e) {
  function n(t, l) {
    var a = l.sdkState, d = l.cacheContext, r = e.call(this, t) || this;
    return r._channels = /* @__PURE__ */ new Map(), r._sdkState = a, r._cacheContext = d, r;
  }
  return J(n, e), Object.defineProperty(n.prototype, "collection", { get: function() {
    var t = this._cacheContext.nestdb;
    return Ze(!!t).throw(j.databaseError), t.collection(y3);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "localCacheEnabled", { get: function() {
    return this._cacheContext.localCacheEnabled && !!this.collection;
  }, enumerable: !1, configurable: !0 }), n.prototype._serialize = function(t, l) {
    return l === void 0 && (l = 0), x(x({}, t.serialize()), { lastMessageUpdatedAt: t.lastMessage ? t.lastMessage.createdAt : 0, syncIndex: l });
  }, n.prototype._deserialize = function(t) {
    return cl.of(this._iid).buildGroupChannelFromSerializedData(t);
  }, Object.defineProperty(n.prototype, "channels", { get: function() {
    return ot([], et(this._channels.values()), !1);
  }, enumerable: !1, configurable: !0 }), n.prototype.isCachedInMemory = function(t) {
    return this._channels.has(t);
  }, n.prototype.filterOffsetChanged = function(t) {
    var l = this;
    return t.filter(function(a) {
      if (l._channels.has(a.url))
        return l._channels.get(a.url).messageOffsetTimestamp < a.messageOffsetTimestamp;
    });
  }, n.prototype.get = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return this._channels.has(t) ? [3, 3] : this.localCacheEnabled ? [4, this.collection.getByKey(t)] : [3, 2];
          case 1:
            if (l = d.sent())
              return a = this._deserialize(l), this._channels.set(t, a), [2, a];
            d.label = 2;
          case 2:
            return [2, void 0];
          case 3:
            return [2, this._channels.get(t)];
        }
      });
    });
  }, n.prototype.fetch = function(t) {
    var l = t.token, a = t.limit, d = a === void 0 ? G3 : a, r = t.backward, i = r !== void 0 && r, c = t.filter, V = c === void 0 ? new eb() : c, s = t.order, o = s === void 0 ? Xn.LATEST_LAST_MESSAGE : s, U = t.borderlineChannelUrl;
    return M(this, void 0, void 0, function() {
      var N, R, h, Z, W = this;
      return p(this, function(F) {
        switch (F.label) {
          case 0:
            return this.localCacheEnabled ? (N = bN(o), R = { where: function(m) {
              if (l)
                switch (o) {
                  case Xn.CHANNEL_NAME_ALPHABETICAL:
                    if (!i && m.name.localeCompare(l) < 0 || i && m.name.localeCompare(l) > 0 || U && U === m.url)
                      return !1;
                    break;
                  case Xn.CHRONOLOGICAL:
                    if (!i && m.createdAt > l || i && m.createdAt < l || U && U === m.url)
                      return !1;
                    break;
                  case Xn.LATEST_LAST_MESSAGE:
                    if (!i && m.lastMessageUpdatedAt > l || i && m.lastMessageUpdatedAt < l || U && U === m.url)
                      return !1;
                }
              return V.match(W._deserialize(m), W._sdkState.userId);
            }, index: N, backward: i }, [4, this.collection.query(R)]) : [3, 3];
          case 1:
            return [4, F.sent().fetch({ limit: d })];
          case 2:
            return h = F.sent(), (Z = h.map(function(m) {
              return W._deserialize(m);
            })).forEach(function(m) {
              W._channels.has(m.url) || W._channels.set(m.url, m);
            }), [2, Z];
          case 3:
            return [2, []];
        }
      });
    });
  }, n.prototype.upsert = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i = this;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            if (a = [], t.forEach(function(V) {
              if (i._channels.has(V.url)) {
                var s = i._channels.get(V.url);
                s._pinnedMessagesUpdatedAt < V._pinnedMessagesUpdatedAt && (s._pinnedMessagesUpdatedAt = V._pinnedMessagesUpdatedAt), s._messageCollectionLastAccessedAt > V._messageCollectionLastAccessedAt && Object.assign(V, { _messageCollectionLastAccessedAt: void 0 }), V.cachedMetaData && l && (s._updateCachedMetaData(V.cachedMetaData, l), Object.assign(V, { _cachedMetaData: void 0 })), s._update(V), a.push(s);
              } else
                i._channels.set(V.url, V), a.push(V);
            }), !this.localCacheEnabled)
              return [3, 2];
            for (r in d = [], a)
              d.push(this._serialize(a[r], parseInt(r)));
            return [4, this.collection.upsertMany(d)];
          case 1:
            c.sent(), c.label = 2;
          case 2:
            return [2, a];
        }
      });
    });
  }, n.prototype.remove = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            V.trys.push([0, 5, 6, 7]), l = be(t), a = l.next(), V.label = 1;
          case 1:
            return a.done ? [3, 4] : (d = a.value, this._channels.delete(d), this.localCacheEnabled ? [4, this.collection.remove(d)] : [3, 3]);
          case 2:
            V.sent(), V.label = 3;
          case 3:
            return a = l.next(), [3, 1];
          case 4:
            return [3, 7];
          case 5:
            return r = V.sent(), i = { error: r }, [3, 7];
          case 6:
            try {
              a && !a.done && (c = l.return) && c.call(l);
            } finally {
              if (i)
                throw i.error;
            }
            return [7];
          case 7:
            return [2];
        }
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this.clearMemoryCache(), this.localCacheEnabled ? [4, this.collection.clear()] : [3, 2];
          case 1:
            t.sent(), t.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.clearMemoryCache = function() {
    this._channels.clear();
  }, n.prototype._setBlockStateOfAllChannels = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      var d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k;
      return p(this, function(Q) {
        switch (Q.label) {
          case 0:
            if (d = [], t === this._sdkState.userId)
              try {
                for (r = be(this._channels.values()), i = r.next(); !i.done; i = r.next()) {
                  U = i.value;
                  try {
                    for (F = void 0, c = be(U.members), V = c.next(); !V.done; V = c.next())
                      if ((h = V.value).userId === l) {
                        h.isBlockedByMe = a, d.push(U);
                        break;
                      }
                  } catch (S) {
                    F = { error: S };
                  } finally {
                    try {
                      V && !V.done && (m = c.return) && m.call(c);
                    } finally {
                      if (F)
                        throw F.error;
                    }
                  }
                }
              } catch (S) {
                Z = { error: S };
              } finally {
                try {
                  i && !i.done && (W = r.return) && W.call(r);
                } finally {
                  if (Z)
                    throw Z.error;
                }
              }
            else if (l === this._sdkState.userId)
              try {
                for (s = be(this._channels.values()), o = s.next(); !o.done; o = s.next()) {
                  U = o.value;
                  try {
                    for (b = void 0, N = be(U.members), R = N.next(); !R.done; R = N.next())
                      if ((h = R.value).userId === t) {
                        h.isBlockingMe = a, d.push(U);
                        break;
                      }
                  } catch (S) {
                    b = { error: S };
                  } finally {
                    try {
                      R && !R.done && (k = N.return) && k.call(N);
                    } finally {
                      if (b)
                        throw b.error;
                    }
                  }
                }
              } catch (S) {
                E = { error: S };
              } finally {
                try {
                  o && !o.done && (u = s.return) && u.call(s);
                } finally {
                  if (E)
                    throw E.error;
                }
              }
            return d.length > 0 ? [4, this.upsert(d)] : [3, 2];
          case 1:
            Q.sent(), Q.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.block = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._setBlockStateOfAllChannels(t, l, !0)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.unblock = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._setBlockStateOfAllChannels(t, l, !1)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.markAsRead = function(t, l) {
    return l === void 0 && (l = ot([], et(this._channels.keys()), !1)), M(this, void 0, void 0, function() {
      var a, d, r, i, c, V, s, o;
      return p(this, function(U) {
        switch (U.label) {
          case 0:
            a = [], U.label = 1;
          case 1:
            U.trys.push([1, 6, 7, 8]), d = be(l), r = d.next(), U.label = 2;
          case 2:
            return r.done ? [3, 5] : (i = r.value, [4, this.get(i)]);
          case 3:
            (c = U.sent()) != null && c._updateUnreadMemberState(this._sdkState.userId, t) && (c._updateUnreadCount(0, 0), a.push(c)), U.label = 4;
          case 4:
            return r = d.next(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return V = U.sent(), s = { error: V }, [3, 8];
          case 7:
            try {
              r && !r.done && (o = d.return) && o.call(d);
            } finally {
              if (s)
                throw s.error;
            }
            return [7];
          case 8:
            return a.length > 0 ? [4, this.upsert(a)] : [3, 10];
          case 9:
            U.sent(), U.label = 10;
          case 10:
            return [2];
        }
      });
    });
  }, n;
}(ml), YN = { invitedUserIds: void 0, channelUrl: void 0, coverUrl: void 0, coverImage: void 0, isDistinct: void 0, isSuper: void 0, isBroadcast: void 0, isExclusive: void 0, isPublic: void 0, isDiscoverable: void 0, isStrict: void 0, isEphemeral: void 0, accessCode: void 0, name: void 0, data: void 0, customType: void 0, operatorUserIds: void 0, messageSurvivalSeconds: void 0 }, AT = function(e) {
  return Jt("string", e.invitedUserIds, !0) && B("string", e.channelUrl, !0) && B("string", e.coverUrl, !0) && (Nl(e.coverImage) || B("string", e.coverImage, !0)) && B("boolean", e.isDistinct, !0) && B("boolean", e.isSuper, !0) && B("boolean", e.isBroadcast, !0) && B("boolean", e.isExclusive, !0) && B("boolean", e.isPublic, !0) && B("boolean", e.isStrict, !0) && B("boolean", e.isDiscoverable, !0) && B("boolean", e.isEphemeral, !0) && B("string", e.accessCode, !0) && B("string", e.name, !0) && B("string", e.data, !0) && B("string", e.customType, !0) && Jt("string", e.operatorUserIds, !0) && B("number", e.messageSurvivalSeconds, !0);
}, UR = { customTypes: void 0, includeEmpty: !1, includeFrozen: !0, includeChatNotification: !1 }, qT = function(e) {
  return Jt("string", e.customTypes, !0) && B("boolean", e.includeEmpty) && B("boolean", e.includeFrozen) && B("boolean", e.includeChatNotification);
}, tb = { myMemberStateFilter: ta.ALL }, nb = function(e) {
  return Qt(ta, e.myMemberStateFilter);
};
(function(e) {
  e.GROUP_CHANNEL_UNREAD_MENTION_COUNT = "group_channel_unread_mention_count", e.NONSUPER_UNREAD_MENTION_COUNT = "non_super_group_channel_unread_mention_count", e.SUPER_UNREAD_MENTION_COUNT = "super_group_channel_unread_mention_count", e.GROUP_CHANNEL_UNREAD_MESSAGE_COUNT = "group_channel_unread_message_count", e.NONSUPER_UNREAD_MESSAGE_COUNT = "non_super_group_channel_unread_message_count", e.SUPER_UNREAD_MESSAGE_COUNT = "super_group_channel_unread_message_count", e.GROUP_CHANNEL_INVITATION_COUNT = "group_channel_invitation_count", e.NONSUPER_INVITATION_COUNT = "non_super_group_channel_invitation_count", e.SUPER_INVITATION_COUNT = "super_group_channel_invitation_count";
})(il || (il = {}));
var vB = { keys: [] }, zB = { channelCustomTypesFilter: void 0, superChannelFilter: la.ALL }, xB = function(e) {
  return Jt("string", e.channelCustomTypesFilter, !0) && Qt(la, e.superChannelFilter);
}, GB = { channelUrl: void 0, scheduledStatus: void 0, messageTypeFilter: bl.ALL };
x({}, ne);
var QN = function(e) {
  return e.startsWith("EVENT_") || e === ne.SYNC_CHANNEL_CHANGELOGS || e === ne.REFRESH_CHANNEL;
}, Dt = function(e) {
  function n(t) {
    var l = t.channels, a = t.source, d = t.isWebSocketEventComing, r = d !== void 0 && d, i = t.data, c = i === void 0 ? null : i, V = t.ts, s = e.call(this) || this;
    return s.channels = l, s.source = a, s.isWebSocketEventComing = r, s.data = c, s.ts = V, s;
  }
  return J(n, e), n;
}(un), sr = function(e) {
  function n(t) {
    var l = t.channelUrls, a = t.source, d = t.isWebSocketEventComing, r = d !== void 0 && d, i = e.call(this) || this;
    return i.channelUrls = l, i.source = a, i.isWebSocketEventComing = r, i;
  }
  return J(n, e), n;
}(un), yB = function() {
  function e(n) {
    var t = n.groupChannelCache, l = n.messageCache, a = n.unsentMessageCache, d = n.dispatcher, r = this;
    this._observers = /* @__PURE__ */ new Map(), d.on(function(i) {
      return M(r, void 0, void 0, function() {
        var c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b = this;
        return p(this, function(k) {
          switch (k.label) {
            case 0:
              if (!(i instanceof Dt))
                return [3, 10];
              c = i.channels, F = i.source, m = i.isWebSocketEventComing, V = i.data, s = c.filter(function(Q) {
                return Q instanceof ja;
              }), o = t.filterOffsetChanged(s), k.label = 1;
            case 1:
              k.trys.push([1, 6, 7, 8]), U = be(o), N = U.next(), k.label = 2;
            case 2:
              return N.done ? [3, 5] : (R = N.value, [4, l.removeUnderOffset(R.url, R.messageOffsetTimestamp)]);
            case 3:
              k.sent(), k.label = 4;
            case 4:
              return N = U.next(), [3, 2];
            case 5:
              return [3, 8];
            case 6:
              return h = k.sent(), E = { error: h }, [3, 8];
            case 7:
              try {
                N && !N.done && (u = U.return) && u.call(U);
              } finally {
                if (E)
                  throw E.error;
              }
              return [7];
            case 8:
              return [4, t.upsert(s, i.ts)];
            case 9:
              return Z = k.sent(), m || this._broadcastUpdateEvent(Z, F, V), [3, 15];
            case 10:
              return i instanceof sr ? (W = i.channelUrls, F = i.source, m = i.isWebSocketEventComing, [4, t.remove(W)]) : [3, 13];
            case 11:
              return k.sent(), [4, yn(function() {
                return M(b, void 0, void 0, function() {
                  var Q, S, v, G, w, y;
                  return p(this, function(g) {
                    switch (g.label) {
                      case 0:
                        g.trys.push([0, 6, 7, 8]), Q = be(W), S = Q.next(), g.label = 1;
                      case 1:
                        return S.done ? [3, 5] : (v = S.value, [4, l.removeMessagesOfChannel(v)]);
                      case 2:
                        return g.sent(), [4, a.removeMessagesOfChannel(v)];
                      case 3:
                        g.sent(), g.label = 4;
                      case 4:
                        return S = Q.next(), [3, 1];
                      case 5:
                        return [3, 8];
                      case 6:
                        return G = g.sent(), w = { error: G }, [3, 8];
                      case 7:
                        try {
                          S && !S.done && (y = Q.return) && y.call(Q);
                        } finally {
                          if (w)
                            throw w.error;
                        }
                        return [7];
                      case 8:
                        return [2];
                    }
                  });
                });
              })];
            case 12:
              return k.sent(), m || this._broadcastRemoveEvent(W, F), [3, 15];
            case 13:
              return i instanceof w3 ? [4, t.fetch({ token: Number.MAX_SAFE_INTEGER, limit: Number.MAX_SAFE_INTEGER })] : [3, 15];
            case 14:
              k.sent(), k.label = 15;
            case 15:
              return [2];
          }
        });
      });
    });
  }
  return e.prototype._broadcastUpdateEvent = function(n, t, l) {
    var a, d;
    try {
      for (var r = be(this._observers.values()), i = r.next(); !i.done; i = r.next()) {
        var c = i.value;
        c.onUpdate && c.onUpdate(n, t, l);
      }
    } catch (V) {
      a = { error: V };
    } finally {
      try {
        i && !i.done && (d = r.return) && d.call(r);
      } finally {
        if (a)
          throw a.error;
      }
    }
  }, e.prototype._broadcastRemoveEvent = function(n, t) {
    var l, a;
    try {
      for (var d = be(this._observers.values()), r = d.next(); !r.done; r = d.next()) {
        var i = r.value;
        i.onRemove && i.onRemove(n, t);
      }
    } catch (c) {
      l = { error: c };
    } finally {
      try {
        r && !r.done && (a = d.return) && a.call(d);
      } finally {
        if (l)
          throw l.error;
      }
    }
  }, e.prototype.subscribe = function(n, t) {
    this._observers.set(n, t);
  }, e.prototype.unsubscribe = function(n) {
    this._observers.delete(n);
  }, e.prototype.unsubscribeAll = function() {
    this._observers.clear();
  }, e;
}(), BB = function(e) {
  function n(t) {
    var l = t.userId, a = t.ts, d = t.token, r = t.filter, i = t.includeChatNotification, c = i !== void 0 && i, V = e.call(this) || this, s = x(x({}, UR), r), o = s.customTypes, U = s.includeEmpty, N = s.includeFrozen;
    return V.method = he.GET, V.path = "".concat(It, "/").concat(encodeURIComponent(l), "/my_group_channels/changelogs"), V.params = je(Ae({ show_delivery_receipt: !0, show_member: !0, show_read_receipt: !0, change_ts: a || null, token: d, custom_types: o, show_empty: U, show_frozen: N, include_chat_notification: c })), V;
  }
  return J(n, e), n;
}(Te), DB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.updatedChannels = l.updated.map(function(d) {
      return new ja(t, Object.assign(d, { ts: l.ts }));
    }), a.deletedChannelUrls = l.deleted, a.hasMore = l.has_more, a.token = l.next, a.ts = l.ts, a;
  }
  return J(n, e), n;
}(ue), $T = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.isInternalCall, d = e.call(this) || this;
    return d.method = he.GET, d.path = "".concat(a ? Rx : vl, "/").concat(encodeURIComponent(l)), d.params = { show_member: !0, show_read_receipt: !0, show_delivery_receipt: !0 }, d;
  }
  return J(n, e), n;
}(Te), e0 = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.channel = new ja(t, l), a;
  }
  return J(n, e), n;
}(ue), gV = { includeEmpty: !1, includeFrozen: !0, includeMetaData: !0, includeChatNotification: !1, channelUrlsFilter: void 0, customTypesFilter: void 0, customTypeStartsWithFilter: void 0, nicknameContainsFilter: void 0, nicknameStartsWithFilter: void 0, nicknameExactMatchFilter: void 0, channelNameContainsFilter: void 0, myMemberStateFilter: ta.ALL, unreadChannelFilter: Ti.ALL, superChannelFilter: la.ALL, publicChannelFilter: Cd.ALL, hiddenChannelFilter: Zd.ALL, userIdsFilter: { userIds: [], includeMode: !0, queryType: Er.AND }, searchFilter: { query: void 0, fields: [] }, metadataKey: void 0, metadataValues: void 0, metadataOrderKeyFilter: void 0, metadataValueStartsWith: void 0, order: Xn.LATEST_LAST_MESSAGE, createdAfter: void 0, createdBefore: void 0 }, XB = function(e) {
  function n(t) {
    var l = this, a = t.userId, d = t.token, r = t.limit, i = t.order, c = t.includeEmpty, V = t.myMemberStateFilter, s = t.superChannelFilter, o = t.publicChannelFilter, U = t.unreadChannelFilter, N = t.nicknameContainsFilter, R = t.nicknameStartsWithFilter, h = t.nicknameExactMatchFilter, Z = t.channelNameContainsFilter, W = t.channelUrlsFilter, F = t.customTypesFilter, m = t.customTypeStartsWithFilter, E = t.hiddenChannelFilter, u = t.metadataOrderKeyFilter, b = t.metadataKey, k = t.metadataValues, Q = t.metadataValueStartsWith, S = t.includeFrozen, v = t.includeMetaData, G = t.searchFilter, w = t.userIdsFilter, y = t.includeChatNotification, g = y !== void 0 && y, f = t.includeLeftChannel, I = f !== void 0 && f, K = t.createdAfter, Ue = t.createdBefore;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(It, "/").concat(encodeURIComponent(a), "/my_group_channels"), l.params = je({ token: d, limit: r, order: i ?? gV.order, show_member: !0, show_read_receipt: !0, show_delivery_receipt: !0, show_empty: c ?? gV.includeEmpty, member_state_filter: V ?? gV.myMemberStateFilter, super_mode: s ?? gV.superChannelFilter, public_mode: o ?? gV.publicChannelFilter, unread_filter: U ?? gV.unreadChannelFilter, members_nickname_contains: N, members_nickname_startswith: R, members_nickname: h, name_contains: Z, channel_urls: W, custom_types: F, custom_type_startswith: m, hidden_mode: E, metadata_order_key: u, metadata_key: b, metadata_values: k, metadata_value_startswith: Q, show_frozen: S, show_metadata: v, include_chat_notification: g, include_left_channel: I, created_after: K, created_before: Ue }), G && G.query && G.fields && (l.params.search_query = G.query, l.params.search_fields = G.fields), w && w.userIds && w.userIds.length > 0 && (w.includeMode ? (l.params.members_include_in = w.userIds, l.params.query_type = w.queryType.toUpperCase()) : l.params.members_exactly_in = w.userIds), l;
  }
  return J(n, e), n;
}(Te), OB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    a.channels = [];
    var d = l.next, r = l.channels, i = l.ts;
    return a.token = d, r && r.length > 0 && (a.channels = r.map(function(c) {
      return c.ts = i, new ja(t, c);
    })), a.ts = i ?? 0, a;
  }
  return J(n, e), n;
}(ue), jB = function(e) {
  function n(t) {
    var l = t.userId, a = t.filter, d = e.call(this) || this, r = a.myMemberStateFilter;
    return d.method = he.GET, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/group_channel_count"), d.params = { state: r ?? ta.ALL }, d;
  }
  return J(n, e), n;
}(Te), HB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.groupChannelCount = l.group_channel_count, a;
  }
  return J(n, e), n;
}(ue), fB = function(e) {
  function n(t) {
    var l = t.userId, a = t.filter, d = e.call(this) || this, r = a.keys;
    return d.method = he.GET, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/unread_item_count"), d.params = je({ item_keys: r }), d;
  }
  return J(n, e), n;
}(Te), wB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return typeof l[il.GROUP_CHANNEL_UNREAD_MENTION_COUNT] == "number" && (a.groupChannelUnreadMentionCount = l[il.GROUP_CHANNEL_UNREAD_MENTION_COUNT]), typeof l[il.GROUP_CHANNEL_UNREAD_MESSAGE_COUNT] == "number" && (a.groupChannelUnreadMessageCount = l[il.GROUP_CHANNEL_UNREAD_MESSAGE_COUNT]), typeof l[il.GROUP_CHANNEL_INVITATION_COUNT] == "number" && (a.groupChannelInvitationCount = l[il.GROUP_CHANNEL_INVITATION_COUNT]), typeof l[il.SUPER_UNREAD_MENTION_COUNT] == "number" && (a.superGroupChannelUnreadMentionCount = l[il.SUPER_UNREAD_MENTION_COUNT]), typeof l[il.SUPER_UNREAD_MESSAGE_COUNT] == "number" && (a.superGroupChannelUnreadMessageCount = l[il.SUPER_UNREAD_MESSAGE_COUNT]), typeof l[il.SUPER_INVITATION_COUNT] == "number" && (a.superGroupChannelInvitationCount = l[il.SUPER_INVITATION_COUNT]), typeof l[il.NONSUPER_UNREAD_MENTION_COUNT] == "number" && (a.nonSuperGroupChannelUnreadMentionCount = l[il.NONSUPER_UNREAD_MENTION_COUNT]), typeof l[il.NONSUPER_UNREAD_MESSAGE_COUNT] == "number" && (a.nonSuperGroupChannelUnreadMessageCount = l[il.NONSUPER_UNREAD_MESSAGE_COUNT]), typeof l[il.NONSUPER_INVITATION_COUNT] == "number" && (a.nonSuperGroupChannelInvitationCount = l[il.NONSUPER_INVITATION_COUNT]), a;
  }
  return J(n, e), n;
}(ue), gB = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.GET, a.path = "".concat(It, "/").concat(encodeURIComponent(l), "/unread_channel_count"), a;
  }
  return J(n, e), n;
}(Te), IB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.unreadCount = l.unread_count, a;
  }
  return J(n, e), n;
}(ue), LB = function(e) {
  function n(t) {
    var l = t.userId, a = t.filter, d = t.includeFeedChannel, r = d !== void 0 && d, i = e.call(this) || this, c = a.channelCustomTypesFilter, V = a.superChannelFilter;
    return i.method = he.GET, i.path = "".concat(It, "/").concat(encodeURIComponent(l), "/unread_message_count"), i.params = { super_mode: V ?? la.ALL, custom_types: c, include_feed_channel: r }, i;
  }
  return J(n, e), n;
}(Te), CB = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.unreadCount = l.unread_count, a.unreadFeedCount = l.unread_feed_count, a;
  }
  return J(n, e), n;
}(ue), KB = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.scheduledStatus, d = t.messageTypeFilter, r = e.call(this) || this;
    return r.method = he.GET, r.path = "".concat(pk, "/count"), r.params = { channel_url: l, status: PB(a) }, d && (r.params.message_type = d), r;
  }
  return J(n, e), n;
}(Te), _B = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.count = l.count, a;
  }
  return J(n, e), n;
}(ue), PB = function(e) {
  if (!e)
    return [];
  var n = [];
  return e.forEach(function(t) {
    switch (t) {
      case ii.PENDING:
        n.push(xa.PENDING);
        break;
      case ii.SENT:
        n.push(xa.IN_QUEUE), n.push(xa.SENT);
        break;
      case ii.CANCELED:
        n.push(xa.CANCELED);
        break;
      case ii.FAILED:
        n.push(xa.FAILED);
    }
  }), n;
}, AB = function(e) {
  function n(t) {
    var l = this, a = t.userId, d = t.channelUrl, r = t.coverUrl, i = t.coverImage, c = t.isDistinct, V = t.isSuper, s = t.isBroadcast, o = t.isPublic, U = t.isExclusive, N = t.isDiscoverable, R = t.isStrict, h = t.isEphemeral, Z = t.accessCode, W = t.name, F = t.data, m = t.customType, E = t.messageSurvivalSeconds, u = t.invitedUserIds, b = t.operatorUserIds;
    return (l = e.call(this) || this).method = he.POST, l.path = vl, l.params = je({ user_ids: ot([a], et(u ?? []), !1).filter(function(k, Q, S) {
      return Q === S.indexOf(k);
    }), channel_url: d, cover_url: r, cover_file: i, is_distinct: c, is_super: V, is_broadcast: s, is_exclusive: U, is_public: o, is_discoverable: N, strict: R, is_ephemeral: h, access_code: Z, name: W, data: F, custom_type: m, operator_ids: b, message_survival_seconds: E }), l;
  }
  return J(n, e), n;
}(Te), qB = function(e) {
  function n(t, l) {
    var a, d = this;
    return (d = e.call(this, t, l) || this).channel = new ja(t, l), d.isCreated = (a = l.is_created) === null || a === void 0 || a, d;
  }
  return J(n, e), n;
}(ue), Du = function(e) {
  function n(t) {
    var l = t.userId, a = t.channelUrls, d = e.call(this) || this;
    return d.method = he.PUT, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/mark_as_read_all"), d.params = { channel_urls: a }, d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var $B = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.userId, r = t.accessCode;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(vl, "/").concat(encodeURIComponent(a), "/join"), l.params = { user_id: d, access_code: r }, l;
  }
  return J(n, e), n;
}(Te), eD = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.channel = new ja(t, l), a;
  }
  return J(n, e), n;
}(ue), tD = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, l, a) || this, r = a.data, i = r.member_count, c = i === void 0 ? 0 : i, V = r.joined_member_count, s = V === void 0 ? 0 : V, o = r.users, U = o === void 0 ? null : o;
    return d.memberCount = c, d.joinedMemberCount = s, d.members = Array.isArray(U) ? U.map(function(N) {
      return new Ga(t, N);
    }) : [new Ga(t, a.data)], d;
  }
  return J(n, e), n;
}(Dr), nD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.userId, r = t.shouldRemoveOperatorStatus;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(vl, "/").concat(encodeURIComponent(a), "/leave"), l.params = { user_id: d, should_remove_operator_status: r }, l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    return e.call(this, t, l) || this;
  }
  J(n, e);
})(ue);
var lD = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, l, a) || this, r = a.data, i = r.member_count, c = i === void 0 ? 0 : i, V = r.joined_member_count, s = V === void 0 ? 0 : V;
    return d.memberCount = c, d.joinedMemberCount = s, d.member = new Ga(d._iid, a.data), d;
  }
  return J(n, e), n;
}(Dr), aD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.userIds;
    return (l = e.call(this) || this).method = he.POST, l.path = "".concat(vl, "/").concat(encodeURIComponent(a), "/invite"), l.params = { user_ids: d }, l;
  }
  return J(n, e), n;
}(Te), dD = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.channel = new ja(t, l), a;
  }
  return J(n, e), n;
}(ue), rD = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, l, a) || this;
    d.inviter = null;
    var r = a.data, i = r.member_count, c = i === void 0 ? 0 : i, V = r.joined_member_count, s = V === void 0 ? 0 : V, o = r.inviter, U = r.invitees, N = U === void 0 ? [] : U;
    return d.memberCount = c, d.joinedMemberCount = s, o && Object.keys(o).length > 0 && (d.inviter = new xt(t, o)), d.invitees = N.map(function(R) {
      return new Ga(t, R);
    }), d;
  }
  return J(n, e), n;
}(Dr), iD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.userId;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(vl, "/").concat(encodeURIComponent(a), "/decline"), l.params = { user_id: d }, l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.channel = new ja(t, l), a.channel.myMemberState = On.NONE, a;
  }
  J(n, e);
})(ue);
var VD = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, l, a) || this, r = a.data, i = r.member_count, c = r.joined_member_count, V = r.inviter, s = r.invitee;
    return d.memberCount = i ?? 0, d.joinedMemberCount = c ?? 0, d.inviter = new xt(t, V), d.invitee = new Ga(t, s), d;
  }
  return J(n, e), n;
}(Dr), t0 = { hidePreviousMessages: !1, allowAutoUnhide: !0 }, cD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.userId, r = t.hidePreviousMessages, i = t.allowAutoUnhide;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(vl, "/").concat(encodeURIComponent(a), "/hide"), l.params = { user_id: d, hide_previous_messages: r ?? t0.hidePreviousMessages, allow_auto_unhide: i ?? t0.allowAutoUnhide }, l;
  }
  return J(n, e), n;
}(Te), sD = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this, d = l.ts_message_offset;
    return a.messageOffsetTimestamp = d, a;
  }
  return J(n, e), n;
}(ue), oD = function(e) {
  function n(t, l, a) {
    var d, r, i, c = this;
    return (c = e.call(this, t, "SYEV", a) || this).allowAutoUnhide = null, c.hidePreviousMessages = null, c.messageOffsetTimestamp = null, a.data && (c.allowAutoUnhide = (d = a.data.allow_auto_unhide) !== null && d !== void 0 ? d : null, c.hidePreviousMessages = (r = a.data.hide_previous_messages) !== null && r !== void 0 ? r : null), c.messageOffsetTimestamp = (i = a.ts_message_offset) !== null && i !== void 0 ? i : null, c;
  }
  return J(n, e), n;
}(Wn), UD = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.time;
    return e.call(this, { code: "TPST", ackRequired: !1, payload: { channel_url: l, time: a } }) || this;
  }
  return J(n, e), n;
}(Yl), ND = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return d.user = new xt(t, a.data), d;
  }
  return J(n, e), n;
}(Wn), RD = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.time;
    return e.call(this, { code: "TPEN", ackRequired: !1, payload: { channel_url: l, time: a } }) || this;
  }
  return J(n, e), n;
}(Yl), hD = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "SYEV", a) || this;
    return d.user = new xt(t, a.data), d;
  }
  return J(n, e), n;
}(Wn), ZD = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.messageId;
    return e.call(this, { code: "MACK", ackRequired: !1, payload: { channel_url: l, msg_id: a } }) || this;
  }
  return J(n, e), n;
}(Yl), lb = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S, v, G = this;
    return (G = e.call(this, t, l) || this).includeEmpty = !1, G.includeFrozen = !0, G.includeMetaData = !0, G.includeChatNotification = !1, G.channelUrlsFilter = null, G.customTypesFilter = null, G.customTypeStartsWithFilter = null, G.nicknameContainsFilter = null, G.nicknameStartsWithFilter = null, G.nicknameExactMatchFilter = null, G.channelNameContainsFilter = "", G.myMemberStateFilter = ta.ALL, G.unreadChannelFilter = Ti.ALL, G.superChannelFilter = la.ALL, G.publicChannelFilter = Cd.ALL, G.hiddenChannelFilter = Zd.UNHIDDEN, G.searchFilter = { fields: [], query: null }, G.userIdsFilter = { userIds: [], includeMode: !0, queryType: Er.AND }, G.metadataKey = null, G.metadataValues = null, G.metadataOrderKeyFilter = null, G.metadataValueStartsWith = null, G.order = Xn.LATEST_LAST_MESSAGE, G.includeEmpty = (a = l.includeEmpty) !== null && a !== void 0 && a, G.includeFrozen = (d = l.includeFrozen) === null || d === void 0 || d, G.includeMetaData = (r = l.includeMetaData) === null || r === void 0 || r, G.includeChatNotification = (i = l.includeChatNotification) !== null && i !== void 0 && i, G.channelUrlsFilter = (c = l.channelUrlsFilter) !== null && c !== void 0 ? c : null, G.customTypesFilter = (V = l.customTypesFilter) !== null && V !== void 0 ? V : null, G.customTypeStartsWithFilter = (s = l.customTypeStartsWithFilter) !== null && s !== void 0 ? s : "", G.nicknameContainsFilter = (o = l.nicknameContainsFilter) !== null && o !== void 0 ? o : null, G.nicknameStartsWithFilter = (U = l.nicknameStartsWithFilter) !== null && U !== void 0 ? U : null, G.nicknameExactMatchFilter = (N = l.nicknameExactMatchFilter) !== null && N !== void 0 ? N : null, G.channelNameContainsFilter = (R = l.channelNameContainsFilter) !== null && R !== void 0 ? R : "", G.myMemberStateFilter = (h = l.myMemberStateFilter) !== null && h !== void 0 ? h : ta.ALL, G.unreadChannelFilter = (Z = l.unreadChannelFilter) !== null && Z !== void 0 ? Z : Ti.ALL, G.superChannelFilter = (W = l.superChannelFilter) !== null && W !== void 0 ? W : la.ALL, G.publicChannelFilter = (F = l.publicChannelFilter) !== null && F !== void 0 ? F : Cd.ALL, G.hiddenChannelFilter = (m = l.hiddenChannelFilter) !== null && m !== void 0 ? m : Zd.UNHIDDEN, G.searchFilter = (E = l.searchFilter) !== null && E !== void 0 ? E : { fields: [], query: null }, G.userIdsFilter = (u = l.userIdsFilter) !== null && u !== void 0 ? u : { userIds: [], includeMode: !0, queryType: Er.AND }, G.metadataKey = (b = l.metadataKey) !== null && b !== void 0 ? b : null, G.metadataValues = (k = l.metadataValues) !== null && k !== void 0 ? k : null, G.metadataOrderKeyFilter = (Q = l.metadataOrderKeyFilter) !== null && Q !== void 0 ? Q : null, G.metadataValueStartsWith = (S = l.metadataValueStartsWith) !== null && S !== void 0 ? S : null, G.order = (v = l.order) !== null && v !== void 0 ? v : Xn.LATEST_LAST_MESSAGE, l.createdAfter && (G.createdAfter = l.createdAfter), l.createdBefore && (G.createdBefore = l.createdBefore), G;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && B("boolean", this.includeEmpty) && B("boolean", this.includeFrozen) && B("boolean", this.includeMetaData) && B("string", this.channelNameContainsFilter) && Jt("string", this.channelUrlsFilter, !0) && Jt("string", this.customTypesFilter, !0) && B("string", this.customTypeStartsWithFilter) && B("string", this.nicknameContainsFilter, !0) && B("string", this.nicknameStartsWithFilter, !0) && B("string", this.nicknameExactMatchFilter, !0) && Qt(ta, this.myMemberStateFilter) && Qt(la, this.superChannelFilter) && Qt(Cd, this.publicChannelFilter) && Qt(Ti, this.unreadChannelFilter) && Qt(Zd, this.hiddenChannelFilter) && Jt(po, this.searchFilter.fields) && B("string", this.searchFilter.query, !0) && Jt("string", this.userIdsFilter.userIds) && B("boolean", this.userIdsFilter.includeMode) && Qt(Er, this.userIdsFilter.queryType) && Qt(Xn, this.order) && B("string", this.metadataOrderKeyFilter, !0) && B("string", this.metadataKey, !0) && Jt("string", this.metadataValues, !0) && B("string", this.metadataValueStartsWith, !0) && Sm(this.createdAfter, !0) && Sm(this.createdBefore, !0);
  }, n.prototype.serialize = function() {
    return gc(this);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, [4, cl.of(this._iid).getMyGroupChannels(this._token, Ae(x({}, this)), this.limit, ne.REQUEST_CHANNEL, !0)]) : [3, 2] : [3, 5];
          case 1:
            return t = d.sent(), l = t.channels, a = t.token, this._token = a, this._hasNext = !!a, this._isLoading = !1, [2, l];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(yr), TD = function(e) {
  function n(t, l, a) {
    var d, r = this;
    return (r = e.call(this, t, "SYEV", a) || this).pinnedMessageIds = [], r.latestPinnedMessage = null, r.ts = 0, a.data && (r.pinnedMessageIds = (d = a.data.pinned_message_ids) !== null && d !== void 0 ? d : [], r.latestPinnedMessage = a.data.latest_pinned_message ? Hl(t, x({}, a.data.latest_pinned_message)) : null), r.ts = a.ts, r;
  }
  return J(n, e), n;
}(Wn), FD = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.userId, d = e.call(this) || this;
    return d.method = he.PUT, d.path = "".concat(vl, "/").concat(encodeURIComponent(l), "/messages/mark_as_delivered"), d.params = je({ userId: a }), d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var Rr, WD = function(e) {
  function n(t, l, a) {
    var d = e.call(this, t, "DLVR", a) || this;
    return d.channelUrl = a.channel_url, d.deliveredStateUpdate = a.updated, d;
  }
  return J(n, e), n;
}(Wn), fd = function() {
  function e(n) {
    var t = n.top, l = t === void 0 ? Number.MAX_SAFE_INTEGER : t, a = n.bottom, d = a === void 0 ? 0 : a;
    this.top = l, this.bottom = d;
  }
  return e.prototype.includes = function() {
    for (var n = this, t = [], l = 0; l < arguments.length; l++)
      t[l] = arguments[l];
    return t.every(function(a) {
      return n.top <= a && a <= n.bottom;
    });
  }, e.prototype.overlap = function(n) {
    return this.includes(n.top) || this.includes(n.bottom);
  }, e.prototype.intersect = function() {
    for (var n = this, t = [], l = 0; l < arguments.length; l++)
      t[l] = arguments[l];
    return t.some(function(a) {
      return n.top <= a && a <= n.bottom;
    });
  }, e.prototype.extends = function() {
    for (var n = [], t = 0; t < arguments.length; t++)
      n[t] = arguments[t];
    this.top = Math.min.apply(Math, ot([this.top], et(n), !1)), this.bottom = Math.max.apply(Math, ot([this.bottom], et(n), !1));
  }, e;
}(), Bi = {}, cl = function(e) {
  function n(t, l) {
    var a, d = this;
    return (d = e.call(this, t, x(x({}, l), { channelType: Xt.GROUP })) || this)._leftChannels = /* @__PURE__ */ new Map(), d._disableMack = !1, d._markAsReadAllLastSentAt = 0, d._disableMack = (a = l.disableMack) !== null && a !== void 0 && a, d._groupChannelHandlers = /* @__PURE__ */ new Map(), d._groupChannelCache = new JB(d._iid, { sdkState: l.sdkState, cacheContext: l.cacheContext }), d._groupChannelBroadcast = new yB({ dispatcher: l.dispatcher, groupChannelCache: d._groupChannelCache, messageCache: ac.of(d._iid), unsentMessageCache: bV.of(d._iid) }), setInterval(function() {
      var r, i, c = function(o) {
        o.invalidateTypingStatus() && (d._dispatcher.dispatch(new Dt({ channels: [o], source: ne.EVENT_CHANNEL_TYPING_STATUS_UPDATE })), d._groupChannelHandlers.forEach(function(U) {
          U.onTypingStatusUpdated && U.onTypingStatusUpdated(o);
        }));
      };
      try {
        for (var V = be(d._groupChannelCache.channels), s = V.next(); !s.done; s = V.next())
          c(s.value);
      } catch (o) {
        r = { error: o };
      } finally {
        try {
          s && !s.done && (i = V.return) && i.call(V);
        } finally {
          if (r)
            throw r.error;
        }
      }
    }, 1e3), d._dispatcher.on(function(r) {
      r instanceof Wn ? d._handleEvent(r).catch(function(i) {
        if (Il(i) && d._sdkState.appState === "foreground")
          throw i;
      }) : r instanceof f3 ? M(d, void 0, void 0, function() {
        var i, c;
        return p(this, function(V) {
          switch (V.label) {
            case 0:
              return i = r.message, [4, this.getChannel(i.channelUrl, !0)];
            case 1:
              return c = V.sent(), i instanceof kl ? c._autoResendUserMessage(i) : i instanceof Ln && c._autoResendFileMessage(i), [2];
          }
        });
      }) : r instanceof g3 ? d.reduceDBSize() : r instanceof T3 && M(d, void 0, void 0, function() {
        var i, c, V, s, o, U = this;
        return p(this, function(N) {
          switch (N.label) {
            case 0:
              return i = r.channelUrl, c = r.channelType, V = r.parentMessage, s = new H3(this._iid, { channel_type: Xt.GROUP, channel_url: i, parent_message_id: V.messageId, thread_info: aR.payloadify(V.threadInfo) }), c !== Xt.GROUP ? [3, 2] : [4, this.getChannel(i, !0)];
            case 1:
              o = N.sent(), Ce(function() {
                return M(U, void 0, void 0, function() {
                  var R, h, Z, W, F;
                  return p(this, function(m) {
                    try {
                      for (R = be(this._groupChannelHandlers.values()), h = R.next(); !h.done; h = R.next())
                        (Z = h.value).onThreadInfoUpdated && Z.onThreadInfoUpdated(o, s);
                    } catch (E) {
                      W = { error: E };
                    } finally {
                      try {
                        h && !h.done && (F = R.return) && F.call(R);
                      } finally {
                        if (W)
                          throw W.error;
                      }
                    }
                    return [2];
                  });
                });
              }), N.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }), Bi[t] || (Bi[t] = d), d;
  }
  return J(n, e), Object.defineProperty(n.prototype, "_messageCache", { get: function() {
    return ac.of(this._iid);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "_unsentMessageCache", { get: function() {
    return bV.of(this._iid);
  }, enumerable: !1, configurable: !0 }), n.of = function(t) {
    return Bi[t] || (Bi[t] = new n(t, D.of(t))), Bi[t];
  }, n.clear = function(t) {
    Bi[t] && delete Bi[t];
  }, Object.defineProperty(n.prototype, "handlers", { get: function() {
    return ot([], et(this._groupChannelHandlers.values()), !1);
  }, enumerable: !1, configurable: !0 }), n.prototype.buildGroupChannelFromSerializedData = function(t) {
    var l = hi(t);
    return new ja(this._iid, ja.payloadify(l));
  }, n.prototype.buildGroupChannelListQueryFromSerializedData = function(t) {
    var l = hi(t);
    return new lb(this._iid, l);
  }, n.prototype.buildMemberFromSerializedData = function(t) {
    var l = hi(t);
    return new Ga(this._iid, Ga.payloadify(l));
  }, n.prototype.getChannelFromCache = function(t) {
    var l;
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._groupChannelCache.get(t)];
          case 1:
            return [2, (l = a.sent()) !== null && l !== void 0 ? l : null];
        }
      });
    });
  }, n.prototype.getChannelsFromCache = function(t, l, a, d, r) {
    return M(this, void 0, void 0, function() {
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return [4, this._groupChannelCache.fetch({ token: t, filter: l, order: a, limit: d, borderlineChannelUrl: r })];
          case 1:
            return [2, i.sent()];
        }
      });
    });
  }, n.prototype.upsertChannelsToCache = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._groupChannelCache.upsert(t)];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, n.prototype.removeChannelsFromCache = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._groupChannelCache.remove(t)];
          case 1:
            return l.sent(), [2];
        }
      });
    });
  }, n.prototype.clearChannelsFromCache = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this._groupChannelCache.clear()];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, n.prototype.reduceDBSize = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V, s, o, U, N, R, h, Z;
      return p(this, function(W) {
        switch (W.label) {
          case 0:
            return t = ac.of(this._iid), l = D.of(this._iid).cacheContext, a = l.localCacheConfig, d = l.nestdb, l.localCacheEnabled && d && d.state == Dd.OPENED ? (r = 1024 * a.maxSize * 1024, [4, d.estimateUsage()]) : [2];
          case 1:
            if ((i = W.sent()) < r)
              return [2];
            c = [], V = this._groupChannelCache.channels, s = {}, R = 0, W.label = 2;
          case 2:
            return R < V.length ? [4, this.getMessagesFromCache(V[R].url, 0, "prev", new mi())] : [3, 5];
          case 3:
            o = W.sent(), s[V[R].url] = JSON.stringify(o).length, U = new sx({ channel: V[R], cachedMessageCount: o.length }), c.push(U), W.label = 4;
          case 4:
            return R++, [3, 2];
          case 5:
            N = c.sort(a.clearOrderComparator), R = 0, W.label = 6;
          case 6:
            return R < N.length ? [4, t.removeMessagesOfChannel(N[R].channel.url)] : [3, 10];
          case 7:
            return W.sent(), [4, t._getGroupChannelPreferenceSize(N[R].channel.url)];
          case 8:
            if (h = W.sent(), Z = s[N[R].channel.url] + h, (i -= Z) < r)
              return [3, 10];
            W.label = 9;
          case 9:
            return R++, [3, 6];
          case 10:
            return [2];
        }
      });
    });
  }, n.prototype._handleEvent = function(t) {
    var l, a;
    return M(this, void 0, void 0, function() {
      var d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S, v, G, w, y, g, f, I, K, Ue, q, ae, se, le, L, $, ee, O, re, te, Qe, Ye, Se, P, ge, Me, We, De, Oe, tt, Be, He, at, Ge, $e, fe, Xe, pt, Vt, yt, xe, At, kt, Kt, ln, vt, Rt, Ke, Je, de, qe, lt, ct, Ot, zt, cn, mt, sn, hn, ft, qt, jt, Bt, Ie, it, ze, ht, Ft, X, Ne, pe, we, Nt, Ee, H, Ve, ye, Zt, Mt, Ct, Ht, Sn, bt, rn, en, gn, An, xi, ir, Dh, bd, MU, _c, Pc, Ac, Gi, EU, SU, kU, bU, Xr, YU, em, tm, nm, Xh, Oh, jh, QU, JU, Hh, fh, lm, wh, am, gh, dm, Ih, rm, Lh, im, on = this;
      return p(this, function(gt) {
        switch (gt.label) {
          case 0:
            switch (gt.trys.push([0, 80, , 81]), t.code) {
              case "MESG":
              case "FILE":
              case "ADMM":
              case "BRDM":
                return [3, 1];
              case "MEDI":
              case "FEDI":
              case "AEDI":
                return [3, 4];
              case "DELM":
                return [3, 7];
              case "READ":
                return [3, 10];
              case "DLVR":
                return [3, 13];
              case "MRCT":
                return [3, 15];
              case "MTHD":
                return [3, 19];
              case "MCNT":
                return [3, 23];
              case "PEDI":
                return [3, 32];
              case "VOTE":
                return [3, 35];
              case "SYEV":
                return [3, 38];
              case "USEV":
                return [3, 78];
            }
            return [3, 79];
          case 1:
            return U = null, t.code === "MESG" ? U = t.as(JW) : t.code === "FILE" ? U = t.as(bW) : t.code !== "ADMM" && t.code != "BRDM" || (U = t.as(K3)), U ? (d = U.message, r = U.isMentioned, i = U.forceUpdateLastMessage, d.channelType !== Xt.GROUP ? [3, 3] : (this._disableMack || yn(function() {
              return M(on, void 0, void 0, function() {
                var Re;
                return p(this, function(C) {
                  return Re = new ZD(d), this._requestQueue.send(Re), [2];
                });
              });
            }), I = this._groupChannelCache.isCachedInMemory(d.channelUrl), v = d instanceof wn && d.sender.userId === this._sdkState.userId, [4, this.getChannel(d.channelUrl, !0)])) : [3, 3];
          case 2:
            if ((c = gt.sent()).hiddenState === yl.HIDDEN_ALLOW_AUTO_UNHIDE && (c.hiddenState = yl.UNHIDDEN), d instanceof wn) {
              V = D.of(this._iid).useMemberInfoInMessage;
              try {
                for (s = be(c.members), o = s.next(); !o.done; o = s.next())
                  if ((Ee = o.value).userId === d.sender.userId) {
                    V || (d.sender.nickname = Ee.nickname, d.sender.plainProfileUrl = Ee.plainProfileUrl, d.sender.metaData = Ee.metaData, d.sender.isBlockedByMe = Ee.isBlockedByMe);
                    break;
                  }
              } catch (Re) {
                fh = { error: Re };
              } finally {
                try {
                  o && !o.done && (lm = s.return) && lm.call(s);
                } finally {
                  if (fh)
                    throw fh.error;
                }
              }
              !V && r && ((l = d.mentionedUsers) === null || l === void 0 || l.forEach(function(Re) {
                var C, Et;
                try {
                  for (var st = be(c.members), St = st.next(); !St.done; St = st.next()) {
                    var Dn = St.value;
                    if (Re.userId === Dn.userId) {
                      Re.nickname = Dn.nickname, Re.plainProfileUrl = Dn.plainProfileUrl, Re.metaData = Dn.metaData;
                      break;
                    }
                  }
                } catch (Rn) {
                  C = { error: Rn };
                } finally {
                  try {
                    St && !St.done && (Et = st.return) && Et.call(st);
                  } finally {
                    if (C)
                      throw C.error;
                  }
                }
              })), v && (F = this._sessionManager.currentUser) && (F.nickname = d.sender.nickname, F.plainProfileUrl = d.sender.plainProfileUrl, F.metaData = d.sender.metaData);
            }
            d.silent && !v || (c.isEphemeral || I) && (c._updateLastMessage(d), v || c._updateUnreadCount(c.unreadMessageCount + 1, c.unreadMentionCount + (r ? 1 : 0))), i && c._updateLastMessage(d), this._dispatcher.dispatch(new Dt({ channels: [c], source: ne.EVENT_MESSAGE_RECEIVED })), d.silent && !v || Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onChannelChanged && Et.onChannelChanged(c);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), this._dispatcher.dispatch(new En({ messages: [d], source: ne.EVENT_MESSAGE_RECEIVED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onMessageReceived && Et.onMessageReceived(c, d), r && Et.onMentionReceived && Et.onMentionReceived(c, d);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), gt.label = 3;
          case 3:
            return [3, 79];
          case 4:
            return U = null, t.code === "MEDI" ? U = t.as(rR) : t.code === "FEDI" ? U = t.as(iR) : t.code === "AEDI" && (U = t.as(_3)), U ? (N = U.message, R = U.mentionCountChange, N.threadInfo && (N.threadInfo.unreadReplyCount = void 0), N.channelType !== Xt.GROUP ? [3, 6] : (I = this._groupChannelCache.isCachedInMemory(N.channelUrl), [4, this.getChannel(N.channelUrl, !0)])) : [3, 6];
          case 5:
            h = gt.sent(), v = N instanceof wn && N.sender.userId === this._sdkState.userId, Z = !1, v ? (W = N.sender, (F = this._sessionManager.currentUser) && (F.nickname = W.nickname, F.plainProfileUrl = W.plainProfileUrl, F.metaData = W.metaData)) : h.isReadMessage(N) || R !== 0 && !N.silent && I && (h._updateUnreadCount(h.unreadMessageCount, h.unreadMentionCount + R), Z = !0), h._updateLastMessage(N) ? Z = !0 : !((a = h.lastMessage) === null || a === void 0) && a.isIdentical(N) && (I ? h._updateLastMessage(N) && (Z = !0) : Z = !0), m = !1, h.lastPinnedMessage && h.lastPinnedMessage.messageId === N.messageId && (h.lastPinnedMessage = N, Z = !0, m = !0), Z && (this._dispatcher.dispatch(new Dt({ channels: [h], source: m ? ne.EVENT_PINNED_MESSAGE_UPDATED : ne.EVENT_MESSAGE_UPDATED })), N.silent && !v || Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onChannelChanged && Et.onChannelChanged(h);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), m && Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onPinnedMessageUpdated && Et.onPinnedMessageUpdated(h);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            })), this._dispatcher.dispatch(new En({ messages: [N], source: ne.EVENT_MESSAGE_UPDATED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onMessageUpdated && Et.onMessageUpdated(h, N), R > 0 && Et.onMentionReceived && Et.onMentionReceived(h, N);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), gt.label = 6;
          case 6:
            return [3, 79];
          case 7:
            return E = t.as(z3), Be = E.channelUrl, He = E.channelType, u = E.messageId, b = E.silent, k = E.messageCreatedAt, Q = E.senderId, He !== Xt.GROUP ? [3, 9] : [4, this.getChannel(Be, !0)];
          case 8:
            S = gt.sent(), v = Q === this._sdkState.userId, b || v || k > 0 && S.myLastRead < k && S.unreadMessageCount > 0 && S._updateUnreadCount(S.unreadMessageCount - 1, 0), this._dispatcher.dispatch(new EW({ messageIds: [u], source: ne.EVENT_MESSAGE_DELETED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onMessageDeleted && Et.onMessageDeleted(S, u);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), gt.label = 9;
          case 9:
            return [3, 79];
          case 10:
            return (G = t.as(Z3).readStatus).channelType !== Xt.GROUP ? [3, 12] : (I = this._groupChannelCache.isCachedInMemory(G.channelUrl), [4, this.getChannel(G.channelUrl, !0)]);
          case 11:
            w = gt.sent(), I && w._updateUnreadMemberState(G.reader.userId, G.readAt), G.reader.userId === this._sdkState.userId ? I ? (w.unreadMessageCount > 0 || w.unreadMentionCount > 0) && (w._updateUnreadCount(0, 0), this._dispatcher.dispatch(new Dt({ channels: [w], source: ne.EVENT_CHANNEL_READ })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onChannelChanged && Et.onChannelChanged(w);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            })) : w.unreadMessageCount !== 0 && w.unreadMentionCount !== 0 || (this._dispatcher.dispatch(new Dt({ channels: [w], source: ne.EVENT_CHANNEL_READ })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onChannelChanged && Et.onChannelChanged(w);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            })) : (this._dispatcher.dispatch(new Dt({ channels: [w], source: ne.EVENT_CHANNEL_READ })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onUnreadMemberStatusUpdated && Et.onUnreadMemberStatusUpdated(w);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            })), gt.label = 12;
          case 12:
            return [3, 79];
          case 13:
            return y = t.as(WD), Be = y.channelUrl, g = y.deliveredStateUpdate, f = g === void 0 ? {} : g, I = this._groupChannelCache.isCachedInMemory(Be), [4, this.getChannel(Be, !0)];
          case 14:
            if (K = gt.sent(), I)
              for (Ue in f)
                K._updateUndeliveredMemberState(Ue, f[Ue]);
            return Object.keys(f).some(function(Re) {
              return Re !== on._sdkState.userId;
            }) && (this._dispatcher.dispatch(new Dt({ channels: [K], source: ne.EVENT_CHANNEL_DELIVERED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onUndeliveredMemberStatusUpdated && Et.onUndeliveredMemberStatusUpdated(K);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            })), [3, 79];
          case 15:
            return q = t.as(P3), Be = q.channelUrl, He = q.channelType, ae = q.event, He !== Xt.GROUP ? [3, 18] : [4, this.getChannel(Be, !0)];
          case 16:
            return se = gt.sent(), [4, this.getMessageFromCache(ae.messageId)];
          case 17:
            ($ = gt.sent()) ? $ instanceof Bl && ($.applyReactionEvent(ae), this._dispatcher.dispatch(new En({ messages: [$], source: ne.EVENT_MESSAGE_REACTION_UPDATED }))) : this._dispatcher.dispatch(new t3({ event: ae, source: ne.EVENT_MESSAGE_REACTION_UPDATED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onReactionUpdated && Et.onReactionUpdated(se, ae);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), gt.label = 18;
          case 18:
            return [3, 79];
          case 19:
            return (le = t.as(A3).event).channelType !== Xt.GROUP ? [3, 22] : [4, this.getChannel(le.channelUrl, !0)];
          case 20:
            return L = gt.sent(), [4, this.getMessageFromCache(le.targetMessageId)];
          case 21:
            ($ = gt.sent()) ? $ instanceof Bl && ($.applyThreadInfoUpdateEvent(le), this._dispatcher.dispatch(new En({ messages: [$], source: ne.EVENT_MESSAGE_THREADINFO_UPDATED }))) : this._dispatcher.dispatch(new n3({ event: le, source: ne.EVENT_MESSAGE_THREADINFO_UPDATED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onThreadInfoUpdated && Et.onThreadInfoUpdated(L, le);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), gt.label = 22;
          case 22:
            return [3, 79];
          case 23:
            ee = t.as(q3).groupChannelMemberCounts, O = [], gt.label = 24;
          case 24:
            gt.trys.push([24, 29, 30, 31]), re = be(ee), te = re.next(), gt.label = 25;
          case 25:
            return te.done ? [3, 28] : (Qe = te.value, Be = Qe.channelUrl, jt = Qe.memberCount, Bt = Qe.joinedMemberCount, Ye = Qe.updatedAt, [4, this.getChannelFromCache(Be)]);
          case 26:
            (Se = gt.sent()) && Se._setLatestMemberCount(jt, Bt, Ye) && O.push(Se), gt.label = 27;
          case 27:
            return te = re.next(), [3, 25];
          case 28:
            return [3, 31];
          case 29:
            return P = gt.sent(), wh = { error: P }, [3, 31];
          case 30:
            try {
              te && !te.done && (am = re.return) && am.call(re);
            } finally {
              if (wh)
                throw wh.error;
            }
            return [7];
          case 31:
            return O.length > 0 && (this._dispatcher.dispatch(new Dt({ channels: O, source: ne.EVENT_CHANNEL_MEMBER_COUNT_UPDATED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onChannelMemberCountChanged && Et.onChannelMemberCountChanged(O);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            })), [3, 79];
          case 32:
            return ge = t.as($3), Me = ge.event, We = ge.status, Be = ge.channelUrl, He = ge.channelType, Be && He === Xt.GROUP ? [4, this.getChannel(Be, !0)] : [3, 34];
          case 33:
            De = gt.sent(), this._dispatcher.dispatch(new SW({ event: Me, source: ne.EVENT_POLL_UPDATED })), Ce(We === d3 ? function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onPollDeleted && Et.onPollDeleted(De, Me.pollId);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            } : function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onPollUpdated && Et.onPollUpdated(De, Me);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), gt.label = 34;
          case 34:
            return [3, 79];
          case 35:
            return Oe = t.as(vW), tt = Oe.event, Be = Oe.channelUrl, He = Oe.channelType, Be && He === Xt.GROUP ? [4, this.getChannel(Be, !0)] : [3, 37];
          case 36:
            at = gt.sent(), this._dispatcher.dispatch(new KR({ event: tt, source: ne.EVENT_POLL_VOTED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onPollVoted && Et.onPollVoted(at, tt);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), gt.label = 37;
          case 37:
            return [3, 79];
          case 38:
            if (!(Ge = t.as(Dr).event).isGroupChannelEvent)
              return [3, 77];
            switch (Ge.category) {
              case Vn.CHANNEL_JOIN:
                return [3, 39];
              case Vn.CHANNEL_LEAVE:
                return [3, 41];
              case Vn.CHANNEL_OPERATOR_UPDATE:
                return [3, 45];
              case Vn.CHANNEL_INVITE:
                return [3, 47];
              case Vn.CHANNEL_DECLINE_INVITE:
                return [3, 49];
              case Vn.TYPING_START:
              case Vn.TYPING_END:
                return [3, 51];
              case Vn.USER_CHANNEL_MUTE:
              case Vn.USER_CHANNEL_UNMUTE:
                return [3, 53];
              case Vn.USER_CHANNEL_BAN:
                return [3, 55];
              case Vn.USER_CHANNEL_UNBAN:
                return [3, 59];
              case Vn.CHANNEL_FREEZE:
              case Vn.CHANNEL_UNFREEZE:
                return [3, 61];
              case Vn.CHANNEL_HIDE:
                return [3, 63];
              case Vn.CHANNEL_UNHIDE:
                return [3, 65];
              case Vn.CHANNEL_DELETED:
                return [3, 67];
              case Vn.CHANNEL_PROP_CHANGED:
                return [3, 69];
              case Vn.CHANNEL_META_DATA_CHANGED:
                return [3, 71];
              case Vn.CHANNEL_META_COUNTERS_CHANGED:
                return [3, 73];
              case Vn.PINNED_MESSAGE_CHANGED:
                return [3, 75];
            }
            return [3, 77];
          case 39:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 40:
            return $e = gt.sent(), fe = t.as(tD), Xe = fe.memberCount, pt = fe.joinedMemberCount, Vt = fe.members, yt = !1, Vt.forEach(function(Re) {
              $e.isExclusive || $e.isSuper || $e.isBroadcast ? yt = yt || $e._setLatestMemberCount(Xe, pt, Ge.ts) : (Re.state = On.JOINED, $e.addMember(Re, Ge.ts), on._updateJoinedMemberCount($e)), Re.userId === on._sdkState.userId && ($e.myMemberState = On.JOINED);
            }), this._dispatcher.dispatch(new Dt({ channels: [$e], source: ne.EVENT_CHANNEL_JOINED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    var Et, st;
                    try {
                      for (var St = be(Vt), Dn = St.next(); !Dn.done; Dn = St.next()) {
                        var Rn = Dn.value;
                        C.onUserJoined && C.onUserJoined($e, Rn);
                      }
                    } catch (_v) {
                      Et = { error: _v };
                    } finally {
                      try {
                        Dn && !Dn.done && (st = St.return) && st.call(St);
                      } finally {
                        if (Et)
                          throw Et.error;
                      }
                    }
                    $e.isBroadcast && yt && C.onChannelMemberCountChanged && C.onChannelMemberCountChanged([$e]);
                  }), [2];
                });
              });
            }), [3, 77];
          case 41:
            return (H = this._leftChannels.get(Ge.channelUrl)) ? (At = H.channel, [3, 44]) : [3, 42];
          case 42:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 43:
            At = gt.sent(), gt.label = 44;
          case 44:
            return xe = At, kt = t.as(lD), jt = kt.memberCount, Bt = kt.joinedMemberCount, Kt = kt.member, ln = !1, vt = D.of(this._iid).appInfo, xe.isExclusive || xe.isSuper || xe.isBroadcast ? ln = xe._setLatestMemberCount(jt, Bt, Ge.ts) : (vt != null && vt.enabledChannelMemberShipHistory ? ((Rt = xe.members.find(function(Re) {
              return Re.userId === Kt.userId;
            })) && (Rt.state = On.LEFT), xe.memberCount = jt) : xe.removeMember(Kt), this._updateJoinedMemberCount(xe)), Kt.userId === this._sdkState.userId ? (xe.myMemberState = On.NONE, xe.invitedAt = 0, xe.joinedAt = 0, xe._updateUnreadCount(0, 0), xe.isPublic ? this._dispatcher.dispatch(new Dt({ channels: [xe], source: ne.EVENT_CHANNEL_LEFT })) : (this._markAsLeave(xe), this._dispatcher.dispatch(new sr({ channelUrls: [xe.url], source: ne.EVENT_CHANNEL_LEFT })))) : this._dispatcher.dispatch(new Dt({ channels: [xe], source: ne.EVENT_CHANNEL_LEFT })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onUserLeft && C.onUserLeft(xe, Kt), xe.isBroadcast && ln && C.onChannelMemberCountChanged && C.onChannelMemberCountChanged([xe]);
                  }), [2];
                });
              });
            }), [3, 77];
          case 45:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 46:
            Ke = gt.sent(), Je = t.as(L3).operators, de = Je.map(function(Re) {
              return Re.userId;
            });
            try {
              for (qe = be(Ke.members), lt = qe.next(); !lt.done; lt = qe.next())
                (Ee = lt.value).role = de.includes(Ee.userId) ? ed.OPERATOR : ed.NONE;
            } catch (Re) {
              gh = { error: Re };
            } finally {
              try {
                lt && !lt.done && (dm = qe.return) && dm.call(qe);
              } finally {
                if (gh)
                  throw gh.error;
              }
            }
            return Ke.myRole = de.includes(this._sdkState.userId) ? ed.OPERATOR : ed.NONE, this._dispatcher.dispatch(new Dt({ channels: [Ke], source: ne.EVENT_CHANNEL_OPERATOR_UPDATED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onOperatorUpdated && C.onOperatorUpdated(Ke, Je);
                  }), [2];
                });
              });
            }), [3, 77];
          case 47:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 48:
            ct = gt.sent(), Ot = t.as(rD), jt = Ot.memberCount, Bt = Ot.joinedMemberCount, zt = Ot.inviter, (cn = Ot.invitees).forEach(function(Re) {
              return Re.state = On.INVITED;
            });
            try {
              for (mt = be(cn), sn = mt.next(); !sn.done; sn = mt.next())
                hn = sn.value, ct.isExclusive || ct.isSuper || ct.isBroadcast ? ct._setLatestMemberCount(jt, Bt, Ge.ts) : ct.addMember(hn, Ge.ts), this._sdkState.userId === hn.userId && (ct.hiddenState = yl.UNHIDDEN, ct.myMemberState !== On.JOINED && (ct.myMemberState = On.INVITED), ct.invitedAt = Ge.ts);
            } catch (Re) {
              Ih = { error: Re };
            } finally {
              try {
                sn && !sn.done && (rm = mt.return) && rm.call(mt);
              } finally {
                if (Ih)
                  throw Ih.error;
              }
            }
            return this._dispatcher.dispatch(new Dt({ channels: [ct], source: ne.EVENT_CHANNEL_INVITED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onUserReceivedInvitation && C.onUserReceivedInvitation(ct, zt, cn);
                  }), [2];
                });
              });
            }), [3, 77];
          case 49:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 50:
            return ft = gt.sent(), qt = t.as(VD), jt = qt.memberCount, Bt = qt.joinedMemberCount, Ie = qt.inviter, it = qt.invitee, ft.isExclusive || ft.isSuper || ft.isBroadcast ? ft._setLatestMemberCount(jt, Bt, Ge.ts) : ft.removeMember(it), this._sdkState.userId === it.userId ? (ft.invitedAt = 0, ft.myMemberState = On.NONE, ft.isPublic ? this._dispatcher.dispatch(new Dt({ channels: [ft], source: ne.EVENT_CHANNEL_DECLINED_INVITE })) : this._dispatcher.dispatch(new sr({ channelUrls: [ft.url], source: ne.EVENT_CHANNEL_DECLINED_INVITE }))) : this._dispatcher.dispatch(new Dt({ channels: [ft], source: ne.EVENT_CHANNEL_DECLINED_INVITE })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onUserDeclinedInvitation && C.onUserDeclinedInvitation(ft, Ie, it);
                  }), [2];
                });
              });
            }), [3, 77];
          case 51:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 52:
            return ze = gt.sent(), ht = Ge.category === Vn.TYPING_START, Ft = t.as(ht ? ND : hD).user, ze._updateTypingStatus(Ft, ht ? Ge.ts : 0), this._dispatcher.dispatch(new Dt({ channels: [ze], source: ne.EVENT_CHANNEL_TYPING_STATUS_UPDATE })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onTypingStatusUpdated && C.onTypingStatusUpdated(ze);
                  }), [2];
                });
              });
            }), [3, 77];
          case 53:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 54:
            X = gt.sent(), Ne = Ge.category === Vn.USER_CHANNEL_MUTE, (pe = t.as(Ne ? b3 : Y3).user).userId === this._sdkState.userId && (X.myMutedState = Ne ? Od.MUTED : Od.UNMUTED, X._myMutedRemainingTime = pe.restrictionInfo.remainingDuration);
            try {
              for (we = be(X.members), Nt = we.next(); !Nt.done; Nt = we.next())
                if ((Ee = Nt.value).userId === pe.userId) {
                  Ee.isMuted = Ne;
                  break;
                }
            } catch (Re) {
              Lh = { error: Re };
            } finally {
              try {
                Nt && !Nt.done && (im = we.return) && im.call(we);
              } finally {
                if (Lh)
                  throw Lh.error;
              }
            }
            return this._dispatcher.dispatch(new Dt({ channels: [X], source: Ne ? ne.EVENT_CHANNEL_MUTED : ne.EVENT_CHANNEL_UNMUTED, data: pe.userId })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    Ne ? C.onUserMuted && C.onUserMuted(X, pe) : C.onUserUnmuted && C.onUserUnmuted(X, pe);
                  }), [2];
                });
              });
            }), [3, 77];
          case 55:
            return (H = this._leftChannels.get(Ge.channelUrl)) ? (ye = H.channel, [3, 58]) : [3, 56];
          case 56:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 57:
            ye = gt.sent(), gt.label = 58;
          case 58:
            return Ve = ye, this._markAsLeave(Ve), Zt = t.as(Q3).user, Zt.userId === this._sdkState.userId && this._dispatcher.dispatch(new sr({ channelUrls: [Ve.url], source: ne.EVENT_CHANNEL_BANNED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onUserBanned && C.onUserBanned(Ve, Zt);
                  }), [2];
                });
              });
            }), [3, 77];
          case 59:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 60:
            return Mt = gt.sent(), Ct = t.as(J3).user, Ct.userId === this._sdkState.userId && this._dispatcher.dispatch(new sr({ channelUrls: [Mt.url], source: ne.EVENT_CHANNEL_UNBANNED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onUserUnbanned && C.onUserUnbanned(Mt, Ct);
                  }), [2];
                });
              });
            }), [3, 77];
          case 61:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 62:
            return Ht = gt.sent(), Sn = t.as(v3).freeze, Ht.isFrozen = Sn, this._dispatcher.dispatch(new Dt({ channels: [Ht], source: Sn ? ne.EVENT_CHANNEL_FROZEN : ne.EVENT_CHANNEL_UNFROZEN })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    Sn ? C.onChannelFrozen && C.onChannelFrozen(Ht) : C.onChannelUnfrozen && C.onChannelUnfrozen(Ht);
                  }), [2];
                });
              });
            }), [3, 77];
          case 63:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 64:
            return bt = gt.sent(), rn = t.as(oD), en = rn.allowAutoUnhide, gn = rn.hidePreviousMessages, An = rn.messageOffsetTimestamp, en !== null && (bt.hiddenState = en ? yl.HIDDEN_ALLOW_AUTO_UNHIDE : yl.HIDDEN_PREVENT_AUTO_UNHIDE), gn !== null && gn && bt._updateUnreadCount(0, 0), An !== null && (bt.messageOffsetTimestamp = An), this._dispatcher.dispatch(new Dt({ channels: [bt], source: ne.EVENT_CHANNEL_HIDDEN })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onChannelHidden && C.onChannelHidden(bt);
                  }), [2];
                });
              });
            }), [3, 77];
          case 65:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 66:
            return (xi = gt.sent()).hiddenState = yl.UNHIDDEN, this._dispatcher.dispatch(new Dt({ channels: [xi], source: ne.EVENT_CHANNEL_UNHIDDEN })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onChannelChanged && C.onChannelChanged(xi);
                  }), [2];
                });
              });
            }), [3, 77];
          case 67:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 68:
            return ir = gt.sent(), this._dispatcher.dispatch(new sr({ channelUrls: [Ge.channelUrl], source: ne.EVENT_CHANNEL_DELETED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onChannelDeleted && C.onChannelDeleted(ir.url, ir.channelType);
                  }), [2];
                });
              });
            }), [3, 77];
          case 69:
            return [4, this.getChannelWithoutCache(Ge.channelUrl, !0)];
          case 70:
            return Dh = gt.sent(), this._dispatcher.dispatch(new Dt({ channels: [Dh], source: ne.EVENT_CHANNEL_UPDATED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onChannelChanged && C.onChannelChanged(Dh);
                  }), [2];
                });
              });
            }), [3, 77];
          case 71:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 72:
            return bd = gt.sent(), MU = t.as(S3), _c = MU.created, Pc = MU.updated, Ac = MU.deleted, _c && (bd._upsertCachedMetaData(_c, Ge.ts), this._dispatcher.dispatch(new Dt({ channels: [bd], source: ne.EVENT_CHANNEL_METADATA_CREATED }))), Pc && (bd._upsertCachedMetaData(Pc, Ge.ts), this._dispatcher.dispatch(new Dt({ channels: [bd], source: ne.EVENT_CHANNEL_METADATA_UPDATED }))), Ac && (bd._removeFromCachedMetaData(Ac, Ge.ts), this._dispatcher.dispatch(new Dt({ channels: [bd], source: ne.EVENT_CHANNEL_METADATA_DELETED }))), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    _c && C.onMetaDataCreated && C.onMetaDataCreated(bd, _c), Pc && C.onMetaDataUpdated && C.onMetaDataUpdated(bd, Pc), Ac && C.onMetaDataDeleted && C.onMetaDataDeleted(bd, Ac);
                  }), [2];
                });
              });
            }), [3, 77];
          case 73:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 74:
            return Gi = gt.sent(), EU = t.as(k3), SU = EU.created, kU = EU.updated, bU = EU.deleted, SU && this._dispatcher.dispatch(new Dt({ channels: [Gi], source: ne.EVENT_CHANNEL_METACOUNTER_CREATED })), kU && this._dispatcher.dispatch(new Dt({ channels: [Gi], source: ne.EVENT_CHANNEL_METACOUNTER_UPDATED })), bU && this._dispatcher.dispatch(new Dt({ channels: [Gi], source: ne.EVENT_CHANNEL_METACOUNTER_DELETED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    SU && C.onMetaCounterCreated && C.onMetaCounterCreated(Gi, SU), kU && C.onMetaCounterUpdated && C.onMetaCounterUpdated(Gi, kU), bU && C.onMetaCounterDeleted && C.onMetaCounterDeleted(Gi, bU);
                  }), [2];
                });
              });
            }), [3, 77];
          case 75:
            return [4, this.getChannel(Ge.channelUrl, !0)];
          case 76:
            return Xr = gt.sent(), YU = t.as(TD), em = YU.pinnedMessageIds, tm = YU.latestPinnedMessage, (nm = YU.ts) > Xr._pinnedMessagesUpdatedAt && (Xr.pinnedMessageIds = em, Xr.lastPinnedMessage = tm, Xr._pinnedMessagesUpdatedAt = nm, this._dispatcher.dispatch(new Dt({ channels: [Xr], source: ne.EVENT_PINNED_MESSAGE_UPDATED })), Ce(function() {
              return M(on, void 0, void 0, function() {
                var Re, C, Et, st, St;
                return p(this, function(Dn) {
                  try {
                    for (Re = be(this._groupChannelHandlers.values()), C = Re.next(); !C.done; C = Re.next())
                      (Et = C.value).onChannelChanged && Et.onChannelChanged(Xr);
                  } catch (Rn) {
                    st = { error: Rn };
                  } finally {
                    try {
                      C && !C.done && (St = Re.return) && St.call(Re);
                    } finally {
                      if (st)
                        throw st.error;
                    }
                  }
                  return [2];
                });
              });
            }), Ce(function() {
              return M(on, void 0, void 0, function() {
                return p(this, function(Re) {
                  return this._groupChannelHandlers.forEach(function(C) {
                    C.onPinnedMessageUpdated && C.onPinnedMessageUpdated(Xr);
                  }), [2];
                });
              });
            })), [3, 77];
          case 77:
            return [3, 79];
          case 78:
            switch ((Xh = t.as(I3).event).category) {
              case uo.USER_BLOCK:
                Oh = sR.getDataAsUserBlockEvent(this._iid, Xh), QU = Oh.blocker, JU = Oh.blockee, this._groupChannelCache.block(QU.userId, JU.userId);
                break;
              case uo.USER_UNBLOCK:
                jh = sR.getDataAsUserBlockEvent(this._iid, Xh), QU = jh.blocker, JU = jh.blockee, this._groupChannelCache.unblock(QU.userId, JU.userId);
            }
            return [3, 79];
          case 79:
            return [3, 81];
          case 80:
            if (Hh = gt.sent(), Il(Hh))
              throw Hh;
            return [3, 81];
          case 81:
            return [2];
        }
      });
    });
  }, n.prototype._markAsLeave = function(t) {
    var l, a = this, d = (l = this._leftChannels.get(t.url)) !== null && l !== void 0 ? l : { channel: t, ref: 0 };
    d.ref++, this._leftChannels.set(t.url, d), setTimeout(function() {
      d.ref--, d.ref === 0 && a._leftChannels.delete(t.url);
    }, 1e4);
  }, n.prototype.addHandler = function(t, l) {
    this._groupChannelHandlers.set(t, l);
  }, n.prototype.removeHandler = function(t) {
    this._groupChannelHandlers.delete(t);
  }, n.prototype.clearHandler = function() {
    this._groupChannelHandlers.clear();
  }, n.prototype.subscribeChannelEvent = function(t, l) {
    this._groupChannelBroadcast.subscribe(t, l);
  }, n.prototype.unsubscribeChannelEvent = function(t) {
    this._groupChannelBroadcast.unsubscribe(t);
  }, n.prototype._updateJoinedMemberCount = function(t) {
    t.joinedMemberCount = t.members.filter(function(l) {
      return l.state === On.JOINED;
    }).length;
  }, n.prototype.getChannel = function(t, l) {
    return l === void 0 && (l = !1), M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            Ze(B("string", t)).throw(j.invalidParameters), d.label = 1;
          case 1:
            return d.trys.push([1, 3, , 4]), [4, this.getChannelFromCache(t)];
          case 2:
            return (a = d.sent()) ? [2, a] : [3, 4];
          case 3:
            return d.sent(), [3, 4];
          case 4:
            return [4, this.getChannelWithoutCache(t, l)];
          case 5:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype.getChannelWithoutCache = function(t, l) {
    return l === void 0 && (l = !1), M(this, void 0, void 0, function() {
      var a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return Ze(B("string", t)).throw(j.invalidParameters), a = new $T({ channelUrl: t, isInternalCall: l }), [4, this._requestQueue.send(a)];
          case 1:
            switch (d = V.sent(), r = d.as(e0).channel, i = r.unreadMessageCount, c = r.unreadMentionCount, r.myCountPreference) {
              case Ja.UNREAD_MESSAGE_COUNT_ONLY:
                c = 0;
                break;
              case Ja.UNREAD_MENTION_COUNT_ONLY:
                i = 0;
                break;
              case Ja.OFF:
                i = 0, c = 0;
            }
            return r._updateUnreadCount(i, c), [4, this.upsertChannelsToCache([r])];
          case 2:
            return [2, V.sent()[0]];
        }
      });
    });
  }, n.prototype.refreshChannel = function(t, l, a) {
    return l === void 0 && (l = !0), a === void 0 && (a = ne.REFRESH_CHANNEL), M(this, void 0, void 0, function() {
      var d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return s.trys.push([0, 5, , 6]), d = new $T({ channelUrl: t, isInternalCall: l }), [4, this._requestQueue.send(d)];
          case 1:
            return r = s.sent(), (i = r.as(e0).channel).myMemberState !== On.NONE ? [3, 2] : (this._dispatcher.dispatch(new sr({ channelUrls: [i.url], source: a })), [3, 4]);
          case 2:
            return [4, this.upsertChannelsToCache([i])];
          case 3:
            c = s.sent(), this._dispatcher.dispatch(new Dt({ channels: c, source: a })), s.label = 4;
          case 4:
            return [3, 6];
          case 5:
            return (V = s.sent()).code !== nt.NON_AUTHORIZED && V.code !== nt.NOT_FOUND_IN_DATABASE || this._dispatcher.dispatch(new sr({ channelUrls: [t], source: a })), [3, 6];
          case 6:
            return [2];
        }
      });
    });
  }, n.prototype.getMyGroupChannels = function(t, l, a, d, r) {
    return d === void 0 && (d = ne.REQUEST_CHANNEL), r === void 0 && (r = !1), M(this, void 0, void 0, function() {
      var i, c, V, s, o, U, N, R, h;
      return p(this, function(Z) {
        switch (Z.label) {
          case 0:
            return l.createdAfter && (l.createdAfter = Math.floor(l.createdAfter / 1e3)), l.createdBefore && (l.createdBefore = Math.floor(l.createdBefore / 1e3)), i = !1, r && (c = D.of(this._iid), V = c.appInfo, (s = c.cacheContext) && !s.localCacheEnabled && (V != null && V.enabledChannelMemberShipHistory) && (V != null && V.applicationAttributes.includes("left_user_view_support")) && (i = !0)), o = new XB(x(x({}, l), { userId: this._sdkState.userId, token: t, limit: a, includeLeftChannel: r && i })), [4, this._requestQueue.send(o)];
          case 1:
            return U = Z.sent(), N = U.as(OB), R = N.channels, h = N.token, this._dispatcher.dispatch(new Dt({ channels: R, source: d })), [2, { channels: R, token: h }];
        }
      });
    });
  }, n.prototype.getMyGroupChannelChangeLogs = function(t, l, a) {
    return a === void 0 && (a = ne.REQUEST_CHANNEL_CHANGELOGS), M(this, void 0, void 0, function() {
      var d, r, i, c, V, s, o, U;
      return p(this, function(N) {
        switch (N.label) {
          case 0:
            return d = x(x({}, UR), l), Ze((B("string", t) || B("number", t)) && qT(d)).throw(j.invalidParameters), r = new BB(Ae({ userId: this._sdkState.userId, ts: typeof t == "number" ? t : null, token: typeof t == "string" ? t : null, filter: d })), [4, this._requestQueue.send(r)];
          case 1:
            return i = N.sent(), c = i.as(DB), V = c.updatedChannels, s = c.deletedChannelUrls, o = c.hasMore, U = c.ts, V.length > 0 && this._dispatcher.dispatch(new Dt({ channels: V, source: a, ts: U })), s.length > 0 && this._dispatcher.dispatch(new sr({ channelUrls: s, source: a })), [2, { updatedChannels: V, deletedChannelUrls: s, hasMore: o, token: c.token }];
        }
      });
    });
  }, n.prototype.getGroupChannelCount = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return l = x(x({}, tb), t), Ze(nb(l)).throw(j.invalidParameters), a = new jB({ userId: this._sdkState.userId, filter: l }), [4, this._requestQueue.send(a)];
          case 1:
            return d = r.sent(), [2, d.as(HB).groupChannelCount];
        }
      });
    });
  }, n.prototype.getUnreadItemCount = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F;
      return p(this, function(m) {
        switch (m.label) {
          case 0:
            return l = x(x({}, vB), t), Ze(function(E) {
              return Jt(il, E.keys);
            }(l)).throw(j.invalidParameters), a = D.of(this._iid), d = a.sdkState, r = a.requestQueue, i = new fB({ userId: d.userId, filter: l }), [4, r.send(i)];
          case 1:
            return c = m.sent(), V = c.as(wB), s = V.groupChannelUnreadMentionCount, o = V.groupChannelUnreadMessageCount, U = V.groupChannelInvitationCount, N = V.superGroupChannelUnreadMentionCount, R = V.superGroupChannelUnreadMessageCount, h = V.superGroupChannelInvitationCount, Z = V.nonSuperGroupChannelUnreadMentionCount, W = V.nonSuperGroupChannelUnreadMessageCount, F = V.nonSuperGroupChannelInvitationCount, [2, je({ groupChannelUnreadMentionCount: s, groupChannelUnreadMessageCount: o, groupChannelInvitationCount: U, superGroupChannelUnreadMentionCount: N, superGroupChannelUnreadMessageCount: R, superGroupChannelInvitationCount: h, nonSuperGroupChannelUnreadMentionCount: Z, nonSuperGroupChannelUnreadMessageCount: W, nonSuperGroupChannelInvitationCount: F })];
        }
      });
    });
  }, n.prototype.getTotalUnreadChannelCount = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new gB({ userId: l.userId }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(IB).unreadCount];
        }
      });
    });
  }, n.prototype.getTotalUnreadMessageCount = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return l = x(x({}, zB), t), Ze(xB(l)).throw(j.invalidParameters), a = D.of(this._iid), d = a.sdkState, r = a.requestQueue, i = new LB({ userId: d.userId, filter: l }), [4, r.send(i)];
          case 1:
            return c = V.sent(), [2, c.as(CB).unreadCount];
        }
      });
    });
  }, n.prototype.getTotalScheduledMessageCount = function(t) {
    return t === void 0 && (t = {}), M(this, void 0, void 0, function() {
      var l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return l = x(x({}, GB), t), Ze(function(c) {
              return B("string", c.channelUrl, !0) && Jt(ii, c.scheduledStatus, !0) && Qt(bl, c.messageTypeFilter);
            }(l)).throw(j.invalidParameters), a = D.of(this._iid).requestQueue, d = new KB(l), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(_B).count];
        }
      });
    });
  }, n.prototype.getSubscribedTotalUnreadMessageCount = function() {
    var t = D.of(this._iid).subscribedUnreadMessageCount;
    return t.all >= 0 ? t.all : 0;
  }, n.prototype.getSubscribedCustomTypeTotalUnreadMessageCount = function() {
    var t = 0, l = D.of(this._iid).subscribedUnreadMessageCount;
    for (var a in l.customTypes)
      t += l.customTypes[a];
    return t;
  }, n.prototype.getSubscribedCustomTypeUnreadMessageCount = function(t) {
    var l;
    return (l = D.of(this._iid).subscribedUnreadMessageCount.customTypes[t]) !== null && l !== void 0 ? l : 0;
  }, n.prototype.createChannel = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return l = x(x({}, YN), t), Ze(AT(l)).throw(j.invalidParameters), l.isPublic || (l.accessCode = void 0), a = new AB(x({ userId: this._sdkState.userId }, l)), [4, this._requestQueue.send(a)];
          case 1:
            return d = i.sent(), r = d.as(qB).channel, [4, this.upsertChannelsToCache([r])];
          case 2:
            return i.sent(), [2, r];
        }
      });
    });
  }, n.prototype.markAsReadAll = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return t = Date.now(), Ze(t - this._markAsReadAllLastSentAt >= 1e3).throw(j.markAsReadAllRateLimitExceeded), this._markAsReadAllLastSentAt = t, l = new Du({ userId: this._sdkState.userId }), [4, this._requestQueue.send(l)];
          case 1:
            s.sent(), a = this._groupChannelCache.channels;
            try {
              for (d = be(a), r = d.next(); !r.done; r = d.next())
                (i = r.value)._updateUnreadMemberState(this._sdkState.userId, t), i._updateUnreadCount(0, 0);
            } catch (o) {
              c = { error: o };
            } finally {
              try {
                r && !r.done && (V = d.return) && V.call(d);
              } finally {
                if (c)
                  throw c.error;
              }
            }
            return a.length > 0 ? [4, this.upsertChannelsToCache(a)] : [3, 3];
          case 2:
            s.sent(), s.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, n.prototype.markAsReadWithChannelUrls = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s, o;
      return p(this, function(U) {
        switch (U.label) {
          case 0:
            return l = Date.now(), Ze(Jt("string", t) && l - this._markAsReadAllLastSentAt >= 1e3).throw(j.markAsReadAllRateLimitExceeded), this._markAsReadAllLastSentAt = l, a = new Du({ userId: this._sdkState.userId, channelUrls: t }), [4, this._requestQueue.send(a)];
          case 1:
            U.sent(), d = this._groupChannelCache.channels, r = [];
            try {
              for (i = be(d), c = i.next(); !c.done; c = i.next())
                V = c.value, t.includes(V.url) && (V._updateUnreadMemberState(this._sdkState.userId, l), V._updateUnreadCount(0, 0), r.push(V));
            } catch (N) {
              s = { error: N };
            } finally {
              try {
                c && !c.done && (o = i.return) && o.call(i);
              } finally {
                if (s)
                  throw s.error;
              }
            }
            return r.length > 0 ? [4, this.upsertChannelsToCache(r)] : [3, 3];
          case 2:
            U.sent(), U.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, n.prototype.markAsDelivered = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this.getChannel(t)];
          case 1:
            return [4, l.sent().markAsDelivered()];
          case 2:
            return l.sent(), [2];
        }
      });
    });
  }, n.prototype.getMessageFromCache = function(t) {
    var l;
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._messageCache.get(t)];
          case 1:
            return [2, (l = a.sent()) !== null && l !== void 0 ? l : null];
        }
      });
    });
  }, n.prototype.getExactlyMatchingMessagesForTokenFromCache = function(t, l, a) {
    return M(this, void 0, void 0, function() {
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return [4, this._messageCache.fetch({ channelUrl: t, token: l, filter: a, exactMatch: !0 })];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype.getMessagesFromCache = function(t, l, a, d, r, i) {
    return r === void 0 && (r = B3), i === void 0 && (i = !0), M(this, void 0, void 0, function() {
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return [4, this._messageCache.fetch({ channelUrl: t, token: l, limit: r, filter: d, backward: a === "next", inclusive: i })];
          case 1:
            return [2, c.sent()];
        }
      });
    });
  }, n.prototype.getPollMessagesFromCache = function(t, l, a, d) {
    return M(this, void 0, void 0, function() {
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this._messageCache.fetch({ channelUrl: t, token: l, limit: d, filter: a, backward: !1, isPollOnly: !0 })];
          case 1:
            return [2, r.sent()];
        }
      });
    });
  }, n.prototype.getCachedMessageCountBetween = function(t, l, a, d) {
    return M(this, void 0, void 0, function() {
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this._messageCache.countBetween(t, l, new fd({ top: a, bottom: d }))];
          case 1:
            return [2, r.sent()];
        }
      });
    });
  }, n.prototype.getUnsentMessagesFromCache = function(t, l) {
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._unsentMessageCache.fetch({ channelUrl: t, filter: l })];
          case 1:
            return [2, a.sent()];
        }
      });
    });
  }, n.prototype.removeFailedMessageFromCache = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._unsentMessageCache.remove([t])];
          case 1:
            return l.sent(), [2];
        }
      });
    });
  }, n;
}(C3), Ea = function(e, n) {
  return n instanceof wn ? e.findIndex(function(t) {
    return t instanceof wn && n.isIdentical(t);
  }) : e.findIndex(function(t) {
    return t.isIdentical(n);
  });
}, ls = function(e, n) {
  return e.findIndex(function(t) {
    return t instanceof Bl ? t.messageId === n : t instanceof SV ? t.notificationId === n : void 0;
  });
}, uZ = function(e, n) {
  if (e.length > 0) {
    for (var t = 0, l = e.length - 1, a = Math.floor((t + l) / 2); t < l; ) {
      var d = e[a].createdAt - n.createdAt;
      if (d > 0)
        l = a, a = Math.floor((t + l) / 2);
      else {
        if (!(d < 0))
          return a;
        t = a + 1, a = Math.floor((t + l) / 2);
      }
    }
    return e[a].createdAt > n.createdAt ? a : a + 1;
  }
  return e.length;
};
(function(e) {
  e[e.IDLE = 0] = "IDLE", e[e.RUNNING = 1] = "RUNNING", e[e.END = 2] = "END";
})(Rr || (Rr = {}));
var n0, ui = function(e) {
  function n(t, l, a, d) {
    var r = e.call(this) || this;
    return r._state = Rr.IDLE, r._retryCount = 0, r._retryLimit = 3, r.priority = 0, r._worker = l, r;
  }
  return J(n, e), Object.defineProperty(n.prototype, "isIdle", { get: function() {
    return this._state === Rr.IDLE;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isRunning", { get: function() {
    return this._state === Rr.RUNNING;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isDone", { get: function() {
    return this._state === Rr.END;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "retryCount", { get: function() {
    return this._retryCount;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "retryLimit", { get: function() {
    return this._retryLimit;
  }, enumerable: !1, configurable: !0 }), n.prototype._run = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            if (!this.isRunning)
              return [3, 4];
            d.label = 1;
          case 1:
            return d.trys.push([1, 3, , 4]), [4, this._worker(t)];
          case 2:
            return l = d.sent(), this._retryCount = 0, this.dispatch("progress", l), l.hasNext ? this._run(l.nextToken) : this.end(), [3, 4];
          case 3:
            return a = d.sent(), this.dispatch("error", a), this._retryCount < this._retryLimit ? (this._retryCount++, this._run(t)) : this.stop(), [3, 4];
          case 4:
            return [2];
        }
      });
    });
  }, n.prototype.start = function(t) {
    this.isIdle && (this._state = Rr.RUNNING, this._run(t));
  }, n.prototype.stop = function() {
    this._state = Rr.IDLE, this.dispatch("stop");
  }, n.prototype.end = function() {
    this._state = Rr.END, this.dispatch("end");
  }, n;
}(zV), cd = {}, mD = function() {
  function e(n) {
    var t = n._iid, l = n.channel, a = n.limit, d = a === void 0 ? 100 : a, r = this;
    this.ref = 0, this._iid = t, this._channel = l, this._limit = d, this._prevSyncLoopCount = 0;
    var i, c, V = D.of(this._iid), s = V.sdkState, o = V.cacheContext, U = V.dispatcher, N = V.logger, R = V.statLogCollector;
    this._metadataKey = (i = s.userId, c = l.url, "sendbird:".concat(i, "@groupchannel/").concat(c, "/message/sync.meta"));
    var h = function(Z, W) {
      return "sendbird:".concat(Z, "@groupchannel/").concat(W, "/message/sync");
    }(s.userId, l.url);
    this._prevSync = new ui(h, function(Z) {
      return M(r, void 0, void 0, function() {
        var W, F, m, E, u, b, k, Q, S, v, G, w;
        return p(this, function(y) {
          switch (y.label) {
            case 0:
              return W = { hasNext: !0, nextToken: 0 }, this._prevSyncLoopCount++, [4, this.loadMetadata(Z)];
            case 1:
              if (y.sent(), N.debug("message background prev sync from", (b = this._metadata) === null || b === void 0 ? void 0 : b.range.top), (k = this._metadata) === null || k === void 0 ? void 0 : k.previousComplete)
                return [3, 10];
              y.label = 2;
            case 2:
              return y.trys.push([2, 5, 8, 9]), [4, tl.of(this._iid).getMessagesByTimestamp(this._channel.url, this._channel.channelType, !((S = (Q = this._metadata) === null || Q === void 0 ? void 0 : Q.range) === null || S === void 0) && S.top ? this._metadata.range.top : Z, { prevResultSize: this._limit, nextResultSize: 0, replyType: al.ALL, includeReactions: !0, includeMetaArray: !0, includeParentMessageInfo: !0, includeThreadInfo: !0 }, ne.SYNC_MESSAGE_BACKGROUND)];
            case 3:
              return (F = y.sent()).length > 0 && (m = F.map(function(g) {
                return g.createdAt;
              }), !((v = this._metadata) === null || v === void 0) && (u = v.range).intersect.apply(u, ot([], et(m), !1)) ? this.extendRange(F) : this._metadata = { range: new fd({ top: Math.min.apply(Math, ot([], et(m), !1)), bottom: Math.max.apply(Math, ot([], et(m), !1)) }), previousComplete: !1 }), W.hasNext = F.length >= this._limit && this._prevSyncLoopCount < 1, this._metadata && (W.nextToken = this._metadata.range.top, this._metadata.previousComplete = F.length < this._limit), N.debug("message background prev sync progress", W), [4, this.saveMetadata()];
            case 4:
              return y.sent(), [3, 9];
            case 5:
              return E = y.sent(), N.debug("message background prev sync error", E), E instanceof j && E.isInvalidTokenError ? [4, this.clearMetadata()] : [3, 7];
            case 6:
              y.sent(), y.label = 7;
            case 7:
              throw E;
            case 8:
              return R.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: l.url, measured_on: "back_sync", event: "cache_fetch", max_db_size: (w = (G = o.localCacheConfig) === null || G === void 0 ? void 0 : G.maxSize) !== null && w !== void 0 ? w : 0, use_local_cache: o.localCacheEnabled, starting_point: 0, message_init_policy: "" } })), [7];
            case 9:
              return [3, 11];
            case 10:
              W.hasNext = !1, y.label = 11;
            case 11:
              return [2, W];
          }
        });
      });
    }), this._nextSync = new ui(h, function(Z) {
      return M(r, void 0, void 0, function() {
        var W, F, m, E, u, b, k, Q, S, v, G;
        return p(this, function(w) {
          switch (w.label) {
            case 0:
              return W = { hasNext: !0, nextToken: 0 }, [4, this.loadMetadata(Z)];
            case 1:
              w.sent(), N.debug("message background next sync from", (b = this._metadata) === null || b === void 0 ? void 0 : b.range.bottom), w.label = 2;
            case 2:
              return w.trys.push([2, 5, 6, 7]), [4, tl.of(this._iid).getMessagesByTimestamp(this._channel.url, this._channel.channelType, !((Q = (k = this._metadata) === null || k === void 0 ? void 0 : k.range) === null || Q === void 0) && Q.bottom ? this._metadata.range.bottom : Z, { prevResultSize: 0, nextResultSize: this._limit, replyType: al.ALL, includeReactions: !0, includeMetaArray: !0, includeParentMessageInfo: !0, includeThreadInfo: !0 }, ne.SYNC_MESSAGE_BACKGROUND)];
            case 3:
              return (F = w.sent()).length > 0 && (m = F.map(function(y) {
                return y.createdAt;
              }), !((S = this._metadata) === null || S === void 0) && (u = S.range).intersect.apply(u, ot([], et(m), !1)) ? this.extendRange(F) : this._metadata = { range: new fd({ top: Math.min.apply(Math, ot([], et(m), !1)), bottom: Math.max.apply(Math, ot([], et(m), !1)) }), previousComplete: !1 }), W.hasNext = F.length >= this._limit, this._metadata && (W.nextToken = this._metadata.range.bottom), N.debug("message background next sync progress", W), [4, this.saveMetadata()];
            case 4:
              return w.sent(), [3, 7];
            case 5:
              throw E = w.sent(), N.debug("message background next sync error", E), E;
            case 6:
              return R.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: l.url, measured_on: "back_sync", event: "cache_fetch", max_db_size: (G = (v = o.localCacheConfig) === null || v === void 0 ? void 0 : v.maxSize) !== null && G !== void 0 ? G : 0, use_local_cache: o.localCacheEnabled, starting_point: 0, message_init_policy: "" } })), [7];
            case 7:
              return [2, W];
          }
        });
      });
    }), this._connectionEventContext = U.on(function(Z) {
      Z instanceof ua && (Z.stateType === tn.CONNECTED ? r.resume() : r.pause());
    });
  }
  return e.of = function(n, t) {
    return cd[n] || (cd[n] = {}), cd[n][t.url] || (cd[n][t.url] = new e({ _iid: n, channel: t })), cd[n][t.url].ref++, cd[n][t.url];
  }, e.clear = function(n, t) {
    cd[n] && cd[n][t] && (cd[n][t].close(), delete cd[n]);
  }, Object.defineProperty(e.prototype, "range", { get: function() {
    var n, t;
    return (t = (n = this._metadata) === null || n === void 0 ? void 0 : n.range) !== null && t !== void 0 ? t : new fd({});
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "previousComplete", { get: function() {
    var n;
    return !!(!((n = this._metadata) === null || n === void 0) && n.previousComplete);
  }, enumerable: !1, configurable: !0 }), e.prototype.isWrappingMessages = function(n) {
    var t;
    return (t = this.range) === null || t === void 0 ? void 0 : t.includes.apply(t, ot([], et(n.map(function(l) {
      return l.createdAt;
    })), !1));
  }, e.prototype.extendRange = function(n) {
    var t;
    this._metadata && (t = this._metadata.range).extends.apply(t, ot([], et(n.map(function(l) {
      return l.createdAt;
    })), !1));
  }, e.prototype.loadMetadata = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return this._metadata ? [3, 2] : [4, D.of(this._iid).cacheContext.preference.get(this._metadataKey)];
          case 1:
            t = l.sent(), this._metadata = t ? { range: new fd(t.range), previousComplete: t.previousComplete } : { range: new fd({}), previousComplete: !1 }, l.label = 2;
          case 2:
            return [2, this._metadata];
        }
      });
    });
  }, e.prototype.saveMetadata = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return this._metadata ? [4, D.of(this._iid).cacheContext.preference.set(this._metadataKey, this._metadata)] : [3, 2];
          case 1:
            return n.sent(), [2, !0];
          case 2:
            return [2, !1];
        }
      });
    });
  }, e.prototype.clearMetadata = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, D.of(this._iid).cacheContext.preference.remove(this._metadataKey)];
          case 1:
            return n.sent(), this._metadata = void 0, [2];
        }
      });
    });
  }, e.prototype.resume = function(n) {
    var t, l, a, d;
    n === void 0 && (n = Date.now());
    var r = D.of(this._iid), i = r.logger;
    r.sessionManager.session.hasSession && (i.debug("message background sync resume()"), this._prevSyncLoopCount = 0, this._metadata && this._metadata.previousComplete || this._prevSync.start((l = (t = this._metadata) === null || t === void 0 ? void 0 : t.range.top) !== null && l !== void 0 ? l : n), this._nextSync.start((d = (a = this._metadata) === null || a === void 0 ? void 0 : a.range.bottom) !== null && d !== void 0 ? d : n));
  }, e.prototype.pause = function() {
    D.of(this._iid).logger.debug("message background sync stop()"), this._prevSync.stop(), this._nextSync.stop();
  }, e.prototype.close = function() {
    this.ref--, this.ref <= 0 && (this.ref = 0, this.pause(), this._connectionEventContext.close(), delete cd[this._iid][this._channel.url]);
  }, e;
}(), sd = {}, uD = function() {
  function e(n) {
    var t = n._iid, l = n.channel, a = n.includeParams, d = this;
    this.ref = 0, this._iid = t, this._channel = l, this._includeParams = a;
    var r, i, c = D.of(this._iid), V = c.logger, s = c.sdkState, o = c.dispatcher;
    this._metadataKey = (r = s.userId, i = l.url, "sendbird:".concat(r, "@groupchannel/").concat(i, "/message/changelogs.meta"));
    var U = function(N, R) {
      return "sendbird:".concat(N, "@groupchannel/").concat(R, "/message/changelogs");
    }(s.userId, this._channel.url);
    this._sync = new ui(U, function() {
      return M(d, void 0, void 0, function() {
        var N, R, h, Z, W, F, m, E;
        return p(this, function(u) {
          switch (u.label) {
            case 0:
              return N = { hasNext: !0, nextToken: 0 }, [4, this.loadMetadata()];
            case 1:
              u.sent(), V.debug("message changelog sync from", (E = this._metadata) === null || E === void 0 ? void 0 : E.token), u.label = 2;
            case 2:
              return u.trys.push([2, 5, , 8]), [4, tl.of(this._iid).getMessageChangelogs(this._channel.url, this._channel.channelType, this._metadata.token, x({ replyType: al.ALL }, this._includeParams), ne.SYNC_MESSAGE_CHANGELOGS)];
            case 3:
              return R = u.sent(), h = R.updatedMessages, Z = R.deletedMessageIds, W = R.hasMore, F = R.token, N.hasNext = W, N.nextToken = F, (h.length > 0 || Z.length > 0) && this._metadata && (this._metadata.token = F), V.debug("message changelog sync progress", N), [4, this.saveMetadata()];
            case 4:
              return u.sent(), [3, 8];
            case 5:
              return m = u.sent(), V.debug("message changelog sync error", m), m instanceof j && m.isInvalidTokenError ? [4, this.clearMetadata()] : [3, 7];
            case 6:
              u.sent(), u.label = 7;
            case 7:
              throw m;
            case 8:
              return [2, N];
          }
        });
      });
    }), this._connectionEventContext = o.on(function(N) {
      N instanceof ua && (N.stateType === tn.CONNECTED ? d.resume() : d.pause());
    });
  }
  return e.of = function(n, t, l) {
    return sd[n] || (sd[n] = {}), sd[n][t.url] || (sd[n][t.url] = new e({ _iid: n, channel: t, includeParams: l })), sd[n][t.url].ref++, sd[n][t.url];
  }, e.clear = function(n, t) {
    sd[n] && sd[n][t] && (sd[n][t].close(), delete sd[n]);
  }, e.prototype.loadMetadata = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return this._metadata ? [3, 2] : (n = D.of(this._iid), t = n.cacheContext, l = n.firstConnectedAt, [4, t.preference.get(this._metadataKey)]);
          case 1:
            a = d.sent(), this._metadata = { token: a ? a.token : l }, d.label = 2;
          case 2:
            return [2, this._metadata];
        }
      });
    });
  }, e.prototype.saveMetadata = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return this._metadata ? [4, D.of(this._iid).cacheContext.preference.set(this._metadataKey, this._metadata)] : [3, 2];
          case 1:
            return n.sent(), [2, !0];
          case 2:
            return [2, !1];
        }
      });
    });
  }, e.prototype.clearMetadata = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, D.of(this._iid).cacheContext.preference.remove(this._metadataKey)];
          case 1:
            return n.sent(), this._metadata = void 0, [2];
        }
      });
    });
  }, e.prototype.resume = function() {
    var n = D.of(this._iid), t = n.logger;
    n.sessionManager.session.hasSession && (t.debug("message changelog sync resume()"), this._sync.start(0));
  }, e.prototype.pause = function() {
    D.of(this._iid).logger.debug("message changelog sync pause()"), this._sync.stop();
  }, e.prototype.close = function() {
    this.ref--, this.ref <= 0 && (this.ref = 0, this.pause(), this._connectionEventContext.close(), delete sd[this._iid][this._channel.url]);
  }, e;
}(), Di = {}, pD = function() {
  function e(n) {
    var t = n._iid, l = n.channel, a = n.hasPollMessage, d = this;
    this.ref = 0, this._iid = t, this._channel = l;
    var r, i, c = D.of(this._iid), V = c.logger, s = c.sdkState, o = c.dispatcher;
    this._metadataKey = (r = s.userId, i = l.url, "sendbird:".concat(r, "@groupchannel/").concat(i, "/poll/changelogs.meta"));
    var U = function(N, R) {
      return "sendbird:".concat(N, "@groupchannel/").concat(R, "/poll/changelogs");
    }(s.userId, this._channel.url);
    this._sync = new ui(U, function() {
      return M(d, void 0, void 0, function() {
        var N, R, h, Z, W, F, m, E;
        return p(this, function(u) {
          switch (u.label) {
            case 0:
              return N = { hasNext: !0, nextToken: 0 }, [4, this.loadMetadata()];
            case 1:
              return u.sent(), V.debug("poll changelog sync from", (E = this._metadata) === null || E === void 0 ? void 0 : E.token), (R = !this._metadata || !this._metadata.token) ? [4, a()] : [3, 3];
            case 2:
              R = !u.sent(), u.label = 3;
            case 3:
              if (R)
                return [2, { hasNext: !1, nextToken: 0 }];
              this._metadata || (h = D.of(this._iid).firstConnectedAt, this._metadata = { token: h }), u.label = 4;
            case 4:
              return u.trys.push([4, 7, , 10]), [4, tR.of(this._iid).getPollChangeLogs(this._channel.url, this._channel.channelType, this._metadata.token)];
            case 5:
              return Z = u.sent(), W = Z.hasMore, F = Z.token, N.hasNext = W, N.nextToken = F, this._metadata.token = F, V.debug("poll changelog sync progress", N), [4, this.saveMetadata()];
            case 6:
              return u.sent(), [3, 10];
            case 7:
              return m = u.sent(), V.debug("poll changelog sync error", m), m instanceof j && m.isInvalidTokenError ? [4, this.clearMetadata()] : [3, 9];
            case 8:
              u.sent(), u.label = 9;
            case 9:
              throw m;
            case 10:
              return [2, N];
          }
        });
      });
    }), this._connectionEventContext = o.on(function(N) {
      N instanceof ua && (N.stateType === tn.CONNECTED ? d.resume() : d.pause());
    });
  }
  return e.of = function(n, t, l) {
    return Di[n] || (Di[n] = {}), Di[n][t.url] || (Di[n][t.url] = new e({ _iid: n, channel: t, hasPollMessage: l })), Di[n][t.url].ref++, Di[n][t.url];
  }, e.prototype.loadMetadata = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this._metadata ? [3, 2] : [4, D.of(this._iid).cacheContext.preference.get(this._metadataKey)];
          case 1:
            n = t.sent(), this._metadata = n ? { token: n.token } : void 0, t.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, e.prototype.saveMetadata = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return this._metadata ? [4, D.of(this._iid).cacheContext.preference.set(this._metadataKey, this._metadata)] : [3, 2];
          case 1:
            n.sent(), n.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, e.prototype.clearMetadata = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, D.of(this._iid).cacheContext.preference.remove(this._metadataKey)];
          case 1:
            return n.sent(), this._metadata = void 0, [2];
        }
      });
    });
  }, e.prototype.resume = function() {
    D.of(this._iid).logger.debug("poll changelog sync resume()"), this._sync.start(0);
  }, e.prototype.pause = function() {
    D.of(this._iid).logger.debug("poll changelog sync pause()"), this._sync.stop();
  }, e.prototype.close = function() {
    this.ref--, this.ref <= 0 && (this.ref = 0, this.pause(), this._connectionEventContext.close(), delete Di[this._iid][this._channel.url]);
  }, e;
}(), MD = function(e) {
  function n(t) {
    var l = t.channels, a = t.source, d = t.isWebSocketEventComing, r = d !== void 0 && d, i = t.data, c = i === void 0 ? null : i, V = e.call(this) || this;
    return V.channels = l, V.source = a, V.isWebSocketEventComing = r, V.data = c, V;
  }
  return J(n, e), n;
}(un);
(function(e) {
  function n(t) {
    var l = t.channelUrls, a = t.source, d = t.isWebSocketEventComing, r = d !== void 0 && d, i = e.call(this) || this;
    return i.channelUrls = l, i.source = a, i.isWebSocketEventComing = r, i;
  }
  return J(n, e), n;
})(un);
var ED = function(e) {
  function n(t) {
    var l, a, d, r, i, c, V, s, o, U, N = this;
    return (N = e.call(this) || this).method = he.GET, N.path = "".concat(Lt(t.channelType), "/").concat(t.channelUrl, "/messages_gap"), N.params = je({ prev_start_ts: t.prevStart, prev_end_ts: t.prevEnd, prev_cache_count: t.prevCount, next_start_ts: t.nextStart, next_end_ts: t.nextEnd, next_cache_count: t.nextCount, huge_gap_threshold: (l = t.threshold) !== null && l !== void 0 ? l : null, reverse: !0, custom_types: (a = t.customTypes) !== null && a !== void 0 ? a : ["*"], message_type: (d = t.messageType) !== null && d !== void 0 ? d : null, include_reply_type: (r = t.replyType) !== null && r !== void 0 ? r : al.NONE, include_reactions: (i = t.includeReactions) === null || i === void 0 || i, include_meta_array: (c = t.includeMetaArray) === null || c === void 0 || c, include_thread_info: (V = t.includeThreadInfo) === null || V === void 0 || V, include_parent_message_info: (s = t.includeParentMessageInfo) === null || s === void 0 || s, with_sorted_meta_array: (o = t.includeMetaArray) === null || o === void 0 || o, show_subchannel_messages_only: (U = t.showSubchannelMessagesOnly) !== null && U !== void 0 && U, include_poll_details: !0, checking_continuous_messages: t.checkingContinuousMessages }), N;
  }
  return J(n, e), n;
}(Te), SD = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s = this;
    return (s = e.call(this, t, l) || this).isHugeGap = l.is_huge_gap, s.prevMessages = ((a = l.prev_messages) !== null && a !== void 0 ? a : []).map(function(o) {
      return Hl(t, o);
    }), s.prevHasMore = (d = l.prev_hasmore) !== null && d !== void 0 && d, s.isContinuousPrevMessages = (r = l.is_continuous_prev_messages) !== null && r !== void 0 && r, s.nextMessages = ((i = l.next_messages) !== null && i !== void 0 ? i : []).map(function(o) {
      return Hl(t, o);
    }), s.nextHasmore = (c = l.next_hasmore) !== null && c !== void 0 && c, s.isContinuousNextMessages = (V = l.is_continuous_next_messages) !== null && V !== void 0 && V, s;
  }
  return J(n, e), n;
}(ue), ab = function(e) {
  this.source = e;
}, l0 = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return J(n, e), n;
}(ab), kD = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return J(n, e), n;
}(ab), db = function(e) {
  this.source = e;
}, bD = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return J(n, e), n;
}(db), YD = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return J(n, e), n;
}(db), Xu = { includeMetaArray: !0, includeReactions: !0, includeThreadInfo: !0, includeParentMessageInfo: !0 };
(function(e) {
  e.CACHE_AND_REPLACE_BY_API = "cache_and_replace_by_api";
})(n0 || (n0 = {}));
var As, qs, $s, QD = function() {
  function e() {
    this._onCacheResult = ut, this._onApiResult = ut;
  }
  return e.prototype._invokeResponse = function(n, t, l) {
    var a = this;
    Ce(function() {
      return M(a, void 0, void 0, function() {
        return p(this, function(d) {
          switch (n) {
            case "local":
              this._onCacheResult(t, l);
              break;
            case "remote":
              this._onApiResult(t, l);
          }
          return [2];
        });
      });
    });
  }, e.prototype.onCacheResult = function(n) {
    return this._onCacheResult = n, this;
  }, e.prototype.onApiResult = function(n) {
    return this._onApiResult = n, this;
  }, e;
}(), JD = function() {
  function e(n, t) {
    var l = t.filter, a = t.startingPoint, d = t.limit, r = t.prevResultLimit, i = t.nextResultLimit, c = t.channel, V = t.channelManager, s = t.disableBackgroundSync, o = s !== void 0 && s, U = this;
    this._messages = [], this._unsentMessages = [], this._isLoadingPrevious = !1, this._isLoadingNext = !1, this._iid = n, this._key = "mc-".concat(vr()), this._isDisposed = !1, this.filter = l ?? new mi(), this._channel = c, this._syncRange = new fd({}), this._hasPrevious = !0, this._hasNext = !0, this._startingPoint = typeof a == "number" && Number.isFinite(a) ? a : Number.MAX_SAFE_INTEGER, this._limit = d || B3, this._prevResultLimit = r ?? Math.floor(this._limit / 2), this._nextResultLimit = i ?? Math.floor(this._limit / 2), this._channelManager = V, this._channelManager.subscribeChannelEvent(this._key, { onUpdate: function(F, m, E) {
      var u = F.findIndex(function(b) {
        return b.isIdentical(U.channel);
      });
      u >= 0 && (U._replaceChannelOfCollection(F[u]), U.channel._runIfHandleableWithGroupChannel(function(b) {
        switch (m) {
          case ne.EVENT_CHANNEL_UPDATED:
            var k = !1;
            for (var Q in U._messages)
              if (U._messages[Q].createdAt >= b.messageOffsetTimestamp) {
                k = !0;
                var S = parseInt(Q);
                if (S > 0) {
                  var v = U._messages.splice(0, S);
                  U._removeMessagesFromView(v.map(function(g) {
                    return U.keyOf(g);
                  }), ne.EVENT_MESSAGE_OFFSET_UPDATED);
                }
                break;
              }
            !k && U._messages.length > 0 && U._removeMessagesFromView(U._messages.map(function(g) {
              return U.keyOf(g);
            }), ne.EVENT_MESSAGE_OFFSET_UPDATED);
            break;
          case ne.EVENT_CHANNEL_UNMUTED:
            var G = D.of(U._iid).sdkState, w = E;
            G.userId === w && U._clearCheckMyMutedTimer();
            break;
          case ne.EVENT_CHANNEL_MUTED:
            G = D.of(U._iid).sdkState;
            var y = E;
            G.userId === y && b._myMutedRemainingTime !== -1 && U._startCheckMyMutedTimer(b._myMutedRemainingTime);
            break;
          case ne.EVENT_CHANNEL_LEFT:
            b.isPublic && U._clearCheckMyMutedTimer();
        }
        Ce(function() {
          return M(U, void 0, void 0, function() {
            var g, f;
            return p(this, function(I) {
              return g = this._createChannelEventContext(m), QN(m) && (!((f = this._handler) === null || f === void 0) && f.onChannelUpdated) && this._handler.onChannelUpdated(g, this.channel), [2];
            });
          });
        });
      }), U._postprocessChannelUpdateEvent(F[u], m));
    }, onRemove: function(F, m) {
      var E = F.indexOf(U.channel.url);
      E >= 0 && (U._clearCheckMyMutedTimer(), Ce(function() {
        return M(U, void 0, void 0, function() {
          var u, b;
          return p(this, function(k) {
            return u = this._createChannelEventContext(m), !((b = this._handler) === null || b === void 0) && b.onChannelDeleted && this._handler.onChannelDeleted(u, this.channel.url), [2];
          });
        });
      }), U._postprocessChannelRemoveEvent(F[E]));
    } }), this._channelManager.subscribeMessageEvent(this._key, { onUpdate: function(F, m) {
      var E, u, b = [], k = [];
      try {
        for (var Q = be(F), S = Q.next(); !S.done; S = Q.next()) {
          var v = S.value;
          v.channelUrl === U._channel.url && (U.filter.match(v) ? b.push(v) : k.push(U.keyOf(v)));
        }
      } catch (G) {
        E = { error: G };
      } finally {
        try {
          S && !S.done && (u = Q.return) && u.call(Q);
        } finally {
          if (E)
            throw E.error;
        }
      }
      if (Nr(m)) {
        if (b.length > 0)
          switch (m) {
            case ne.LOCAL_MESSAGE_CANCELED:
            case ne.LOCAL_MESSAGE_RESEND_STARTED:
            case ne.EVENT_MESSAGE_SENT_FAILED:
            case ne.EVENT_MESSAGE_SENT_SUCCESS:
            case ne.EVENT_MESSAGE_UPDATED:
            case ne.EVENT_MESSAGE_THREADINFO_UPDATED:
            case ne.EVENT_MESSAGE_REACTION_UPDATED:
            case ne.EVENT_MESSAGE_FEEDBACK_ADDED:
            case ne.EVENT_MESSAGE_FEEDBACK_UPDATED:
            case ne.EVENT_MESSAGE_FEEDBACK_DELETED:
            case ne.SYNC_MESSAGE_CHANGELOGS:
              U._updateMessagesToView(b, m);
              break;
            case ne.EVENT_MESSAGE_SENT_PENDING:
              U._addMessagesToView(b, m);
              break;
            case ne.EVENT_MESSAGE_RECEIVED:
              U.hasNext || U._addMessagesToView(b, m);
              break;
            case ne.SYNC_MESSAGE_FILL:
              U._addMessagesToView(b, m);
          }
        k.length > 0 && U._removeMessagesFromView(k, m);
      }
      U._postprocessMessageUpdateEvent(F, m);
    }, onRemove: function(F, m) {
      U._removeMessagesFromView(F, m), U._postprocessMessageRemoveEvent(F);
    }, onRemoveUnsent: function(F, m) {
      U._removeUnsentMessageFromView(F, m);
    }, onPollChangeLogUpdate: function(F, m) {
      U._updatePollsToView(F, m);
    }, onPollUpdate: function(F, m) {
      U._applyPollUpdateEventToView(F, m);
    }, onPollVote: function(F, m) {
      U._applyPollVoteEventToView(F, m);
    }, onReactionUpdate: function(F, m) {
      U._applyReactionEventToView(F, m);
    }, onThreadInfoUpdate: function(F, m) {
      U._applyThreadInfoEventToView(F, m);
    } });
    var N = D.of(this._iid), R = N.cacheContext, h = N.dispatcher;
    this._channel._updateMessageCollectionLastAccessedAt();
    var Z = this._createChannelUpdateEventCommand(ne.CHANNEL_LASTACCESSEDAT_UPDATED);
    Z && h.dispatch(Z), !o && this._shouldStartBackgroundSync() && (this._backgroundSync = mD.of(this._iid, this._channel), this._backgroundSync.resume(this._startingPoint)), this._changelogSync = uD.of(this._iid, this._channel, this.changelogIncludeParams), this._changelogSync.resume(), this._pollChangelogSync = pD.of(this._iid, this._channel, this._hasPollMessage.bind(this)), this._pollChangelogSync.resume(), this._prevFill = new ui(this._key, function(F) {
      return M(U, void 0, void 0, function() {
        var m, E, u, b, k, Q, S;
        return p(this, function(v) {
          switch (v.label) {
            case 0:
              return [4, this._getRemoteMessages(F, { prevLimit: this._prevResultLimit, source: ne.SYNC_MESSAGE_FILL, checkingContinuousMessages: R.localCacheEnabled })];
            case 1:
              return m = v.sent(), E = m.messages, u = m.isContinuousMessages, E.length > 0 ? (b = Math.min.apply(Math, ot([], et(E.map(function(G) {
                return G.createdAt;
              })), !1)), this._syncRange.extends(b), u && ((k = this._backgroundSync) === null || k === void 0 || k.range.extends(b)), [2, { hasNext: E.length >= this._prevResultLimit && this.viewTop < b, nextToken: this._syncRange.top }]) : (W.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: this.channel.url, measured_on: "gap_check", event: "cache_fetch", max_db_size: (S = (Q = R.localCacheConfig) === null || Q === void 0 ? void 0 : Q.maxSize) !== null && S !== void 0 ? S : 0, use_local_cache: R.localCacheEnabled, starting_point: 0, message_init_policy: "" } })), [2, { hasNext: !1, nextToken: 0 }]);
          }
        });
      });
    }), this._nextFill = new ui(this._key, function(F) {
      return M(U, void 0, void 0, function() {
        var m, E, u, b, k, Q, S;
        return p(this, function(v) {
          switch (v.label) {
            case 0:
              return [4, this._getRemoteMessages(F, { nextLimit: this._nextResultLimit, source: ne.SYNC_MESSAGE_FILL, checkingContinuousMessages: R.localCacheEnabled })];
            case 1:
              return m = v.sent(), E = m.messages, u = m.isContinuousMessages, E.length > 0 ? (b = Math.max.apply(Math, ot([], et(E.map(function(G) {
                return G.createdAt;
              })), !1)), this._syncRange.extends(b), u && ((k = this._backgroundSync) === null || k === void 0 || k.range.extends(b)), [2, { hasNext: !(E.length >= this._nextResultLimit && this._hasNext) || this.viewBottom > b, nextToken: this._syncRange.bottom }]) : (W.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: this.channel.url, measured_on: "gap_check", event: "cache_fetch", max_db_size: (S = (Q = R.localCacheConfig) === null || Q === void 0 ? void 0 : Q.maxSize) !== null && S !== void 0 ? S : 0, use_local_cache: R.localCacheEnabled, starting_point: 0, message_init_policy: "" } })), [2, { hasNext: !1, nextToken: 0 }]);
          }
        });
      });
    }), this._connectionEventContext = h.on(function(F) {
      if (F instanceof ua)
        switch (F.stateType) {
          case tn.CONNECTED:
            yn(function() {
              return M(U, void 0, void 0, function() {
                return p(this, function(m) {
                  return this._activate(), [2];
                });
              });
            });
            break;
          case tn.LOGOUT:
            U.dispose();
            break;
          default:
            U._clearCheckMyMutedTimer(), U._prevFill.stop(), U._nextFill.stop();
        }
    });
    var W = D.of(this._iid).statLogCollector;
    W.put(new nV({ type: Mn.FEATURE_LOCALCACHE, data: { use_local_cache: R.localCacheEnabled, collection_interface: { message: !0 } } }));
  }
  return e.prototype.keyOf = function(n) {
    return 0;
  }, Object.defineProperty(e.prototype, "changelogIncludeParams", { get: function() {
    return { includeReactions: !0, includeThreadInfo: !0, includeMetaArray: !0, includeParentMessageInfo: !0 };
  }, enumerable: !1, configurable: !0 }), e.prototype._postprocessChannelUpdateEvent = function(n, t) {
  }, e.prototype._postprocessChannelRemoveEvent = function(n) {
  }, e.prototype._postprocessMessageUpdateEvent = function(n, t) {
  }, e.prototype._postprocessMessageRemoveEvent = function(n) {
  }, Object.defineProperty(e.prototype, "channel", { get: function() {
    return this._channel;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "succeededMessages", { get: function() {
    return ot([], et(this._messages), !1);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "failedMessages", { get: function() {
    return this._unsentMessages.filter(function(n) {
      return n.sendingStatus === $t.FAILED;
    });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "pendingMessages", { get: function() {
    return this._unsentMessages.filter(function(n) {
      return n.sendingStatus === $t.PENDING;
    });
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "hasPrevious", { get: function() {
    return this._hasPrevious;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "hasNext", { get: function() {
    return this._hasNext;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "viewTop", { get: function() {
    return Math.min.apply(Math, ot(ot([], et(this._messages.map(function(n) {
      return n.createdAt;
    })), !1), [Number.MAX_SAFE_INTEGER], !1));
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "viewBottom", { get: function() {
    return Math.max.apply(Math, ot(ot([], et(this._messages.map(function(n) {
      return n.createdAt;
    })), !1), [0], !1));
  }, enumerable: !1, configurable: !0 }), e.prototype._activate = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return D.of(this._iid).logger.debug("check huge gap"), this._checkHugeGap(), [4, this._refreshChannel(ne.SYNC_CHANNEL_CHANGELOGS)];
          case 1:
            return n.sent(), [2];
        }
      });
    });
  }, e.prototype._replaceChannelOfCollection = function(n) {
    this._channel.isGroupChannel() ? this._channel = n : this._channel.isFeedChannel() && (this._channel._groupChannel = n._groupChannel);
  }, e.prototype._shouldStartBackgroundSync = function() {
    var n = D.of(this._iid).cacheContext;
    return this.channel.isGroupChannel() ? n.localCacheEnabled && !this.channel.isSuper : n.localCacheEnabled;
  }, e.prototype._createChannelEventContext = function(n) {
    switch (!0) {
      case this.channel.isGroupChannel():
        return new l0(n);
      case this.channel.isFeedChannel():
        return new kD(n);
      default:
        throw new j({ code: nt.WRONG_CHANNEL_TYPE, message: "Wrong channel type" });
    }
  }, e.prototype._createMessageEventContext = function(n) {
    switch (!0) {
      case this.channel.isGroupChannel():
        return new bD(n);
      case this.channel.isFeedChannel():
        return new YD(n);
      default:
        throw new j({ code: nt.WRONG_CHANNEL_TYPE, message: "Wrong channel type" });
    }
  }, e.prototype._createChannelUpdateEventCommand = function(n) {
    switch (!0) {
      case this.channel.isGroupChannel():
        return new Dt({ channels: [this._channel], source: n });
      case this.channel.isFeedChannel():
        return new MD({ channels: [this._channel], source: n });
      default:
        return null;
    }
  }, e.prototype._setBaseMessageCollectionHandler = function(n) {
    this._handler = n;
  }, e.prototype._filterUnderOffsetMessage = function(n) {
    return n;
  }, e.prototype._updateChildMessagesInView = function(n) {
    var t = [];
    return this._messages.forEach(function(l) {
      l instanceof Bl && l.parentMessageId === n.messageId && l.applyParentMessage(n) && t.push(l);
    }), t;
  }, e.prototype._updatePollsToView = function(n, t) {
    var l, a, d = this, r = [];
    try {
      for (var i = be(n), c = i.next(); !c.done; c = i.next()) {
        var V = c.value, s = ls(this._messages, V.messageId);
        if (s >= 0) {
          var o = this._messages[s];
          o.isUserMessage() && o.applyPoll(V), r.push(o);
        }
      }
    } catch (U) {
      l = { error: U };
    } finally {
      try {
        c && !c.done && (a = i.return) && a.call(i);
      } finally {
        if (l)
          throw l.error;
      }
    }
    return r.length > 0 && Nr(t) && Ce(function() {
      return M(d, void 0, void 0, function() {
        var U, N, R;
        return p(this, function(h) {
          return U = this._createMessageEventContext(t), r.length > 0 && ((R = (N = this._handler).onMessagesUpdated) === null || R === void 0 || R.call(N, U, this.channel, r)), [2];
        });
      });
    }), r;
  }, e.prototype._applyPollUpdateEventToView = function(n, t) {
    var l = this, a = ls(this._messages, n.messageId);
    if (a >= 0) {
      var d = this._messages[a];
      d && d.isUserMessage() && d.poll && d.poll.applyPollUpdateEvent(n) && Nr(t) && Ce(function() {
        return M(l, void 0, void 0, function() {
          var r, i, c;
          return p(this, function(V) {
            return r = this._createMessageEventContext(t), (c = (i = this._handler) === null || i === void 0 ? void 0 : i.onMessagesUpdated) === null || c === void 0 || c.call(i, r, this.channel, [d]), [2];
          });
        });
      });
    }
  }, e.prototype._applyPollVoteEventToView = function(n, t) {
    var l = this, a = ls(this._messages, n.messageId);
    if (a >= 0) {
      var d = this._messages[a];
      d && d.isUserMessage() && d.poll && d.poll.applyPollVoteEvent(n) && Nr(t) && Ce(function() {
        return M(l, void 0, void 0, function() {
          var r, i, c;
          return p(this, function(V) {
            return r = this._createMessageEventContext(t), (c = (i = this._handler) === null || i === void 0 ? void 0 : i.onMessagesUpdated) === null || c === void 0 || c.call(i, r, this.channel, [d]), [2];
          });
        });
      });
    }
  }, e.prototype._applyReactionEventToView = function(n, t) {
    var l = this, a = ls(this._messages, n.messageId);
    if (a >= 0) {
      var d = this._messages[a];
      d && (d.isUserMessage() || d.isFileMessage() || d.isMultipleFilesMessage()) && Nr(t) && (d.applyReactionEvent(n), Ce(function() {
        return M(l, void 0, void 0, function() {
          var r, i, c;
          return p(this, function(V) {
            return r = this._createMessageEventContext(t), (c = (i = this._handler) === null || i === void 0 ? void 0 : i.onMessagesUpdated) === null || c === void 0 || c.call(i, r, this.channel, [d]), [2];
          });
        });
      }));
    }
  }, e.prototype._applyThreadInfoEventToView = function(n, t) {
    var l = this, a = ls(this._messages, n.targetMessageId);
    if (a >= 0) {
      var d = this._messages[a];
      d && (d.isUserMessage() || d.isFileMessage() || d.isMultipleFilesMessage()) && Nr(t) && (d.applyThreadInfoUpdateEvent(n), Ce(function() {
        return M(l, void 0, void 0, function() {
          var r, i, c;
          return p(this, function(V) {
            return r = this._createMessageEventContext(t), (c = (i = this._handler) === null || i === void 0 ? void 0 : i.onMessagesUpdated) === null || c === void 0 || c.call(i, r, this.channel, [d]), [2];
          });
        });
      }));
    }
  }, e.prototype._removeMessagesFromView = function(n, t) {
    var l, a, d = this, r = [], i = [], c = function(U) {
      var N = V._messages.findIndex(function(h) {
        return d.keyOf(h) === U;
      });
      if (N >= 0) {
        var R = V._messages[N];
        r.push(V.keyOf(R)), i.push(R), V._messages.splice(N, 1);
      }
    }, V = this;
    try {
      for (var s = be(n), o = s.next(); !o.done; o = s.next())
        c(o.value);
    } catch (U) {
      l = { error: U };
    } finally {
      try {
        o && !o.done && (a = s.return) && a.call(s);
      } finally {
        if (l)
          throw l.error;
      }
    }
    return Nr(t) && i.length > 0 && Ce(function() {
      return M(d, void 0, void 0, function() {
        var U, N, R;
        return p(this, function(h) {
          return U = this._createMessageEventContext(t), (R = (N = this._handler) === null || N === void 0 ? void 0 : N.onMessagesDeleted) === null || R === void 0 || R.call(N, U, this.channel, r, i), [2];
        });
      });
    }), r;
  }, e.prototype._removeUnsentMessageFromView = function(n, t) {
    var l = this._unsentMessages.findIndex(function(a) {
      return a.reqId === n;
    });
    l >= 0 && this._unsentMessages.splice(l, 1);
  }, e.prototype._getLocalMessages = function(n, t) {
    var l = t.prevLimit, a = l === void 0 ? 0 : l, d = t.nextLimit, r = d === void 0 ? 0 : d, i = t.inclusive, c = i === void 0 || i;
    return M(this, void 0, void 0, function() {
      var V, s, o, U, N;
      return p(this, function(R) {
        switch (R.label) {
          case 0:
            return V = [], c ? [4, this._channelManager.getExactlyMatchingMessagesForTokenFromCache(this._channel.url, n, this.filter)] : [3, 2];
          case 1:
            V = R.sent(), R.label = 2;
          case 2:
            return a > 0 ? [4, this._channelManager.getMessagesFromCache(this._channel.url, n, "prev", this.filter, a, !1)] : [3, 4];
          case 3:
            return o = R.sent(), [3, 5];
          case 4:
            o = [], R.label = 5;
          case 5:
            return s = o, r > 0 ? [4, this._channelManager.getMessagesFromCache(this._channel.url, n, "next", this.filter, r, !1)] : [3, 7];
          case 6:
            return N = R.sent(), [3, 8];
          case 7:
            N = [], R.label = 8;
          case 8:
            return U = N, [2, ot(ot(ot([], et(V), !1), et(s), !1), et(U), !1).sort(function(h, Z) {
              return Z.createdAt - h.createdAt;
            })];
        }
      });
    });
  }, e.prototype._getRemoteMessages = function(n, t) {
    var l = t.prevLimit, a = l === void 0 ? 0 : l, d = t.nextLimit, r = d === void 0 ? 0 : d, i = t.source, c = i === void 0 ? ne.REQUEST_MESSAGE : i, V = t.reverse, s = V !== void 0 && V, o = t.checkingHasNext, U = o !== void 0 && o, N = t.checkingContinuousMessages, R = N !== void 0 && N;
    return M(this, void 0, void 0, function() {
      var h, Z;
      return p(this, function(W) {
        switch (W.label) {
          case 0:
            return h = tl.of(this._iid), a > 0 || r > 0 ? [4, h._getMessagesByTimestampForCollection(this._channel.url, this._channel.channelType, n, Ae(x(x(x({}, this.filter), Xu), { isInclusive: !0, reverse: s, prevResultSize: a, nextResultSize: r })), c, U, R)] : [3, 2];
          case 1:
            return Z = W.sent(), [3, 3];
          case 2:
            Z = { messages: [], isContinuousMessages: !1 }, W.label = 3;
          case 3:
            return [2, Z];
        }
      });
    });
  }, e.prototype._checkHugeGap = function() {
    var n, t, l, a, d;
    return M(this, void 0, void 0, function() {
      var r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S, v, G, w, y, g, f = this;
      return p(this, function(I) {
        switch (I.label) {
          case 0:
            return r = D.of(this._iid), i = r.dispatcher, c = r.requestQueue, V = r.cacheContext, s = r.statLogCollector, o = r.logger, this._messages.length > 0 ? (U = this._syncRange.top, N = this.viewTop, R = this._syncRange.bottom, h = this.hasNext ? this.viewBottom : Number.MAX_SAFE_INTEGER, [4, this._channelManager.getCachedMessageCountBetween(this._channel.url, this.filter, N, U)]) : [3, 8];
          case 1:
            return Z = I.sent(), [4, this._channelManager.getCachedMessageCountBetween(this._channel.url, this.filter, R, h)];
          case 2:
            W = I.sent(), I.label = 3;
          case 3:
            return I.trys.push([3, 5, 6, 7]), [4, IR(function() {
              return M(f, void 0, void 0, function() {
                var K, Ue, q, ae, se, le, L, $, ee, O, re, te, Qe, Ye, Se, P, ge, Me = this;
                return p(this, function(We) {
                  switch (We.label) {
                    case 0:
                      return K = new ED(x(x({ channelUrl: this._channel.url, channelType: this._channel.channelType, prevStart: N, prevEnd: U, prevCount: Z, nextStart: R, nextEnd: h, nextCount: W, checkingContinuousMessages: V.localCacheEnabled }, this.filter), Xu)), [4, c.send(K)];
                    case 1:
                      return Ue = We.sent(), q = Ue.as(SD), ae = q.isHugeGap, se = q.prevMessages, le = se === void 0 ? [] : se, L = q.prevHasMore, $ = q.isContinuousPrevMessages, ee = q.nextMessages, O = ee === void 0 ? [] : ee, re = q.nextHasmore, te = q.isContinuousNextMessages, ae ? Ce(function() {
                        return M(Me, void 0, void 0, function() {
                          var De;
                          return p(this, function(Oe) {
                            return !((De = this._handler) === null || De === void 0) && De.onHugeGapDetected && this._handler.onHugeGapDetected(), [2];
                          });
                        });
                      }) : (Qe = this.viewTop, Ye = this.viewBottom, Se = Math.min.apply(Math, ot([Number.MAX_SAFE_INTEGER, Qe], et(le.map(function(De) {
                        return De.createdAt;
                      })), !1)), P = Math.max.apply(Math, ot([0, Ye], et(O.map(function(De) {
                        return De.createdAt;
                      })), !1)), i.dispatch(new En({ messages: le, source: ne.SYNC_MESSAGE_FILL })), i.dispatch(new En({ messages: O, source: ne.SYNC_MESSAGE_FILL })), this._syncRange.extends(Se, P), ($ || te) && ((ge = this._backgroundSync) === null || ge === void 0 || ge.range.extends(Se, P)), L && this._prevFill.start(Se), re && this._nextFill.start(P)), [2];
                  }
                });
              });
            }, 1)];
          case 4:
            return I.sent(), [3, 7];
          case 5:
            return F = I.sent(), o.debug("Failed HugeGap Check ", F), [3, 7];
          case 6:
            return s.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: this.channel.url, measured_on: "gap_check", event: "cache_fetch", max_db_size: (t = (n = V.localCacheConfig) === null || n === void 0 ? void 0 : n.maxSize) !== null && t !== void 0 ? t : 0, use_local_cache: V.localCacheEnabled, starting_point: 0, message_init_policy: "" } })), [7];
          case 7:
            return [3, 13];
          case 8:
            m = Date.now(), I.label = 9;
          case 9:
            return I.trys.push([9, 11, 12, 13]), [4, this._getRemoteMessages(m, { prevLimit: this._prevResultLimit, nextLimit: this._nextResultLimit, source: ne.SYNC_MESSAGE_FILL, checkingHasNext: !0, checkingContinuousMessages: V.localCacheEnabled })];
          case 10:
            if (E = I.sent(), u = E.messages, b = E.isContinuousMessages, k = E.hasNext, u.length > 0) {
              for (Q = u.map(function(K) {
                return K.createdAt;
              }), S = 0, v = 0, G = 0; G < Q.length; G++)
                (w = Q[G]) <= m ? S++ : w >= m && v++;
              this._hasPrevious = S >= this._prevResultLimit, this._hasNext = k ?? v >= this._nextResultLimit, (g = this._syncRange).extends.apply(g, ot([], et(Q), !1)), b && ((l = this._backgroundSync) === null || l === void 0 || l.range.extends(this._syncRange.top, this._syncRange.bottom)), this._addMessagesToView(u, ne.SYNC_MESSAGE_FILL);
            } else
              this._hasPrevious = !1, this._hasNext = !1;
            return [3, 13];
          case 11:
            return (y = I.sent()) instanceof j && y.code === nt.NOT_FOUND_IN_DATABASE && (this._hasPrevious = !1, this._hasNext = !1), [3, 13];
          case 12:
            return s.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: this.channel.url, measured_on: "gap_check", event: "cache_fetch", max_db_size: (d = (a = V.localCacheConfig) === null || a === void 0 ? void 0 : a.maxSize) !== null && d !== void 0 ? d : 0, use_local_cache: V.localCacheEnabled, starting_point: 0, message_init_policy: "" } })), [7];
          case 13:
            return [2];
        }
      });
    });
  }, e.prototype._loadUnsentMessages = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return n = this, [4, this._channelManager.getUnsentMessagesFromCache(this._channel.url, this.filter)];
          case 1:
            return n._unsentMessages = t.sent(), [2];
        }
      });
    });
  }, e.prototype._hasPollMessage = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, this._channelManager.getPollMessagesFromCache(this._channel.url, Date.now() + 6e5, this.filter, 1)];
          case 1:
            return n.sent().length > 0 ? [2, !0] : [2, !1];
        }
      });
    });
  }, e.prototype._refreshChannel = function(n) {
    var t = this;
    yn(function() {
      return M(t, void 0, void 0, function() {
        return p(this, function(l) {
          switch (l.label) {
            case 0:
              return [4, this._channelManager.refreshChannel(this.channel.url, !0, n)];
            case 1:
              return l.sent(), [2];
          }
        });
      });
    });
  }, e.prototype._startCheckMyMutedTimer = function(n) {
    var t = this;
    this._clearCheckMyMutedTimer(), this._checkMyMutedStateTimer = setTimeout(function() {
      return M(t, void 0, void 0, function() {
        var l, a, d = this;
        return p(this, function(r) {
          switch (r.label) {
            case 0:
              this._checkMyMutedStateTimer = void 0, l = !0, r.label = 1;
            case 1:
              return r.trys.push([1, 3, 4, 5]), [4, this._channel.getMyMutedInfo()];
            case 2:
              return a = r.sent(), l = !a.isMuted, [3, 5];
            case 3:
              return r.sent(), l = !0, [3, 5];
            case 4:
              return l && this.channel._runIfHandleableWithGroupChannel(function(i) {
                var c, V;
                i.myMutedState = Od.UNMUTED;
                var s = d._createChannelEventContext(ne.EVENT_CHANNEL_UNMUTED);
                (V = (c = d._handler) === null || c === void 0 ? void 0 : c.onChannelUpdated) === null || V === void 0 || V.call(c, s, d.channel);
              }), [7];
            case 5:
              return [2];
          }
        });
      });
    }, n + 1e3);
  }, e.prototype._clearCheckMyMutedTimer = function() {
    this._checkMyMutedStateTimer && (clearTimeout(this._checkMyMutedStateTimer), this._checkMyMutedStateTimer = void 0);
  }, e.prototype.initialize = function(n) {
    var t = this, l = new QD();
    this._messages = [], this._unsentMessages = [], this._syncRange = new fd({}), this._hasNext = !0, this._hasPrevious = !0, this._refreshChannel(ne.REFRESH_CHANNEL);
    var a = D.of(this._iid), d = a.cacheContext, r = a.statLogCollector;
    return n === n0.CACHE_AND_REPLACE_BY_API && this._getLocalMessages(this._startingPoint, { prevLimit: this._prevResultLimit, nextLimit: this._nextResultLimit }).then(function(i) {
      return M(t, void 0, void 0, function() {
        var c;
        return p(this, function(V) {
          switch (V.label) {
            case 0:
              return c = this._filterUnderOffsetMessage(i), this._addMessagesToView(c, ne.REQUEST_MESSAGE), [4, this._loadUnsentMessages()];
            case 1:
              return V.sent(), l._invokeResponse("local", null, c), [2];
          }
        });
      });
    }).catch(function(i) {
      if (Il(i))
        throw i;
      l._invokeResponse("local", i, null);
    }).finally(function() {
      var i = D.of(t._iid).cacheContext;
      t._getRemoteMessages(t._startingPoint, { prevLimit: t._prevResultLimit, nextLimit: t._nextResultLimit, reverse: !0, checkingHasNext: !0, checkingContinuousMessages: i.localCacheEnabled }).then(function(c) {
        var V, s, o, U, N, R, h = c.messages, Z = c.isContinuousMessages, W = c.hasNext, F = t._filterUnderOffsetMessage(h), m = !0;
        if (t._messages.length === F.length) {
          var E = t._messages.map(function(v) {
            return t.keyOf(v);
          });
          for (var u in F)
            if (!E.includes(t.keyOf(F[u]))) {
              m = !1;
              break;
            }
        } else
          m = !1;
        if (t._messages = [], F.length > 0) {
          var b = F.map(function(v) {
            return v.createdAt;
          }), k = 0, Q = 0;
          for (u = 0; u < b.length; u++) {
            var S = b[u];
            S < t._startingPoint ? k++ : S > t._startingPoint && Q++;
          }
          t._hasPrevious = k >= t._prevResultLimit, t._hasNext = W ?? Q >= t._nextResultLimit, (V = t._syncRange).extends.apply(V, ot([], et(F.map(function(v) {
            return v.createdAt;
          })), !1)), Z && ((s = t._backgroundSync) === null || s === void 0 || s.range.extends(t._syncRange.top, t._syncRange.bottom)), t._addMessagesToView(F, ne.REQUEST_MESSAGE);
        } else
          t._hasPrevious = !1, t._hasNext = !1;
        r.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: t.channel.url, starting_point: t._startingPoint, measured_on: "initial_load", event: m ? "cache_hit" : "cache_miss", max_db_size: (U = (o = i.localCacheConfig) === null || o === void 0 ? void 0 : o.maxSize) !== null && U !== void 0 ? U : 0, message_init_policy: n, use_local_cache: i.localCacheEnabled, collection_id: t._key } })), r.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: t.channel.url, starting_point: t._startingPoint, measured_on: "initial_load", event: "cache_fetch", max_db_size: (R = (N = i.localCacheConfig) === null || N === void 0 ? void 0 : N.maxSize) !== null && R !== void 0 ? R : 0, message_init_policy: n, use_local_cache: i.localCacheEnabled, collection_id: t._key } })), l._invokeResponse("remote", null, F);
      }).catch(function(c) {
        if (Il(c))
          throw c;
        l._invokeResponse("remote", c, null);
      });
    }), r.put(new nV({ type: Mn.FEATURE_LOCALCACHE, data: { use_local_cache: d.localCacheEnabled, collection_interface: { message_init_policy: n } } })), l;
  }, e.prototype.loadPrevious = function() {
    var n, t, l;
    return M(this, void 0, void 0, function() {
      var a, d, r, i, c, V, s, o, U = this;
      return p(this, function(N) {
        switch (N.label) {
          case 0:
            if (this._isDisposed)
              throw new j({ code: nt.COLLECTION_DISPOSED, message: "Collection has been disposed." });
            return a = D.of(this._iid), d = a.cacheContext, r = a.statLogCollector, i = a.logger, this._hasPrevious ? this._isLoadingPrevious ? (i.warn("Messages are already fetching."), [2, []]) : (this._isLoadingPrevious = !0, c = this.viewTop, V = [], [4, yn(function() {
              return M(U, void 0, void 0, function() {
                var R;
                return p(this, function(h) {
                  switch (h.label) {
                    case 0:
                      return R = this._filterUnderOffsetMessage, [4, this._getLocalMessages(c, { prevLimit: this._prevResultLimit, inclusive: !1 })];
                    case 1:
                      return V = R.apply(this, [h.sent()]), [2];
                  }
                });
              });
            })]) : [2, []];
          case 1:
            return N.sent(), s = V.length >= this._prevResultLimit, r.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: this.channel.url, starting_point: this._startingPoint, measured_on: "load_prev", event: d.localCacheEnabled && s ? "cache_hit" : "cache_miss", max_db_size: (t = (n = d.localCacheConfig) === null || n === void 0 ? void 0 : n.maxSize) !== null && t !== void 0 ? t : 0, use_local_cache: d.localCacheEnabled, collection_id: this._key, message_init_policy: "" } })), s && (!((l = this._backgroundSync) === null || l === void 0) && l.isWrappingMessages(V)) ? [3, 3] : (o = !1, [4, yn(function() {
              return M(U, void 0, void 0, function() {
                var R, h, Z, W, F, m, E, u = this;
                return p(this, function(b) {
                  switch (b.label) {
                    case 0:
                      return R = D.of(this._iid).cacheContext, [4, this._getRemoteMessages(c, { prevLimit: this._prevResultLimit, reverse: !0, checkingContinuousMessages: R.localCacheEnabled })];
                    case 1:
                      return h = b.sent(), (V = this._filterUnderOffsetMessage(h.messages)).length > 0 && ((Z = this._syncRange).extends.apply(Z, ot([], et(V.map(function(k) {
                        return k.createdAt;
                      })), !1)), !((W = this._backgroundSync) === null || W === void 0) && W.range.overlap(this._syncRange) && h.isContinuousMessages && (o = !0, (F = this._backgroundSync) === null || F === void 0 || F.range.extends(this._syncRange.top))), V = V.filter(function(k) {
                        return Ea(u._messages, k) < 0;
                      }), this._hasPrevious = V.length >= this._prevResultLimit, o && r.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: this.channel.url, starting_point: this._startingPoint, measured_on: "load_prev", event: "cache_fetch", max_db_size: (E = (m = R.localCacheConfig) === null || m === void 0 ? void 0 : m.maxSize) !== null && E !== void 0 ? E : 0, use_local_cache: R.localCacheEnabled, collection_id: this._key, message_init_policy: "" } })), [2];
                  }
                });
              });
            })]);
          case 2:
            return N.sent(), this._addMessagesToView(V, ne.REQUEST_MESSAGE), [3, 4];
          case 3:
            this._hasPrevious = V.length >= this._prevResultLimit, V.length > 0 && this._addMessagesToView(V, ne.REQUEST_MESSAGE), N.label = 4;
          case 4:
            return this._isLoadingPrevious = !1, [2, V];
        }
      });
    });
  }, e.prototype.loadNext = function() {
    var n, t, l;
    return M(this, void 0, void 0, function() {
      var a, d, r, i, c, V, s, o, U = this;
      return p(this, function(N) {
        switch (N.label) {
          case 0:
            if (this._isDisposed)
              throw new j({ code: nt.COLLECTION_DISPOSED, message: "Collection has been disposed." });
            return a = D.of(this._iid), d = a.cacheContext, r = a.statLogCollector, i = a.logger, this._hasNext ? this._isLoadingNext ? (i.warn("Messages are already fetching."), [2, []]) : (this._isLoadingNext = !0, c = this.viewBottom, V = [], [4, yn(function() {
              return M(U, void 0, void 0, function() {
                var R;
                return p(this, function(h) {
                  switch (h.label) {
                    case 0:
                      return R = this._filterUnderOffsetMessage, [4, this._getLocalMessages(c, { nextLimit: this._nextResultLimit, inclusive: !1 })];
                    case 1:
                      return V = R.apply(this, [h.sent()]), [2];
                  }
                });
              });
            })]) : [2, []];
          case 1:
            return N.sent(), s = V.length >= this._nextResultLimit, r.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: this.channel.url, starting_point: this._startingPoint, measured_on: "load_next", event: d.localCacheEnabled && s ? "cache_hit" : "cache_miss", max_db_size: (t = (n = d.localCacheConfig) === null || n === void 0 ? void 0 : n.maxSize) !== null && t !== void 0 ? t : 0, use_local_cache: d.localCacheEnabled, collection_id: this._key, message_init_policy: "" } })), s && (!((l = this._backgroundSync) === null || l === void 0) && l.isWrappingMessages(V)) ? [3, 3] : (o = !1, [4, yn(function() {
              return M(U, void 0, void 0, function() {
                var R, h, Z, W, F, m, E, u, b = this;
                return p(this, function(k) {
                  switch (k.label) {
                    case 0:
                      return R = D.of(this._iid).cacheContext, [4, this._getRemoteMessages(c, { nextLimit: this._nextResultLimit, reverse: !0, checkingHasNext: !0, checkingContinuousMessages: R.localCacheEnabled })];
                    case 1:
                      return h = k.sent(), (V = this._filterUnderOffsetMessage(h.messages)).length > 0 && ((Z = this._syncRange).extends.apply(Z, ot([], et(V.map(function(Q) {
                        return Q.createdAt;
                      })), !1)), !((W = this._backgroundSync) === null || W === void 0) && W.range.overlap(this._syncRange) && h.isContinuousMessages && (o = !0, (F = this._backgroundSync) === null || F === void 0 || F.range.extends(this._syncRange.bottom))), V = V.filter(function(Q) {
                        return Ea(b._messages, Q) < 0;
                      }), this._hasNext = (m = h.hasNext) !== null && m !== void 0 ? m : V.length >= this._nextResultLimit, o && r.put(new Ml({ type: Mn.FEATURE_LOCALCACHE_EVENT, ts: Date.now(), data: { channel_url: this.channel.url, starting_point: this._startingPoint, measured_on: "load_next", event: "cache_fetch", max_db_size: (u = (E = R.localCacheConfig) === null || E === void 0 ? void 0 : E.maxSize) !== null && u !== void 0 ? u : 0, use_local_cache: R.localCacheEnabled, collection_id: this._key, message_init_policy: "" } })), [2];
                  }
                });
              });
            })]);
          case 2:
            return N.sent(), this._addMessagesToView(V, ne.REQUEST_MESSAGE), [3, 4];
          case 3:
            this._hasNext = V.length >= this._nextResultLimit, V.length > 0 && this._addMessagesToView(V, ne.REQUEST_MESSAGE), N.label = 4;
          case 4:
            return this._isLoadingNext = !1, [2, V];
        }
      });
    });
  }, e.prototype.removeFailedMessage = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            if (this._isDisposed)
              throw new j({ code: nt.COLLECTION_DISPOSED, message: "Collection has been disposed." });
            return [4, this._channelManager.removeFailedMessageFromCache(n)];
          case 1:
            return l.sent(), (t = this._unsentMessages.findIndex(function(a) {
              return a.reqId === n;
            })) > -1 && this._unsentMessages.splice(t, 1), [2];
        }
      });
    });
  }, e.prototype.dispose = function() {
    var n, t, l, a = this;
    if (!this._isDisposed) {
      this._isDisposed = !0;
      var d = D.of(this._iid), r = d.cacheContext, i = d.dispatcher;
      this._messages = [], this._clearCheckMyMutedTimer(), this._channel._runIfHandleableWithGroupChannel(function(c) {
        if (c.myMemberState !== On.NONE) {
          a._channel._updateMessageCollectionLastAccessedAt();
          var V = a._createChannelUpdateEventCommand(ne.CHANNEL_LASTACCESSEDAT_UPDATED);
          V && i.dispatch(V);
        }
      }), r.localCacheEnabled && (this._prevFill.stop(), this._nextFill.stop()), (n = this._backgroundSync) === null || n === void 0 || n.close(), (t = this._changelogSync) === null || t === void 0 || t.close(), (l = this._pollChangelogSync) === null || l === void 0 || l.close(), this._channelManager.unsubscribeChannelEvent(this._key), this._channelManager.unsubscribeMessageEvent(this._key), this._connectionEventContext && this._connectionEventContext.close();
    }
  }, e;
}(), vD = function(e) {
  function n(t, l) {
    return e.call(this, t, x(x({}, l), { channelManager: cl.of(t) })) || this;
  }
  return J(n, e), n.prototype.keyOf = function(t) {
    return t.messageId;
  }, n.prototype.initialize = function(t) {
    var l = this;
    return yn(function() {
      return M(l, void 0, void 0, function() {
        var a;
        return p(this, function(d) {
          switch (d.label) {
            case 0:
              return [4, this.channel.getMyMutedInfo()];
            case 1:
              return (a = d.sent()).isMuted && a.remainingDuration !== -1 && this._startCheckMyMutedTimer(a.remainingDuration), [2];
          }
        });
      });
    }), e.prototype.initialize.call(this, t);
  }, n.prototype.setMessageCollectionHandler = function(t) {
    this._setBaseMessageCollectionHandler(t);
  }, n.prototype._activate = function() {
    return M(this, void 0, void 0, function() {
      var t = this;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, e.prototype._activate.call(this)];
          case 1:
            return l.sent(), [4, yn(function() {
              return M(t, void 0, void 0, function() {
                var a;
                return p(this, function(d) {
                  switch (d.label) {
                    case 0:
                      return [4, this.channel.getMyMutedInfo()];
                    case 1:
                      return (a = d.sent()).isMuted && a.remainingDuration !== -1 && this._startCheckMyMutedTimer(a.remainingDuration), [2];
                  }
                });
              });
            })];
          case 2:
            return l.sent(), [2];
        }
      });
    });
  }, n.prototype._addMessagesToView = function(t, l) {
    var a, d, r = this, i = this._filterUnderOffsetMessage(t), c = [], V = [];
    try {
      for (var s = be(i), o = s.next(); !o.done; o = s.next()) {
        var U = o.value;
        if (l === ne.SYNC_MESSAGE_FILL)
          if (U.messageId > 0) {
            if ((Z = Ea(this._messages, U)) < 0) {
              Ea(this._unsentMessages, U) < 0 && c.push(U);
              var N = uZ(this._messages, U);
              this._messages.splice(N, 0, U);
            }
          } else
            U instanceof wn && (Z = Ea(this._unsentMessages, U)) < 0 && Ea(this._messages, U) < 0 && (this._unsentMessages.push(U), c.push(U));
        else if (U.messageId > 0) {
          if ((Z = Ea(this._messages, U)) < 0) {
            var R = Ea(this._unsentMessages, U);
            R < 0 ? c.push(U) : (this._unsentMessages.splice(R, 1), V.push(U)), N = uZ(this._messages, U), this._messages.splice(N, 0, U);
          } else
            V.push(U), this._messages[Z] = U;
          if (U.updatedAt > 0) {
            var h = this._updateChildMessagesInView(U);
            V.push.apply(V, ot([], et(h), !1));
          }
        } else if (U instanceof wn) {
          var Z;
          (Z = Ea(this._unsentMessages, U)) < 0 ? Ea(this._messages, U) < 0 && (this._unsentMessages.push(U), c.push(U)) : (V.push(U), this._unsentMessages[Z] = U);
        }
      }
    } catch (W) {
      a = { error: W };
    } finally {
      try {
        o && !o.done && (d = s.return) && d.call(s);
      } finally {
        if (a)
          throw a.error;
      }
    }
    Nr(l) && Ce(function() {
      return M(r, void 0, void 0, function() {
        var W, F, m, E, u;
        return p(this, function(b) {
          return W = this._createMessageEventContext(l), c.length > 0 && ((m = (F = this._handler) === null || F === void 0 ? void 0 : F.onMessagesAdded) === null || m === void 0 || m.call(F, W, this.channel, c)), V.length > 0 && ((u = (E = this._handler) === null || E === void 0 ? void 0 : E.onMessagesUpdated) === null || u === void 0 || u.call(E, W, this.channel, V)), [2];
        });
      });
    });
  }, n.prototype._updateMessagesToView = function(t, l) {
    var a, d, r = this, i = [], c = [], V = [];
    try {
      for (var s = be(t), o = s.next(); !o.done; o = s.next()) {
        var U, N = o.value;
        if (N.messageId > 0)
          if ((U = Ea(this._messages, N)) >= 0)
            c.push(N), this._messages[U] = N;
          else {
            var R = Ea(this._unsentMessages, N);
            if (R >= 0) {
              var h = et(this._unsentMessages.splice(R, 1), 1)[0];
              if (this.hasNext && h)
                V.push(h);
              else {
                c.push(N);
                var Z = uZ(this._messages, N);
                this._messages.splice(Z, 0, N);
              }
            } else {
              var W = this._messages.map(function(F) {
                return F.createdAt;
              });
              (N.createdAt < Math.min.apply(Math, ot([], et(W), !1)) && !this._hasPrevious || N.createdAt > Math.max.apply(Math, ot([], et(W), !1)) && !this._hasNext) && i.push(N);
            }
          }
        else
          N instanceof wn && (U = Ea(this._unsentMessages, N)) >= 0 && (c.push(N), this._unsentMessages[U] = N);
      }
    } catch (F) {
      a = { error: F };
    } finally {
      try {
        o && !o.done && (d = s.return) && d.call(s);
      } finally {
        if (a)
          throw a.error;
      }
    }
    return Nr(l) && Ce(function() {
      return M(r, void 0, void 0, function() {
        var F, m, E, u, b;
        return p(this, function(k) {
          return F = this._createMessageEventContext(l), c.length > 0 ? (E = (m = this._handler) === null || m === void 0 ? void 0 : m.onMessagesUpdated) === null || E === void 0 || E.call(m, F, this.channel, c) : V.length > 0 ? (b = (u = this._handler) === null || u === void 0 ? void 0 : u.onMessagesDeleted) === null || b === void 0 || b.call(u, F, this.channel, [], V) : i.length > 0 && this._addMessagesToView(i, l), [2];
        });
      });
    }), c;
  }, n;
}(JD), zD = { coverUrl: void 0, coverImage: void 0, isDistinct: void 0, isPublic: void 0, isDiscoverable: void 0, accessCode: void 0, name: void 0, data: void 0, customType: void 0, operatorUserIds: void 0, messageSurvivalSeconds: void 0 }, xD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.token, r = t.limit, i = t.order, c = t.mutedMemberFilter, V = t.memberStateFilter, s = t.nicknameStartsWithFilter, o = t.operatorFilter;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(vl, "/").concat(encodeURIComponent(a), "/members"), l.params = { token: d, limit: r, order: i, muted_member_filter: c, member_state_filter: V, nickname_startswith: s, operator_filter: o, show_member_is_muted: !0, show_read_receipt: !0, show_delivery_receipt: !0 }, l;
  }
  return J(n, e), n;
}(Te), GD = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    a.members = [];
    var d = l.next, r = l.members;
    return a.token = d, r && r.length > 0 && (a.members = r.map(function(i) {
      return new Ga(t, i);
    })), a;
  }
  return J(n, e), n;
}(ue);
(function(e) {
  e.ALL = "all", e.MUTED = "muted", e.UNMUTED = "unmuted";
})(As || (As = {})), function(e) {
  e.MEMBER_NICKNAME_ALPHABETICAL = "member_nickname_alphabetical", e.OPERATOR_THEN_MEMBER_ALPHABETICAL = "operator_then_member_alphabetical";
}(qs || (qs = {})), function(e) {
  e.ALL = "all", e.JOINED = "joined_only", e.INVITED = "invited_only", e.INVITED_BY_FRIEND = "invited_by_friend", e.INVITED_BY_NON_FRIEND = "invited_by_non_friend";
}($s || ($s = {}));
var yD = function(e) {
  function n(t, l, a) {
    var d, r, i, c, V = this;
    return (V = e.call(this, t, l, Xt.GROUP, a) || this).mutedMemberFilter = As.ALL, V.memberStateFilter = $s.ALL, V.nicknameStartsWithFilter = null, V.operatorFilter = oR.ALL, V.order = qs.MEMBER_NICKNAME_ALPHABETICAL, V.mutedMemberFilter = (d = a.mutedMemberFilter) !== null && d !== void 0 ? d : As.ALL, V.memberStateFilter = (r = a.memberStateFilter) !== null && r !== void 0 ? r : $s.ALL, V.nicknameStartsWithFilter = (i = a.nicknameStartsWithFilter) !== null && i !== void 0 ? i : null, V.order = (c = a.order) !== null && c !== void 0 ? c : qs.MEMBER_NICKNAME_ALPHABETICAL, V;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && Qt(As, this.mutedMemberFilter) && Qt($s, this.memberStateFilter) && (B("string", this.nicknameStartsWithFilter) || this.nicknameStartsWithFilter === null) && Qt(oR, this.operatorFilter) && Qt(qs, this.order);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new xD(Ae(x(x({}, this), { token: this._token }))), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = c.sent(), d = a.as(GD), r = d.members, i = d.token, this._token = i, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar), BD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.userId, r = t.accessCode;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(vl, "/").concat(encodeURIComponent(a), "/accept"), l.params = { user_id: d, access_code: r }, l;
  }
  return J(n, e), n;
}(Te), DD = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.channel = new ja(t, l), a.channel.myMemberState = On.JOINED, a;
  }
  return J(n, e), n;
}(ue), XD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.isDistinct, r = t.isPublic, i = t.isDiscoverable, c = t.coverUrl, V = t.coverImage, s = t.accessCode, o = t.name, U = t.data, N = t.customType, R = t.operatorUserIds, h = t.messageSurvivalSeconds;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(vl, "/").concat(encodeURIComponent(a)), l.params = je({ is_distinct: d, is_public: r, is_discoverable: i, name: o, data: U, custom_type: N, cover_url: c, cover_file: V, access_code: s, operator_ids: R, message_survival_seconds: h }), l;
  }
  return J(n, e), n;
}(Te), OD = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.channel = new ja(t, l), a;
  }
  return J(n, e), n;
}(ue), jD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(vl, "/").concat(encodeURIComponent(a)), l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    return e.call(this, t, l) || this;
  }
  J(n, e);
})(ue);
var HD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(vl, "/").concat(encodeURIComponent(a), "/hide"), l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var fD = function(e) {
  function n(t) {
    var l = t.userId, a = t.channelUrl, d = t.countPreference, r = e.call(this) || this;
    return r.method = he.PUT, r.path = "".concat(It, "/").concat(encodeURIComponent(l), "/count_preference/").concat(encodeURIComponent(a)), r.params = { count_preference: d }, r;
  }
  return J(n, e), n;
}(Te), wD = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.countPreference = l.count_preference, a;
  }
  return J(n, e), n;
}(ue), gD = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(vl, "/").concat(encodeURIComponent(a), "/reset_user_history"), l;
  }
  return J(n, e), n;
}(Te), ID = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this, d = l.ts_message_offset;
    return a.messageOffsetTimestamp = d, a;
  }
  return J(n, e), n;
}(ue), LD = x(x({}, YW), { scheduledAt: void 0, file: void 0, fileUrl: void 0, fileName: void 0, mimeType: void 0, fileSize: void 0, thumbnailSizes: void 0, requireAuth: !1 }), CD = x(x({}, M3), { scheduledAt: void 0 }), KD = function(e) {
  function n(t) {
    var l, a, d = this;
    d = e.call(this) || this;
    var r = [];
    t.mentionType === Jl.USERS && (t.mentionedUserIds ? r = t.mentionedUserIds : t.mentionedUsers && (r = t.mentionedUsers.map(function(s) {
      return s.userId;
    })));
    var i = t.channelType, c = t.channelUrl, V = t.scheduledMessageId;
    return d.method = he.PUT, d.path = "".concat(Lt(i), "/").concat(encodeURIComponent(c), "/scheduled_messages/").concat(encodeURIComponent(V)), d.params = je(Ae({ req_id: t.reqId, scheduled_at: t.scheduledAt, message_type: Mc.FILE, url: t.fileUrl, file_name: t.fileName, file_size: t.fileSize, file_type: t.mimeType, thumbnails: (l = t._thumbnails) === null || l === void 0 ? void 0 : l.map(function(s) {
      return Br.payloadify(s);
    }), custom_type: t.customType, data: t.data, require_auth: t.requireAuth, mention_type: t.mentionType, mentioned_user_ids: r, sorted_metaarray: (a = t.metaArrays) === null || a === void 0 ? void 0 : a.map(function(s) {
      return Ol.payloadify(s);
    }), apple_critical_alert_options: t.appleCriticalAlertOptions ? ad.payloadify(t.appleCriticalAlertOptions) : null, push_option: t.pushNotificationDeliveryOption })), d;
  }
  return J(n, e), n;
}(Te), _D = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.message = new Ln(t, l), a;
  }
  return J(n, e), n;
}(ue), PD = function(e) {
  function n(t) {
    var l, a = this;
    a = e.call(this) || this;
    var d = [];
    t.mentionType === Jl.USERS && (t.mentionedUserIds ? d = t.mentionedUserIds : t.mentionedUsers && (d = t.mentionedUsers.map(function(V) {
      return V.userId;
    })));
    var r = t.channelType, i = t.channelUrl, c = t.scheduledMessageId;
    return a.method = he.PUT, a.path = "".concat(Lt(r), "/").concat(encodeURIComponent(i), "/scheduled_messages/").concat(encodeURIComponent(c)), a.params = je(Ae({ req_id: t.reqId, scheduled_at: t.scheduledAt, message_type: Mc.USER, message: t.message, custom_type: t.customType, data: t.data, mention_type: t.mentionType, mentioned_user_ids: d, sorted_metaarray: (l = t.metaArrays) === null || l === void 0 ? void 0 : l.map(function(V) {
      return Ol.payloadify(V);
    }), apple_critical_alert_options: t.appleCriticalAlertOptions ? ad.payloadify(t.appleCriticalAlertOptions) : null, target_langs: t.translationTargetLanguages, push_option: t.pushNotificationDeliveryOption })), a;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.message = new kl(t, l), a;
  }
  J(n, e);
})(ue);
var AD = function(e) {
  function n(t) {
    var l = e.call(this) || this, a = t.channelType, d = t.channelUrl, r = t.scheduledMessageId;
    return l.method = he.DELETE, l.path = "".concat(Lt(a), "/").concat(encodeURIComponent(d), "/scheduled_messages/").concat(encodeURIComponent(r)), l;
  }
  return J(n, e), n;
}(Te), qD = function(e) {
  function n(t) {
    var l = e.call(this) || this, a = t.channelType, d = t.channelUrl, r = t.scheduledMessageId;
    return l.method = he.POST, l.path = "".concat(Lt(a), "/").concat(encodeURIComponent(d), "/scheduled_messages/").concat(encodeURIComponent(r), "/send_now"), l;
  }
  return J(n, e), n;
}(Te), $D = function(e) {
  function n(t) {
    var l = t.userId, a = t.channelUrl, d = t.pushTriggerOption, r = e.call(this) || this;
    return r.method = he.PUT, r.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push_preference/").concat(encodeURIComponent(a)), r.params = { push_trigger_option: d }, r;
  }
  return J(n, e), n;
}(Te), eX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.pushTriggerOption = l.push_trigger_option, a.enabled = l.enable, a;
  }
  return J(n, e), n;
}(ue), tX = function(e) {
  function n(t) {
    var l = t.userId, a = t.channelUrl, d = e.call(this) || this;
    return d.method = he.GET, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push_preference/").concat(encodeURIComponent(a)), d;
  }
  return J(n, e), n;
}(Te), nX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.pushTriggerOption = l.push_trigger_option, a.enabled = l.enable, a;
  }
  return J(n, e), n;
}(ue), lX = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = e.call(this) || this;
    return r.method = he.POST, r.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(d, "/pin"), r;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    return e.call(this, t, l) || this;
  }
  J(n, e);
})(ue);
var aX = function(e) {
  function n(t) {
    var l = t.channelType, a = t.channelUrl, d = t.messageId, r = e.call(this) || this;
    return r.method = he.DELETE, r.path = "".concat(Lt(l), "/").concat(encodeURIComponent(a), "/messages/").concat(d, "/pin"), r;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    return e.call(this, t, l) || this;
  }
  J(n, e);
})(ue);
var Ja, yl, dX = function(e) {
  function n(t, l) {
    var a = e.call(this, t) || this;
    return a.message = null, a.message = Hl(t, l.message), a;
  }
  return J(n, e), n;
}(ml), rX = function(e) {
  function n(t) {
    var l = this, a = t.channelType, d = t.channelUrl, r = t.limit, i = t.token, c = t.includeReactions, V = t.includeMetaArray, s = t.includeParentMessageInfo, o = t.includeThreadInfo, U = t.includePollDetails;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(Lt(a), "/").concat(encodeURIComponent(d), "/pinned_messages"), l.params = je({ limit: r, token: i, include_reactions: c, with_sorted_meta_array: V, include_thread_info: o, include_parent_message_info: s, include_poll_details: U }), l;
  }
  return J(n, e), n;
}(Te), iX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this, d = l.pinned_messages, r = l.has_more, i = l.next;
    return a.pinnedMessages = d.map(function(c) {
      return new dX(t, c);
    }), a.hasMore = r, a.token = i, a;
  }
  return J(n, e), n;
}(ue), VX = function(e) {
  function n(t, l, a, d) {
    var r = e.call(this, t, l, a, d) || this;
    return r.includeMetaArray = d.includeMetaArray, r.includeReactions = d.includeReactions, r.includeParentMessageInfo = d.includeParentMessageInfo, r.includeThreadInfo = d.includeThreadInfo, r.includePollDetails = d.includePollDetails, r;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && B("boolean", this.includeMetaArray, !0) && B("boolean", this.includeReactions, !0) && B("boolean", this.includeParentMessageInfo, !0) && B("boolean", this.includeThreadInfo, !0) && B("boolean", this.includePollDetails, !0);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new rX(x(x({}, this), { token: this._token })), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = V.sent(), d = a.as(iX), r = d.pinnedMessages, i = d.hasMore, c = d.token, this._token = c, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar), cX = function(e) {
  function n(t, l) {
    var a, d, r = this;
    return (r = e.call(this, t) || this).channelUrl = (a = l.channel_url) !== null && a !== void 0 ? a : "", r.channelType = (d = l.channel_type) !== null && d !== void 0 ? d : Xt.GROUP, r.member = new xt(r._iid, l.user), r.deliveryAt = l.ts, r;
  }
  return J(n, e), n;
}(ml);
(function(e) {
  e.ALL = "all", e.UNREAD_MESSAGE_COUNT_ONLY = "unread_message_count_only", e.UNREAD_MENTION_COUNT_ONLY = "unread_mention_count_only", e.OFF = "off";
})(Ja || (Ja = {})), function(e) {
  e.UNHIDDEN = "unhidden", e.HIDDEN_ALLOW_AUTO_UNHIDE = "hidden_allow_auto_unhide", e.HIDDEN_PREVENT_AUTO_UNHIDE = "hidden_prevent_auto_unhide";
}(yl || (yl = {}));
var ja = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S = this;
    return (S = e.call(this, t, l) || this)._unreadMemberStateMap = /* @__PURE__ */ new Map(), S._undeliveredMemberStateMap = /* @__PURE__ */ new Map(), S._typingStatus = /* @__PURE__ */ new Map(), S._lastMemberCountUpdated = 0, S._typingStarted = 0, S._typingEnded = 0, S.isDistinct = !1, S.isSuper = !1, S.isBroadcast = !1, S.isExclusive = !1, S.isPublic = !1, S.isDiscoverable = !0, S.isChatNotification = !1, S.isAccessCodeRequired = !1, S.isPushEnabled = !1, S.unreadMessageCount = 0, S.unreadMentionCount = 0, S.totalUnreadReplyCount = 0, S.members = [], S.memberCount = 0, S.joinedMemberCount = 0, S.hiddenState = yl.UNHIDDEN, S.lastMessage = null, S.messageOffsetTimestamp = 0, S.messageSurvivalSeconds = -1, S.myMemberState = On.NONE, S.myRole = ed.NONE, S.myMutedState = Od.UNMUTED, S.myLastRead = 0, S.myCountPreference = Ja.ALL, S.myPushTriggerOption = $i.DEFAULT, S.inviter = null, S.invitedAt = 0, S.joinedAt = 0, S.pinnedMessageIds = [], S.lastPinnedMessage = null, S._pinnedMessagesUpdatedAt = 0, S._myMutedRemainingTime = -1, S.channelType = Xt.GROUP, S.isDistinct = (d = l.is_distinct) !== null && d !== void 0 && d, S.isSuper = (r = l.is_super) !== null && r !== void 0 && r, S.isBroadcast = (i = l.is_broadcast) !== null && i !== void 0 && i, S.isExclusive = (c = l.is_exclusive) !== null && c !== void 0 && c, S.isPublic = (V = l.is_public) !== null && V !== void 0 && V, S.isDiscoverable = (s = l.is_discoverable) !== null && s !== void 0 ? s : S.isPublic, S.isChatNotification = (o = l.is_chat_notification) !== null && o !== void 0 && o, S.isAccessCodeRequired = (U = l.is_access_code_required) !== null && U !== void 0 && U, S.isPushEnabled = (N = l.is_push_enabled) !== null && N !== void 0 && N, Array.isArray(l.members) && (a = S.members).push.apply(a, ot([], et(l.members.map(function(v) {
      return new Ga(S._iid, v);
    })), !1)), S.memberCount = (R = l.member_count) !== null && R !== void 0 ? R : 0, S.joinedMemberCount = (h = l.joined_member_count) !== null && h !== void 0 ? h : 0, S.hiddenState = Qt(yl, l.hidden_state) ? l.hidden_state : yl.UNHIDDEN, S.messageOffsetTimestamp = (Z = l.ts_message_offset) !== null && Z !== void 0 ? Z : 0, S.messageSurvivalSeconds = (W = l.message_survival_seconds) !== null && W !== void 0 ? W : -1, S.lastMessage = l.last_message ? Hl(S._iid, x({ channel_type: S.channelType }, l.last_message)) : null, l.read_receipt && Object.keys(l.read_receipt).forEach(function(v) {
      B("number", l.read_receipt[v]) && S._updateUnreadMemberState(v, l.read_receipt[v]);
    }), l.delivery_receipt && Object.keys(l.delivery_receipt).forEach(function(v) {
      B("number", l.delivery_receipt[v]) && S._updateUndeliveredMemberState(v, l.delivery_receipt[v]);
    }), S.myMemberState = Qt(On, l.member_state) ? l.member_state : On.NONE, S.myRole = Qt(ed, l.my_role) ? l.my_role : ed.NONE, Qt(Od, l.is_muted) ? S.myMutedState = l.is_muted : B("boolean", l.is_muted) ? S.myMutedState = l.is_muted ? Od.MUTED : Od.UNMUTED : S.myMutedState = Od.UNMUTED, S.myCountPreference = Qt(Ja, l.count_preference) ? l.count_preference : Ja.ALL, S.myPushTriggerOption = Qt($i, l.push_trigger_option) ? l.push_trigger_option : $i.ALL, S.myLastRead = (F = l.user_last_read) !== null && F !== void 0 ? F : 0, S.inviter = l.inviter ? new xt(S._iid, l.inviter) : null, S.invitedAt = (m = l.invited_at) !== null && m !== void 0 ? m : 0, S.joinedAt = (E = l.joined_ts) !== null && E !== void 0 ? E : 0, S._updateUnreadCount((u = l.unread_message_count) !== null && u !== void 0 ? u : 0, (b = l.unread_mention_count) !== null && b !== void 0 ? b : 0), S.totalUnreadReplyCount = (k = l.total_unread_thread_message_count) !== null && k !== void 0 ? k : 0, S.pinnedMessageIds = (Q = l.pinned_message_ids) !== null && Q !== void 0 ? Q : [], S.lastPinnedMessage = l.latest_pinned_message ? Hl(S._iid, x({ channel_type: S.channelType }, l.latest_pinned_message)) : null, S;
  }
  return J(n, e), Object.defineProperty(n.prototype, "isHidden", { get: function() {
    return this.hiddenState !== yl.UNHIDDEN;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isTyping", { get: function() {
    return this._typingStatus.size > 0;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "cachedUnreadMemberState", { get: function() {
    var t, l, a = {};
    try {
      for (var d = be(this._unreadMemberStateMap), r = d.next(); !r.done; r = d.next()) {
        var i = et(r.value, 2), c = i[0], V = i[1];
        a[c] = V;
      }
    } catch (s) {
      t = { error: s };
    } finally {
      try {
        r && !r.done && (l = d.return) && l.call(d);
      } finally {
        if (t)
          throw t.error;
      }
    }
    return a;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "cachedUndeliveredMemberState", { get: function() {
    var t, l, a = {};
    try {
      for (var d = be(this._undeliveredMemberStateMap), r = d.next(); !r.done; r = d.next()) {
        var i = et(r.value, 2), c = i[0], V = i[1];
        a[c] = V;
      }
    } catch (s) {
      t = { error: s };
    } finally {
      try {
        r && !r.done && (l = d.return) && l.call(d);
      } finally {
        if (t)
          throw t.error;
      }
    }
    return a;
  }, enumerable: !1, configurable: !0 }), n.payloadify = function(t) {
    return je(Ae(x(x({}, e.payloadify.call(this, t)), { is_access_code_required: t.isAccessCodeRequired, is_distinct: t.isDistinct, is_super: t.isSuper, is_broadcast: t.isBroadcast, is_exclusive: t.isExclusive, is_public: t.isPublic, is_discoverable: t.isDiscoverable, is_muted: t.myMutedState, is_push_enabled: t.isPushEnabled, unread_message_count: t.unreadMessageCount, unread_mention_count: t.unreadMentionCount, total_unread_thread_message_count: t.totalUnreadReplyCount, push_trigger_option: t.myPushTriggerOption, count_preference: t.myCountPreference, hidden_state: t.hiddenState, member_count: t.memberCount, joined_member_count: t.joinedMemberCount, member_state: t.myMemberState, my_role: t.myRole, user_last_read: t.myLastRead, ts_message_offset: t.messageOffsetTimestamp, message_survival_seconds: t.messageSurvivalSeconds, read_receipt: t.cachedUnreadMemberState, delivery_receipt: t.cachedUndeliveredMemberState, members: t.members.map(function(l) {
      return Ga.payloadify(l);
    }), last_message: t.lastMessage ? Uu(t.lastMessage) : null, inviter: t.inviter ? xt.payloadify(t.inviter) : null, invited_at: t.invitedAt, joined_ts: t.joinedAt, pinned_message_ids: t.pinnedMessageIds, latest_pinned_message: t.lastPinnedMessage ? Uu(t.lastPinnedMessage) : null })));
  }, n.prototype._shouldUpdateLastMessageWith = function(t) {
    return !(t instanceof wn && t.parentMessageId > 0 && !t.replyToChannel) && !t.silent && (!this.lastMessage || this.lastMessage.createdAt < t.createdAt || this.lastMessage.createdAt === t.createdAt && this.lastMessage.messageId === t.messageId && this.lastMessage.updatedAt < t.updatedAt);
  }, n.prototype._tryUpdateLastMessageAndCallEvents = function(t, l) {
    var a = D.of(this._iid).dispatcher, d = cl.of(this._iid);
    this._updateLastMessage(l), d.handlers.map(function(r) {
      r.onChannelChanged && r.onChannelChanged(t);
    }), a.dispatch(new Dt({ channels: [t], source: ne.EVENT_MESSAGE_SENT }));
  }, n.prototype._updateLastMessage = function(t) {
    return !!this._shouldUpdateLastMessageWith(t) && (this.lastMessage = t, !0);
  }, n.prototype._updateUnreadCount = function(t, l) {
    if (typeof t == "number" && t >= 0)
      if (this.myCountPreference === Ja.ALL || this.myCountPreference === Ja.UNREAD_MESSAGE_COUNT_ONLY)
        if (this.isExclusive || this.isSuper || this.isBroadcast) {
          var a = D.of(this._iid).maxSuperGroupChannelUnreadCount;
          this.unreadMessageCount = a && t >= a ? a : t;
        } else
          this.unreadMessageCount = t;
      else
        this.unreadMessageCount = 0;
    else
      this.unreadMessageCount = 0;
    typeof l == "number" && l >= 0 && (this.myCountPreference === Ja.ALL || this.myCountPreference === Ja.UNREAD_MENTION_COUNT_ONLY) ? this.unreadMentionCount = l : this.unreadMentionCount = 0;
  }, n.prototype._updateUnreadMemberState = function(t, l) {
    var a = this._unreadMemberStateMap.get(t);
    return (!a || a < l) && (this._unreadMemberStateMap.set(t, l), D.of(this._iid).sdkState.userId === t && (this.myLastRead = l), !0);
  }, n.prototype._updateUndeliveredMemberState = function(t, l) {
    var a = this._undeliveredMemberStateMap.get(t);
    return (!a || a < l) && (this._undeliveredMemberStateMap.set(t, l), !0);
  }, n.prototype._updateTypingStatus = function(t, l) {
    l === void 0 && (l = (/* @__PURE__ */ new Date()).getTime()), l > 0 ? this._typingStatus.set(t.userId, { user: t, ts: l }) : this._typingStatus.delete(t.userId);
  }, n.prototype._clearTypingStatus = function() {
    this._typingStatus.clear(), this._typingStarted = 0, this._typingEnded = 0;
  }, n.prototype._setLatestMemberCount = function(t, l, a) {
    var d = !1;
    return a >= this._lastMemberCountUpdated && (this._lastMemberCountUpdated = a, d = t !== this.memberCount || l !== this.joinedMemberCount, this.memberCount = t, this.joinedMemberCount = l), d;
  }, n.prototype.isReadMessage = function(t) {
    var l = D.of(this._iid).sdkState, a = this._unreadMemberStateMap.get(l.userId);
    return !!a && a >= t.createdAt;
  }, n.prototype.serialize = function() {
    var t = this;
    return gc(this, function(l) {
      l.cachedUnreadMemberState = t.cachedUnreadMemberState, l.cachedUndeliveredMemberState = t.cachedUndeliveredMemberState;
    });
  }, n.prototype.createMessageCollection = function(t) {
    return t === void 0 && (t = {}), new vD(this._iid, x(x({}, t), { channel: this }));
  }, n.prototype.createMemberListQuery = function(t) {
    return t === void 0 && (t = {}), new yD(this._iid, this.url, t);
  }, n.prototype.createThreadedParentMessageListQuery = function(t) {
    return t === void 0 && (t = {}), new EB(this._iid, this.url, this.channelType, t);
  }, n.prototype.createPinnedMessageListQuery = function(t) {
    return t === void 0 && (t = {}), new VX(this._iid, this.url, this.channelType, t);
  }, n.prototype.addMember = function(t, l) {
    if (l === void 0 && (l = 0), !this.isExclusive && !this.isSuper && !this.isBroadcast) {
      var a = this.members.findIndex(function(r) {
        return r.userId === t.userId;
      });
      if (a > -1) {
        var d = this.members[a];
        d.state === On.JOINED && (t.state = d.state), this.members.splice(a, 1), this.memberCount--;
      }
      this.members.push(t), this.memberCount++, this._updateUnreadMemberState(t.userId, l), this._updateUndeliveredMemberState(t.userId, l);
    }
  }, n.prototype.removeMember = function(t) {
    if (!this.isExclusive && !this.isSuper && !this.isBroadcast) {
      var l = t instanceof Ga ? t.userId : t, a = this.members.findIndex(function(d) {
        return d.userId === l;
      });
      if (a > -1)
        return this.members.splice(a, 1), this.memberCount--, !0;
    }
    return !1;
  }, n.prototype.getUnreadMemberCount = function(t) {
    var l, a;
    if (t instanceof wn && !this.isExclusive && !this.isSuper && !this.isBroadcast) {
      var d = D.of(this._iid).sdkState, r = t.createdAt, i = 0;
      try {
        for (var c = be(this.members), V = c.next(); !V.done; V = c.next()) {
          var s = V.value;
          d.userId !== s.userId && s.state === On.JOINED && t.sender.userId !== s.userId && (this.cachedUnreadMemberState[s.userId] || 0) < r && i++;
        }
      } catch (o) {
        l = { error: o };
      } finally {
        try {
          V && !V.done && (a = c.return) && a.call(c);
        } finally {
          if (l)
            throw l.error;
        }
      }
      return i;
    }
    return 0;
  }, n.prototype.getUndeliveredMemberCount = function(t) {
    var l, a;
    if (t instanceof wn && !this.isExclusive && !this.isSuper && !this.isBroadcast) {
      var d = D.of(this._iid).sdkState, r = t.createdAt, i = 0;
      try {
        for (var c = be(this.members), V = c.next(); !V.done; V = c.next()) {
          var s = V.value;
          d.userId !== s.userId && s.state === On.JOINED && t.sender.userId !== s.userId && (this.cachedUndeliveredMemberState[s.userId] || 0) < r && i++;
        }
      } catch (o) {
        l = { error: o };
      } finally {
        try {
          V && !V.done && (a = c.return) && a.call(c);
        } finally {
          if (l)
            throw l.error;
        }
      }
      return i;
    }
    return 0;
  }, n.prototype.getReadMembers = function(t, l) {
    var a = this;
    l === void 0 && (l = !1);
    var d = D.of(this._iid).sdkState;
    if (!d.userId || this.isExclusive || this.isSuper || this.isBroadcast)
      return [];
    var r = t instanceof wn ? t.sender : null, i = [];
    return this.members.forEach(function(c) {
      if (l || c.userId !== d.userId && c.userId !== (r == null ? void 0 : r.userId)) {
        var V = a._unreadMemberStateMap.get(c.userId);
        V && V >= t.createdAt && i.push(c);
      }
    }), i;
  }, n.prototype.getUnreadMembers = function(t, l) {
    var a = this;
    l === void 0 && (l = !1);
    var d = D.of(this._iid).sdkState;
    if (!d.userId || this.isExclusive || this.isSuper || this.isBroadcast)
      return [];
    var r = t instanceof wn ? t.sender : null, i = [];
    return this.members.forEach(function(c) {
      if (l || c.userId !== d.userId && c.userId !== (r == null ? void 0 : r.userId)) {
        var V = a._unreadMemberStateMap.get(c.userId);
        V && V < t.createdAt && i.push(c);
      }
    }), i;
  }, n.prototype.getReadStatus = function(t) {
    var l = this;
    t === void 0 && (t = !1);
    var a = D.of(this._iid).sdkState;
    if (!a.userId || this.isExclusive || this.isSuper || this.isBroadcast)
      return null;
    var d = {};
    return this.members.forEach(function(r) {
      if (t || r.userId !== a.userId) {
        var i = l._unreadMemberStateMap.get(r.userId);
        d[r.userId] = new h3(l._iid, { channel_url: l.url, channel_type: l.channelType, user: Ga.payloadify(r), ts: i ?? 0 });
      }
    }), d;
  }, n.prototype.getDeliveryStatus = function(t) {
    var l = this;
    t === void 0 && (t = !0);
    var a = D.of(this._iid).sdkState;
    if (!a.userId || this.isExclusive || this.isSuper || this.isBroadcast)
      return null;
    var d = {};
    return this.members.forEach(function(r) {
      if (t || r.userId !== a.userId) {
        var i = l._undeliveredMemberStateMap.get(r.userId);
        d[r.userId] = new cX(l._iid, { channel_url: l.url, channel_type: l.channelType, user: Ga.payloadify(r), ts: i ?? 0 });
      }
    }), d;
  }, n.prototype.getTypingUsers = function() {
    var t = [];
    return this._typingStatus.forEach(function(l) {
      var a = l.user;
      t.push(a);
    }), t;
  }, n.prototype.invalidateTypingStatus = function() {
    var t = this, l = D.of(this._iid).typingIndicatorInvalidateTime, a = Date.now(), d = !1;
    return this._typingStatus.forEach(function(r, i) {
      var c = r.ts;
      a - c >= l && (t._typingStatus.delete(i), d = !0);
    }), d;
  }, n.prototype.refresh = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return [2, this._refresh()];
      });
    });
  }, n.prototype._refresh = function(t) {
    return t === void 0 && (t = !1), M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return l = D.of(this._iid), a = l.requestQueue, d = l.dispatcher, r = new $T({ channelUrl: this.url }), [4, a.send(r)];
          case 1:
            return i = V.sent(), c = i.as(e0).channel, this._update(c), t || d.dispatch(new Dt({ channels: [c], source: ne.REFRESH_CHANNEL })), [2, this];
        }
      });
    });
  }, n.prototype.freeze = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, e.prototype.freeze.call(this)];
          case 1:
            return t.sent(), D.of(this._iid).dispatcher.dispatch(new Dt({ channels: [this], source: ne.EVENT_CHANNEL_FROZEN, isWebSocketEventComing: !0 })), [2];
        }
      });
    });
  }, n.prototype.unfreeze = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, e.prototype.unfreeze.call(this)];
          case 1:
            return t.sent(), D.of(this._iid).dispatcher.dispatch(new Dt({ channels: [this], source: ne.EVENT_CHANNEL_UNFROZEN, isWebSocketEventComing: !0 })), [2];
        }
      });
    });
  }, n.prototype.updateChannel = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return l = x(x({}, zD), t), Ze(function(o) {
              return B("string", o.coverUrl, !0) && (Nl(o.coverImage) || B("string", o.coverImage, !0)) && B("boolean", o.isDistinct, !0) && B("boolean", o.isPublic, !0) && B("boolean", o.isDiscoverable, !0) && B("string", o.accessCode, !0) && B("string", o.name, !0) && B("string", o.data, !0) && B("string", o.customType, !0) && Jt("string", o.operatorUserIds, !0) && B("number", o.messageSurvivalSeconds, !0);
            }(l)).throw(j.invalidParameters), a = D.of(this._iid), d = a.dispatcher, r = a.requestQueue, i = new XD(x({ channelUrl: this.url }, l)), [4, r.send(i)];
          case 1:
            return c = s.sent(), V = c.as(OD).channel, this._update(V), d.dispatch(new Dt({ channels: [V], source: ne.EVENT_CHANNEL_UPDATED, isWebSocketEventComing: !0 })), [2, this];
        }
      });
    });
  }, n.prototype.invite = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return Ze(t.every(function(a) {
          return a instanceof xt;
        })).throw(j.invalidParameters), [2, this.inviteWithUserIds(t.map(function(a) {
          return a.userId;
        }))];
      });
    });
  }, n.prototype.inviteWithUserIds = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return Ze(Jt("string", t)).throw(j.invalidParameters), l = D.of(this._iid), a = l.dispatcher, d = l.requestQueue, r = new aD({ channelUrl: this.url, userIds: t }), [4, d.send(r)];
          case 1:
            return i = V.sent(), c = i.as(dD).channel, this._update(c), a.dispatch(new Dt({ channels: [c], source: ne.EVENT_CHANNEL_INVITED, isWebSocketEventComing: !0 })), [2, this];
        }
      });
    });
  }, n.prototype.join = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return Ze(B("string", t, !0)).throw(j.invalidParameters), l = D.of(this._iid), a = l.dispatcher, d = l.sdkState, r = l.requestQueue, i = new $B({ channelUrl: this.url, userId: d.userId, accessCode: t }), [4, r.send(i)];
          case 1:
            return c = s.sent(), (V = c.as(eD).channel).myMemberState = this.myMemberState = On.JOINED, this._update(V), a.dispatch(new Dt({ channels: [V], source: ne.EVENT_CHANNEL_JOINED, isWebSocketEventComing: !0 })), [2, this];
        }
      });
    });
  }, n.prototype.leave = function(t) {
    return t === void 0 && (t = !1), M(this, void 0, void 0, function() {
      var l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return l = D.of(this._iid), a = l.sdkState, d = l.requestQueue, r = new nD({ channelUrl: this.url, userId: a.userId, shouldRemoveOperatorStatus: t }), [4, d.send(r)];
          case 1:
            return i.sent(), this.myMemberState = On.NONE, [2];
        }
      });
    });
  }, n.prototype.acceptInvitation = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return Ze(B("string", t, !0)).throw(j.invalidParameters), l = D.of(this._iid), a = l.dispatcher, d = l.sdkState, r = l.requestQueue, i = new BD({ channelUrl: this.url, userId: d.userId, accessCode: t }), [4, r.send(i)];
          case 1:
            return c = s.sent(), (V = c.as(DD).channel).myMemberState = this.myMemberState = On.JOINED, this._update(V), a.dispatch(new Dt({ channels: [V], source: ne.EVENT_CHANNEL_ACCEPTED_INVITE, isWebSocketEventComing: !0 })), [2, this];
        }
      });
    });
  }, n.prototype.declineInvitation = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new iD({ channelUrl: this.url, userId: l.userId }), [4, a.send(d)];
          case 1:
            return r.sent(), this.myMemberState = On.NONE, [2, this];
        }
      });
    });
  }, n.prototype.sendUserMessage = function(t) {
    var l = this, a = new oa(), d = D.of(this._iid).dispatcher, r = bs.of(this._iid);
    return e.prototype.sendUserMessage.call(this, t).onPending(function(i) {
      r.completeCurrentAndProcessNextAutoResend(i), a._trigger(i);
    }).onFailed(function(i, c) {
      c && r.completeCurrentAndProcessNextAutoResend(c), a._triggerFailed(i, c);
    }).onSucceeded(function(i) {
      l.hiddenState === yl.HIDDEN_ALLOW_AUTO_UNHIDE && (l.hiddenState = yl.UNHIDDEN), r.completeCurrentAndProcessNextAutoResend(i), l._updateLastMessage(i), cl.of(l._iid).handlers.map(function(c) {
        c.onChannelChanged && c.onChannelChanged(l);
      }), d.dispatch(new Dt({ channels: [l], source: ne.EVENT_MESSAGE_SENT })), a._trigger(i);
    }), a;
  }, n.prototype.updateUserMessage = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i, c = this;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return a = D.of(this._iid).dispatcher, [4, e.prototype.updateUserMessage.call(this, t, l)];
          case 1:
            return d = V.sent(), r = this._updateLastMessage(d), i = !1, this.lastPinnedMessage && this.lastPinnedMessage.messageId === d.messageId && (this.lastPinnedMessage = d, r = !0, i = !0), r && (cl.of(this._iid).handlers.map(function(s) {
              s.onChannelChanged && s.onChannelChanged(c);
            }), a.dispatch(new Dt({ channels: [this], source: i ? ne.EVENT_PINNED_MESSAGE_UPDATED : ne.EVENT_MESSAGE_UPDATED }))), i && cl.of(this._iid).handlers.map(function(s) {
              s.onPinnedMessageUpdated && s.onPinnedMessageUpdated(c);
            }), a.dispatch(new En({ messages: [d], source: ne.EVENT_MESSAGE_UPDATED })), [2, d];
        }
      });
    });
  }, n.prototype._autoResendUserMessage = function(t) {
    var l = this, a = new oa(), d = D.of(this._iid).dispatcher, r = bs.of(this._iid);
    return e.prototype._autoResendUserMessage.call(this, t).onPending(function(i) {
      r.completeCurrentAndProcessNextAutoResend(i), a._trigger(i);
    }).onFailed(function(i, c) {
      r.completeCurrentAndProcessNextAutoResend(c), a._triggerFailed(i, c);
    }).onSucceeded(function(i) {
      var c = cl.of(l._iid);
      r.completeCurrentAndProcessNextAutoResend(i), l._updateLastMessage(i), c.handlers.map(function(V) {
        V.onChannelChanged && V.onChannelChanged(l);
      }), d.dispatch(new Dt({ channels: [l], source: ne.EVENT_MESSAGE_SENT })), a._trigger(i);
    }), a;
  }, n.prototype.sendFileMessage = function(t) {
    var l = this, a = new oa(), d = D.of(this._iid).dispatcher, r = bs.of(this._iid);
    return e.prototype.sendFileMessage.call(this, t).onPending(function(i) {
      r.completeCurrentAndProcessNextAutoResend(i), a._trigger(i);
    }).onFailed(function(i, c) {
      c && r.completeCurrentAndProcessNextAutoResend(c), a._triggerFailed(i, c);
    }).onSucceeded(function(i) {
      var c = cl.of(l._iid);
      r.completeCurrentAndProcessNextAutoResend(i), l._updateLastMessage(i), c.handlers.map(function(V) {
        V.onChannelChanged && V.onChannelChanged(l);
      }), d.dispatch(new Dt({ channels: [l], source: ne.EVENT_MESSAGE_SENT })), a._trigger(i);
    }), a;
  }, n.prototype.sendMultipleFilesMessage = function(t) {
    var l = this, a = new SN(), d = D.of(this._iid).dispatcher;
    return e.prototype.sendMultipleFilesMessage.call(this, t).onPending(function(r) {
      a._trigger(r);
    }).onFailed(function(r, i) {
      a._triggerFailed(r, i);
    }).onSucceeded(function(r) {
      var i = cl.of(l._iid);
      l._updateLastMessage(r), i.handlers.map(function(c) {
        c.onChannelChanged && c.onChannelChanged(l);
      }), d.dispatch(new Dt({ channels: [l], source: ne.EVENT_MESSAGE_SENT })), a._trigger(r);
    }).onFileUploaded(function(r, i, c, V) {
      a._triggerOnFileUploaded(r, i, c, V);
    }), a;
  }, n.prototype.updateFileMessage = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i, c = this;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return a = D.of(this._iid).dispatcher, [4, e.prototype.updateFileMessage.call(this, t, l)];
          case 1:
            return d = V.sent(), r = this._updateLastMessage(d), i = !1, this.lastPinnedMessage && this.lastPinnedMessage.messageId === d.messageId && (this.lastPinnedMessage = d, r = !0, i = !0), r && (cl.of(this._iid).handlers.map(function(s) {
              s.onChannelChanged && s.onChannelChanged(c);
            }), a.dispatch(new Dt({ channels: [this], source: i ? ne.EVENT_PINNED_MESSAGE_UPDATED : ne.EVENT_MESSAGE_UPDATED }))), i && cl.of(this._iid).handlers.map(function(s) {
              s.onPinnedMessageUpdated && s.onPinnedMessageUpdated(c);
            }), a.dispatch(new En({ messages: [d], source: ne.EVENT_MESSAGE_UPDATED })), [2, d];
        }
      });
    });
  }, n.prototype._autoResendFileMessage = function(t) {
    var l = this, a = new oa(), d = D.of(this._iid).dispatcher, r = bs.of(this._iid);
    return e.prototype._autoResendFileMessage.call(this, t).onPending(function(i) {
      r.completeCurrentAndProcessNextAutoResend(i), a._trigger(i);
    }).onFailed(function(i, c) {
      r.completeCurrentAndProcessNextAutoResend(c), a._triggerFailed(i, c);
    }).onSucceeded(function(i) {
      var c = cl.of(l._iid);
      r.completeCurrentAndProcessNextAutoResend(i), l._updateLastMessage(i), c.handlers.map(function(V) {
        V.onChannelChanged && V.onChannelChanged(l);
      }), d.dispatch(new Dt({ channels: [l], source: ne.EVENT_MESSAGE_SENT })), a._trigger(i);
    }), a;
  }, n.prototype.deleteMessage = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, e.prototype.deleteMessage.call(this, t)];
          case 1:
            return l.sent(), t.messageId === 0 && t instanceof wn && D.of(this._iid).dispatcher.dispatch(new l3({ reqId: t.reqId, source: ne.EVENT_MESSAGE_DELETED })), [2];
        }
      });
    });
  }, n.prototype.hide = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            return l = x(x({}, t0), t), Ze(function(U) {
              return B("boolean", U.hidePreviousMessages, !0) && B("boolean", U.allowAutoUnhide, !0);
            }(l)).throw(j.invalidParameters), a = D.of(this._iid), d = a.dispatcher, r = a.sdkState, i = a.requestQueue, c = new cD(x({ channelUrl: this.url, userId: r.userId }, l)), [4, i.send(c)];
          case 1:
            return V = o.sent(), s = V.as(sD).messageOffsetTimestamp, this.hiddenState = l.allowAutoUnhide ? yl.HIDDEN_ALLOW_AUTO_UNHIDE : yl.HIDDEN_PREVENT_AUTO_UNHIDE, l.hidePreviousMessages && this._updateUnreadCount(0, 0), s && (this.messageOffsetTimestamp = s), d.dispatch(new Dt({ channels: [this], source: ne.EVENT_CHANNEL_HIDDEN, isWebSocketEventComing: !0 })), [2, this];
        }
      });
    });
  }, n.prototype.unhide = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return t = D.of(this._iid), l = t.dispatcher, a = t.requestQueue, d = new HD({ channelUrl: this.url }), [4, a.send(d)];
          case 1:
            return r.sent(), this.hiddenState = yl.UNHIDDEN, l.dispatch(new Dt({ channels: [this], source: ne.EVENT_CHANNEL_UNHIDDEN, isWebSocketEventComing: !0 })), [2, this];
        }
      });
    });
  }, n.prototype.delete = function() {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new jD({ channelUrl: this.url }), [4, t.send(l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.markAsRead = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V = this;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return t = D.of(this._iid), l = t.sdkState, a = t.dispatcher, d = t.requestQueue, r = new Vy({ channelUrl: this.url }), [4, d.send(r)];
          case 1:
            return i = s.sent(), c = i.as(Z3).readStatus, this._updateUnreadMemberState(l.userId, c.readAt), (this.unreadMessageCount > 0 || this.unreadMentionCount > 0) && (this._updateUnreadCount(0, 0), cl.of(this._iid).handlers.map(function(o) {
              o.onChannelChanged && o.onChannelChanged(V);
            })), a.dispatch(new Dt({ channels: [this], source: ne.EVENT_CHANNEL_READ })), [2];
        }
      });
    });
  }, n.prototype.markAsDelivered = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new FD({ channelUrl: this.url, userId: l.userId }), [4, a.send(d)];
          case 1:
            return r.sent(), [2];
        }
      });
    });
  }, n.prototype.startTyping = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return t = D.of(this._iid), l = t.requestQueue, a = t.typingIndicatorThrottle, (d = (/* @__PURE__ */ new Date()).getTime()) - this._typingStarted >= a ? (this._typingStarted = d, this._typingEnded = 0, r = new UD({ channelUrl: this.url, time: this._typingStarted }), [4, l.send(r)]) : [3, 2];
          case 1:
            i.sent(), i.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.endTyping = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return t = D.of(this._iid), l = t.requestQueue, a = t.typingIndicatorThrottle, (d = (/* @__PURE__ */ new Date()).getTime()) - this._typingEnded >= a ? (this._typingStarted = 0, this._typingEnded = d, r = new RD({ channelUrl: this.url, time: this._typingStarted }), [4, l.send(r)]) : [3, 2];
          case 1:
            i.sent(), i.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.createScheduledUserMessage = function(t) {
    t = x(x({}, VB), t), Ze(cB(t)).throw(j.invalidParameters);
    var l = new oa();
    return this._createScheduledUserMessage(t, l), l;
  }, n.prototype.updateScheduledUserMessage = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return a = x(x({}, CD), l), Ze(function(V) {
              return E3(V) && B("number", V.scheduledAt, !0);
            }(a)).throw(j.invalidParameters), d = D.of(this._iid).requestQueue, r = new PD(x({ reqId: this._generateRequestId(), scheduledMessageId: t, channelType: this.channelType, channelUrl: this.url }, a)), [4, d.send(r)];
          case 1:
            return i = c.sent(), [2, i.as(x3).message];
        }
      });
    });
  }, n.prototype.createScheduledFileMessage = function(t) {
    var l = this;
    t = x(x({}, sB), t), Ze(oB(t)).throw(j.invalidParameters);
    var a = Date.now(), d = this._generateRequestId(), r = new oa();
    return Qa(O5).then(function() {
      var i = l._createPendingScheduledFileMessage(t, d, a);
      Ce(function() {
        return M(l, void 0, void 0, function() {
          return p(this, function(c) {
            return [2, r._trigger(i)];
          });
        });
      });
    }), Nl(t.file) ? this._uploadFileAndUpdateParams(t).then(function() {
      return l._createScheduledFileMessage(t, r, d, a);
    }) : this._createScheduledFileMessage(t, r, d, a), r;
  }, n.prototype.updateScheduledFileMessage = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return a = x(x({}, LD), l), Ze(function(c) {
              return QW(c) && B("number", c.scheduledAt, !0) && (Nl(c.file) || B("string", c.fileUrl)) && B("string", c.fileName, !0) && B("string", c.mimeType, !0) && B("number", c.fileSize, !0) && (c.thumbnailSizes === null || c.thumbnailSizes === void 0 || c.thumbnailSizes.every(function(V) {
                return B("object", V) && V.maxWidth > 0 && V.maxHeight > 0;
              }));
            }(a)).throw(j.invalidParameters), Nl(a.file) ? [4, this._uploadFileAndUpdateParams(a)] : [3, 2];
          case 1:
            i.sent(), i.label = 2;
          case 2:
            return d = new KD(x({ reqId: this._generateRequestId(), scheduledMessageId: t, channelType: this.channelType, channelUrl: this.url }, a)), [4, D.of(this._iid).requestQueue.send(d)];
          case 3:
            return r = i.sent(), [2, r.as(_D).message];
        }
      });
    });
  }, n.prototype.cancelScheduledMessage = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = new AD({ scheduledMessageId: t, channelType: this.channelType, channelUrl: this.url }), [4, D.of(this._iid).requestQueue.send(l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.sendScheduledMessageNow = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return l = new qD({ scheduledMessageId: t, channelType: this.channelType, channelUrl: this.url }), [4, D.of(this._iid).requestQueue.send(l)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.getMyPushTriggerOption = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new tX({ userId: l.userId, channelUrl: this.url }), [4, a.send(d)];
          case 1:
            return r = c.sent(), i = r.as(nX).pushTriggerOption, this.myPushTriggerOption = i, [2, i];
        }
      });
    });
  }, n.prototype.setMyPushTriggerOption = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return Ze(Qt($i, t)).throw(j.invalidParameters), l = D.of(this._iid), a = l.dispatcher, d = l.sdkState, r = l.requestQueue, i = new $D({ userId: d.userId, channelUrl: this.url, pushTriggerOption: t }), [4, r.send(i)];
          case 1:
            return c = s.sent(), V = c.as(eX).pushTriggerOption, this.myPushTriggerOption = V, a.dispatch(new Dt({ channels: [this], source: ne.EVENT_CHANNEL_UPDATED, isWebSocketEventComing: !0 })), [2, V];
        }
      });
    });
  }, n.prototype.setMyCountPreference = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return Ze(Qt(Ja, t)).throw(j.invalidParameters), l = D.of(this._iid), a = l.dispatcher, d = l.sdkState, r = l.requestQueue, i = new fD({ channelUrl: this.url, userId: d.userId, countPreference: t }), [4, r.send(i)];
          case 1:
            return c = s.sent(), V = c.as(wD).countPreference, this.myCountPreference = V, this._updateUnreadCount(this.unreadMessageCount, this.unreadMentionCount), a.dispatch(new Dt({ channels: [this], source: ne.EVENT_CHANNEL_UPDATED, isWebSocketEventComing: !0 })), [2, V];
        }
      });
    });
  }, n.prototype.resetMyHistory = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return t = D.of(this._iid), l = t.dispatcher, a = t.requestQueue, d = new gD({ channelUrl: this.url }), [4, a.send(d)];
          case 1:
            return r = c.sent(), i = r.as(ID).messageOffsetTimestamp, this.messageOffsetTimestamp = i, this.lastMessage && this.lastMessage.createdAt < i && (this.lastMessage = null), this._updateUnreadCount(0, 0), this.totalUnreadReplyCount = 0, l.dispatch(new Dt({ channels: [this], source: ne.EVENT_CHANNEL_RESET_HISTORY, isWebSocketEventComing: !0 })), [2, this];
        }
      });
    });
  }, n.prototype.pinMessage = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return Ze(B("number", t) && t > 0).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new lX({ channelType: this.channelType, channelUrl: this.url, messageId: t }), [4, l.send(a)];
          case 1:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype.unpinMessage = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return Ze(B("number", t) && t > 0).throw(j.invalidParameters), l = D.of(this._iid).requestQueue, a = new aX({ channelType: this.channelType, channelUrl: this.url, messageId: t }), [4, l.send(a)];
          case 1:
            return d.sent(), [2];
        }
      });
    });
  }, n.prototype._uploadFileAndUpdateParams = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s, o, U;
      return p(this, function(N) {
        switch (N.label) {
          case 0:
            return Nl(t.file) ? (l = D.of(this._iid).requestQueue, a = new nR({ file: t.file, channelUrl: this.url, thumbnailSizes: t.thumbnailSizes, requestId: this._generateRequestId() }), [4, l.send(a)]) : [3, 2];
          case 1:
            d = N.sent(), r = d.as(lR), i = r.url, c = r.fileSize, V = c === void 0 ? t.fileSize : c, s = r.thumbnails, o = r.requireAuth, U = o !== void 0 && o, t.fileUrl = i, t.fileSize = V, t.requireAuth = U, t._thumbnails = s, N.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, n.prototype.resendMessage = function(t, l) {
    var a, d = this;
    if (Ze(t instanceof wn && !t.scheduledInfo && t.isResendable).throw(j.invalidParameters), t.isUserMessage()) {
      var r = (a = t.messageParams) !== null && a !== void 0 ? a : gT(t), i = new oa();
      return this._sendUserMessage(r, pl.RESEND, t.reqId).onPending(function(o) {
        i._trigger(o);
      }).onFailed(function(o, U) {
        i._triggerFailed(o, U);
      }).onSucceeded(function(o) {
        d._tryUpdateLastMessageAndCallEvents(d, o), i._trigger(o);
      }), i;
    }
    if (t.isFileMessage()) {
      var c = this._validateFailedFileMessageHasFile(t, l);
      Ze(c).throw(j.invalidParameters), r = IT(t, l);
      var V = new oa();
      return this._sendFileMessage(r, pl.RESEND, t.reqId).onPending(function(o) {
        V._trigger(o);
      }).onFailed(function(o, U) {
        V._triggerFailed(o, U);
      }).onSucceeded(function(o) {
        d._tryUpdateLastMessageAndCallEvents(d, o), V._trigger(o);
      }), V;
    }
    if (t.isMultipleFilesMessage()) {
      r = t.messageParams;
      var s = new SN();
      return this._sendMultipleFilesMessage(r, pl.RESEND, t.reqId).onPending(function(o) {
        s._trigger(o);
      }).onFailed(function(o, U) {
        s._triggerFailed(o, U);
      }).onSucceeded(function(o) {
        d._tryUpdateLastMessageAndCallEvents(d, o), s._trigger(o);
      }).onFileUploaded(function(o, U, N, R) {
        s._triggerOnFileUploaded(o, U, N, R);
      }), s;
    }
  }, n.prototype.copyMessage = function(t, l) {
    var a = this;
    if (Ze(t instanceof VR && l instanceof wn && l.sendingStatus === $t.SUCCEEDED && this.url === l.channelUrl && !l.scheduledInfo).throw(j.invalidParameters), l.isUserMessage()) {
      Ze(!l.poll).throw(j.notSupportedError);
      var d = m3(l), r = new oa();
      return t._sendUserMessage(d).onPending(function(V) {
        r._trigger(V);
      }).onFailed(function(V, s) {
        r._triggerFailed(V, s);
      }).onSucceeded(function(V) {
        t.isGroupChannel() && a._tryUpdateLastMessageAndCallEvents(t, V), r._trigger(V);
      }), r;
    }
    if (l.isFileMessage()) {
      d = p3(l);
      var i = new oa();
      return t._sendFileMessage(d).onPending(function(V) {
        i._trigger(V);
      }).onFailed(function(V, s) {
        i._triggerFailed(V, s);
      }).onSucceeded(function(V) {
        t.isGroupChannel() && a._tryUpdateLastMessageAndCallEvents(t, V), i._trigger(V);
      }), i;
    }
    if (l.isMultipleFilesMessage()) {
      if (t.isGroupChannel()) {
        d = B5(l);
        var c = new SN();
        return t._sendMultipleFilesMessage(d, pl.COPY).onPending(function(V) {
          c._trigger(V);
        }).onFailed(function(V, s) {
          c._triggerFailed(V, s);
        }).onSucceeded(function(V) {
          a._tryUpdateLastMessageAndCallEvents(t, V), c._trigger(V);
        }).onFileUploaded(function(V, s, o, U) {
          c._triggerOnFileUploaded(V, s, o, U);
        }), c;
      }
      throw j.channelTypeNotSupportedError;
    }
  }, n;
}(VR), rb = function() {
  this.onUserMuted = ut, this.onUserUnmuted = ut, this.onUserBanned = ut, this.onUserUnbanned = ut, this.onChannelChanged = ut, this.onChannelDeleted = ut, this.onChannelFrozen = ut, this.onChannelUnfrozen = ut, this.onOperatorUpdated = ut, this.onChannelMemberCountChanged = ut, this.onMetaDataCreated = ut, this.onMetaDataUpdated = ut, this.onMetaDataDeleted = ut, this.onMetaCounterCreated = ut, this.onMetaCounterUpdated = ut, this.onMetaCounterDeleted = ut, this.onMessageReceived = ut, this.onMessageUpdated = ut, this.onMessageDeleted = ut, this.onMentionReceived = ut, this.onReactionUpdated = ut, this.onThreadInfoUpdated = ut;
}, eo, jr = {}, sX = function() {
  function e(n) {
    var t = n._iid, l = n.limit, a = l === void 0 ? 100 : l, d = this;
    this.ref = 0, this._iid = t, this._limit = a;
    var r, i = D.of(this._iid), c = i.sdkState, V = i.dispatcher, s = i.logger, o = i.cacheContext;
    this._metadataKey = (r = c.userId, "sendbird:".concat(r, "@groupchannel/sync.meta"));
    var U = function(N) {
      return "sendbird:".concat(N, "@groupchannel/sync");
    }(c.userId);
    this._sync = new ui(U, function() {
      return M(d, void 0, void 0, function() {
        var N, R, h, Z, W, F, m, E, u, b, k, Q;
        return p(this, function(S) {
          switch (S.label) {
            case 0:
              return N = { hasNext: !0, nextToken: "" }, [4, this.loadMetadata()];
            case 1:
              if (S.sent(), s.debug("channel background sync from", (u = this._metadata) === null || u === void 0 ? void 0 : u.token), (b = this._metadata) === null || b === void 0 ? void 0 : b.completed)
                return [3, 13];
              S.label = 2;
            case 2:
              if (S.trys.push([2, 9, , 12]), (R = { includeEmpty: !0, order: Xn.CHRONOLOGICAL }).order !== Xn.LATEST_LAST_MESSAGE)
                return [3, 6];
              S.label = 3;
            case 3:
              return S.trys.push([3, 5, , 6]), [4, o.preference.get(pW(c.appId))];
            case 4:
              return h = S.sent(), R.includeChatNotification = !!h, [3, 6];
            case 5:
              return S.sent(), R.includeChatNotification = !1, [3, 6];
            case 6:
              return [4, cl.of(this._iid).getMyGroupChannels((Q = (k = this._metadata) === null || k === void 0 ? void 0 : k.token) !== null && Q !== void 0 ? Q : "", R, this._limit, ne.SYNC_CHANNEL_BACKGROUND)];
            case 7:
              return Z = S.sent(), W = Z.channels, F = Z.token, N.hasNext = W.length >= this._limit && !!F, N.nextToken = F, this._metadata && (this._metadata.token = F, (E = this._metadata.range).extends.apply(E, ot([], et(W.map(function(v) {
                return v.createdAt;
              })), !1)), this._metadata.completed = !N.hasNext), s.debug("channel background sync progress", N), [4, this.saveMetadata()];
            case 8:
              return S.sent(), [3, 12];
            case 9:
              return m = S.sent(), s.debug("channel background sync error", m), m instanceof j && m.isInvalidTokenError ? [4, this.clearMetaData()] : [3, 11];
            case 10:
              S.sent(), S.label = 11;
            case 11:
              throw m;
            case 12:
              return [3, 14];
            case 13:
              N.hasNext = !1, N.nextToken = "", S.label = 14;
            case 14:
              return [2, N];
          }
        });
      });
    }), this._connectionEventContext = V.on(function(N) {
      N instanceof ua && (N.stateType === tn.CONNECTED ? d.resume() : d.pause());
    });
  }
  return e.of = function(n) {
    return jr[n] || (jr[n] = new e({ _iid: n })), jr[n].ref++, jr[n];
  }, e.clear = function(n) {
    jr[n] && (jr[n].close(), delete jr[n]);
  }, Object.defineProperty(e.prototype, "range", { get: function() {
    var n, t;
    return (t = (n = this._metadata) === null || n === void 0 ? void 0 : n.range) !== null && t !== void 0 ? t : new fd({});
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "completed", { get: function() {
    var n;
    return !!(!((n = this._metadata) === null || n === void 0) && n.completed);
  }, enumerable: !1, configurable: !0 }), e.prototype.loadMetadata = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return this._metadata ? [3, 2] : [4, D.of(this._iid).cacheContext.preference.get(this._metadataKey)];
          case 1:
            n = t.sent(), this._metadata = { token: n ? n.token : "", range: new fd(n ? n.range : { top: Number.MAX_SAFE_INTEGER, bottom: 0 }), completed: !!n && n.completed }, t.label = 2;
          case 2:
            return [2, this._metadata];
        }
      });
    });
  }, e.prototype.saveMetadata = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return this._metadata ? [4, D.of(this._iid).cacheContext.preference.set(this._metadataKey, this._metadata)] : [3, 2];
          case 1:
            return n.sent(), [2, !0];
          case 2:
            return [2, !1];
        }
      });
    });
  }, e.prototype.clearMetaData = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, D.of(this._iid).cacheContext.preference.remove(this._metadataKey)];
          case 1:
            return n.sent(), this._metadata = void 0, [2];
        }
      });
    });
  }, e.prototype.resume = function() {
    var n, t, l = D.of(this._iid), a = l.logger;
    l.sessionManager.session.hasSession && (a.debug("channel background sync resume()"), this._sync.start((t = (n = this._metadata) === null || n === void 0 ? void 0 : n.token) !== null && t !== void 0 ? t : ""));
  }, e.prototype.pause = function() {
    D.of(this._iid).logger.debug("channel background sync stop()"), this._sync.stop();
  }, e.prototype.close = function() {
    this.ref--, this.ref <= 0 && (this.ref = 0, this.pause(), this._connectionEventContext.close(), delete jr[this._iid]);
  }, e;
}(), Hr = {}, oX = function() {
  function e(n) {
    var t = n._iid, l = this;
    this.ref = 0, this._iid = t;
    var a, d = D.of(this._iid), r = d.logger, i = d.sdkState, c = d.dispatcher, V = d.cacheContext;
    this._metadataKey = (a = i.userId, "sendbird:".concat(a, "@groupchannel/changelogs.meta"));
    var s = function(o) {
      return "sendbird:".concat(o, "@groupchannel/changelogs");
    }(i.userId);
    this._sync = new ui(s, function() {
      return M(l, void 0, void 0, function() {
        var o, U, N, R, h, Z, W, F, m, E;
        return p(this, function(u) {
          switch (u.label) {
            case 0:
              return o = { hasNext: !0, nextToken: 0 }, [4, this.loadMetadata()];
            case 1:
              u.sent(), r.debug("channel changelog sync from", (F = this._metadata) === null || F === void 0 ? void 0 : F.token), u.label = 2;
            case 2:
              u.trys.push([2, 9, , 12]), U = { includeEmpty: !0 }, u.label = 3;
            case 3:
              return u.trys.push([3, 5, , 6]), [4, V.preference.get(pW(i.appId))];
            case 4:
              return N = u.sent(), U.includeChatNotification = !!N, [3, 6];
            case 5:
              return u.sent(), U.includeChatNotification = !1, [3, 6];
            case 6:
              return [4, cl.of(this._iid).getMyGroupChannelChangeLogs((E = (m = this._metadata) === null || m === void 0 ? void 0 : m.token) !== null && E !== void 0 ? E : "", U, ne.SYNC_CHANNEL_CHANGELOGS)];
            case 7:
              return R = u.sent(), h = R.hasMore, Z = R.token, o.hasNext = h, o.nextToken = Z, this._metadata && (this._metadata.token = Z), r.debug("channel changelog sync progress", o), [4, this.saveMetadata()];
            case 8:
              return u.sent(), [3, 12];
            case 9:
              return W = u.sent(), r.debug("channel changelog sync error", W), W instanceof j && W.isInvalidTokenError ? [4, this.clearMetadata()] : [3, 11];
            case 10:
              u.sent(), u.label = 11;
            case 11:
              throw W;
            case 12:
              return [2, o];
          }
        });
      });
    }), this._connectionEventContext = c.on(function(o) {
      o instanceof ua && (o.stateType === tn.CONNECTED ? l.resume() : l.pause());
    });
  }
  return e.of = function(n) {
    return Hr[n] || (Hr[n] = new e({ _iid: n })), Hr[n].ref++, Hr[n];
  }, e.clear = function(n) {
    Hr[n] && (Hr[n].close(), delete Hr[n]);
  }, e.prototype.loadMetadata = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return this._metadata ? [3, 2] : (n = D.of(this._iid), t = n.cacheContext, l = n.firstConnectedAt, [4, t.preference.get(this._metadataKey)]);
          case 1:
            a = d.sent(), this._metadata = { token: a ? a.token : l }, d.label = 2;
          case 2:
            return [2, this._metadata];
        }
      });
    });
  }, e.prototype.saveMetadata = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return this._metadata ? [4, D.of(this._iid).cacheContext.preference.set(this._metadataKey, this._metadata)] : [3, 2];
          case 1:
            return n.sent(), [2, !0];
          case 2:
            return [2, !1];
        }
      });
    });
  }, e.prototype.clearMetadata = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, D.of(this._iid).cacheContext.preference.remove(this._metadataKey)];
          case 1:
            return n.sent(), this._metadata = void 0, [2];
        }
      });
    });
  }, e.prototype.resume = function() {
    D.of(this._iid).sessionManager.session.hasSession && this._sync.start(0);
  }, e.prototype.pause = function() {
    this._sync.stop();
  }, e.prototype.close = function() {
    this.ref--, this.ref <= 0 && (this.ref = 0, this.pause(), this._connectionEventContext.close(), delete Hr[this._iid]);
  }, e;
}(), a0 = function(e, n) {
  return e.findIndex(function(t) {
    return t.isIdentical(n);
  });
}, UX = function(e, n, t) {
  if (e.length > 0) {
    for (var l = a0(e, n), a = 0, d = e.length - 1, r = Math.floor((a + d) / 2); a < d; ) {
      var i = Ou(e[r], n, t);
      if (i > 0)
        d = r, r = Math.floor((a + d) / 2);
      else {
        if (!(i < 0))
          return { place: r, oldPosition: l };
        a = r + 1, r = Math.floor((a + d) / 2);
      }
    }
    return { place: Ou(e[r], n, t) >= 0 ? r : r + 1, oldPosition: l };
  }
  return { place: e.length, oldPosition: -1 };
}, Ou = function(e, n, t) {
  switch (t) {
    case Xn.LATEST_LAST_MESSAGE:
      return e.lastMessage && n.lastMessage ? n.lastMessage.createdAt - e.lastMessage.createdAt : e.lastMessage ? -1 : n.lastMessage ? 1 : n.createdAt - e.createdAt;
    case Xn.CHRONOLOGICAL:
      return n.createdAt - e.createdAt;
    case Xn.CHANNEL_NAME_ALPHABETICAL:
      var l = e.name.localeCompare(n.name);
      return l === 0 ? e.createdAt - n.createdAt : l;
    default:
      return 0;
  }
}, NX = function() {
  function e(n, t) {
    var l = t.filter, a = t.order, d = t.limit, r = this;
    this.channels = [], this._iid = n, this._key = "gcc-".concat(vr()), this._isDisposed = !1, this._isGetRemoteChannelsSucceeded = !0, this.filter = l ?? new eb(), this.order = a ?? Xn.LATEST_LAST_MESSAGE, this._hasMore = !0, this._token = "", this._limit = d ?? G3;
    var i = D.of(this._iid), c = i.sdkState, V = i.cacheContext, s = i.dispatcher;
    V.localCacheEnabled && (this._backgroundSync = sX.of(n), this._backgroundSync.resume()), this._changelogSync = oX.of(n), this._changelogSync.resume(), cl.of(this._iid).subscribeChannelEvent(this._key, { onUpdate: function(o, U) {
      if (QN(U)) {
        var N = o.filter(function(h) {
          return r.filter.match(h, c.userId);
        }), R = o.filter(function(h) {
          return !r.filter.match(h, c.userId);
        }).map(function(h) {
          return h.url;
        });
        N.length > 0 && r._addChannelsToView(N, U), R.length > 0 && r._removeChannelsFromView(R, U);
      }
    }, onRemove: function(o, U) {
      r._removeChannelsFromView(o, U);
    } }), D.of(this._iid).statLogCollector.put(new nV({ type: Mn.FEATURE_LOCALCACHE, data: { use_local_cache: V.localCacheEnabled, collection_interface: { group_channel: !0 } } })), s.on(function(o) {
      o instanceof ua && (o.stateType === tn.CONNECTED ? r._isGetRemoteChannelsSucceeded || M(r, void 0, void 0, function() {
        return p(this, function(U) {
          switch (U.label) {
            case 0:
              return [4, this._revokeLoadMore()];
            case 1:
              return U.sent(), [2];
          }
        });
      }) : o.stateType === tn.LOGOUT && r.dispose());
    });
  }
  return Object.defineProperty(e.prototype, "hasMore", { get: function() {
    return !this._isDisposed && this._hasMore;
  }, enumerable: !1, configurable: !0 }), e.prototype.setGroupChannelCollectionHandler = function(n) {
    this._handler = n;
  }, e.prototype._addChannelsToView = function(n, t, l) {
    var a, d, r, i, c = this;
    l === void 0 && (l = !1);
    var V = [], s = [], o = [];
    try {
      for (var U = be(n), N = U.next(); !N.done; N = U.next()) {
        var R = N.value, h = a0(this.channels, R);
        h >= 0 && this.channels.splice(h, 1);
        var Z = UX(this.channels, R, this.order).place;
        if (h < 0)
          Z === this.channels.length ? !l && this._hasMore || (V.push(R), this.channels.push(R)) : (V.push(R), this.channels.splice(Z, 0, R));
        else
          switch (t) {
            case ne.EVENT_CHANNEL_UPDATED:
            case ne.EVENT_MESSAGE_RECEIVED:
            case ne.SYNC_CHANNEL_CHANGELOGS:
            case ne.EVENT_MESSAGE_SENT:
              this.order === Xn.CHANNEL_NAME_ALPHABETICAL && this._hasMore && Z === this.channels.length ? o.push(R) : (this.channels.splice(Z, 0, R), s.push(R));
              break;
            default:
              this.channels.splice(Z, 0, R), s.push(R);
          }
      }
    } catch (E) {
      a = { error: E };
    } finally {
      try {
        N && !N.done && (d = U.return) && d.call(U);
      } finally {
        if (a)
          throw a.error;
      }
    }
    if (o.length > 0)
      try {
        for (var W = be(o), F = W.next(); !F.done; F = W.next()) {
          R = F.value;
          var m = a0(this.channels, R);
          m !== -1 && this.channels.splice(m, 1);
        }
      } catch (E) {
        r = { error: E };
      } finally {
        try {
          F && !F.done && (i = W.return) && i.call(W);
        } finally {
          if (r)
            throw r.error;
        }
      }
    QN(t) && Ce(function() {
      return M(c, void 0, void 0, function() {
        var E, u, b, k;
        return p(this, function(Q) {
          return E = new l0(t), V.length > 0 && (!((u = this._handler) === null || u === void 0) && u.onChannelsAdded) && this._handler.onChannelsAdded(E, V), s.length > 0 && (!((b = this._handler) === null || b === void 0) && b.onChannelsUpdated) && this._handler.onChannelsUpdated(E, s), o.length > 0 && (!((k = this._handler) === null || k === void 0) && k.onChannelsDeleted) && this._handler.onChannelsDeleted(E, o.map(function(S) {
            return S.url;
          })), [2];
        });
      });
    });
  }, e.prototype._removeChannelsFromView = function(n, t) {
    var l, a, d = this, r = [], i = function(o) {
      var U = c.channels.findIndex(function(N) {
        return N.url === o;
      });
      U >= 0 && (r.push(c.channels[U].url), c.channels.splice(U, 1));
    }, c = this;
    try {
      for (var V = be(n), s = V.next(); !s.done; s = V.next())
        i(s.value);
    } catch (o) {
      l = { error: o };
    } finally {
      try {
        s && !s.done && (a = V.return) && a.call(V);
      } finally {
        if (l)
          throw l.error;
      }
    }
    return QN(t) && r.length > 0 && Ce(function() {
      return M(d, void 0, void 0, function() {
        var o, U;
        return p(this, function(N) {
          return o = new l0(t), !((U = this._handler) === null || U === void 0) && U.onChannelsDeleted && this._handler.onChannelsDeleted(o, r), [2];
        });
      });
    }), r;
  }, e.prototype._getLocalChannels = function() {
    return M(this, void 0, void 0, function() {
      var n, t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return n = cl.of(this._iid), t = this.channels.length > 0 ? function(a, d) {
              var r, i, c, V;
              switch (d) {
                case Xn.LATEST_LAST_MESSAGE:
                  return (i = (r = a.lastMessage) === null || r === void 0 ? void 0 : r.createdAt) !== null && i !== void 0 ? i : a.createdAt;
                case Xn.CHRONOLOGICAL:
                  return a.createdAt;
                case Xn.CHANNEL_NAME_ALPHABETICAL:
                  return a.name;
                default:
                  return (V = (c = a.lastMessage) === null || c === void 0 ? void 0 : c.createdAt) !== null && V !== void 0 ? V : a.createdAt;
              }
            }(this.channels[this.channels.length - 1], this.order) : null, [4, n.getChannelsFromCache(t, this.filter, this.order, this._limit, t ? this.channels[this.channels.length - 1].url : void 0)];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, e.prototype._getRemoteChannels = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, cl.of(this._iid).getMyGroupChannels(this._token, Ae(x(x({}, this.filter), { order: this.order })), this._limit)];
          case 1:
            return n = a.sent(), t = n.channels, l = n.token, this._token = l, this._hasMore = !!l, [2, t];
        }
      });
    });
  }, e.prototype._revokeLoadMore = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            if (this._isDisposed)
              return [2];
            t.label = 1;
          case 1:
            return t.trys.push([1, 3, , 4]), [4, this._getRemoteChannels()];
          case 2:
            return n = t.sent(), this._isGetRemoteChannelsSucceeded = !0, this._addChannelsToView(n, ne.REQUEST_CHANNEL, !0), [3, 4];
          case 3:
            return t.sent(), this._isGetRemoteChannelsSucceeded = !1, [3, 4];
          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.loadMore = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d = this;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            if (this._isDisposed)
              throw new j({ code: nt.COLLECTION_DISPOSED, message: "Collection has been disposed." });
            return this._hasMore ? (n = D.of(this._iid), t = n.cacheContext, l = n.connectionManager, a = [], !t.localCacheEnabled || l.isConnected && !this._backgroundSync.completed ? [3, 2] : [4, yn(function() {
              return M(d, void 0, void 0, function() {
                return p(this, function(i) {
                  switch (i.label) {
                    case 0:
                      return [4, this._getLocalChannels()];
                    case 1:
                      return a = i.sent(), [2];
                  }
                });
              });
            })]) : [3, 6];
          case 1:
            return r.sent(), this._hasMore = a.length >= this._limit, [3, 5];
          case 2:
            return r.trys.push([2, 4, , 5]), [4, this._getRemoteChannels()];
          case 3:
            return a = r.sent(), this._isGetRemoteChannelsSucceeded = !0, [3, 5];
          case 4:
            return r.sent(), this._isGetRemoteChannelsSucceeded = !1, [3, 5];
          case 5:
            return this._addChannelsToView(a, ne.REQUEST_CHANNEL, !0), [2, a];
          case 6:
            return [2, []];
        }
      });
    });
  }, e.prototype.dispose = function() {
    var n, t;
    this._isDisposed || (this._isDisposed = !0, this.channels.length > 0 && this.channels.splice(0, this.channels.length), (n = this._backgroundSync) === null || n === void 0 || n.close(), (t = this._changelogSync) === null || t === void 0 || t.close(), cl.of(this._iid).unsubscribeChannelEvent(this._key));
  }, e;
}(), RX = function(e) {
  function n(t) {
    var l = this, a = t.token, d = t.limit, r = t.order, i = t.includeEmpty, c = t.membershipFilter, V = t.channelNameContainsFilter, s = t.channelUrlsFilter, o = t.customTypesFilter, U = t.customTypeStartsWithFilter, N = t.superChannelFilter, R = t.metadataOrderKeyFilter, h = t.metadataKey, Z = t.metadataValues, W = t.metadataValueStartsWith, F = t.includeFrozen, m = t.includeMetaData;
    return (l = e.call(this) || this).method = he.GET, l.path = vl, l.params = je(Ae({ token: a, limit: d, order: r, show_member: !0, show_read_receipt: !0, show_delivery_receipt: !0, show_empty: i, public_mode: Cd.PUBLIC, public_membership_mode: c, name_contains: V, channel_urls: s, custom_types: o, custom_type_startswith: U, super_mode: N, metadata_order_key: R, metadata_key: h, metadata_values: Z, metadata_value_startswith: W, show_frozen: F, show_metadata: m })), l;
  }
  return J(n, e), n;
}(Te), hX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    a.channels = [];
    var d = l.next, r = l.channels, i = l.ts;
    return a.token = d, r && r.length > 0 && (a.channels = r.map(function(c) {
      return c.ts = i, new ja(t, c);
    })), a.ts = typeof i == "number" ? i : 0, a;
  }
  return J(n, e), n;
}(ue);
(function(e) {
  e.ALL = "all", e.JOINED = "joined";
})(eo || (eo = {}));
var ZX = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F = this;
    return (F = e.call(this, t, l) || this).includeEmpty = !1, F.includeFrozen = !0, F.includeMetaData = !0, F.channelUrlsFilter = null, F.customTypesFilter = null, F.customTypeStartsWithFilter = null, F.channelNameContainsFilter = null, F.membershipFilter = eo.ALL, F.superChannelFilter = la.ALL, F.metadataKey = null, F.metadataValues = null, F.metadataOrderKeyFilter = null, F.metadataValueStartsWith = null, F.order = Ps.CHRONOLOGICAL, F.includeEmpty = (a = l.includeEmpty) !== null && a !== void 0 && a, F.includeFrozen = (d = l.includeFrozen) === null || d === void 0 || d, F.includeMetaData = (r = l.includeMetaData) === null || r === void 0 || r, F.channelUrlsFilter = (i = l.channelUrlsFilter) !== null && i !== void 0 ? i : null, F.customTypesFilter = (c = l.customTypesFilter) !== null && c !== void 0 ? c : null, F.customTypeStartsWithFilter = (V = l.customTypeStartsWithFilter) !== null && V !== void 0 ? V : null, F.channelNameContainsFilter = (s = l.channelNameContainsFilter) !== null && s !== void 0 ? s : null, F.membershipFilter = (o = l.membershipFilter) !== null && o !== void 0 ? o : eo.ALL, F.superChannelFilter = (U = l.superChannelFilter) !== null && U !== void 0 ? U : la.ALL, F.metadataKey = (N = l.metadataKey) !== null && N !== void 0 ? N : null, F.metadataValues = (R = l.metadataValues) !== null && R !== void 0 ? R : null, F.metadataOrderKeyFilter = (h = l.metadataOrderKeyFilter) !== null && h !== void 0 ? h : null, F.metadataValueStartsWith = (Z = l.metadataValueStartsWith) !== null && Z !== void 0 ? Z : null, F.order = (W = l.order) !== null && W !== void 0 ? W : Ps.CHRONOLOGICAL, F;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && B("boolean", this.includeEmpty) && B("boolean", this.includeFrozen) && B("boolean", this.includeMetaData) && B("string", this.channelNameContainsFilter, !0) && Jt("string", this.channelUrlsFilter, !0) && Jt("string", this.customTypesFilter, !0) && B("string", this.customTypeStartsWithFilter, !0) && Qt(eo, this.membershipFilter) && Qt(la, this.superChannelFilter) && Qt(Ps, this.order) && B("string", this.metadataOrderKeyFilter, !0) && B("string", this.metadataKey, !0) && Jt("string", this.metadataValues, !0) && B("string", this.metadataValueStartsWith, !0);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : (t = [], this._hasNext ? (this._isLoading = !0, l = D.of(this._iid).requestQueue, a = new RX(Ae(x(x({}, this), { token: this._token }))), [4, l.send(a)]) : [3, 2]) : [3, 5];
          case 1:
            return d = V.sent(), r = d.as(hX), i = r.channels, c = r.token, this._token = c, this._hasNext = !!c, this._isLoading = !1, [2, i];
          case 2:
            return [2, t];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(yr), xW = function(e) {
  function n(t) {
    t === void 0 && (t = {});
    var l = e.call(this) || this;
    return Object.keys(t).forEach(function(a) {
      l.hasOwnProperty(a) && (l[a] = t[a]);
    }), l;
  }
  return J(n, e), n;
}(function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.onUserJoined = ut, t.onUserLeft = ut, t.onUserReceivedInvitation = ut, t.onUserDeclinedInvitation = ut, t.onChannelHidden = ut, t.onUnreadMemberStatusUpdated = ut, t.onUndeliveredMemberStatusUpdated = ut, t.onTypingStatusUpdated = ut, t.onPollUpdated = ut, t.onPollVoted = ut, t.onPollDeleted = ut, t.onPinnedMessageUpdated = ut, t;
  }
  return J(n, e), n;
}(rb)), TX = function(e) {
  function n(t) {
    var l = this, a = t.token, d = t.limit, r = t.order, i = t.reverse, c = t.channelUrl, V = t.messageTypeFilter, s = t.scheduledStatus;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(pk), l.params = je(Ae({ token: a, limit: d, reverse: i, channel_url: c, order: r, message_type: V, status: s })), l;
  }
  return J(n, e), n;
}(Te), FX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    a.scheduledMessages = [];
    var d = l.next, r = l.scheduled_messages;
    return a.token = d, a.scheduledMessages = r.map(function(i) {
      return Hl(t, i);
    }), a;
  }
  return J(n, e), n;
}(ue), WX = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V = this;
    return (V = e.call(this, t, l) || this).channelUrl = null, V.order = null, V.reverse = !1, V.scheduledStatus = null, V.messageTypeFilter = bl.ALL, V.channelUrl = (a = l.channelUrl) !== null && a !== void 0 ? a : null, V.order = (d = l.order) !== null && d !== void 0 ? d : null, V.reverse = (r = l.reverse) !== null && r !== void 0 && r, V.scheduledStatus = (i = l.scheduledStatus) !== null && i !== void 0 ? i : null, V.messageTypeFilter = (c = l.messageTypeFilter) !== null && c !== void 0 ? c : bl.ALL, V;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && B("string", this.channelUrl, !0) && (Qt(PT, this.order) || this.order === null) && B("boolean", this.reverse) && (Jt(ii, this.scheduledStatus) || this.scheduledStatus === null) && Qt(bl, this.messageTypeFilter);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new TX(Ae(x(x({}, this), { token: this._token }))), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = c.sent(), d = a.as(FX), r = d.scheduledMessages, i = d.token, this._token = i, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(yr), mX = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.name = "groupChannel", t;
  }
  return J(n, e), n.prototype.init = function(t, l) {
    var a = l.sdkState, d = l.dispatcher, r = l.sessionManager, i = l.requestQueue, c = l.logger, V = l.onlineDetector, s = l.cacheContext;
    e.prototype.init.call(this, t, { sdkState: a, dispatcher: d, sessionManager: r, requestQueue: i, logger: c, onlineDetector: V, cacheContext: s }), this._manager = new cl(t, { sdkState: a, cacheContext: s, dispatcher: d, sessionManager: r, requestQueue: i, logger: c });
  }, n.prototype.createGroupChannelCollection = function(t) {
    return t === void 0 && (t = {}), new NX(this._iid, t);
  }, n.prototype.createMyGroupChannelListQuery = function(t) {
    return t === void 0 && (t = {}), new lb(this._iid, t);
  }, n.prototype.createPublicGroupChannelListQuery = function(t) {
    return t === void 0 && (t = {}), new ZX(this._iid, t);
  }, n.prototype.createScheduledMessageListQuery = function(t) {
    return t === void 0 && (t = {}), new WX(this._iid, t);
  }, n.prototype.addGroupChannelHandler = function(t, l) {
    Ze(B("string", t) && l instanceof xW).throw(j.invalidParameters), this._manager.addHandler(t, l);
  }, n.prototype.removeGroupChannelHandler = function(t) {
    Ze(B("string", t)).throw(j.invalidParameters), this._manager.removeHandler(t);
  }, n.prototype.removeAllGroupChannelHandlers = function() {
    this._manager.clearHandler();
  }, n.prototype.buildGroupChannelFromSerializedData = function(t) {
    return this._manager.buildGroupChannelFromSerializedData(t);
  }, n.prototype.buildGroupChannelListQueryFromSerializedData = function(t) {
    return this._manager.buildGroupChannelListQueryFromSerializedData(t);
  }, n.prototype.buildMemberFromSerializedData = function(t) {
    return this._manager.buildMemberFromSerializedData(t);
  }, n.prototype.getChannel = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return Ze(B("string", t)).throw(j.invalidParameters), [2, this._manager.getChannel(t)];
      });
    });
  }, n.prototype.getChannelWithoutCache = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return Ze(B("string", t)).throw(j.invalidParameters), [2, this._manager.getChannelWithoutCache(t)];
      });
    });
  }, n.prototype.getMyGroupChannelChangeLogsByToken = function(t, l) {
    return l === void 0 && (l = {}), M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, UR), l), Ze(B("string", t) && qT(a)).throw(j.invalidParameters), [4, this._manager.getMyGroupChannelChangeLogs(t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype.getMyGroupChannelChangeLogsByTimestamp = function(t, l) {
    return l === void 0 && (l = {}), M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return a = x(x({}, UR), l), Ze(B("number", t) && qT(a)).throw(j.invalidParameters), [4, this._manager.getMyGroupChannelChangeLogs(t, a)];
          case 1:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype.getGroupChannelCount = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        return l = x(x({}, tb), t), Ze(nb(l)).throw(j.invalidParameters), [2, this._manager.getGroupChannelCount(l)];
      });
    });
  }, n.prototype.getUnreadItemCount = function(t) {
    return t === void 0 && (t = {}), M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._manager.getUnreadItemCount(t)];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, n.prototype.getTotalUnreadChannelCount = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this._manager.getTotalUnreadChannelCount()];
          case 1:
            return [2, t.sent()];
        }
      });
    });
  }, n.prototype.getTotalUnreadMessageCount = function(t) {
    return t === void 0 && (t = {}), M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._manager.getTotalUnreadMessageCount(t)];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, n.prototype.getTotalScheduledMessageCount = function(t) {
    return t === void 0 && (t = {}), M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._manager.getTotalScheduledMessageCount(t)];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, n.prototype.getSubscribedTotalUnreadMessageCount = function() {
    return this._manager.getSubscribedTotalUnreadMessageCount();
  }, n.prototype.getSubscribedCustomTypeTotalUnreadMessageCount = function() {
    return this._manager.getSubscribedCustomTypeTotalUnreadMessageCount();
  }, n.prototype.getSubscribedCustomTypeUnreadMessageCount = function(t) {
    return this._manager.getSubscribedCustomTypeUnreadMessageCount(t);
  }, n.prototype.createChannel = function(t) {
    return t === void 0 && (t = {}), M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        return l = x(x({}, YN), t), Ze(AT(l)).throw(j.invalidParameters), [2, this._manager.createChannel(l)];
      });
    });
  }, n.prototype.createDistinctChannelIfNotExist = function(t) {
    return t === void 0 && (t = {}), M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        return l = x(x({}, YN), t), Ze(AT(l)).throw(j.invalidParameters), l && (l.isDistinct = !0), [2, this.createChannel(l)];
      });
    });
  }, n.prototype.createChannelWithUserIds = function(t, l, a, d, r, i) {
    return l === void 0 && (l = !1), r === void 0 && (r = ""), i === void 0 && (i = ""), M(this, void 0, void 0, function() {
      var c;
      return p(this, function(V) {
        return c = x(x({}, YN), { invitedUserIds: t, isDistinct: l, name: a, data: r, customType: i }), typeof d == "string" ? c.coverUrl = d : c.coverImage = d, [2, this.createChannel(c)];
      });
    });
  }, n.prototype.markAsReadAll = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return this._manager.markAsReadAll(), [2];
      });
    });
  }, n.prototype.markAsReadWithChannelUrls = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return Ze(Jt("string", t)).throw(j.invalidParameters), this._manager.markAsReadWithChannelUrls(t), [2];
      });
    });
  }, n.prototype.markAsDelivered = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return Ze(B("string", t)).throw(j.invalidParameters), [4, this.getChannel(t)];
          case 1:
            return [4, l.sent().markAsDelivered()];
          case 2:
            return l.sent(), [2];
        }
      });
    });
  }, n;
}(CR);
Xn.LATEST_LAST_MESSAGE;
globalThis && globalThis.__awaiter;
function lU(e) {
  const n = Wt(e);
  return n.current = e, Pt((...t) => n.current(...t), [n]);
}
globalThis && globalThis.__rest;
globalThis && globalThis.__awaiter;
var uX = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.name = "poll", t;
  }
  return J(n, e), n.prototype.init = function(t, l) {
    var a = l.sdkState, d = l.dispatcher, r = l.sessionManager, i = l.requestQueue, c = l.logger, V = l.onlineDetector, s = l.cacheContext;
    e.prototype.init.call(this, t, { sdkState: a, dispatcher: d, sessionManager: r, requestQueue: i, logger: c, onlineDetector: V, cacheContext: s }), this._manager = new tR(t, { sdkState: a, dispatcher: d, sessionManager: r, requestQueue: i, logger: c, onlineDetector: V, cacheContext: s });
  }, n.prototype.create = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        return l = x(x({}, ty), t), Ze(i3(l)).throw(j.invalidParameters), [2, this._manager.create(l)];
      });
    });
  }, n.prototype.get = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        return l = x(x({}, ly), t), Ze(c3(l)).throw(j.invalidParameters), [2, this._manager.get(l)];
      });
    });
  }, n.prototype.getOption = function(t) {
    return M(this, void 0, void 0, function() {
      var l;
      return p(this, function(a) {
        return l = x(x({}, ny), t), Ze(V3(l)).throw(j.invalidParameters), [2, this._manager.getOption(l)];
      });
    });
  }, n.prototype.buildPollFromSerializedData = function(t) {
    return this._manager.buildPollFromSerializedData(t);
  }, n;
}(CR), pX = function(e) {
  return ["-lastMessageUpdatedAt", "-createdAt", "syncIndex"];
}, ju = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return J(n, e), n;
}(un), ib = function(e) {
  this.key = e.key, this.url = e.url;
}, Vb = function(e) {
  this.id = e.id, this.name = e.name, this.url = e.url, this.emojis = e.emojis ? e.emojis.map(function(n) {
    return new ib(n);
  }) : [];
}, MX = function(e) {
  this.emojiHash = e.emoji_hash || "", this.emojiCategories = e.emoji_categories ? e.emoji_categories.map(function(n) {
    return new Vb(n);
  }) : [];
}, EX = { profileImage: void 0, profileUrl: void 0, nickname: void 0 }, Hu = function(e) {
  return function(n, t) {
    return M(void 0, void 0, void 0, function() {
      var l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            switch (n) {
              case 1:
              case 2:
              case 3:
                return [3, 1];
              case 4:
                return [3, 2];
              case 5:
                return [3, 9];
            }
            return [3, 13];
          case 1:
            return t(), [3, 14];
          case 2:
            return c.trys.push([2, 7, , 8]), [4, e.clear()];
          case 3:
            return c.sent(), l = function(V) {
              return { v2: function() {
                return M(void 0, void 0, void 0, function() {
                  return p(this, function(s) {
                    switch (s.label) {
                      case 0:
                        return [4, V.commitSchema([{ collectionName: y3, keyName: Q5, index: [bN(Xn.LATEST_LAST_MESSAGE), bN(Xn.CHRONOLOGICAL), bN(Xn.CHANNEL_NAME_ALPHABETICAL)] }, { collectionName: LT, keyName: J5, index: [wd(Wl.CHANNEL_LATEST), wd(Wl.NEWEST_CHILD_MESSAGE)] }, { collectionName: O3, keyName: UB, index: [wd(Wl.CHANNEL_LATEST), wd(Wl.NEWEST_CHILD_MESSAGE)] }, { collectionName: z5, keyName: x5 }])];
                      case 1:
                        return [2, s.sent()];
                    }
                  });
                });
              }, v3: function() {
                return M(void 0, void 0, void 0, function() {
                  return p(this, function(s) {
                    switch (s.label) {
                      case 0:
                        return [4, V.commitSchema([{ collectionName: G5, keyName: y5, index: [pX()] }])];
                      case 1:
                        return [2, s.sent()];
                    }
                  });
                });
              }, v4: function() {
                return M(void 0, void 0, void 0, function() {
                  return p(this, function(s) {
                    switch (s.label) {
                      case 0:
                        return [4, V.commitSchema([{ collectionName: D3, keyName: v5, index: [iB()] }])];
                      case 1:
                        return [2, s.sent()];
                    }
                  });
                });
              } };
            }(e), a = l.v2, d = l.v3, r = l.v4, [4, a()];
          case 4:
            return c.sent(), [4, d()];
          case 5:
            return c.sent(), [4, r()];
          case 6:
            return c.sent(), t(), [3, 8];
          case 7:
            return i = c.sent(), t(i), [3, 8];
          case 8:
            return [3, 14];
          case 9:
            return c.trys.push([9, 11, , 12]), [4, e.collection(LT).removeIf({ where: { channelType: Xt.OPEN } })];
          case 10:
          case 11:
            return c.sent(), [3, 12];
          case 12:
            return t(), [3, 14];
          case 13:
            t(), c.label = 14;
          case 14:
            return [2];
        }
      });
    });
  };
}, SX = function() {
  return typeof document < "u" ? document.visibilityState : "visible";
}, kX = function(e) {
  function n(t) {
    var l = t.getVisibilityState, a = l === void 0 ? SX : l, d = t.initialState, r = d === void 0 ? "visible" : d, i = t.isEnabled, c = i === void 0 || i, V = t.pauseCheckDelay, s = V === void 0 ? 3e4 : V, o = e.call(this) || this;
    return o._pauseCheckDelay = 3e4, o._currentState = "visible", o._getVisibilityState = a, o._pauseCheckDelay = s, o._currentState = r, o._isEnabled = c, o._boundToggleState = o._toggleState.bind(o), o;
  }
  return J(n, e), Object.defineProperty(n.prototype, "currentState", { get: function() {
    return this._currentState;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isAvailable", { get: function() {
    return typeof window < "u" && !!window.addEventListener && !!window.removeEventListener;
  }, enumerable: !1, configurable: !0 }), n.prototype._toggleState = function() {
    var t = this, l = this._getVisibilityState();
    l !== "hidden" ? this._currentState === "hidden" && (this._pauseDelayTimer && (clearTimeout(this._pauseDelayTimer), this._pauseDelayTimer = void 0), this.dispatch("resume")) : this._currentState !== "hidden" && (this._pauseDelayTimer = setTimeout(function() {
      t._pauseDelayTimer = void 0, t.dispatch("pause");
    }, this._pauseCheckDelay)), this._currentState = l;
  }, n.prototype.start = function() {
    this._isEnabled && this.isAvailable && (this._boundToggleState = this._toggleState.bind(this), window.addEventListener("visibilitychange", this._boundToggleState, { capture: !0 }));
  }, n.prototype.stop = function() {
    this._isEnabled && this.isAvailable && this._boundToggleState && window.removeEventListener("visibilitychange", this._boundToggleState, { capture: !0 });
  }, n;
}(zV), bX = function() {
  function e(n) {
    var t = n.logger, l = n.connectionDelegate, a = l === void 0 ? null : l, d = this;
    this._onlineWorker = function() {
      var r;
      return (r = d.connectionDelegate) === null || r === void 0 ? void 0 : r.reconnect();
    }, this._offlineWorker = function() {
      var r;
      return (r = d.connectionDelegate) === null || r === void 0 ? void 0 : r.disconnect();
    }, this.unsubscribes = [], this._onlineListener = function(r) {
      if (d.isAvailableOnWeb)
        return window.addEventListener("online", r), function() {
          return window.removeEventListener("online", r, !1);
        };
    }, this._offlineListener = function(r) {
      if (d.isAvailableOnWeb)
        return window.addEventListener("offline", r), function() {
          return window.removeEventListener("offline", r, !1);
        };
    }, this.logger = t, a && (this.connectionDelegate = a);
  }
  return Object.defineProperty(e.prototype, "isAvailableOnWeb", { get: function() {
    return typeof window < "u" && !!window.addEventListener && "ononline" in window && "onoffline" in window && typeof navigator < "u" && navigator.onLine !== void 0;
  }, enumerable: !1, configurable: !0 }), e.prototype.setOnlineListener = function(n) {
    n && typeof n == "function" && (this._onlineListener = n);
  }, e.prototype.setOfflineListener = function(n) {
    n && typeof n == "function" && (this._offlineListener = n);
  }, e.prototype.start = function() {
    this.unsubscribes = [this._onlineListener(this._onlineWorker), this._offlineListener(this._offlineWorker)];
  }, e.prototype.stop = function() {
    var n = this;
    this.unsubscribes.forEach(function(t) {
      try {
        t == null || t();
      } catch (l) {
        n.logger.warn(l.message);
      }
    }), this.unsubscribes = [];
  }, e.prototype.isOnline = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(n) {
        return this.isAvailableOnWeb ? [2, navigator.onLine] : [2, new Promise(function(t) {
          fetch("https://www.google.com", { method: he.GET, mode: "no-cors" }).then(function() {
            return t(!0);
          }).catch(function() {
            return t(!1);
          });
        })];
      });
    });
  }, e;
}(), fu = function(e) {
  function n(t) {
    var l = t.userId, a = t.nickname, d = t.profileUrl, r = t.profileImage, i = t.preferredLanguages, c = e.call(this) || this;
    return c.method = he.PUT, c.path = "".concat(It, "/").concat(encodeURIComponent(l)), c.params = je(Ae({ nickname: a, profile_url: d, profile_file: r, preferred_languages: i })), c;
  }
  return J(n, e), n;
}(Te), wu = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.user = new xt(t, x({}, l)), a;
  }
  return J(n, e), n;
}(ue), YX = function(e) {
  function n(t) {
    var l = t.userId, a = t.token, d = e.call(this) || this;
    return d.method = he.POST, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push/apns"), d.params = { apns_device_token: a, always_push: !0 }, d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.token = l.token, a.type = l.type ? sl[l.type.toLowerCase()] : sl.UNKNOWN, a.user = new xt(t, l.user), a;
  }
  J(n, e);
})(ue);
var QX = function(e) {
  function n(t) {
    var l = t.userId, a = t.token, d = e.call(this) || this;
    return d.method = he.POST, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push/gcm"), d.params = { gcm_reg_token: a, always_push: !0 }, d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.token = l.token, a.type = l.type ? sl[l.type.toLowerCase()] : sl.UNKNOWN, a.user = new xt(t, l.user), a;
  }
  J(n, e);
})(ue);
var JX = function(e) {
  function n(t) {
    var l = t.userId, a = t.token, d = e.call(this) || this;
    return d.method = he.DELETE, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push/apns/").concat(encodeURIComponent(a)), d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.token = l.token, a.user = new xt(t, l.user), a.lastDeletedAt = l.device_token_last_deleted_at, a;
  }
  J(n, e);
})(ue);
var vX = function(e) {
  function n(t) {
    var l = t.userId, a = t.token, d = e.call(this) || this;
    return d.method = he.DELETE, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push/gcm/").concat(encodeURIComponent(a)), d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.token = l.token, a.user = new xt(t, l.user), a.lastDeletedAt = l.device_token_last_deleted_at, a;
  }
  J(n, e);
})(ue);
var zX = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.DELETE, a.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push/apns"), a;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.type = l.type ? sl[l.type.toLowerCase()] : sl.UNKNOWN, a.user = new xt(t, l.user), a.lastDeletedAt = l.device_token_last_deleted_at, a;
  }
  J(n, e);
})(ue);
var xX = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.DELETE, a.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push/gcm"), a;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.type = l.type ? sl[l.type.toLowerCase()] : sl.UNKNOWN, a.user = new xt(t, l.user), a.lastDeletedAt = l.device_token_last_deleted_at, a;
  }
  J(n, e);
})(ue);
var GX = function(e) {
  function n(t) {
    var l = t.userId, a = t.type, d = t.token, r = t.ts, i = e.call(this) || this;
    return i.method = he.GET, i.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push/").concat(encodeURIComponent(a), "/device_tokens"), i.params = { created_ts: r, token: d }, i;
  }
  return J(n, e), n;
}(Te), yX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.pushTokens = { type: l.type ? sl[l.type.toLowerCase()] : sl.UNKNOWN, deviceTokens: l.device_tokens, hasMore: l.has_more, token: l.token }, a;
  }
  return J(n, e), n;
}(ue), BX = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.GET, a.path = "".concat(It, "/").concat(encodeURIComponent(l), "/channel_invitation_preference"), a;
  }
  return J(n, e), n;
}(Te), DX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.autoAccept = l.auto_accept, a;
  }
  return J(n, e), n;
}(ue), XX = function(e) {
  function n(t) {
    var l = t.userId, a = t.willAutoAccept, d = e.call(this) || this;
    return d.method = he.PUT, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/channel_invitation_preference"), d.params = { auto_accept: a }, d;
  }
  return J(n, e), n;
}(Te), OX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.autoAccept = l.auto_accept, a;
  }
  return J(n, e), n;
}(ue), jX = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.GET, a.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push_preference"), a;
  }
  return J(n, e), n;
}(Te), HX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.preference = { doNotDisturbOn: l.do_not_disturb, startHour: l.start_hour, startMin: l.start_min, endHour: l.end_hour, endMin: l.end_min, timezone: l.timezone }, a;
  }
  return J(n, e), n;
}(ue), fX = function(e) {
  function n(t) {
    var l = t.userId, a = t.doNotDisturbOn, d = t.startHour, r = t.startMin, i = t.endHour, c = t.endMin, V = t.timezone, s = e.call(this) || this;
    return s.method = he.PUT, s.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push_preference"), s.params = { do_not_disturb: a, start_hour: d, start_min: r, end_hour: i, end_min: c, timezone: V }, s;
  }
  return J(n, e), n;
}(Te), wX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.preference = { doNotDisturbOn: l.do_not_disturb, startHour: l.start_hour, startMin: l.start_min, endHour: l.end_hour, endMin: l.end_min, timezone: l.timezone }, a;
  }
  return J(n, e), n;
}(ue), gX = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.GET, a.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push_preference"), a;
  }
  return J(n, e), n;
}(Te), IX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.snoozePeriod = { isSnoozeOn: l.snooze_enabled }, typeof l.snooze_start_ts == "number" && (a.snoozePeriod.startTs = l.snooze_start_ts), typeof l.snooze_end_ts == "number" && (a.snoozePeriod.endTs = l.snooze_end_ts), a;
  }
  return J(n, e), n;
}(ue), LX = function(e) {
  function n(t) {
    var l = t.userId, a = t.snoozeOn, d = t.startTs, r = t.endTs, i = e.call(this) || this;
    return i.method = he.PUT, i.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push_preference"), i.params = { snooze_enabled: a, snooze_start_ts: d, snooze_end_ts: r }, i;
  }
  return J(n, e), n;
}(Te), CX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.snoozePeriod = { isSnoozeOn: l.snooze_enabled }, typeof l.snooze_start_ts == "number" && (a.snoozePeriod.startTs = l.snooze_start_ts), typeof l.snooze_end_ts == "number" && (a.snoozePeriod.endTs = l.snooze_end_ts), a;
  }
  return J(n, e), n;
}(ue), KX = function(e) {
  function n(t) {
    var l = t.userId, a = t.blockedUserId, d = e.call(this) || this;
    return d.method = he.POST, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/block"), d.params = { target_id: a }, d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.user = new xt(t, l), a;
  }
  J(n, e);
})(ue);
var _X = function(e) {
  function n(t) {
    var l = t.userId, a = t.unblockedUserId, d = e.call(this) || this;
    return d.method = he.DELETE, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/block/").concat(encodeURIComponent(a)), d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var PX = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.GET, a.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push_preference"), a;
  }
  return J(n, e), n;
}(Te), AX = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.pushTriggerOption = l.push_trigger_option, a;
  }
  return J(n, e), n;
}(ue), qX = function(e) {
  function n(t) {
    var l = t.userId, a = t.pushTriggerOption, d = e.call(this) || this;
    return d.method = he.PUT, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push_preference"), d.params = { push_trigger_option: a }, d;
  }
  return J(n, e), n;
}(Te), $X = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.pushTriggerOption = l.push_trigger_option, a;
  }
  return J(n, e), n;
}(ue), eO = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.GET, a.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push/template"), a;
  }
  return J(n, e), n;
}(Te), tO = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.name = l.name, a;
  }
  return J(n, e), n;
}(ue), nO = function(e) {
  function n(t) {
    var l = t.userId, a = t.templateName, d = e.call(this) || this;
    return d.method = he.PUT, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/push/template"), d.params = { name: a }, d;
  }
  return J(n, e), n;
}(Te), lO = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.name = l.name, a;
  }
  return J(n, e), n;
}(ue), aO = function(e) {
  function n(t) {
    var l = t.userId, a = t.token, d = e.call(this) || this;
    return d.method = he.GET, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/friends/changelogs"), d.params = { token: a }, d;
  }
  return J(n, e), n;
}(Te), dO = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.changelogs = { addedUsers: l.added.map(function(d) {
      return new xt(t, d);
    }), updatedUsers: l.updated.map(function(d) {
      return new xt(t, d);
    }), deletedUserIds: l.deleted, hasMore: l.has_more, token: l.next }, a;
  }
  return J(n, e), n;
}(ue), rO = function(e) {
  function n(t) {
    var l = t.userId, a = t.discoveries, d = e.call(this) || this;
    return d.method = he.PUT, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/friend_discoveries"), d.params = { friend_discoveries: a.map(function(r) {
      return { friend_discovery_key: r.friendDiscoveryKey, friend_name: r.friendName };
    }) }, d;
  }
  return J(n, e), n;
}(Te), iO = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.friendDiscoveryRequestId = l.friend_discovery_request_id, a;
  }
  return J(n, e), n;
}(ue), VO = function(e) {
  function n(t) {
    var l = t.userId, a = t.discoveryKeys, d = e.call(this) || this;
    return d.method = he.DELETE, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/friend_discoveries"), d.params = { friend_discovery_keys: a }, d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var cO = function(e) {
  function n(t) {
    var l = t.userId, a = t.userIds, d = e.call(this) || this;
    return d.method = he.POST, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/friends"), d.params = { user_ids: a }, d;
  }
  return J(n, e), n;
}(Te), sO = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.users = l.users.map(function(d) {
      return new xt(t, d);
    }), a;
  }
  return J(n, e), n;
}(ue), oO = function(e) {
  function n(t) {
    var l = t.userId, a = t.userIds, d = e.call(this) || this;
    return d.method = he.DELETE, d.path = "".concat(It, "/").concat(encodeURIComponent(l), "/friends"), d.params = { user_ids: a }, d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var UO = function(e) {
  function n(t) {
    var l = t.userId, a = e.call(this) || this;
    return a.method = he.GET, a.path = "".concat(It, "/").concat(l, "/allow_friend_discovery"), a.params = {}, a;
  }
  return J(n, e), n;
}(Te), NO = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.allowFriendDiscovery = l.allow_friend_discovery, a;
  }
  return J(n, e), n;
}(ue), RO = function(e) {
  function n(t) {
    var l = t.userId, a = t.allowFriendDiscovery, d = e.call(this) || this;
    return d.method = he.PUT, d.path = "".concat(It, "/").concat(l, "/allow_friend_discovery"), d.params = { allow_friend_discovery: a }, d;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  J(n, e);
})(ue);
var as, hO = function(e) {
  function n() {
    var t = e.call(this) || this;
    return t.method = he.GET, t.path = uk, t;
  }
  return J(n, e), n;
}(Te), ZO = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.emojiContainer = new MX(l), a;
  }
  return J(n, e), n;
}(ue), TO = function(e) {
  function n(t) {
    var l = t.categoryId, a = e.call(this) || this;
    return a.method = he.GET, a.path = "".concat(uk, "/").concat(l), a;
  }
  return J(n, e), n;
}(Te), FO = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.emojiCategory = new Vb(l), a;
  }
  return J(n, e), n;
}(ue), WO = function(e) {
  function n(t) {
    var l = t.key, a = e.call(this) || this;
    return a.method = he.GET, a.path = "".concat(Tx, "/").concat(l), a;
  }
  return J(n, e), n;
}(Te), mO = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.emoji = new ib(l), a;
  }
  return J(n, e), n;
}(ue), uO = function(e) {
  function n() {
    var t = e.call(this) || this;
    return t.method = he.GET, t.path = "".concat(Fx), t;
  }
  return J(n, e), n;
}(Te), pO = function(e) {
  function n(t, l) {
    var a, d = this, r = l ?? {};
    return (d = e.call(this, t, l) || this).uikitConfiguration = { string: JSON.stringify(r), json: r }, d.updatedAt = (a = l == null ? void 0 : l.updated_at) !== null && a !== void 0 ? a : 0, d;
  }
  return J(n, e), n;
}(ue), MO = function() {
  function e(n, t, l) {
    var a = this;
    this._storeInitialized = !1, this._iid = n, this.options = t;
    var d = D.of(n), r = d.sdkState, i = d.cacheContext, c = d.dispatcher, V = d.sessionManager, s = d.requestQueue, o = d.logger, U = d.userEventHandlers, N = d.appStateToggleEnabled;
    this._onlineDetector = new bX({ logger: o, connectionDelegate: { reconnect: function() {
      return M(a, void 0, void 0, function() {
        var h, Z, W, F, m, E;
        return p(this, function(u) {
          switch (u.label) {
            case 0:
              if (h = D.of(n), Z = h.sdkState, W = h.connectionManager, (F = h.sessionManager).session.hasSession)
                return [3, 5];
              u.label = 1;
            case 1:
              return u.trys.push([1, 3, , 4]), [4, W.connect(F.session.authToken)];
            case 2:
              return u.sent(), [3, 4];
            case 3:
              if (m = u.sent(), Il(m))
                throw m;
              return o.debug("connect failed by reconnect event = ", m), [3, 4];
            case 4:
              return [3, 9];
            case 5:
              if (Z.appState !== "foreground")
                return [3, 9];
              u.label = 6;
            case 6:
              return u.trys.push([6, 8, , 9]), [4, W.resetAndReconnect()];
            case 7:
              return u.sent(), [3, 9];
            case 8:
              if (E = u.sent(), Il(E))
                throw E;
              return o.debug("resetAndReconnect failed by reconnect event = ", E), [3, 9];
            case 9:
              return c.dispatch(new ju()), [2];
          }
        });
      });
    }, disconnect: function() {
      yn(function() {
        return M(a, void 0, void 0, function() {
          return p(this, function(h) {
            switch (h.label) {
              case 0:
                return [4, D.of(n).connectionManager.disconnect()];
              case 1:
                return h.sent(), [2];
            }
          });
        });
      });
    } } });
    var R = new bs(n, { localCacheEnabled: i.localCacheEnabled, enableAutoResend: i.localCacheConfig.enableAutoResend, dispatcher: c, sdkState: r, logger: o });
    l.forEach(function(h) {
      h.init(n, { sdkState: r, cacheContext: i, dispatcher: c, sessionManager: V, requestQueue: s, logger: o, onlineDetector: a._onlineDetector }), a[h.name] = h;
    }), this._appStateChangeDetector = new kX({ isEnabled: N }), this._appStateChangeDetector.on("resume", function() {
      o.debug("the page resumes from freeze"), a.setForegroundState();
    }).on("pause", function() {
      o.debug("the page freezes"), a.setBackgroundState();
    }), c.on(function(h) {
      var Z;
      if (h instanceof ua)
        h.stateType === tn.CONNECTED && R.processNonAutoResendRegisteredPendingMessages();
      else if (h instanceof Wn) {
        if (h.code === "USEV") {
          var W = h.as(I3).event;
          if (W.category === uo.FRIEND_DISCOVERED) {
            var F = sR.getDataAsFriendDiscoveredEvent(n, W).friendDiscoveries;
            Ce(function() {
              return M(a, void 0, void 0, function() {
                return p(this, function(k) {
                  return [2, U.forEach(function(Q) {
                    Q.onFriendsDiscovered && Q.onFriendsDiscovered(F);
                  })];
                });
              });
            });
          }
        }
      } else if (h instanceof Ik) {
        var m = D.of(a._iid).subscribedUnreadMessageCount, E = !1, u = h.ts;
        if (typeof u == "number" && u > m.ts) {
          if (m.all !== h.all && (E = !0), m.all = h.all >= 0 ? h.all : 0, h.customTypes)
            for (var b in h.customTypes)
              m.customTypes[b] !== h.customTypes[b] && (E = !0), m.customTypes[b] = h.customTypes[b];
          E = E && m.ts > 0, m.ts = u;
        }
        E && Ce(function() {
          return M(a, void 0, void 0, function() {
            return p(this, function(k) {
              return [2, U.forEach(function(Q) {
                Q.onTotalUnreadMessageCountChanged && Q.onTotalUnreadMessageCountChanged({ groupChannelCount: m.all, feedChannelCount: m.feed, customTypeUnreadCount: m.customTypes }), Q.onTotalUnreadMessageCountUpdated && Q.onTotalUnreadMessageCountUpdated(m.all, m.customTypes);
              })];
            });
          });
        });
      } else
        h instanceof Kk ? (i.preference.set(a._getUserProfileCacheKey(r.userId), OT.payloadify(h.userProfile)), !((Z = h.userProfile.appInfo.notificationInfo) === null || Z === void 0) && Z.isEnabled && i.preference.set(pW(a.appId), { value: !0 })) : h instanceof Sc && h.error && h.error.isSessionInvalidatedError && (o.debug("session revoked."), a.disconnect());
    });
  }
  return e.init = function(n) {
    var t = n.appId, l = n.appVersion, a = n.modules, d = a === void 0 ? [] : a, r = n.options, i = r === void 0 ? new Fk() : r, c = n.debugMode, V = c !== void 0 && c, s = n.customApiHost, o = n.customWebSocketHost, U = n.newInstance, N = U !== void 0 && U, R = n.logLevel, h = n.localCacheEnabled, Z = h !== void 0 && h, W = n.localCacheConfig, F = W === void 0 ? new mk() : W, m = n.localCacheEncryption, E = n.useAsyncStorageStore, u = E === void 0 ? null : E, b = n.appStateToggleEnabled, k = b === void 0 || b;
    if (!as || N) {
      var Q = "su-".concat(vr()), S = m ?? { encrypt: function(y) {
        return y;
      }, decrypt: function(y) {
        return y;
      } }, v = new Pr({ encryption: S });
      V || (v = GT() ? u ? new dB({ AsyncStorage: u, encryption: S }) : new Pr({ encryption: S }) : new aB({ encryption: S })), new D(Q, { appId: t, appVersion: l, options: i, apiHost: s ?? "https://api-".concat(t, ".sendbird.com"), websocketHost: o ?? "wss://ws-".concat(t, ".sendbird.com"), store: v, encryption: S, logLevel: R, localCacheEnabled: Z, localCacheConfig: F, debugMode: V, appStateToggleEnabled: k });
      var G = [new bB(), new uX()], w = new e(Q, i, ot(ot([], et(d), !1), et(G), !1));
      return as || (as = w), w;
    }
    return as;
  }, Object.defineProperty(e, "instance", { get: function() {
    return as;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "version", { get: function() {
    return Zk;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "appId", { get: function() {
    return D.of(this._iid).sdkState.appId;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "appInfo", { get: function() {
    var n = D.of(this._iid).appInfo;
    return n ?? null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "appVersion", { get: function() {
    var n;
    return (n = D.of(this._iid).sdkState.appVersion) !== null && n !== void 0 ? n : "";
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "debugMode", { get: function() {
    return !!D.of(this._iid).debugMode;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "logLevel", { get: function() {
    return D.of(this._iid).logger.level;
  }, set: function(n) {
    D.of(this._iid).logger.level = n;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "isCacheEnabled", { get: function() {
    return D.of(this._iid).cacheContext.localCacheEnabled;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "localCacheConfig", { get: function() {
    var n = D.of(this._iid).cacheContext;
    return n.localCacheEnabled ? n.localCacheConfig : null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "ekey", { get: function() {
    return D.of(this._iid).sessionManager.ekey;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "currentUser", { get: function() {
    var n;
    return (n = D.of(this._iid).sessionManager.currentUser) !== null && n !== void 0 ? n : null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "connectionState", { get: function() {
    var n = D.of(this._iid).connectionManager;
    return n.isConnected ? Hd.OPEN : n.isConnecting ? Hd.CONNECTING : Hd.CLOSED;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "lastConnectedAt", { get: function() {
    var n = D.of(this._iid), t = n.connectedAt;
    return n.connectionManager.isConnected ? t : 0;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "fcmPushToken", { get: function() {
    var n;
    return (n = this._fcmPushToken) !== null && n !== void 0 ? n : null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "apnsPushToken", { get: function() {
    var n;
    return (n = this._apnsPushToken) !== null && n !== void 0 ? n : null;
  }, enumerable: !1, configurable: !0 }), e.prototype._getNestDBVersion = function() {
    return 6;
  }, e.prototype._getPreferenceCacheKey = function(n) {
    return "sendbird@".concat(this.appId, "/").concat(n, ".pref");
  }, e.prototype._getUserProfileCacheKey = function(n) {
    return "sendbird@".concat(this.appId, "/").concat(n, ".profile");
  }, e.prototype.getMemoryStoreForDebugging = function() {
    var n = D.of(this._iid), t = n.debugMode, l = n.cacheContext;
    if (t)
      return l.store instanceof Pr ? l.store : null;
    throw j.debugModeRequired;
  }, e.prototype.addExtension = function(n, t) {
    var l = D.of(this._iid).sdkState;
    ["sb_uikit", "sb_syncmanager", "device-os-platform"].indexOf(n) > -1 && l.extensions && (l.extensions[n] = t);
  }, e.prototype.addSendbirdExtensions = function(n, t, l) {
    var a, d, r = D.of(this._iid), i = r.logger, c = r.sdkState, V = new RegExp(Ex);
    if (n.length === 0)
      return i.debug("sb.addSendbirdExtensions() has failed because the given sendbirdExtensions is empty."), !1;
    if (n.find(function(h) {
      return !V.test(h.version);
    }))
      return i.debug("sb.addSendbirdExtensions() has failed because the given version did not satisfy the SemVer specification."), !1;
    if (l)
      try {
        for (var s = be(Object.entries(l)), o = s.next(); !o.done; o = s.next()) {
          var U = et(o.value, 2), N = U[0], R = U[1];
          if (/&|=/.test(N) || /&|=/.test(R))
            return i.debug("sb.addSendbirdExtensions() has failed because the given customData includes at least one invalid character: = or &."), !1;
        }
      } catch (h) {
        a = { error: h };
      } finally {
        try {
          o && !o.done && (d = s.return) && d.call(s);
        } finally {
          if (a)
            throw a.error;
        }
      }
    return c.sendbirdRuntimeEnvironment = { sendbirdExtensions: n, deviceOS: t, customData: l }, !0;
  }, e.prototype.setOnlineListener = function(n) {
    this._onlineDetector.setOnlineListener(n);
  }, e.prototype.setOfflineListener = function(n) {
    this._onlineDetector.setOfflineListener(n);
  }, e.prototype._safeInitializeStore = function(n) {
    return M(this, void 0, void 0, function() {
      var t;
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            t = D.of(this._iid).cacheContext, l.label = 1;
          case 1:
            return l.trys.push([1, 3, , 5]), [4, t.store.init(n)];
          case 2:
            return l.sent(), this._storeInitialized = !0, [3, 5];
          case 3:
            return l.sent(), t.replaceStore(new Pr()), [4, this._safeInitializeStore(n)];
          case 4:
            return l.sent(), [3, 5];
          case 5:
            return [2];
        }
      });
    });
  }, e.prototype.initializeCache = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c, V, s;
      return p(this, function(o) {
        switch (o.label) {
          case 0:
            if (t = D.of(this._iid), l = t.sdkState, a = t.cacheContext, d = t.dispatcher, r = t.logger, l.userId && l.userId === n)
              return [3, 9];
            if (i = "sendbird@".concat(l.appId, "/").concat(n, ".db"), !a.localCacheEnabled)
              return [3, 7];
            o.label = 1;
          case 1:
            return o.trys.push([1, 4, , 6]), a.nestdb && a.nestdb.state !== Dd.CLOSED && a.nestdb.name === i ? [3, 3] : (c = "sendbird@".concat(l.appId, "/").concat(n, ".db"), (V = a.nestdb = new rB({ name: c, version: this._getNestDBVersion(), store: a.store, config: new nU({ dbname: c, itemSizeLimit: 61440 }) })).on("upgrade", Hu(V)), V.on("storeReplaced", function(U) {
              a.replaceStore(U), a.localCacheEnabled = !1, V.on("upgrade", Hu(V));
            }), [4, V.open()]);
          case 2:
            o.sent(), this._storeInitialized = !0, d.dispatch(new w3(this._iid, { userId: n })), o.label = 3;
          case 3:
            return l.userId = n, [3, 6];
          case 4:
            return s = o.sent(), r.warn("Nest DB Open Failed. ", s), a.store instanceof Pr || (a.replaceStore(new Pr()), a.localCacheEnabled = !1), [4, this._safeInitializeStore(i)];
          case 5:
            throw o.sent(), l.userId = n, j.databaseError;
          case 6:
            return [3, 9];
          case 7:
            return [4, this._safeInitializeStore(i)];
          case 8:
            o.sent(), l.userId = n, o.label = 9;
          case 9:
            return [2];
        }
      });
    });
  }, e.prototype.getCacheDataSize = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return (n = D.of(this._iid).cacheContext).localCacheEnabled && n.nestdb ? [4, n.nestdb.estimateUsage()] : [3, 2];
          case 1:
            return [2, t.sent()];
          case 2:
            return [2, 0];
        }
      });
    });
  }, e.prototype.clearCachedData = function() {
    return M(this, void 0, void 0, function() {
      var n;
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return (n = D.of(this._iid).cacheContext).localCacheEnabled && n.nestdb ? [4, n.nestdb.clear()] : [3, 2];
          case 1:
            t.sent(), t.label = 2;
          case 2:
            return this._storeInitialized ? [4, n.preference.clear()] : [3, 4];
          case 3:
            t.sent(), t.label = 4;
          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.clearCachedMessages = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a = this;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return Ze(Jt("string", n)).throw(j.invalidParameters), t = ac.of(this._iid), l = bV.of(this._iid), t && l ? [4, Promise.all(n.map(function(r) {
              return M(a, void 0, void 0, function() {
                return p(this, function(i) {
                  switch (i.label) {
                    case 0:
                      return [4, t.removeMessagesOfChannel(r)];
                    case 1:
                      return i.sent(), [4, l.removeMessagesOfChannel(r)];
                    case 2:
                      return i.sent(), [2];
                  }
                });
              });
            }))] : [3, 2];
          case 1:
            d.sent(), d.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, e.prototype._setupPreference = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return t = D.of(this._iid), l = t.sdkState, a = t.cacheContext, d = t.statLogCollector, [4, a.preference.init(this._getPreferenceCacheKey(n), this._getNestDBVersion())];
          case 1:
            return i.sent(), [4, a.preference.get(this._getUserProfileCacheKey(n))];
          case 2:
            return (r = i.sent()) && new OT(this._iid, r).apply(), [4, d.init("sendbird@".concat(l.appId, "/").concat(n, ".statlog"))];
          case 3:
            return i.sent(), [2];
        }
      });
    });
  }, e.prototype._ready = function(n, t, l) {
    return l === void 0 && (l = {}), M(this, void 0, void 0, function() {
      var a, d, r, i, c, V;
      return p(this, function(s) {
        switch (s.label) {
          case 0:
            return Ze(B("string", n) && B("string", t, !0)).throw(j.invalidParameters), a = D.of(this._iid), d = a.sdkState, r = a.cacheContext, i = a.connectionManager, c = l.errorForOtherUser, d.userId && d.userId !== n ? c ? [3, 2] : [4, i.logout()] : [3, 3];
          case 1:
            return s.sent(), [3, 3];
          case 2:
            throw c;
          case 3:
            return s.trys.push([3, 5, 6, 8]), [4, this.initializeCache(n)];
          case 4:
            return s.sent(), D.of(this._iid).dispatcher.dispatch(new g3()), [3, 8];
          case 5:
            return s.sent(), V = D.of(this._iid).logger, r.localCacheEnabled = !1, V.warn("Cache initialization failed - cache is not available."), [3, 8];
          case 6:
            return [4, this._setupPreference(n)];
          case 7:
            return s.sent(), [7];
          case 8:
            return [2];
        }
      });
    });
  }, e.prototype.authenticateFeed = function(n, t) {
    var l;
    return M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return a = D.of(this._iid), d = a.sessionManager, r = a.connectionManager, [4, this._ready(n, t, { errorForOtherUser: r.isConnected ? j.alreadyConnectedAsAnotherUser : void 0 })];
          case 1:
            return i.sent(), !((l = d.session.services) === null || l === void 0) && l.includes(ho.CHAT) ? [3, 3] : [4, d.authenticateFeed(n, t)];
          case 2:
            i.sent(), i.label = 3;
          case 3:
            return [2, this.currentUser];
        }
      });
    });
  }, e.prototype.connect = function(n, t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._ready(n, t)];
          case 1:
            l.sent(), l.label = 2;
          case 2:
            return l.trys.push([2, , 4, 5]), [4, D.of(this._iid).connectionManager.connect(t)];
          case 3:
            return l.sent(), [3, 5];
          case 4:
            return this._onlineDetector.start(), this._appStateChangeDetector.start(), [7];
          case 5:
            return [2, this.currentUser];
        }
      });
    });
  }, e.prototype.reconnect = function() {
    var n = D.of(this._iid), t = n.connectionManager, l = n.sdkState, a = n.sessionManager.session.hasSession;
    return a && (this._appStateChangeDetector.start(), this._onlineDetector.start(), t.resetAndReconnect().then(function() {
      l.appState = "foreground";
    }).catch(function() {
    })), a;
  }, e.prototype.disconnect = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return n = D.of(this._iid), t = n.connectionManager, l = n.sdkState, a = n.requestQueue, this._appStateChangeDetector.stop(), this._onlineDetector.stop(), a.cancelAll(), [4, t.logout()];
          case 1:
            return d.sent(), [4, this.clearCachedData()];
          case 2:
            return d.sent(), l.appState = "foreground", [2];
        }
      });
    });
  }, e.prototype.disconnectWebSocket = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return n = D.of(this._iid), t = n.connectionManager, l = n.requestQueue, this._appStateChangeDetector.stop(), this._onlineDetector.stop(), l.cancelAll(), [4, t.disconnectWebSocket(!0)];
          case 1:
            return a.sent(), [2];
        }
      });
    });
  }, e.prototype.setBackgroundState = function() {
    var n = D.of(this._iid), t = n.connectionManager, l = n.sdkState, a = n.logger;
    l.appState === "foreground" && (l.appState = "background", a.debug("going background state"), t.background().catch(function(d) {
      a.debug("setBackgroundState error = ", d);
    }));
  }, e.prototype.setForegroundState = function() {
    var n = D.of(this._iid), t = n.connectionManager, l = n.sdkState, a = n.dispatcher, d = n.logger;
    l.appState === "background" && (l.appState = "foreground", d.debug("going foreground state"), t.resetAndReconnect().catch(function(r) {
      d.debug("setForgroundState error = ", r);
    }), a.dispatch(new ju()));
  }, e.prototype.setSessionHandler = function(n) {
    Ze(n instanceof j5).throw(j.invalidParameters), D.of(this._iid).sessionManager.handler = n;
  }, e.prototype.addUserEventHandler = function(n, t) {
    Ze(B("string", n) && t instanceof H5).throw(j.invalidParameters), D.of(this._iid).userEventHandlers.set(n, t);
  }, e.prototype.removeUserEventHandler = function(n) {
    D.of(this._iid).userEventHandlers.delete(n);
  }, e.prototype.removeAllUserEventHandler = function() {
    D.of(this._iid).userEventHandlers.clear();
  }, e.prototype.addConnectionHandler = function(n, t) {
    Ze(B("string", n) && t instanceof X3).throw(j.invalidParameters), D.of(this._iid).connectionHandlers.set(n, t);
  }, e.prototype.removeConnectionHandler = function(n) {
    D.of(this._iid).connectionHandlers.delete(n);
  }, e.prototype.removeAllConnectionHandler = function() {
    D.of(this._iid).connectionHandlers.clear();
  }, e.prototype.createApplicationUserListQuery = function(n) {
    return n === void 0 && (n = {}), new g5(this._iid, n);
  }, e.prototype.createBlockedUserListQuery = function(n) {
    return n === void 0 && (n = {}), new C5(this._iid, n);
  }, e.prototype.createFriendListQuery = function(n) {
    return n === void 0 && (n = {}), new P5(this._iid, n);
  }, e.prototype.createMessageSearchQuery = function(n) {
    return new uB(this._iid, n);
  }, e.prototype.createPollListQuery = function(n) {
    return new s3(this._iid, x({}, n));
  }, e.prototype.createPollVoterListQuery = function(n) {
    return new o3(this._iid, x({}, n));
  }, e.prototype.buildUserFromSerializedData = function(n) {
    var t = hi(n);
    return new xt(this._iid, xt.payloadify(t));
  }, e.prototype.updateCurrentUserInfo = function(n) {
    return n === void 0 && (n = {}), M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return t = x(x({}, EX), n), Ze(function(s) {
              return Nl(s.profileImage, !0) && B("string", s.profileUrl, !0) && B("string", s.nickname, !0);
            }(t)).throw(j.invalidParameters), this.currentUser ? (l = D.of(this._iid), a = l.sdkState, d = l.requestQueue, r = new fu(x({ userId: a.userId }, t)), [4, d.send(r)]) : [3, 2];
          case 1:
            return i = V.sent(), c = i.as(wu).user, this.currentUser && (t.nickname && (this.currentUser.nickname = c.nickname), (t.profileUrl || t.profileImage) && (this.currentUser.plainProfileUrl = c.profileUrl)), [2, c];
          case 2:
            throw j.connectionRequired;
        }
      });
    });
  }, e.prototype.updateCurrentUserInfoWithPreferredLanguages = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return Ze(Jt("string", n)).throw(j.invalidParameters), this.currentUser ? (t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new fu({ userId: l.userId, preferredLanguages: n }), [4, a.send(d)]) : [3, 2];
          case 1:
            return r = c.sent(), i = r.as(wu).user, this.currentUser && (this.currentUser.preferredLanguages = i.preferredLanguages), [2, i];
          case 2:
            throw j.connectionRequired;
        }
      });
    });
  }, e.prototype.registerFCMPushTokenForCurrentUser = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i = this;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            if (Ze(B("string", n)).throw(j.invalidParameters), !this.currentUser)
              return [3, 6];
            c.label = 1;
          case 1:
            return c.trys.push([1, 4, , 5]), t = D.of(this._iid), l = t.sessionManager, a = t.sdkState, d = t.requestQueue, l.hasDeviceToken(sl.FCM, n) ? [2, wl.SUCCESS] : (r = new QX({ userId: a.userId, token: n }), [4, d.send(r)]);
          case 2:
            return c.sent(), [4, yn(function() {
              return M(i, void 0, void 0, function() {
                return p(this, function(V) {
                  switch (V.label) {
                    case 0:
                      return l.setDeviceToken(sl.FCM, n), [4, l.saveDeviceToken()];
                    case 1:
                      return V.sent(), [2];
                  }
                });
              });
            })];
          case 3:
            return c.sent(), this._fcmPushToken = "", [2, wl.SUCCESS];
          case 4:
            return c.sent(), [2, wl.ERROR];
          case 5:
            return [3, 7];
          case 6:
            return this._fcmPushToken = n, [2, wl.PENDING];
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.unregisterFCMPushTokenForCurrentUser = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c = this;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            if (Ze(B("string", n)).throw(j.invalidParameters), !this.currentUser)
              return [3, 6];
            V.label = 1;
          case 1:
            return V.trys.push([1, 4, , 5]), t = D.of(this._iid), l = t.sessionManager, a = t.sdkState, d = t.requestQueue, r = new vX({ userId: a.userId, token: n }), [4, d.send(r)];
          case 2:
            return i = V.sent().lastDeletedAt, [4, yn(function() {
              return M(c, void 0, void 0, function() {
                return p(this, function(s) {
                  switch (s.label) {
                    case 0:
                      return l.unsetDeviceToken(sl.FCM, n), l.setDeviceTokenDeletedAt(i), [4, l.saveDeviceToken()];
                    case 1:
                      return s.sent(), [2];
                  }
                });
              });
            })];
          case 3:
            return V.sent(), this._fcmPushToken = "", [2, wl.SUCCESS];
          case 4:
            return V.sent(), [2, wl.ERROR];
          case 5:
            return [3, 7];
          case 6:
            return this._fcmPushToken = n, [2, wl.PENDING];
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.unregisterFCMPushTokenAllForCurrentUser = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r, i = this;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this.currentUser ? (n = D.of(this._iid), t = n.sessionManager, l = n.sdkState, a = n.requestQueue, d = new xX({ userId: l.userId }), [4, a.send(d)]) : [3, 3];
          case 1:
            return r = c.sent().lastDeletedAt, [4, yn(function() {
              return M(i, void 0, void 0, function() {
                return p(this, function(V) {
                  switch (V.label) {
                    case 0:
                      return t.unsetDeviceTokens(sl.FCM), t.setDeviceTokenDeletedAt(r), [4, t.saveDeviceToken()];
                    case 1:
                      return V.sent(), [2];
                  }
                });
              });
            })];
          case 2:
            c.sent(), c.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, e.prototype.registerAPNSPushTokenForCurrentUser = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i = this;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            if (Ze(B("string", n)).throw(j.invalidParameters), !this.currentUser)
              return [3, 6];
            c.label = 1;
          case 1:
            return c.trys.push([1, 4, , 5]), t = D.of(this._iid), l = t.sessionManager, a = t.sdkState, d = t.requestQueue, l.hasDeviceToken(sl.APNS, n) ? [2, wl.SUCCESS] : (r = new YX({ userId: a.userId, token: n }), [4, d.send(r)]);
          case 2:
            return c.sent(), [4, yn(function() {
              return M(i, void 0, void 0, function() {
                return p(this, function(V) {
                  switch (V.label) {
                    case 0:
                      return l.setDeviceToken(sl.APNS, n), [4, l.saveDeviceToken()];
                    case 1:
                      return V.sent(), [2];
                  }
                });
              });
            })];
          case 3:
            return c.sent(), this._apnsPushToken = "", [2, wl.SUCCESS];
          case 4:
            return c.sent(), [2, wl.ERROR];
          case 5:
            return [3, 7];
          case 6:
            return this._apnsPushToken = n, [2, wl.PENDING];
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.unregisterAPNSPushTokenForCurrentUser = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i, c = this;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            if (Ze(B("string", n)).throw(j.invalidParameters), !this.currentUser)
              return [3, 6];
            V.label = 1;
          case 1:
            return V.trys.push([1, 4, , 5]), t = D.of(this._iid), l = t.sessionManager, a = t.sdkState, d = t.requestQueue, r = new JX({ userId: a.userId, token: n }), [4, d.send(r)];
          case 2:
            return i = V.sent().lastDeletedAt, [4, yn(function() {
              return M(c, void 0, void 0, function() {
                return p(this, function(s) {
                  switch (s.label) {
                    case 0:
                      return l.unsetDeviceToken(sl.APNS, n), l.setDeviceTokenDeletedAt(i), [4, l.saveDeviceToken()];
                    case 1:
                      return s.sent(), [2];
                  }
                });
              });
            })];
          case 3:
            return V.sent(), this._apnsPushToken = "", [2, wl.SUCCESS];
          case 4:
            return V.sent(), [2, wl.ERROR];
          case 5:
            return [3, 7];
          case 6:
            return this._apnsPushToken = n, [2, wl.PENDING];
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.unregisterAPNSPushTokenAllForCurrentUser = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d, r, i = this;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this.currentUser ? (n = D.of(this._iid), t = n.sessionManager, l = n.sdkState, a = n.requestQueue, d = new zX({ userId: l.userId }), [4, a.send(d)]) : [3, 3];
          case 1:
            return r = c.sent().lastDeletedAt, [4, yn(function() {
              return M(i, void 0, void 0, function() {
                return p(this, function(V) {
                  switch (V.label) {
                    case 0:
                      return t.unsetDeviceTokens(sl.APNS), t.setDeviceTokenDeletedAt(r), [4, t.saveDeviceToken()];
                    case 1:
                      return V.sent(), [2];
                  }
                });
              });
            })];
          case 2:
            c.sent(), c.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, e.prototype.getChannelInvitationPreference = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return n = D.of(this._iid), t = n.sdkState, l = n.requestQueue, a = new BX({ userId: t.userId }), [4, l.send(a)];
          case 1:
            return d = r.sent(), [2, { autoAccept: d.as(DX).autoAccept }];
        }
      });
    });
  }, e.prototype.setChannelInvitationPreference = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(B("boolean", n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new XX({ userId: l.userId, willAutoAccept: n }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, { autoAccept: r.as(OX).autoAccept }];
        }
      });
    });
  }, e.prototype.getDoNotDisturb = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return n = D.of(this._iid), t = n.sdkState, l = n.requestQueue, a = new jX({ userId: t.userId }), [4, l.send(a)];
          case 1:
            return d = r.sent(), [2, d.as(HX).preference];
        }
      });
    });
  }, e.prototype.setDoNotDisturb = function(n, t, l, a, d, r) {
    return t === void 0 && (t = 0), l === void 0 && (l = 0), a === void 0 && (a = 0), d === void 0 && (d = 0), r === void 0 && (r = ""), M(this, void 0, void 0, function() {
      var i, c, V, s, o;
      return p(this, function(U) {
        switch (U.label) {
          case 0:
            return Ze(B("boolean", n) && B("number", t) && B("number", l) && B("number", a) && B("number", d) && B("string", r)).throw(j.invalidParameters), i = D.of(this._iid), c = i.sdkState, V = i.requestQueue, s = new fX({ userId: c.userId, doNotDisturbOn: n, startHour: t, startMin: l, endHour: a, endMin: d, timezone: r }), [4, V.send(s)];
          case 1:
            return o = U.sent(), [2, o.as(wX).preference];
        }
      });
    });
  }, e.prototype.getSnoozePeriod = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return n = D.of(this._iid), t = n.sdkState, l = n.requestQueue, a = new gX({ userId: t.userId }), [4, l.send(a)];
          case 1:
            return d = r.sent(), [2, d.as(IX).snoozePeriod];
        }
      });
    });
  }, e.prototype.setSnoozePeriod = function(n, t, l) {
    return t === void 0 && (t = 0), l === void 0 && (l = 0), M(this, void 0, void 0, function() {
      var a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            return Ze(B("boolean", n) && B("number", t) && B("number", l)).throw(j.invalidParameters), a = D.of(this._iid), d = a.sdkState, r = a.requestQueue, i = new LX({ userId: d.userId, snoozeOn: n, startTs: t, endTs: l }), [4, r.send(i)];
          case 1:
            return c = V.sent(), [2, c.as(CX).snoozePeriod];
        }
      });
    });
  }, e.prototype.getMyPushTokensByToken = function(n, t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s, o, U, N, R;
      return p(this, function(h) {
        switch (h.label) {
          case 0:
            return Ze(B("string", n) && Qt(sl, t)).throw(j.invalidParameters), l = D.of(this._iid), a = l.sdkState, d = l.requestQueue, r = l.sessionManager, i = new GX({ userId: a.userId, type: t, token: n }), [4, d.send(i)];
          case 1:
            c = h.sent(), V = c.as(yX).pushTokens;
            try {
              for (s = be(V.deviceTokens), o = s.next(); !o.done; o = s.next())
                U = o.value, r.setDeviceToken(V.type, U);
            } catch (Z) {
              N = { error: Z };
            } finally {
              try {
                o && !o.done && (R = s.return) && R.call(s);
              } finally {
                if (N)
                  throw N.error;
              }
            }
            return [4, r.saveDeviceToken()];
          case 2:
            return h.sent(), [2, V];
        }
      });
    });
  }, e.prototype.getPushTriggerOption = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return n = D.of(this._iid), t = n.sdkState, l = n.requestQueue, a = new PX({ userId: t.userId }), [4, l.send(a)];
          case 1:
            return [2, d.sent().as(AX).pushTriggerOption];
        }
      });
    });
  }, e.prototype.setPushTriggerOption = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return Ze(Qt($i, n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new qX({ userId: l.userId, pushTriggerOption: n }), [4, a.send(d)];
          case 1:
            return [2, r.sent().as($X).pushTriggerOption];
        }
      });
    });
  }, e.prototype.getPushTemplate = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return n = D.of(this._iid), t = n.sdkState, l = n.requestQueue, a = new eO({ userId: t.userId }), [4, l.send(a)];
          case 1:
            return [2, d.sent().as(tO).name];
        }
      });
    });
  }, e.prototype.setPushTemplate = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return Ze(Qt(JT, n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new nO({ userId: l.userId, templateName: n }), [4, a.send(d)];
          case 1:
            return [2, r.sent().as(lO).name];
        }
      });
    });
  }, e.prototype.blockUser = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return Ze(n instanceof xt || B("string", n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new KX({ userId: l.userId, blockedUserId: n instanceof xt ? n.userId : n }), [4, a.send(d)];
          case 1:
            return r.sent(), [2];
        }
      });
    });
  }, e.prototype.blockUserWithUserId = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return [2, this.blockUser(n)];
      });
    });
  }, e.prototype.unblockUser = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return Ze(n instanceof xt || B("string", n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new _X({ userId: l.userId, unblockedUserId: n instanceof xt ? n.userId : n }), [4, a.send(d)];
          case 1:
            return r.sent(), [2];
        }
      });
    });
  }, e.prototype.unblockUserWithUserId = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return [2, this.unblockUser(n)];
      });
    });
  }, e.prototype.getFriendChangeLogsByToken = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(B("string", n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new aO({ userId: l.userId, token: n }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(dO).changelogs];
        }
      });
    });
  }, e.prototype.getAllowFriendDiscovery = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return n = D.of(this._iid), t = n.sdkState, l = n.requestQueue, a = new UO({ userId: t.userId }), [4, l.send(a)];
          case 1:
            return d = r.sent(), [2, d.as(NO).allowFriendDiscovery];
        }
      });
    });
  }, e.prototype.setAllowFriendDiscovery = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return Ze(B("boolean", n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new RO({ userId: l.userId, allowFriendDiscovery: n }), [4, a.send(d)];
          case 1:
            return r.sent(), [2, n];
        }
      });
    });
  }, e.prototype.uploadFriendDiscoveries = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new rO({ userId: l.userId, discoveries: n }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(iO).friendDiscoveryRequestId];
        }
      });
    });
  }, e.prototype.deleteFriendDiscovery = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return [2, this.deleteFriendDiscoveries([n])];
      });
    });
  }, e.prototype.deleteFriendDiscoveries = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return Ze(Jt("string", n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new VO({ userId: l.userId, discoveryKeys: n }), [4, a.send(d)];
          case 1:
            return r.sent(), [2];
        }
      });
    });
  }, e.prototype.addFriends = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(Jt("string", n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new cO({ userId: l.userId, userIds: n }), [4, a.send(d)];
          case 1:
            return r = i.sent(), [2, r.as(sO).users];
        }
      });
    });
  }, e.prototype.deleteFriend = function(n) {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return [2, this.deleteFriends([n])];
      });
    });
  }, e.prototype.deleteFriends = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a, d;
      return p(this, function(r) {
        switch (r.label) {
          case 0:
            return Ze(Jt("string", n)).throw(j.invalidParameters), t = D.of(this._iid), l = t.sdkState, a = t.requestQueue, d = new oO({ userId: l.userId, userIds: n }), [4, a.send(d)];
          case 1:
            return r.sent(), [2];
        }
      });
    });
  }, e.prototype.getAllEmoji = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return n = D.of(this._iid).requestQueue, t = new hO(), [4, n.send(t)];
          case 1:
            return l = a.sent(), [2, l.as(ZO).emojiContainer];
        }
      });
    });
  }, e.prototype.getEmojiCategory = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new TO({ categoryId: n }), [4, t.send(l)];
          case 1:
            return a = d.sent(), [2, a.as(FO).emojiCategory];
        }
      });
    });
  }, e.prototype.getEmoji = function(n) {
    return M(this, void 0, void 0, function() {
      var t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new WO({ key: n }), [4, t.send(l)];
          case 1:
            return a = d.sent(), [2, a.as(mO).emoji];
        }
      });
    });
  }, e.prototype.getUIKitConfiguration = function() {
    return M(this, void 0, void 0, function() {
      var n, t, l, a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            return n = D.of(this._iid), Ze(n.hasExtension("sb_uikit")).throw(j.notSupportedError), t = n.requestQueue, l = new uO(), [4, t.send(l)];
          case 1:
            return a = d.sent(), [2, a.as(pO).uikitConfiguration];
        }
      });
    });
  }, e;
}();
function _t(e) {
  return typeof e == "boolean";
}
function ds(e, n) {
  return n.includes(e);
}
function EO(e) {
  return e instanceof Set;
}
function SO(e, n) {
  return Object.prototype.toString.call(e) === Object.prototype.toString.call(n);
}
function d0(e) {
  if (typeof e != "object" || e === null)
    return e;
  if (Array.isArray(e))
    return e.map((t) => d0(t));
  const n = {};
  return Object.keys(e).forEach((t) => {
    const l = t.replace(/_\w/g, (a) => a[1].toUpperCase());
    n[l] = d0(e[t]);
  }), n;
}
globalThis && globalThis.__rest;
globalThis && globalThis.__awaiter;
function cb(e, n) {
  const t = Object.assign({}, e);
  return Object.keys(n).forEach((l) => {
    Object.prototype.hasOwnProperty.call(t, l) && SO(t[l], n[l]) && (typeof n[l] == "object" && !Array.isArray(n[l]) ? t[l] = cb(t[l], n[l]) : t[l] = n[l]);
  }), t;
}
const GW = () => ({
  common: {
    enableUsingDefaultUserProfile: !1
  },
  groupChannel: {
    channel: {
      enableMention: !1,
      enableOgtag: !0,
      enableReactions: !0,
      enableReactionsSupergroup: !1,
      enableTypingIndicator: !0,
      enableVoiceMessage: !1,
      input: {
        camera: {
          enablePhoto: !0,
          enableVideo: !0
        },
        enableDocument: !0,
        gallery: {
          enablePhoto: !0,
          enableVideo: !0
        }
      },
      replyType: "quote_reply",
      threadReplySelectType: "thread",
      typingIndicatorTypes: /* @__PURE__ */ new Set(["text"]),
      enableFeedback: !1,
      enableSuggestedReplies: !1,
      showSuggestedRepliesFor: "last_message_only"
    },
    channelList: {
      enableMessageReceiptStatus: !1,
      enableTypingIndicator: !1
    },
    setting: {
      enableMessageSearch: !1
    }
  },
  openChannel: {
    channel: {
      enableOgtag: !0,
      input: {
        camera: {
          enablePhoto: !0,
          enableVideo: !0
        },
        enableDocument: !0,
        gallery: {
          enablePhoto: !0,
          enableVideo: !0
        }
      }
    }
  }
});
function kO(e) {
  return delete e.groupChannel.channel.typingIndicatorTypes, delete e.groupChannel.channel.enableFeedback, delete e.groupChannel.channel.enableSuggestedReplies, delete e.groupChannel.channel.showSuggestedRepliesFor, e;
}
const sb = () => {
  const e = GW();
  return kO(e);
}, gu = GW(), bO = sb();
var NR = globalThis && globalThis.__awaiter || function(e, n, t, l) {
  function a(d) {
    return d instanceof t ? d : new t(function(r) {
      r(d);
    });
  }
  return new (t || (t = Promise))(function(d, r) {
    function i(s) {
      try {
        V(l.next(s));
      } catch (o) {
        r(o);
      }
    }
    function c(s) {
      try {
        V(l.throw(s));
      } catch (o) {
        r(o);
      }
    }
    function V(s) {
      s.done ? d(s.value) : a(s.value).then(i, c);
    }
    V((l = l.apply(e, n || [])).next());
  });
};
const r0 = {
  items: {},
  getItem(e) {
    var n;
    return NR(this, void 0, void 0, function* () {
      return (n = r0.items[e]) !== null && n !== void 0 ? n : null;
    });
  },
  setItem(e, n) {
    return NR(this, void 0, void 0, function* () {
      r0.items[e] = n;
    });
  }
};
class YO {
  constructor(n) {
    this.storage = n ?? r0;
  }
  init(n) {
    return this.key = `sbu@${n}.uikitConfiguration`, this.get();
  }
  get safeKey() {
    if (!this.key)
      throw new Error("Please UIKitConfigManager.init() first");
    return this.key;
  }
  update(n) {
    return NR(this, void 0, void 0, function* () {
      const t = yield this.get(), l = {
        updatedAt: n.updatedAt,
        configuration: cb(t.configuration, n.configuration)
      };
      return yield this.storage.setItem(this.safeKey, JSON.stringify(l)), l;
    });
  }
  get() {
    return NR(this, void 0, void 0, function* () {
      const n = {
        updatedAt: 0,
        configuration: bO
      };
      try {
        const t = yield this.storage.getItem(this.safeKey);
        return t ? JSON.parse(t) : n;
      } catch {
        return n;
      }
    });
  }
}
function QO(e, n, t) {
  var l, a;
  t.common && _t((l = t.common) === null || l === void 0 ? void 0 : l.enableUsingDefaultUserProfile) && (e.enableUsingDefaultUserProfile = t.common.enableUsingDefaultUserProfile), n.common && _t((a = n.common) === null || a === void 0 ? void 0 : a.enableUsingDefaultUserProfile) && (e.enableUsingDefaultUserProfile = n.common.enableUsingDefaultUserProfile);
}
function JO(e, n, t) {
  vO(e, n, t), zO(e, n, t), xO(e, n, t), GO(e, n, t);
}
function vO(e, n, t) {
  var l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S, v, G, w, y, g, f, I, K, Ue, q, ae, se, le, L, $, ee, O, re, te, Qe, Ye, Se, P, ge, Me, We, De, Oe, tt, Be, He, at, Ge, $e, fe, Xe, pt, Vt, yt, xe, At, kt, Kt, ln, vt, Rt, Ke, Je, de, qe, lt, ct, Ot, zt, cn, mt, sn, hn, ft, qt, jt, Bt, Ie, it, ze, ht, Ft, X, Ne, pe, we, Nt, Ee, H, Ve;
  !((l = t.groupChannel) === null || l === void 0) && l.channel && _t((d = (a = t.groupChannel) === null || a === void 0 ? void 0 : a.channel) === null || d === void 0 ? void 0 : d.enableOgtag) && (e.channel.enableOgtag = t.groupChannel.channel.enableOgtag), !((r = n.groupChannel) === null || r === void 0) && r.channel && _t((c = (i = n.groupChannel) === null || i === void 0 ? void 0 : i.channel) === null || c === void 0 ? void 0 : c.enableOgtag) && (e.channel.enableOgtag = (s = (V = n.groupChannel) === null || V === void 0 ? void 0 : V.channel) === null || s === void 0 ? void 0 : s.enableOgtag), !((o = t.groupChannel) === null || o === void 0) && o.channel && _t((N = (U = t.groupChannel) === null || U === void 0 ? void 0 : U.channel) === null || N === void 0 ? void 0 : N.enableTypingIndicator) && (e.channel.enableTypingIndicator = (h = (R = t.groupChannel) === null || R === void 0 ? void 0 : R.channel) === null || h === void 0 ? void 0 : h.enableTypingIndicator), !((Z = n.groupChannel) === null || Z === void 0) && Z.channel && _t((F = (W = n.groupChannel) === null || W === void 0 ? void 0 : W.channel) === null || F === void 0 ? void 0 : F.enableTypingIndicator) && (e.channel.enableTypingIndicator = (E = (m = n.groupChannel) === null || m === void 0 ? void 0 : m.channel) === null || E === void 0 ? void 0 : E.enableTypingIndicator), !((u = t.groupChannel) === null || u === void 0) && u.channel && _t((k = (b = t.groupChannel) === null || b === void 0 ? void 0 : b.channel) === null || k === void 0 ? void 0 : k.enableReactions) && (e.channel.enableReactions = (S = (Q = t.groupChannel) === null || Q === void 0 ? void 0 : Q.channel) === null || S === void 0 ? void 0 : S.enableReactions), !((v = n.groupChannel) === null || v === void 0) && v.channel && _t((w = (G = n.groupChannel) === null || G === void 0 ? void 0 : G.channel) === null || w === void 0 ? void 0 : w.enableReactions) && (e.channel.enableReactions = (g = (y = n.groupChannel) === null || y === void 0 ? void 0 : y.channel) === null || g === void 0 ? void 0 : g.enableReactions), !((f = t.groupChannel) === null || f === void 0) && f.channel && _t((K = (I = t.groupChannel) === null || I === void 0 ? void 0 : I.channel) === null || K === void 0 ? void 0 : K.enableReactionsSupergroup) && (e.channel.enableReactionsSupergroup = (q = (Ue = t.groupChannel) === null || Ue === void 0 ? void 0 : Ue.channel) === null || q === void 0 ? void 0 : q.enableReactionsSupergroup), !((ae = n.groupChannel) === null || ae === void 0) && ae.channel && _t((le = (se = n.groupChannel) === null || se === void 0 ? void 0 : se.channel) === null || le === void 0 ? void 0 : le.enableReactionsSupergroup) && (e.channel.enableReactionsSupergroup = ($ = (L = n.groupChannel) === null || L === void 0 ? void 0 : L.channel) === null || $ === void 0 ? void 0 : $.enableReactionsSupergroup), !((ee = t.groupChannel) === null || ee === void 0) && ee.channel && _t((re = (O = t.groupChannel) === null || O === void 0 ? void 0 : O.channel) === null || re === void 0 ? void 0 : re.enableMention) && (e.channel.enableMention = (Qe = (te = t.groupChannel) === null || te === void 0 ? void 0 : te.channel) === null || Qe === void 0 ? void 0 : Qe.enableMention), !((Ye = n.groupChannel) === null || Ye === void 0) && Ye.channel && _t((P = (Se = n.groupChannel) === null || Se === void 0 ? void 0 : Se.channel) === null || P === void 0 ? void 0 : P.enableMention) && (e.channel.enableMention = (Me = (ge = n.groupChannel) === null || ge === void 0 ? void 0 : ge.channel) === null || Me === void 0 ? void 0 : Me.enableMention), !((We = t.groupChannel) === null || We === void 0) && We.channel && ds((Oe = (De = t.groupChannel) === null || De === void 0 ? void 0 : De.channel) === null || Oe === void 0 ? void 0 : Oe.replyType, ["none", "quote_reply", "thread"]) && (e.channel.replyType = (Be = (tt = t.groupChannel) === null || tt === void 0 ? void 0 : tt.channel) === null || Be === void 0 ? void 0 : Be.replyType), !((He = n.groupChannel) === null || He === void 0) && He.channel && ds((Ge = (at = n.groupChannel) === null || at === void 0 ? void 0 : at.channel) === null || Ge === void 0 ? void 0 : Ge.replyType, ["none", "quote_reply", "thread"]) && (e.channel.replyType = (fe = ($e = n.groupChannel) === null || $e === void 0 ? void 0 : $e.channel) === null || fe === void 0 ? void 0 : fe.replyType), !((Xe = t.groupChannel) === null || Xe === void 0) && Xe.channel && ds((Vt = (pt = t.groupChannel) === null || pt === void 0 ? void 0 : pt.channel) === null || Vt === void 0 ? void 0 : Vt.threadReplySelectType, ["thread", "parent"]) && (e.channel.threadReplySelectType = (xe = (yt = t.groupChannel) === null || yt === void 0 ? void 0 : yt.channel) === null || xe === void 0 ? void 0 : xe.threadReplySelectType), !((At = n.groupChannel) === null || At === void 0) && At.channel && ds((Kt = (kt = n.groupChannel) === null || kt === void 0 ? void 0 : kt.channel) === null || Kt === void 0 ? void 0 : Kt.threadReplySelectType, ["thread", "parent"]) && (e.channel.threadReplySelectType = (vt = (ln = n.groupChannel) === null || ln === void 0 ? void 0 : ln.channel) === null || vt === void 0 ? void 0 : vt.threadReplySelectType), !((Rt = t.groupChannel) === null || Rt === void 0) && Rt.channel && _t((Je = (Ke = t.groupChannel) === null || Ke === void 0 ? void 0 : Ke.channel) === null || Je === void 0 ? void 0 : Je.enableVoiceMessage) && (e.channel.enableVoiceMessage = (qe = (de = t.groupChannel) === null || de === void 0 ? void 0 : de.channel) === null || qe === void 0 ? void 0 : qe.enableVoiceMessage), !((lt = n.groupChannel) === null || lt === void 0) && lt.channel && _t((Ot = (ct = n.groupChannel) === null || ct === void 0 ? void 0 : ct.channel) === null || Ot === void 0 ? void 0 : Ot.enableVoiceMessage) && (e.channel.enableVoiceMessage = (cn = (zt = n.groupChannel) === null || zt === void 0 ? void 0 : zt.channel) === null || cn === void 0 ? void 0 : cn.enableVoiceMessage), !((mt = n.groupChannel) === null || mt === void 0) && mt.channel && EO((hn = (sn = n.groupChannel) === null || sn === void 0 ? void 0 : sn.channel) === null || hn === void 0 ? void 0 : hn.typingIndicatorTypes) && (e.channel.typingIndicatorTypes = (qt = (ft = n.groupChannel) === null || ft === void 0 ? void 0 : ft.channel) === null || qt === void 0 ? void 0 : qt.typingIndicatorTypes), !((jt = n.groupChannel) === null || jt === void 0) && jt.channel && _t((Ie = (Bt = n.groupChannel) === null || Bt === void 0 ? void 0 : Bt.channel) === null || Ie === void 0 ? void 0 : Ie.enableFeedback) && (e.channel.enableFeedback = (ze = (it = n.groupChannel) === null || it === void 0 ? void 0 : it.channel) === null || ze === void 0 ? void 0 : ze.enableFeedback), !((ht = n.groupChannel) === null || ht === void 0) && ht.channel && _t((X = (Ft = n.groupChannel) === null || Ft === void 0 ? void 0 : Ft.channel) === null || X === void 0 ? void 0 : X.enableSuggestedReplies) && (e.channel.enableSuggestedReplies = (pe = (Ne = n.groupChannel) === null || Ne === void 0 ? void 0 : Ne.channel) === null || pe === void 0 ? void 0 : pe.enableSuggestedReplies), !((we = n.groupChannel) === null || we === void 0) && we.channel && ds((Ee = (Nt = n.groupChannel) === null || Nt === void 0 ? void 0 : Nt.channel) === null || Ee === void 0 ? void 0 : Ee.showSuggestedRepliesFor, ["all_messages", "last_message_only"]) && (e.channel.showSuggestedRepliesFor = (Ve = (H = n.groupChannel) === null || H === void 0 ? void 0 : H.channel) === null || Ve === void 0 ? void 0 : Ve.showSuggestedRepliesFor);
}
function zO(e, n, t) {
  var l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S, v, G, w, y, g, f, I, K, Ue, q, ae, se, le, L, $, ee, O, re, te, Qe, Ye, Se, P, ge, Me, We, De, Oe, tt, Be, He, at, Ge, $e, fe, Xe, pt, Vt, yt, xe, At, kt, Kt, ln, vt, Rt, Ke, Je, de, qe, lt, ct, Ot, zt, cn, mt, sn, hn, ft, qt, jt, Bt, Ie, it, ze, ht, Ft, X, Ne, pe, we, Nt, Ee, H, Ve, ye, Zt, Mt, Ct, Ht, Sn;
  !((a = (l = t.groupChannel) === null || l === void 0 ? void 0 : l.channel) === null || a === void 0) && a.input && _t((i = (r = (d = t.groupChannel) === null || d === void 0 ? void 0 : d.channel) === null || r === void 0 ? void 0 : r.input) === null || i === void 0 ? void 0 : i.enableDocument) && (e.channel.input.enableDocument = (s = (V = (c = t.groupChannel) === null || c === void 0 ? void 0 : c.channel) === null || V === void 0 ? void 0 : V.input) === null || s === void 0 ? void 0 : s.enableDocument), !((U = (o = n.groupChannel) === null || o === void 0 ? void 0 : o.channel) === null || U === void 0) && U.input && _t((h = (R = (N = n.groupChannel) === null || N === void 0 ? void 0 : N.channel) === null || R === void 0 ? void 0 : R.input) === null || h === void 0 ? void 0 : h.enableDocument) && (e.channel.input.enableDocument = (F = (W = (Z = n.groupChannel) === null || Z === void 0 ? void 0 : Z.channel) === null || W === void 0 ? void 0 : W.input) === null || F === void 0 ? void 0 : F.enableDocument), !((u = (E = (m = t.groupChannel) === null || m === void 0 ? void 0 : m.channel) === null || E === void 0 ? void 0 : E.input) === null || u === void 0) && u.camera && _t((S = (Q = (k = (b = t.groupChannel) === null || b === void 0 ? void 0 : b.channel) === null || k === void 0 ? void 0 : k.input) === null || Q === void 0 ? void 0 : Q.camera) === null || S === void 0 ? void 0 : S.enablePhoto) && (e.channel.input.camera.enablePhoto = (y = (w = (G = (v = t.groupChannel) === null || v === void 0 ? void 0 : v.channel) === null || G === void 0 ? void 0 : G.input) === null || w === void 0 ? void 0 : w.camera) === null || y === void 0 ? void 0 : y.enablePhoto), !((I = (f = (g = n.groupChannel) === null || g === void 0 ? void 0 : g.channel) === null || f === void 0 ? void 0 : f.input) === null || I === void 0) && I.camera && _t((ae = (q = (Ue = (K = n.groupChannel) === null || K === void 0 ? void 0 : K.channel) === null || Ue === void 0 ? void 0 : Ue.input) === null || q === void 0 ? void 0 : q.camera) === null || ae === void 0 ? void 0 : ae.enablePhoto) && (e.channel.input.camera.enablePhoto = ($ = (L = (le = (se = n.groupChannel) === null || se === void 0 ? void 0 : se.channel) === null || le === void 0 ? void 0 : le.input) === null || L === void 0 ? void 0 : L.camera) === null || $ === void 0 ? void 0 : $.enablePhoto), !((re = (O = (ee = t.groupChannel) === null || ee === void 0 ? void 0 : ee.channel) === null || O === void 0 ? void 0 : O.input) === null || re === void 0) && re.camera && _t((Se = (Ye = (Qe = (te = t.groupChannel) === null || te === void 0 ? void 0 : te.channel) === null || Qe === void 0 ? void 0 : Qe.input) === null || Ye === void 0 ? void 0 : Ye.camera) === null || Se === void 0 ? void 0 : Se.enableVideo) && (e.channel.input.camera.enableVideo = (We = (Me = (ge = (P = t.groupChannel) === null || P === void 0 ? void 0 : P.channel) === null || ge === void 0 ? void 0 : ge.input) === null || Me === void 0 ? void 0 : Me.camera) === null || We === void 0 ? void 0 : We.enableVideo), !((tt = (Oe = (De = n.groupChannel) === null || De === void 0 ? void 0 : De.channel) === null || Oe === void 0 ? void 0 : Oe.input) === null || tt === void 0) && tt.camera && _t((Ge = (at = (He = (Be = n.groupChannel) === null || Be === void 0 ? void 0 : Be.channel) === null || He === void 0 ? void 0 : He.input) === null || at === void 0 ? void 0 : at.camera) === null || Ge === void 0 ? void 0 : Ge.enableVideo) && (e.channel.input.camera.enableVideo = (pt = (Xe = (fe = ($e = n.groupChannel) === null || $e === void 0 ? void 0 : $e.channel) === null || fe === void 0 ? void 0 : fe.input) === null || Xe === void 0 ? void 0 : Xe.camera) === null || pt === void 0 ? void 0 : pt.enableVideo), !((xe = (yt = (Vt = t.groupChannel) === null || Vt === void 0 ? void 0 : Vt.channel) === null || yt === void 0 ? void 0 : yt.input) === null || xe === void 0) && xe.gallery && _t((ln = (Kt = (kt = (At = t.groupChannel) === null || At === void 0 ? void 0 : At.channel) === null || kt === void 0 ? void 0 : kt.input) === null || Kt === void 0 ? void 0 : Kt.gallery) === null || ln === void 0 ? void 0 : ln.enablePhoto) && (e.channel.input.gallery.enablePhoto = (Je = (Ke = (Rt = (vt = t.groupChannel) === null || vt === void 0 ? void 0 : vt.channel) === null || Rt === void 0 ? void 0 : Rt.input) === null || Ke === void 0 ? void 0 : Ke.gallery) === null || Je === void 0 ? void 0 : Je.enablePhoto), !((lt = (qe = (de = n.groupChannel) === null || de === void 0 ? void 0 : de.channel) === null || qe === void 0 ? void 0 : qe.input) === null || lt === void 0) && lt.gallery && _t((cn = (zt = (Ot = (ct = n.groupChannel) === null || ct === void 0 ? void 0 : ct.channel) === null || Ot === void 0 ? void 0 : Ot.input) === null || zt === void 0 ? void 0 : zt.gallery) === null || cn === void 0 ? void 0 : cn.enablePhoto) && (e.channel.input.gallery.enablePhoto = (ft = (hn = (sn = (mt = n.groupChannel) === null || mt === void 0 ? void 0 : mt.channel) === null || sn === void 0 ? void 0 : sn.input) === null || hn === void 0 ? void 0 : hn.gallery) === null || ft === void 0 ? void 0 : ft.enablePhoto), !((Bt = (jt = (qt = t.groupChannel) === null || qt === void 0 ? void 0 : qt.channel) === null || jt === void 0 ? void 0 : jt.input) === null || Bt === void 0) && Bt.gallery && _t((ht = (ze = (it = (Ie = t.groupChannel) === null || Ie === void 0 ? void 0 : Ie.channel) === null || it === void 0 ? void 0 : it.input) === null || ze === void 0 ? void 0 : ze.gallery) === null || ht === void 0 ? void 0 : ht.enableVideo) && (e.channel.input.gallery.enableVideo = (pe = (Ne = (X = (Ft = t.groupChannel) === null || Ft === void 0 ? void 0 : Ft.channel) === null || X === void 0 ? void 0 : X.input) === null || Ne === void 0 ? void 0 : Ne.gallery) === null || pe === void 0 ? void 0 : pe.enableVideo), !((Ee = (Nt = (we = n.groupChannel) === null || we === void 0 ? void 0 : we.channel) === null || Nt === void 0 ? void 0 : Nt.input) === null || Ee === void 0) && Ee.gallery && _t((Zt = (ye = (Ve = (H = n.groupChannel) === null || H === void 0 ? void 0 : H.channel) === null || Ve === void 0 ? void 0 : Ve.input) === null || ye === void 0 ? void 0 : ye.gallery) === null || Zt === void 0 ? void 0 : Zt.enableVideo) && (e.channel.input.gallery.enableVideo = (Sn = (Ht = (Ct = (Mt = n.groupChannel) === null || Mt === void 0 ? void 0 : Mt.channel) === null || Ct === void 0 ? void 0 : Ct.input) === null || Ht === void 0 ? void 0 : Ht.gallery) === null || Sn === void 0 ? void 0 : Sn.enableVideo);
}
function xO(e, n, t) {
  var l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E;
  !((l = t.groupChannel) === null || l === void 0) && l.channelList && _t((d = (a = t.groupChannel) === null || a === void 0 ? void 0 : a.channelList) === null || d === void 0 ? void 0 : d.enableTypingIndicator) && (e.channelList.enableTypingIndicator = t.groupChannel.channelList.enableTypingIndicator), !((r = n.groupChannel) === null || r === void 0) && r.channelList && _t((c = (i = n.groupChannel) === null || i === void 0 ? void 0 : i.channelList) === null || c === void 0 ? void 0 : c.enableTypingIndicator) && (e.channelList.enableTypingIndicator = (s = (V = n.groupChannel) === null || V === void 0 ? void 0 : V.channelList) === null || s === void 0 ? void 0 : s.enableTypingIndicator), !((o = t.groupChannel) === null || o === void 0) && o.channelList && _t((N = (U = t.groupChannel) === null || U === void 0 ? void 0 : U.channelList) === null || N === void 0 ? void 0 : N.enableMessageReceiptStatus) && (e.channelList.enableMessageReceiptStatus = (h = (R = t.groupChannel) === null || R === void 0 ? void 0 : R.channelList) === null || h === void 0 ? void 0 : h.enableMessageReceiptStatus), !((Z = n.groupChannel) === null || Z === void 0) && Z.channelList && _t((F = (W = n.groupChannel) === null || W === void 0 ? void 0 : W.channelList) === null || F === void 0 ? void 0 : F.enableMessageReceiptStatus) && (e.channelList.enableMessageReceiptStatus = (E = (m = n.groupChannel) === null || m === void 0 ? void 0 : m.channelList) === null || E === void 0 ? void 0 : E.enableMessageReceiptStatus);
}
function GO(e, n, t) {
  var l, a, d, r, i, c, V, s;
  !((l = t.groupChannel) === null || l === void 0) && l.setting && _t((d = (a = t.groupChannel) === null || a === void 0 ? void 0 : a.setting) === null || d === void 0 ? void 0 : d.enableMessageSearch) && (e.setting.enableMessageSearch = t.groupChannel.setting.enableMessageSearch), !((r = n.groupChannel) === null || r === void 0) && r.setting && _t((c = (i = n.groupChannel) === null || i === void 0 ? void 0 : i.setting) === null || c === void 0 ? void 0 : c.enableMessageSearch) && (e.setting.enableMessageSearch = (s = (V = n.groupChannel) === null || V === void 0 ? void 0 : V.setting) === null || s === void 0 ? void 0 : s.enableMessageSearch);
}
function yO(e, n, t) {
  BO(e, n, t), DO(e, n, t);
}
function BO(e, n, t) {
  var l, a, d, r, i, c, V, s;
  !((l = t.openChannel) === null || l === void 0) && l.channel && _t((d = (a = t.openChannel) === null || a === void 0 ? void 0 : a.channel) === null || d === void 0 ? void 0 : d.enableOgtag) && (e.channel.enableOgtag = t.openChannel.channel.enableOgtag), !((r = n.openChannel) === null || r === void 0) && r.channel && _t((c = (i = n.openChannel) === null || i === void 0 ? void 0 : i.channel) === null || c === void 0 ? void 0 : c.enableOgtag) && (e.channel.enableOgtag = (s = (V = n.openChannel) === null || V === void 0 ? void 0 : V.channel) === null || s === void 0 ? void 0 : s.enableOgtag);
}
function DO(e, n, t) {
  var l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S, v, G, w, y, g, f, I, K, Ue, q, ae, se, le, L, $, ee, O, re, te, Qe, Ye, Se, P, ge, Me, We, De, Oe, tt, Be, He, at, Ge, $e, fe, Xe, pt, Vt, yt, xe, At, kt, Kt, ln, vt, Rt, Ke, Je, de, qe, lt, ct, Ot, zt, cn, mt, sn, hn, ft, qt, jt, Bt, Ie, it, ze, ht, Ft, X, Ne, pe, we, Nt, Ee, H, Ve, ye, Zt, Mt, Ct, Ht, Sn;
  !((a = (l = t.openChannel) === null || l === void 0 ? void 0 : l.channel) === null || a === void 0) && a.input && _t((i = (r = (d = t.openChannel) === null || d === void 0 ? void 0 : d.channel) === null || r === void 0 ? void 0 : r.input) === null || i === void 0 ? void 0 : i.enableDocument) && (e.channel.input.enableDocument = (s = (V = (c = t.openChannel) === null || c === void 0 ? void 0 : c.channel) === null || V === void 0 ? void 0 : V.input) === null || s === void 0 ? void 0 : s.enableDocument), !((U = (o = n.openChannel) === null || o === void 0 ? void 0 : o.channel) === null || U === void 0) && U.input && _t((h = (R = (N = n.openChannel) === null || N === void 0 ? void 0 : N.channel) === null || R === void 0 ? void 0 : R.input) === null || h === void 0 ? void 0 : h.enableDocument) && (e.channel.input.enableDocument = (F = (W = (Z = n.openChannel) === null || Z === void 0 ? void 0 : Z.channel) === null || W === void 0 ? void 0 : W.input) === null || F === void 0 ? void 0 : F.enableDocument), !((u = (E = (m = t.openChannel) === null || m === void 0 ? void 0 : m.channel) === null || E === void 0 ? void 0 : E.input) === null || u === void 0) && u.camera && _t((S = (Q = (k = (b = t.openChannel) === null || b === void 0 ? void 0 : b.channel) === null || k === void 0 ? void 0 : k.input) === null || Q === void 0 ? void 0 : Q.camera) === null || S === void 0 ? void 0 : S.enablePhoto) && (e.channel.input.camera.enablePhoto = (y = (w = (G = (v = t.openChannel) === null || v === void 0 ? void 0 : v.channel) === null || G === void 0 ? void 0 : G.input) === null || w === void 0 ? void 0 : w.camera) === null || y === void 0 ? void 0 : y.enablePhoto), !((I = (f = (g = n.openChannel) === null || g === void 0 ? void 0 : g.channel) === null || f === void 0 ? void 0 : f.input) === null || I === void 0) && I.camera && _t((ae = (q = (Ue = (K = n.openChannel) === null || K === void 0 ? void 0 : K.channel) === null || Ue === void 0 ? void 0 : Ue.input) === null || q === void 0 ? void 0 : q.camera) === null || ae === void 0 ? void 0 : ae.enablePhoto) && (e.channel.input.camera.enablePhoto = ($ = (L = (le = (se = n.openChannel) === null || se === void 0 ? void 0 : se.channel) === null || le === void 0 ? void 0 : le.input) === null || L === void 0 ? void 0 : L.camera) === null || $ === void 0 ? void 0 : $.enablePhoto), !((re = (O = (ee = t.openChannel) === null || ee === void 0 ? void 0 : ee.channel) === null || O === void 0 ? void 0 : O.input) === null || re === void 0) && re.camera && _t((Se = (Ye = (Qe = (te = t.openChannel) === null || te === void 0 ? void 0 : te.channel) === null || Qe === void 0 ? void 0 : Qe.input) === null || Ye === void 0 ? void 0 : Ye.camera) === null || Se === void 0 ? void 0 : Se.enableVideo) && (e.channel.input.camera.enableVideo = (We = (Me = (ge = (P = t.openChannel) === null || P === void 0 ? void 0 : P.channel) === null || ge === void 0 ? void 0 : ge.input) === null || Me === void 0 ? void 0 : Me.camera) === null || We === void 0 ? void 0 : We.enableVideo), !((tt = (Oe = (De = n.openChannel) === null || De === void 0 ? void 0 : De.channel) === null || Oe === void 0 ? void 0 : Oe.input) === null || tt === void 0) && tt.camera && _t((Ge = (at = (He = (Be = n.openChannel) === null || Be === void 0 ? void 0 : Be.channel) === null || He === void 0 ? void 0 : He.input) === null || at === void 0 ? void 0 : at.camera) === null || Ge === void 0 ? void 0 : Ge.enableVideo) && (e.channel.input.camera.enableVideo = (pt = (Xe = (fe = ($e = n.openChannel) === null || $e === void 0 ? void 0 : $e.channel) === null || fe === void 0 ? void 0 : fe.input) === null || Xe === void 0 ? void 0 : Xe.camera) === null || pt === void 0 ? void 0 : pt.enableVideo), !((xe = (yt = (Vt = t.openChannel) === null || Vt === void 0 ? void 0 : Vt.channel) === null || yt === void 0 ? void 0 : yt.input) === null || xe === void 0) && xe.gallery && _t((ln = (Kt = (kt = (At = t.openChannel) === null || At === void 0 ? void 0 : At.channel) === null || kt === void 0 ? void 0 : kt.input) === null || Kt === void 0 ? void 0 : Kt.gallery) === null || ln === void 0 ? void 0 : ln.enablePhoto) && (e.channel.input.gallery.enablePhoto = (Je = (Ke = (Rt = (vt = t.openChannel) === null || vt === void 0 ? void 0 : vt.channel) === null || Rt === void 0 ? void 0 : Rt.input) === null || Ke === void 0 ? void 0 : Ke.gallery) === null || Je === void 0 ? void 0 : Je.enablePhoto), !((lt = (qe = (de = n.openChannel) === null || de === void 0 ? void 0 : de.channel) === null || qe === void 0 ? void 0 : qe.input) === null || lt === void 0) && lt.gallery && _t((cn = (zt = (Ot = (ct = n.openChannel) === null || ct === void 0 ? void 0 : ct.channel) === null || Ot === void 0 ? void 0 : Ot.input) === null || zt === void 0 ? void 0 : zt.gallery) === null || cn === void 0 ? void 0 : cn.enablePhoto) && (e.channel.input.gallery.enablePhoto = (ft = (hn = (sn = (mt = n.openChannel) === null || mt === void 0 ? void 0 : mt.channel) === null || sn === void 0 ? void 0 : sn.input) === null || hn === void 0 ? void 0 : hn.gallery) === null || ft === void 0 ? void 0 : ft.enablePhoto), !((Bt = (jt = (qt = t.openChannel) === null || qt === void 0 ? void 0 : qt.channel) === null || jt === void 0 ? void 0 : jt.input) === null || Bt === void 0) && Bt.gallery && _t((ht = (ze = (it = (Ie = t.openChannel) === null || Ie === void 0 ? void 0 : Ie.channel) === null || it === void 0 ? void 0 : it.input) === null || ze === void 0 ? void 0 : ze.gallery) === null || ht === void 0 ? void 0 : ht.enableVideo) && (e.channel.input.gallery.enableVideo = (pe = (Ne = (X = (Ft = t.openChannel) === null || Ft === void 0 ? void 0 : Ft.channel) === null || X === void 0 ? void 0 : X.input) === null || Ne === void 0 ? void 0 : Ne.gallery) === null || pe === void 0 ? void 0 : pe.enableVideo), !((Ee = (Nt = (we = n.openChannel) === null || we === void 0 ? void 0 : we.channel) === null || Nt === void 0 ? void 0 : Nt.input) === null || Ee === void 0) && Ee.gallery && _t((Zt = (ye = (Ve = (H = n.openChannel) === null || H === void 0 ? void 0 : H.channel) === null || Ve === void 0 ? void 0 : Ve.input) === null || ye === void 0 ? void 0 : ye.gallery) === null || Zt === void 0 ? void 0 : Zt.enableVideo) && (e.channel.input.gallery.enableVideo = (Sn = (Ht = (Ct = (Mt = n.openChannel) === null || Mt === void 0 ? void 0 : Mt.channel) === null || Ct === void 0 ? void 0 : Ct.input) === null || Ht === void 0 ? void 0 : Ht.gallery) === null || Sn === void 0 ? void 0 : Sn.enableVideo);
}
function XO(e, n) {
  const t = GW();
  return QO(t.common, e, n), JO(t.groupChannel, e, n), yO(t.openChannel, e, n), t;
}
function OO(e) {
  return typeof e == "object" && "configuration" in e && "updated_at" in e;
}
var jO = globalThis && globalThis.__awaiter || function(e, n, t, l) {
  function a(d) {
    return d instanceof t ? d : new t(function(r) {
      r(d);
    });
  }
  return new (t || (t = Promise))(function(d, r) {
    function i(s) {
      try {
        V(l.next(s));
      } catch (o) {
        r(o);
      }
    }
    function c(s) {
      try {
        V(l.throw(s));
      } catch (o) {
        r(o);
      }
    }
    function V(s) {
      s.done ? d(s.value) : a(s.value).then(i, c);
    }
    V((l = l.apply(e, n || [])).next());
  });
};
function rs(e) {
  var n, t;
  return (t = (n = e.appInfo) === null || n === void 0 ? void 0 : n.applicationAttributes) !== null && t !== void 0 ? t : [];
}
const ob = _l({
  initDashboardConfigs: () => Promise.resolve(),
  configs: gu,
  configsWithAppAttr: () => gu
}), HO = ({ storage: e, children: n, localConfigs: t = {} }) => {
  const [l, a] = me(sb), [d] = me(() => new YO(e)), r = Pt((V) => jO(void 0, void 0, void 0, function* () {
    const s = yield d.init(V.appId);
    if (V.appInfo && V.appInfo.uikitConfigInfo.lastUpdatedAt === s.updatedAt)
      a(s.configuration);
    else
      try {
        const o = yield V.getUIKitConfiguration();
        if (OO(o.json)) {
          const U = d0(o.json), N = yield d.update(U);
          a(N.configuration);
        }
      } catch {
        a(s.configuration);
      }
  }), [d]), i = XO(t, l), c = lU((V) => ({
    groupChannel: {
      channel: {
        get enableReactions() {
          return i.groupChannel.channel.enableReactions && rs(V).includes(es.reactions);
        },
        get enableReactionsSupergroup() {
          return i.groupChannel.channel.enableReactionsSupergroup && rs(V).includes(es.reactions);
        },
        get enableOgtag() {
          return i.groupChannel.channel.enableOgtag && rs(V).includes(es.enable_og_tag);
        }
      },
      setting: {
        get enableMessageSearch() {
          return i.groupChannel.setting.enableMessageSearch && rs(V).includes(es.message_search_v3);
        }
      }
    },
    openChannel: {
      channel: {
        get enableOgtag() {
          return i.openChannel.channel.enableOgtag && rs(V).includes(es.enable_og_tag);
        }
      }
    }
  }));
  return T.createElement(ob.Provider, { value: { initDashboardConfigs: r, configs: i, configsWithAppAttr: c } }, n);
}, fO = () => Gt(ob);
var Ub = T.createContext(null);
/*!
 * css-vars-ponyfill
 * v2.4.8
 * https://jhildenbiddle.github.io/css-vars-ponyfill/
 * (c) 2018-2022 John Hildenbiddle <http://hildenbiddle.com>
 * MIT license
 */
function Ua() {
  return Ua = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, Ua.apply(this, arguments);
}
/*!
 * get-css-data
 * v2.1.0
 * https://github.com/jhildenbiddle/get-css-data
 * (c) 2018-2022 John Hildenbiddle <http://hildenbiddle.com>
 * MIT license
 */
function Iu(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = {
    mimeType: n.mimeType || null,
    onBeforeSend: n.onBeforeSend || Function.prototype,
    onSuccess: n.onSuccess || Function.prototype,
    onError: n.onError || Function.prototype,
    onComplete: n.onComplete || Function.prototype
  }, l = Array.isArray(e) ? e : [e], a = Array.apply(null, Array(l.length)).map(function(V) {
    return null;
  });
  function d(V) {
    var s = typeof V == "string", o = s && V.trim().charAt(0) === "<";
    return s && !o;
  }
  function r(V, s) {
    t.onError(V, l[s], s);
  }
  function i(V, s) {
    var o = t.onSuccess(V, l[s], s);
    V = o === !1 ? "" : o || V, a[s] = V, a.indexOf(null) === -1 && t.onComplete(a);
  }
  var c = document.createElement("a");
  l.forEach(function(V, s) {
    c.setAttribute("href", V), c.href = String(c.href);
    var o = !!(document.all && !window.atob), U = o && c.host.split(":")[0] !== location.host.split(":")[0];
    if (U) {
      var N = c.protocol === location.protocol;
      if (N) {
        var R = new XDomainRequest();
        R.open("GET", V), R.timeout = 0, R.onprogress = Function.prototype, R.ontimeout = Function.prototype, R.onload = function() {
          var Z = R.responseText;
          d(Z) ? i(Z, s) : r(R, s);
        }, R.onerror = function(Z) {
          r(R, s);
        }, setTimeout(function() {
          R.send();
        }, 0);
      } else
        console.warn("Internet Explorer 9 Cross-Origin (CORS) requests must use the same protocol (".concat(V, ")")), r(null, s);
    } else {
      var h = new XMLHttpRequest();
      h.open("GET", V), t.mimeType && h.overrideMimeType && h.overrideMimeType(t.mimeType), t.onBeforeSend(h, V, s), h.onreadystatechange = function() {
        if (h.readyState === 4) {
          var Z = h.responseText;
          h.status < 400 && d(Z) || h.status === 0 && d(Z) ? i(Z, s) : r(h, s);
        }
      }, h.send();
    }
  });
}
/**
 * Gets CSS data from <style> and <link> nodes (including @imports), then
 * returns data in order processed by DOM. Allows specifying nodes to
 * include/exclude and filtering CSS data using RegEx.
 *
 * @preserve
 * @param {object}   [options] The options object
 * @param {object}   [options.rootElement=document] Root element to traverse for
 *                   <link> and <style> nodes.
 * @param {string}   [options.include] CSS selector matching <link> and <style>
 *                   nodes to include
 * @param {string}   [options.exclude] CSS selector matching <link> and <style>
 *                   nodes to exclude
 * @param {object}   [options.filter] Regular expression used to filter node CSS
 *                   data. Each block of CSS data is tested against the filter,
 *                   and only matching data is included.
 * @param {boolean}  [options.skipDisabled=true] Determines if disabled
 *                   stylesheets will be skipped while collecting CSS data.
 * @param {boolean}  [options.useCSSOM=false] Determines if CSS data will be
 *                   collected from a stylesheet's runtime values instead of its
 *                   text content. This is required to get accurate CSS data
 *                   when a stylesheet has been modified using the deleteRule()
 *                   or insertRule() methods because these modifications will
 *                   not be reflected in the stylesheet's text content.
 * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes
 *                   1) the XHR object, 2) source node reference, and 3) the
 *                   source URL as arguments.
 * @param {function} [options.onSuccess] Callback on each CSS node read. Passes
 *                   1) CSS text, 2) source node reference, and 3) the source
 *                   URL as arguments.
 * @param {function} [options.onError] Callback on each error. Passes 1) the XHR
 *                   object for inspection, 2) soure node reference, and 3) the
 *                   source URL that failed (either a <link> href or an @import)
 *                   as arguments
 * @param {function} [options.onComplete] Callback after all nodes have been
 *                   processed. Passes 1) concatenated CSS text, 2) an array of
 *                   CSS text in DOM order, and 3) an array of nodes in DOM
 *                   order as arguments.
 *
 * @example
 *
 *   getCssData({
 *     rootElement : document,
 *     include     : 'style,link[rel="stylesheet"]',
 *     exclude     : '[href="skip.css"]',
 *     filter      : /red/,
 *     skipDisabled: true,
 *     useCSSOM    : false,
 *     onBeforeSend(xhr, node, url) {
 *       // ...
 *     }
 *     onSuccess(cssText, node, url) {
 *       // ...
 *     }
 *     onError(xhr, node, url) {
 *       // ...
 *     },
 *     onComplete(cssText, cssArray, nodeArray) {
 *       // ...
 *     }
 *   });
 */
function Lu(e) {
  var n = {
    cssComments: /\/\*[\s\S]+?\*\//g,
    cssImports: /(?:@import\s*)(?:url\(\s*)?(?:['"])([^'"]*)(?:['"])(?:\s*\))?(?:[^;]*;)/g
  }, t = {
    rootElement: e.rootElement || document,
    include: e.include || 'style,link[rel="stylesheet"]',
    exclude: e.exclude || null,
    filter: e.filter || null,
    skipDisabled: e.skipDisabled !== !1,
    useCSSOM: e.useCSSOM || !1,
    onBeforeSend: e.onBeforeSend || Function.prototype,
    onSuccess: e.onSuccess || Function.prototype,
    onError: e.onError || Function.prototype,
    onComplete: e.onComplete || Function.prototype
  }, l = Array.apply(null, t.rootElement.querySelectorAll(t.include)).filter(function(V) {
    return !wO(V, t.exclude);
  }), a = Array.apply(null, Array(l.length)).map(function(V) {
    return null;
  });
  function d() {
    var V = a.indexOf(null) === -1;
    if (V) {
      a.reduce(function(o, U, N) {
        return U === "" && o.push(N), o;
      }, []).reverse().forEach(function(o) {
        return [l, a].forEach(function(U) {
          return U.splice(o, 1);
        });
      });
      var s = a.join("");
      t.onComplete(s, a, l);
    }
  }
  function r(V, s, o, U) {
    var N = t.onSuccess(V, o, U);
    V = N !== void 0 && !N ? "" : N || V, c(V, o, U, function(R, h) {
      a[s] === null && (h.forEach(function(Z) {
        return t.onError(Z.xhr, o, Z.url);
      }), !t.filter || t.filter.test(R) ? a[s] = R : a[s] = "", d());
    });
  }
  function i(V, s) {
    var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], U = {};
    return U.rules = (V.replace(n.cssComments, "").match(n.cssImports) || []).filter(function(N) {
      return o.indexOf(N) === -1;
    }), U.urls = U.rules.map(function(N) {
      return N.replace(n.cssImports, "$1");
    }), U.absoluteUrls = U.urls.map(function(N) {
      return pZ(N, s);
    }), U.absoluteRules = U.rules.map(function(N, R) {
      var h = U.urls[R], Z = pZ(U.absoluteUrls[R], s);
      return N.replace(h, Z);
    }), U;
  }
  function c(V, s, o, U) {
    var N = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], R = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [], h = i(V, o, R);
    h.rules.length ? Iu(h.absoluteUrls, {
      onBeforeSend: function(W, F, m) {
        t.onBeforeSend(W, s, F);
      },
      onSuccess: function(W, F, m) {
        var E = t.onSuccess(W, s, F);
        W = E === !1 ? "" : E || W;
        var u = i(W, F, R);
        return u.rules.forEach(function(b, k) {
          W = W.replace(b, u.absoluteRules[k]);
        }), W;
      },
      onError: function(W, F, m) {
        N.push({
          xhr: W,
          url: F
        }), R.push(h.rules[m]), c(V, s, o, U, N, R);
      },
      onComplete: function(W) {
        W.forEach(function(F, m) {
          V = V.replace(h.rules[m], F);
        }), c(V, s, o, U, N, R);
      }
    }) : U(V, N);
  }
  l.length ? l.forEach(function(V, s) {
    var o = V.getAttribute("href"), U = V.getAttribute("rel"), N = V.nodeName.toLowerCase() === "link" && o && U && U.toLowerCase().indexOf("stylesheet") !== -1, R = t.skipDisabled === !1 ? !1 : V.disabled, h = V.nodeName.toLowerCase() === "style";
    if (N && !R) {
      var Z = o.indexOf("data:text/css") !== -1;
      if (Z) {
        var W = decodeURIComponent(o.substring(o.indexOf(",") + 1));
        t.useCSSOM && (W = Array.apply(null, V.sheet.cssRules).map(function(m) {
          return m.cssText;
        }).join("")), r(W, s, V, location.href);
      } else
        Iu(o, {
          mimeType: "text/css",
          onBeforeSend: function(E, u, b) {
            t.onBeforeSend(E, V, u);
          },
          onSuccess: function(E, u, b) {
            var k = pZ(o);
            r(E, s, V, k);
          },
          onError: function(E, u, b) {
            a[s] = "", t.onError(E, V, u), d();
          }
        });
    } else if (h && !R) {
      var F = V.textContent;
      t.useCSSOM && (F = Array.apply(null, V.sheet.cssRules).map(function(m) {
        return m.cssText;
      }).join("")), r(F, s, V, location.href);
    } else
      a[s] = "", d();
  }) : t.onComplete("", []);
}
function pZ(e, n) {
  var t = document.implementation.createHTMLDocument(""), l = t.createElement("base"), a = t.createElement("a");
  return t.head.appendChild(l), t.body.appendChild(a), l.href = n || document.baseURI || (document.querySelector("base") || {}).href || location.href, a.href = e, a.href;
}
function wO(e, n) {
  var t = e.matches || e.matchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector;
  return t.call(e, n);
}
var Nb = Rb;
function Rb(e, n, t) {
  e instanceof RegExp && (e = Cu(e, t)), n instanceof RegExp && (n = Cu(n, t));
  var l = hb(e, n, t);
  return l && {
    start: l[0],
    end: l[1],
    pre: t.slice(0, l[0]),
    body: t.slice(l[0] + e.length, l[1]),
    post: t.slice(l[1] + n.length)
  };
}
function Cu(e, n) {
  var t = n.match(e);
  return t ? t[0] : null;
}
Rb.range = hb;
function hb(e, n, t) {
  var l, a, d, r, i, c = t.indexOf(e), V = t.indexOf(n, c + 1), s = c;
  if (c >= 0 && V > 0) {
    if (e === n)
      return [c, V];
    for (l = [], d = t.length; s >= 0 && !i; )
      s == c ? (l.push(s), c = t.indexOf(e, s + 1)) : l.length == 1 ? i = [l.pop(), V] : (a = l.pop(), a < d && (d = a, r = V), V = t.indexOf(n, s + 1)), s = c < V && c >= 0 ? c : V;
    l.length && (i = [d, r]);
  }
  return i;
}
function yW(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = {
    preserveStatic: !0,
    removeComments: !1
  }, l = Ua({}, t, n), a = [];
  function d(y) {
    throw new Error("CSS parse error: ".concat(y));
  }
  function r(y) {
    var g = y.exec(e);
    if (g)
      return e = e.slice(g[0].length), g;
  }
  function i() {
    return r(/^{\s*/);
  }
  function c() {
    return r(/^}/);
  }
  function V() {
    r(/^\s*/);
  }
  function s() {
    if (V(), !(e[0] !== "/" || e[1] !== "*")) {
      for (var y = 2; e[y] && (e[y] !== "*" || e[y + 1] !== "/"); )
        y++;
      if (!e[y])
        return d("end of comment is missing");
      var g = e.slice(2, y);
      return e = e.slice(y + 2), {
        type: "comment",
        comment: g
      };
    }
  }
  function o() {
    for (var y = [], g; g = s(); )
      y.push(g);
    return l.removeComments ? [] : y;
  }
  function U() {
    for (V(); e[0] === "}"; )
      d("extra closing bracket");
    var y = r(/^(("(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^{])+)/);
    if (y) {
      var g = y[0].trim(), f, I = /\/\*/.test(g);
      I && (g = g.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, ""));
      var K = /["']\w*,\w*["']/.test(g);
      K && (g = g.replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(q) {
        return q.replace(/,/g, "‌");
      }));
      var Ue = /,/.test(g);
      return Ue ? f = g.split(/\s*(?![^(]*\)),\s*/) : f = [g], K && (f = f.map(function(q) {
        return q.replace(/\u200C/g, ",");
      })), f;
    }
  }
  function N() {
    if (e[0] === "@")
      return v();
    r(/^([;\s]*)+/);
    var y = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, g = r(/^(\*?[-#/*\\\w.]+(\[[0-9a-z_-]+\])?)\s*/);
    if (g) {
      if (g = g[0].trim(), !r(/^:\s*/))
        return d("property missing ':'");
      var f = r(/^((?:\/\*.*?\*\/|'(?:\\'|.)*?'|"(?:\\"|.)*?"|\((\s*'(?:\\'|.)*?'|"(?:\\"|.)*?"|[^)]*?)\s*\)|[^};])+)/), I = {
        type: "declaration",
        property: g.replace(y, ""),
        value: f ? f[0].replace(y, "").trim() : ""
      };
      return r(/^[;\s]*/), I;
    }
  }
  function R() {
    if (!i())
      return d("missing '{'");
    for (var y, g = o(); y = N(); )
      g.push(y), g = g.concat(o());
    return c() ? g : d("missing '}'");
  }
  function h() {
    V();
    for (var y = [], g; g = r(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/); )
      y.push(g[1]), r(/^,\s*/);
    if (y.length)
      return {
        type: "keyframe",
        values: y,
        declarations: R()
      };
  }
  function Z() {
    var y = r(/^@([-\w]+)?keyframes\s*/);
    if (y) {
      var g = y[1];
      if (y = r(/^([-\w]+)\s*/), !y)
        return d("@keyframes missing name");
      var f = y[1];
      if (!i())
        return d("@keyframes missing '{'");
      for (var I, K = o(); I = h(); )
        K.push(I), K = K.concat(o());
      return c() ? {
        type: "keyframes",
        name: f,
        vendor: g,
        keyframes: K
      } : d("@keyframes missing '}'");
    }
  }
  function W() {
    var y = r(/^@page */);
    if (y) {
      var g = U() || [];
      return {
        type: "page",
        selectors: g,
        declarations: R()
      };
    }
  }
  function F() {
    var y = r(/@(top|bottom|left|right)-(left|center|right|top|middle|bottom)-?(corner)?\s*/);
    if (y) {
      var g = "".concat(y[1], "-").concat(y[2]) + (y[3] ? "-".concat(y[3]) : "");
      return {
        type: "page-margin-box",
        name: g,
        declarations: R()
      };
    }
  }
  function m() {
    var y = r(/^@font-face\s*/);
    if (y)
      return {
        type: "font-face",
        declarations: R()
      };
  }
  function E() {
    var y = r(/^@supports *([^{]+)/);
    if (y)
      return {
        type: "supports",
        supports: y[1].trim(),
        rules: w()
      };
  }
  function u() {
    var y = r(/^@host\s*/);
    if (y)
      return {
        type: "host",
        rules: w()
      };
  }
  function b() {
    var y = r(/^@media([^{]+)*/);
    if (y)
      return {
        type: "media",
        media: (y[1] || "").trim(),
        rules: w()
      };
  }
  function k() {
    var y = r(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
    if (y)
      return {
        type: "custom-media",
        name: y[1].trim(),
        media: y[2].trim()
      };
  }
  function Q() {
    var y = r(/^@([-\w]+)?document *([^{]+)/);
    if (y)
      return {
        type: "document",
        document: y[2].trim(),
        vendor: y[1] ? y[1].trim() : null,
        rules: w()
      };
  }
  function S() {
    var y = r(/^@(import|charset|namespace)\s*([^;]+);/);
    if (y)
      return {
        type: y[1],
        name: y[2].trim()
      };
  }
  function v() {
    if (V(), e[0] === "@") {
      var y = S() || m() || b() || Z() || E() || Q() || k() || u() || W() || F();
      if (y && !l.preserveStatic) {
        var g = !1;
        if (y.declarations)
          g = y.declarations.some(function(I) {
            return /var\(/.test(I.value);
          });
        else {
          var f = y.keyframes || y.rules || [];
          g = f.some(function(I) {
            return (I.declarations || []).some(function(K) {
              return /var\(/.test(K.value);
            });
          });
        }
        return g ? y : {};
      }
      return y;
    }
  }
  function G() {
    if (!l.preserveStatic) {
      var y = Nb("{", "}", e);
      if (y) {
        var g = /:(?:root|host)(?![.:#(])/.test(y.pre) && /--\S*\s*:/.test(y.body), f = /var\(/.test(y.body);
        if (!g && !f)
          return e = e.slice(y.end + 1), {};
      }
    }
    var I = U() || [], K = l.preserveStatic ? R() : R().filter(function(Ue) {
      var q = I.some(function(se) {
        return /:(?:root|host)(?![.:#(])/.test(se);
      }) && /^--\S/.test(Ue.property), ae = /var\(/.test(Ue.value);
      return q || ae;
    });
    return I.length || d("selector missing"), {
      type: "rule",
      selectors: I,
      declarations: K
    };
  }
  function w(y) {
    if (!y && !i())
      return d("missing '{'");
    for (var g, f = o(); e.length && (y || e[0] !== "}") && (g = v() || G()); )
      g.type && f.push(g), f = f.concat(o());
    return !y && !c() ? d("missing '}'") : f;
  }
  return {
    type: "stylesheet",
    stylesheet: {
      rules: w(!0),
      errors: a
    }
  };
}
function Ku(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = {
    parseHost: !1,
    store: {},
    onWarning: function() {
    }
  }, l = Ua({}, t, n), a = new RegExp(":".concat(l.parseHost ? "host" : "root", "$"));
  return typeof e == "string" && (e = yW(e, l)), e.stylesheet.rules.forEach(function(d) {
    d.type !== "rule" || !d.selectors.some(function(r) {
      return a.test(r);
    }) || d.declarations.forEach(function(r, i) {
      var c = r.property, V = r.value;
      c && c.indexOf("--") === 0 && (l.store[c] = V);
    });
  }), l.store;
}
function Zb(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", t = arguments.length > 2 ? arguments[2] : void 0, l = {
    charset: function(r) {
      return "@charset " + r.name + ";";
    },
    comment: function(r) {
      return r.comment.indexOf("__CSSVARSPONYFILL") === 0 ? "/*" + r.comment + "*/" : "";
    },
    "custom-media": function(r) {
      return "@custom-media " + r.name + " " + r.media + ";";
    },
    declaration: function(r) {
      return r.property + ":" + r.value + ";";
    },
    document: function(r) {
      return "@" + (r.vendor || "") + "document " + r.document + "{" + a(r.rules) + "}";
    },
    "font-face": function(r) {
      return "@font-face{" + a(r.declarations) + "}";
    },
    host: function(r) {
      return "@host{" + a(r.rules) + "}";
    },
    import: function(r) {
      return "@import " + r.name + ";";
    },
    keyframe: function(r) {
      return r.values.join(",") + "{" + a(r.declarations) + "}";
    },
    keyframes: function(r) {
      return "@" + (r.vendor || "") + "keyframes " + r.name + "{" + a(r.keyframes) + "}";
    },
    media: function(r) {
      return "@media " + r.media + "{" + a(r.rules) + "}";
    },
    namespace: function(r) {
      return "@namespace " + r.name + ";";
    },
    page: function(r) {
      return "@page " + (r.selectors.length ? r.selectors.join(", ") : "") + "{" + a(r.declarations) + "}";
    },
    "page-margin-box": function(r) {
      return "@" + r.name + "{" + a(r.declarations) + "}";
    },
    rule: function(r) {
      var i = r.declarations;
      if (i.length)
        return r.selectors.join(",") + "{" + a(i) + "}";
    },
    supports: function(r) {
      return "@supports " + r.supports + "{" + a(r.rules) + "}";
    }
  };
  function a(d) {
    for (var r = "", i = 0; i < d.length; i++) {
      var c = d[i];
      t && t(c);
      var V = l[c.type](c);
      V && (r += V, V.length && c.selectors && (r += n));
    }
    return r;
  }
  return a(e.stylesheet.rules);
}
function Tb(e, n) {
  e.rules.forEach(function(t) {
    if (t.rules) {
      Tb(t, n);
      return;
    }
    if (t.keyframes) {
      t.keyframes.forEach(function(l) {
        l.type === "keyframe" && n(l.declarations, t);
      });
      return;
    }
    t.declarations && n(t.declarations, e);
  });
}
var gO = "--", IO = "var";
function LO(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = {
    preserveStatic: !0,
    preserveVars: !1,
    variables: {},
    onWarning: function() {
    }
  }, l = Ua({}, t, n);
  return typeof e == "string" && (e = yW(e, l)), Tb(e.stylesheet, function(a, d) {
    for (var r = 0; r < a.length; r++) {
      var i = a[r], c = i.type, V = i.property, s = i.value;
      if (c === "declaration") {
        if (!l.preserveVars && V && V.indexOf(gO) === 0) {
          a.splice(r, 1), r--;
          continue;
        }
        if (s.indexOf(IO + "(") !== -1) {
          var o = Ys(s, l);
          o !== i.value && (o = CO(o), l.preserveVars ? (a.splice(r, 0, {
            type: c,
            property: V,
            value: o
          }), r++) : i.value = o);
        }
      }
    }
  }), Zb(e);
}
function CO(e) {
  var n = /calc\(([^)]+)\)/g;
  return (e.match(n) || []).forEach(function(t) {
    var l = "calc".concat(t.split("calc").join(""));
    e = e.replace(t, l);
  }), e;
}
function Ys(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  if (e.indexOf("var(") === -1)
    return e;
  var l = Nb("(", ")", e);
  function a(r) {
    var i = r.split(",")[0].replace(/[\s\n\t]/g, ""), c = (r.match(/(?:\s*,\s*){1}(.*)?/) || [])[1], V = Object.prototype.hasOwnProperty.call(n.variables, i) ? String(n.variables[i]) : void 0, s = V || (c ? String(c) : void 0), o = t || r;
    return V || n.onWarning('variable "'.concat(i, '" is undefined')), s && s !== "undefined" && s.length > 0 ? Ys(s, n, o) : "var(".concat(o, ")");
  }
  if (l)
    if (l.pre.slice(-3) === "var") {
      var d = l.body.trim().length === 0;
      return d ? (n.onWarning("var() must contain a non-whitespace string"), e) : l.pre.slice(0, -3) + a(l.body) + Ys(l.post, n);
    } else
      return l.pre + "(".concat(Ys(l.body, n), ")") + Ys(l.post, n);
  else
    return e.indexOf("var(") !== -1 && n.onWarning('missing closing ")" in the value "'.concat(e, '"')), e;
}
var $R = typeof window < "u", _u = $R && window.CSS && window.CSS.supports && window.CSS.supports("(--a: 0)"), Ki = {
  group: 0,
  job: 0
}, $U = {
  rootElement: $R ? document : null,
  shadowDOM: !1,
  include: "style,link[rel=stylesheet]",
  exclude: "",
  variables: {},
  onlyLegacy: !0,
  preserveStatic: !0,
  preserveVars: !1,
  silent: !1,
  updateDOM: !0,
  updateURLs: !0,
  watch: null,
  onBeforeSend: function() {
  },
  onError: function() {
  },
  onWarning: function() {
  },
  onSuccess: function() {
  },
  onComplete: function() {
  },
  onFinally: function() {
  }
}, Xd = {
  cssComments: /\/\*[\s\S]+?\*\//g,
  cssKeyframes: /@(?:-\w*-)?keyframes/,
  cssMediaQueries: /@media[^{]+\{([\s\S]+?})\s*}/g,
  cssUrls: /url\((?!['"]?(?:data|http|\/\/):)['"]?([^'")]*)['"]?\)/g,
  cssVarDeclRules: /(?::(?:root|host)(?![.:#(])[\s,]*[^{]*{\s*[^}]*})/g,
  cssVarDecls: /(?:[\s;]*)(-{2}\w[\w-]*)(?:\s*:\s*)([^;]*);/g,
  cssVarFunc: /var\(\s*--[\w-]/,
  cssVars: /(?:(?::(?:root|host)(?![.:#(])[\s,]*[^{]*{\s*[^;]*;*\s*)|(?:var\(\s*))(--[^:)]+)(?:\s*[:)])/
}, Vl = {
  dom: {},
  job: {},
  user: {}
}, JN = !1, ya = null, Qs = 0, i0 = null, V0 = !1;
/**
 * Fetches, parses, and transforms CSS custom properties from specified
 * <style> and <link> elements into static values, then appends a new <style>
 * element with static values to the DOM to provide CSS custom property
 * compatibility for legacy browsers. Also provides a single interface for
 * live updates of runtime values in both modern and legacy browsers.
 *
 * @preserve
 * @param {object}   [options] Options object
 * @param {object}   [options.rootElement=document] Root element to traverse for
 *                   <link> and <style> nodes
 * @param {boolean}  [options.shadowDOM=false] Determines if shadow DOM <link>
 *                   and <style> nodes will be processed.
 * @param {string}   [options.include="style,link[rel=stylesheet]"] CSS selector
 *                   matching <link re="stylesheet"> and <style> nodes to
 *                   process
 * @param {string}   [options.exclude] CSS selector matching <link
 *                   rel="stylehseet"> and <style> nodes to exclude from those
 *                   matches by options.include
 * @param {object}   [options.variables] A map of custom property name/value
 *                   pairs. Property names can omit or include the leading
 *                   double-hyphen (—), and values specified will override
 *                   previous values
 * @param {boolean}  [options.onlyLegacy=true] Determines if the ponyfill will
 *                   only generate legacy-compatible CSS in browsers that lack
 *                   native support (i.e., legacy browsers)
 * @param {boolean}  [options.preserveStatic=true] Determines if CSS
 *                   declarations that do not reference a custom property will
 *                   be preserved in the transformed CSS
 * @param {boolean}  [options.preserveVars=false] Determines if CSS custom
 *                   property declarations will be preserved in the transformed
 *                   CSS
 * @param {boolean}  [options.silent=false] Determines if warning and error
 *                   messages will be displayed on the console
 * @param {boolean}  [options.updateDOM=true] Determines if the ponyfill will
 *                   update the DOM after processing CSS custom properties
 * @param {boolean}  [options.updateURLs=true] Determines if relative url()
 *                   paths will be converted to absolute urls in external CSS
 * @param {boolean}  [options.watch=false] Determines if a MutationObserver will
 *                   be created that will execute the ponyfill when a <link> or
 *                   <style> DOM mutation is observed
 * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes
 *                   1) the XHR object, 2) source node reference, and 3) the
 *                   source URL as arguments
 * @param {function} [options.onError] Callback after a CSS parsing error has
 *                   occurred or an XHR request has failed. Passes 1) an error
 *                   message, and 2) source node reference, 3) xhr, and 4 url as
 *                   arguments.
 * @param {function} [options.onWarning] Callback after each CSS parsing warning
 *                   has occurred. Passes 1) a warning message as an argument.
 * @param {function} [options.onSuccess] Callback after CSS data has been
 *                   collected from each node and before CSS custom properties
 *                   have been transformed. Allows modifying the CSS data before
 *                   it is transformed by returning any string value (or false
 *                   to skip). Passes 1) CSS text, 2) source node reference, and
 *                   3) the source URL as arguments.
 * @param {function} [options.onComplete] Callback after all CSS has been
 *                   processed, legacy-compatible CSS has been generated, and
 *                   (optionally) the DOM has been updated. Passes 1) a CSS
 *                   string with CSS variable values resolved, 2) an array of
 *                   output <style> node references that have been appended to
 *                   the DOM, 3) an object containing all custom properies names
 *                   and values, and 4) the ponyfill execution time in
 *                   milliseconds.
 * @param {function} [options.onFinally] Callback in modern and legacy browsers
 *                   after the ponyfill has finished all tasks. Passes 1) a
 *                   boolean indicating if the last ponyfill call resulted in a
 *                   style change, 2) a boolean indicating if the current
 *                   browser provides native support for CSS custom properties,
 *                   and 3) the ponyfill execution time in milliseconds.
 * @example
 *
 *   cssVars({
 *     rootElement   : document,
 *     shadowDOM     : false,
 *     include       : 'style,link[rel="stylesheet"]',
 *     exclude       : '',
 *     variables     : {},
 *     onlyLegacy    : true,
 *     preserveStatic: true,
 *     preserveVars  : false,
 *     silent        : false,
 *     updateDOM     : true,
 *     updateURLs    : true,
 *     watch         : false,
 *     onBeforeSend(xhr, node, url) {},
 *     onError(message, node, xhr, url) {},
 *     onWarning(message) {},
 *     onSuccess(cssText, node, url) {},
 *     onComplete(cssText, styleNode, cssVariables, benchmark) {},
 *     onFinally(hasChanged, hasNativeSupport, benchmark)
 *   });
 */
function Fr() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = "cssVars(): ", t = Ua({}, $U, e);
  function l(s, o, U, N) {
    !t.silent && window.console && console.error("".concat(n).concat(s, `
`), o), t.onError(s, o, U, N);
  }
  function a(s) {
    !t.silent && window.console && console.warn("".concat(n).concat(s)), t.onWarning(s);
  }
  function d(s) {
    t.onFinally(!!s, _u, MZ() - t.__benchmark);
  }
  if ($R) {
    if (t.watch) {
      t.watch = $U.watch, KO(t), Fr(t);
      return;
    } else
      t.watch === !1 && ya && (ya.disconnect(), ya = null);
    if (!t.__benchmark) {
      if (JN === t.rootElement) {
        _O(e);
        return;
      }
      var r = [].slice.call(t.rootElement.querySelectorAll('[data-cssvars]:not([data-cssvars="out"])'));
      if (t.__benchmark = MZ(), t.exclude = [ya ? '[data-cssvars]:not([data-cssvars=""])' : '[data-cssvars="out"]', "link[disabled]:not([data-cssvars])", t.exclude].filter(function(s) {
        return s;
      }).join(","), t.variables = qO(t.variables), r.forEach(function(s) {
        var o = s.nodeName.toLowerCase() === "style" && s.__cssVars.text, U = o && s.textContent !== s.__cssVars.text;
        o && U && (s.sheet && (s.sheet.disabled = !1), s.setAttribute("data-cssvars", ""));
      }), !ya) {
        var i = [].slice.call(t.rootElement.querySelectorAll('[data-cssvars="out"]'));
        i.forEach(function(s) {
          var o = s.getAttribute("data-cssvars-group"), U = o ? t.rootElement.querySelector('[data-cssvars="src"][data-cssvars-group="'.concat(o, '"]')) : null;
          U || s.parentNode.removeChild(s);
        }), Qs && r.length < Qs && (Qs = r.length, Vl.dom = {});
      }
    }
    if (document.readyState !== "loading")
      if (_u && t.onlyLegacy) {
        var c = !1;
        if (t.updateDOM) {
          var V = t.rootElement.host || (t.rootElement === document ? document.documentElement : t.rootElement);
          Object.keys(t.variables).forEach(function(s) {
            var o = t.variables[s];
            c = c || o !== getComputedStyle(V).getPropertyValue(s), V.style.setProperty(s, o);
          });
        }
        d(c);
      } else
        !V0 && (t.shadowDOM || t.rootElement.shadowRoot || t.rootElement.host) ? Lu({
          rootElement: $U.rootElement,
          include: $U.include,
          exclude: t.exclude,
          skipDisabled: !1,
          onSuccess: function(o, U, N) {
            var R = (U.sheet || {}).disabled && !U.__cssVars;
            return R ? !1 : (o = o.replace(Xd.cssComments, "").replace(Xd.cssMediaQueries, ""), o = (o.match(Xd.cssVarDeclRules) || []).join(""), o || !1);
          },
          onComplete: function(o, U, N) {
            Ku(o, {
              store: Vl.dom,
              onWarning: a
            }), V0 = !0, Fr(t);
          }
        }) : (JN = t.rootElement, Lu({
          rootElement: t.rootElement,
          include: t.include,
          exclude: t.exclude,
          skipDisabled: !1,
          onBeforeSend: t.onBeforeSend,
          onError: function(o, U, N) {
            var R = o.responseURL || Fb(N, location.href), h = o.statusText ? "(".concat(o.statusText, ")") : "Unspecified Error" + (o.status === 0 ? " (possibly CORS related)" : ""), Z = "CSS XHR Error: ".concat(R, " ").concat(o.status, " ").concat(h);
            l(Z, U, o, R);
          },
          onSuccess: function(o, U, N) {
            var R = (U.sheet || {}).disabled && !U.__cssVars;
            if (R)
              return !1;
            var h = U.nodeName.toLowerCase() === "link", Z = U.nodeName.toLowerCase() === "style" && o !== U.textContent, W = t.onSuccess(o, U, N);
            return o = W !== void 0 && !W ? "" : W || o, t.updateURLs && (h || Z) && (o = AO(o, N)), o;
          },
          onComplete: function(o, U) {
            var N = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], R = Ua({}, Vl.dom, Vl.user), h = !1;
            if (Vl.job = {}, N.forEach(function(k, Q) {
              var S = U[Q];
              if (k.__cssVars = k.__cssVars || {}, k.__cssVars.text = S, Xd.cssVars.test(S))
                try {
                  var v = yW(S, {
                    preserveStatic: t.preserveStatic,
                    removeComments: !0
                  });
                  Ku(v, {
                    parseHost: !!t.rootElement.host,
                    store: Vl.dom,
                    onWarning: a
                  }), k.__cssVars.tree = v;
                } catch (G) {
                  l(G.message, k);
                }
            }), Ua(Vl.job, Vl.dom), t.updateDOM ? (Ua(Vl.user, t.variables), Ua(Vl.job, Vl.user)) : (Ua(Vl.job, Vl.user, t.variables), Ua(R, t.variables)), h = Ki.job > 0 && !!(Object.keys(Vl.job).length > Object.keys(R).length || Object.keys(R).length && Object.keys(Vl.job).some(function(k) {
              return Vl.job[k] !== R[k];
            })), h)
              c0(t.rootElement), Fr(t);
            else {
              var Z = [], W = [], F = !1;
              if (t.updateDOM && Ki.job++, N.forEach(function(k, Q) {
                var S = !k.__cssVars.tree;
                if (k.__cssVars.tree)
                  try {
                    LO(k.__cssVars.tree, Ua({}, t, {
                      variables: Vl.job,
                      onWarning: a
                    }));
                    var v = Zb(k.__cssVars.tree);
                    if (t.updateDOM) {
                      var G = U[Q], w = Xd.cssVarFunc.test(G);
                      if (k.getAttribute("data-cssvars") || k.setAttribute("data-cssvars", "src"), v.length && w) {
                        var y = k.getAttribute("data-cssvars-group") || ++Ki.group, g = v.replace(/\s/g, ""), f = t.rootElement.querySelector('[data-cssvars="out"][data-cssvars-group="'.concat(y, '"]')) || document.createElement("style");
                        F = F || Xd.cssKeyframes.test(v), t.preserveStatic && k.sheet && (k.sheet.disabled = !0), f.hasAttribute("data-cssvars") || f.setAttribute("data-cssvars", "out"), g === k.textContent.replace(/\s/g, "") ? (S = !0, f && f.parentNode && (k.removeAttribute("data-cssvars-group"), f.parentNode.removeChild(f))) : g !== f.textContent.replace(/\s/g, "") && ([k, f].forEach(function(I) {
                          I.setAttribute("data-cssvars-job", Ki.job), I.setAttribute("data-cssvars-group", y);
                        }), f.textContent = v, Z.push(v), W.push(f), f.parentNode || k.parentNode.insertBefore(f, k.nextSibling));
                      }
                    } else
                      k.textContent.replace(/\s/g, "") !== v && Z.push(v);
                  } catch (I) {
                    l(I.message, k);
                  }
                S && k.setAttribute("data-cssvars", "skip"), k.hasAttribute("data-cssvars-job") || k.setAttribute("data-cssvars-job", Ki.job);
              }), Qs = t.rootElement.querySelectorAll('[data-cssvars]:not([data-cssvars="out"])').length, t.shadowDOM) {
                for (var m = [].concat(t.rootElement).concat([].slice.call(t.rootElement.querySelectorAll("*"))), E = 0, u; u = m[E]; ++E)
                  if (u.shadowRoot && u.shadowRoot.querySelector("style")) {
                    var b = Ua({}, t, {
                      rootElement: u.shadowRoot
                    });
                    Fr(b);
                  }
              }
              t.updateDOM && F && PO(t.rootElement), JN = !1, t.onComplete(Z.join(""), W, JSON.parse(JSON.stringify(Vl.job)), MZ() - t.__benchmark), d(W.length);
            }
          }
        }));
    else
      document.addEventListener("DOMContentLoaded", function s(o) {
        Fr(e), document.removeEventListener("DOMContentLoaded", s);
      });
  }
}
Fr.reset = function() {
  Ki.job = 0, Ki.group = 0, JN = !1, ya && (ya.disconnect(), ya = null), Qs = 0, i0 = null, V0 = !1;
  for (var e in Vl)
    Vl[e] = {};
};
function KO(e) {
  function n(c) {
    var V = t(c) && c.hasAttribute("disabled"), s = (c.sheet || {}).disabled;
    return V || s;
  }
  function t(c) {
    var V = c.nodeName.toLowerCase() === "link" && (c.getAttribute("rel") || "").indexOf("stylesheet") !== -1;
    return V;
  }
  function l(c) {
    return c.nodeName.toLowerCase() === "style";
  }
  function a(c) {
    var V = !1;
    if (c.type === "attributes" && t(c.target) && !n(c.target)) {
      var s = c.attributeName === "disabled", o = c.attributeName === "href", U = c.target.getAttribute("data-cssvars") === "skip", N = c.target.getAttribute("data-cssvars") === "src";
      s ? V = !U && !N : o && (U ? c.target.setAttribute("data-cssvars", "") : N && c0(e.rootElement, !0), V = !0);
    }
    return V;
  }
  function d(c) {
    var V = !1;
    if (c.type === "childList") {
      var s = l(c.target), o = c.target.getAttribute("data-cssvars") === "out";
      V = s && !o;
    }
    return V;
  }
  function r(c) {
    var V = !1;
    return c.type === "childList" && (V = [].slice.call(c.addedNodes).some(function(s) {
      var o = s.nodeType === 1, U = o && s.hasAttribute("data-cssvars"), N = l(s) && Xd.cssVars.test(s.textContent), R = !U && (t(s) || N);
      return R && !n(s);
    })), V;
  }
  function i(c) {
    var V = !1;
    return c.type === "childList" && (V = [].slice.call(c.removedNodes).some(function(s) {
      var o = s.nodeType === 1, U = o && s.getAttribute("data-cssvars") === "out", N = o && s.getAttribute("data-cssvars") === "src", R = N;
      if (N || U) {
        var h = s.getAttribute("data-cssvars-group"), Z = e.rootElement.querySelector('[data-cssvars-group="'.concat(h, '"]'));
        N && c0(e.rootElement, !0), Z && Z.parentNode.removeChild(Z);
      }
      return R;
    })), V;
  }
  window.MutationObserver && (ya && (ya.disconnect(), ya = null), ya = new MutationObserver(function(c) {
    var V = c.some(function(s) {
      return a(s) || d(s) || r(s) || i(s);
    });
    V && Fr(e);
  }), ya.observe(document.documentElement, {
    attributes: !0,
    attributeFilter: ["disabled", "href"],
    childList: !0,
    subtree: !0
  }));
}
function _O(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
  clearTimeout(i0), i0 = setTimeout(function() {
    e.__benchmark = null, Fr(e);
  }, n);
}
function PO(e) {
  var n = ["animation-name", "-moz-animation-name", "-webkit-animation-name"].filter(function(U) {
    return getComputedStyle(document.body)[U];
  })[0];
  if (n) {
    for (var t = [].slice.call(e.querySelectorAll("*")), l = [], a = "__CSSVARSPONYFILL-KEYFRAMES__", d = 0, r = t.length; d < r; d++) {
      var i = t[d], c = getComputedStyle(i)[n];
      c !== "none" && (i.style[n] += a, l.push(i));
    }
    document.body.offsetHeight;
    for (var V = 0, s = l.length; V < s; V++) {
      var o = l[V].style;
      o[n] = o[n].replace(a, "");
    }
  }
}
function AO(e, n) {
  var t = e.replace(Xd.cssComments, "").match(Xd.cssUrls) || [];
  return t.forEach(function(l) {
    var a = l.replace(Xd.cssUrls, "$1"), d = Fb(a, n);
    e = e.replace(l, l.replace(a, d));
  }), e;
}
function qO() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = /^-{2}/;
  return Object.keys(e).reduce(function(t, l) {
    var a = n.test(l) ? l : "--".concat(l.replace(/^-+/, ""));
    return t[a] = e[l], t;
  }, {});
}
function Fb(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : location.href, t = document.implementation.createHTMLDocument(""), l = t.createElement("base"), a = t.createElement("a");
  return t.head.appendChild(l), t.body.appendChild(a), l.href = n, a.href = e, a.href;
}
function MZ() {
  return $R && (window.performance || {}).now ? window.performance.now() : (/* @__PURE__ */ new Date()).getTime();
}
function c0(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, t = [].slice.call(e.querySelectorAll('[data-cssvars="skip"],[data-cssvars="src"]'));
  t.forEach(function(l) {
    return l.setAttribute("data-cssvars", "");
  }), n && (Vl.dom = {});
}
var Md = Symbol("@ts-pattern/matcher"), RR = "@ts-pattern/anonymous-select-key", s0 = function(e) {
  return !!(e && typeof e == "object");
}, vN = function(e) {
  return e && !!e[Md];
}, DV = function e(n, t, l) {
  if (s0(n)) {
    if (vN(n)) {
      var a = n[Md]().match(t), d = a.matched, r = a.selections;
      return d && r && Object.keys(r).forEach(function(c) {
        return l(c, r[c]);
      }), d;
    }
    if (!s0(t))
      return !1;
    if (Array.isArray(n))
      return !!Array.isArray(t) && n.length === t.length && n.every(function(c, V) {
        return e(c, t[V], l);
      });
    if (n instanceof Map)
      return t instanceof Map && Array.from(n.keys()).every(function(c) {
        return e(n.get(c), t.get(c), l);
      });
    if (n instanceof Set) {
      if (!(t instanceof Set))
        return !1;
      if (n.size === 0)
        return t.size === 0;
      if (n.size === 1) {
        var i = Array.from(n.values())[0];
        return vN(i) ? Array.from(t.values()).every(function(c) {
          return e(i, c, l);
        }) : t.has(i);
      }
      return Array.from(n.values()).every(function(c) {
        return t.has(c);
      });
    }
    return Object.keys(n).every(function(c) {
      var V, s = n[c];
      return (c in t || vN(V = s) && V[Md]().matcherType === "optional") && e(s, t[c], l);
    });
  }
  return Object.is(t, n);
}, pi = function e(n) {
  var t, l, a;
  return s0(n) ? vN(n) ? (t = (l = (a = n[Md]()).getSelectionKeys) == null ? void 0 : l.call(a)) != null ? t : [] : Array.isArray(n) ? Mo(n, e) : Mo(Object.values(n), e) : [];
}, Mo = function(e, n) {
  return e.reduce(function(t, l) {
    return t.concat(n(l));
  }, []);
};
function Pu(e) {
  var n;
  return (n = {})[Md] = function() {
    return { match: function(t) {
      var l = {}, a = function(d, r) {
        l[d] = r;
      };
      return t === void 0 ? (pi(e).forEach(function(d) {
        return a(d, void 0);
      }), { matched: !0, selections: l }) : { matched: DV(e, t, a), selections: l };
    }, getSelectionKeys: function() {
      return pi(e);
    }, matcherType: "optional" };
  }, n;
}
function Au(e) {
  var n;
  return (n = {})[Md] = function() {
    return { match: function(t) {
      if (!Array.isArray(t))
        return { matched: !1 };
      var l = {};
      if (t.length === 0)
        return pi(e).forEach(function(d) {
          l[d] = [];
        }), { matched: !0, selections: l };
      var a = function(d, r) {
        l[d] = (l[d] || []).concat([r]);
      };
      return { matched: t.every(function(d) {
        return DV(e, d, a);
      }), selections: l };
    }, getSelectionKeys: function() {
      return pi(e);
    } };
  }, n;
}
function qu() {
  var e, n = [].slice.call(arguments);
  return (e = {})[Md] = function() {
    return { match: function(t) {
      var l = {}, a = function(d, r) {
        l[d] = r;
      };
      return { matched: n.every(function(d) {
        return DV(d, t, a);
      }), selections: l };
    }, getSelectionKeys: function() {
      return Mo(n, pi);
    }, matcherType: "and" };
  }, e;
}
function $u() {
  var e, n = [].slice.call(arguments);
  return (e = {})[Md] = function() {
    return { match: function(t) {
      var l = {}, a = function(d, r) {
        l[d] = r;
      };
      return Mo(n, pi).forEach(function(d) {
        return a(d, void 0);
      }), { matched: n.some(function(d) {
        return DV(d, t, a);
      }), selections: l };
    }, getSelectionKeys: function() {
      return Mo(n, pi);
    }, matcherType: "or" };
  }, e;
}
function ep(e) {
  var n;
  return (n = {})[Md] = function() {
    return { match: function(t) {
      return { matched: !DV(e, t, function() {
      }) };
    }, getSelectionKeys: function() {
      return [];
    }, matcherType: "not" };
  }, n;
}
function Kd(e) {
  var n;
  return (n = {})[Md] = function() {
    return { match: function(t) {
      return { matched: !!e(t) };
    } };
  }, n;
}
function tp() {
  var e, n = [].slice.call(arguments), t = typeof n[0] == "string" ? n[0] : void 0, l = n.length === 2 ? n[1] : typeof n[0] == "string" ? void 0 : n[0];
  return (e = {})[Md] = function() {
    return { match: function(a) {
      var d, r = ((d = {})[t ?? RR] = a, d);
      return { matched: l === void 0 || DV(l, a, function(i, c) {
        r[i] = c;
      }), selections: r };
    }, getSelectionKeys: function() {
      return [t ?? RR].concat(l === void 0 ? [] : pi(l));
    } };
  }, e;
}
var Wb = Kd(function(e) {
  return !0;
}), $O = Wb, ej = Kd(function(e) {
  return typeof e == "string";
}), tj = Kd(function(e) {
  return typeof e == "number";
}), nj = Kd(function(e) {
  return typeof e == "boolean";
}), lj = Kd(function(e) {
  return typeof e == "bigint";
}), aj = Kd(function(e) {
  return typeof e == "symbol";
}), dj = Kd(function(e) {
  return e == null;
}), rj = { __proto__: null, optional: Pu, array: Au, intersection: qu, union: $u, not: ep, when: Kd, select: tp, any: Wb, _: $O, string: ej, number: tj, boolean: nj, bigint: lj, symbol: aj, nullish: dj, instanceOf: function(e) {
  return Kd(function(n) {
    return function(t) {
      return t instanceof n;
    };
  }(e));
}, typed: function() {
  return { array: Au, optional: Pu, intersection: qu, union: $u, not: ep, select: tp, when: Kd };
} };
function Va(e) {
  return new ij(e, []);
}
var ij = /* @__PURE__ */ function() {
  function e(t, l) {
    this.value = void 0, this.cases = void 0, this.value = t, this.cases = l;
  }
  var n = e.prototype;
  return n.with = function() {
    var t = [].slice.call(arguments), l = t[t.length - 1], a = [t[0]], d = [];
    return t.length === 3 && typeof t[1] == "function" ? (a.push(t[0]), d.push(t[1])) : t.length > 2 && a.push.apply(a, t.slice(1, t.length - 1)), new e(this.value, this.cases.concat([{ match: function(r) {
      var i = {}, c = !!(a.some(function(V) {
        return DV(V, r, function(s, o) {
          i[s] = o;
        });
      }) && d.every(function(V) {
        return V(r);
      }));
      return { matched: c, value: c && Object.keys(i).length ? RR in i ? i[RR] : i : r };
    }, handler: l }]));
  }, n.when = function(t, l) {
    return new e(this.value, this.cases.concat([{ match: function(a) {
      return { matched: !!t(a), value: a };
    }, handler: l }]));
  }, n.otherwise = function(t) {
    return new e(this.value, this.cases.concat([{ match: function(l) {
      return { matched: !0, value: l };
    }, handler: t }])).run();
  }, n.exhaustive = function() {
    return this.run();
  }, n.run = function() {
    for (var t = this.value, l = void 0, a = 0; a < this.cases.length; a++) {
      var d = this.cases[a], r = d.match(this.value);
      if (r.matched) {
        t = r.value, l = d.handler;
        break;
      }
    }
    if (!l) {
      var i;
      try {
        i = JSON.stringify(this.value);
      } catch {
        i = this.value;
      }
      throw new Error("Pattern matching error: no pattern matches value " + i);
    }
    return l(t, this.value);
  }, e;
}(), uV = {
  INIT_USER: "INIT_USER",
  RESET_USER: "RESET_USER",
  UPDATE_USER_INFO: "UPDATE_USER_INFO"
}, zr = function() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
    var n = Math.random() * 16 | 0, t = e === "x" ? n : n & 3 | 8;
    return t.toString(16);
  });
};
function Vj(e, n) {
  var t, l, a = me(
    // window is undefined in SSR env
    typeof window < "u" && (l = (t = window == null ? void 0 : window.navigator) === null || t === void 0 ? void 0 : t.onLine) !== null && l !== void 0 ? l : !0
  ), d = a[0], r = a[1];
  return _e(function() {
    var i = zr();
    try {
      n.warning("sdk changed", i);
      var c = new X3({
        onDisconnected: function() {
          r(!1), n.warning("onDisconnected", { isOnline: d });
        },
        onReconnectStarted: function() {
          r(!1), n.warning("onReconnectStarted", { isOnline: d });
        },
        onReconnectSucceeded: function() {
          r(!0), n.warning("onReconnectSucceeded", { isOnline: d });
        },
        onReconnectFailed: function() {
          e.reconnect(), n.warning("onReconnectFailed");
        }
      });
      e != null && e.addConnectionHandler && (e.addConnectionHandler(i, c), n.info("Added ConnectionHandler", i));
    } catch {
    }
    return function() {
      try {
        e.removeConnectionHandler(i), n.info("Removed ConnectionHandler", i);
      } catch {
      }
    };
  }, [e]), _e(function() {
    var i = function() {
      try {
        n.warning("Try reconnecting SDK"), e.connectionState !== "OPEN" && e.reconnect();
      } catch {
      }
    };
    return window.addEventListener("online", i), function() {
      window.removeEventListener("online", i);
    };
  }, [e]), _e(function() {
    var i = document.querySelector("body");
    if (!d && !(e != null && e.isCacheEnabled))
      try {
        i.classList.add("sendbird__offline"), n.info("Added class sendbird__offline to body");
      } catch {
      }
    else
      try {
        i.classList.remove("sendbird__offline"), n.info("Removed class sendbird__offline from body");
      } catch {
      }
  }, [d, e == null ? void 0 : e.isCacheEnabled]), d;
}
var cj = 2e3;
function mb(e) {
  var n = e.logger, t = e.timeout, l = e.cb, a = [], d = null, r = function(c) {
    var V = a.find(function(o) {
      return o.url === c.url;
    });
    if (V ? n.info("Channel: Mark as read already in queue", { channel: c }) : a.push(c), !d) {
      var s = a.shift();
      s && l(s), d = setInterval(function() {
        if (a.length === 0 && d) {
          clearInterval(d), d = null;
          return;
        }
        var o = a.shift();
        o && l(o);
      }, t || cj);
    }
  }, i = function() {
    a = [], d && (clearInterval(d), d = null);
  };
  return {
    push: r,
    clear: i,
    getQueue: function() {
      return a;
    }
  };
}
function BW(e, n) {
  n === void 0 && (n = []), ud(function() {
    return function() {
      e();
    };
  }, n);
}
function sj(e, n) {
  var t = this, l = e.isConnected, a = n.logger, d = nn(function() {
    return mb({
      logger: a,
      cb: function(r) {
        return ol(t, void 0, void 0, function() {
          var i;
          return Ul(this, function(c) {
            switch (c.label) {
              case 0:
                return c.trys.push([0, 2, , 3]), [4, r.markAsDelivered()];
              case 1:
                return c.sent(), [3, 3];
              case 2:
                return i = c.sent(), a.warning("Channel: Mark as delivered failed", { channel: r, error: i }), [3, 3];
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }
    });
  }, []);
  return _e(function() {
    l || d.clear();
  }, [l]), BW(function() {
    d.clear();
  }), d;
}
var oj = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t._channels = /* @__PURE__ */ new Map(), t._enteredChannelUrls = [], t;
  }
  return J(n, e), Object.defineProperty(n.prototype, "enteredChannels", { get: function() {
    var t = this;
    return this._enteredChannelUrls.map(function(l) {
      return t._channels.get(l);
    }).filter(function(l) {
      return !!l;
    });
  }, enumerable: !1, configurable: !0 }), n.prototype.isEnteredChannel = function(t) {
    return this._enteredChannelUrls.includes(t);
  }, n.prototype.enter = function(t) {
    this._enteredChannelUrls.indexOf(t) < 0 && this._enteredChannelUrls.push(t);
  }, n.prototype.exit = function(t) {
    var l = this._enteredChannelUrls.indexOf(t);
    l >= 0 && this._enteredChannelUrls.splice(l, 1);
  }, n.prototype.exitAll = function() {
    this._enteredChannelUrls = [];
  }, n.prototype.get = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2, this._channels.get(t)];
      });
    });
  }, n.prototype.upsert = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a = this;
      return p(this, function(d) {
        return l = [], t.forEach(function(r) {
          if (a._channels.has(r.url)) {
            var i = a._channels.get(r.url);
            Object.assign(i, r), l.push(i);
          } else
            a._channels.set(r.url, r), l.push(r);
        }), [2, l];
      });
    });
  }, n.prototype.remove = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return this._channels.delete(t), this.exit(t), [2];
      });
    });
  }, n.prototype.clear = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        return this._channels.clear(), this._enteredChannelUrls = [], [2];
      });
    });
  }, n;
}(ml), ub = { channelUrl: void 0, name: void 0, coverUrlOrImage: void 0, data: void 0, customType: void 0, operatorUserIds: void 0, isEphemeral: void 0 }, Uj = function(e) {
  function n(t) {
    var l = t.channelUrl, a = t.isInternalCall, d = e.call(this) || this;
    return d.method = he.GET, d.path = "".concat(a ? hx : xV, "/").concat(encodeURIComponent(l)), d;
  }
  return J(n, e), n;
}(Te), np = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.channel = new Jc(t, l), a;
  }
  return J(n, e), n;
}(ue), Nj = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.coverUrlOrImage, r = t.name, i = t.data, c = t.customType, V = t.operatorUserIds, s = t.isEphemeral;
    return (l = e.call(this) || this).method = he.POST, l.path = xV, l.params = je(Ae({ channel_url: a, cover_url: B("string", d) ? d : null, cover_file: Nl(d) ? d : null, name: r, data: i, custom_type: c, operators: V, is_ephemeral: s })), l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.channel = new Jc(t, l), a;
  }
  J(n, e);
})(ue);
var Rj = function(e) {
  function n(t) {
    var l = t.channelUrl;
    return e.call(this, { code: "ENTR", payload: { channel_url: l }, ackRequired: !0 }) || this;
  }
  return J(n, e), n;
}(Yl), pb = function(e) {
  function n(t, l, a) {
    var d, r, i = this;
    return i = e.call(this, t, "SYEV", a) || this, a.data && (i.participantCount = (d = a.data.participant_count) !== null && d !== void 0 ? d : 0, i.user = new xt(t, a.data), i.ts = (r = a.data.edge_ts) !== null && r !== void 0 ? r : 0), i;
  }
  return J(n, e), n;
}(Dr), hj = function(e) {
  function n(t) {
    var l = t.channelUrl;
    return e.call(this, { code: "EXIT", payload: { channel_url: l }, ackRequired: !0 }) || this;
  }
  return J(n, e), n;
}(Yl), Mb = function(e) {
  function n(t, l, a) {
    var d, r, i = this;
    return i = e.call(this, t, "EXIT", a) || this, a.data && (i.participantCount = (d = a.data.participant_count) !== null && d !== void 0 ? d : 0, i.user = new xt(t, a.data), i.ts = (r = a.data.edge_ts) !== null && r !== void 0 ? r : 0), i;
  }
  return J(n, e), n;
}(Dr), EZ = {}, _i = function(e) {
  function n(t, l) {
    var a = e.call(this, t, x(x({}, l), { channelType: Xt.OPEN })) || this;
    return a.subscribeChannelEvent = ut, a.unsubscribeChannelEvent = ut, a.refreshChannel = function() {
      return M(a, void 0, void 0, function() {
        return p(this, function(d) {
          return [2, ut()];
        });
      });
    }, a._openChannelCache = new oj(t), a._openChannelHandlers = /* @__PURE__ */ new Map(), a._dispatcher.on(function(d) {
      var r, i;
      if (d instanceof Wn)
        a._handleEvent(d).catch(function(o) {
          if (Il(o) && a._sdkState.appState === "foreground")
            throw o;
        });
      else if (d instanceof ua && d.stateType === tn.CONNECTED) {
        var c = a._openChannelCache.enteredChannels;
        try {
          for (var V = be(c), s = V.next(); !s.done; s = V.next())
            s.value.enter();
        } catch (o) {
          r = { error: o };
        } finally {
          try {
            s && !s.done && (i = V.return) && i.call(V);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
    }), EZ[t] || (EZ[t] = a), a;
  }
  return J(n, e), n.of = function(t) {
    return EZ[t];
  }, n.prototype.buildOpenChannelFromSerializedData = function(t) {
    var l = hi(t);
    return new Jc(this._iid, Jc.payloadify(l));
  }, n.prototype.getChannelFromCache = function(t) {
    var l;
    return M(this, void 0, void 0, function() {
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this._openChannelCache.get(t)];
          case 1:
            return [2, (l = a.sent()) !== null && l !== void 0 ? l : null];
        }
      });
    });
  }, n.prototype.upsertChannelsToCache = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        switch (l.label) {
          case 0:
            return [4, this._openChannelCache.upsert(t)];
          case 1:
            return [2, l.sent()];
        }
      });
    });
  }, n.prototype.removeChannelsFromCache = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c;
      return p(this, function(V) {
        switch (V.label) {
          case 0:
            V.trys.push([0, 5, 6, 7]), l = be(t), a = l.next(), V.label = 1;
          case 1:
            return a.done ? [3, 4] : (d = a.value, [4, this._openChannelCache.remove(d)]);
          case 2:
            V.sent(), V.label = 3;
          case 3:
            return a = l.next(), [3, 1];
          case 4:
            return [3, 7];
          case 5:
            return r = V.sent(), i = { error: r }, [3, 7];
          case 6:
            try {
              a && !a.done && (c = l.return) && c.call(l);
            } finally {
              if (i)
                throw i.error;
            }
            return [7];
          case 7:
            return [2];
        }
      });
    });
  }, n.prototype.setEnteredToCache = function(t) {
    this._openChannelCache.enter(t.url);
  }, n.prototype.setExitedToCache = function(t) {
    this._openChannelCache.exit(t.url);
  }, n.prototype._handleEvent = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S, v, G, w, y, g, f, I, K, Ue, q, ae, se, le, L, $, ee, O, re, te, Qe, Ye, Se, P, ge, Me, We, De, Oe, tt, Be, He, at, Ge, $e, fe, Xe, pt, Vt, yt, xe, At, kt, Kt, ln, vt, Rt = this;
      return p(this, function(Ke) {
        switch (Ke.label) {
          case 0:
            switch (Ke.trys.push([0, 57, , 58]), t.code) {
              case "MESG":
              case "FILE":
              case "ADMM":
              case "BRDM":
                return [3, 1];
              case "MEDI":
              case "FEDI":
              case "AEDI":
                return [3, 4];
              case "DELM":
                return [3, 7];
              case "MRCT":
                return [3, 10];
              case "MTHD":
                return [3, 13];
              case "MCNT":
                return [3, 16];
              case "PEDI":
                return [3, 27];
              case "VOTE":
                return [3, 30];
              case "SYEV":
                return [3, 33];
            }
            return [3, 56];
          case 1:
            return r = null, t.code === "MESG" ? r = t.as(JW) : t.code === "FILE" ? r = t.as(bW) : t.code !== "ADMM" && t.code != "BRDM" || (r = t.as(K3)), r ? (l = r.message, a = r.isMentioned, l.channelType !== Xt.OPEN ? [3, 3] : [4, this.getChannel(l.channelUrl, !0)]) : [3, 3];
          case 2:
            d = Ke.sent(), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                var Je, de, qe, lt, ct;
                return p(this, function(Ot) {
                  try {
                    for (Je = be(this._openChannelHandlers.values()), de = Je.next(); !de.done; de = Je.next())
                      qe = de.value, this._openChannelCache.isEnteredChannel(d.url) && (qe.onMessageReceived && qe.onMessageReceived(d, l), a && qe.onMentionReceived && qe.onMentionReceived(d, l));
                  } catch (zt) {
                    lt = { error: zt };
                  } finally {
                    try {
                      de && !de.done && (ct = Je.return) && ct.call(Je);
                    } finally {
                      if (lt)
                        throw lt.error;
                    }
                  }
                  return [2];
                });
              });
            }), Ke.label = 3;
          case 3:
            return [3, 56];
          case 4:
            return r = null, t.code === "MEDI" ? r = t.as(rR) : t.code === "FEDI" ? r = t.as(iR) : t.code === "AEDI" && (r = t.as(_3)), r ? (i = r.message, c = r.mentionCountChange, i.channelType !== Xt.OPEN ? [3, 6] : [4, this.getChannel(i.channelUrl, !0)]) : [3, 6];
          case 5:
            V = Ke.sent(), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                var Je, de, qe, lt, ct;
                return p(this, function(Ot) {
                  try {
                    for (Je = be(this._openChannelHandlers.values()), de = Je.next(); !de.done; de = Je.next())
                      qe = de.value, this._openChannelCache.isEnteredChannel(V.url) && (qe.onMessageUpdated && qe.onMessageUpdated(V, i), c > 0 && qe.onMentionReceived && qe.onMentionReceived(V, i));
                  } catch (zt) {
                    lt = { error: zt };
                  } finally {
                    try {
                      de && !de.done && (ct = Je.return) && ct.call(Je);
                    } finally {
                      if (lt)
                        throw lt.error;
                    }
                  }
                  return [2];
                });
              });
            }), Ke.label = 6;
          case 6:
            return [3, 56];
          case 7:
            return s = t.as(z3), K = s.channelUrl, Ue = s.channelType, o = s.messageId, Ue !== Xt.OPEN ? [3, 9] : [4, this.getChannel(K, !0)];
          case 8:
            U = Ke.sent(), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                var Je, de, qe, lt, ct;
                return p(this, function(Ot) {
                  try {
                    for (Je = be(this._openChannelHandlers.values()), de = Je.next(); !de.done; de = Je.next())
                      qe = de.value, this._openChannelCache.isEnteredChannel(U.url) && qe.onMessageDeleted && qe.onMessageDeleted(U, o);
                  } catch (zt) {
                    lt = { error: zt };
                  } finally {
                    try {
                      de && !de.done && (ct = Je.return) && ct.call(Je);
                    } finally {
                      if (lt)
                        throw lt.error;
                    }
                  }
                  return [2];
                });
              });
            }), Ke.label = 9;
          case 9:
            return [3, 56];
          case 10:
            return N = t.as(P3), K = N.channelUrl, Ue = N.channelType, R = N.event, Ue !== Xt.OPEN ? [3, 12] : [4, this.getChannel(K, !0)];
          case 11:
            h = Ke.sent(), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                var Je, de, qe, lt, ct;
                return p(this, function(Ot) {
                  try {
                    for (Je = be(this._openChannelHandlers.values()), de = Je.next(); !de.done; de = Je.next())
                      qe = de.value, this._openChannelCache.isEnteredChannel(h.url) && qe.onReactionUpdated && qe.onReactionUpdated(h, R);
                  } catch (zt) {
                    lt = { error: zt };
                  } finally {
                    try {
                      de && !de.done && (ct = Je.return) && ct.call(Je);
                    } finally {
                      if (lt)
                        throw lt.error;
                    }
                  }
                  return [2];
                });
              });
            }), Ke.label = 12;
          case 12:
            return [3, 56];
          case 13:
            return (Z = t.as(A3).event).channelType !== Xt.OPEN ? [3, 15] : [4, this.getChannel(Z.channelUrl, !0)];
          case 14:
            W = Ke.sent(), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                var Je, de, qe, lt, ct;
                return p(this, function(Ot) {
                  try {
                    for (Je = be(this._openChannelHandlers.values()), de = Je.next(); !de.done; de = Je.next())
                      qe = de.value, this._openChannelCache.isEnteredChannel(W.url) && qe.onThreadInfoUpdated && qe.onThreadInfoUpdated(W, Z);
                  } catch (zt) {
                    lt = { error: zt };
                  } finally {
                    try {
                      de && !de.done && (ct = Je.return) && ct.call(Je);
                    } finally {
                      if (lt)
                        throw lt.error;
                    }
                  }
                  return [2];
                });
              });
            }), Ke.label = 15;
          case 15:
            return [3, 56];
          case 16:
            F = t.as(q3).openChannelMemberCounts, m = [], Ke.label = 17;
          case 17:
            Ke.trys.push([17, 22, 23, 24]), E = be(F), u = E.next(), Ke.label = 18;
          case 18:
            return u.done ? [3, 21] : (b = u.value, K = b.channelUrl, re = b.participantCount, k = b.updatedAt, [4, this.getChannelFromCache(K)]);
          case 19:
            (Q = Ke.sent()) && Q._updateParticipantCount(re, k) && m.push(Q), Ke.label = 20;
          case 20:
            return u = E.next(), [3, 18];
          case 21:
            return [3, 24];
          case 22:
            return S = Ke.sent(), ln = { error: S }, [3, 24];
          case 23:
            try {
              u && !u.done && (vt = E.return) && vt.call(E);
            } finally {
              if (ln)
                throw ln.error;
            }
            return [7];
          case 24:
            return m.length > 0 ? [4, this.upsertChannelsToCache(m)] : [3, 26];
          case 25:
            v = Ke.sent(), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                var Je, de, qe, lt, ct;
                return p(this, function(Ot) {
                  try {
                    for (Je = be(this._openChannelHandlers.values()), de = Je.next(); !de.done; de = Je.next())
                      (qe = de.value).onChannelMemberCountChanged && qe.onChannelMemberCountChanged(v);
                  } catch (zt) {
                    lt = { error: zt };
                  } finally {
                    try {
                      de && !de.done && (ct = Je.return) && ct.call(Je);
                    } finally {
                      if (lt)
                        throw lt.error;
                    }
                  }
                  return [2];
                });
              });
            }), Ke.label = 26;
          case 26:
            return [3, 56];
          case 27:
            return G = t.as($3), w = G.event, y = G.status, K = G.channelUrl, Ue = G.channelType, K && Ue === Xt.OPEN ? [4, this.getChannel(K, !0)] : [3, 29];
          case 28:
            g = Ke.sent(), this._dispatcher.dispatch(new SW({ event: w, source: ne.EVENT_POLL_UPDATED })), Ce(y === d3 ? function() {
              return M(Rt, void 0, void 0, function() {
                var Je, de, qe, lt, ct;
                return p(this, function(Ot) {
                  try {
                    for (Je = be(this._openChannelHandlers.values()), de = Je.next(); !de.done; de = Je.next())
                      (qe = de.value).onPollDeleted && qe.onPollDeleted(g, w.pollId);
                  } catch (zt) {
                    lt = { error: zt };
                  } finally {
                    try {
                      de && !de.done && (ct = Je.return) && ct.call(Je);
                    } finally {
                      if (lt)
                        throw lt.error;
                    }
                  }
                  return [2];
                });
              });
            } : function() {
              return M(Rt, void 0, void 0, function() {
                var Je, de, qe, lt, ct;
                return p(this, function(Ot) {
                  try {
                    for (Je = be(this._openChannelHandlers.values()), de = Je.next(); !de.done; de = Je.next())
                      (qe = de.value).onPollUpdated && qe.onPollUpdated(g, w);
                  } catch (zt) {
                    lt = { error: zt };
                  } finally {
                    try {
                      de && !de.done && (ct = Je.return) && ct.call(Je);
                    } finally {
                      if (lt)
                        throw lt.error;
                    }
                  }
                  return [2];
                });
              });
            }), Ke.label = 29;
          case 29:
            return [3, 56];
          case 30:
            return f = t.as(vW), I = f.event, K = f.channelUrl, Ue = f.channelType, K && Ue === Xt.OPEN ? [4, this.getChannel(K, !0)] : [3, 32];
          case 31:
            q = Ke.sent(), this._dispatcher.dispatch(new KR({ event: I, source: ne.EVENT_POLL_VOTED })), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                var Je, de, qe, lt, ct;
                return p(this, function(Ot) {
                  try {
                    for (Je = be(this._openChannelHandlers.values()), de = Je.next(); !de.done; de = Je.next())
                      (qe = de.value).onPollVoted && qe.onPollVoted(q, I);
                  } catch (zt) {
                    lt = { error: zt };
                  } finally {
                    try {
                      de && !de.done && (ct = Je.return) && ct.call(Je);
                    } finally {
                      if (lt)
                        throw lt.error;
                    }
                  }
                  return [2];
                });
              });
            }), Ke.label = 32;
          case 32:
            return [3, 56];
          case 33:
            if (!(ae = t.as(Dr).event).isOpenChannelEvent)
              return [3, 55];
            switch (ae.category) {
              case Vn.CHANNEL_ENTER:
                return [3, 34];
              case Vn.CHANNEL_EXIT:
                return [3, 36];
              case Vn.CHANNEL_OPERATOR_UPDATE:
                return [3, 38];
              case Vn.USER_CHANNEL_MUTE:
              case Vn.USER_CHANNEL_UNMUTE:
                return [3, 40];
              case Vn.USER_CHANNEL_BAN:
              case Vn.USER_CHANNEL_UNBAN:
                return [3, 42];
              case Vn.CHANNEL_FREEZE:
              case Vn.CHANNEL_UNFREEZE:
                return [3, 44];
              case Vn.CHANNEL_DELETED:
                return [3, 46];
              case Vn.CHANNEL_PROP_CHANGED:
                return [3, 49];
              case Vn.CHANNEL_META_DATA_CHANGED:
                return [3, 51];
              case Vn.CHANNEL_META_COUNTERS_CHANGED:
                return [3, 53];
            }
            return [3, 55];
          case 34:
            return [4, this.getChannel(ae.channelUrl, !0)];
          case 35:
            return se = Ke.sent(), le = t.as(pb), re = le.participantCount, L = le.user, $ = se._updateParticipantCount(re, ae.ts), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    de.onUserEntered && de.onUserEntered(se, L), $ && de.onChannelParticipantCountChanged && de.onChannelParticipantCountChanged(se);
                  }), [2];
                });
              });
            }), [3, 55];
          case 36:
            return [4, this.getChannel(ae.channelUrl, !0)];
          case 37:
            return ee = Ke.sent(), O = t.as(Mb), re = O.participantCount, te = O.user, Qe = ee._updateParticipantCount(re, ae.ts), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    de.onUserExited && de.onUserExited(ee, te), Qe && de.onChannelParticipantCountChanged && de.onChannelParticipantCountChanged(ee);
                  }), [2];
                });
              });
            }), [3, 55];
          case 38:
            return [4, this.getChannel(ae.channelUrl, !0)];
          case 39:
            return Ye = Ke.sent(), Se = t.as(L3).operators, Ye.operators = Se, this.upsertChannelsToCache([Ye]), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    de.onOperatorUpdated && de.onOperatorUpdated(Ye, Se);
                  }), [2];
                });
              });
            }), [3, 55];
          case 40:
            return [4, this.getChannel(ae.channelUrl, !0)];
          case 41:
            return P = Ke.sent(), ge = ae.category === Vn.USER_CHANNEL_MUTE, Me = t.as(ge ? b3 : Y3).user, Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    ge ? de.onUserMuted && de.onUserMuted(P, Me) : de.onUserUnmuted && de.onUserUnmuted(P, Me);
                  }), [2];
                });
              });
            }), [3, 55];
          case 42:
            return [4, this.getChannel(ae.channelUrl, !0)];
          case 43:
            return We = Ke.sent(), De = ae.category === Vn.USER_CHANNEL_BAN, Oe = t.as(De ? Q3 : J3).user, Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    De ? de.onUserBanned && de.onUserBanned(We, Oe) : de.onUserUnbanned && de.onUserUnbanned(We, Oe);
                  }), [2];
                });
              });
            }), [3, 55];
          case 44:
            return [4, this.getChannel(ae.channelUrl, !0)];
          case 45:
            return tt = Ke.sent(), Be = t.as(v3).freeze, tt.isFrozen = Be, this.upsertChannelsToCache([tt]), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    Be ? de.onChannelFrozen && de.onChannelFrozen(tt) : de.onChannelUnfrozen && de.onChannelUnfrozen(tt);
                  }), [2];
                });
              });
            }), [3, 55];
          case 46:
            return [4, this.getChannel(ae.channelUrl, !0)];
          case 47:
            return He = Ke.sent(), [4, this.removeChannelsFromCache([He.url])];
          case 48:
            return Ke.sent(), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    de.onChannelDeleted && de.onChannelDeleted(He.url, He.channelType);
                  }), [2];
                });
              });
            }), [3, 55];
          case 49:
            return [4, this.getChannelWithoutCache(ae.channelUrl, !0)];
          case 50:
            return at = Ke.sent(), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    de.onChannelChanged && de.onChannelChanged(at);
                  }), [2];
                });
              });
            }), [3, 55];
          case 51:
            return [4, this.getChannel(ae.channelUrl, !0)];
          case 52:
            return Ge = Ke.sent(), $e = t.as(S3), fe = $e.created, Xe = $e.updated, pt = $e.deleted, fe && Ge._upsertCachedMetaData(fe, ae.ts), Xe && Ge._upsertCachedMetaData(Xe, ae.ts), pt && Ge._removeFromCachedMetaData(pt, ae.ts), Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    fe && de.onMetaDataCreated && de.onMetaDataCreated(Ge, fe), Xe && de.onMetaDataUpdated && de.onMetaDataUpdated(Ge, Xe), pt && de.onMetaDataDeleted && de.onMetaDataDeleted(Ge, pt);
                  }), [2];
                });
              });
            }), [3, 55];
          case 53:
            return [4, this.getChannel(ae.channelUrl, !0)];
          case 54:
            return Vt = Ke.sent(), yt = t.as(k3), xe = yt.created, At = yt.updated, kt = yt.deleted, Ce(function() {
              return M(Rt, void 0, void 0, function() {
                return p(this, function(Je) {
                  return this._openChannelHandlers.forEach(function(de) {
                    xe && de.onMetaCounterCreated && de.onMetaCounterCreated(Vt, xe), At && de.onMetaCounterUpdated && de.onMetaCounterUpdated(Vt, At), kt && de.onMetaCounterDeleted && de.onMetaCounterDeleted(Vt, kt);
                  }), [2];
                });
              });
            }), [3, 55];
          case 55:
            return [3, 56];
          case 56:
            return [3, 58];
          case 57:
            if (Kt = Ke.sent(), Il(Kt))
              throw Kt;
            return [3, 58];
          case 58:
            return [2];
        }
      });
    });
  }, n.prototype.addHandler = function(t, l) {
    this._openChannelHandlers.set(t, l);
  }, n.prototype.removeHandler = function(t) {
    this._openChannelHandlers.delete(t);
  }, n.prototype.clearHandler = function() {
    this._openChannelHandlers.clear();
  }, n.prototype.getChannel = function(t, l) {
    return M(this, void 0, void 0, function() {
      var a;
      return p(this, function(d) {
        switch (d.label) {
          case 0:
            Ze(B("string", t)).throw(j.invalidParameters), d.label = 1;
          case 1:
            return d.trys.push([1, 3, , 4]), [4, this.getChannelFromCache(t)];
          case 2:
            return (a = d.sent()) ? [2, a] : [3, 4];
          case 3:
            return d.sent(), [3, 4];
          case 4:
            return [4, this.getChannelWithoutCache(t)];
          case 5:
            return [2, d.sent()];
        }
      });
    });
  }, n.prototype.getChannelWithoutCache = function(t, l) {
    return l === void 0 && (l = !1), M(this, void 0, void 0, function() {
      var a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return Ze(B("string", t)).throw(j.invalidParameters), a = new Uj({ channelUrl: t, isInternalCall: l }), [4, this._requestQueue.send(a)];
          case 1:
            return d = i.sent(), r = d.as(np).channel, [4, this.upsertChannelsToCache([r])];
          case 2:
            return [2, i.sent()[0]];
        }
      });
    });
  }, n.prototype.createChannel = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r;
      return p(this, function(i) {
        switch (i.label) {
          case 0:
            return l = x(x({}, ub), t), Ze(function(c) {
              return Jt("string", c.operatorUserIds, !0) && (B("string", c.coverUrlOrImage, !0) || Nl(c.coverUrlOrImage, !0)) && B("string", c.name, !0) && B("string", c.data, !0) && B("string", c.customType, !0) && (B("string", c.channelUrl) && /^\w+$/.test(c.channelUrl) || c.channelUrl === null || c.channelUrl === void 0) && B("boolean", c.isEphemeral, !0);
            }(l)).throw(j.invalidParameters), a = new Nj(l), [4, this._requestQueue.send(a)];
          case 1:
            return d = i.sent(), r = d.as(np).channel, this.upsertChannelsToCache([r]), [2, r];
        }
      });
    });
  }, n;
}(C3), lp = { name: void 0, coverUrlOrImage: void 0, data: void 0, customType: void 0, operatorUserIds: void 0 }, Zj = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.token, r = t.limit;
    return (l = e.call(this) || this).method = he.GET, l.path = "".concat(xV, "/").concat(encodeURIComponent(a), "/participants"), l.params = { token: d, limit: r }, l;
  }
  return J(n, e), n;
}(Te), Tj = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    a.participants = [];
    var d = l.next, r = l.participants;
    return a.token = d, a.participants = r.map(function(i) {
      return new ky(t, i);
    }), a;
  }
  return J(n, e), n;
}(ue), Fj = function(e) {
  function n(t, l, a) {
    return e.call(this, t, l, Xt.OPEN, a) || this;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 3] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new Zj(x(x({}, this), { token: this._token })), [4, t.send(l)]) : [3, 2] : [3, 5];
          case 1:
            return a = c.sent(), d = a.as(Tj), r = d.participants, i = d.token, this._token = i, this._hasNext = !!i, this._isLoading = !1, [2, r];
          case 2:
            return [2, []];
          case 3:
            throw j.queryInProgress;
          case 4:
            return [3, 6];
          case 5:
            throw j.invalidParameters;
          case 6:
            return [2];
        }
      });
    });
  }, n;
}(ar), Wj = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl, d = t.coverUrlOrImage, r = t.name, i = t.data, c = t.customType, V = t.operatorUserIds;
    return (l = e.call(this) || this).method = he.PUT, l.path = "".concat(xV, "/").concat(encodeURIComponent(a)), l.params = je(Ae({ cover_url: B("string", d) ? d : null, cover_file: Nl(d) ? d : null, name: r, data: i, custom_type: c, operators: V })), l;
  }
  return J(n, e), n;
}(Te), mj = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    return a.channel = new Jc(t, l), a;
  }
  return J(n, e), n;
}(ue), uj = function(e) {
  function n(t) {
    var l = this, a = t.channelUrl;
    return (l = e.call(this) || this).method = he.DELETE, l.path = "".concat(xV, "/").concat(encodeURIComponent(a)), l;
  }
  return J(n, e), n;
}(Te);
(function(e) {
  function n(t, l) {
    return e.call(this, t, l) || this;
  }
  J(n, e);
})(ue);
var Jc = function(e) {
  function n(t, l) {
    var a, d = this;
    return (d = e.call(this, t, l) || this)._lastParticipantCountUpdated = 0, d.participantCount = 0, d.operators = [], d.channelType = Xt.OPEN, d.participantCount = (a = l.participant_count) !== null && a !== void 0 ? a : 0, d.operators = Array.isArray(l.operators) ? l.operators.map(function(r) {
      return new xt(t, r);
    }) : [], d;
  }
  return J(n, e), n.payloadify = function(t) {
    return je(Ae(x(x({}, VR.payloadify(t)), { participant_count: t.participantCount, operators: t.operators.map(function(l) {
      return xt.payloadify(l);
    }) })));
  }, n.prototype.serialize = function() {
    return gc(this);
  }, n.prototype.isOperator = function(t) {
    return t instanceof xt ? this.isOperator(t.userId) : this.operators.some(function(l) {
      return l.userId === t;
    });
  }, n.prototype._updateParticipantCount = function(t, l) {
    return l > this._lastParticipantCountUpdated && (this.participantCount = t, this._lastParticipantCountUpdated = l, !0);
  }, n.prototype.createParticipantListQuery = function(t) {
    return new Fj(this._iid, this.url, t);
  }, n.prototype.refresh = function() {
    return M(this, void 0, void 0, function() {
      return p(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, _i.of(this._iid).getChannelWithoutCache(this.url)];
          case 1:
            return [2, t.sent()];
        }
      });
    });
  }, n.prototype.enter = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new Rj({ channelUrl: this.url }), [4, t.send(l)];
          case 1:
            return a = c.sent(), d = a.as(pb), r = d.participantCount, i = d.ts, this._updateParticipantCount(r, i), _i.of(this._iid).setEnteredToCache(this), [2];
        }
      });
    });
  }, n.prototype.exit = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new hj({ channelUrl: this.url }), [4, t.send(l)];
          case 1:
            return a = c.sent(), d = a.as(Mb), r = d.participantCount, i = d.ts, this._updateParticipantCount(r, i), _i.of(this._iid).setExitedToCache(this), tl.of(this._iid).fileMessageQueue.cancel(this), [2];
        }
      });
    });
  }, n.prototype.updateChannel = function(t) {
    return M(this, void 0, void 0, function() {
      var l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return l = x(x({}, lp), t), Ze(function(V) {
              return Jt("string", V.operatorUserIds, !0) && (B("string", V.coverUrlOrImage, !0) || Nl(V.coverUrlOrImage, !0)) && B("string", V.name, !0) && B("string", V.data, !0) && B("string", V.customType, !0);
            }(l)).throw(j.invalidParameters), a = D.of(this._iid).requestQueue, d = new Wj(x({ channelUrl: this.url }, l)), [4, a.send(d)];
          case 1:
            return r = c.sent(), i = r.as(mj).channel, this._update(i), [4, _i.of(this._iid).upsertChannelsToCache([i])];
          case 2:
            return c.sent(), [2, this];
        }
      });
    });
  }, n.prototype.updateChannelWithOperatorUserIds = function(t, l, a, d, r) {
    return M(this, void 0, void 0, function() {
      var i;
      return p(this, function(c) {
        return i = x(x({}, lp), { name: t, coverUrlOrImage: l, data: a, operatorUserIds: d, customType: r }), [2, this.updateChannel(i)];
      });
    });
  }, n.prototype.delete = function() {
    return M(this, void 0, void 0, function() {
      var t, l;
      return p(this, function(a) {
        switch (a.label) {
          case 0:
            return t = D.of(this._iid).requestQueue, l = new uj({ channelUrl: this.url }), [4, t.send(l)];
          case 1:
            return a.sent(), [4, _i.of(this._iid).removeChannelsFromCache([this.url])];
          case 2:
            return a.sent(), [2];
        }
      });
    });
  }, n.prototype.sendUserMessage = function(t) {
    return Ze(!t.isPinnedMessage).throw(j.notSupportedError), e.prototype.sendUserMessage.call(this, t);
  }, n.prototype.sendFileMessage = function(t) {
    return Ze(!t.isPinnedMessage).throw(j.notSupportedError), e.prototype.sendFileMessage.call(this, t);
  }, n;
}(VR);
(function(e) {
  function n(t) {
    t === void 0 && (t = {});
    var l = e.call(this) || this;
    return Object.keys(t).forEach(function(a) {
      l.hasOwnProperty(a) && (l[a] = t[a]);
    }), l;
  }
  return J(n, e), n;
})(function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.onUserEntered = ut, t.onUserExited = ut, t.onChannelParticipantCountChanged = ut, t.onPollUpdated = ut, t.onPollVoted = ut, t.onPollDeleted = ut, t;
  }
  return J(n, e), n;
}(rb));
var pj = function(e) {
  function n(t) {
    var l = this, a = t.token, d = t.limit, r = t.nameKeyword, i = t.urlKeyword, c = t.customTypes, V = t.includeFrozen, s = t.includeMetaData;
    return (l = e.call(this) || this).method = he.GET, l.path = xV, l.params = je({ token: a, limit: d, name_contains: r, url_contains: i, custom_types: c, show_frozen: V, show_metadata: s }), l;
  }
  return J(n, e), n;
}(Te), Mj = function(e) {
  function n(t, l) {
    var a = e.call(this, t, l) || this;
    a.channels = [];
    var d = l.next, r = l.channels, i = l.ts;
    return a.token = d, r && r.length > 0 && (a.channels = r.map(function(c) {
      return new Jc(t, c);
    })), a.ts = typeof i == "number" ? i : null, a;
  }
  return J(n, e), n;
}(ue), Ej = function(e) {
  function n(t, l) {
    var a, d, r, i, c, V = this;
    return (V = e.call(this, t, l) || this).includeFrozen = !0, V.includeMetaData = !0, V.nameKeyword = null, V.urlKeyword = null, V.customTypes = null, V.includeFrozen = (a = l.includeFrozen) === null || a === void 0 || a, V.includeMetaData = (d = l.includeMetaData) === null || d === void 0 || d, V.nameKeyword = (r = l.nameKeyword) !== null && r !== void 0 ? r : null, V.urlKeyword = (i = l.urlKeyword) !== null && i !== void 0 ? i : null, V.customTypes = (c = l.customTypes) !== null && c !== void 0 ? c : null, V;
  }
  return J(n, e), n.prototype._validate = function() {
    return e.prototype._validate.call(this) && B("boolean", this.includeFrozen) && B("boolean", this.includeMetaData) && B("string", this.nameKeyword, !0) && B("string", this.urlKeyword, !0) && Jt("string", this.customTypes, !0);
  }, n.prototype.next = function() {
    return M(this, void 0, void 0, function() {
      var t, l, a, d, r, i;
      return p(this, function(c) {
        switch (c.label) {
          case 0:
            return this._validate() ? this._isLoading ? [3, 4] : this._hasNext ? (this._isLoading = !0, t = D.of(this._iid).requestQueue, l = new pj(Ae(x(x({}, this), { token: this._token }))), [4, t.send(l)]) : [3, 3] : [3, 6];
          case 1:
            return a = c.sent(), d = a.as(Mj), r = d.channels, i = d.token, this._token = i, this._hasNext = !!i, [4, _i.of(this._iid).upsertChannelsToCache(r)];
          case 2:
            return c.sent(), this._isLoading = !1, [2, r];
          case 3:
            return [2, []];
          case 4:
            throw j.queryInProgress;
          case 5:
            return [3, 7];
          case 6:
            throw j.invalidParameters;
          case 7:
            return [2];
        }
      });
    });
  }, n;
}(yr), Sj = function(e) {
  function n() {
    var t = e !== null && e.apply(this, arguments) || this;
    return t.name = "openChannel", t;
  }
  return J(n, e), n.prototype.init = function(t, l) {
    var a = l.sdkState, d = l.dispatcher, r = l.sessionManager, i = l.requestQueue, c = l.logger, V = l.onlineDetector, s = l.cacheContext;
    e.prototype.init.call(this, t, { sdkState: a, dispatcher: d, sessionManager: r, requestQueue: i, logger: c, onlineDetector: V, cacheContext: s }), this._manager = new _i(t, { sdkState: a, dispatcher: d, requestQueue: i, logger: c, cacheContext: s, sessionManager: r });
  }, n.prototype.createOpenChannelListQuery = function(t) {
    return t === void 0 && (t = {}), new Ej(this._iid, t);
  }, n.prototype.addOpenChannelHandler = function(t, l) {
    this._manager.addHandler(t, l);
  }, n.prototype.removeOpenChannelHandler = function(t) {
    this._manager.removeHandler(t);
  }, n.prototype.removeAllOpenChannelHandlers = function() {
    this._manager.clearHandler();
  }, n.prototype.buildOpenChannelFromSerializedData = function(t) {
    return this._manager.buildOpenChannelFromSerializedData(t);
  }, n.prototype.getChannel = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2, this._manager.getChannel(t)];
      });
    });
  }, n.prototype.getChannelWithoutCache = function(t) {
    return M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2, this._manager.getChannelWithoutCache(t)];
      });
    });
  }, n.prototype.createChannel = function(t) {
    return t === void 0 && (t = {}), M(this, void 0, void 0, function() {
      return p(this, function(l) {
        return [2, this._manager.createChannel(t)];
      });
    });
  }, n.prototype.createChannelWithOperatorUserIds = function(t, l, a, d, r) {
    return M(this, void 0, void 0, function() {
      var i;
      return p(this, function(c) {
        return (i = x({}, ub)).name = t, i.coverUrlOrImage = l, i.data = a, i.operatorUserIds = d, i.customType = r, [2, this._manager.createChannel(i)];
      });
    });
  }, n;
}(CR), fn;
(function(e) {
  e.NONE = "NONE", e.PENDING = "PENDING", e.SENT = "SENT", e.FAILED = "FAILED", e.DELIVERED = "DELIVERED", e.READ = "READ";
})(fn || (fn = {}));
var Eb = function(e, n) {
  var t, l, a, d, r;
  if (!n || !("sendingStatus" in n))
    return fn.NONE;
  if (n.sendingStatus === "pending")
    return fn.PENDING;
  if (n.sendingStatus === "failed")
    return fn.FAILED;
  if (!((t = e == null ? void 0 : e.isGroupChannel) === null || t === void 0) && t.call(e)) {
    if (((a = (l = e).getUnreadMemberCount) === null || a === void 0 ? void 0 : a.call(l, n)) === 0)
      return fn.READ;
    if (((r = (d = e).getUndeliveredMemberCount) === null || r === void 0 ? void 0 : r.call(d, n)) === 0)
      return fn.DELIVERED;
  }
  return n.sendingStatus === "succeeded" ? fn.SENT : fn.NONE;
}, dV = {
  IMAGE: [
    "image/jpeg",
    "image/jpg",
    "image/png",
    "image/gif",
    "image/svg+xml",
    "image/webp"
    // not supported in IE
  ],
  VIDEO: [
    "video/mpeg",
    "video/ogg",
    "video/webm",
    "video/mp4",
    "video/quicktime"
    // .mov
  ],
  AUDIO: [
    "audio/aac",
    "audio/midi",
    "audio/x-midi",
    "audio/mpeg",
    "audio/ogg",
    "audio/opus",
    "audio/wav",
    "audio/webm",
    "audio/3gpp",
    "audio/3gpp2",
    "audio/mp3"
  ],
  DOCUMENT: [
    "text/plain",
    "text/css",
    "text/csv",
    "text/html",
    "text/calendar",
    "text/javascript",
    "text/xml"
  ],
  APPLICATION: [
    "application/x-abiword",
    "application/x-freearc",
    "application/vnd.amazon.ebook",
    "application/octet-stream",
    "application/x-bzip",
    "application/x-bzip2",
    "application/x-cdf",
    "application/x-csh",
    "application/msword",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.ms-fontobject",
    "application/epub+zip",
    "application/gzip",
    "application/java-archive",
    "application/json",
    "application/ld+json",
    "application/vnd.apple.installer+xml",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.text",
    "application/ogg",
    "application/pdf",
    "application/x-httpd-php",
    "application/vnd.ms-powerpoint",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.rar",
    "application/rtf",
    "application/x-sh",
    "application/x-tar",
    "application/vnd.visio",
    "application/xhtml+xml",
    "application/vnd.ms-excel",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/xml",
    "application/vnd.mozilla.xul+xml",
    "application/zip",
    "application/x-7z-compressed"
  ]
}, kj = function(e) {
  return Array.isArray(e) && e.length > 0 ? e.reduce(function(n, t) {
    switch (t) {
      case "image": {
        n.push.apply(n, dV.IMAGE);
        break;
      }
      case "video": {
        n.push.apply(n, dV.VIDEO);
        break;
      }
      case "audio": {
        n.push.apply(n, dV.AUDIO);
        break;
      }
      default: {
        n.push(t);
        break;
      }
    }
    return n;
  }, []).join() : Object.values(dV).reduce(function(n, t) {
    return n.concat(t);
  }, []).join();
}, vd = {
  ADMIN: "ADMIN",
  TEXT: "TEXT",
  FILE: "FILE",
  MULTIPLE_FILES: "MULTIPLE_FILES",
  THUMBNAIL: "THUMBNAIL",
  OG: "OG",
  UNKNOWN: "UNKNOWN"
}, Pi = {
  IMAGE: "IMAGE",
  AUDIO: "AUDIO",
  VIDEO: "VIDEO",
  GIF: "GIF",
  VOICE: "VOICE",
  OTHERS: "OTHERS"
}, ap = function(e) {
  return e === "" || e === null;
}, XV = function(e) {
  return dV.IMAGE.indexOf(e) >= 0;
}, YV = function(e) {
  return dV.VIDEO.indexOf(e) >= 0;
}, aU = function(e) {
  return e === "image/gif";
}, Eo = function(e) {
  return XV(e) || YV(e);
}, Sb = function(e) {
  return dV.AUDIO.indexOf(e) >= 0;
}, bj = function() {
  return ce({}, Pi);
}, kb = function(e) {
  return aU(e) ? Pi.GIF : XV(e) ? Pi.IMAGE : YV(e) ? Pi.VIDEO : Sb(e) ? Pi.AUDIO : Pi.OTHERS;
}, So = function(e) {
  return e.sendingStatus === "succeeded";
}, dp = function(e, n) {
  return Eb(e, n) === fn.READ;
}, Ba = function(e) {
  return (e == null ? void 0 : e.sendingStatus) === "failed";
}, Fd = function(e) {
  return (e == null ? void 0 : e.sendingStatus) === "pending";
}, Yj = function(e) {
  return e === fn.SENT || e === fn.DELIVERED || e === fn.READ;
}, Qj = function(e) {
  return e && (e.isAdminMessage && typeof e.isAdminMessage == "function" ? e.isAdminMessage() : (e == null ? void 0 : e.messageType) === "admin");
}, dd = function(e) {
  return e && (e.isUserMessage && typeof e.isUserMessage == "function" ? e.isUserMessage() : (e == null ? void 0 : e.messageType) === "user");
}, wa = function(e) {
  return e && (e.isFileMessage && typeof e.isFileMessage == "function" ? e.isFileMessage() : (e == null ? void 0 : e.messageType) === "file");
}, Fa = function(e) {
  return e && (e.isMultipleFilesMessage && typeof e.isMultipleFilesMessage == "function" ? e.isMultipleFilesMessage() : e.messageType === "file" && Object.prototype.hasOwnProperty.call(e, "fileInfoList"));
}, bb = function(e) {
  return !!e.parentMessageId && !!e.parentMessage;
}, zN = function(e) {
  var n;
  return !!(e && (!((n = e.extendedMessagePayload) === null || n === void 0) && n.template));
}, DW = function(e) {
  var n, t, l, a;
  return !!(e && dd(e) && (e != null && e.ogMetaData) && (!((n = e.ogMetaData) === null || n === void 0) && n.url || !((t = e.ogMetaData) === null || t === void 0) && t.title || !((l = e.ogMetaData) === null || l === void 0) && l.description || !((a = e.ogMetaData) === null || a === void 0) && a.defaultImage));
}, Jj = function(e) {
  return dd(e);
}, Qi = function(e) {
  return e && wa(e) && Eo(e.type);
}, Yb = function(e) {
  return e && e.isFileMessage() && Qi(e) && XV(e.type);
}, vj = function(e) {
  return e && (XV(e.mimeType) || aU(e.mimeType));
}, dc = function(e) {
  return e && Qi(e) && YV(e.type);
}, o0 = function(e) {
  return e && Qi(e) && aU(e.type);
}, zj = function(e) {
  return e && wa(e) && Sb(e.type);
}, xj = function(e) {
  return /^audio\//.test(e);
}, Gj = function(e) {
  return /^voice\//.test(e);
}, Mi = function(e) {
  var n, t, l, a;
  if (!(e && wa(e)) || !e.type)
    return !1;
  var d = e.type.split(";"), r = d[0], i = d[1];
  if (!xj(r))
    return !1;
  if (i) {
    var c = i.split("="), V = c[0], s = c[1];
    return V === "sbu_type" && s === "voice";
  }
  return Gj((a = (l = (t = (n = e == null ? void 0 : e.metaArrays) === null || n === void 0 ? void 0 : n.find(function(o) {
    return o.key === "KEY_INTERNAL_MESSAGE_TYPE";
  })) === null || t === void 0 ? void 0 : t.value) === null || l === void 0 ? void 0 : l[0]) !== null && a !== void 0 ? a : "");
}, Qb = function(e) {
  return dd(e) && (e == null ? void 0 : e.updatedAt) > 0;
}, yj = function() {
  return ce({}, vd);
}, XW = function(e) {
  return Qj(e) ? vd.ADMIN : dd(e) ? DW(e) ? vd.OG : vd.TEXT : Fa(e) ? vd.MULTIPLE_FILES : wa(e) ? Qi(e) ? vd.THUMBNAIL : Mi(e) ? Pi.VOICE : vd.FILE : vd.UNKNOWN;
}, Bj = function(e, n) {
  return Array.isArray(n) ? Ut(Ut([], e, !0), n, !0) : (e.push(n), e);
}, vn = function(e) {
  return Array.isArray(e) ? e.reduce(Bj, []).join(" ") : e;
}, Jb = function(e, n) {
  return n.userIds.some(function(t) {
    return t === e;
  });
}, Dj = function(e, n, t, l) {
  var a = "";
  return Jb(n, e) && (a = e.userIds.length === 1 ? l.TOOLTIP__YOU : l.TOOLTIP__AND_YOU), "".concat(e.userIds.filter(function(d) {
    return d !== n;
  }).map(function(d) {
    return t.get(d) || l.TOOLTIP__UNKNOWN_USER;
  }).join(", ")).concat(a);
};
function OW(e) {
  var n;
  return Array.isArray((n = e == null ? void 0 : e.extendedMessagePayload) === null || n === void 0 ? void 0 : n.suggested_replies) ? e.extendedMessagePayload.suggested_replies : [];
}
var vb = function(e, n) {
  if (n || (n = 40), e == null)
    return "";
  if (e.length <= n)
    return e;
  var t = "...", l = t.length, a = n - l, d = Math.ceil(a / 2), r = Math.floor(a / 2);
  return e.substr(0, d) + t + e.substr(e.length - r);
}, jW = function(e) {
  if (window.clipboardData && window.clipboardData.setData)
    return window.clipboardData.setData("Text", e);
  if (document.queryCommandSupported && document.queryCommandSupported("copy")) {
    var n = document.createElement("textarea");
    n.textContent = e, n.style.position = "fixed", document.body.appendChild(n), n.select();
    try {
      return document.execCommand("copy");
    } catch {
      return !1;
    } finally {
      document.body.removeChild(n);
    }
  }
  return !1;
}, eh = function(e) {
  var n;
  return (n = e == null ? void 0 : e.emojiCategories) === null || n === void 0 ? void 0 : n.map(function(t) {
    return t.emojis;
  }).reduce(function(t, l) {
    return t.concat(l);
  }, []);
}, Xj = function(e) {
  var n, t = /* @__PURE__ */ new Map();
  return (n = e == null ? void 0 : e.emojiCategories) === null || n === void 0 || n.forEach(function(l) {
    var a;
    (a = l == null ? void 0 : l.emojis) === null || a === void 0 || a.forEach(function(d) {
      d && d.key && t.set(d.key, d);
    });
  }), t;
}, Oj = function(e) {
  return function(n) {
    var t = n.key;
    return t === e;
  };
}, jj = function(e, n) {
  var t, l, a = Oj(n ?? "");
  return ((l = (t = e == null ? void 0 : e.emojiCategories.find(function(d) {
    return d.emojis.some(a);
  })) === null || t === void 0 ? void 0 : t.emojis.find(a)) === null || l === void 0 ? void 0 : l.url) || "";
}, Hj = function(e) {
  return (e == null ? void 0 : e.friendName) || (e == null ? void 0 : e.nickname) || (e == null ? void 0 : e.userId);
}, fj = function(e) {
  return (e == null ? void 0 : e.sender) && Hj(e == null ? void 0 : e.sender);
}, rp = function(e, n) {
  var t, l, a, d, r = e.customTypesFilter, i = r === void 0 ? [] : r;
  if (e != null && e.messageTypeFilter && e.messageTypeFilter !== n.messageType)
    return !1;
  if ((i == null ? void 0 : i.length) > 0) {
    var c = i.filter(function(s) {
      return s !== "*";
    });
    if (c.length > 0 && !c.includes(n.customType))
      return !1;
  }
  if (e != null && e.senderUserIdsFilter && ((t = e == null ? void 0 : e.senderUserIdsFilter) === null || t === void 0 ? void 0 : t.length) > 0)
    if (!((l = n == null ? void 0 : n.isUserMessage) === null || l === void 0) && l.call(n) || !((a = n == null ? void 0 : n.isFileMessage) === null || a === void 0) && a.call(n)) {
      var V = n.sender || n._sender;
      if (!(!((d = e == null ? void 0 : e.senderUserIdsFilter) === null || d === void 0) && d.includes(V == null ? void 0 : V.userId)))
        return !1;
    } else
      return !1;
  return !(!(e != null && e.includeParentMessageInfo) && (n != null && n.parentMessageId || n != null && n.parentMessage));
}, ip;
(function(e) {
  e.normal = "normal", e.mention = "mention", e.url = "url";
})(ip || (ip = {}));
var wj = function(e, n) {
  if (Array.isArray(e) && Array.isArray(n) && e.length === n.length) {
    for (var t = 0; t < e.length; t++)
      if (e[t] !== n[t])
        return !1;
    return !0;
  }
  return !1;
}, th = function(e) {
  return !!e && "sender" in e;
}, dl = function() {
}, gj = function(e) {
  var n = /iPhone|iPad|iPod/i.test(e), t = /WebKit/i.test(e), l = /Safari/i.test(e);
  return n && (t || l);
}, Ij = function() {
  var e = {};
  return {
    __getTopics: function() {
      return e;
    },
    subscribe: function(n, t) {
      var l;
      return (l = e[n]) !== null && l !== void 0 || (e[n] = /* @__PURE__ */ new Set()), e[n].add(t), {
        remove: function() {
          e[n].delete(t);
        }
      };
    },
    publish: function(n, t) {
      e[n] && e[n].forEach(function(l) {
        setTimeout(function() {
          return l(t !== void 0 ? t : {});
        }, 0);
      });
    }
  };
}, Vi = 10, vc = 100, zb = 100, SZ = 250, HW = 1e3, Lj = 6e5, Cj = 12e3, Jle = 11025, Vp = ["audio/webm", "audio/mp4", "audio/mpeg", "audio/ogg"], kZ = "sendbird-voice-player-provider-root", U0 = "sendbird-global-audio-player-id", hR = "Voice_message.mp3", to = "audio/mp3;sbu_type=voice", Kj = "KEY_VOICE_MESSAGE_DURATION", _j = "KEY_INTERNAL_MESSAGE_TYPE", Pj = "voice/mp3", eN = "32px", Aj = 10, bZ = "sendbird_message_templates_token_key", IV = "sendbird_message_templates_key", qj = "No sendbird state value available. Make sure you are rendering `<SendbirdProvider>` at the top of your app.";
function zn() {
  var e = Gt(Ub);
  if (!e)
    throw new Error(qj);
  return e;
}
var xb = "INITIALIZE_AUDIO_UNIT", N0 = "RESET_AUDIO_UNIT", Gb = "SET_CURRENT_PLAYER", yb = "ON_VOICE_PLAYER_PLAY", Bb = "ON_VOICE_PLAYER_PAUSE", Db = "ON_CURRENT_TIME_UPDATE", Td = {
  IDLE: "IDLE",
  PREPARING: "PREPARING",
  PLAYING: "PLAYING",
  PAUSED: "PAUSED",
  COMPLETED: "COMPLETED"
}, Ai = function() {
  return {
    audioFile: null,
    playbackTime: 0,
    duration: 1e3,
    playingStatus: Td.IDLE
  };
}, $j = {
  currentPlayer: null,
  currentGroupKey: "",
  audioStorage: {}
};
function eH(e, n) {
  var t, l, a, d, r, i, c, V, s;
  switch (n.type) {
    case xb: {
      var o = n.payload.groupKey, U = !((i = e.audioStorage) === null || i === void 0) && i[o] ? e.audioStorage[o] : Ai();
      return U.playingStatus = Td.PREPARING, ce(ce({}, e), { audioStorage: ce(ce({}, e.audioStorage), (t = {}, t[o] = U, t)) });
    }
    case N0: {
      var o = n.payload.groupKey;
      return ce(ce({}, e), { audioStorage: ce(ce({}, e.audioStorage), (l = {}, l[o] = Ai(), l)) });
    }
    case Gb: {
      var N = n.payload, R = N.audioPlayer, o = N.groupKey;
      return ce(ce({}, e), { currentPlayer: R, currentGroupKey: o });
    }
    case yb: {
      var h = n.payload, o = h.groupKey, Z = h.audioFile, U = !((c = e.audioStorage) === null || c === void 0) && c[o] ? e.audioStorage[o] : Ai();
      return U.audioFile = Z, U.playingStatus = Td.PLAYING, ce(ce({}, e), { audioStorage: ce(ce({}, e.audioStorage), (a = {}, a[o] = U, a)) });
    }
    case Bb: {
      var W = n.payload, o = W.groupKey, F = W.duration, m = W.currentTime, U = !((V = e.audioStorage) === null || V === void 0) && V[o] ? e.audioStorage[o] : Ai();
      return U.playingStatus = Td.PAUSED, F === m && (U.playbackTime = 0), ce(ce({}, e), { audioStorage: ce(ce({}, e.audioStorage), (d = {}, d[o] = U, d)) });
    }
    case Db: {
      var o = n.payload.groupKey, E = e.currentPlayer, m = E.currentTime, F = E.duration, U = !((s = e.audioStorage) === null || s === void 0) && s[o] ? e.audioStorage[o] : Ai();
      return U.playbackTime === U.duration && U.playingStatus === Td.PAUSED ? U.playbackTime = 0 : m > 0 && F > 0 && (U.playbackTime = m, U.duration = F), ce(ce({}, e), { audioStorage: ce(ce({}, e.audioStorage), (r = {}, r[o] = U, r)) });
    }
    default:
      return e;
  }
}
var tH = "ALL", YZ = function() {
}, nH = {
  currentGroupKey: "",
  currentPlayer: null,
  audioStorage: {}
}, Xb = _l({
  play: YZ,
  pause: YZ,
  stop: YZ,
  voicePlayerStore: nH
}), lH = function(e) {
  var n = e.children, t = zs(eH, $j), l = t[0], a = t[1], d = l.currentGroupKey, r = l.currentPlayer, i = l.audioStorage, c = zn().config, V = c.logger, s = function(N) {
    N === void 0 && (N = ""), d.includes(N) && (V.info("VoicePlayer: Pause playing(by text)."), o(d));
  }, o = function(N) {
    d === N && r !== null && (V.info("VoicePlayer: Pause playing(by group key)."), r == null || r.pause()), N === tH && (V.info("VoicePlayer: Pause playing(all)."), r == null || r.pause());
  }, U = function(N) {
    var R = N.groupKey, h = N.audioFile, Z = h === void 0 ? null : h, W = N.audioFileUrl, F = W === void 0 ? "" : W;
    R !== d && o(d);
    var m = document.getElementById(kZ), E = document.getElementById(U0);
    E && m.removeChild(E), V.info("VoicePlayer: Start getting audio file."), new Promise(function(u, b) {
      var k;
      if (a({
        type: xb,
        payload: { groupKey: R }
      }), Z) {
        V.info("VoicePlayer: Use the audioFile instance."), u(Z);
        return;
      }
      var Q = (k = i == null ? void 0 : i[R]) === null || k === void 0 ? void 0 : k.audioFile;
      if (Q) {
        V.info("VoicePlayer: Get from the audioStorage."), u(Q);
        return;
      }
      fetch(F).then(function(S) {
        return S.blob();
      }).then(function(S) {
        var v = new File([S], hR, {
          lastModified: (/* @__PURE__ */ new Date()).getTime(),
          type: to
        });
        u(v), V.info("VoicePlayer: Get the audioFile from URL.");
      }).catch(b);
    }).then(function(u) {
      var b, k = document.getElementById(kZ);
      V.info("VoicePlayer: Succeeded getting audio file.", { audioFile: u });
      var Q = i[R] || Ai(), S = new Audio((b = URL == null ? void 0 : URL.createObjectURL) === null || b === void 0 ? void 0 : b.call(URL, u));
      S.id = U0, S.currentTime = Q.playbackTime, S.volume = 1, S.loop = !1, S.onplaying = function() {
        V.info("VoicePlayer: OnPlaying event is called from audioPlayer", { groupKey: R, audioPlayer: S }), a({
          type: yb,
          payload: { groupKey: R, audioFile: u }
        });
      }, S.onpause = function() {
        V.info("VoicePlayer: OnPause event is called from audioPlayer", { groupKey: R, audioPlayer: S }), a({
          type: Bb,
          payload: { groupKey: R, duration: S.duration, currentTime: S.currentTime }
        });
      }, S.ontimeupdate = function() {
        a({
          type: Db,
          payload: { groupKey: R }
        });
      }, S.onerror = function(v) {
        V.error("VoicePlayer: Failed to load the audioFile on the audio player.", v), a({
          type: N0,
          payload: { groupKey: R }
        });
      }, S.dataset.sbGroupId = R;
      try {
        k == null || k.childNodes.forEach(function(v) {
          var G, w, y = v, g = (G = y.dataset) === null || G === void 0 ? void 0 : G.sbGroupKey;
          g !== R && ((w = y == null ? void 0 : y.pause) === null || w === void 0 || w.call(y), k.removeChild(y), V.info("VoicePlayer: Removed other player.", { element: y }));
        });
      } finally {
        S == null || S.play(), k == null || k.appendChild(S), a({
          type: Gb,
          payload: { groupKey: R, audioPlayer: S }
        }), V.info("VoicePlayer: Succeeded playing audio player.", { groupKey: R, audioPlayer: S });
      }
    }).catch(function(u) {
      V.warning("VoicePlayer: Failed loading audio file with URL.", u), a({
        type: N0,
        payload: { groupKey: R }
      });
    });
  };
  return T.createElement(
    Xb.Provider,
    { value: {
      play: U,
      pause: o,
      stop: s,
      voicePlayerStore: l
    } },
    T.createElement("div", { id: kZ, style: { display: "none" } }),
    n
  );
}, aH = function() {
  return Gt(Xb);
}, dH = {
  en: {
    // Group Channel - Conversation
    MESSAGE_STATUS__YESTERDAY: "Yesterday",
    CHANNEL__MESSAGE_LIST__NOTIFICATION__NEW_MESSAGE: "new message(s) since",
    /** @deprecated Please use `DATE_FORMAT__MESSAGE_LIST__NOTIFICATION__UNREAD_SINCE` instead * */
    CHANNEL__MESSAGE_LIST__NOTIFICATION__ON: "on",
    // Channel List
    CHANNEL_PREVIEW_MOBILE_LEAVE: "Leave channel",
    // Group Channel - Settings
    CHANNEL_SETTING__HEADER__TITLE: "Channel information",
    CHANNEL_SETTING__PROFILE__EDIT: "Edit",
    CHANNEL_SETTING__MEMBERS__TITLE: "Members",
    CHANNEL_SETTING__MEMBERS__SEE_ALL_MEMBERS: "All members",
    CHANNEL_SETTING__MEMBERS__INVITE_MEMBER: "Invite users",
    CHANNEL_SETTING__MEMBERS__YOU: " (You)",
    CHANNEL_SETTING__MEMBERS__SELECT_TITLE: "Select members",
    CHANNEL_SETTING__MEMBERS__OPERATOR: "Operator",
    CHANNEL_SETTING__LEAVE_CHANNEL__TITLE: "Leave channel",
    CHANNEL_SETTING__OPERATORS__TITLE: "Operators",
    CHANNEL_SETTING__OPERATORS__TITLE_ALL: "All operators",
    CHANNEL_SETTING__OPERATORS__TITLE_ADD: "Add operator",
    CHANNEL_SETTING__OPERATORS__ADD_BUTTON: "Add",
    CHANNEL_SETTING__MUTED_MEMBERS__TITLE: "Muted members",
    CHANNEL_SETTING__MUTED_MEMBERS__TITLE_ALL: "All muted members",
    CHANNEL_SETTING__NO_UNMUTED: "No muted members yet",
    CHANNEL_SETTING__BANNED_MEMBERS__TITLE: "Banned users",
    CHANNEL_SETTING__FREEZE_CHANNEL: "Freeze Channel",
    CHANNEL_SETTING__MODERATION__REGISTER_AS_OPERATOR: "Register as operator",
    CHANNEL_SETTING__MODERATION__UNREGISTER_OPERATOR: "Unregister operator",
    CHANNEL_SETTING__MODERATION__MUTE: "Mute",
    CHANNEL_SETTING__MODERATION__UNMUTE: "Unmute",
    CHANNEL_SETTING__MODERATION__BAN: "Ban",
    CHANNEL_SETTING__MODERATION__UNBAN: "Unban",
    CHANNEL_SETTING__MODERATION__EMPTY_BAN: "No banned members yet",
    CHANNEL_SETTING__MODERATION__ALL_BAN: "All banned members",
    // OpenChannel - Conversation
    OPEN_CHANNEL_CONVERSATION__TITLE_PARTICIPANTS: "participants",
    OPEN_CHANNEL_CONVERSATION__SELECT_PARTICIPANTS: "Select participants",
    // OpenChannelList
    OPEN_CHANNEL_LIST__TITLE: "Channels",
    CREATE_OPEN_CHANNEL_LIST__TITLE: "New channel profile",
    CREATE_OPEN_CHANNEL_LIST__SUBTITLE__IMG_SECTION: "Channel image",
    CREATE_OPEN_CHANNEL_LIST__SUBTITLE__IMG_UPLOAD: "Upload",
    CREATE_OPEN_CHANNEL_LIST__SUBTITLE__TEXT_SECTION: "Channel name",
    CREATE_OPEN_CHANNEL_LIST__SUBTITLE__TEXT_PLACE_HOLDER: "Enter channel name",
    CREATE_OPEN_CHANNEL_LIST__SUBMIT: "Create",
    // OpenChannel - Settings
    OPEN_CHANNEL_SETTINGS__OPERATOR_TITLE: "Channel Information",
    OPEN_CHANNEL_SETTINGS__OPERATOR_URL: "URL",
    OPEN_CHANNEL_SETTINGS__PARTICIPANTS_ACCORDION_TITLE: "Participants",
    OPEN_CHANNEL_SETTINGS__DELETE_CHANNEL_PANEL: "Delete channel",
    OPEN_CHANNEL_SETTINGS__DELETE_CHANNEL_TITLE: "Delete channel?",
    OPEN_CHANNEL_SETTINGS__DELETE_CHANNEL_CONTEXT: "Once deleted, this channel can't be restored.",
    OPEN_CHANNEL_SETTINGS__DELETE_CHANNEL_SUBMIT: "Delete",
    OPEN_CHANNEL_SETTINGS__OPERATORS_TITLE: "Operators",
    OPEN_CHANNEL_SETTINGS__OPERATORS__TITLE_ADD: "Add operator",
    OPEN_CHANNEL_SETTINGS__OPERATORS__TITLE_ALL: "All operators",
    OPEN_CHANNEL_SETTINGS__MUTED_MEMBERS__TITLE: "Muted participants",
    OPEN_CHANNEL_SETTINGS__MUTED_MEMBERS__TITLE_ALL: "All muted participants",
    OPEN_CHANNEL_SETTINGS__MUTED_MEMBERS__NO_ONE: "No muted participants yet",
    OPEN_CHANNEL_SETTINGS__BANNED_MEMBERS__TITLE: "Banned users",
    OPEN_CHANNEL_SETTINGS__BANNED_MEMBERS__TITLE_ALL: "All banned users",
    OPEN_CHANNEL_SETTINGS__BANNED_MEMBERS__NO_ONE: "No banned users yet",
    OPEN_CHANNEL_SETTINGS__MEMBERS__YOU: " (You)",
    OPEN_CHANNEL_SETTINGS__MEMBERS__OPERATOR: "Operator",
    OPEN_CHANNEL_SETTINGS__PARTICIPANTS_TITLE: "Participants",
    OPEN_CHANNEL_SETTINGS__EMPTY_LIST: "No participants yet",
    OPEN_CHANNEL_SETTINGS__SEE_ALL: "See all participants",
    OPEN_CHANNEL_SETTINGS__ALL_PARTICIPANTS_TITLE: "All participants",
    OPEN_CHANNEL_SETTINGS__NO_TITLE: "(No title)",
    OPEN_CHANNEL_SETTING__MODERATION__REGISTER_AS_OPERATOR: "Register as operator",
    OPEN_CHANNEL_SETTING__MODERATION__UNREGISTER_OPERATOR: "Unregister operator",
    OPEN_CHANNEL_SETTING__MODERATION__MUTE: "Mute",
    OPEN_CHANNEL_SETTING__MODERATION__UNMUTE: "Unmute",
    OPEN_CHANNEL_SETTING__MODERATION__BAN: "Ban",
    OPEN_CHANNEL_SETTING__MODERATION__UNBAN: "Unban",
    // Channel - Common
    TRYING_TO_CONNECT: "Trying to connect…",
    TYPING_INDICATOR__IS_TYPING: "is typing...",
    TYPING_INDICATOR__AND: "and",
    TYPING_INDICATOR__ARE_TYPING: "are typing...",
    TYPING_INDICATOR__MULTIPLE_TYPING: "Several people are typing...",
    CHANNEL_FROZEN: "Channel frozen",
    PLACE_HOLDER__NO_CHANNEL: "No channels",
    PLACE_HOLDER__WRONG: "Something went wrong",
    PLACE_HOLDER__RETRY_TO_CONNECT: "Retry",
    PLACE_HOLDER__NO_MESSAGES: "No messages",
    TOOLTIP__AND_YOU: ", and you",
    TOOLTIP__YOU: "you",
    TOOLTIP__UNKNOWN_USER: "(no name)",
    UNKNOWN__UNKNOWN_MESSAGE_TYPE: "(Unknown message type)",
    UNKNOWN__CANNOT_READ_MESSAGE: "Cannot read this message.",
    UNKNOWN__TEMPLATE_ERROR: "(Template error)",
    UNKNOWN__CANNOT_READ_TEMPLATE: "Cannot read this template.",
    MESSAGE_EDITED: "(edited)",
    // Channel - Modal
    MODAL__DELETE_MESSAGE__TITLE: "Delete this message?",
    MODAL__CHANNEL_INFORMATION__TITLE: "Edit channel information",
    MODAL__CHANNEL_INFORMATION__CHANNEL_IMAGE: "Channel image",
    MODAL__CHANNEL_INFORMATION__UPLOAD: "Upload",
    MODAL__CHANNEL_INFORMATION__CHANNEL_NAME: "Channel name",
    MODAL__CHANNEL_INFORMATION__INPUT__PLACE_HOLDER: "Enter name",
    MODAL__INVITE_MEMBER__TITLE: "Invite member",
    MODAL__INVITE_MEMBER__SELECTED: "selected",
    MODAL__CHOOSE_CHANNEL_TYPE__TITLE: "New channel",
    MODAL__CHOOSE_CHANNEL_TYPE__GROUP: "Group",
    MODAL__CHOOSE_CHANNEL_TYPE__SUPER_GROUP: "Super group",
    MODAL__CHOOSE_CHANNEL_TYPE__BROADCAST: "Broadcast",
    MODAL__CREATE_CHANNEL__TITLE: "New channel",
    MODAL__CREATE_CHANNEL__GROUP: "Group",
    MODAL__CREATE_CHANNEL__SUPER: "Super group",
    MODAL__CREATE_CHANNEL__BROADCAST: "Broadcast",
    MODAL__CREATE_CHANNEL__SELECTED: "selected",
    MODAL__LEAVE_CHANNEL__TITLE: "Leave this channel?",
    MODAL__LEAVE_CHANNEL__FOOTER: "Leave",
    MODAL__VOICE_MESSAGE_INPUT_DISABLED__TITLE_MUTED: "You're muted by the operator.",
    MODAL__VOICE_MESSAGE_INPUT_DISABLED__TITLE_FROZEN: "Channel is frozen.",
    // User Profile
    USER_PROFILE__MESSAGE: "Message",
    USER_PROFILE__USER_ID: "User ID",
    EDIT_PROFILE__TITLE: "My profile",
    EDIT_PROFILE__IMAGE_LABEL: "Profile image",
    EDIT_PROFILE__IMAGE_UPLOAD: "Upload",
    EDIT_PROFILE__NICKNAME_LABEL: "Nickname",
    EDIT_PROFILE__NICKNAME_PLACEHOLDER: "Enter your nickname",
    EDIT_PROFILE__USERID_LABEL: "User ID",
    EDIT_PROFILE__THEME_LABEL: "Dark theme",
    // Message Input
    MESSAGE_INPUT__PLACE_HOLDER: "Enter message",
    MESSAGE_INPUT__PLACE_HOLDER__DISABLED: "Chat is unavailable in this channel",
    MESSAGE_INPUT__PLACE_HOLDER__MUTED: "Chat is unavailable because you're muted",
    MESSAGE_INPUT__PLACE_HOLDER__MUTED_SHORT: "You're muted",
    MESSAGE_INPUT__QUOTE_REPLY__PLACE_HOLDER: "Reply to message",
    // Common UI
    BUTTON__SUBMIT: "Submit",
    BUTTON__CANCEL: "Cancel",
    BUTTON__DELETE: "Delete",
    BUTTON__SAVE: "Save",
    BUTTON__CREATE: "Create",
    BUTTON__INVITE: "Invite",
    BUTTON__OK: "OK",
    BADGE__OVER: "+",
    NO_TITLE: "No title",
    NO_NAME: "(No name)",
    NO_MEMBERS: "(No members)",
    LABEL__OPERATOR: "Operator",
    // Context Menu
    MESSAGE_MENU__COPY: "Copy",
    MESSAGE_MENU__REPLY: "Reply",
    MESSAGE_MENU__THREAD: "Reply in thread",
    MESSAGE_MENU__OPEN_IN_CHANNEL: "Open in channel",
    MESSAGE_MENU__EDIT: "Edit",
    MESSAGE_MENU__RESEND: "Resend",
    MESSAGE_MENU__DELETE: "Delete",
    MESSAGE_MENU__SAVE: "Save",
    //  * FIXME: get back legacy, remove after refactoring open channel messages *
    CONTEXT_MENU_DROPDOWN__COPY: "Copy",
    CONTEXT_MENU_DROPDOWN__EDIT: "Edit",
    CONTEXT_MENU_DROPDOWN__RESEND: "Resend",
    CONTEXT_MENU_DROPDOWN__DELETE: "Delete",
    CONTEXT_MENU_DROPDOWN__SAVE: "Save",
    // Feature - Message Search
    SEARCH: "Search",
    SEARCH_IN_CHANNEL: "Search in channel",
    SEARCH_IN: "Search in",
    SEARCHING: "Searching for messages...",
    NO_SEARCHED_MESSAGE: "No results found.",
    // Feature - Message Reply
    QUOTE_MESSAGE_INPUT__REPLY_TO: "Reply to",
    QUOTE_MESSAGE_INPUT__FILE_TYPE_IMAGE: "Photo",
    QUOTE_MESSAGE_INPUT__FILE_TYPE_GIF: "GIF",
    QUOTE_MESSAGE_INPUT__FILE_TYPE__VIDEO: "Video",
    QUOTED_MESSAGE__REPLIED_TO: "replied to",
    QUOTED_MESSAGE__CURRENT_USER: "You",
    QUOTED_MESSAGE__UNAVAILABLE: "Message unavailable",
    // Feature - Thread
    THREAD__HEADER_TITLE: "Thread",
    CHANNEL__THREAD_REPLY: "reply",
    CHANNEL__THREAD_REPLIES: "replies",
    CHANNEL__THREAD_OVER_MAX: "99+",
    THREAD__THREAD_REPLY: "reply",
    THREAD__THREAD_REPLIES: "replies",
    THREAD__INPUT__REPLY_TO_THREAD: "Reply to thread",
    THREAD__INPUT__REPLY_IN_THREAD: "Reply in thread",
    // Feature - Mention
    MENTION_NAME__NO_NAME: "(No name)",
    MENTION_COUNT__OVER_LIMIT: "You can mention up to %d times at a time.",
    UI__FILE_VIEWER__UNSUPPORT: "Unsupported message",
    // Feature - Voice Message
    VOICE_RECORDING_PERMISSION_DENIED: `You cannot record the voice since
        voice recording is not permitted in your device system setting`,
    VOICE_MESSAGE: "Voice Message",
    // Channel preview last message file type display strings
    CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_GIF: "GIF",
    CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_PHOTO: "Photo",
    CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_VIDEO: "Video",
    CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_AUDIO: "Audio",
    CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_VOICE_MESSAGE: "Voice message",
    CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_GENERAL: "File",
    CHANNEL_PREVIEW_LAST_MESSAGE_TEMPLATE_MESSAGE: "Message",
    // Date format
    DATE_FORMAT__MESSAGE_LIST__NOTIFICATION__UNREAD_SINCE: "p 'on' MMM dd",
    DATE_FORMAT__MESSAGE_LIST__DATE_SEPARATOR: "MMMM dd, yyyy",
    DATE_FORMAT__THREAD_LIST__DATE_SEPARATOR: "MMM dd, yyyy",
    // File upload
    FILE_UPLOAD_NOTIFICATION__COUNT_LIMIT: "Up to %d files can be attached.",
    FILE_UPLOAD_NOTIFICATION__SIZE_LIMIT: "The maximum size per file is %d MB.",
    // Feedback button text
    FEEDBACK_LIKE: "Like",
    FEEDBACK_DISLIKE: "Dislike",
    // Mobile feedback options menu items
    EDIT_COMMENT: "Edit comment",
    REMOVE_FEEDBACK: "Remove Feedback",
    // Feedback modal title
    FEEDBACK_MODAL_TITLE: "Provide additional feedback (optional)",
    FEEDBACK_CONTENT_PLACEHOLDER: "Leave a comment",
    BUTTON__REMOVE_FEEDBACK: "Remove feedback",
    // Feedback failed modal title
    FEEDBACK_FAILED_SUBMIT: "Couldn’t submit. Try again.",
    FEEDBACK_FAILED_SAVE: "Couldn’t save. Try again.",
    FEEDBACK_FAILED_DELETE: "Couldn’t delete. Try again."
  }
}, ZR = function(e) {
  return e === void 0 && (e = "en"), dH[e];
}, rH = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, iH = function(n, t, l) {
  var a, d = rH[n];
  return typeof d == "string" ? a = d : t === 1 ? a = d.one : a = d.other.replace("{{count}}", t.toString()), l != null && l.addSuffix ? l.comparison && l.comparison > 0 ? "in " + a : a + " ago" : a;
}, VH = iH;
function QZ(e) {
  return function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = n.width ? String(n.width) : e.defaultWidth, l = e.formats[t] || e.formats[e.defaultWidth];
    return l;
  };
}
var cH = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, sH = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, oH = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, UH = {
  date: QZ({
    formats: cH,
    defaultWidth: "full"
  }),
  time: QZ({
    formats: sH,
    defaultWidth: "full"
  }),
  dateTime: QZ({
    formats: oH,
    defaultWidth: "full"
  })
}, NH = UH, RH = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, hH = function(n, t, l, a) {
  return RH[n];
}, ZH = hH;
function is(e) {
  return function(n, t) {
    var l = t != null && t.context ? String(t.context) : "standalone", a;
    if (l === "formatting" && e.formattingValues) {
      var d = e.defaultFormattingWidth || e.defaultWidth, r = t != null && t.width ? String(t.width) : d;
      a = e.formattingValues[r] || e.formattingValues[d];
    } else {
      var i = e.defaultWidth, c = t != null && t.width ? String(t.width) : e.defaultWidth;
      a = e.values[c] || e.values[i];
    }
    var V = e.argumentCallback ? e.argumentCallback(n) : n;
    return a[V];
  };
}
var TH = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, FH = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, WH = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}, mH = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}, uH = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, pH = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, MH = function(n, t) {
  var l = Number(n), a = l % 100;
  if (a > 20 || a < 10)
    switch (a % 10) {
      case 1:
        return l + "st";
      case 2:
        return l + "nd";
      case 3:
        return l + "rd";
    }
  return l + "th";
}, EH = {
  ordinalNumber: MH,
  era: is({
    values: TH,
    defaultWidth: "wide"
  }),
  quarter: is({
    values: FH,
    defaultWidth: "wide",
    argumentCallback: function(n) {
      return n - 1;
    }
  }),
  month: is({
    values: WH,
    defaultWidth: "wide"
  }),
  day: is({
    values: mH,
    defaultWidth: "wide"
  }),
  dayPeriod: is({
    values: uH,
    defaultWidth: "wide",
    formattingValues: pH,
    defaultFormattingWidth: "wide"
  })
}, SH = EH;
function Vs(e) {
  return function(n) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = t.width, a = l && e.matchPatterns[l] || e.matchPatterns[e.defaultMatchWidth], d = n.match(a);
    if (!d)
      return null;
    var r = d[0], i = l && e.parsePatterns[l] || e.parsePatterns[e.defaultParseWidth], c = Array.isArray(i) ? bH(i, function(o) {
      return o.test(r);
    }) : kH(i, function(o) {
      return o.test(r);
    }), V;
    V = e.valueCallback ? e.valueCallback(c) : c, V = t.valueCallback ? t.valueCallback(V) : V;
    var s = n.slice(r.length);
    return {
      value: V,
      rest: s
    };
  };
}
function kH(e, n) {
  for (var t in e)
    if (e.hasOwnProperty(t) && n(e[t]))
      return t;
}
function bH(e, n) {
  for (var t = 0; t < e.length; t++)
    if (n(e[t]))
      return t;
}
function YH(e) {
  return function(n) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = n.match(e.matchPattern);
    if (!l)
      return null;
    var a = l[0], d = n.match(e.parsePattern);
    if (!d)
      return null;
    var r = e.valueCallback ? e.valueCallback(d[0]) : d[0];
    r = t.valueCallback ? t.valueCallback(r) : r;
    var i = n.slice(a.length);
    return {
      value: r,
      rest: i
    };
  };
}
var QH = /^(\d+)(th|st|nd|rd)?/i, JH = /\d+/i, vH = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, zH = {
  any: [/^b/i, /^(a|c)/i]
}, xH = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, GH = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, yH = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, BH = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}, DH = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, XH = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, OH = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, jH = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, HH = {
  ordinalNumber: YH({
    matchPattern: QH,
    parsePattern: JH,
    valueCallback: function(n) {
      return parseInt(n, 10);
    }
  }),
  era: Vs({
    matchPatterns: vH,
    defaultMatchWidth: "wide",
    parsePatterns: zH,
    defaultParseWidth: "any"
  }),
  quarter: Vs({
    matchPatterns: xH,
    defaultMatchWidth: "wide",
    parsePatterns: GH,
    defaultParseWidth: "any",
    valueCallback: function(n) {
      return n + 1;
    }
  }),
  month: Vs({
    matchPatterns: yH,
    defaultMatchWidth: "wide",
    parsePatterns: BH,
    defaultParseWidth: "any"
  }),
  day: Vs({
    matchPatterns: DH,
    defaultMatchWidth: "wide",
    parsePatterns: XH,
    defaultParseWidth: "any"
  }),
  dayPeriod: Vs({
    matchPatterns: OH,
    defaultMatchWidth: "any",
    parsePatterns: jH,
    defaultParseWidth: "any"
  })
}, fH = HH, wH = {
  code: "en-US",
  formatDistance: VH,
  formatLong: NH,
  formatRelative: ZH,
  localize: SH,
  match: fH,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
}, Ob = wH, Kn = T.createContext({
  stringSet: ZR("en"),
  dateLocale: Ob
}), gH = function(e) {
  var n = e.children;
  return T.createElement(Kn.Provider, { value: e }, n);
}, ca = function() {
  return T.useContext(Kn);
}, IH = !1, jb = "sendbird--mobile-mode", Hb = T.createContext({
  breakpoint: IH,
  isMobile: !1
}), cp = function() {
  try {
    var e = document.querySelector("body");
    e == null || e.classList.add(jb);
  } catch {
  }
}, sp = function() {
  try {
    var e = document.querySelector("body");
    e == null || e.classList.remove(jb);
  } catch {
  }
}, LH = function(e) {
  var n = e.children, t = e.logger, l = (e == null ? void 0 : e.breakpoint) || !1, a = me(!1), d = a[0], r = a[1];
  return _e(function() {
    var i, c = function() {
      var V, s, o, U, N;
      if (typeof l == "boolean")
        r(l), l ? ((V = t == null ? void 0 : t.info) === null || V === void 0 || V.call(t, "MediaQueryProvider: isMobile: true"), cp()) : ((s = t == null ? void 0 : t.info) === null || s === void 0 || s.call(t, "MediaQueryProvider: isMobile: false"), sp());
      else {
        var R = window.matchMedia("(max-width: ".concat(l, ")"));
        (o = t == null ? void 0 : t.info) === null || o === void 0 || o.call(t, "MediaQueryProvider: Screensize updated to ".concat(l)), R.matches ? (r(!0), cp(), (U = t == null ? void 0 : t.info) === null || U === void 0 || U.call(t, "MediaQueryProvider: isMobile: true")) : (r(!1), sp(), (N = t == null ? void 0 : t.info) === null || N === void 0 || N.call(t, "MediaQueryProvider: isMobile: false"));
      }
    };
    return c(), window.addEventListener("resize", c), (i = t == null ? void 0 : t.info) === null || i === void 0 || i.call(t, "MediaQueryProvider: addEventListener", { updateSize: c }), function() {
      var V;
      window.removeEventListener("resize", c), (V = t == null ? void 0 : t.info) === null || V === void 0 || V.call(t, "MediaQueryProvider: removeEventListener", { updateSize: c });
    };
  }, [l]), T.createElement(Hb.Provider, { value: { breakpoint: l, isMobile: d } }, n);
}, dr = function() {
  return T.useContext(Hb);
}, Fi = T.forwardRef(function(e, n) {
  var t = e.className, l = t === void 0 ? "" : t, a = e.children, d = e.disabled, r = d === void 0 ? !1 : d, i = e.width, c = i === void 0 ? "56px" : i, V = e.height, s = V === void 0 ? "56px" : V, o = e.type, U = o === void 0 ? "button" : o, N = e.style, R = N === void 0 ? {} : N, h = e.onBlur, Z = h === void 0 ? function() {
  } : h, W = e.onClick, F = W === void 0 ? function() {
  } : W, m = me(!1), E = m[0], u = m[1];
  return T.createElement(
    "button",
    { className: Ut(Ut([], Array.isArray(l) ? l : [l], !0), [
      "sendbird-iconbutton",
      E ? "sendbird-iconbutton--pressed" : ""
    ], !1).join(" "), disabled: r, ref: n, type: U, style: ce(ce({}, R), { height: s, width: c }), onClick: function(b) {
      r || (u(!0), F == null || F(b));
    }, onBlur: function(b) {
      u(!1), Z == null || Z(b);
    } },
    T.createElement("span", { className: "sendbird-iconbutton__inner" }, a)
  );
}), Ma = {
  H_1: "H_1",
  H_2: "H_2",
  SUBTITLE_1: "SUBTITLE_1",
  SUBTITLE_2: "SUBTITLE_2",
  BODY_1: "BODY_1",
  BODY_2: "BODY_2",
  BUTTON_1: "BUTTON_1",
  BUTTON_2: "BUTTON_2",
  BUTTON_3: "BUTTON_3",
  CAPTION_1: "CAPTION_1",
  CAPTION_2: "CAPTION_2",
  CAPTION_3: "CAPTION_3"
}, Ia = {
  ONBACKGROUND_1: "ONBACKGROUND_1",
  ONBACKGROUND_2: "ONBACKGROUND_2",
  ONBACKGROUND_3: "ONBACKGROUND_3",
  ONBACKGROUND_4: "ONBACKGROUND_4",
  ONCONTENT_1: "ONCONTENT_1",
  ONCONTENT_2: "ONCONTENT_2",
  ONCONTENT_INVERSE_1: "ONCONTENT_INVERSE_1",
  ONCONTENT_INVERSE_5: "ONCONTENT_INVERSE_5",
  PRIMARY: "PRIMARY",
  ERROR: "ERROR",
  SECONDARY_3: "SECONDARY_3"
};
function CH(e) {
  switch (e) {
    case Ma.H_1:
      return "sendbird-label--h-1";
    case Ma.H_2:
      return "sendbird-label--h-2";
    case Ma.SUBTITLE_1:
      return "sendbird-label--subtitle-1";
    case Ma.SUBTITLE_2:
      return "sendbird-label--subtitle-2";
    case Ma.BODY_1:
      return "sendbird-label--body-1";
    case Ma.BODY_2:
      return "sendbird-label--body-2";
    case Ma.BUTTON_1:
      return "sendbird-label--button-1";
    case Ma.BUTTON_2:
      return "sendbird-label--button-2";
    case Ma.BUTTON_3:
      return "sendbird-label--button-3";
    case Ma.CAPTION_1:
      return "sendbird-label--caption-1";
    case Ma.CAPTION_2:
      return "sendbird-label--caption-2";
    case Ma.CAPTION_3:
      return "sendbird-label--caption-3";
    default:
      return "";
  }
}
function fb(e) {
  switch (e) {
    case Ia.ONBACKGROUND_1:
      return "sendbird-label--color-onbackground-1";
    case Ia.ONBACKGROUND_2:
      return "sendbird-label--color-onbackground-2";
    case Ia.ONBACKGROUND_3:
      return "sendbird-label--color-onbackground-3";
    case Ia.ONBACKGROUND_4:
      return "sendbird-label--color-onbackground-4";
    case Ia.ONCONTENT_1:
      return "sendbird-label--color-oncontent-1";
    case Ia.ONCONTENT_2:
      return "sendbird-label--color-oncontent-2";
    case Ia.ONCONTENT_INVERSE_1:
      return "sendbird-label--color-oncontent-inverse-1";
    case Ia.ONCONTENT_INVERSE_5:
      return "sendbird-label--color-oncontent-inverse-5";
    case Ia.PRIMARY:
      return "sendbird-label--color-primary";
    case Ia.ERROR:
      return "sendbird-label--color-error";
    case Ia.SECONDARY_3:
      return "sendbird-label--color-secondary-3";
    default:
      return "";
  }
}
function Fe(e) {
  var n = e.className, t = n === void 0 ? [] : n, l = e.type, a = e.color, d = e.children, r = d === void 0 ? null : d;
  return (
    // Donot make this into div
    // Mention uses Label. If we use div, it would break the mention detection on Paste
    // https://github.com/sendbird/sendbird-uikit-react/pull/479
    T.createElement("span", { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
      "sendbird-label",
      CH(l),
      fb(a)
    ], !1).join(" ") }, r)
  );
}
var oe = Ma, ie = Ia, wb = ZR("en"), nl;
(function(e) {
  e.PRIMARY = "PRIMARY", e.SECONDARY = "SECONDARY", e.DANGER = "DANGER", e.DISABLED = "DISABLED", e.WARNING = "WARNING";
})(nl || (nl = {}));
var Ei;
(function(e) {
  e.BIG = "BIG", e.SMALL = "SMALL";
})(Ei || (Ei = {}));
function KH(e) {
  switch (e) {
    case nl.PRIMARY:
      return "sendbird-button--primary";
    case nl.SECONDARY:
      return "sendbird-button--secondary";
    case nl.DANGER:
      return "sendbird-button--danger";
    case nl.DISABLED:
      return "sendbird-button--disabled";
    case nl.WARNING:
      return "sendbird-button--warning";
    default:
      return null;
  }
}
function _H(e) {
  switch (e) {
    case Ei.BIG:
      return "sendbird-button--big";
    case Ei.SMALL:
      return "sendbird-button--small";
    default:
      return null;
  }
}
function Ql(e) {
  var n = e.className, t = e.type, l = t === void 0 ? nl.PRIMARY : t, a = e.size, d = a === void 0 ? Ei.BIG : a, r = e.children, i = r === void 0 ? "Button" : r, c = e.disabled, V = c === void 0 ? !1 : c, s = e.onClick, o = s === void 0 ? function() {
  } : s, U = e.labelType, N = U === void 0 ? oe.BUTTON_1 : U, R = e.labelColor, h = R === void 0 ? ie.ONCONTENT_1 : R, Z = Ut(Ut([], Array.isArray(n) ? n : [n], !0), [
    "sendbird-button",
    V ? "sendbird-button__disabled" : "",
    KH(l),
    _H(d)
  ], !1).join(" ");
  return T.createElement(
    "button",
    { className: Z, type: "button", onClick: o, disabled: V },
    T.createElement(Fe, { className: "sendbird-button__text", type: N, color: h }, i)
  );
}
var ke = {
  ADD: "ADD",
  ARROW_LEFT: "ARROW_LEFT",
  ATTACH: "ATTACH",
  AUDIO_ON_LINED: "AUDIO_ON_LINED",
  BAN: "BAN",
  BROADCAST: "BROADCAST",
  CAMERA: "CAMERA",
  CHANNELS: "CHANNELS",
  CHAT: "CHAT",
  CHAT_FILLED: "CHAT_FILLED",
  CHEVRON_DOWN: "CHEVRON_DOWN",
  CHEVRON_RIGHT: "CHEVRON_RIGHT",
  CLOSE: "CLOSE",
  COLLAPSE: "COLLAPSE",
  COPY: "COPY",
  CREATE: "CREATE",
  DELETE: "DELETE",
  DISCONNECTED: "DISCONNECTED",
  DOCUMENT: "DOCUMENT",
  DONE: "DONE",
  DONE_ALL: "DONE_ALL",
  DOWNLOAD: "DOWNLOAD",
  EDIT: "EDIT",
  EMOJI_MORE: "EMOJI_MORE",
  ERROR: "ERROR",
  EXPAND: "EXPAND",
  FILE_AUDIO: "FILE_AUDIO",
  FILE_DOCUMENT: "FILE_DOCUMENT",
  FREEZE: "FREEZE",
  GIF: "GIF",
  INFO: "INFO",
  LEAVE: "LEAVE",
  MEMBERS: "MEMBERS",
  MESSAGE: "MESSAGE",
  MODERATIONS: "MODERATIONS",
  MORE: "MORE",
  MUTE: "MUTE",
  NOTIFICATIONS: "NOTIFICATIONS",
  NOTIFICATIONS_OFF_FILLED: "NOTIFICATIONS_OFF_FILLED",
  OPERATOR: "OPERATOR",
  PHOTO: "PHOTO",
  PLAY: "PLAY",
  PLUS: "PLUS",
  QUESTION: "QUESTION",
  REFRESH: "REFRESH",
  REPLY: "REPLY",
  REMOVE: "REMOVE",
  SEARCH: "SEARCH",
  SEND: "SEND",
  SETTINGS_FILLED: "SETTINGS_FILLED",
  SLIDE_LEFT: "SLIDE_LEFT",
  SPINNER: "SPINNER",
  SUPERGROUP: "SUPERGROUP",
  THREAD: "THREAD",
  THUMBNAIL_NONE: "THUMBNAIL_NONE",
  TOGGLE_OFF: "TOGGLE_OFF",
  TOGGLE_ON: "TOGGLE_ON",
  USER: "USER",
  FEEDBACK_LIKE: "FEEDBACK_LIKE",
  FEEDBACK_DISLIKE: "FEEDBACK_DISLIKE"
}, Zl = {
  DEFAULT: "DEFAULT",
  PRIMARY: "PRIMARY",
  PRIMARY_2: "PRIMARY_2",
  SECONDARY: "SECONDARY",
  CONTENT: "CONTENT",
  CONTENT_INVERSE: "CONTENT_INVERSE",
  CONTENT_INVERSE_5: "CONTENT_INVERSE_5",
  WHITE: "WHITE",
  GRAY: "GRAY",
  THUMBNAIL_ICON: "THUMBNAIL_ICON",
  SENT: "SENT",
  READ: "READ",
  ON_BACKGROUND_1: "ON_BACKGROUND_1",
  ON_BACKGROUND_2: "ON_BACKGROUND_2",
  ON_BACKGROUND_3: "ON_BACKGROUND_3",
  ON_BACKGROUND_4: "ON_BACKGROUND_4",
  BACKGROUND_3: "BACKGROUND_3",
  ERROR: "ERROR"
};
function PH(e) {
  switch (e) {
    case Zl.PRIMARY:
      return "sendbird-icon-color--primary";
    case Zl.PRIMARY_2:
      return "sendbird-icon-color--primary-2";
    case Zl.SECONDARY:
      return "sendbird-icon-color--secondary";
    case Zl.CONTENT:
      return "sendbird-icon-color--content";
    case Zl.CONTENT_INVERSE:
      return "sendbird-icon-color--content-inverse";
    case Zl.CONTENT_INVERSE_5:
      return "sendbird-icon-color--content-inverse-5";
    case Zl.WHITE:
      return "sendbird-icon-color--white";
    case Zl.GRAY:
      return "sendbird-icon-color--gray";
    case Zl.THUMBNAIL_ICON:
      return "sendbird-icon-color--thumbnail-icon";
    case Zl.SENT:
      return "sendbird-icon-color--sent";
    case Zl.READ:
      return "sendbird-icon-color--read";
    case Zl.ON_BACKGROUND_1:
      return "sendbird-icon-color--on-background-1";
    case Zl.ON_BACKGROUND_2:
      return "sendbird-icon-color--on-background-2";
    case Zl.ON_BACKGROUND_3:
      return "sendbird-icon-color--on-background-3";
    case Zl.ON_BACKGROUND_4:
      return "sendbird-icon-color--on-background-4";
    case Zl.BACKGROUND_3:
      return "sendbird-icon-color--background-3";
    case Zl.ERROR:
      return "sendbird-icon-color--error";
    default:
      return "";
  }
}
function AH(e) {
  switch (e) {
    case ke.ADD:
      return "sendbird-icon-add";
    case ke.ARROW_LEFT:
      return "sendbird-icon-arrow-left";
    case ke.ATTACH:
      return "sendbird-icon-attach";
    case ke.AUDIO_ON_LINED:
      return "sendbird-icon-audio-on-lined";
    case ke.BAN:
      return "sendbird-icon-ban";
    case ke.BROADCAST:
      return "sendbird-icon-broadcast";
    case ke.CAMERA:
      return "sendbird-icon-camera";
    case ke.CHANNELS:
      return "sendbird-icon-channels";
    case ke.CHAT:
      return "sendbird-icon-chat";
    case ke.CHAT_FILLED:
      return "sendbird-icon-chat-filled";
    case ke.CHEVRON_DOWN:
      return "sendbird-icon-chevron-down";
    case ke.CHEVRON_RIGHT:
      return "sendbird-icon-chevron-right";
    case ke.CLOSE:
      return "sendbird-icon-close";
    case ke.COLLAPSE:
      return "sendbird-icon-collapse";
    case ke.COPY:
      return "sendbird-icon-copy";
    case ke.CREATE:
      return "sendbird-icon-create";
    case ke.DELETE:
      return "sendbird-icon-delete";
    case ke.DISCONNECTED:
      return "sendbird-icon-disconnected";
    case ke.DOCUMENT:
      return "sendbird-icon-document";
    case ke.DONE:
      return "sendbird-icon-done";
    case ke.DONE_ALL:
      return "sendbird-icon-done-all";
    case ke.DOWNLOAD:
      return "sendbird-icon-down-load";
    case ke.EDIT:
      return "sendbird-icon-edit";
    case ke.EMOJI_MORE:
      return "sendbird-icon-emoji-more";
    case ke.ERROR:
      return "sendbird-icon-error";
    case ke.EXPAND:
      return "sendbird-icon-expand";
    case ke.FILE_AUDIO:
      return "sendbird-icon-file-audio";
    case ke.FILE_DOCUMENT:
      return "sendbird-icon-file-document";
    case ke.FREEZE:
      return "sendbird-icon-freeze";
    case ke.GIF:
      return "sendbird-icon-gif";
    case ke.INFO:
      return "sendbird-icon-info";
    case ke.LEAVE:
      return "sendbird-icon-leave";
    case ke.MEMBERS:
      return "sendbird-icon-members";
    case ke.MESSAGE:
      return "sendbird-icon-message";
    case ke.MODERATIONS:
      return "sendbird-icon-moderations";
    case ke.MORE:
      return "sendbird-icon-more";
    case ke.MUTE:
      return "sendbird-icon-mute";
    case ke.NOTIFICATIONS:
      return "sendbird-icon-notifications";
    case ke.NOTIFICATIONS_OFF_FILLED:
      return "sendbird-icon-notifications-off-filled";
    case ke.OPERATOR:
      return "sendbird-icon-operator";
    case ke.PHOTO:
      return "sendbird-icon-photo";
    case ke.PLAY:
      return "sendbird-icon-play";
    case ke.PLUS:
      return "sendbird-iconn-plus";
    case ke.QUESTION:
      return "sendbird-icon-question";
    case ke.REFRESH:
      return "sendbird-icon-refresh";
    case ke.REMOVE:
      return "sendbird-icon-remove";
    case ke.REPLY:
      return "sendbird-icon-reply";
    case ke.SEARCH:
      return "sendbird-icon-search";
    case ke.SEND:
      return "sendbird-icon-send";
    case ke.SETTINGS_FILLED:
      return "sendbird-icon-settings-filled";
    case ke.SPINNER:
      return "sendbird-icon-spinner";
    case ke.SUPERGROUP:
      return "sendbird-icon-supergroup";
    case ke.THREAD:
      return "sendbird-icon-thread";
    case ke.THUMBNAIL_NONE:
      return "sendbird-icon-thumbnail-none";
    case ke.TOGGLE_OFF:
      return "sendbird-icon-toggle-off";
    case ke.TOGGLE_ON:
      return "sendbird-icon-toggle-on";
    case ke.USER:
      return "sendbird-icon-user";
    case ke.FEEDBACK_LIKE:
      return "sendbird-icon-feedback-like";
    case ke.FEEDBACK_DISLIKE:
      return "sendbird-icon-feedback-dislike";
    default:
      return "sendbird-icon-unknown";
  }
}
var op;
function R0() {
  return R0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, R0.apply(this, arguments);
}
var qH = function(n) {
  return /* @__PURE__ */ z.createElement("svg", R0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), op || (op = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M50.667 5.333a8 8 0 0 1 8 8v37.334a8 8 0 0 1-8 8H13.333a8 8 0 0 1-8-8V13.333a8 8 0 0 1 8-8zm0 5.334H13.333a2.667 2.667 0 0 0-2.666 2.666v37.334a2.667 2.667 0 0 0 2.666 2.666h37.334a2.667 2.667 0 0 0 2.666-2.666V13.333a2.667 2.667 0 0 0-2.666-2.666m-18.667 8a2.667 2.667 0 0 1 2.649 2.355l.018.311v8h8a2.667 2.667 0 0 1 .311 5.316l-.311.018h-8v8a2.667 2.667 0 0 1-5.316.311l-.018-.311v-8h-8a2.667 2.667 0 0 1-.311-5.316l.311-.018h8v-8A2.667 2.667 0 0 1 32 18.667",
    className: "icon-add_svg__fill"
  })));
}, Up;
function h0() {
  return h0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, h0.apply(this, arguments);
}
var $H = function(n) {
  return /* @__PURE__ */ z.createElement("svg", h0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Up || (Up = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M33.886 8.781a2.67 2.67 0 0 1 .221 3.52l-.221.251-16.78 16.781H56a2.667 2.667 0 0 1 .311 5.316l-.311.018-38.895-.001 16.78 16.782a2.666 2.666 0 0 1 .222 3.52l-.221.251a2.67 2.67 0 0 1-3.52.222l-.252-.222L8.781 33.886a2.67 2.67 0 0 1-.222-3.52l.222-.252L30.114 8.781a2.67 2.67 0 0 1 3.772 0",
    className: "icon-arrow-left_svg__fill"
  })));
}, Np;
function Z0() {
  return Z0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, Z0.apply(this, arguments);
}
var ef = function(n) {
  return /* @__PURE__ */ z.createElement("svg", Z0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Np || (Np = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "m55.334 28.926-24.506 23.34c-5.222 4.973-13.74 4.973-18.962 0-5.149-4.903-5.149-12.797 0-17.7l24.506-23.34c3.138-2.988 8.278-2.988 11.416 0 3.064 2.919 3.064 7.594 0 10.513L23.255 45.077c-1.055 1.005-2.815 1.005-3.87.001-.98-.933-.98-2.39 0-3.325l22.64-21.535a2.667 2.667 0 0 0-3.676-3.864L15.709 37.89a7.58 7.58 0 0 0-.001 11.05c3.113 2.966 8.11 2.966 11.224 0l24.533-23.338c5.272-5.021 5.272-13.217 0-18.238-5.197-4.95-13.573-4.95-18.77 0L8.187 30.704c-7.356 7.005-7.356 18.419 0 25.424 7.281 6.935 19.036 6.935 26.318 0l24.506-23.34a2.666 2.666 0 1 0-3.678-3.862z",
    className: "icon-attach_svg__fill"
  })));
}, Rp, hp;
function T0() {
  return T0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, T0.apply(this, arguments);
}
var tf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", T0({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 64 64"
  }, n), Rp || (Rp = /* @__PURE__ */ z.createElement("g", {
    clipPath: "url(#icon-audio-on-lined_svg__a)"
  }, /* @__PURE__ */ z.createElement("path", {
    d: "M32 0C26.11 0 21.333 4.776 21.333 10.667V32c0 5.891 4.776 10.667 10.667 10.667S42.667 37.89 42.667 32V10.667C42.667 4.776 37.89 0 32 0m-5.333 10.667a5.333 5.333 0 0 1 10.666 0V32a5.333 5.333 0 0 1-10.666 0z",
    className: "icon-audio-on-lined_svg__fill",
    clipRule: "evenodd"
  }), /* @__PURE__ */ z.createElement("path", {
    d: "M16 26.667a2.667 2.667 0 1 0-5.333 0V32c0 10.879 8.143 19.856 18.666 21.168v5.499h-8a2.667 2.667 0 0 0 0 5.333h21.334a2.667 2.667 0 1 0 0-5.333h-8v-5.499C45.19 51.856 53.333 42.88 53.333 32v-5.333a2.667 2.667 0 1 0-5.333 0V32c0 8.837-7.163 16-16 16s-16-7.163-16-16z",
    className: "icon-audio-on-lined_svg__fill"
  }))), hp || (hp = /* @__PURE__ */ z.createElement("defs", null, /* @__PURE__ */ z.createElement("clipPath", {
    id: "icon-audio-on-lined_svg__a"
  }, /* @__PURE__ */ z.createElement("path", {
    fill: "#fff",
    d: "M0 0h64v64H0z"
  })))));
}, Zp;
function F0() {
  return F0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, F0.apply(this, arguments);
}
var nf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", F0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Zp || (Zp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 2.667C48.2 2.667 61.333 15.8 61.333 32S48.2 61.333 32 61.333 2.667 48.2 2.667 32 15.8 2.667 32 2.667M32 8C18.745 8 8 18.745 8 32s10.745 24 24 24 24-10.745 24-24S45.255 8 32 8m12.333 21.333a1 1 0 0 1 1 1v3.334a1 1 0 0 1-1 1H19.667a1 1 0 0 1-1-1v-3.334a1 1 0 0 1 1-1z",
    className: "icon-ban_svg__fill"
  })));
}, Tp;
function W0() {
  return W0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, W0.apply(this, arguments);
}
var lf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", W0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Tp || (Tp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M58.545 5.498q.121.389.122.796v46.079a2.666 2.666 0 0 1-3.462 2.546l-17.951-5.61c-.645 5.273-5.14 9.358-10.587 9.358C20.776 58.667 16 53.89 16 48v-5.334h-5.333a8 8 0 0 1-7.997-7.75l-.003-.25V24a8 8 0 0 1 8-8H16L55.205 3.749a2.665 2.665 0 0 1 3.34 1.75zM21.333 44.587V48a5.333 5.333 0 0 0 10.652.398L32 47.92zm32-34.667-32 9.997v18.83l32 9.997zM16 21.333h-5.333a2.67 2.67 0 0 0-2.65 2.356L8 24v10.667a2.667 2.667 0 0 0 2.667 2.666H16z",
    className: "icon-broadcast_svg__fill"
  })));
}, Fp;
function m0() {
  return m0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, m0.apply(this, arguments);
}
var af = function(n) {
  return /* @__PURE__ */ z.createElement("svg", m0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Fp || (Fp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M40 5.333c.892 0 1.724.446 2.219 1.188l4.541 6.812H56a8 8 0 0 1 7.986 7.53l.014.47v29.334a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V21.333a8 8 0 0 1 8-8h9.237l4.544-6.812a2.67 2.67 0 0 1 1.888-1.167l.331-.02zm-1.43 5.334H25.428l-4.542 6.812a2.66 2.66 0 0 1-1.887 1.167l-.331.02H8a2.67 2.67 0 0 0-2.667 2.667v29.334A2.667 2.667 0 0 0 8 53.333h48a2.667 2.667 0 0 0 2.667-2.666V21.333A2.667 2.667 0 0 0 56 18.667H45.333a2.67 2.67 0 0 1-2.218-1.188zM32 21.333c7.364 0 13.333 5.97 13.333 13.334S39.363 48 32 48s-13.333-5.97-13.333-13.333S24.637 21.333 32 21.333m0 5.334a8 8 0 1 0 0 16 8 8 0 0 0 0-16",
    className: "icon-camera_svg__fill"
  })));
}, Wp;
function u0() {
  return u0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, u0.apply(this, arguments);
}
var df = function(n) {
  return /* @__PURE__ */ z.createElement("svg", u0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Wp || (Wp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "m42.65 5.333.311.017a2.666 2.666 0 0 1 2.373 2.633l-.017.311-1.45 13.04h9.466a2.667 2.667 0 0 1 .311 5.315l-.31.018H43.271l-1.184 10.666h11.245a2.667 2.667 0 0 1 .312 5.316l-.31.018H41.495l-1.512 13.627a2.667 2.667 0 0 1-5.318-.277l.017-.311 1.448-13.04H25.496l-1.512 13.628a2.667 2.667 0 0 1-5.318-.277l.017-.311 1.448-13.04h-9.464a2.667 2.667 0 0 1-.311-5.315l.31-.018h10.057l1.186-10.667H10.667a2.667 2.667 0 0 1-.311-5.315l.31-.018h11.835l1.515-13.627a2.67 2.67 0 0 1 2.634-2.373l.311.017a2.666 2.666 0 0 1 2.373 2.633l-.017.311-1.45 13.04H38.5l1.515-13.628a2.67 2.67 0 0 1 2.634-2.373zm-5.927 32 1.186-10.667H27.272l-1.184 10.667z",
    className: "icon-channels_svg__fill"
  })));
}, mp;
function p0() {
  return p0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, p0.apply(this, arguments);
}
var rf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", p0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), mp || (mp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 2.667C48.2 2.667 61.333 15.8 61.333 32S48.2 61.333 32 61.333c-4.455 0-8.679-.993-12.461-2.77l-1.753.58q-8.947 2.868-12.504 1.981-4.198-1.047-1.657-3.663 1.757-2.094 2.928-5.234.934-2.502-.737-7A29.15 29.15 0 0 1 2.666 32C2.667 15.8 15.8 2.667 32 2.667M32 8C18.745 8 8 18.745 8 32c0 3.5.747 6.88 2.168 9.978l.405.837.137.271.106.285c1.517 4.085 1.89 7.622.734 10.72l-.382.972-.192.433.235-.05a62 62 0 0 0 4.886-1.363l1.721-.568 2.04-.696 1.95.917A23.9 23.9 0 0 0 32 56c13.255 0 24-10.745 24-24S45.255 8 32 8",
    className: "icon-chat_svg__fill"
  })));
}, up;
function M0() {
  return M0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, M0.apply(this, arguments);
}
var Vf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", M0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), up || (up = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 2.667C48.2 2.667 61.333 15.8 61.333 32S48.2 61.333 32 61.333c-4.455 0-8.679-.993-12.461-2.77l-1.753.58q-8.947 2.868-12.504 1.981-4.198-1.047-1.657-3.663 1.757-2.094 2.928-5.234.934-2.502-.737-7A29.15 29.15 0 0 1 2.666 32C2.667 15.8 15.8 2.667 32 2.667",
    className: "icon-chat-filled_svg__fill"
  })));
}, pp;
function E0() {
  return E0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, E0.apply(this, arguments);
}
var cf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", E0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), pp || (pp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M16.121 21.879a3 3 0 0 0-4.242 0 3 3 0 0 0 0 4.242l18 18a3 3 0 0 0 4.242 0l18-18a3 3 0 0 0 0-4.242 3 3 0 0 0-4.242 0L32 37.757z",
    className: "icon-chevron-down_svg__fill"
  })));
}, Mp;
function S0() {
  return S0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, S0.apply(this, arguments);
}
var sf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", S0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Mp || (Mp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M22.114 46.114a2.668 2.668 0 0 0 3.772 3.772l16-16a2.67 2.67 0 0 0 0-3.772l-16-16a2.668 2.668 0 0 0-3.772 3.772L36.23 32z",
    className: "icon-chevron-right_svg__fill"
  })));
}, Ep;
function k0() {
  return k0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, k0.apply(this, arguments);
}
var of = function(n) {
  return /* @__PURE__ */ z.createElement("svg", k0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Ep || (Ep = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M52.552 11.448a2.666 2.666 0 0 1 .222 3.52l-.222.251-16.781 16.78 16.781 16.782a2.665 2.665 0 0 1 0 3.771 2.666 2.666 0 0 1-3.52.222l-.251-.222L32 35.771 15.219 52.552a2.665 2.665 0 0 1-3.771 0 2.666 2.666 0 0 1-.222-3.52l.222-.251L28.228 32l-16.78-16.781a2.665 2.665 0 0 1 0-3.771 2.666 2.666 0 0 1 3.52-.222l.251.222 16.78 16.78 16.782-16.78a2.665 2.665 0 0 1 3.771 0",
    className: "icon-close_svg__fill"
  })));
}, Sp;
function b0() {
  return b0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, b0.apply(this, arguments);
}
var Uf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", b0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Sp || (Sp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M16 8a2.667 2.667 0 0 0-2.649 2.356l-.018.31v42.667a2.667 2.667 0 0 0 5.316.311l.018-.31V34.666h25.56l-6.113 6.114a2.67 2.67 0 0 0-.221 3.52l.221.251a2.666 2.666 0 0 0 3.52.222l.252-.222 10.666-10.666a2.666 2.666 0 0 0 .222-3.52l-.222-.252-10.666-10.666a2.666 2.666 0 0 0-3.993 3.52l.221.251 6.113 6.114h-25.56V10.667A2.667 2.667 0 0 0 16 8",
    className: "icon-collapse_svg__fill"
  })));
}, kp;
function Y0() {
  return Y0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, Y0.apply(this, arguments);
}
var Nf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", Y0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), kp || (kp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M53.333 21.333a8 8 0 0 1 8 8v24a8 8 0 0 1-8 8h-24a8 8 0 0 1-8-8v-24a8 8 0 0 1 8-8zm0 5.334h-24a2.667 2.667 0 0 0-2.666 2.666v24A2.667 2.667 0 0 0 29.333 56h24A2.667 2.667 0 0 0 56 53.333v-24a2.667 2.667 0 0 0-2.667-2.666m-18.666-24a8 8 0 0 1 7.986 7.53l.014.47v2.666a2.667 2.667 0 0 1-5.316.311l-.018-.31v-2.667a2.67 2.67 0 0 0-2.355-2.65L34.667 8h-24a2.67 2.67 0 0 0-2.65 2.356l-.017.31v24a2.67 2.67 0 0 0 2.356 2.65l.31.017h2.667a2.667 2.667 0 0 1 .311 5.316l-.31.018h-2.667a8 8 0 0 1-7.987-7.53l-.013-.47v-24c0-4.26 3.33-7.743 7.53-7.987l.47-.013z",
    className: "icon-copy_svg__fill"
  })));
}, bp;
function Q0() {
  return Q0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, Q0.apply(this, arguments);
}
var Rf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", Q0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), bp || (bp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 2.667C48.2 2.667 61.333 15.8 61.333 32S48.2 61.333 32 61.333c-4.455 0-8.679-.993-12.461-2.77l-1.753.58q-8.947 2.868-12.504 1.981-4.198-1.047-1.657-3.663 1.757-2.094 2.928-5.234.934-2.502-.737-7A29.15 29.15 0 0 1 2.666 32C2.667 15.8 15.8 2.667 32 2.667M32 8C18.745 8 8 18.745 8 32c0 3.5.747 6.88 2.168 9.978l.405.837.137.271.106.285c1.517 4.085 1.89 7.622.734 10.72l-.382.972-.192.433.235-.05a62 62 0 0 0 4.886-1.363l1.721-.568 2.04-.696 1.95.917A23.9 23.9 0 0 0 32 56c13.255 0 24-10.745 24-24S45.255 8 32 8m2.667 16v5.333H40c3.556 0 3.556 5.334 0 5.334h-5.333V40c0 3.556-5.334 3.556-5.334 0v-5.333H24c-3.556 0-3.556-5.334 0-5.334h5.333V24c0-3.556 5.334-3.556 5.334 0",
    className: "icon-create_svg__fill"
  })));
}, Yp;
function J0() {
  return J0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, J0.apply(this, arguments);
}
var hf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", J0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Yp || (Yp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M37.333 2.667c4.26 0 7.743 3.33 7.987 7.53l.013.47v2.666H56a2.667 2.667 0 0 1 .311 5.316l-.311.018h-2.668l.001 34.666c0 4.26-3.33 7.743-7.53 7.987l-.47.013H18.667a8 8 0 0 1-7.987-7.53l-.013-.47V18.667H8a2.667 2.667 0 0 1-.311-5.316L8 13.333h10.666v-2.666a8 8 0 0 1 7.53-7.987l.47-.013zm10.666 16H16v34.666a2.67 2.67 0 0 0 2.356 2.65l.31.017h26.667a2.67 2.67 0 0 0 2.65-2.356l.017-.31zm-21.332 8a2.667 2.667 0 0 1 2.648 2.355l.018.311v16a2.667 2.667 0 0 1-5.316.311l-.017-.31v-16a2.667 2.667 0 0 1 2.667-2.667m10.666 0a2.67 2.67 0 0 1 2.65 2.355l.017.311v16a2.667 2.667 0 0 1-5.315.311l-.018-.31v-16a2.667 2.667 0 0 1 2.666-2.667m0-18.667H26.667a2.67 2.67 0 0 0-2.65 2.356l-.017.31v2.667h16v-2.666a2.67 2.67 0 0 0-2.356-2.65L37.334 8z",
    className: "icon-delete_svg__fill"
  })));
}, Qp;
function v0() {
  return v0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, v0.apply(this, arguments);
}
var Zf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", v0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Qp || (Qp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "m54.534 6.069-.248.217-9.736 9.735-.04.04-9.573 9.573q-.226.178-.405.404L6.286 54.286a2.423 2.423 0 0 0 3.18 3.645l.248-.217 13.374-13.373a2.42 2.42 0 0 0 1.88-.401 12.12 12.12 0 0 1 14.04 0 2.424 2.424 0 1 0 2.808-3.952 16.95 16.95 0 0 0-11.303-3.072l6.743-6.744a24.1 24.1 0 0 1 10.159 5.021 2.424 2.424 0 0 0 3.11-3.719 29 29 0 0 0-9.34-5.23l5.633-5.634a36.2 36.2 0 0 1 9.225 5.934 2.425 2.425 0 0 0 3.211-3.633 41 41 0 0 0-8.796-5.941l7.256-7.256a2.423 2.423 0 0 0-3.18-3.645m-35.04 21.474a29 29 0 0 0-6.032 3.942 2.424 2.424 0 0 0 3.137 3.697 24 24 0 0 1 5.022-3.282 2.425 2.425 0 0 0-2.127-4.357M4.748 22.909a2.424 2.424 0 0 0 3.207 3.636 36.36 36.36 0 0 1 26.978-8.977 2.424 2.424 0 0 0 .389-4.832A41.2 41.2 0 0 0 4.748 22.909",
    className: "icon-disconnected_svg__fill"
  })));
}, Jp;
function z0() {
  return z0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, z0.apply(this, arguments);
}
var Tf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", z0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Jp || (Jp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M37.333 2.667a3 3 0 0 1 .274.014l.085.01.058.008q.07.01.141.026l.029.007q.075.016.146.037l.034.01q.357.107.663.303l.034.022q.053.034.104.072l.057.043q.045.033.085.068.091.075.176.16l-.126-.117q.075.065.143.135L55.21 19.438q.07.07.134.143l.035.04q.04.047.076.096l.04.054.07.1.024.038c.16.253.279.535.347.836l.01.048q.014.064.024.13l.006.048.007.051.004.041q.014.135.014.27v32a8 8 0 0 1-8 8H16a8 8 0 0 1-8-8V10.667a8 8 0 0 1 8-8zM34.666 8H16a2.667 2.667 0 0 0-2.667 2.667v42.666A2.667 2.667 0 0 0 16 56h32a2.667 2.667 0 0 0 2.667-2.667L50.666 24H37.333a2.667 2.667 0 0 1-2.648-2.356l-.018-.31zm12.227 10.667-6.894-6.894.001 6.894z",
    className: "icon-document_svg__fill"
  })));
}, vp;
function x0() {
  return x0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, x0.apply(this, arguments);
}
var Ff = function(n) {
  return /* @__PURE__ */ z.createElement("svg", x0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), vp || (vp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M12.552 31.448a2.665 2.665 0 1 0-3.771 3.771l13.333 13.333a2.666 2.666 0 0 0 3.772 0L55.219 19.22a2.667 2.667 0 0 0-3.771-3.771L24 42.895z",
    className: "icon-done_svg__fill"
  })));
}, zp;
function G0() {
  return G0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, G0.apply(this, arguments);
}
var Wf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", G0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), zp || (zp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M5.886 31.448 19.219 44.78a2.667 2.667 0 0 1-3.771 3.771L2.114 35.22a2.667 2.667 0 0 1 3.772-3.771zm52.228-16a2.666 2.666 0 1 1 3.772 3.771L32.552 48.552a2.665 2.665 0 0 1-3.771 0L15.448 35.22a2.665 2.665 0 0 1 0-3.771 2.665 2.665 0 0 1 3.771 0l11.448 11.447zm-9.562 0a2.665 2.665 0 0 1 0 3.771L32.556 35.215a2.665 2.665 0 0 1-3.771 0 2.664 2.664 0 0 1 0-3.77L44.78 15.447a2.665 2.665 0 0 1 3.771 0z",
    className: "icon-done-all_svg__fill"
  })));
}, xp;
function y0() {
  return y0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, y0.apply(this, arguments);
}
var mf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", y0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), xp || (xp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M56 42.667a2.667 2.667 0 0 1 2.649 2.355l.018.311v8c0 4.26-3.33 7.743-7.53 7.987l-.47.013H13.333a8 8 0 0 1-7.986-7.53l-.014-.47v-8a2.667 2.667 0 0 1 5.316-.311l.018.311v8a2.67 2.67 0 0 0 2.355 2.65l.311.017h37.334a2.667 2.667 0 0 0 2.648-2.356l.018-.31v-8A2.667 2.667 0 0 1 56 42.667m-36.552-8.781a2.666 2.666 0 0 1 3.52-3.993l.251.221 6.114 6.114V5.333a2.667 2.667 0 0 1 5.316-.311l.018.311v30.894l6.114-6.113a2.67 2.67 0 0 1 3.52-.221l.251.221a2.666 2.666 0 0 1 .222 3.52l-.222.252-10.658 10.657a2 2 0 0 1-.135.128l.127-.119a3 3 0 0 1-.195.176l-.056.045-.086.064-.056.04-.086.056-.06.036-.081.046-.079.04a3 3 0 0 1-.14.065l-.09.036q-.034.014-.067.025l-.09.03-.063.019q-.064.018-.13.034l-.013.003-.144.028-.064.01q-.045.008-.092.012l-.084.008-.103.006-.069.002h-.095q-.042 0-.082-.003l.139.003q-.126 0-.249-.011l-.061-.007-.092-.012-.09-.015-.118-.025-.04-.01a3 3 0 0 1-.34-.11l-.015-.006q-.074-.03-.145-.063l-.042-.02L30.71 45l-.067-.039q-.045-.026-.087-.054l-.062-.041q-.045-.03-.088-.063l-.04-.03-.008-.007a3 3 0 0 1-.251-.223z",
    className: "icon-download_svg__fill"
  })));
}, Gp;
function B0() {
  return B0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, B0.apply(this, arguments);
}
var uf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", B0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 65 65"
  }, n), Gp || (Gp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M56 56a2.667 2.667 0 0 1 .311 5.315l-.311.018H8a2.667 2.667 0 0 1-.311-5.316L8 56zM35.448 3.448a2.665 2.665 0 0 1 3.771 0l10.667 10.666a2.67 2.67 0 0 1 0 3.772L20.552 47.219c-.5.5-1.178.781-1.885.781H8a2.667 2.667 0 0 1-2.667-2.667V34.667c0-.708.281-1.386.781-1.886zm1.885 5.659L10.667 35.77v6.896h6.89L44.227 16z",
    className: "icon-edit_svg__fill"
  })));
}, yp;
function D0() {
  return D0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, D0.apply(this, arguments);
}
var pf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", D0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), yp || (yp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32.097 3.22c2.65 0 5.255.357 7.763 1.054a2.134 2.134 0 0 1-1.144 4.111 24.7 24.7 0 0 0-6.619-.899c-13.603 0-24.63 11.027-24.63 24.63s11.027 24.63 24.63 24.63 24.63-11.027 24.63-24.63c0-2.227-.295-4.413-.87-6.518a2.13 2.13 0 0 1 1.494-2.62 2.13 2.13 0 0 1 2.62 1.494 29 29 0 0 1 1.023 7.644c0 15.96-12.938 28.897-28.897 28.897-15.96 0-28.897-12.937-28.897-28.897S16.138 3.22 32.097 3.22m10.705 34.792a2.133 2.133 0 0 1 2.024 2.808c-1.873 5.623-6.937 9.488-12.729 9.488s-10.856-3.865-12.73-9.488a2.134 2.134 0 0 1 1.875-2.803l.15-.005zm-3.477 4.266H24.867l.294.382c1.539 1.887 3.718 3.113 6.115 3.342l.314.024.507.015c2.617 0 5.037-1.188 6.743-3.151l.193-.23zM21.392 21.954c1.087 0 1.985.814 2.116 1.866l.017.267v5.353a2.133 2.133 0 0 1-4.25.268l-.017-.268v-5.353c0-1.178.955-2.133 2.134-2.133m21.41 0c1.088 0 1.985.814 2.117 1.866l.017.267v5.353a2.133 2.133 0 0 1-4.25.268l-.017-.268v-5.353c0-1.178.955-2.133 2.133-2.133M54.853 0a.8.8 0 0 1 .8.8v7.786h7.76a.8.8 0 0 1 .8.8v2.667a.8.8 0 0 1-.8.8h-7.76v7.758a.8.8 0 0 1-.8.8h-2.666a.8.8 0 0 1-.8-.8v-7.758h-7.785a.8.8 0 0 1-.8-.8V9.387a.8.8 0 0 1 .8-.8l7.784-.001V.8a.8.8 0 0 1 .8-.8z",
    className: "icon-emoji-more_svg__fill"
  })));
}, Bp;
function X0() {
  return X0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, X0.apply(this, arguments);
}
var Mf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", X0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Bp || (Bp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 5.06a8 8 0 0 1 6.561 3.424l.287.439 22.608 37.744a8 8 0 0 1 .022 7.962 8 8 0 0 1-6.356 4.014l-.535.024H9.384a8 8 0 0 1-6.862-4.038 8.01 8.01 0 0 1-.226-7.493l.27-.506L25.16 8.91A8 8 0 0 1 32 5.06m0 5.333c-.816 0-1.58.372-2.076.99l-.196.28-22.565 37.67a2.67 2.67 0 0 0 1.909 3.973l.341.027h45.144a2.67 2.67 0 0 0 2.45-3.659l-.148-.304L34.28 11.676A2.67 2.67 0 0 0 32 10.393m0 32.274A2.667 2.667 0 1 1 32 48a2.667 2.667 0 0 1 0-5.333m0-21.334a2.667 2.667 0 0 1 2.649 2.356l.018.311v10.667a2.667 2.667 0 0 1-5.316.311l-.018-.311V24A2.667 2.667 0 0 1 32 21.333",
    className: "icon-error_svg__fill"
  })));
}, Dp;
function O0() {
  return O0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, O0.apply(this, arguments);
}
var Ef = function(n) {
  return /* @__PURE__ */ z.createElement("svg", O0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Dp || (Dp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M48 8a2.667 2.667 0 0 1 2.649 2.356l.018.31V32l-.001.027v21.306a2.667 2.667 0 0 1-5.315.311l-.018-.31V34.665H19.772l6.114 6.115a2.67 2.67 0 0 1 .221 3.52l-.221.251a2.666 2.666 0 0 1-3.52.222l-.252-.222-10.666-10.666a2.666 2.666 0 0 1-.222-3.52l.222-.252 10.666-10.666a2.666 2.666 0 0 1 3.993 3.52l-.221.251-6.113 6.114h25.56V10.667A2.667 2.667 0 0 1 48 8",
    className: "icon-expand_svg__fill"
  })));
}, Xp;
function j0() {
  return j0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, j0.apply(this, arguments);
}
var Sf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", j0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Xp || (Xp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M30.52 12.51c1.685-1.226 4.139-.103 4.139 1.893v35.194c0 1.996-2.454 3.119-4.138 1.893l-12.45-9.909H7.898c-1.416 0-2.564-1.074-2.564-2.399V24.818c0-1.325 1.148-2.4 2.564-2.4h10.175zm20.427.163c10.293 10.667 10.293 27.987 0 38.654a2.137 2.137 0 0 1-3.156-.047c-.86-.942-.84-2.448.044-3.364 8.49-8.799 8.49-23.033 0-31.832-.884-.916-.904-2.422-.044-3.364a2.137 2.137 0 0 1 3.156-.047m-8.492 8.799c5.597 5.8 5.597 15.231 0 21.031a2.136 2.136 0 0 1-3.156-.046c-.86-.942-.84-2.448.044-3.364 3.794-3.932 3.794-10.279 0-14.211-.884-.916-.904-2.422-.044-3.363a2.136 2.136 0 0 1 3.156-.047",
    className: "icon-file-audio_svg__fill"
  })));
}, Op;
function H0() {
  return H0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, H0.apply(this, arguments);
}
var kf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", H0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Op || (Op = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M39.414 6.4a2.4 2.4 0 0 1 1.71.701l12.642 12.75c.407.41.634.953.634 1.516v29.765c0 3.542-4.342 6.468-8 6.468H16.16c-3.658 0-6.4-2.926-6.4-6.468L9.6 12.868c0-3.542 2.902-6.468 6.56-6.468zm3.331 35.173-21.49.027-.147.005c-1.066.08-1.908 1.014-1.908 2.155 0 1.193.92 2.16 2.055 2.16l21.49-.027.147-.005c1.066-.08 1.908-1.014 1.908-2.155 0-1.193-.92-2.16-2.055-2.16m0-8.533-21.49.027-.147.005c-1.066.08-1.908 1.014-1.908 2.155 0 1.193.92 2.16 2.055 2.16l21.49-.027.147-.005c1.066-.08 1.908-1.014 1.908-2.155 0-1.193-.92-2.16-2.055-2.16m-11.807-8.507h-9.6l-.153.006a2.15 2.15 0 0 0-1.985 2.154c0 1.193.957 2.16 2.138 2.16h9.6l.152-.005a2.15 2.15 0 0 0 1.985-2.155c0-1.193-.957-2.16-2.137-2.16",
    className: "icon-file-document_svg__fill"
  })));
}, jp;
function f0() {
  return f0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, f0.apply(this, arguments);
}
var bf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", f0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), jp || (jp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "m41.636 3.226.251.222a2.67 2.67 0 0 1 .222 3.52l-.222.251-7.219 7.218V27.38l11.209-6.472 2.643-9.86a2.667 2.667 0 0 1 5.218 1.051l-.067.329-2.237 8.35 8.352 2.24a2.67 2.67 0 0 1 1.952 2.938l-.067.328a2.67 2.67 0 0 1-2.937 1.952l-.329-.066-9.861-2.643L37.334 32l11.209 6.47 9.862-2.64.329-.067a2.67 2.67 0 0 1 2.937 1.952l.067.328a2.67 2.67 0 0 1-1.952 2.938l-8.353 2.237 2.238 8.353.067.329a2.666 2.666 0 0 1-5.218 1.052l-2.643-9.861-11.209-6.472v12.944l7.219 7.218a2.667 2.667 0 0 1-3.52 3.993l-.251-.222L32 54.437l-6.114 6.115a2.666 2.666 0 0 1-3.52.222l-.251-.222a2.666 2.666 0 0 1-.222-3.52l.222-.251 7.218-7.22V36.62l-11.209 6.47-2.642 9.863a2.666 2.666 0 0 1-5.218-1.052l.067-.329 2.236-8.351-8.35-2.24a2.665 2.665 0 0 1-1.953-2.937l.067-.328a2.665 2.665 0 0 1 2.937-1.952l.329.066 9.861 2.642L26.667 32l-11.209-6.472-9.86 2.643-.329.066a2.665 2.665 0 0 1-2.937-1.952l-.067-.328a2.67 2.67 0 0 1 1.952-2.938l8.35-2.239-2.235-8.351-.067-.329a2.667 2.667 0 0 1 5.218-1.052l2.642 9.862 11.209 6.47V14.439L22.116 7.22a2.665 2.665 0 0 1 0-3.771 2.666 2.666 0 0 1 3.52-.222l.251.222 6.114 6.112 6.115-6.112a2.666 2.666 0 0 1 3.52-.222z",
    className: "icon-freeze_svg__fill"
  })));
}, Hp;
function w0() {
  return w0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, w0.apply(this, arguments);
}
var Yf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", w0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Hp || (Hp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M16.664 45.333q3.233 0 5.89-.953 2.658-.954 4.113-2.683V31.34h-10.29v3.94h4.902v4.474q-1.292 1.284-4.327 1.283-3.017 0-4.58-2.085-1.561-2.085-1.562-6.168v-1.657q.018-4.047 1.455-6.097t4.184-2.05q2.155 0 3.385 1.034t1.59 3.262h5.243q-.486-4.206-3.107-6.408t-7.273-2.201q-3.34 0-5.827 1.506t-3.807 4.35q-1.32 2.843-1.32 6.728v1.765q.036 3.78 1.428 6.578 1.392 2.797 3.95 4.269 2.56 1.47 5.953 1.47m20.67 0V18.667H32v26.666h5.333zm10.396 0V34.436h9.721v-4.432H47.73v-6.887h10.937v-4.45h-16v26.666z",
    className: "icon-gif_svg__fill"
  })));
}, fp;
function g0() {
  return g0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, g0.apply(this, arguments);
}
var Qf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", g0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), fp || (fp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 2.667C48.2 2.667 61.333 15.8 61.333 32S48.2 61.333 32 61.333 2.667 48.2 2.667 32 15.8 2.667 32 2.667M32 8C18.745 8 8 18.745 8 32s10.745 24 24 24 24-10.745 24-24S45.255 8 32 8m1.667 21.333a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1h-3.334a1 1 0 0 1-1-1v-14a1 1 0 0 1 1-1zm-1.667-8a2.667 2.667 0 1 1 0 5.334 2.667 2.667 0 0 1 0-5.334",
    className: "icon-info_svg__fill"
  })));
}, wp;
function I0() {
  return I0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, I0.apply(this, arguments);
}
var Jf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", I0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), wp || (wp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 5.333a2.667 2.667 0 0 1 .311 5.316l-.311.018H10.667a2.67 2.67 0 0 0-2.65 2.355L8 13.333v37.334a2.667 2.667 0 0 0 2.356 2.648l.31.018H32a2.667 2.667 0 0 1 .311 5.316l-.311.018H10.667a8 8 0 0 1-7.987-7.53l-.013-.47V13.333a8 8 0 0 1 7.53-7.986l.47-.014zm17.634 13.893.252.222 10.666 10.666a2.666 2.666 0 0 1 .222 3.52l-.222.252-10.666 10.666a2.666 2.666 0 0 1-3.993-3.52l.221-.251 4.78-4.782L20 36a2.667 2.667 0 0 1-.311-5.315l.311-.018h33.56l-7.446-7.448a2.67 2.67 0 0 1-.221-3.52l.221-.251a2.666 2.666 0 0 1 3.52-.222",
    className: "icon-leave_svg__fill"
  })));
}, gp;
function L0() {
  return L0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, L0.apply(this, arguments);
}
var vf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", L0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), gp || (gp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M34.667 37.333c7.17 0 13.018 5.66 13.32 12.755l.013.579V56a2.667 2.667 0 0 1-5.315.311L42.667 56v-5.333c0-4.26-3.33-7.743-7.53-7.987l-.47-.013H13.333a8 8 0 0 0-7.986 7.53l-.014.47V56a2.667 2.667 0 0 1-5.316.311L0 56v-5.333c0-7.17 5.66-13.019 12.755-13.321l.578-.013zM54 37.765a13.33 13.33 0 0 1 9.986 12.297l.014.605V56a2.667 2.667 0 0 1-5.315.311L58.667 56v-5.331a8 8 0 0 0-6-7.74A2.667 2.667 0 1 1 54 37.765M24 5.333c7.364 0 13.333 5.97 13.333 13.334S31.363 32 24 32s-13.333-5.97-13.333-13.333S16.637 5.333 24 5.333m19.328.43a13.333 13.333 0 0 1 0 25.834 2.667 2.667 0 1 1-1.323-5.167 8 8 0 0 0 0-15.5 2.667 2.667 0 1 1 1.323-5.167M24 10.667a8 8 0 1 0 0 16 8 8 0 0 0 0-16",
    className: "icon-members_svg__fill"
  })));
}, Ip;
function C0() {
  return C0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, C0.apply(this, arguments);
}
var zf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", C0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Ip || (Ip = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 2.667C48.2 2.667 61.333 15.8 61.333 32S48.2 61.333 32 61.333c-4.455 0-8.679-.993-12.461-2.77l-1.753.58q-8.947 2.868-12.504 1.981-4.198-1.047-1.657-3.663 1.757-2.094 2.928-5.234.934-2.502-.737-7A29.15 29.15 0 0 1 2.666 32C2.667 15.8 15.8 2.667 32 2.667M32 8C18.745 8 8 18.745 8 32c0 3.5.747 6.88 2.168 9.978l.405.837.137.271.106.285c1.517 4.085 1.89 7.622.734 10.72l-.382.972-.192.433.235-.05a62 62 0 0 0 4.886-1.363l1.721-.568 2.04-.696 1.95.917A23.9 23.9 0 0 0 32 56c13.255 0 24-10.745 24-24S45.255 8 32 8M18.667 29.333a2.667 2.667 0 1 1-.001 5.333 2.667 2.667 0 0 1 .001-5.333m13.333 0a2.667 2.667 0 1 1 0 5.334 2.667 2.667 0 0 1 0-5.334m13.333 0a2.667 2.667 0 1 1 0 5.334 2.667 2.667 0 0 1 0-5.334",
    className: "icon-message_svg__fill"
  })));
}, Lp;
function K0() {
  return K0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, K0.apply(this, arguments);
}
var xf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", K0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Lp || (Lp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M18.667 34.667a2.667 2.667 0 0 1 .311 5.316l-.311.017h-5.334v16a2.667 2.667 0 0 1-5.316.311L8 56V40H2.667a2.667 2.667 0 0 1-.311-5.315l.31-.018h16zM32 29.333a2.667 2.667 0 0 1 2.649 2.356l.018.311v24a2.667 2.667 0 0 1-5.316.311L29.333 56V32A2.667 2.667 0 0 1 32 29.333M61.333 40a2.667 2.667 0 0 1 .311 5.315l-.31.018h-5.335L56 56a2.667 2.667 0 0 1-5.315.311L50.667 56l-.001-10.668-5.333.001a2.667 2.667 0 0 1-.311-5.316l.311-.017zm-8-34.667a2.67 2.67 0 0 1 2.65 2.356L56 8v24a2.667 2.667 0 0 1-5.315.311L50.667 32V8a2.667 2.667 0 0 1 2.666-2.667m-42.666 0a2.667 2.667 0 0 1 2.648 2.356l.018.311v18.667a2.667 2.667 0 0 1-5.316.311L8 26.667V8a2.667 2.667 0 0 1 2.667-2.667m21.333 0a2.667 2.667 0 0 1 2.649 2.356l.018.311-.001 10.666H40a2.668 2.668 0 0 1 .311 5.317L40 24H24a2.667 2.667 0 0 1-.311-5.315l.311-.018h5.333V8A2.667 2.667 0 0 1 32 5.333",
    className: "icon-moderations_svg__fill"
  })));
}, Cp;
function _0() {
  return _0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, _0.apply(this, arguments);
}
var Gf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", _0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Cp || (Cp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 45.333a5.333 5.333 0 1 1 0 10.666 5.333 5.333 0 0 1 0-10.666M32 28a5.333 5.333 0 1 1 0 10.668A5.333 5.333 0 0 1 32 28m0-17.333c2.946 0 5.333 2.387 5.333 5.333S34.946 21.333 32 21.333 26.667 18.946 26.667 16s2.387-5.333 5.333-5.333",
    className: "icon-more_svg__fill"
  })));
}, Kp;
function P0() {
  return P0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, P0.apply(this, arguments);
}
var yf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", P0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Kp || (Kp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "m55.62 19.616.067.123A26.55 26.55 0 0 1 58.667 32c0 4.326-1.03 8.41-2.864 12.025q-1.518 4.089-.67 6.363 1.066 2.855 2.662 4.758 2.31 2.379-1.506 3.33-3.135.782-10.879-1.646l-.488-.155-1.594-.527A26.6 26.6 0 0 1 32 58.667a26.55 26.55 0 0 1-12.326-3.014l-.059-.03 4-4A21.2 21.2 0 0 0 32 53.333c2.993 0 5.89-.614 8.562-1.786l.498-.226 1.925-.905 3.613 1.196.695.219q1.093.337 2.054.595l.472.125.485.121-.167-.42-.2-.594c-.814-2.685-.484-5.681.713-9.065l.154-.425.106-.284.528-1.084a21.2 21.2 0 0 0 1.895-8.8 21.2 21.2 0 0 0-1.71-8.385zm2.266-13.502a2.67 2.67 0 0 1 .221 3.52l-.221.252-48 48a2.668 2.668 0 0 1-3.993-3.52l.221-.252 5.238-5.237a26.56 26.56 0 0 1-6.015-16.412L5.333 32C5.333 17.272 17.273 5.333 32 5.333a26.55 26.55 0 0 1 16.877 6.02l5.237-5.239a2.67 2.67 0 0 1 3.772 0M32 10.667c-11.782 0-21.333 9.55-21.333 21.333 0 4.836 1.614 9.401 4.48 13.084l29.936-29.938A21.25 21.25 0 0 0 32 10.666z",
    className: "icon-mute_svg__fill"
  })));
}, _p;
function A0() {
  return A0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, A0.apply(this, arguments);
}
var Bf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", A0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), _p || (_p = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M36.613 53.333c2.056 0 3.338 2.227 2.307 4.005a8 8 0 0 1-13.84 0c-.98-1.689.129-3.783 2.004-3.988l.303-.017zM32 2.667c11.56 0 20.972 9.194 21.323 20.669l.01.664v13.333a5.334 5.334 0 0 0 4.936 5.319l.753.033c2.963.318 3.077 4.616.342 5.24l-.342.056-.355.019H5.333l-.355-.019c-3.082-.33-3.082-4.965 0-5.296l.753-.033a5.335 5.335 0 0 0 4.92-4.9l.016-.419V24c0-11.782 9.55-21.333 21.333-21.333M32 8c-8.636 0-15.674 6.842-15.989 15.4L16 24v13.333c0 1.562-.336 3.046-.939 4.383l-.275.564-.218.387h34.861l-.215-.387a10.6 10.6 0 0 1-1.146-3.74l-.055-.674-.013-.533V24c0-8.837-7.163-16-16-16",
    className: "icon-notifications_svg__fill"
  })));
}, Pp;
function q0() {
  return q0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, q0.apply(this, arguments);
}
var Df = function(n) {
  return /* @__PURE__ */ z.createElement("svg", q0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Pp || (Pp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M36.613 53.333c2.056 0 3.338 2.227 2.307 4.005a8 8 0 0 1-13.84 0c-.98-1.689.129-3.783 2.004-3.988l.303-.017zM32 2.667c7.173 0 13.52 3.54 17.387 8.97l5.686-5.687a2.105 2.105 0 0 1 2.85-.117l.127.117a2.105 2.105 0 0 1 0 2.977L8.927 58.05c-.78.781-2.023.82-2.85.117l-.127-.117a2.105 2.105 0 0 1 0-2.977L13.023 48h-7.69l-.355-.019c-3.082-.33-3.082-4.965 0-5.296l.753-.033a5.335 5.335 0 0 0 4.92-4.9l.016-.419V24c0-11.782 9.55-21.333 21.333-21.333m20.85 16.795c.271 1.253.433 2.548.473 3.874l.01.664v13.333a5.334 5.334 0 0 0 4.936 5.319l.753.033c2.963.318 3.077 4.616.342 5.24l-.342.056-.355.019H24.31z",
    className: "icon-notifications-off-filled_svg__fill"
  })));
}, Ap;
function $0() {
  return $0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, $0.apply(this, arguments);
}
var Xf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", $0({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), Ap || (Ap = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M29.83 6.45a2.667 2.667 0 0 1 4.34 0l11.697 16.374L57 13.918c1.88-1.504 4.573.054 4.32 2.35l-.047.29-8 37.334A2.666 2.666 0 0 1 50.666 56H13.333a2.666 2.666 0 0 1-2.607-2.108l-8-37.333c-.525-2.452 2.315-4.207 4.273-2.641l11.132 8.906zM32 12.587l-11.163 15.63a2.667 2.667 0 0 1-3.836.532l-7.497-5.997 5.984 27.915h33.021l5.984-27.915L47 28.749a2.667 2.667 0 0 1-3.632-.281l-.204-.251zM32 32a5.333 5.333 0 1 1 0 10.668A5.333 5.333 0 0 1 32 32",
    className: "icon-operator_svg__fill"
  })));
}, qp;
function eF() {
  return eF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, eF.apply(this, arguments);
}
var Of = function(n) {
  return /* @__PURE__ */ z.createElement("svg", eF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), qp || (qp = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M50.667 5.333a8 8 0 0 1 8 8v37.334a8 8 0 0 1-8 8H13.333a8 8 0 0 1-8-8V13.333a8 8 0 0 1 8-8zm-8 25.107L19.77 53.332l30.896.001a2.667 2.667 0 0 0 2.661-2.498l.005-.168v-9.564L42.666 30.44zm8-19.773H13.333a2.667 2.667 0 0 0-2.666 2.666v37.334c0 1.143.72 2.119 1.731 2.498L40.781 24.78a2.67 2.67 0 0 1 3.52-.222l.251.222 8.78 8.78.001-20.228a2.667 2.667 0 0 0-2.498-2.661zm-28 5.333a6.666 6.666 0 1 1 0 13.333 6.666 6.666 0 0 1 0-13.333m0 5.333a1.334 1.334 0 1 0 0 2.667 1.334 1.334 0 0 0 0-2.667",
    className: "icon-photo_svg__fill"
  })));
}, $p;
function tF() {
  return tF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, tF.apply(this, arguments);
}
var jf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", tF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), $p || ($p = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M51.908 34.75c1.9-1.233 1.896-3.26.013-4.514L19.376 8.577c-1.893-1.26-3.404-.391-3.376 1.968l.522 42.888c.028 2.347 1.596 3.247 3.493 2.016z",
    className: "icon-play_svg__fill"
  })));
}, eM;
function nF() {
  return nF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, nF.apply(this, arguments);
}
var Hf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", nF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), eM || (eM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M34.667 29.333h18.666c3.556 0 3.556 5.334 0 5.334H34.667v18.666c0 3.556-5.334 3.556-5.334 0V34.667H10.667c-3.556 0-3.556-5.334 0-5.334h18.666V10.667c0-3.556 5.334-3.556 5.334 0z",
    className: "icon-plus_svg__fill"
  })));
}, tM;
function lF() {
  return lF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, lF.apply(this, arguments);
}
var ff = function(n) {
  return /* @__PURE__ */ z.createElement("svg", lF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), tM || (tM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 61.333C15.8 61.333 2.667 48.2 2.667 32S15.8 2.667 32 2.667 61.333 15.8 61.333 32 48.2 61.333 32 61.333M32 56c13.255 0 24-10.745 24-24S45.255 8 32 8 8 18.745 8 32s10.745 24 24 24m2.213-18.63a2.667 2.667 0 1 1-5.333 0v-2.69c0-1.148.734-2.168 1.823-2.53.173-.058.532-.195 1.01-.407.809-.36 1.616-.79 2.354-1.282 1.835-1.223 2.813-2.528 2.813-3.786a5.333 5.333 0 0 0-10.364-1.777 2.667 2.667 0 0 1-5.032-1.77 10.668 10.668 0 0 1 20.729 3.551c0 3.413-2.022 6.109-5.187 8.22a21 21 0 0 1-2.813 1.578zm-5.333 7.523a2.667 2.667 0 1 1 5.333 0v.44a2.667 2.667 0 1 1-5.333 0v-.44",
    className: "icon-question_svg__fill"
  })));
}, nM;
function aF() {
  return aF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, aF.apply(this, arguments);
}
var wf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", aF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), nM || (nM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "m46.14 14.43.562.537 6.631 6.167v-7.8a2.67 2.67 0 0 1 2.356-2.65l.311-.017a2.667 2.667 0 0 1 2.649 2.355l.018.311v16a2.67 2.67 0 0 1-2.356 2.65L56 32H40a2.667 2.667 0 0 1-.311-5.315l.311-.018h11.452l-8.44-7.85c-5.964-5.893-15.168-7.182-22.563-3.156-7.38 4.018-11.172 12.357-9.314 20.455 1.859 8.107 8.935 14.032 17.362 14.518 8.43.487 16.162-4.585 18.967-12.426a2.667 2.667 0 0 1 5.022 1.797C48.88 50.082 38.973 56.582 28.19 55.959c-10.785-.623-19.862-8.222-22.254-18.65C3.542 26.872 8.426 16.135 17.9 10.977c9.227-5.024 20.65-3.579 28.241 3.453z",
    className: "icon-refresh_svg__fill"
  })));
}, lM;
function dF() {
  return dF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, dF.apply(this, arguments);
}
var gf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", dF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), lM || (lM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 2.667C48.2 2.667 61.333 15.8 61.333 32S48.2 61.333 32 61.333 2.667 48.2 2.667 32 15.8 2.667 32 2.667m9.886 19.447a2.67 2.67 0 0 0-3.772 0L32 28.23l-6.114-6.115-.134-.124a2.667 2.667 0 0 0-3.638.124l-.124.134a2.667 2.667 0 0 0 .124 3.638L28.23 32l-6.115 6.114-.124.134a2.667 2.667 0 0 0 .124 3.638l.134.124a2.667 2.667 0 0 0 3.638-.124L32 35.77l6.114 6.115.134.124a2.667 2.667 0 0 0 3.638-.124l.124-.134a2.667 2.667 0 0 0-.124-3.638L35.77 32l6.115-6.114.124-.134a2.667 2.667 0 0 0-.124-3.638z",
    className: "icon-remove_svg__fill"
  })));
}, aM;
function rF() {
  return rF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, rF.apply(this, arguments);
}
var If = function(n) {
  return /* @__PURE__ */ z.createElement("svg", rF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 12 12"
  }, n), aM || (aM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M11.774 10.5c.062 0 .12-.025.164-.07a.22.22 0 0 0 .062-.164c-.069-1.447-.495-2.678-1.268-3.66-.618-.785-1.455-1.409-2.49-1.855a9.3 9.3 0 0 0-2.406-.655 10 10 0 0 0-.862-.078V2.225a.23.23 0 0 0-.128-.203.23.23 0 0 0-.24.028L.084 5.692A.22.22 0 0 0 0 5.865c0 .068.03.132.082.175l4.523 3.737c.067.056.16.068.24.03a.22.22 0 0 0 .13-.202v-1.95c1.134-.08 2.178.003 3.107.25a6.4 6.4 0 0 1 2.087.96c1.018.724 1.398 1.5 1.401 1.507a.23.23 0 0 0 .204.128",
    className: "icon-reply-filled_svg__fill"
  })));
}, dM;
function iF() {
  return iF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, iF.apply(this, arguments);
}
var Lf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", iF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), dM || (dM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M26.667 48C14.885 48 5.333 38.449 5.333 26.667S14.885 5.333 26.667 5.333 48 14.885 48 26.667c0 4.93-1.672 9.469-4.48 13.081l13.67 13.67a2.668 2.668 0 0 1-3.772 3.772l-13.67-13.67A21.24 21.24 0 0 1 26.667 48m0-5.333c8.836 0 16-7.164 16-16s-7.164-16-16-16-16 7.163-16 16 7.163 16 16 16",
    className: "icon-search_svg__fill"
  })));
}, rM;
function VF() {
  return VF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, VF.apply(this, arguments);
}
var Cf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", VF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), rM || (rM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M59.795 29.43 7.329 2.979C4.691 1.802 1.76 4.153 2.932 6.798l6.925 18.609a2 2 0 0 0 1.544 1.275l32.273 5.394L11.4 37.47a2 2 0 0 0-1.544 1.275L2.932 57.353c-.879 2.645 1.76 4.997 4.397 3.527l52.466-26.453c2.051-.882 2.051-3.82 0-4.996z",
    className: "icon-send_svg__fill"
  })));
}, iM;
function cF() {
  return cF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, cF.apply(this, arguments);
}
var Kf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", cF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), iM || (iM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 2.667A5.33 5.33 0 0 1 37.333 8v.24A4.4 4.4 0 0 0 40 12.267a4.4 4.4 0 0 0 4.853-.88l.16-.16a5.33 5.33 0 0 1 7.547 0 5.333 5.333 0 0 1 0 7.546l-.16.16a4.4 4.4 0 0 0-.88 4.854V24a4.4 4.4 0 0 0 4.027 2.667H56c2.946 0 5.333 2.387 5.333 5.333S58.946 37.333 56 37.333h-.24A4.4 4.4 0 0 0 51.733 40a4.4 4.4 0 0 0 .88 4.853l.16.16a5.33 5.33 0 0 1 0 7.547 5.333 5.333 0 0 1-7.546 0l-.16-.16a4.4 4.4 0 0 0-4.854-.88 4.4 4.4 0 0 0-2.666 4.027V56a5.333 5.333 0 0 1-10.667 0v-.24A4.4 4.4 0 0 0 24 51.733a4.4 4.4 0 0 0-4.853.88l-.16.16a5.33 5.33 0 0 1-7.547 0 5.333 5.333 0 0 1 0-7.546l.16-.16a4.4 4.4 0 0 0 .88-4.854 4.4 4.4 0 0 0-4.027-2.666H8A5.333 5.333 0 0 1 8 26.88h.24A4.4 4.4 0 0 0 12.267 24a4.4 4.4 0 0 0-.88-4.853l-.16-.16a5.33 5.33 0 0 1 0-7.547 5.333 5.333 0 0 1 7.546 0l.16.16a4.4 4.4 0 0 0 4.854.88H24a4.4 4.4 0 0 0 2.667-4.027V8A5.33 5.33 0 0 1 32 2.667M32 24a8 8 0 1 0 0 16 8 8 0 0 0 0-16",
    className: "icon-settings-filled_svg__fill"
  })));
}, VM;
function sF() {
  return sF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, sF.apply(this, arguments);
}
var _f = function(n) {
  return /* @__PURE__ */ z.createElement("svg", sF({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 32 32"
  }, n), VM || (VM = /* @__PURE__ */ z.createElement("path", {
    d: "M21.943 24.39a1.333 1.333 0 0 1-1.886 1.886l-9.333-9.333a1.333 1.333 0 0 1 0-1.886l9.333-9.333a1.333 1.333 0 1 1 1.886 1.885L13.553 16z",
    className: "icon-slide-left_svg__fill",
    clipRule: "evenodd"
  })));
}, cM;
function oF() {
  return oF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, oF.apply(this, arguments);
}
var Pf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", oF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), cM || (cM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M32 61.333C48.2 61.333 61.333 48.2 61.333 32S48.2 2.667 32 2.667 2.667 15.8 2.667 32a2.838 2.838 0 1 0 5.678 0C8.344 18.935 18.934 8.344 32 8.344c13.065 0 23.656 10.591 23.656 23.656S45.065 55.656 32 55.656a2.838 2.838 0 1 0 0 5.677",
    className: "icon-spinner_svg__fill"
  })));
}, sM;
function UF() {
  return UF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, UF.apply(this, arguments);
}
var Af = function(n) {
  return /* @__PURE__ */ z.createElement("svg", UF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), sM || (sM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M36.889 43.013c6.608 0 12.121 4.685 12.43 10.734l.014.537V58a2.667 2.667 0 0 1-5.316.311L44 58v-3.716c0-3.07-2.87-5.718-6.636-5.925l-.475-.013H27.11c-3.838 0-6.86 2.525-7.096 5.557l-.015.381V58a2.667 2.667 0 0 1-5.315.311L14.667 58v-3.716c0-6.126 5.324-10.986 11.864-11.26l.58-.011zm18.578-17.291q.401 0 .784.118c4.632 1.426 7.518 4.801 7.736 9.688l.013.594v12.8a2.667 2.667 0 0 1-5.315.311l-.018-.311V36.124c-.002-2.595-1.163-4.171-3.528-5.034l-.104-.037-2.502.002a2.667 2.667 0 0 1-2.648-2.356l-.018-.31a2.67 2.67 0 0 1 2.355-2.65l.311-.017zm-44 0 .31.018a2.666 2.666 0 0 1 2.356 2.648l-.018.311a2.666 2.666 0 0 1-2.648 2.356l-2.51-.002-.119.042c-2.246.85-3.503 2.574-3.505 5.147v12.68l-.018.31A2.666 2.666 0 0 1 0 48.922V36.24l.014-.591c.225-4.874 3.203-8.415 7.712-9.809q.384-.117.788-.118zM32 19.958c5.512 0 10 4.409 10 9.871s-4.488 9.872-10 9.872-10-4.41-10-9.872 4.488-9.871 10-9.871m0 5.333c-2.588 0-4.667 2.043-4.667 4.538s2.08 4.538 4.667 4.538c2.588 0 4.667-2.042 4.667-4.538 0-2.495-2.08-4.538-4.667-4.538M17.333 2.667c5.513 0 10 4.409 10 9.871s-4.487 9.871-10 9.871c-5.512 0-10-4.409-10-9.871s4.488-9.871 10-9.871m29.334 0c5.512 0 10 4.409 10 9.871s-4.488 9.871-10 9.871c-5.513 0-10-4.409-10-9.871s4.487-9.871 10-9.871M17.333 8c-2.587 0-4.666 2.042-4.666 4.538s2.079 4.538 4.666 4.538S22 15.034 22 12.538 19.921 8 17.333 8m29.334 0C44.079 8 42 10.042 42 12.538s2.079 4.538 4.667 4.538 4.666-2.042 4.666-4.538S49.254 8 46.667 8",
    className: "icon-supergroup_svg__fill"
  })));
}, oM, UM;
function NF() {
  return NF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, NF.apply(this, arguments);
}
var qf = function(n) {
  return /* @__PURE__ */ z.createElement("svg", NF({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 64 64"
  }, n), oM || (oM = /* @__PURE__ */ z.createElement("path", {
    d: "M38.824 25.895a2.95 2.95 0 0 1 4.16-.074L57.1 39.378a2.92 2.92 0 0 1 .002 4.213L42.985 57.177a2.95 2.95 0 0 1-4.158-.07 2.92 2.92 0 0 1 .07-4.14l11.928-11.48-11.926-11.451a2.92 2.92 0 0 1-.075-4.14",
    className: "icon-thread_svg__fill",
    clipRule: "evenodd"
  })), UM || (UM = /* @__PURE__ */ z.createElement("path", {
    d: "M8.866 6c1.583 0 2.866 1.216 2.866 2.716V25.5c0 7.672 6.846 14.068 15.475 14.068h22.927c1.583 0 2.866 1.216 2.866 2.716S51.717 45 50.134 45H27.207C15.604 45 6 36.35 6 25.5V8.716C6 7.216 7.283 6 8.866 6",
    className: "icon-thread_svg__fill",
    clipRule: "evenodd"
  })));
}, NM;
function RF() {
  return RF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, RF.apply(this, arguments);
}
var $f = function(n) {
  return /* @__PURE__ */ z.createElement("svg", RF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), NM || (NM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M34.667 5.333a2.667 2.667 0 0 1 0 5.334H13.333a2.667 2.667 0 0 0-2.666 2.666v37.334c0 1.143.72 2.118 1.73 2.497l28.384-28.383a2.667 2.667 0 0 1 3.771 0l8.781 8.78v-4.228a2.667 2.667 0 0 1 2.498-2.661l.169-.005a2.667 2.667 0 0 1 2.667 2.666v21.334a8 8 0 0 1-8 8H13.33a8 8 0 0 1-7.998-8V13.333a8 8 0 0 1 8-8zm8 25.105L19.77 53.333h30.897a2.667 2.667 0 0 0 2.661-2.498l.005-.168v-9.563zM22.667 16a6.666 6.666 0 1 1 0 13.333 6.666 6.666 0 0 1 0-13.333m0 5.333a1.334 1.334 0 1 0 0 2.667 1.334 1.334 0 0 0 0-2.667M56.78 3.448a2.665 2.665 0 0 1 3.771 0 2.665 2.665 0 0 1 0 3.771l-4.782 4.78 4.782 4.782c.998.998 1.04 2.59.125 3.638l-.125.133a2.665 2.665 0 0 1-3.771 0l-4.782-4.781-4.78 4.781a2.667 2.667 0 0 1-3.638.125l-.133-.125a2.665 2.665 0 0 1 0-3.771L48.228 12l-4.78-4.781a2.667 2.667 0 0 1-.125-3.638l.125-.133a2.665 2.665 0 0 1 3.771 0l4.78 4.78z",
    className: "icon-thumbnail-none_svg__fill"
  })));
}, RM;
function hF() {
  return hF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, hF.apply(this, arguments);
}
var ew = function(n) {
  return /* @__PURE__ */ z.createElement("svg", hF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 88 48"
  }, n), RM || (RM = /* @__PURE__ */ z.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ z.createElement("rect", {
    width: 80,
    height: 40,
    x: 4,
    y: 4,
    fill: "#000",
    className: "icon-toggleoff_svg__fill",
    rx: 20
  }), /* @__PURE__ */ z.createElement("circle", {
    cx: 24,
    cy: 24,
    r: 12,
    fill: "#FFF"
  }), /* @__PURE__ */ z.createElement("path", {
    fill: "#FFF",
    d: "M64 4c11.046 0 20 8.954 20 20s-8.954 20-20 20H24C12.954 44 4 35.046 4 24S12.954 4 24 4zm0 2H24C14.059 6 6 14.059 6 24c0 9.764 7.774 17.712 17.47 17.992L24 42h40c9.941 0 18-8.059 18-18 0-9.764-7.774-17.712-17.47-17.992z"
  }), /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    d: "M64 0H24C10.745 0 0 10.745 0 24s10.745 24 24 24h40c13.255 0 24-10.745 24-24S77.255 0 64 0m0 4c11.046 0 20 8.954 20 20s-8.954 20-20 20H24C12.954 44 4 35.046 4 24S12.954 4 24 4z",
    className: "icon-toggleoff_svg__fill"
  }))));
}, hM;
function ZF() {
  return ZF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, ZF.apply(this, arguments);
}
var tw = function(n) {
  return /* @__PURE__ */ z.createElement("svg", ZF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 88 48"
  }, n), hM || (hM = /* @__PURE__ */ z.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ z.createElement("rect", {
    width: 80,
    height: 40,
    x: 4,
    y: 4,
    fill: "#000",
    className: "icon-toggleon_svg__fill",
    rx: 20
  }), /* @__PURE__ */ z.createElement("circle", {
    cx: 64,
    cy: 24,
    r: 12,
    fill: "#FFF"
  }), /* @__PURE__ */ z.createElement("path", {
    fill: "#FFF",
    d: "M64 4c11.046 0 20 8.954 20 20s-8.954 20-20 20H24C12.954 44 4 35.046 4 24S12.954 4 24 4zm0 2H24C14.059 6 6 14.059 6 24c0 9.764 7.774 17.712 17.47 17.992L24 42h40c9.941 0 18-8.059 18-18 0-9.764-7.774-17.712-17.47-17.992z"
  }), /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    d: "M64 0H24C10.745 0 0 10.745 0 24s10.745 24 24 24h40c13.255 0 24-10.745 24-24S77.255 0 64 0m0 4c11.046 0 20 8.954 20 20s-8.954 20-20 20H24C12.954 44 4 35.046 4 24S12.954 4 24 4z",
    className: "icon-toggleon_svg__fill"
  }))));
}, ZM;
function TF() {
  return TF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, TF.apply(this, arguments);
}
var nw = function(n) {
  return /* @__PURE__ */ z.createElement("svg", TF({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, n), ZM || (ZM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M42.667 37.333c7.17 0 13.018 5.66 13.32 12.755l.013.579V56a2.667 2.667 0 0 1-5.315.311L50.667 56v-5.333c0-4.26-3.33-7.743-7.53-7.987l-.47-.013H21.333a8 8 0 0 0-7.986 7.53l-.014.47V56a2.667 2.667 0 0 1-5.316.311L8 56v-5.333c0-7.17 5.66-13.019 12.755-13.321l.578-.013zM32 5.333c7.364 0 13.333 5.97 13.333 13.334S39.363 32 32 32s-13.333-5.97-13.333-13.333S24.637 5.333 32 5.333m0 5.334a8 8 0 1 0 0 16 8 8 0 0 0 0-16",
    className: "icon-user_svg__fill"
  })));
}, TM;
function FF() {
  return FF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, FF.apply(this, arguments);
}
var lw = function(n) {
  return /* @__PURE__ */ z.createElement("svg", FF({
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    fill: "none"
  }, n), TM || (TM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M12.346 5.336v-.001c.405-.523 1.182-.524 1.58-.037.162.2.25.443.25.69v3.678c0 .518.42.938.938.938H18.6c.359 0 .7.179.911.488l.001.001.369.548.003.004c.174.256.226.583.134.895l-1.532 5.316c-.131.459-.559.782-1.044.782h-7.075c-.3 0-.593-.127-.8-.345l-1.13-1.222v-6.647zm-4.73 3.078 3.245-4.223.002-.002c1.125-1.456 3.339-1.521 4.517-.075.421.52.671 1.177.671 1.874v2.74h2.55c.99 0 1.908.496 2.462 1.31l.002.004.368.547.002.002a2.93 2.93 0 0 1 .382 2.475v.003l-1.528 5.302a2.96 2.96 0 0 1-2.847 2.142h-7.075a2.99 2.99 0 0 1-2.166-.935l-.007-.007-.066-.072a2.13 2.13 0 0 1-1.821 1.025H4.192a2.13 2.13 0 0 1-2.13-2.13v-8.3a2.13 2.13 0 0 1 2.13-2.13h2.115c.493 0 .948.168 1.31.45m-3.678 1.68c0-.141.114-.255.254-.255h2.115c.14 0 .254.114.254.255v8.3c0 .14-.114.255-.254.255H4.192a.255.255 0 0 1-.255-.255z",
    clipRule: "evenodd"
  })));
}, FM;
function WF() {
  return WF = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, WF.apply(this, arguments);
}
var aw = function(n) {
  return /* @__PURE__ */ z.createElement("svg", WF({
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    fill: "none"
  }, n), FM || (FM = /* @__PURE__ */ z.createElement("path", {
    fill: "#000",
    fillRule: "evenodd",
    d: "M11.654 18.664v.001c-.405.523-1.182.524-1.58.037-.162-.2-.25-.444-.25-.69v-3.678a.94.94 0 0 0-.938-.938H5.4c-.359 0-.7-.179-.911-.488l-.001-.001-.369-.548-.003-.004a1.05 1.05 0 0 1-.134-.895l1.532-5.316c.131-.459.559-.782 1.044-.782h7.075c.3 0 .593.127.8.345l1.13 1.222v6.647zm4.73-3.078-3.245 4.223-.002.002c-1.125 1.456-3.339 1.521-4.517.075a2.98 2.98 0 0 1-.671-1.874v-2.74h-2.55c-.99 0-1.908-.496-2.462-1.31l-.002-.004-.368-.547-.002-.002a2.93 2.93 0 0 1-.382-2.475v-.003L3.711 5.63a2.96 2.96 0 0 1 2.847-2.142h7.075c.823 0 1.608.345 2.166.935l.007.007.066.072a2.13 2.13 0 0 1 1.821-1.025h2.115a2.13 2.13 0 0 1 2.13 2.13v8.3a2.13 2.13 0 0 1-2.13 2.13h-2.115a2.12 2.12 0 0 1-1.31-.45m3.678-1.68c0 .141-.114.255-.254.255h-2.115a.255.255 0 0 1-.255-.255v-8.3c0-.14.115-.255.255-.255h2.115c.14 0 .255.114.255.255z",
    clipRule: "evenodd"
  })));
};
function dw(e) {
  switch (e) {
    case ke.ADD:
      return T.createElement(qH, null);
    case ke.ARROW_LEFT:
      return T.createElement($H, null);
    case ke.ATTACH:
      return T.createElement(ef, null);
    case ke.AUDIO_ON_LINED:
      return T.createElement(tf, null);
    case ke.BAN:
      return T.createElement(nf, null);
    case ke.BROADCAST:
      return T.createElement(lf, null);
    case ke.CAMERA:
      return T.createElement(af, null);
    case ke.CHANNELS:
      return T.createElement(df, null);
    case ke.CHAT:
      return T.createElement(rf, null);
    case ke.CHAT_FILLED:
      return T.createElement(Vf, null);
    case ke.CHEVRON_DOWN:
      return T.createElement(cf, null);
    case ke.CHEVRON_RIGHT:
      return T.createElement(sf, null);
    case ke.CLOSE:
      return T.createElement(of, null);
    case ke.COLLAPSE:
      return T.createElement(Uf, null);
    case ke.COPY:
      return T.createElement(Nf, null);
    case ke.CREATE:
      return T.createElement(Rf, null);
    case ke.DELETE:
      return T.createElement(hf, null);
    case ke.DISCONNECTED:
      return T.createElement(Zf, null);
    case ke.DOCUMENT:
      return T.createElement(Tf, null);
    case ke.DONE:
      return T.createElement(Ff, null);
    case ke.DONE_ALL:
      return T.createElement(Wf, null);
    case ke.DOWNLOAD:
      return T.createElement(mf, null);
    case ke.EDIT:
      return T.createElement(uf, null);
    case ke.EMOJI_MORE:
      return T.createElement(pf, null);
    case ke.ERROR:
      return T.createElement(Mf, null);
    case ke.EXPAND:
      return T.createElement(Ef, null);
    case ke.FILE_AUDIO:
      return T.createElement(Sf, null);
    case ke.FILE_DOCUMENT:
      return T.createElement(kf, null);
    case ke.FREEZE:
      return T.createElement(bf, null);
    case ke.GIF:
      return T.createElement(Yf, null);
    case ke.INFO:
      return T.createElement(Qf, null);
    case ke.LEAVE:
      return T.createElement(Jf, null);
    case ke.MEMBERS:
      return T.createElement(vf, null);
    case ke.MESSAGE:
      return T.createElement(zf, null);
    case ke.MODERATIONS:
      return T.createElement(xf, null);
    case ke.MORE:
      return T.createElement(Gf, null);
    case ke.MUTE:
      return T.createElement(yf, null);
    case ke.NOTIFICATIONS:
      return T.createElement(Bf, null);
    case ke.NOTIFICATIONS_OFF_FILLED:
      return T.createElement(Df, null);
    case ke.OPERATOR:
      return T.createElement(Xf, null);
    case ke.PHOTO:
      return T.createElement(Of, null);
    case ke.PLAY:
      return T.createElement(jf, null);
    case ke.PLUS:
      return T.createElement(Hf, null);
    case ke.QUESTION:
      return T.createElement(ff, null);
    case ke.REFRESH:
      return T.createElement(wf, null);
    case ke.REMOVE:
      return T.createElement(gf, null);
    case ke.REPLY:
      return T.createElement(If, null);
    case ke.SEARCH:
      return T.createElement(Lf, null);
    case ke.SEND:
      return T.createElement(Cf, null);
    case ke.SETTINGS_FILLED:
      return T.createElement(Kf, null);
    case ke.SLIDE_LEFT:
      return T.createElement(_f, null);
    case ke.SPINNER:
      return T.createElement(Pf, null);
    case ke.SUPERGROUP:
      return T.createElement(Af, null);
    case ke.THREAD:
      return T.createElement(qf, null);
    case ke.THUMBNAIL_NONE:
      return T.createElement($f, null);
    case ke.TOGGLE_OFF:
      return T.createElement(ew, null);
    case ke.TOGGLE_ON:
      return T.createElement(tw, null);
    case ke.USER:
      return T.createElement(nw, null);
    case ke.FEEDBACK_LIKE:
      return T.createElement(lw, null);
    case ke.FEEDBACK_DISLIKE:
      return T.createElement(aw, null);
    default:
      return "icon";
  }
}
function dt(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.type, a = e.fillColor, d = a === void 0 ? Zl.DEFAULT : a, r = e.width, i = r === void 0 ? 26 : r, c = e.height, V = c === void 0 ? 26 : c, s = e.onClick, o = s === void 0 ? dl : s, U = e.children, N = U === void 0 ? null : U, R = {
    width: typeof i == "string" ? i : "".concat(i, "px"),
    minWidth: typeof i == "string" ? i : "".concat(i, "px"),
    height: typeof V == "string" ? V : "".concat(V, "px"),
    minHeight: typeof V == "string" ? V : "".concat(V, "px")
  };
  return T.createElement("div", { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
    "sendbird-icon",
    AH(l),
    PH(d)
  ], !1).join(" "), role: "button", onClick: o, onKeyDown: o, tabIndex: 0, style: R }, N || dw(l));
}
var Le = ke, Pe = Zl, ko = "sendbird-modal-root", rw = function(e) {
  var n = e.titleText;
  return T.createElement(
    "div",
    { className: "sendbird-modal__header" },
    T.createElement(Fe, { type: oe.H_1, color: ie.ONBACKGROUND_1 }, n)
  );
}, iw = function(e) {
  var n = e.children;
  return T.createElement(
    "div",
    { className: "sendbird-modal__body" },
    T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_2 }, n)
  );
}, mF = function(e) {
  var n = e.submitText, t = e.disabled, l = t === void 0 ? !1 : t, a = e.hideCancelButton, d = a === void 0 ? !1 : a, r = e.type, i = r === void 0 ? nl.DANGER : r, c = e.onSubmit, V = e.onCancel, s = Gt(Kn).stringSet;
  return T.createElement(
    "div",
    { className: "sendbird-modal__footer" },
    !d && T.createElement(
      Ql,
      { type: nl.SECONDARY, onClick: V },
      T.createElement(Fe, { type: oe.BUTTON_1, color: ie.ONBACKGROUND_1 }, s.BUTTON__CANCEL)
    ),
    T.createElement(Ql, { type: i, disabled: l, onClick: c }, n)
  );
};
function Ic(e) {
  var n = e.children, t = n === void 0 ? null : n, l = e.className, a = l === void 0 ? "" : l, d = e.contentClassName, r = d === void 0 ? "" : d, i = e.isCloseOnClickOutside, c = i === void 0 ? !1 : i, V = e.isFullScreenOnMobile, s = V === void 0 ? !1 : V, o = e.titleText, U = e.submitText, N = e.disabled, R = N === void 0 ? !1 : N, h = e.hideFooter, Z = h === void 0 ? !1 : h, W = e.type, F = W === void 0 ? nl.DANGER : W, m = e.onCancel, E = m === void 0 ? dl : m, u = e.onClose, b = e.onSubmit, k = b === void 0 ? dl : b, Q = e.renderHeader, S = e.customFooter, v = u ?? E, G = dr().isMobile;
  return Yi(T.createElement(
    "div",
    { className: `
      sendbird-modal `.concat(a, `
      `).concat(s && G ? "sendbird-modal--full-mobile" : "", `
    `) },
    T.createElement(
      "div",
      { className: Ut([
        "sendbird-modal__content"
      ], Array.isArray(r) ? r : [r], !0).join(" ") },
      (Q == null ? void 0 : Q()) || T.createElement(rw, { titleText: o ?? "" }),
      T.createElement(iw, null, t),
      !Z && (S ?? T.createElement(mF, { disabled: R, onCancel: v, onSubmit: k, submitText: U ?? "", type: F })),
      !G && T.createElement(
        "div",
        { className: "sendbird-modal__close" },
        T.createElement(
          Fi,
          { width: "32px", height: "32px", onClick: v },
          T.createElement(dt, { type: Le.CLOSE, fillColor: Pe.DEFAULT, width: "24px", height: "24px" })
        )
      )
    ),
    T.createElement("div", { className: `
          sendbird-modal__backdrop
          `.concat(c && "sendbird-modal__backdrop--clickoutside", `
        `), onClick: function(w) {
      w == null || w.stopPropagation(), c && v();
    } })
  ), document.getElementById(ko));
}
var uF = function() {
}, gb = _l({
  start: uF,
  stop: uF,
  isRecordable: !1
}), Vw = function(e) {
  var n, t = e.children, l = zn().config, a = l.logger, d = l.isVoiceMessageEnabled, r = me(null), i = r[0], c = r[1], V = me(!1), s = V[0], o = V[1], U = me(!1), N = U[0], R = U[1], h = ca().stringSet, Z = me(null), W = Z[0], F = Z[1], m = (n = Vp.find(function(b) {
    return MediaRecorder.isTypeSupported(b);
  })) !== null && n !== void 0 ? n : "";
  d && !m && a.error("VoiceRecorder: Browser does not support mimeType", { mimmeTypes: Vp }), _e(function() {
    d && !W && import("./bundle-f5U_VL0z-4ba4fb58.mjs").then(function(b) {
      F(b);
    });
  }, [d, W]);
  var E = Pt(function(b) {
    var k, Q;
    if (d && !W) {
      a.error("VoiceRecorder: Recording audio processor is being loaded.");
      return;
    }
    var S = function() {
      try {
        navigator.permissions.query({ name: "microphone" }).then(function(v) {
          v.state === "denied" && (a.warning("VoiceRecorder: Permission denied."), R(!0));
        });
      } catch (v) {
        a.warning("VoiceRecorder: Failed to check permission.", v);
      }
    };
    a.info("VoiceRecorder: Start recording."), i && (u(), a.info("VoiceRecorder: Previous mediaRecorder is stopped.")), S(), (Q = (k = navigator == null ? void 0 : navigator.mediaDevices) === null || k === void 0 ? void 0 : k.getUserMedia) === null || Q === void 0 || Q.call(k, { audio: !0 }).then(function(v) {
      var G;
      a.info("VoiceRecorder: Succeeded getting media stream.", v), o(!0);
      var w = new MediaRecorder(v, {
        mimeType: m,
        audioBitsPerSecond: Cj
      });
      w.ondataavailable = function(y) {
        var g, f, I;
        a.info("VoiceRecorder: Succeeded getting an available data.", y.data);
        var K = new File([y.data], hR, {
          lastModified: (/* @__PURE__ */ new Date()).getTime(),
          type: to
        });
        W == null || W.downsampleToWav(K, function(Ue) {
          var q = W == null ? void 0 : W.encodeMp3(Ue), ae = new Blob(q, { type: to }), se = new File([ae], hR, {
            lastModified: (/* @__PURE__ */ new Date()).getTime(),
            type: to
          });
          b == null || b.onRecordingEnded(se), a.info("VoiceRecorder: Succeeded converting audio file.", se);
        }), (I = (g = v == null ? void 0 : v.getAudioTracks) === null || g === void 0 ? void 0 : (f = g.call(v)).forEach) === null || I === void 0 || I.call(f, function(Ue) {
          return Ue == null ? void 0 : Ue.stop();
        }), o(!1);
      }, w.onstart = (G = b == null ? void 0 : b.onRecordingStarted) !== null && G !== void 0 ? G : uF, w == null || w.start(), c(w);
    }).catch(function(v) {
      a.error("VoiceRecorder: Failed getting media stream.", v), c(null);
    });
  }, [i, W]), u = Pt(function() {
    i == null || i.stop(), c(null), o(!1), a.info("VoiceRecorder: Stop recording.");
  }, [i]);
  return T.createElement(
    gb.Provider,
    { value: {
      start: E,
      stop: u,
      isRecordable: s
    } },
    t,
    N && T.createElement(
      Ic,
      { hideFooter: !0, onCancel: function() {
        return R(!1);
      } },
      T.createElement(T.Fragment, null, h.VOICE_RECORDING_PERMISSION_DENIED)
    )
  );
}, Ib = function() {
  return Gt(gb);
};
function Lb(e) {
  return {
    lowerCase: e.toLowerCase(),
    upperCase: e.toUpperCase()
  };
}
function Cb(e) {
  return {
    lowerCase: e.toLowerCase(),
    upperCase: e.toUpperCase()
  };
}
var Kb = _l({
  openModal: dl
}), cw = function(e) {
  var n = e.children, t = me([]), l = t[0], a = t[1], d = Pt(function(c) {
    a(function(V) {
      return Ut(Ut([], V, !0), [c], !1);
    });
  }, []), r = Pt(function() {
    a(function(c) {
      return c.slice(1);
    });
  }, []), i = nn(function() {
    return function() {
      return Va(l).when(function(c) {
        return c.length === 0;
      }, function() {
        return T.createElement(T.Fragment, null);
      }).otherwise(function() {
        var c = l[0], V = c.modalProps, s = c.childElement;
        return T.createElement(Ic, ce({}, V, { className: "sendbird-global-modal ".concat(V == null ? void 0 : V.className), onClose: function() {
          var o;
          (o = V == null ? void 0 : V.onClose) === null || o === void 0 || o.call(V), r();
        } }), s({
          closeModal: r
        }));
      });
    };
  }, [l]);
  return T.createElement(
    Kb.Provider,
    { value: {
      openModal: d
    } },
    T.createElement(i, null),
    n
  );
}, sw = function() {
  return Gt(Kb);
}, ow = function(e) {
  if (e == null)
    return !0;
  for (var n in e)
    if (e.hasOwnProperty(n))
      return !1;
  return JSON.stringify(e) === JSON.stringify({});
}, Uw = function(e) {
  ud(function() {
    ow(e) || Fr({
      variables: ce({
        "--sendbird-dark-primary-500": "#4d2aa6",
        "--sendbird-dark-primary-400": "#6440C4",
        "--sendbird-dark-primary-300": "#7B53EF",
        "--sendbird-dark-primary-200": "#9E8CF5",
        "--sendbird-dark-primary-100": "#E2DFFF",
        "--sendbird-dark-secondary-500": "#007A7A",
        "--sendbird-dark-secondary-400": "#189A8D",
        "--sendbird-dark-secondary-300": "#2EBA9F",
        "--sendbird-dark-secondary-200": "#6FD6BE",
        "--sendbird-dark-secondary-100": "#AEF2DC",
        "--sendbird-dark-information-100": "#b2d9ff",
        "--sendbird-dark-error-500": "#A30E2D",
        "--sendbird-dark-error-400": "#C11F41",
        "--sendbird-dark-error-300": "#E53157",
        "--sendbird-dark-error-200": "#FF6183",
        "--sendbird-dark-error-100": "#FFABBD",
        "--sendbird-dark-background-700": "#000000",
        "--sendbird-dark-background-600": "#161616",
        "--sendbird-dark-background-500": "#2C2C2C",
        "--sendbird-dark-background-400": "#393939",
        "--sendbird-dark-background-300": "#A8A8A8",
        "--sendbird-dark-background-200": "#D9D9D9",
        "--sendbird-dark-background-100": "#F0F0F0",
        "--sendbird-dark-background-50": "#FFFFFF",
        "--sendbird-dark-overlay": "rgba(0, 0, 0, 0.32)",
        "--sendbird-dark-onlight-01": "rgba(0, 0, 0, 0.88)",
        "--sendbird-dark-onlight-02": "rgba(0, 0, 0, 0.50)",
        "--sendbird-dark-onlight-03": "rgba(0, 0, 0, 0.38)",
        "--sendbird-dark-onlight-04": "rgba(0, 0, 0, 0.12)",
        "--sendbird-dark-ondark-01": "rgba(255, 255, 255, 0.88)",
        "--sendbird-dark-ondark-02": "rgba(255, 255, 255, 0.50)",
        "--sendbird-dark-ondark-03": "rgba(255, 255, 255, 0.38)",
        "--sendbird-dark-ondark-04": "rgba(255, 255, 255, 0.12)",
        "--sendbird-dark-shadow-01": "0 1px 5px 0 rgba(33, 34, 66, 0.04), 0 0 3px 0 rgba(0, 0, 0, 0.08), 0 2px 1px 0 rgba(0, 0, 0, 0.12)",
        "--sendbird-dark-shadow-02": "0 3px 5px -3px rgba(33, 34, 66, 0.04), 0 3px 14px 2px rgba(0, 0, 0, 0.08), 0 8px 10px 1px rgba(0, 0, 0, 0.12)",
        "--sendbird-dark-shadow-03": "0 6px 10px -5px rgba(0, 0, 0, 0.04), 0 6px 30px 5px rgba(0, 0, 0, 0.08), 0 16px 24px 2px rgba(0, 0, 0, 0.12)",
        "--sendbird-dark-shadow-04": "0 9px 15px -7px rgba(0, 0, 0, 0.04), 0 9px 46px 8px rgba(0, 0, 0, 0.08), 0 24px 38px 3px rgba(0, 0, 0, 0.12)",
        "--sendbird-dark-shadow-message-input": "0 1px 5px 0 rgba(33, 34, 66, 0.12), 0 0 1px 0 rgba(33, 34, 66, 0.16), 0 2px 1px 0 rgba(33, 34, 66, 0.08), 0 1px 5px 0 rgba(0, 0, 0, 0.12)",
        "--sendbird-light-primary-500": "#4d2aa6",
        "--sendbird-light-primary-400": "#6440C4",
        "--sendbird-light-primary-300": "#7B53EF",
        "--sendbird-light-primary-200": "#9E8CF5",
        "--sendbird-light-primary-100": "#E2DFFF",
        "--sendbird-light-secondary-500": "#007A7A",
        "--sendbird-light-secondary-400": "#189A8D",
        "--sendbird-light-secondary-300": "#2EBA9F",
        "--sendbird-light-secondary-200": "#6FD6BE",
        "--sendbird-light-secondary-100": "#AEF2DC",
        "--sendbird-light-information-100": "#b2d9ff",
        "--sendbird-light-error-500": "#A30E2D",
        "--sendbird-light-error-400": "#C11F41",
        "--sendbird-light-error-300": "#E53157",
        "--sendbird-light-error-200": "#FF6183",
        "--sendbird-light-error-100": "#FFABBD",
        "--sendbird-light-background-700": "#000000",
        "--sendbird-light-background-600": "#161616",
        "--sendbird-light-background-500": "#2C2C2C",
        "--sendbird-light-background-400": "#393939",
        "--sendbird-light-background-300": "#A8A8A8",
        "--sendbird-light-background-200": "#D9D9D9",
        "--sendbird-light-background-100": "#F0F0F0",
        "--sendbird-light-background-50": " #FFFFFF",
        "--sendbird-light-overlay": "rgba(0, 0, 0, 0.32)",
        "--sendbird-light-onlight-01": "rgba(0, 0, 0, 0.88)",
        "--sendbird-light-onlight-02": "rgba(0, 0, 0, 0.50)",
        "--sendbird-light-onlight-03": "rgba(0, 0, 0, 0.38)",
        "--sendbird-light-onlight-04": "rgba(0, 0, 0, 0.12)",
        "--sendbird-light-onlight-05": "rgba(0, 0, 0, 0.44)",
        "--sendbird-light-ondark-01": "rgba(255, 255, 255, 0.88)",
        "--sendbird-light-ondark-02": "rgba(255, 255, 255, 0.50)",
        "--sendbird-light-ondark-03": "rgba(255, 255, 255, 0.38)",
        "--sendbird-light-ondark-04": "rgba(255, 255, 255, 0.12)",
        "--sendbird-light-ondark-05": "rgba(255, 255, 255, 0.44)",
        "--sendbird-light-shadow-01": "0 1px 5px 0 rgba(33, 34, 66, 0.04), 0 0 3px 0 rgba(0, 0, 0, 0.08), 0 2px 1px 0 rgba(0, 0, 0, 0.12)",
        "--sendbird-light-shadow-02": "0 3px 5px -3px rgba(33, 34, 66, 0.04), 0 3px 14px 2px rgba(0, 0, 0, 0.08), 0 8px 10px 1px rgba(0, 0, 0, 0.12)",
        "--sendbird-light-shadow-03": "0 6px 10px -5px rgba(0, 0, 0, 0.04), 0 6px 30px 5px rgba(0, 0, 0, 0.08), 0 16px 24px 2px rgba(0, 0, 0, 0.12)",
        "--sendbird-light-shadow-04": "0 9px 15px -7px rgba(0, 0, 0, 0.04), 0 9px 46px 8px rgba(0, 0, 0, 0.08), 0 24px 38px 3px rgba(0, 0, 0, 0.12)",
        "--sendbird-light-shadow-message-input": "0 1px 5px 0 rgba(33, 34, 66, 0.12), 0 0 1px 0 rgba(33, 34, 66, 0.16), 0 2px 1px 0 rgba(33, 34, 66, 0.08), 0 1px 5px 0 rgba(0, 0, 0, 0.12)"
      }, e)
    });
  }, [e]);
}, gd = {
  INIT_SDK: "INIT_SDK",
  SET_SDK_LOADING: "SET_SDK_LOADING",
  RESET_SDK: "RESET_SDK",
  SDK_ERROR: "SDK_ERROR"
}, _b = {
  initialized: !1,
  loading: !1,
  sdk: {},
  error: !1
};
function Nw(e, n) {
  return Va(n).with({ type: gd.SET_SDK_LOADING }, function(t) {
    var l = t.payload;
    return ce(ce({}, e), { initialized: !1, loading: l });
  }).with({ type: gd.SDK_ERROR }, function() {
    return ce(ce({}, e), { initialized: !1, loading: !1, error: !0 });
  }).with({ type: gd.INIT_SDK }, function(t) {
    var l = t.payload;
    return {
      sdk: l,
      initialized: !0,
      loading: !1,
      error: !1
    };
  }).with({ type: gd.RESET_SDK }, function() {
    return _b;
  }).otherwise(function() {
    return e;
  });
}
var Pb = {
  initialized: !1,
  loading: !1,
  user: {}
};
function Rw(e, n) {
  return Va(n).with({ type: uV.INIT_USER }, function(t) {
    var l = t.payload;
    return {
      initialized: !0,
      loading: !1,
      user: l
    };
  }).with({ type: uV.RESET_USER }, function() {
    return Pb;
  }).with({ type: uV.UPDATE_USER_INFO }, function(t) {
    var l = t.payload;
    return ce(ce({}, e), { user: l });
  }).otherwise(function() {
    return e;
  });
}
var ci = {
  INITIALIZE_MESSAGE_TEMPLATES_INFO: "INITIALIZE_MESSAGE_TEMPLATES_INFO",
  UPSERT_MESSAGE_TEMPLATE: "UPSERT_MESSAGE_TEMPLATE",
  UPSERT_WAITING_TEMPLATE_KEY: "UPSERT_WAITING_TEMPLATE_KEY",
  MARK_ERROR_WAITING_TEMPLATE_KEY: "MARK_ERROR_WAITING_TEMPLATE_KEY"
};
function hw(e, n) {
  return Va(n).with({ type: ci.INITIALIZE_MESSAGE_TEMPLATES_INFO }, function(t) {
    var l = t.payload;
    return {
      messageTemplatesInfo: l,
      waitingTemplateKeysMap: {}
    };
  }).with({ type: ci.UPSERT_MESSAGE_TEMPLATE }, function(t) {
    var l = t.payload, a = e.messageTemplatesInfo;
    if (!a)
      return e;
    var d = l.key, r = l.template;
    return a.templatesMap[d] = r, delete e.waitingTemplateKeysMap[d], ce(ce({}, e), { messageTemplatesInfo: a });
  }).with({ type: ci.UPSERT_WAITING_TEMPLATE_KEY }, function(t) {
    var l = t.payload, a = l.key, d = l.requestedAt;
    return e.waitingTemplateKeysMap[a] = {
      requestedAt: d,
      isError: !1
    }, ce({}, e);
  }).with({ type: ci.MARK_ERROR_WAITING_TEMPLATE_KEY }, function(t) {
    var l = t.payload, a = l.key, d = e.waitingTemplateKeysMap[a];
    return d && (d.isError = !0), ce({}, e);
  }).otherwise(function() {
    return e;
  });
}
var Zw = {
  waitingTemplateKeysMap: {}
};
function Ab(e) {
  var n = e.sdkDispatcher, t = e.userDispatcher, l = e.sdk;
  return ol(this, void 0, void 0, function() {
    return Ul(this, function(a) {
      return [2, new Promise(function(d) {
        n({ type: gd.SET_SDK_LOADING, payload: !0 }), l != null && l.disconnect ? l.disconnect().then(function() {
          n({ type: gd.RESET_SDK }), t({ type: uV.RESET_USER });
        }).finally(function() {
          d(!0);
        }) : d(!0);
      })];
    });
  });
}
var JZ = "3.13.1", Tw = gd.INIT_SDK, Fw = gd.SET_SDK_LOADING, Ww = gd.RESET_SDK, WM = gd.SDK_ERROR, mw = uV.INIT_USER, uw = uV.UPDATE_USER_INFO, pw = uV.RESET_USER;
function Mw(e) {
  var n = e.userId, t = e.appId;
  return "SendbirdProvider | useConnect/setupConnection/Connection failed UserId: ".concat(n, " or appId: ").concat(t, " missing");
}
function Ew(e) {
  return "SendbirdProvider | useConnect/setupConnection/Connection failed. ".concat((e == null ? void 0 : e.code) || "", " ").concat((e == null ? void 0 : e.message) || "");
}
function Sw(e) {
  var n = e.appId, t = e.customApiHost, l = e.customWebSocketHost, a = e.sdkInitParams, d = a === void 0 ? {} : a, r = Object.assign(d, {
    appId: n,
    modules: [new mX(), new Sj()],
    newInstance: !0,
    localCacheEnabled: !0
  });
  return t && (r.customApiHost = t), l && (r.customWebSocketHost = l), MO.init(r);
}
function kw(e) {
  var n = e.logger, t = e.sdkDispatcher, l = e.userDispatcher, a = e.initDashboardConfigs, d = e.userId, r = e.appId, i = e.customApiHost, c = e.customWebSocketHost, V = e.configureSession, s = e.nickname, o = e.profileUrl, U = e.accessToken, N = e.isUserIdUsedForNickname, R = e.sdkInitParams, h = e.customExtensionParams, Z = e.isMobile, W = Z === void 0 ? !1 : Z, F = e.eventHandlers, m = e.initializeMessageTemplatesInfo;
  return ol(this, void 0, void 0, function() {
    var E = this;
    return Ul(this, function(u) {
      return [2, new Promise(function(b, k) {
        var Q, S, v, G, w, y, g, f, I, K, Ue;
        (Q = n == null ? void 0 : n.info) === null || Q === void 0 || Q.call(n, "SendbirdProvider | useConnect/setupConnection/init", { userId: d, appId: r });
        var q = (S = F == null ? void 0 : F.connection) === null || S === void 0 ? void 0 : S.onFailed;
        if (t({ type: Fw, payload: !0 }), d && r) {
          var ae = Sw({
            appId: r,
            customApiHost: i,
            customWebSocketHost: c,
            sdkInitParams: R
          });
          if (V && typeof V == "function") {
            var se = V(ae);
            (v = n == null ? void 0 : n.info) === null || v === void 0 || v.call(n, "SendbirdProvider | useConnect/setupConnection/configureSession", se), ae.setSessionHandler(se);
          }
          (G = n == null ? void 0 : n.info) === null || G === void 0 || G.call(n, "SendbirdProvider | useConnect/setupConnection/setVersion", { version: JZ }), (w = ae == null ? void 0 : ae.addSendbirdExtensions) === null || w === void 0 || w.call(ae, [
            {
              product: (y = ys == null ? void 0 : ys.UIKIT_CHAT) !== null && y !== void 0 ? y : "uikit-chat",
              version: JZ,
              platform: (g = ZV == null ? void 0 : ZV.JS) !== null && g !== void 0 ? g : "js"
            }
          ], {
            platform: W ? (f = Cr == null ? void 0 : Cr.MOBILE_WEB) !== null && f !== void 0 ? f : "mobile_web" : (I = Cr == null ? void 0 : Cr.WEB) !== null && I !== void 0 ? I : "web"
          }, h), ae.addExtension("sb_uikit", JZ);
          var le = function(ee) {
            return ol(E, void 0, void 0, function() {
              var O, re, te, Qe;
              return Ul(this, function(Ye) {
                switch (Ye.label) {
                  case 0:
                    (re = n == null ? void 0 : n.info) === null || re === void 0 || re.call(n, "SendbirdProvider | useConnect/setupConnection/connectCbSuccess", ee), t({ type: Tw, payload: ae }), l({ type: mw, payload: ee }), Ye.label = 1;
                  case 1:
                    return Ye.trys.push([1, 3, , 4]), [4, m(ae)];
                  case 2:
                    return Ye.sent(), [3, 4];
                  case 3:
                    return O = Ye.sent(), (te = n == null ? void 0 : n.error) === null || te === void 0 || te.call(n, "SendbirdProvider | useConnect/setupConnection/upsertMessageTemplateListInLocalStorage failed", {
                      error: O
                    }), [3, 4];
                  case 4:
                    return a(ae).then(function(Se) {
                      var P;
                      (P = n == null ? void 0 : n.info) === null || P === void 0 || P.call(n, "SendbirdProvider | useConnect/setupConnection/getUIKitConfiguration success", {
                        config: Se
                      });
                    }).catch(function(Se) {
                      var P;
                      (P = n == null ? void 0 : n.error) === null || P === void 0 || P.call(n, "SendbirdProvider | useConnect/setupConnection/getUIKitConfiguration failed", {
                        error: Se
                      });
                    }), (s !== ee.nickname || o !== ee.profileUrl) && !(ap(s) && ap(o)) ? ((Qe = n == null ? void 0 : n.info) === null || Qe === void 0 || Qe.call(n, "SendbirdProvider | useConnect/setupConnection/updateCurrentUserInfo", {
                      nickname: s,
                      profileUrl: o
                    }), ae.updateCurrentUserInfo({
                      nickname: s || ee.nickname || (N ? ee.userId : ""),
                      profileUrl: o || ee.profileUrl
                    }).then(function(Se) {
                      var P;
                      (P = n == null ? void 0 : n.info) === null || P === void 0 || P.call(n, "SendbirdProvider | useConnect/setupConnection/updateCurrentUserInfo success", {
                        nickname: s,
                        profileUrl: o
                      }), l({ type: uw, payload: Se });
                    }).finally(function() {
                      b();
                    })) : b(), [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }, L = function(ee) {
            var O, re = Ew(ee);
            (O = n == null ? void 0 : n.error) === null || O === void 0 || O.call(n, re, {
              e: ee,
              appId: r,
              userId: d
            }), t({ type: Ww }), l({ type: pw }), t({ type: WM }), q == null || q(ee), k(re);
          };
          (K = n == null ? void 0 : n.info) === null || K === void 0 || K.call(n, "SendbirdProvider | useConnect/setupConnection/connect connecting using ".concat(U ?? d)), ae.connect(d, U).then(function(ee) {
            return le(ee);
          }).catch(function(ee) {
            return L(ee);
          });
        } else {
          var $ = Mw({ userId: d, appId: r });
          t({ type: WM }), q == null || q({ message: $ }), (Ue = n == null ? void 0 : n.error) === null || Ue === void 0 || Ue.call(n, $), k($);
        }
      })];
    });
  });
}
function mM(e) {
  var n = e.logger, t = e.sdkDispatcher, l = e.userDispatcher, a = e.appInfoDispatcher, d = e.initDashboardConfigs, r = e.userId, i = e.appId, c = e.customApiHost, V = e.customWebSocketHost, s = e.configureSession, o = e.nickname, U = e.profileUrl, N = e.accessToken, R = e.sdk, h = e.sdkInitParams, Z = e.customExtensionParams, W = e.isMobile, F = e.eventHandlers, m = e.isUserIdUsedForNickname, E = e.initializeMessageTemplatesInfo;
  return ol(this, void 0, void 0, function() {
    return Ul(this, function(u) {
      switch (u.label) {
        case 0:
          return [4, Ab({
            logger: n,
            sdkDispatcher: t,
            userDispatcher: l,
            sdk: R
          })];
        case 1:
          return u.sent(), [4, kw({
            logger: n,
            sdkDispatcher: t,
            userDispatcher: l,
            appInfoDispatcher: a,
            initDashboardConfigs: d,
            userId: r,
            appId: i,
            customApiHost: c,
            customWebSocketHost: V,
            configureSession: s,
            nickname: o,
            profileUrl: U,
            accessToken: N,
            sdkInitParams: h,
            customExtensionParams: Z,
            isMobile: W,
            eventHandlers: F,
            isUserIdUsedForNickname: m,
            initializeMessageTemplatesInfo: E
          })];
        case 2:
          return u.sent(), [
            2
            /*return*/
          ];
      }
    });
  });
}
function bw(e, n) {
  var t = this, l, a = e.userId, d = e.appId, r = e.accessToken, i = e.isMobile, c = e.isUserIdUsedForNickname, V = n.logger, s = n.nickname, o = n.profileUrl, U = n.configureSession, N = n.customApiHost, R = n.customWebSocketHost, h = n.sdk, Z = n.sdkDispatcher, W = n.userDispatcher, F = n.appInfoDispatcher, m = n.initDashboardConfigs, E = n.sdkInitParams, u = n.customExtensionParams, b = n.eventHandlers, k = n.initializeMessageTemplatesInfo;
  (l = V == null ? void 0 : V.info) === null || l === void 0 || l.call(V, "SendbirdProvider | useConnect", ce(ce({}, e), n));
  var Q = Wt({
    appId: "",
    userId: ""
  });
  _e(function() {
    var v;
    (v = V == null ? void 0 : V.info) === null || v === void 0 || v.call(V, "SendbirdProvider | useConnect/useEffect", { userId: a, appId: d, accessToken: r }), !(Q.current.appId === d && Q.current.userId === a) && (Q.current = { appId: d, userId: a }, mM({
      userId: a,
      appId: d,
      accessToken: r,
      logger: V,
      nickname: s,
      profileUrl: o,
      configureSession: U,
      customApiHost: N,
      customWebSocketHost: R,
      sdk: h,
      sdkDispatcher: Z,
      userDispatcher: W,
      appInfoDispatcher: F,
      initDashboardConfigs: m,
      isUserIdUsedForNickname: c,
      sdkInitParams: E,
      customExtensionParams: u,
      isMobile: i,
      eventHandlers: b,
      initializeMessageTemplatesInfo: k
    }).catch(function(G) {
      var w;
      (w = V == null ? void 0 : V.error) === null || w === void 0 || w.call(V, "SendbirdProvider | useConnect/useEffect", G);
    }));
  }, [a, d]);
  var S = Pt(function() {
    return ol(t, void 0, void 0, function() {
      var v, G, w;
      return Ul(this, function(y) {
        switch (y.label) {
          case 0:
            (G = V == null ? void 0 : V.info) === null || G === void 0 || G.call(V, "SendbirdProvider | useConnect/reconnect/useCallback", { sdk: h }), y.label = 1;
          case 1:
            return y.trys.push([1, 3, , 4]), [4, mM({
              userId: a,
              appId: d,
              accessToken: r,
              logger: V,
              nickname: s,
              profileUrl: o,
              configureSession: U,
              customApiHost: N,
              customWebSocketHost: R,
              sdk: h,
              sdkDispatcher: Z,
              userDispatcher: W,
              appInfoDispatcher: F,
              initDashboardConfigs: m,
              isUserIdUsedForNickname: c,
              sdkInitParams: E,
              customExtensionParams: u,
              isMobile: i,
              eventHandlers: b,
              initializeMessageTemplatesInfo: k
            })];
          case 2:
            return y.sent(), [3, 4];
          case 3:
            return v = y.sent(), (w = V == null ? void 0 : V.error) === null || w === void 0 || w.call(V, "SendbirdProvider | useConnect/reconnect/useCallback", v), [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [h]);
  return S;
}
var Sa = {
  DEBUG: "debug",
  WARNING: "warning",
  ERROR: "error",
  INFO: "info",
  ALL: "all"
}, Yw = function(e) {
  switch (e) {
    case Sa.WARNING:
      return "color: Orange";
    case Sa.ERROR:
      return "color: Red";
    default:
      return "color: Gray";
  }
}, Qw = function(e) {
  var n = e.level, t = e.title, l = e.description, a = l === void 0 ? "" : l, d = e.payload, r = d === void 0 ? [] : d;
  console.log.apply(console, Ut(["%c SendbirdUIKit | ".concat(n, " | ").concat((/* @__PURE__ */ new Date()).toISOString(), " | ").concat(t, " ").concat(a && "|"), Yw(n), a], r, !1));
}, Jw = function() {
  return {
    info: dl,
    error: dl,
    warning: dl
  };
}, uM = function(e, n) {
  var t = n || Qw, l = Array.isArray(e) ? e : [e], a = function(d) {
    return function(r, i) {
      for (var c = [], V = 2; V < arguments.length; V++)
        c[V - 2] = arguments[V];
      return t({
        level: d,
        title: r,
        description: i,
        payload: c
      });
    };
  };
  return l.reduce(function(d, r) {
    return r === Sa.DEBUG || r === Sa.ALL ? ce(ce({}, d), { info: a(Sa.INFO), error: a(Sa.ERROR), warning: a(Sa.WARNING) }) : r === Sa.INFO ? ce(ce({}, d), { info: a(Sa.INFO) }) : r === Sa.ERROR ? ce(ce({}, d), { error: a(Sa.ERROR) }) : r === Sa.WARNING ? ce(ce({}, d), { warning: a(Sa.WARNING) }) : ce({}, d);
  }, Jw());
};
function vw(e, n) {
  e === void 0 && (e = []), n === void 0 && (n = "unknown"), _e(function() {
    var t = document.querySelector(n);
    return t && e.forEach(function(l) {
      var a = document.createElement("div");
      a.setAttribute("id", l), t.appendChild(a);
    }), function() {
      t && e.forEach(function(l) {
        var a = document.getElementById(l);
        a && t.removeChild(a);
      });
    };
  }, []);
}
var zw = function(e) {
  var n = e.children;
  return T.createElement(
    lH,
    null,
    T.createElement(Vw, null, n)
  );
};
function xw(e) {
  var n, t, l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k, Q, S, v, G, w, y = e.legacyConfig, g = e.uikitOptions, f = g === void 0 ? {} : g, I = y.replyType, K = y.isMentionEnabled, Ue = y.isReactionEnabled, q = y.disableUserProfile, ae = y.isVoiceMessageEnabled, se = y.isTypingIndicatorEnabledOnChannelList, le = y.isMessageReceiptStatusEnabledOnChannelList, L = y.showSearchIcon;
  return {
    common: {
      enableUsingDefaultUserProfile: (t = (n = f.common) === null || n === void 0 ? void 0 : n.enableUsingDefaultUserProfile) !== null && t !== void 0 ? t : typeof q == "boolean" ? !q : void 0
    },
    groupChannel: {
      enableOgtag: (l = f.groupChannel) === null || l === void 0 ? void 0 : l.enableOgtag,
      enableMention: (d = (a = f.groupChannel) === null || a === void 0 ? void 0 : a.enableMention) !== null && d !== void 0 ? d : K,
      enableReactions: (i = (r = f.groupChannel) === null || r === void 0 ? void 0 : r.enableReactions) !== null && i !== void 0 ? i : Ue,
      enableTypingIndicator: (c = f.groupChannel) === null || c === void 0 ? void 0 : c.enableTypingIndicator,
      enableVoiceMessage: (s = (V = f.groupChannel) === null || V === void 0 ? void 0 : V.enableVoiceMessage) !== null && s !== void 0 ? s : ae,
      replyType: (U = (o = f.groupChannel) === null || o === void 0 ? void 0 : o.replyType) !== null && U !== void 0 ? U : I != null ? Lb(I).lowerCase : void 0,
      threadReplySelectType: (N = f.groupChannel) === null || N === void 0 ? void 0 : N.threadReplySelectType,
      input: {
        enableDocument: (h = (R = f.groupChannel) === null || R === void 0 ? void 0 : R.input) === null || h === void 0 ? void 0 : h.enableDocument
      },
      typingIndicatorTypes: (Z = f.groupChannel) === null || Z === void 0 ? void 0 : Z.typingIndicatorTypes,
      enableFeedback: (W = f.groupChannel) === null || W === void 0 ? void 0 : W.enableFeedback,
      enableSuggestedReplies: (F = f.groupChannel) === null || F === void 0 ? void 0 : F.enableSuggestedReplies,
      showSuggestedRepliesFor: (m = f.groupChannel) === null || m === void 0 ? void 0 : m.showSuggestedRepliesFor
    },
    groupChannelList: {
      enableTypingIndicator: (u = (E = f.groupChannelList) === null || E === void 0 ? void 0 : E.enableTypingIndicator) !== null && u !== void 0 ? u : se,
      enableMessageReceiptStatus: (k = (b = f.groupChannelList) === null || b === void 0 ? void 0 : b.enableMessageReceiptStatus) !== null && k !== void 0 ? k : le
    },
    groupChannelSettings: {
      enableMessageSearch: (S = (Q = f.groupChannelSettings) === null || Q === void 0 ? void 0 : Q.enableMessageSearch) !== null && S !== void 0 ? S : L
    },
    openChannel: {
      enableOgtag: (v = f.openChannel) === null || v === void 0 ? void 0 : v.enableOgtag,
      input: {
        enableDocument: (w = (G = f.openChannel) === null || G === void 0 ? void 0 : G.input) === null || w === void 0 ? void 0 : w.enableDocument
      }
    }
  };
}
function Gw(e, n) {
  var t = e.isConnected, l = n.logger, a = nn(function() {
    return mb({
      logger: l,
      cb: function(d) {
        try {
          d.markAsRead();
        } catch (r) {
          l.warning("Channel: Mark as delivered failed", { channel: d, error: r });
        }
      }
    });
  }, []);
  return _e(function() {
    t || a.clear();
  }, [t]), BW(function() {
    a.clear();
  }), a;
}
var yw = (
  /** @class */
  function() {
    function e(n) {
      var t = this, l, a = n.sdk, d = n.logger;
      (l = a == null ? void 0 : a.getAllEmoji) === null || l === void 0 || l.call(a).then(function(r) {
        t._emojiContainer = r, d == null || d.info("EmojiManager | Succeeded getting all emojis. ", r);
      }).catch(function() {
        d == null || d.warning("EmojiManager | Failed getting all emojis.");
      });
    }
    return Object.defineProperty(e.prototype, "AllEmojisAsArray", {
      get: function() {
        return this._emojiContainer.emojiCategories.flatMap(function(n) {
          return n.emojis;
        });
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "AllEmojisAsMap", {
      get: function() {
        return this._emojiContainer.emojiCategories.flatMap(function(n) {
          return n.emojis;
        }).reduce(function(n, t) {
          return n.set(t.key, t.url), n;
        }, /* @__PURE__ */ new Map());
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.getAllEmojis = function(n) {
      var t = this;
      return Va(n).when(function(l) {
        return ["array", "arr"].includes(l);
      }, function() {
        return t.AllEmojisAsArray;
      }).when(function(l) {
        return ["map"].includes(l);
      }, function() {
        return t.AllEmojisAsMap;
      }).otherwise(function() {
        return t.AllEmojisAsArray;
      });
    }, e.prototype.getEmojiUrl = function(n) {
      var t;
      return (t = this.AllEmojisAsArray.find(function(l) {
        return l.key === n;
      }).url) !== null && t !== void 0 ? t : "";
    }, Object.defineProperty(e.prototype, "emojiContainer", {
      get: function() {
        return this._emojiContainer;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }()
), Bw = {
  getItem: function(e) {
    var n;
    return ol(this, void 0, void 0, function() {
      return Ul(this, function(t) {
        return [2, (n = localStorage.getItem(e)) !== null && n !== void 0 ? n : null];
      });
    });
  },
  setItem: function(e, n) {
    return ol(this, void 0, void 0, function() {
      return Ul(this, function(t) {
        return [2, localStorage.setItem(e, n)];
      });
    });
  }
}, qb = function(e) {
  return {
    uiTemplate: JSON.stringify(e.ui_template.body.items),
    colorVariables: e.color_variables
  };
}, pM = function(e) {
  var n = {};
  return e.forEach(function(t) {
    n[t.key] = qb(t);
  }), n;
}, Dw = 20, MM = ci.INITIALIZE_MESSAGE_TEMPLATES_INFO, Xw = ci.UPSERT_MESSAGE_TEMPLATE, Ow = ci.UPSERT_WAITING_TEMPLATE_KEY, jw = ci.MARK_ERROR_WAITING_TEMPLATE_KEY;
function Hw(e) {
  var n = this, t = e.sdk, l = e.logger, a = e.appInfoStore, d = e.appInfoDispatcher, r = a == null ? void 0 : a.messageTemplatesInfo, i = function(o) {
    var U, N;
    if (!r)
      return null;
    var R = null, h = (U = r == null ? void 0 : r.templatesMap) !== null && U !== void 0 ? U : null;
    return h && (R = (N = h[o]) !== null && N !== void 0 ? N : null), R;
  }, c = function(o) {
    return ol(n, void 0, void 0, function() {
      var U, N, R, h;
      return Ul(this, function(Z) {
        switch (Z.label) {
          case 0:
            U = !0, N = null, R = [], Z.label = 1;
          case 1:
            return U ? [4, o.message.getMessageTemplatesByToken(N, { limit: Dw })] : [3, 3];
          case 2:
            return h = Z.sent(), U = h.hasMore, N = h.token, h.templates.forEach(function(W) {
              R.push(JSON.parse(W.template));
            }), [3, 1];
          case 3:
            return [2, R];
        }
      });
    });
  }, V = function(o) {
    return ol(n, void 0, void 0, function() {
      var U, N, R, h, Z, h, Z, W;
      return Ul(this, function(F) {
        switch (F.label) {
          case 0:
            return U = (W = o.appInfo) === null || W === void 0 ? void 0 : W.messageTemplateInfo.token, U ? (N = localStorage.getItem(bZ), R = localStorage.getItem(IV), !N || N !== U ? [4, c(o)] : [3, 2]) : (localStorage.removeItem(bZ), localStorage.removeItem(IV), [
              2
              /*return*/
            ]);
          case 1:
            return h = F.sent(), Z = {
              token: U,
              templatesMap: pM(h)
            }, d({ type: MM, payload: Z }), localStorage.setItem(bZ, U), localStorage.setItem(IV, JSON.stringify(h)), [3, 3];
          case 2:
            N && N === U && R && (h = JSON.parse(R), Z = {
              token: U,
              templatesMap: pM(h)
            }, d({ type: MM, payload: Z })), F.label = 3;
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, s = function(o, U) {
    return ol(n, void 0, void 0, function() {
      var N, R, h, Z, W, F, m;
      return Ul(this, function(E) {
        switch (E.label) {
          case 0:
            if (!d)
              return [3, 5];
            d({
              type: Ow,
              payload: {
                key: o,
                requestedAt: U
              }
            }), N = null, E.label = 1;
          case 1:
            return E.trys.push([1, 3, , 4]), [4, t.message.getMessageTemplate(o)];
          case 2:
            return R = E.sent(), N = JSON.parse(R.template), [3, 4];
          case 3:
            return h = E.sent(), (m = l == null ? void 0 : l.error) === null || m === void 0 || m.call(l, "Sendbird | fetchProcessedMessageTemplate failed", h), [3, 4];
          case 4:
            N ? (Z = localStorage.getItem(IV), Z ? (W = JSON.parse(Z), W.push(N), localStorage.setItem(IV, JSON.stringify(W))) : localStorage.setItem(IV, JSON.stringify([N])), F = qb(N), d({
              type: Xw,
              payload: {
                key: o,
                template: F
              }
            })) : d({
              type: jw,
              payload: {
                key: o
              }
            }), E.label = 5;
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  return {
    getCachedTemplate: i,
    updateMessageTemplatesInfo: s,
    initializeMessageTemplatesInfo: V
  };
}
function fw(e) {
  var n = xw({
    legacyConfig: {
      replyType: e.replyType,
      isMentionEnabled: e.isMentionEnabled,
      isReactionEnabled: e.isReactionEnabled,
      disableUserProfile: e.disableUserProfile,
      isVoiceMessageEnabled: e.isVoiceMessageEnabled,
      isTypingIndicatorEnabledOnChannelList: e.isTypingIndicatorEnabledOnChannelList,
      isMessageReceiptStatusEnabledOnChannelList: e.isMessageReceiptStatusEnabledOnChannelList,
      showSearchIcon: e.showSearchIcon
    },
    uikitOptions: e.uikitOptions
  });
  return T.createElement(
    HO,
    { storage: Bw, localConfigs: {
      common: n == null ? void 0 : n.common,
      groupChannel: {
        channel: n == null ? void 0 : n.groupChannel,
        channelList: n == null ? void 0 : n.groupChannelList,
        setting: n == null ? void 0 : n.groupChannelSettings
      },
      openChannel: {
        channel: n == null ? void 0 : n.openChannel
      }
    } },
    T.createElement(ww, ce({}, e))
  );
}
var ww = function(e) {
  var n, t, l, a = e.appId, d = e.userId, r = e.children, i = e.accessToken, c = e.customApiHost, V = e.customWebSocketHost, s = e.configureSession, o = s === void 0 ? null : s, U = e.theme, N = U === void 0 ? "light" : U, R = e.config, h = R === void 0 ? {} : R, Z = e.nickname, W = Z === void 0 ? "" : Z, F = e.colorSet, m = F === void 0 ? null : F, E = e.stringSet, u = E === void 0 ? null : E, b = e.dateLocale, k = b === void 0 ? null : b, Q = e.profileUrl, S = Q === void 0 ? "" : Q, v = e.voiceRecord, G = e.userListQuery, w = G === void 0 ? null : G, y = e.imageCompression, g = y === void 0 ? {} : y, f = e.allowProfileEdit, I = f === void 0 ? !1 : f, K = e.disableMarkAsDelivered, Ue = K === void 0 ? !1 : K, q = e.renderUserProfile, ae = q === void 0 ? null : q, se = e.onUserProfileMessage, le = se === void 0 ? null : se, L = e.breakpoint, $ = L === void 0 ? !1 : L, ee = e.isUserIdUsedForNickname, O = ee === void 0 ? !0 : ee, re = e.sdkInitParams, te = e.customExtensionParams, Qe = e.isMultipleFilesMessageEnabled, Ye = Qe === void 0 ? !1 : Qe, Se = e.eventHandlers, P = h.logLevel, ge = P === void 0 ? "" : P, Me = h.userMention, We = Me === void 0 ? {} : Me, De = h.isREMUnitEnabled, Oe = De === void 0 ? !1 : De, tt = h.pubSub, Be = dr().isMobile, He = me(uM(ge)), at = He[0], Ge = He[1], $e = me(function() {
    return tt ?? Ij();
  })[0], fe = zs(Nw, _b), Xe = fe[0], pt = fe[1], Vt = zs(Rw, Pb), yt = Vt[0], xe = Vt[1], At = zs(hw, Zw), kt = At[0], Kt = At[1], ln = fO(), vt = ln.configs, Rt = ln.configsWithAppAttr, Ke = ln.initDashboardConfigs, Je = Xe.initialized, de = Xe == null ? void 0 : Xe.sdk, qe = (n = de == null ? void 0 : de.appInfo) !== null && n !== void 0 ? n : {}, lt = qe.uploadSizeLimit, ct = qe.multipleFilesMessageFileCountLimit;
  Uw(m);
  var Ot = Hw({
    sdk: de,
    logger: at,
    appInfoStore: kt,
    appInfoDispatcher: Kt
  }), zt = Ot.getCachedTemplate, cn = Ot.updateMessageTemplatesInfo, mt = Ot.initializeMessageTemplatesInfo, sn = {
    updateMessageTemplatesInfo: cn,
    getCachedTemplate: zt
  }, hn = bw({
    appId: a,
    userId: d,
    accessToken: i,
    isUserIdUsedForNickname: O,
    isMobile: Be
  }, {
    logger: at,
    nickname: W,
    profileUrl: S,
    configureSession: o,
    customApiHost: c,
    customWebSocketHost: V,
    sdkInitParams: re,
    customExtensionParams: te,
    sdk: de,
    sdkDispatcher: pt,
    userDispatcher: xe,
    appInfoDispatcher: Kt,
    initDashboardConfigs: Ke,
    eventHandlers: Se,
    initializeMessageTemplatesInfo: mt
  });
  BW(function() {
    typeof de.disconnect == "function" && Ab({
      logger: at,
      sdkDispatcher: pt,
      userDispatcher: xe,
      sdk: de
    });
  }, [de.disconnect]), _e(function() {
    Ge(uM(ge));
  }, [ge]), vw([
    "sendbird-modal-root",
    "sendbird-dropdown-portal",
    "sendbird-emoji-list-portal"
  ], "body");
  var ft = me(N), qt = ft[0], jt = ft[1];
  _e(function() {
    jt(N);
  }, [N]), _e(function() {
    var Ne = document.querySelector("body");
    Ne.classList.remove("sendbird-experimental__rem__units"), Oe && Ne.classList.add("sendbird-experimental__rem__units");
  }, [Oe]), _e(function() {
    at.info("Setup theme", "Theme: ".concat(qt));
    try {
      var Ne = document.querySelector("body");
      Ne.classList.remove("sendbird-theme--light"), Ne.classList.remove("sendbird-theme--dark"), Ne.classList.add("sendbird-theme--".concat(qt || "light")), at.info("Finish setup theme");
    } catch (pe) {
      at.warning("Setup theme failed", "".concat(pe));
    }
    return function() {
      try {
        var pe = document.querySelector("body");
        pe.classList.remove("sendbird-theme--light"), pe.classList.remove("sendbird-theme--dark");
      } catch {
      }
    };
  }, [qt]);
  var Bt = Vj(Xe.sdk, at), Ie = Gw({ isConnected: Bt }, { logger: at }), it = sj({ isConnected: Bt }, { logger: at }), ze = T.useMemo(function() {
    return u ? ce(ce({}, ZR("en")), u) : ZR("en");
  }, [u]), ht = nn(function() {
    return Math.min(Aj, ct ?? Number.MAX_SAFE_INTEGER);
  }, [ct]), Ft = nn(function() {
    return lt;
  }, [lt]), X = nn(function() {
    return new yw({
      sdk: de,
      logger: at
    });
  }, [Xe.initialized]);
  return T.createElement(
    Ub.Provider,
    { value: {
      stores: {
        sdkStore: Xe,
        userStore: yt,
        appInfoStore: kt
      },
      dispatchers: {
        sdkDispatcher: pt,
        userDispatcher: xe,
        appInfoDispatcher: Kt,
        reconnect: hn
      },
      config: {
        disableMarkAsDelivered: Ue,
        renderUserProfile: ae,
        onUserProfileMessage: le,
        allowProfileEdit: I,
        isOnline: Bt,
        userId: d,
        appId: a,
        accessToken: i,
        theme: qt,
        setCurrentTheme: jt,
        setCurrenttheme: jt,
        isMultipleFilesMessageEnabled: Ye,
        uikitUploadSizeLimit: Ft,
        uikitMultipleFilesMessageLimit: ht,
        userListQuery: w,
        logger: at,
        pubSub: $e,
        imageCompression: ce({ compressionRate: 0.7 }, g),
        voiceRecord: {
          maxRecordingTime: (t = v == null ? void 0 : v.maxRecordingTime) !== null && t !== void 0 ? t : Lj,
          minRecordingTime: (l = v == null ? void 0 : v.minRecordingTime) !== null && l !== void 0 ? l : HW
        },
        userMention: {
          maxMentionCount: (We == null ? void 0 : We.maxMentionCount) || 10,
          maxSuggestionCount: (We == null ? void 0 : We.maxSuggestionCount) || 15
        },
        markAsReadScheduler: Ie,
        markAsDeliveredScheduler: it,
        // From UIKitConfigProvider.localConfigs
        disableUserProfile: !vt.common.enableUsingDefaultUserProfile,
        isReactionEnabled: Je && Rt(de).groupChannel.channel.enableReactions,
        isMentionEnabled: vt.groupChannel.channel.enableMention,
        isVoiceMessageEnabled: vt.groupChannel.channel.enableVoiceMessage,
        replyType: Lb(vt.groupChannel.channel.replyType).upperCase,
        isTypingIndicatorEnabledOnChannelList: vt.groupChannel.channelList.enableTypingIndicator,
        isMessageReceiptStatusEnabledOnChannelList: vt.groupChannel.channelList.enableMessageReceiptStatus,
        showSearchIcon: Je && Rt(de).groupChannel.setting.enableMessageSearch,
        // Remote configs set from dashboard by UIKit feature configuration
        groupChannel: {
          enableOgtag: Je && Rt(de).groupChannel.channel.enableOgtag,
          enableTypingIndicator: vt.groupChannel.channel.enableTypingIndicator,
          enableDocument: vt.groupChannel.channel.input.enableDocument,
          enableReactions: Je && Rt(de).groupChannel.channel.enableReactions,
          replyType: vt.groupChannel.channel.replyType,
          threadReplySelectType: Cb(vt.groupChannel.channel.threadReplySelectType).lowerCase,
          typingIndicatorTypes: vt.groupChannel.channel.typingIndicatorTypes,
          enableFeedback: vt.groupChannel.channel.enableFeedback,
          enableSuggestedReplies: vt.groupChannel.channel.enableSuggestedReplies,
          showSuggestedRepliesFor: vt.groupChannel.channel.showSuggestedRepliesFor
        },
        openChannel: {
          enableOgtag: Je && Rt(de).openChannel.channel.enableOgtag,
          enableDocument: vt.openChannel.channel.input.enableDocument
        }
      },
      eventHandlers: Se,
      emojiManager: X,
      utils: sn
    } },
    T.createElement(
      LH,
      { logger: at, breakpoint: $ },
      T.createElement(
        gH,
        { stringSet: ze, dateLocale: k },
        T.createElement(
          zw,
          null,
          T.createElement(cw, null, r)
        )
      )
    )
  );
}, nh = T.createContext({
  disableUserProfile: !0,
  isOpenChannel: !1,
  renderUserProfile: null,
  onUserProfileMessage: null
}), gw = function(e) {
  var n = e.isOpenChannel, t = n === void 0 ? !1 : n, l = e.disableUserProfile, a = l === void 0 ? !1 : l, d = e.renderUserProfile, r = d === void 0 ? null : d, i = e.onUserProfileMessage, c = i === void 0 ? null : i, V = e.children;
  return T.createElement(nh.Provider, { value: {
    isOpenChannel: t,
    disableUserProfile: a,
    renderUserProfile: r,
    onUserProfileMessage: c
  } }, V);
}, $b = 10, eY = 15, no = "@", Rd;
(function(e) {
  e.PARENT = "PARENT", e.THREAD = "THREAD";
})(Rd || (Rd = {}));
var tY = function(e, n, t) {
  var l;
  try {
    var a = e.current, d = (l = a.querySelectorAll('[data-sb-created-at="'.concat(n, '"]'))) === null || l === void 0 ? void 0 : l[0];
    d instanceof HTMLElement && (a.scrollTop = d.offsetTop);
  } catch {
  } finally {
    t == null || t(!0);
  }
}, $d = function(e, n, t) {
  e === void 0 && (e = 0);
  var l = 10, a = e;
  if (a > l) {
    t == null || t(!0);
    return;
  }
  try {
    var d = (n == null ? void 0 : n.current) || document.querySelector(".sendbird-conversation__messages-padding");
    d.scrollTop = d.scrollHeight, t == null || t(!0);
  } catch {
    setTimeout(function() {
      $d(a + 1, n, t);
    }, 500 * a);
  }
}, Iw = function(e) {
  var n = e == null ? void 0 : e.myRole;
  return n === "operator";
}, Lw = function(e) {
  var n = e == null ? void 0 : e.isFrozen;
  return n && !Iw(e);
}, Cw = function(e) {
  var n = e == null ? void 0 : e.myMutedState;
  return n === "muted";
}, Kw = function(e) {
  for (var n = e.emojiCategories, t = n === void 0 ? [] : n, l = /* @__PURE__ */ new Map(), a = 0; a < t.length; a += 1)
    for (var d = t[a].emojis, r = 0; r < d.length; r += 1) {
      var i = d[r], c = i.key, V = i.url;
      l.set(c, V);
    }
  return l;
}, _w = function(e) {
  e === void 0 && (e = []);
  for (var n = /* @__PURE__ */ new Map(), t = 0; t < e.length; t += 1) {
    var l = e[t], a = l.userId, d = l.nickname;
    n.set(a, d);
  }
  return n;
}, Pw = function(e, n) {
  var t = e.map(function(l) {
    return [l[n], l];
  });
  return Array.from(new Map(t).values());
}, Aw = function(e) {
  return Pw(e, "messageId");
}, qw = function(e) {
  return e.sort(function(n, t) {
    return n.createdAt - t.createdAt;
  });
}, $w = function(e, n) {
  var t = e[e.length - 1], l = n[0];
  if ((t == null ? void 0 : t.createdAt) < (l == null ? void 0 : l.createdAt))
    return Ut(Ut([], e, !0), n, !0);
  var a = Ut(Ut([], e, !0), n, !0), d = Aw(a);
  return qw(d);
}, EM = function(e, n) {
  if ("sendingStatus" in n && (n.sendingStatus === $t.SUCCEEDED || n.sendingStatus === $t.PENDING)) {
    var t = e.map(function(a) {
      return "sendingStatus" in a && a.sendingStatus ? a.sendingStatus : a.isAdminMessage() ? $t.SUCCEEDED : null;
    }).lastIndexOf($t.SUCCEEDED);
    if (t + 1 < e.length) {
      var l = Ut([], e, !0);
      return l.splice(t + 1, 0, n), l;
    }
  }
  return Ut(Ut([], e, !0), [n], !1);
}, pV = function(e, n, t) {
  return Math.abs(e - n) <= t;
};
function eg(e) {
  var n = e.isBroadcast, t = n === void 0 ? !1 : n, l = e.isSuper, a = l === void 0 ? !1 : l, d = e.globalLevel, r = d === void 0 ? !0 : d, i = e.moduleLevel;
  return !(t || a) && (i ?? r);
}
function TR(e) {
  "@babel/helpers - typeof";
  return TR = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
    return typeof n;
  } : function(n) {
    return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n;
  }, TR(e);
}
function Pn(e, n) {
  if (n.length < e)
    throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + n.length + " present");
}
function tg(e) {
  return Pn(1, arguments), e instanceof Date || TR(e) === "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function Wa(e) {
  Pn(1, arguments);
  var n = Object.prototype.toString.call(e);
  return e instanceof Date || TR(e) === "object" && n === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || n === "[object Number]" ? new Date(e) : ((typeof e == "string" || n === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
}
function ng(e) {
  if (Pn(1, arguments), !tg(e) && typeof e != "number")
    return !1;
  var n = Wa(e);
  return !isNaN(Number(n));
}
function xr(e) {
  if (e === null || e === !0 || e === !1)
    return NaN;
  var n = Number(e);
  return isNaN(n) ? n : n < 0 ? Math.ceil(n) : Math.floor(n);
}
function lg(e, n) {
  Pn(2, arguments);
  var t = Wa(e).getTime(), l = xr(n);
  return new Date(t + l);
}
function ag(e, n) {
  Pn(2, arguments);
  var t = xr(n);
  return lg(e, -t);
}
var dg = 864e5;
function rg(e) {
  Pn(1, arguments);
  var n = Wa(e), t = n.getTime();
  n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0);
  var l = n.getTime(), a = t - l;
  return Math.floor(a / dg) + 1;
}
function FR(e) {
  Pn(1, arguments);
  var n = 1, t = Wa(e), l = t.getUTCDay(), a = (l < n ? 7 : 0) + l - n;
  return t.setUTCDate(t.getUTCDate() - a), t.setUTCHours(0, 0, 0, 0), t;
}
function nY(e) {
  Pn(1, arguments);
  var n = Wa(e), t = n.getUTCFullYear(), l = /* @__PURE__ */ new Date(0);
  l.setUTCFullYear(t + 1, 0, 4), l.setUTCHours(0, 0, 0, 0);
  var a = FR(l), d = /* @__PURE__ */ new Date(0);
  d.setUTCFullYear(t, 0, 4), d.setUTCHours(0, 0, 0, 0);
  var r = FR(d);
  return n.getTime() >= a.getTime() ? t + 1 : n.getTime() >= r.getTime() ? t : t - 1;
}
function ig(e) {
  Pn(1, arguments);
  var n = nY(e), t = /* @__PURE__ */ new Date(0);
  t.setUTCFullYear(n, 0, 4), t.setUTCHours(0, 0, 0, 0);
  var l = FR(t);
  return l;
}
var Vg = 6048e5;
function cg(e) {
  Pn(1, arguments);
  var n = Wa(e), t = FR(n).getTime() - ig(n).getTime();
  return Math.round(t / Vg) + 1;
}
var sg = {};
function lh() {
  return sg;
}
function WR(e, n) {
  var t, l, a, d, r, i, c, V;
  Pn(1, arguments);
  var s = lh(), o = xr((t = (l = (a = (d = n == null ? void 0 : n.weekStartsOn) !== null && d !== void 0 ? d : n == null || (r = n.locale) === null || r === void 0 || (i = r.options) === null || i === void 0 ? void 0 : i.weekStartsOn) !== null && a !== void 0 ? a : s.weekStartsOn) !== null && l !== void 0 ? l : (c = s.locale) === null || c === void 0 || (V = c.options) === null || V === void 0 ? void 0 : V.weekStartsOn) !== null && t !== void 0 ? t : 0);
  if (!(o >= 0 && o <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var U = Wa(e), N = U.getUTCDay(), R = (N < o ? 7 : 0) + N - o;
  return U.setUTCDate(U.getUTCDate() - R), U.setUTCHours(0, 0, 0, 0), U;
}
function lY(e, n) {
  var t, l, a, d, r, i, c, V;
  Pn(1, arguments);
  var s = Wa(e), o = s.getUTCFullYear(), U = lh(), N = xr((t = (l = (a = (d = n == null ? void 0 : n.firstWeekContainsDate) !== null && d !== void 0 ? d : n == null || (r = n.locale) === null || r === void 0 || (i = r.options) === null || i === void 0 ? void 0 : i.firstWeekContainsDate) !== null && a !== void 0 ? a : U.firstWeekContainsDate) !== null && l !== void 0 ? l : (c = U.locale) === null || c === void 0 || (V = c.options) === null || V === void 0 ? void 0 : V.firstWeekContainsDate) !== null && t !== void 0 ? t : 1);
  if (!(N >= 1 && N <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var R = /* @__PURE__ */ new Date(0);
  R.setUTCFullYear(o + 1, 0, N), R.setUTCHours(0, 0, 0, 0);
  var h = WR(R, n), Z = /* @__PURE__ */ new Date(0);
  Z.setUTCFullYear(o, 0, N), Z.setUTCHours(0, 0, 0, 0);
  var W = WR(Z, n);
  return s.getTime() >= h.getTime() ? o + 1 : s.getTime() >= W.getTime() ? o : o - 1;
}
function og(e, n) {
  var t, l, a, d, r, i, c, V;
  Pn(1, arguments);
  var s = lh(), o = xr((t = (l = (a = (d = n == null ? void 0 : n.firstWeekContainsDate) !== null && d !== void 0 ? d : n == null || (r = n.locale) === null || r === void 0 || (i = r.options) === null || i === void 0 ? void 0 : i.firstWeekContainsDate) !== null && a !== void 0 ? a : s.firstWeekContainsDate) !== null && l !== void 0 ? l : (c = s.locale) === null || c === void 0 || (V = c.options) === null || V === void 0 ? void 0 : V.firstWeekContainsDate) !== null && t !== void 0 ? t : 1), U = lY(e, n), N = /* @__PURE__ */ new Date(0);
  N.setUTCFullYear(U, 0, o), N.setUTCHours(0, 0, 0, 0);
  var R = WR(N, n);
  return R;
}
var Ug = 6048e5;
function Ng(e, n) {
  Pn(1, arguments);
  var t = Wa(e), l = WR(t, n).getTime() - og(t, n).getTime();
  return Math.round(l / Ug) + 1;
}
function xn(e, n) {
  for (var t = e < 0 ? "-" : "", l = Math.abs(e).toString(); l.length < n; )
    l = "0" + l;
  return t + l;
}
var Rg = {
  // Year
  y: function(n, t) {
    var l = n.getUTCFullYear(), a = l > 0 ? l : 1 - l;
    return xn(t === "yy" ? a % 100 : a, t.length);
  },
  // Month
  M: function(n, t) {
    var l = n.getUTCMonth();
    return t === "M" ? String(l + 1) : xn(l + 1, 2);
  },
  // Day of the month
  d: function(n, t) {
    return xn(n.getUTCDate(), t.length);
  },
  // AM or PM
  a: function(n, t) {
    var l = n.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return l.toUpperCase();
      case "aaa":
        return l;
      case "aaaaa":
        return l[0];
      case "aaaa":
      default:
        return l === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function(n, t) {
    return xn(n.getUTCHours() % 12 || 12, t.length);
  },
  // Hour [0-23]
  H: function(n, t) {
    return xn(n.getUTCHours(), t.length);
  },
  // Minute
  m: function(n, t) {
    return xn(n.getUTCMinutes(), t.length);
  },
  // Second
  s: function(n, t) {
    return xn(n.getUTCSeconds(), t.length);
  },
  // Fraction of second
  S: function(n, t) {
    var l = t.length, a = n.getUTCMilliseconds(), d = Math.floor(a * Math.pow(10, l - 3));
    return xn(d, t.length);
  }
}, fr = Rg, LV = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, hg = {
  // Era
  G: function(n, t, l) {
    var a = n.getUTCFullYear() > 0 ? 1 : 0;
    switch (t) {
      case "G":
      case "GG":
      case "GGG":
        return l.era(a, {
          width: "abbreviated"
        });
      case "GGGGG":
        return l.era(a, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return l.era(a, {
          width: "wide"
        });
    }
  },
  // Year
  y: function(n, t, l) {
    if (t === "yo") {
      var a = n.getUTCFullYear(), d = a > 0 ? a : 1 - a;
      return l.ordinalNumber(d, {
        unit: "year"
      });
    }
    return fr.y(n, t);
  },
  // Local week-numbering year
  Y: function(n, t, l, a) {
    var d = lY(n, a), r = d > 0 ? d : 1 - d;
    if (t === "YY") {
      var i = r % 100;
      return xn(i, 2);
    }
    return t === "Yo" ? l.ordinalNumber(r, {
      unit: "year"
    }) : xn(r, t.length);
  },
  // ISO week-numbering year
  R: function(n, t) {
    var l = nY(n);
    return xn(l, t.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(n, t) {
    var l = n.getUTCFullYear();
    return xn(l, t.length);
  },
  // Quarter
  Q: function(n, t, l) {
    var a = Math.ceil((n.getUTCMonth() + 1) / 3);
    switch (t) {
      case "Q":
        return String(a);
      case "QQ":
        return xn(a, 2);
      case "Qo":
        return l.ordinalNumber(a, {
          unit: "quarter"
        });
      case "QQQ":
        return l.quarter(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return l.quarter(a, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return l.quarter(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(n, t, l) {
    var a = Math.ceil((n.getUTCMonth() + 1) / 3);
    switch (t) {
      case "q":
        return String(a);
      case "qq":
        return xn(a, 2);
      case "qo":
        return l.ordinalNumber(a, {
          unit: "quarter"
        });
      case "qqq":
        return l.quarter(a, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return l.quarter(a, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return l.quarter(a, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(n, t, l) {
    var a = n.getUTCMonth();
    switch (t) {
      case "M":
      case "MM":
        return fr.M(n, t);
      case "Mo":
        return l.ordinalNumber(a + 1, {
          unit: "month"
        });
      case "MMM":
        return l.month(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return l.month(a, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return l.month(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function(n, t, l) {
    var a = n.getUTCMonth();
    switch (t) {
      case "L":
        return String(a + 1);
      case "LL":
        return xn(a + 1, 2);
      case "Lo":
        return l.ordinalNumber(a + 1, {
          unit: "month"
        });
      case "LLL":
        return l.month(a, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return l.month(a, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return l.month(a, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function(n, t, l, a) {
    var d = Ng(n, a);
    return t === "wo" ? l.ordinalNumber(d, {
      unit: "week"
    }) : xn(d, t.length);
  },
  // ISO week of year
  I: function(n, t, l) {
    var a = cg(n);
    return t === "Io" ? l.ordinalNumber(a, {
      unit: "week"
    }) : xn(a, t.length);
  },
  // Day of the month
  d: function(n, t, l) {
    return t === "do" ? l.ordinalNumber(n.getUTCDate(), {
      unit: "date"
    }) : fr.d(n, t);
  },
  // Day of year
  D: function(n, t, l) {
    var a = rg(n);
    return t === "Do" ? l.ordinalNumber(a, {
      unit: "dayOfYear"
    }) : xn(a, t.length);
  },
  // Day of week
  E: function(n, t, l) {
    var a = n.getUTCDay();
    switch (t) {
      case "E":
      case "EE":
      case "EEE":
        return l.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return l.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return l.day(a, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return l.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(n, t, l, a) {
    var d = n.getUTCDay(), r = (d - a.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "e":
        return String(r);
      case "ee":
        return xn(r, 2);
      case "eo":
        return l.ordinalNumber(r, {
          unit: "day"
        });
      case "eee":
        return l.day(d, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return l.day(d, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return l.day(d, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return l.day(d, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(n, t, l, a) {
    var d = n.getUTCDay(), r = (d - a.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "c":
        return String(r);
      case "cc":
        return xn(r, t.length);
      case "co":
        return l.ordinalNumber(r, {
          unit: "day"
        });
      case "ccc":
        return l.day(d, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return l.day(d, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return l.day(d, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return l.day(d, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(n, t, l) {
    var a = n.getUTCDay(), d = a === 0 ? 7 : a;
    switch (t) {
      case "i":
        return String(d);
      case "ii":
        return xn(d, t.length);
      case "io":
        return l.ordinalNumber(d, {
          unit: "day"
        });
      case "iii":
        return l.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return l.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return l.day(a, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return l.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(n, t, l) {
    var a = n.getUTCHours(), d = a / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return l.dayPeriod(d, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return l.dayPeriod(d, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return l.dayPeriod(d, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return l.dayPeriod(d, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(n, t, l) {
    var a = n.getUTCHours(), d;
    switch (a === 12 ? d = LV.noon : a === 0 ? d = LV.midnight : d = a / 12 >= 1 ? "pm" : "am", t) {
      case "b":
      case "bb":
        return l.dayPeriod(d, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return l.dayPeriod(d, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return l.dayPeriod(d, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return l.dayPeriod(d, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(n, t, l) {
    var a = n.getUTCHours(), d;
    switch (a >= 17 ? d = LV.evening : a >= 12 ? d = LV.afternoon : a >= 4 ? d = LV.morning : d = LV.night, t) {
      case "B":
      case "BB":
      case "BBB":
        return l.dayPeriod(d, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return l.dayPeriod(d, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return l.dayPeriod(d, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(n, t, l) {
    if (t === "ho") {
      var a = n.getUTCHours() % 12;
      return a === 0 && (a = 12), l.ordinalNumber(a, {
        unit: "hour"
      });
    }
    return fr.h(n, t);
  },
  // Hour [0-23]
  H: function(n, t, l) {
    return t === "Ho" ? l.ordinalNumber(n.getUTCHours(), {
      unit: "hour"
    }) : fr.H(n, t);
  },
  // Hour [0-11]
  K: function(n, t, l) {
    var a = n.getUTCHours() % 12;
    return t === "Ko" ? l.ordinalNumber(a, {
      unit: "hour"
    }) : xn(a, t.length);
  },
  // Hour [1-24]
  k: function(n, t, l) {
    var a = n.getUTCHours();
    return a === 0 && (a = 24), t === "ko" ? l.ordinalNumber(a, {
      unit: "hour"
    }) : xn(a, t.length);
  },
  // Minute
  m: function(n, t, l) {
    return t === "mo" ? l.ordinalNumber(n.getUTCMinutes(), {
      unit: "minute"
    }) : fr.m(n, t);
  },
  // Second
  s: function(n, t, l) {
    return t === "so" ? l.ordinalNumber(n.getUTCSeconds(), {
      unit: "second"
    }) : fr.s(n, t);
  },
  // Fraction of second
  S: function(n, t) {
    return fr.S(n, t);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(n, t, l, a) {
    var d = a._originalDate || n, r = d.getTimezoneOffset();
    if (r === 0)
      return "Z";
    switch (t) {
      case "X":
        return kM(r);
      case "XXXX":
      case "XX":
        return ji(r);
      case "XXXXX":
      case "XXX":
      default:
        return ji(r, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(n, t, l, a) {
    var d = a._originalDate || n, r = d.getTimezoneOffset();
    switch (t) {
      case "x":
        return kM(r);
      case "xxxx":
      case "xx":
        return ji(r);
      case "xxxxx":
      case "xxx":
      default:
        return ji(r, ":");
    }
  },
  // Timezone (GMT)
  O: function(n, t, l, a) {
    var d = a._originalDate || n, r = d.getTimezoneOffset();
    switch (t) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + SM(r, ":");
      case "OOOO":
      default:
        return "GMT" + ji(r, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(n, t, l, a) {
    var d = a._originalDate || n, r = d.getTimezoneOffset();
    switch (t) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + SM(r, ":");
      case "zzzz":
      default:
        return "GMT" + ji(r, ":");
    }
  },
  // Seconds timestamp
  t: function(n, t, l, a) {
    var d = a._originalDate || n, r = Math.floor(d.getTime() / 1e3);
    return xn(r, t.length);
  },
  // Milliseconds timestamp
  T: function(n, t, l, a) {
    var d = a._originalDate || n, r = d.getTime();
    return xn(r, t.length);
  }
};
function SM(e, n) {
  var t = e > 0 ? "-" : "+", l = Math.abs(e), a = Math.floor(l / 60), d = l % 60;
  if (d === 0)
    return t + String(a);
  var r = n || "";
  return t + String(a) + r + xn(d, 2);
}
function kM(e, n) {
  if (e % 60 === 0) {
    var t = e > 0 ? "-" : "+";
    return t + xn(Math.abs(e) / 60, 2);
  }
  return ji(e, n);
}
function ji(e, n) {
  var t = n || "", l = e > 0 ? "-" : "+", a = Math.abs(e), d = xn(Math.floor(a / 60), 2), r = xn(a % 60, 2);
  return l + d + t + r;
}
var bM = function(n, t) {
  switch (n) {
    case "P":
      return t.date({
        width: "short"
      });
    case "PP":
      return t.date({
        width: "medium"
      });
    case "PPP":
      return t.date({
        width: "long"
      });
    case "PPPP":
    default:
      return t.date({
        width: "full"
      });
  }
}, aY = function(n, t) {
  switch (n) {
    case "p":
      return t.time({
        width: "short"
      });
    case "pp":
      return t.time({
        width: "medium"
      });
    case "ppp":
      return t.time({
        width: "long"
      });
    case "pppp":
    default:
      return t.time({
        width: "full"
      });
  }
}, Zg = function(n, t) {
  var l = n.match(/(P+)(p+)?/) || [], a = l[1], d = l[2];
  if (!d)
    return bM(n, t);
  var r;
  switch (a) {
    case "P":
      r = t.dateTime({
        width: "short"
      });
      break;
    case "PP":
      r = t.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      r = t.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      r = t.dateTime({
        width: "full"
      });
      break;
  }
  return r.replace("{{date}}", bM(a, t)).replace("{{time}}", aY(d, t));
}, Tg = {
  p: aY,
  P: Zg
};
function Fg(e) {
  var n = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
  return n.setUTCFullYear(e.getFullYear()), e.getTime() - n.getTime();
}
var Wg = ["D", "DD"], mg = ["YY", "YYYY"];
function ug(e) {
  return Wg.indexOf(e) !== -1;
}
function pg(e) {
  return mg.indexOf(e) !== -1;
}
function YM(e, n, t) {
  if (e === "YYYY")
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(n, "`) for formatting years to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "YY")
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(n, "`) for formatting years to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "D")
    throw new RangeError("Use `d` instead of `D` (in `".concat(n, "`) for formatting days of the month to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "DD")
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(n, "`) for formatting days of the month to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
}
var Mg = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, Eg = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Sg = /^'([^]*?)'?$/, kg = /''/g, bg = /[a-zA-Z]/;
function Sr(e, n, t) {
  var l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E;
  Pn(2, arguments);
  var u = String(n), b = lh(), k = (l = (a = t == null ? void 0 : t.locale) !== null && a !== void 0 ? a : b.locale) !== null && l !== void 0 ? l : Ob, Q = xr((d = (r = (i = (c = t == null ? void 0 : t.firstWeekContainsDate) !== null && c !== void 0 ? c : t == null || (V = t.locale) === null || V === void 0 || (s = V.options) === null || s === void 0 ? void 0 : s.firstWeekContainsDate) !== null && i !== void 0 ? i : b.firstWeekContainsDate) !== null && r !== void 0 ? r : (o = b.locale) === null || o === void 0 || (U = o.options) === null || U === void 0 ? void 0 : U.firstWeekContainsDate) !== null && d !== void 0 ? d : 1);
  if (!(Q >= 1 && Q <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var S = xr((N = (R = (h = (Z = t == null ? void 0 : t.weekStartsOn) !== null && Z !== void 0 ? Z : t == null || (W = t.locale) === null || W === void 0 || (F = W.options) === null || F === void 0 ? void 0 : F.weekStartsOn) !== null && h !== void 0 ? h : b.weekStartsOn) !== null && R !== void 0 ? R : (m = b.locale) === null || m === void 0 || (E = m.options) === null || E === void 0 ? void 0 : E.weekStartsOn) !== null && N !== void 0 ? N : 0);
  if (!(S >= 0 && S <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if (!k.localize)
    throw new RangeError("locale must contain localize property");
  if (!k.formatLong)
    throw new RangeError("locale must contain formatLong property");
  var v = Wa(e);
  if (!ng(v))
    throw new RangeError("Invalid time value");
  var G = Fg(v), w = ag(v, G), y = {
    firstWeekContainsDate: Q,
    weekStartsOn: S,
    locale: k,
    _originalDate: v
  }, g = u.match(Eg).map(function(f) {
    var I = f[0];
    if (I === "p" || I === "P") {
      var K = Tg[I];
      return K(f, k.formatLong);
    }
    return f;
  }).join("").match(Mg).map(function(f) {
    if (f === "''")
      return "'";
    var I = f[0];
    if (I === "'")
      return Yg(f);
    var K = hg[I];
    if (K)
      return !(t != null && t.useAdditionalWeekYearTokens) && pg(f) && YM(f, n, String(e)), !(t != null && t.useAdditionalDayOfYearTokens) && ug(f) && YM(f, n, String(e)), K(w, f, k.localize, y);
    if (I.match(bg))
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + I + "`");
    return f;
  }).join("");
  return g;
}
function Yg(e) {
  var n = e.match(Sg);
  return n ? n[1].replace(kg, "'") : e;
}
var fW = "RESET_MESSAGES", ah = "FETCH_INITIAL_MESSAGES_START", dh = "FETCH_INITIAL_MESSAGES_SUCCESS", bo = "FETCH_INITIAL_MESSAGES_FAILURE", wW = "FETCH_PREV_MESSAGES_SUCCESS", gW = "FETCH_PREV_MESSAGES_FAILURE", IW = "FETCH_NEXT_MESSAGES_SUCCESS", LW = "FETCH_NEXT_MESSAGES_FAILURE", CW = "SEND_MESSAGE_START", _d = "SEND_MESSAGE_SUCCESS", kr = "SEND_MESSAGE_FAILURE", lo = "RESEND_MESSAGE_START", KW = "ON_MESSAGE_RECEIVED", dU = "ON_MESSAGE_UPDATED", _W = "ON_MESSAGE_THREAD_INFO_UPDATED", rU = "ON_MESSAGE_DELETED", PW = "ON_MESSAGE_DELETED_BY_REQ_ID", ba = "SET_CURRENT_CHANNEL", AW = "SET_CHANNEL_INVALID", dY = "MARK_AS_READ", qW = "ON_REACTION_UPDATED", $W = "SET_EMOJI_CONTAINER", e1 = "MESSAGE_LIST_PARAMS_CHANGED", t1 = "ON_FILE_INFO_UPLOADED", n1 = "ON_TYPING_STATUS_UPDATED", Qg = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  FETCH_INITIAL_MESSAGES_FAILURE: bo,
  FETCH_INITIAL_MESSAGES_START: ah,
  FETCH_INITIAL_MESSAGES_SUCCESS: dh,
  FETCH_NEXT_MESSAGES_FAILURE: LW,
  FETCH_NEXT_MESSAGES_SUCCESS: IW,
  FETCH_PREV_MESSAGES_FAILURE: gW,
  FETCH_PREV_MESSAGES_SUCCESS: wW,
  MARK_AS_READ: dY,
  MESSAGE_LIST_PARAMS_CHANGED: e1,
  ON_FILE_INFO_UPLOADED: t1,
  ON_MESSAGE_DELETED: rU,
  ON_MESSAGE_DELETED_BY_REQ_ID: PW,
  ON_MESSAGE_RECEIVED: KW,
  ON_MESSAGE_THREAD_INFO_UPDATED: _W,
  ON_MESSAGE_UPDATED: dU,
  ON_REACTION_UPDATED: qW,
  ON_TYPING_STATUS_UPDATED: n1,
  RESEND_MESSAGE_START: lo,
  RESET_MESSAGES: fW,
  SEND_MESSAGE_FAILURE: kr,
  SEND_MESSAGE_START: CW,
  SEND_MESSAGE_SUCCESS: _d,
  SET_CHANNEL_INVALID: AW,
  SET_CURRENT_CHANNEL: ba,
  SET_EMOJI_CONTAINER: $W
}), QM = function(e) {
  return e == null;
};
function mn(e, n) {
  if (QM(e) || QM(n))
    return !1;
  var t = e.toString(), l = n.toString();
  return t === l;
}
var rh = 30, ih = 15;
function Jg(e, n) {
  var t = e.currentGroupChannel, l = e.initialTimeStamp, a = e.userFilledMessageListQuery, d = e.replyType, r = e.setIsScrolled, i = n.logger, c = n.scrollRef, V = n.messagesDispatcher, s = t == null ? void 0 : t.url, o = Pt(function() {
    if (i.info("Channel useInitialMessagesFetch: Setup started", t), r(!1), V({
      type: fW,
      payload: null
    }), t && (t != null && t.getMessagesByTimestamp)) {
      var U = {
        prevResultSize: rh,
        isInclusive: !0,
        includeReactions: !0,
        includeMetaArray: !0
      };
      l && (U.nextResultSize = ih), (d === "QUOTE_REPLY" || d === "THREAD") && (U.includeThreadInfo = !0, U.includeParentMessageInfo = !0, U.replyType = al.ONLY_REPLY_TO_CHANNEL), a && Object.keys(a).forEach(function(N) {
        U[N] = a[N];
      }), (d && (d === "QUOTE_REPLY" || d === "THREAD") || a) && (i.info("Channel useInitialMessagesFetch: Setup messageListParams", U), V({
        type: e1,
        payload: U
      })), i.info("Channel: Fetching messages", { currentGroupChannel: t, userFilledMessageListQuery: a }), V({
        type: ah,
        payload: null
      }), t.getMessagesByTimestamp(l || (/* @__PURE__ */ new Date()).getTime(), U).then(function(N) {
        V({
          type: dh,
          payload: {
            currentGroupChannel: t,
            messages: N
          }
        });
      }).catch(function(N) {
        i.error("Channel: Fetching messages failed", N), V({
          type: bo,
          payload: { currentGroupChannel: t }
        });
      }).finally(function() {
        l ? setTimeout(function() {
          tY(c, l, r);
        }, 500) : setTimeout(function() {
          return $d(0, c, r);
        }, zb);
      });
    }
  }, [s, a, l]);
  return _e(function() {
    o();
  }, [o]), o;
}
function vg(e, n, t) {
  t === void 0 && (t = !0);
  var l = me(!1), a = l[0], d = l[1], r = !e;
  _e(function() {
    var c = function() {
      t && d(document.hidden);
    };
    return document.addEventListener("visibilitychange", c), function() {
      document.removeEventListener("visibilitychange", c);
    };
  }, [t, document.hidden]);
  var i = r && (n == null ? void 0 : n.url) != null && !a;
  return { shouldReconnect: i };
}
var er;
(function(e) {
  e.CHANNEL = "CHANNEL", e.THREAD = "THREAD";
})(er || (er = {}));
var rY = function(e, n) {
  return !n || n.length === 0 ? !0 : n.includes(e);
};
function xN(e) {
  return rY(er.CHANNEL, e);
}
function zg(e) {
  return rY(er.THREAD, e);
}
var Gl;
(function(e) {
  e.USER_UPDATED = "USER_UPDATED", e.SEND_MESSAGE_START = "SEND_MESSAGE_START", e.SEND_MESSAGE_FAILED = "SEND_MESSAGE_FAILED", e.SEND_USER_MESSAGE = "SEND_USER_MESSAGE", e.SEND_FILE_MESSAGE = "SEND_FILE_MESSAGE", e.ON_FILE_INFO_UPLOADED = "ON_FILE_INFO_UPLOADED", e.UPDATE_USER_MESSAGE = "UPDATE_USER_MESSAGE", e.DELETE_MESSAGE = "DELETE_MESSAGE", e.LEAVE_CHANNEL = "LEAVE_CHANNEL", e.CREATE_CHANNEL = "CREATE_CHANNEL", e.UPDATE_OPEN_CHANNEL = "UPDATE_OPEN_CHANNEL";
})(Gl || (Gl = {}));
var Xa = Gl, cs = "useToggleReactionCallback:";
function xg(e, n) {
  return Pt(function(t, l, a) {
    if (!e) {
      n.warning("".concat(cs, " currentChannel doesn't exist"), e);
      return;
    }
    a ? e.deleteReaction(t, l).then(function(d) {
      n.info("".concat(cs, " Delete reaction success"), d);
    }).catch(function(d) {
      n.warning("".concat(cs, " Delete reaction failed"), d);
    }) : e.addReaction(t, l).then(function(d) {
      n.info("".concat(cs, " Add reaction success"), d);
    }).catch(function(d) {
      n.warning("".concat(cs, " Add reaction failed"), d);
    });
  }, [e]);
}
var iY = function(e) {
  e === void 0 && (e = 0);
  var n = 10, t = e;
  if (!(t > n))
    try {
      var l = document.querySelector(".sendbird-thread-ui--scroll");
      l.scrollTop = l.scrollHeight;
    } catch {
      setTimeout(function() {
        iY(t + 1);
      }, 500 * t);
    }
}, Gg = function(e, n) {
  var t = e.currentChannel, l = e.onBeforeSendMultipleFilesMessage, a = e.publishingModules, d = n.logger, r = n.pubSub, i = n.scrollRef, c = Pt(function(V, s) {
    return new Promise(function(o, U) {
      t || (d.warning("Channel: Sending MFm failed, because currentChannel is null.", { currentChannel: t }), U()), V.length <= 1 && (d.warning("Channel: Sending MFM failed, because there are no multiple files.", { files: V }), U());
      var N = {
        fileInfoList: V.map(function(R) {
          return {
            file: R,
            fileName: R.name,
            fileSize: R.size,
            mimeType: R.type
          };
        })
      };
      s && (N.isReplyToChannel = !0, N.parentMessageId = s.messageId), typeof l == "function" && (N = l(V, s)), d.info("Channel: Start sending MFM", { messageParams: N });
      try {
        t.sendMultipleFilesMessage(N).onFileUploaded(function(R, h, Z, W) {
          d.info("Channel: onFileUploaded during sending MFM", {
            requestId: R,
            index: h,
            error: W,
            uploadableFileInfo: Z
          }), r.publish(Xa.ON_FILE_INFO_UPLOADED, {
            response: {
              channelUrl: t.url,
              requestId: R,
              index: h,
              uploadableFileInfo: Z,
              error: W
            },
            publishingModules: a
          });
        }).onPending(function(R) {
          d.info("Channel: in progress of sending MFM", { pendingMessage: R, fileInfoList: N.fileInfoList }), r.publish(Xa.SEND_MESSAGE_START, {
            message: R,
            channel: t,
            publishingModules: a
          }), setTimeout(function() {
            i && xN(a) && $d(0, i), zg(a) && iY(0);
          }, vc);
        }).onFailed(function(R, h) {
          d.error("Channel: Sending MFM failed.", { error: R, failedMessage: h }), r.publish(Xa.SEND_MESSAGE_FAILED, {
            channel: t,
            message: h,
            publishingModules: a
          }), U(R);
        }).onSucceeded(function(R) {
          d.info("Channel: Sending voice message success!", { succeededMessage: R }), r.publish(Xa.SEND_FILE_MESSAGE, {
            channel: t,
            message: R,
            publishingModules: a
          }), o(R);
        });
      } catch (R) {
        d.error("Channel: Sending MFM failed.", { error: R }), U(R);
      }
    });
  }, [
    t,
    l,
    a
  ]);
  return [c];
}, yg = {
  initialized: !1,
  loading: !0,
  allMessages: [],
  /**
   * localMessages: pending & failed messages
   */
  localMessages: [],
  currentGroupChannel: null,
  // for scrollup
  hasMorePrev: !1,
  oldestMessageTimeStamp: 0,
  // for scroll down
  // onScrollDownCallback is added for navigation to different timestamps on messageSearch
  // hasMorePrev, onScrollCallback -> scroll up(default behavior)
  // hasMoreNext, onScrollDownCallback -> scroll down
  hasMoreNext: !1,
  latestMessageTimeStamp: 0,
  emojiContainer: { emojiCategories: [], emojiHash: "" },
  /** @deprecated Please use `unreadSinceDate` instead. * */
  unreadSince: null,
  /**
   * unreadSinceDate is a date information about message unread.
   * It's used only for the {unreadSinceDate && <UnreadCount unreadSinceDate={unreadSinceDate} />}
   */
  unreadSinceDate: null,
  isInvalid: !1,
  readStatus: null,
  messageListParams: null,
  typingMembers: []
}, JM = function(e) {
  e === void 0 && (e = []);
  var n = e[0];
  return n && n.createdAt || null;
}, vM = function(e) {
  e === void 0 && (e = []);
  var n = e[e.length - 1];
  return n && n.createdAt || null;
};
function CV(e) {
  return "reqId" in e;
}
function Bg(e, n) {
  return Va(n).with({ type: fW }, function() {
    return ce(ce({}, e), {
      // when user switches channel, if the previous channel `hasMorePrev`
      // the onScroll gets called twice, setting hasMorePrev false prevents this
      hasMorePrev: !1,
      hasMoreNext: !1,
      allMessages: [],
      localMessages: []
    });
  }).with({ type: ah }, function() {
    return ce(ce({}, e), { loading: !0, allMessages: e.allMessages.filter(function(t) {
      return th(t) ? t.sendingStatus !== $t.SUCCEEDED : !0;
    }), localMessages: [] });
  }).with({ type: dh }, function(t) {
    var l, a = t.payload, d = a.currentGroupChannel, r = a.messages;
    if ((d == null ? void 0 : d.url) !== ((l = e.currentGroupChannel) === null || l === void 0 ? void 0 : l.url))
      return e;
    var i = JM(r), c = vM(r);
    return ce(ce({}, e), { loading: !1, initialized: !0, hasMorePrev: !0, hasMoreNext: !0, oldestMessageTimeStamp: i, latestMessageTimeStamp: c, allMessages: Ut([], r, !0) });
  }).with({ type: wW }, function(t) {
    var l, a, d, r, i = t.payload, c = i.currentGroupChannel, V = i.messages;
    if ((c == null ? void 0 : c.url) !== ((l = e.currentGroupChannel) === null || l === void 0 ? void 0 : l.url))
      return e;
    var s = ((a = V == null ? void 0 : V.length) !== null && a !== void 0 ? a : 0) >= ((r = (d = e == null ? void 0 : e.messageListParams) === null || d === void 0 ? void 0 : d.prevResultSize) !== null && r !== void 0 ? r : rh) + 1, o = JM(V), U = [], N = e.allMessages.map(function(h) {
      var Z = V.find(function(W) {
        var F = W.messageId;
        return mn(F, h.messageId);
      });
      return Z ? (U.push(Z.messageId), Z.updatedAt > h.updatedAt ? Z : h) : h;
    }), R = U.length > 0 ? V.filter(function(h) {
      return !U.find(function(Z) {
        return mn(Z, h.messageId);
      });
    }) : V;
    return ce(ce({}, e), { hasMorePrev: s, oldestMessageTimeStamp: o, allMessages: Ut(Ut([], R, !0), N, !0) });
  }).with({ type: IW }, function(t) {
    var l, a, d, r, i = t.payload, c = i.currentGroupChannel, V = i.messages;
    if ((c == null ? void 0 : c.url) !== ((l = e.currentGroupChannel) === null || l === void 0 ? void 0 : l.url))
      return e;
    var s = ((a = V == null ? void 0 : V.length) !== null && a !== void 0 ? a : 0) === ((r = (d = e == null ? void 0 : e.messageListParams) === null || d === void 0 ? void 0 : d.nextResultSize) !== null && r !== void 0 ? r : ih) + 1, o = vM(V), U = $w(e.allMessages, V);
    return ce(ce({}, e), { hasMoreNext: s, latestMessageTimeStamp: o, allMessages: U });
  }).with({
    type: rj.union(bo, gW, LW)
  }, function(t) {
    var l, a = t.payload.currentGroupChannel;
    if ((a == null ? void 0 : a.url) !== ((l = e == null ? void 0 : e.currentGroupChannel) === null || l === void 0 ? void 0 : l.url))
      return e;
    var d = [bo].includes(t.type);
    return ce(ce({}, e), { loading: !1, isInvalid: d, initialized: !1, allMessages: [], hasMorePrev: !1, hasMoreNext: !1, oldestMessageTimeStamp: null, latestMessageTimeStamp: null });
  }).with({ type: CW }, function(t) {
    return ce(ce({}, e), { localMessages: Ut(Ut([], e.localMessages, !0), [t.payload], !1) });
  }).with({ type: _d }, function(t) {
    var l = t.payload, a = e.allMessages.filter(function(d) {
      return !CV(d) || (d == null ? void 0 : d.reqId) !== (l == null ? void 0 : l.reqId);
    });
    return ce(ce({}, e), { allMessages: Ut(Ut([], a, !0), [l], !1), localMessages: e.localMessages.filter(function(d) {
      return CV(d) && (d == null ? void 0 : d.reqId) !== (l == null ? void 0 : l.reqId);
    }) });
  }).with({ type: kr }, function(t) {
    return t.payload.failed = !0, ce(ce({}, e), { localMessages: e.localMessages.map(function(l) {
      return mn(CV(l) && l.reqId, t.payload.reqId) ? t.payload : l;
    }) });
  }).with({ type: ba }, function(t) {
    return ce(ce({}, e), { currentGroupChannel: t.payload, isInvalid: !1 });
  }).with({ type: AW }, function() {
    return ce(ce({}, e), { currentGroupChannel: null, allMessages: [], localMessages: [], isInvalid: !0 });
  }).with({ type: KW }, function(t) {
    var l, a, d = t.payload, r = d.channel, i = d.message, c = r.members, V = i.sender, s = e.currentGroupChannel, o = s == null ? void 0 : s.url;
    if (!mn(r == null ? void 0 : r.url, o) || e.allMessages.some(function(N) {
      return N.messageId === i.messageId;
    }) || e.messageListParams && !rp(e.messageListParams, i))
      return e;
    if (i.isAdminMessage && i.isAdminMessage())
      return ce(ce({}, e), { allMessages: EM(e.allMessages, i) });
    var U = c == null ? void 0 : c.find(function(N) {
      return (N == null ? void 0 : N.userId) === (V == null ? void 0 : V.userId);
    });
    return ((U == null ? void 0 : U.profileUrl) !== (V == null ? void 0 : V.profileUrl) || (U == null ? void 0 : U.friendName) !== (V == null ? void 0 : V.friendName) || (U == null ? void 0 : U.nickname) !== (V == null ? void 0 : V.nickname)) && (r.members = c.map(function(N) {
      return N.userId === V.userId ? V : N;
    })), ce(ce({}, e), { currentGroupChannel: r, unreadSince: (l = e.unreadSince) !== null && l !== void 0 ? l : Sr(/* @__PURE__ */ new Date(), "p MMM dd"), unreadSinceDate: (a = e.unreadSinceDate) !== null && a !== void 0 ? a : /* @__PURE__ */ new Date(), allMessages: EM(e.allMessages, i) });
  }).with({ type: dU }, function(t) {
    var l, a = t.payload, d = a.channel, r = a.message, i = ((l = e == null ? void 0 : e.currentGroupChannel) === null || l === void 0 ? void 0 : l.url) || "";
    return mn(d == null ? void 0 : d.url, i) ? e.messageListParams && !rp(e.messageListParams, r) ? ce(ce({}, e), { allMessages: e.allMessages.filter(function(c) {
      return !mn(c.messageId, r == null ? void 0 : r.messageId);
    }) }) : ce(ce({}, e), { allMessages: e.allMessages.map(function(c) {
      return mn(c.messageId, r.messageId) ? r : (mn(c.parentMessageId, r.messageId) && (c.parentMessage = r), c);
    }) }) : e;
  }).with({ type: _W }, function(t) {
    var l, a = t.payload, d = a.channel, r = a.event, i = r.channelUrl, c = r.threadInfo, V = r.targetMessageId, s = ((l = e == null ? void 0 : e.currentGroupChannel) === null || l === void 0 ? void 0 : l.url) || "";
    return !mn(d == null ? void 0 : d.url, s) || !mn(d == null ? void 0 : d.url, i) ? e : ce(ce({}, e), { allMessages: e.allMessages.map(function(o) {
      return mn(o.messageId, V) && (o.threadInfo = c), o;
    }) });
  }).with({ type: lo }, function(t) {
    return ce(ce({}, e), { localMessages: e.localMessages.map(function(l) {
      return mn(CV(l) && l.reqId, t.payload.reqId) ? t.payload : l;
    }) });
  }).with({ type: dY }, function(t) {
    var l, a, d;
    return ((l = e.currentGroupChannel) === null || l === void 0 ? void 0 : l.url) !== ((d = (a = t.payload) === null || a === void 0 ? void 0 : a.channel) === null || d === void 0 ? void 0 : d.url) ? e : ce(ce({}, e), { unreadSince: null, unreadSinceDate: null });
  }).with({ type: rU }, function(t) {
    return ce(ce({}, e), { allMessages: e.allMessages.filter(function(l) {
      return !mn(l.messageId, t.payload);
    }) });
  }).with({ type: PW }, function(t) {
    return ce(ce({}, e), { localMessages: e.localMessages.filter(function(l) {
      return !mn(CV(l) && l.reqId, t.payload);
    }) });
  }).with({ type: $W }, function(t) {
    return ce(ce({}, e), { emojiContainer: t.payload });
  }).with({ type: qW }, function(t) {
    return ce(ce({}, e), { allMessages: e.allMessages.map(function(l) {
      return mn(l.messageId, t.payload.messageId) && l.applyReactionEvent && typeof l.applyReactionEvent == "function" && l.applyReactionEvent(t.payload), l;
    }) });
  }).with({ type: e1 }, function(t) {
    return ce(ce({}, e), { messageListParams: t.payload });
  }).with({ type: t1 }, function(t) {
    var l, a, d = t.payload, r = d.channelUrl, i = d.requestId, c = d.index, V = d.uploadableFileInfo, s = d.error;
    if (!mn(r, (l = e == null ? void 0 : e.currentGroupChannel) === null || l === void 0 ? void 0 : l.url) || s)
      return e;
    var o = e.localMessages, U = o.find(function(R) {
      return mn(CV(R) && R.reqId, i);
    }), N = (a = U.messageParams) === null || a === void 0 ? void 0 : a.fileInfoList;
    return Array.isArray(N) && (N[c] = V), ce(ce({}, e), { localMessages: o });
  }).with({ type: n1 }, function(t) {
    var l, a = t.payload, d = a.channel, r = a.typingMembers;
    return mn(d.url, (l = e == null ? void 0 : e.currentGroupChannel) === null || l === void 0 ? void 0 : l.url) ? ce(ce({}, e), { typingMembers: r }) : e;
  }).otherwise(function() {
    return e;
  });
}
var Dg = "delivery_receipt";
function Xg(e, n) {
  var t, l, a, d = e.sdkInit, r = e.currentGroupChannel, i = e.disableMarkAsRead, c = n.sdk, V = n.logger, s = n.scrollRef, o = n.setQuoteMessage, U = n.messagesDispatcher, N = zn(), R = N.config, h = R.markAsReadScheduler, Z = R.markAsDeliveredScheduler, W = R.disableMarkAsDelivered, F = (a = (l = (t = N.stores.sdkStore.sdk) === null || t === void 0 ? void 0 : t.appInfo) === null || l === void 0 ? void 0 : l.premiumFeatureList) === null || a === void 0 ? void 0 : a.find(function(m) {
    return m === Dg;
  });
  _e(function() {
    var m, E = r == null ? void 0 : r.url, u = zr();
    if (E && d) {
      var b = {
        onMessageReceived: function(k, Q) {
          var S, v;
          if (k.isGroupChannel() && mn(k == null ? void 0 : k.url, E)) {
            var G = !1;
            try {
              var w = s.current;
              G = w.offsetHeight + w.scrollTop >= w.scrollHeight - 10;
            } catch {
            }
            if (V.info("Channel | useHandleChannelEvents: onMessageReceived", Q), U({
              type: KW,
              payload: { channel: k, message: Q }
            }), G && ((S = document.getElementById("sendbird-dropdown-portal")) === null || S === void 0 ? void 0 : S.childElementCount) === 0 && ((v = document.getElementById("sendbird-emoji-list-portal")) === null || v === void 0 ? void 0 : v.childElementCount) === 0)
              try {
                setTimeout(function() {
                  return $d(0, s);
                }), i || h.push(r), F && !W && Z.push(r);
              } catch {
                V.warning("Channel | onMessageReceived | scroll to end failed");
              }
          }
        },
        onUnreadMemberStatusUpdated: function(k) {
          V.info("Channel | useHandleChannelEvents: onUnreadMemberStatusUpdated", k), mn(k == null ? void 0 : k.url, E) && U({
            type: ba,
            payload: k
          });
        },
        // before(onDeliveryReceiptUpdated)
        onUndeliveredMemberStatusUpdated: function(k) {
          mn(k == null ? void 0 : k.url, E) && (V.info("Channel | useHandleChannelEvents: onDeliveryReceiptUpdated", k), U({
            type: ba,
            payload: k
          }));
        },
        onMessageUpdated: function(k, Q) {
          k.isGroupChannel() && mn(k == null ? void 0 : k.url, E) && (V.info("Channel | useHandleChannelEvents: onMessageUpdated", Q), U({
            type: dU,
            payload: { channel: k, message: Q }
          }));
        },
        onThreadInfoUpdated: function(k, Q) {
          k.isGroupChannel() && mn(k == null ? void 0 : k.url, E) && (V.info("Channel | useHandleChannelEvents: onThreadInfoUpdated", { channel: k, threadInfoUpdateEvent: Q }), U({
            type: _W,
            payload: { channel: k, event: Q }
          }));
        },
        onMessageDeleted: function(k, Q) {
          V.info("Channel | useHandleChannelEvents: onMessageDeleted", { channel: k, messageId: Q }), o(null), U({
            type: rU,
            payload: Q
          });
        },
        onReactionUpdated: function(k, Q) {
          V.info("Channel | useHandleChannelEvents: onReactionUpdated", { channel: k, reactionEvent: Q }), U({
            type: qW,
            payload: Q
          });
        },
        onChannelChanged: function(k) {
          k.isGroupChannel() && mn(k == null ? void 0 : k.url, E) && (V.info("Channel | useHandleChannelEvents: onChannelChanged", k), U({
            type: ba,
            payload: k
          }));
        },
        onChannelFrozen: function(k) {
          k.isGroupChannel() && mn(k == null ? void 0 : k.url, E) && (V.info("Channel | useHandleChannelEvents: onChannelFrozen", k), U({
            type: ba,
            payload: k
          }));
        },
        onChannelUnfrozen: function(k) {
          k.isGroupChannel() && mn(k == null ? void 0 : k.url, E) && (V.info("Channel | useHandleChannelEvents: onChannelUnFrozen", k), U({
            type: ba,
            payload: k
          }));
        },
        onUserMuted: function(k, Q) {
          k.isGroupChannel() && mn(k == null ? void 0 : k.url, E) && (V.info("Channel | useHandleChannelEvents: onUserMuted", { channel: k, user: Q }), U({
            type: ba,
            payload: k
          }));
        },
        onUserUnmuted: function(k, Q) {
          k.isGroupChannel() && mn(k == null ? void 0 : k.url, E) && (V.info("Channel | useHandleChannelEvents: onUserUnmuted", { channel: k, user: Q }), U({
            type: ba,
            payload: k
          }));
        },
        onUserBanned: function(k, Q) {
          var S;
          if (mn(k == null ? void 0 : k.url, E)) {
            V.info("Channel | useHandleChannelEvents: onUserBanned", { channel: k, user: Q });
            var v = (Q == null ? void 0 : Q.userId) === ((S = c == null ? void 0 : c.currentUser) === null || S === void 0 ? void 0 : S.userId);
            U({
              type: ba,
              payload: v ? null : k
            });
          }
        },
        onOperatorUpdated: function(k, Q) {
          k.isGroupChannel() && mn(k == null ? void 0 : k.url, E) && (V.info("Channel | useHandleChannelEvents: onOperatorUpdated", { channel: k, users: Q }), U({
            type: ba,
            payload: k
          }));
        },
        onUserLeft: function(k, Q) {
          var S;
          if (mn(k == null ? void 0 : k.url, E)) {
            V.info("Channel | useHandleChannelEvents: onUserLeft", { channel: k, user: Q });
            var v = (Q == null ? void 0 : Q.userId) === ((S = c == null ? void 0 : c.currentUser) === null || S === void 0 ? void 0 : S.userId);
            U({
              type: ba,
              payload: v ? null : k
            });
          }
        },
        onTypingStatusUpdated: function(k) {
          if (mn(k == null ? void 0 : k.url, E)) {
            V.info("Channel | onTypingStatusUpdated", { channel: k });
            var Q = k.getTypingUsers();
            U({
              type: n1,
              payload: {
                channel: k,
                typingMembers: Q
              }
            });
          }
        }
      };
      V.info("Channel | useHandleChannelEvents: Setup event handler", { channelHandlerId: u, channelHandler: b }), (m = c.groupChannel) === null || m === void 0 || m.addGroupChannelHandler(u, new xW(b));
    }
    return function() {
      var k;
      !((k = c == null ? void 0 : c.groupChannel) === null || k === void 0) && k.removeGroupChannelHandler ? (V.info("Channel | useHandleChannelEvents: Removing message reciver handler", u), c.groupChannel.removeGroupChannelHandler(u)) : c != null && c.groupChannel && V.error("Channel | useHandleChannelEvents: Not found the removeGroupChannelHandler");
    };
  }, [r == null ? void 0 : r.url, d]);
}
function Og(e, n) {
  var t = e.channelUrl, l = e.sdkInit, a = e.disableMarkAsRead, d = n.messagesDispatcher, r = n.sdk, i = n.logger, c = n.markAsReadScheduler;
  _e(function() {
    t && l && r && r.groupChannel && (i.info("Channel | useSetChannel fetching channel", t), r.groupChannel.getChannel(t).then(function(V) {
      i.info("Channel | useSetChannel fetched channel", V), d({
        type: ba,
        payload: V
      }), i.info("Channel: Mark as read", V), a || c.push(V);
    }).catch(function(V) {
      i.warning("Channel | useSetChannel fetch channel failed", { channelUrl: t, e: V }), d({
        type: AW
      });
    }), r.getAllEmoji().then(function(V) {
      i.info("Channel: Getting emojis success", V), d({
        type: $W,
        payload: V
      });
    }).catch(function(V) {
      i.error("Channel: Getting emojis failed", V);
    }));
  }, [t, l]);
}
function jg(e, n) {
  var t = e.isOnline, l = e.replyType, a = e.disableMarkAsRead, d = e.reconnectOnIdle, r = n.logger, i = n.sdk, c = n.scrollRef, V = n.currentGroupChannel, s = n.messagesDispatcher, o = n.markAsReadScheduler, U = n.userFilledMessageListQuery, N = vg(t, V, d).shouldReconnect;
  _e(function() {
    return function() {
      var R, h;
      if (N) {
        r.info("Refreshing conversation state");
        var Z = ((R = i == null ? void 0 : i.appInfo) === null || R === void 0 ? void 0 : R.useReaction) || !1, W = {
          prevResultSize: rh,
          isInclusive: !0,
          includeReactions: Z,
          includeMetaArray: !0,
          nextResultSize: ih
        };
        l && l === "QUOTE_REPLY" && (W.includeThreadInfo = !0, W.includeParentMessageInfo = !0, W.replyType = al.ONLY_REPLY_TO_CHANNEL), U && Object.keys(U).forEach(function(F) {
          W[F] = U[F];
        }), r.info("Channel: Fetching messages", { currentGroupChannel: V, userFilledMessageListQuery: U }), s({
          type: ah,
          payload: null
        }), (h = i == null ? void 0 : i.groupChannel) === null || h === void 0 || h.getChannel(V == null ? void 0 : V.url).then(function(F) {
          var m = (/* @__PURE__ */ new Date()).getTime();
          F.getMessagesByTimestamp(m, W).then(function(E) {
            s({
              type: dh,
              payload: {
                currentGroupChannel: V,
                messages: E
              }
            }), setTimeout(function() {
              return $d(0, c);
            }, zb);
          }).catch(function(E) {
            r.error("Channel: Fetching messages failed", E), s({
              type: bo,
              payload: { currentGroupChannel: V }
            });
          }), a || o.push(V);
        });
      }
    };
  }, [N, l]);
}
function Hg(e, n) {
  var t = e.currentGroupChannel, l = e.oldestMessageTimeStamp, a = e.userFilledMessageListQuery, d = e.replyType, r = n.hasMorePrev, i = n.logger, c = n.messagesDispatcher, V = n.sdk;
  return Pt(function(s) {
    var o, U;
    if (r) {
      var N = {
        prevResultSize: rh,
        isInclusive: !0,
        includeMetaArray: !0,
        includeReactions: (U = (o = V == null ? void 0 : V.appInfo) === null || o === void 0 ? void 0 : o.useReaction) !== null && U !== void 0 ? U : !1
      };
      (d === "QUOTE_REPLY" || d === "THREAD") && (N.includeThreadInfo = !0, N.includeParentMessageInfo = !0, N.replyType = al.ONLY_REPLY_TO_CHANNEL), a && Object.keys(a).forEach(function(R) {
        N[R] = a[R];
      }), i.info("Channel: Fetching messages", {
        currentGroupChannel: t,
        userFilledMessageListQuery: a
      }), t.getMessagesByTimestamp(l || (/* @__PURE__ */ new Date()).getTime(), N).then(function(R) {
        c({
          type: wW,
          payload: { currentGroupChannel: t, messages: R }
        }), s && setTimeout(function() {
          return s();
        });
      }).catch(function() {
        c({
          type: gW,
          payload: { currentGroupChannel: t }
        });
      });
    }
  }, [t, l, d]);
}
function fg(e, n) {
  var t = e.currentGroupChannel, l = e.latestMessageTimeStamp, a = e.userFilledMessageListQuery, d = e.hasMoreNext, r = e.replyType, i = n.logger, c = n.messagesDispatcher, V = n.sdk;
  return Pt(function(s) {
    var o, U;
    if (d) {
      var N = (U = (o = V == null ? void 0 : V.appInfo) === null || o === void 0 ? void 0 : o.useReaction) !== null && U !== void 0 ? U : !1, R = {
        nextResultSize: ih,
        isInclusive: !0,
        includeReactions: N,
        includeMetaArray: !0
      };
      r && (r === "QUOTE_REPLY" || r === "THREAD") && (R.includeThreadInfo = !0, R.includeParentMessageInfo = !0, R.replyType = al.ONLY_REPLY_TO_CHANNEL), a && Object.keys(a).forEach(function(h) {
        R[h] = a[h];
      }), i.info("Channel: Fetching later messages", { currentGroupChannel: t, userFilledMessageListQuery: a }), t.getMessagesByTimestamp(l || (/* @__PURE__ */ new Date()).getTime(), R).then(function(h) {
        c({
          type: IW,
          payload: { currentGroupChannel: t, messages: h }
        }), setTimeout(function() {
          return s([h, null]);
        });
      }).catch(function(h) {
        i.error("Channel: Fetching later messages failed", h), c({
          type: LW,
          payload: { currentGroupChannel: t }
        }), setTimeout(function() {
          return s([null, h]);
        });
      });
    }
  }, [t, l, d, r]);
}
function wg(e, n) {
  var t = e.currentGroupChannel, l = e.messagesDispatcher, a = n.logger;
  return Pt(function(d) {
    a.info("Channel | useDeleteMessageCallback: Deleting message", d);
    var r = th(d) ? d.sendingStatus : void 0;
    return new Promise(function(i, c) {
      a.info("Channel | useDeleteMessageCallback: Deleting message requestState:", r), (r === $t.FAILED || r === $t.PENDING) && "reqId" in d ? (a.info("Channel | useDeleteMessageCallback: Deleted message from local:", d), l({
        type: PW,
        payload: d.reqId
      }), i()) : (a.info("Channel | useDeleteMessageCallback: Deleting message from remote:", r), t.deleteMessage(d).then(function() {
        a.info("Channel | useDeleteMessageCallback: Deleting message success!", d), l({
          type: rU,
          payload: d.messageId
        }), i();
      }).catch(function(V) {
        a.warning("Channel | useDeleteMessageCallback: Deleting message failed!", V), c(V);
      }));
    });
  }, [t, l]);
}
function gg(e, n) {
  var t = e.currentGroupChannel, l = e.messagesDispatcher, a = e.onBeforeUpdateUserMessage, d = e.isMentionEnabled, r = n.logger, i = n.pubSub;
  return Pt(function(c, V) {
    var s = c.messageId, o = c.message, U = c.mentionedUsers, N = c.mentionTemplate, R = function(W) {
      var F = {
        message: W
      };
      return d && (U == null ? void 0 : U.length) > 0 && (F.mentionedUsers = U), d && N ? F.mentionedMessageTemplate = N : F.mentionedMessageTemplate = W, F;
    }, h = a && typeof a == "function";
    h && r.info("Channel: creating params using onBeforeUpdateUserMessage", a);
    var Z = h ? a(o) : R(o);
    r.info("Channel: Updating message!", Z), t.updateUserMessage(s, Z).then(function(W) {
      V && V(null, W), r.info("Channel: Updating message success!", W), l({
        type: dU,
        payload: {
          channel: t,
          message: W
        }
      }), i.publish(Xa.UPDATE_USER_MESSAGE, {
        message: W,
        channel: t,
        publishingModules: [er.CHANNEL]
      });
    }).catch(function(W) {
      V && V(W, null);
    });
  }, [t == null ? void 0 : t.url, l, a]);
}
function Ig(e, n) {
  var t = e.currentGroupChannel, l = e.messagesDispatcher, a = n.logger, d = n.pubSub;
  return Pt(function(r) {
    a.info("Channel: Resending message has started", r), r != null && r.isResendable ? r.isUserMessage() ? t.resendMessage(r).onPending(function(i) {
      a.info("Channel: Resending message start!", i), l({
        type: lo,
        payload: i
      });
    }).onSucceeded(function(i) {
      a.info("Channel: Resending message success!", i), l({
        type: _d,
        payload: i
      });
    }).onFailed(function(i, c) {
      a.warning("Channel: Resending message failed!", i), l({
        type: kr,
        payload: c
      });
    }) : r.isFileMessage() ? t.resendMessage(r).onPending(function(i) {
      a.info("Channel: Resending file message start!", i), l({
        type: lo,
        payload: i
      });
    }).onSucceeded(function(i) {
      a.info("Channel: Resending file message success!", i), l({
        type: _d,
        payload: i
      });
    }).onFailed(function(i, c) {
      a.warning("Channel: Resending file message failed!", i), l({
        type: kr,
        payload: c
      });
    }) : r.isMultipleFilesMessage() && t.resendMessage(r).onPending(function(i) {
      a.info("Channel: Resending multiple files message start!", i), l({
        type: lo,
        payload: i
      });
    }).onFileUploaded(function(i, c, V, s) {
      a.info("Channel: Resending multiple files message file uploaded!", {
        requestId: i,
        index: c,
        error: s,
        uploadableFileInfo: V
      }), d.publish(Xa.ON_FILE_INFO_UPLOADED, {
        response: {
          channelUrl: t.url,
          requestId: i,
          index: c,
          uploadableFileInfo: V,
          error: s
        },
        publishingModules: [er.CHANNEL]
      });
    }).onSucceeded(function(i) {
      a.info("Channel: Resending multiple files message success!", i), l({
        type: _d,
        payload: i
      });
    }).onFailed(function(i, c) {
      a.warning("Channel: Resending multiple files message failed!", i), l({
        type: kr,
        payload: c
      });
    }) : a.error("Message is not resendable", r);
  }, [t, l]);
}
function Lg(e, n) {
  var t = e.isMentionEnabled, l = e.currentGroupChannel, a = e.onBeforeSendUserMessage, d = n.logger, r = n.pubSub, i = n.scrollRef, c = n.messagesDispatcher, V = Wt(null), s = Pt(function(o) {
    var U = o.quoteMessage, N = o.message, R = o.mentionTemplate, h = o.mentionedUsers, Z = function() {
      var m = {
        message: N
      };
      return t && (h == null ? void 0 : h.length) > 0 && (m.mentionedUsers = h), t && R && (h == null ? void 0 : h.length) > 0 && (m.mentionedMessageTemplate = R), U && (m.isReplyToChannel = !0, m.parentMessageId = U.messageId), m;
    }, W = a && typeof a == "function";
    W && d.info("Channel: creating params using onBeforeSendUserMessage", a);
    var F = W ? a(N, U) : Z();
    d.info("Channel: Sending message has started", F), l.sendUserMessage(F).onPending(function(m) {
      r.publish(Xa.SEND_MESSAGE_START, {
        /* pubSub is used instead of messagesDispatcher
          to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */
        message: m,
        channel: l,
        publishingModules: [er.CHANNEL]
      }), setTimeout(function() {
        return $d(0, i);
      }, vc);
    }).onFailed(function(m, E) {
      d.warning("Channel: Sending message failed!", { message: E, error: m }), c({
        type: kr,
        payload: E
      });
    }).onSucceeded(function(m) {
      d.info("Channel: Sending message success!", m), c({
        type: _d,
        payload: m
      });
    });
  }, [l, a]);
  return [V, s];
}
function Cg(e, n) {
  var t = e.currentGroupChannel, l = e.onBeforeSendFileMessage, a = e.imageCompression, d = n.logger, r = n.pubSub, i = n.scrollRef, c = n.messagesDispatcher, V = Pt(function(s, o) {
    return o === void 0 && (o = null), new Promise(function(U, N) {
      var R = l == null ? void 0 : l(s, o);
      R || (R = { file: s }, o && (R.isReplyToChannel = !0, R.parentMessageId = o.messageId)), d.info("Channel: Uploading file message start!", R), t.sendFileMessage(R).onPending(function(h) {
        r.publish(Xa.SEND_MESSAGE_START, {
          /* pubSub is used instead of messagesDispatcher
            to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */
          message: ce(ce({}, h), {
            url: URL.createObjectURL(s),
            // pending thumbnail message seems to be failed
            requestState: "pending"
          }),
          channel: t,
          publishingModules: [er.CHANNEL]
        }), setTimeout(function() {
          return $d(0, i);
        }, vc);
      }).onFailed(function(h, Z) {
        d.error("Channel: Sending file message failed!", { failedMessage: Z, err: h }), Z.localUrl = URL.createObjectURL(s), Z.file = s, c({
          type: kr,
          payload: Z
        }), N(h);
      }).onSucceeded(function(h) {
        d.info("Channel: Sending file message success!", h), c({
          type: _d,
          payload: h
        }), U(h);
      });
    });
  }, [t, l, a]);
  return [V];
}
function Kg(e) {
  var n = e.current, t = n == null ? void 0 : n.parentNode;
  n && t && (n.style.pointerEvents = "none", t.style.cursor = "wait");
}
function _g(e) {
  var n = e.current, t = n == null ? void 0 : n.parentNode;
  n && t && (n.style.pointerEvents = "auto", t.style.cursor = "auto");
}
function Pg(e, n) {
  var t = e.setInitialTimeStamp, l = e.setAnimatedMessageId, a = e.allMessages, d = e.scrollRef, r = n.logger;
  return Pt(function(i, c) {
    var V = a.find(function(s) {
      return s.messageId === c;
    });
    l(null), setTimeout(function() {
      try {
        r.info("Channel: scroll to message - disabling mouse events"), Kg(d), V ? (r.info("Channel: scroll to message - message is present"), l(c), tY(d, i)) : (r.info("Channel: scroll to message - fetching older messages"), t(null), t(i), l(c));
      } finally {
        r.info("Channel: scroll to message - enabled mouse events"), _g(d);
      }
    });
  }, [
    t,
    l,
    a
  ]);
}
var Ag = function(e, n) {
  var t = e.currentGroupChannel, l = e.onBeforeSendVoiceMessage, a = n.logger, d = n.pubSub, r = n.scrollRef, i = n.messagesDispatcher, c = Pt(function(V, s, o) {
    return new Promise(function(U, N) {
      if (t) {
        var R = l && typeof l == "function" ? l(V, o) : {
          file: V,
          fileName: hR,
          mimeType: to,
          metaArrays: [
            new Ol({
              key: Kj,
              value: ["".concat(s)]
            }),
            new Ol({
              key: _j,
              value: [Pj]
            })
          ]
        };
        o && (R.isReplyToChannel = !0, R.parentMessageId = o.messageId), a.info("Channel: Start sending voice message", R), t.sendFileMessage(R).onPending(function(h) {
          d.publish(Xa.SEND_MESSAGE_START, {
            /* pubSub is used instead of messagesDispatcher
              to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */
            message: h,
            channel: t,
            publishingModules: [er.CHANNEL]
          }), setTimeout(function() {
            return $d(0, r);
          }, vc);
        }).onFailed(function(h, Z) {
          a.error("Channel: Sending voice message failed!", { failedMessage: Z, err: h }), i({
            type: kr,
            payload: Z
          }), N(h);
        }).onSucceeded(function(h) {
          a.info("Channel: Sending voice message success!", h), i({
            type: _d,
            payload: h
          }), U(h);
        });
      }
    });
  }, [
    t,
    l
  ]);
  return [c];
}, qg = function(e) {
  var n = e.channelUrl, t = e.sdkInit, l = e.pubSub, a = e.dispatcher, d = e.scrollRef;
  _e(function() {
    var r = /* @__PURE__ */ new Map();
    return l != null && l.subscribe && (r.set(Gl.SEND_USER_MESSAGE, l.subscribe(Gl.SEND_USER_MESSAGE, function(i) {
      var c = i.channel, V = i.message;
      n === (c == null ? void 0 : c.url) && (a({
        type: _d,
        payload: V
      }), setTimeout(function() {
        return $d(0, d);
      }, vc));
    })), r.set(Gl.SEND_MESSAGE_START, l.subscribe(Gl.SEND_MESSAGE_START, function(i) {
      var c = i.channel, V = i.message, s = i.publishingModules;
      n === (c == null ? void 0 : c.url) && xN(s) && a({
        type: CW,
        payload: V
      });
    })), r.set(Gl.ON_FILE_INFO_UPLOADED, l.subscribe(Gl.ON_FILE_INFO_UPLOADED, function(i) {
      var c = i.response, V = i.publishingModules;
      n === c.channelUrl && xN(V) && a({
        type: t1,
        payload: c
      });
    })), r.set(Gl.SEND_MESSAGE_FAILED, l.subscribe(Gl.SEND_MESSAGE_FAILED, function(i) {
      var c = i.channel, V = i.message, s = i.publishingModules;
      n === (c == null ? void 0 : c.url) && xN(s) && a({
        type: kr,
        payload: V
      });
    })), r.set(Gl.SEND_FILE_MESSAGE, l.subscribe(Gl.SEND_FILE_MESSAGE, function(i) {
      var c = i.channel, V = i.message;
      n === (c == null ? void 0 : c.url) && (a({
        type: _d,
        payload: V
      }), setTimeout(function() {
        return $d(0, d);
      }, vc));
    })), r.set(Gl.UPDATE_USER_MESSAGE, l.subscribe(Gl.UPDATE_USER_MESSAGE, function(i) {
      var c = i.channel, V = i.message, s = i.fromSelector;
      s && n === (c == null ? void 0 : c.url) && c.isGroupChannel() && a({
        type: dU,
        payload: { channel: c, message: V }
      });
    })), r.set(Gl.DELETE_MESSAGE, l.subscribe(Gl.DELETE_MESSAGE, function(i) {
      var c = i.channel, V = i.messageId;
      n === (c == null ? void 0 : c.url) && a({
        type: rU,
        payload: V
      });
    }))), function() {
      r.forEach(function(i) {
        try {
          i.remove();
        } catch {
        }
      });
    };
  }, [
    n,
    t
  ]);
}, VY = T.createContext(void 0), $g = function(e) {
  var n, t, l, a, d, r, i = e.channelUrl, c = e.children, V = e.isReactionEnabled, s = e.isMessageGroupingEnabled, o = s === void 0 ? !0 : s, U = e.isMultipleFilesMessageEnabled, N = e.showSearchIcon, R = e.animatedMessage, h = e.highlightedMessage, Z = e.startingPoint, W = e.onBeforeSendUserMessage, F = e.onBeforeSendFileMessage, m = e.onBeforeUpdateUserMessage, E = e.onBeforeSendVoiceMessage, u = e.onBeforeSendMultipleFilesMessage, b = e.onChatHeaderActionClick, k = e.onSearchClick, Q = e.onBackClick, S = e.replyType, v = e.threadReplySelectType, G = e.queries, w = e.filterMessageList, y = e.disableMarkAsRead, g = y === void 0 ? !1 : y, f = e.onReplyInThread, I = e.onQuoteMessageClick, K = e.onMessageAnimated, Ue = e.onMessageHighlighted, q = e.scrollBehavior, ae = q === void 0 ? "auto" : q, se = e.reconnectOnIdle, le = se === void 0 ? !0 : se, L = zn(), $ = L.config, ee = S ?? $.replyType, O = $.pubSub, re = $.logger, te = $.userId, Qe = $.isOnline, Ye = $.imageCompression, Se = $.isMentionEnabled, P = $.onUserProfileMessage, ge = $.markAsReadScheduler, Me = $.groupChannel, We = (t = (n = L == null ? void 0 : L.stores) === null || n === void 0 ? void 0 : n.sdkStore) === null || t === void 0 ? void 0 : t.sdk, De = (a = (l = L == null ? void 0 : L.stores) === null || l === void 0 ? void 0 : l.sdkStore) === null || a === void 0 ? void 0 : a.initialized, Oe = L == null ? void 0 : L.config, tt = me(Z), Be = tt[0], He = tt[1];
  _e(function() {
    He(Z);
  }, [Z, i]);
  var at = me(null), Ge = at[0], $e = at[1], fe = me(h), Xe = fe[0], pt = fe[1];
  _e(function() {
    pt(h);
  }, [h]);
  var Vt = G == null ? void 0 : G.messageListParams, yt = me(null), xe = yt[0], At = yt[1], kt = me(!1), Kt = kt[0], ln = kt[1], vt = zs(Bg, yg), Rt = vt[0], Ke = vt[1], Je = Wt(null), de = Rt.allMessages, qe = Rt.localMessages, lt = Rt.loading, ct = Rt.initialized, Ot = Rt.unreadSince, zt = Rt.unreadSinceDate, cn = Rt.isInvalid, mt = Rt.currentGroupChannel, sn = Rt.hasMorePrev, hn = Rt.oldestMessageTimeStamp, ft = Rt.hasMoreNext, qt = Rt.latestMessageTimeStamp, jt = Rt.emojiContainer, Bt = Rt.readStatus, Ie = Rt.typingMembers, it = (mt == null ? void 0 : mt.isSuper) || !1, ze = (mt == null ? void 0 : mt.isBroadcast) || !1, ht = eg({
    isBroadcast: ze,
    isSuper: it,
    globalLevel: $ == null ? void 0 : $.isReactionEnabled,
    moduleLevel: V
  }), Ft = nn(function() {
    return ht ? Kw(jt) : /* @__PURE__ */ new Map();
  }, [jt]), X = nn(function() {
    return ht && mt ? _w(mt == null ? void 0 : mt.members) : /* @__PURE__ */ new Map();
  }, [mt == null ? void 0 : mt.members]);
  _e(function() {
    R && $e(R);
  }, [R]);
  var Ne = Hg({
    currentGroupChannel: mt,
    oldestMessageTimeStamp: hn,
    userFilledMessageListQuery: Vt,
    replyType: ee
  }, {
    hasMorePrev: sn,
    logger: re,
    messagesDispatcher: Ke,
    sdk: We
  }), pe = Pg({
    setInitialTimeStamp: He,
    setAnimatedMessageId: $e,
    allMessages: de,
    scrollRef: Je
  }, { logger: re }), we = fg({
    currentGroupChannel: mt,
    latestMessageTimeStamp: qt,
    userFilledMessageListQuery: Vt,
    hasMoreNext: ft,
    replyType: ee
  }, {
    logger: re,
    messagesDispatcher: Ke,
    sdk: We
  }), Nt = xg(mt, re);
  Og({ channelUrl: i, sdkInit: De, disableMarkAsRead: g }, { messagesDispatcher: Ke, sdk: We, logger: re, markAsReadScheduler: ge }), _e(function() {
    At(null);
  }, [i]), Xg({
    currentGroupChannel: mt,
    sdkInit: De,
    currentUserId: te,
    disableMarkAsRead: g
  }, {
    messagesDispatcher: Ke,
    sdk: We,
    logger: re,
    scrollRef: Je,
    setQuoteMessage: At
  }), Jg({
    currentGroupChannel: mt,
    userFilledMessageListQuery: Vt,
    initialTimeStamp: Be,
    replyType: ee,
    setIsScrolled: ln
  }, {
    logger: re,
    scrollRef: Je,
    messagesDispatcher: Ke
  }), qg({
    channelUrl: i,
    sdkInit: De,
    pubSub: O,
    dispatcher: Ke,
    scrollRef: Je
  }), jg({ isOnline: Qe, replyType: ee, disableMarkAsRead: g, reconnectOnIdle: le }, {
    logger: re,
    sdk: We,
    scrollRef: Je,
    currentGroupChannel: mt,
    messagesDispatcher: Ke,
    userFilledMessageListQuery: Vt,
    markAsReadScheduler: ge
  });
  var Ee = wg({ currentGroupChannel: mt, messagesDispatcher: Ke }, { logger: re }), H = gg({ currentGroupChannel: mt, messagesDispatcher: Ke, onBeforeUpdateUserMessage: m, isMentionEnabled: Se }, { logger: re, pubSub: O }), Ve = Ig({ currentGroupChannel: mt, messagesDispatcher: Ke }, { logger: re, pubSub: O }), ye = Lg({
    currentGroupChannel: mt,
    isMentionEnabled: Se,
    onBeforeSendUserMessage: W
  }, {
    logger: re,
    pubSub: O,
    scrollRef: Je,
    messagesDispatcher: Ke
  }), Zt = ye[0], Mt = ye[1], Ct = Cg({
    currentGroupChannel: mt,
    imageCompression: Ye,
    onBeforeSendFileMessage: F
  }, {
    logger: re,
    pubSub: O,
    scrollRef: Je,
    messagesDispatcher: Ke
  })[0], Ht = Ag({
    currentGroupChannel: mt,
    onBeforeSendVoiceMessage: E
  }, {
    logger: re,
    pubSub: O,
    scrollRef: Je,
    messagesDispatcher: Ke
  })[0], Sn = Gg({
    currentChannel: mt,
    onBeforeSendMultipleFilesMessage: u,
    publishingModules: [er.CHANNEL]
  }, {
    logger: re,
    pubSub: O,
    scrollRef: Je
  })[0];
  return T.createElement(
    VY.Provider,
    { value: {
      // props
      channelUrl: i,
      isReactionEnabled: ht,
      isMessageGroupingEnabled: o,
      isMultipleFilesMessageEnabled: U,
      showSearchIcon: N ?? Oe.showSearchIcon,
      highlightedMessage: h,
      startingPoint: Z,
      onBeforeSendUserMessage: W,
      onBeforeSendFileMessage: F,
      onBeforeUpdateUserMessage: m,
      onChatHeaderActionClick: b,
      onSearchClick: k,
      onBackClick: Q,
      replyType: ee,
      threadReplySelectType: (d = v ?? Cb(Me.threadReplySelectType).upperCase) !== null && d !== void 0 ? d : Rd.THREAD,
      queries: G,
      filterMessageList: w,
      disableMarkAsRead: g,
      onReplyInThread: f,
      onQuoteMessageClick: I,
      onMessageAnimated: K,
      onMessageHighlighted: Ue,
      // messagesStore
      allMessages: de,
      localMessages: qe,
      loading: lt,
      initialized: ct,
      unreadSince: Ot,
      unreadSinceDate: zt,
      isInvalid: cn,
      currentGroupChannel: mt,
      hasMorePrev: sn,
      hasMoreNext: ft,
      oldestMessageTimeStamp: hn,
      latestMessageTimeStamp: qt,
      emojiContainer: jt,
      readStatus: Bt,
      typingMembers: Ie,
      // utils
      scrollToMessage: pe,
      quoteMessage: xe,
      setQuoteMessage: At,
      deleteMessage: Ee,
      updateMessage: H,
      resendMessage: Ve,
      messageInputRef: Zt,
      sendMessage: Mt,
      sendFileMessage: Ct,
      sendVoiceMessage: Ht,
      sendMultipleFilesMessage: Sn,
      initialTimeStamp: Be,
      messageActionTypes: Qg,
      messagesDispatcher: Ke,
      setInitialTimeStamp: He,
      setAnimatedMessageId: $e,
      setHighLightedMessageId: pt,
      animatedMessageId: Ge,
      highLightedMessageId: Xe,
      nicknamesMap: X,
      emojiAllMap: Ft,
      onScrollCallback: Ne,
      onScrollDownCallback: we,
      scrollRef: Je,
      scrollBehavior: ae,
      toggleReaction: Nt,
      isScrolled: Kt,
      setIsScrolled: ln
    } },
    T.createElement(gw, { disableUserProfile: (r = e == null ? void 0 : e.disableUserProfile) !== null && r !== void 0 ? r : $ == null ? void 0 : $.disableUserProfile, renderUserProfile: e == null ? void 0 : e.renderUserProfile, onUserProfileMessage: P }, c)
  );
}, fl = function() {
  return T.useContext(VY);
}, cY = function(e) {
  return typeof e == "number" ? "".concat(e, "px") : e;
};
function zM(e, n, t) {
  var l;
  return "min(".concat(n ?? t, ", ").concat((l = cY(e)) !== null && l !== void 0 ? l : t, ")");
}
function e4(e) {
  var n = e.width, t = e.height, l = e.maxSideLength, a = e.defaultMinLength, d = nn(function() {
    return zM(n, l, a);
  }, [n]), r = nn(function() {
    return zM(t, l, a);
  }, [t]);
  return [d, r];
}
var t4 = function(e) {
  var n = me(!1), t = n[0], l = n[1];
  return ud(function() {
    var a = new IntersectionObserver(function(d) {
      var r = d[0];
      r && l(r.isIntersecting);
    });
    return e.current && a.observe(e.current), function() {
      return a.disconnect();
    };
  }, [e.current]), t;
}, n4 = function(e) {
  var n = Wt(!1), t = t4(e);
  return t && (n.current = !0), n.current;
};
function xM(e, n) {
  return e === void 0 && (e = !1), n === void 0 && (n = null), e ? "50%" : cY(n);
}
function l4(e, n, t) {
  var l = typeof e == "string" ? parseInt(e, 10) : e, a = t - 1, d = n === 0 ? l * 2 : l, r = n === 1 ? l * 2 : l, i = n === a ? l * 2 : l, c = n === a - 1 ? l * 2 : l;
  return "".concat(d, "px ").concat(r, "px ").concat(i, "px ").concat(c, "px");
}
var el = function(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.url, a = e.alt, d = a === void 0 ? "" : a, r = e.width, i = r === void 0 ? null : r, c = e.maxSideLength, V = c === void 0 ? null : c, s = e.height, o = s === void 0 ? null : s, U = e.circle, N = U === void 0 ? !1 : U, R = e.fixedSize, h = R === void 0 ? !1 : R, Z = e.placeHolder, W = Z === void 0 ? null : Z, F = e.defaultComponent, m = F === void 0 ? null : F, E = e.borderRadius, u = E === void 0 ? null : E, b = e.onLoad, k = b === void 0 ? dl : b, Q = e.onError, S = Q === void 0 ? dl : Q, v = e.shadeOnHover, G = e.isUploaded, w = G === void 0 ? !0 : G, y = Wt(null), g = n4(y), f = g ? l : null, I = me(!1), K = I[0], Ue = I[1], q = me(!0), ae = q[0], se = q[1], le = e4({
    width: i,
    height: o,
    maxSideLength: V,
    defaultMinLength: "400px"
  }), L = le[0], $ = le[1], ee = function() {
    return typeof W == "function" ? W({
      style: {
        width: "100%",
        minWidth: L,
        maxWidth: h ? L : "400px",
        height: $,
        position: "absolute",
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      }
    }) : W;
  }, O = function() {
    return typeof m == "function" ? m() : m;
  }, re = function() {
    var te = f ? {
      backgroundRepeat: "no-repeat",
      backgroundPosition: "center",
      backgroundSize: "cover",
      backgroundImage: "url(".concat(f, ")")
    } : {};
    return T.createElement("div", { className: "sendbird-image-renderer__image", style: ce({ width: "100%", minWidth: L, maxWidth: h ? L : "400px", height: $, position: "absolute", borderRadius: xM(N, u) }, te) });
  };
  return L && $ && T.createElement(
    "div",
    { ref: y, className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), ["sendbird-image-renderer"], !1).join(" "), style: {
      width: "100%",
      minWidth: L,
      maxWidth: h ? L : "400px",
      height: $
    } },
    ae && ee(),
    K ? O() : re(),
    v && T.createElement("div", { className: "sendbird-multiple-files-image-renderer__image-cover", style: ce({ borderRadius: xM(N, u) }, w ? {} : { display: "inline-flex" }) }),
    f && T.createElement(a4, { src: f, alt: d, onLoadStart: function() {
      se(!0), Ue(!1);
    }, onLoad: function() {
      se(!1), Ue(!1), k();
    }, onError: function() {
      se(!1), Ue(!0), S();
    } })
  );
}, a4 = function(e) {
  var n = e.src, t = e.alt, l = e.onLoadStart, a = l === void 0 ? dl : l, d = e.onLoad, r = d === void 0 ? dl : d, i = e.onError, c = i === void 0 ? dl : i, V = Wt({
    currSrc: n,
    prevSrc: n,
    loadFailure: !1
  });
  return V.current.currSrc !== n && (V.current.prevSrc = V.current.currSrc, V.current.currSrc = n), ud(function() {
    if (n) {
      var s = V.current.prevSrc !== V.current.currSrc, o = V.current.loadFailure;
      (s || o) && a();
    }
  }, [n, navigator.onLine]), T.createElement("img", { className: "sendbird-image-renderer__hidden-image-loader", src: n, alt: t, onLoad: function() {
    V.current.loadFailure = !1, r();
  }, onError: function() {
    V.current.loadFailure = !0, c();
  } });
}, mR = function(e) {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    var n = Number.parseFloat(e);
    if (!Number.isNaN(n))
      return n;
  }
  return NaN;
}, sY = function(e) {
  var n = e.width, t = e.height, l = e.text, a = mR(n), d = mR(t);
  return typeof a == "number" && !Number.isNaN(a) && (a *= 0.575), typeof d == "number" && !Number.isNaN(d) && (d *= 0.575), T.createElement("div", { className: "sendbird-avatar-img--default ".concat(l ? "text" : ""), style: { width: n, height: t } }, l ? T.createElement("div", { className: "sendbird-avatar-text" }, l) : T.createElement(dt, { type: Le.USER, fillColor: Pe.CONTENT, width: a, height: d }));
}, cr = "sendbird-avatar-img", d4 = function(e) {
  var n = e.src, t = n === void 0 ? "" : n, l = e.alt, a = l === void 0 ? "" : l, d = e.height, r = e.width, i = e.customDefaultComponent, c = function() {
    return i ? i({ width: r, height: d }) : T.createElement(sY, { width: r, height: d });
  };
  return typeof t == "string" ? T.createElement(el, { className: cr, url: t, height: d, width: r, alt: a, defaultComponent: c }) : t && t.length ? t.length === 1 ? T.createElement(el, { className: cr, url: t[0], height: d, width: r, alt: a, defaultComponent: c }) : t.length === 2 ? T.createElement(
    "div",
    { className: "sendbird-avatar--inner__two-child" },
    T.createElement(el, { className: cr, url: t[0], height: d, width: r, alt: a, defaultComponent: c }),
    T.createElement(el, { className: cr, url: t[1], height: d, width: r, alt: a, defaultComponent: c })
  ) : t.length === 3 ? T.createElement(
    T.Fragment,
    null,
    T.createElement(
      "div",
      { className: "sendbird-avatar--inner__three-child--upper" },
      T.createElement(el, { className: cr, url: t[0], height: d, width: r, alt: a, defaultComponent: c })
    ),
    T.createElement(
      "div",
      { className: "sendbird-avatar--inner__three-child--lower" },
      T.createElement(el, { className: cr, url: t[1], height: d, width: r, alt: a, defaultComponent: c }),
      T.createElement(el, { className: cr, url: t[2], height: d, width: r, alt: a, defaultComponent: c })
    )
  ) : T.createElement("div", { className: "sendbird-avatar--inner__four-child" }, t.slice(0, 4).map(function(V, s) {
    return T.createElement(el, { className: cr, url: V, height: d, width: r, alt: a, key: "".concat(V, "-").concat(s), defaultComponent: c });
  })) : T.createElement(el, { className: cr, url: "", height: d, width: r, alt: a, defaultComponent: c });
};
function r4(e, n) {
  var t = e.className, l = t === void 0 ? "" : t, a = e.src, d = a === void 0 ? "" : a, r = e.alt, i = r === void 0 ? "" : r, c = e.width, V = c === void 0 ? "56px" : c, s = e.height, o = s === void 0 ? "56px" : s, U = e.zIndex, N = U === void 0 ? 0 : U, R = e.left, h = R === void 0 ? "" : R, Z = e.onClick, W = e.customDefaultComponent;
  return T.createElement(
    "div",
    { className: Ut(Ut([], Array.isArray(l) ? l : [l], !0), [
      "sendbird-avatar"
    ], !1).join(" "), role: "button", ref: n, style: {
      height: o,
      width: V,
      zIndex: N,
      left: h
    }, onClick: Z, onKeyDown: Z, tabIndex: 0 },
    T.createElement(d4, { src: d, width: V, height: o, alt: i, customDefaultComponent: W })
  );
}
var da = T.forwardRef(r4), oY = "https://static.sendbird.com/sample/cover/cover_", vZ = function(e, n) {
  return e != null && e.coverUrl && !new RegExp("^".concat(oY)).test(e.coverUrl) ? e.coverUrl : ((e == null ? void 0 : e.members) || []).filter(function(t) {
    return t.userId !== n;
  }).map(function(t) {
    var l = t.profileUrl;
    return l;
  });
}, i4 = function(e) {
  return e != null && e.coverUrl ? !!new RegExp("^".concat(oY)).test(e.coverUrl) : !0;
};
function V4(e) {
  var n = e.channel, t = e.userId, l = e.theme, a = e.width, d = a === void 0 ? 56 : a, r = e.height, i = r === void 0 ? 56 : r, c = n == null ? void 0 : n.isBroadcast, V = nn(function() {
    return c ? i4(n) ? T.createElement(
      "div",
      { className: "sendbird-chat-header--default-avatar", style: {
        width: d,
        height: i,
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      } },
      T.createElement(dt, { type: Le.BROADCAST, fillColor: Pe.CONTENT, width: d * 0.575, height: i * 0.575 })
    ) : T.createElement(da, { className: "sendbird-chat-header--avatar--broadcast-channel", src: vZ(n, t), width: d, height: i, alt: n == null ? void 0 : n.name }) : T.createElement(da, { className: "sendbird-chat-header--avatar--group-channel", src: vZ(n, t), width: "".concat(d, "px"), height: "".concat(i, "px"), alt: n == null ? void 0 : n.name });
  }, [vZ(n, t), l]);
  return T.createElement(T.Fragment, null, V);
}
var c4 = function(e, n, t) {
  var l, a = t || wb;
  return !(e != null && e.name) && !(e != null && e.members) ? a.NO_TITLE : e != null && e.name && e.name !== "Group Channel" ? e.name : ((l = e == null ? void 0 : e.members) === null || l === void 0 ? void 0 : l.length) === 1 ? a.NO_MEMBERS : e == null ? void 0 : e.members.filter(function(d) {
    var r = d.userId;
    return r !== n;
  }).map(function(d) {
    var r = d.nickname;
    return r || a.NO_NAME;
  }).join(", ");
}, s4 = function(e) {
  var n, t = e.className, l = e.currentChannel, a = e.showSearchIcon, d = e.onBackClick, r = e.onSearchClick, i = e.onChatHeaderActionClick, c = zn().config, V = c.userId, s = c.theme, o = dr().isMobile, U = ca().stringSet, N = (l == null ? void 0 : l.myMutedState) === "muted", R = (l == null ? void 0 : l.members) && ((n = l == null ? void 0 : l.members) === null || n === void 0 ? void 0 : n.length) !== 2;
  return T.createElement(
    "div",
    { className: "sendbird-chat-header ".concat(t) },
    T.createElement(
      "div",
      { className: "sendbird-chat-header__left" },
      o && T.createElement(dt, { className: "sendbird-chat-header__icon_back", onClick: d, fillColor: Pe.PRIMARY, width: "24px", height: "24px", type: Le.ARROW_LEFT }),
      T.createElement(V4, { theme: s, channel: l, userId: V, height: 32, width: 32 }),
      T.createElement(Fe, { className: "sendbird-chat-header__left__title", type: oe.H_2, color: ie.ONBACKGROUND_1 }, c4(l, V, U)),
      T.createElement(Fe, { className: "sendbird-chat-header__left__subtitle", type: oe.BODY_1, color: ie.ONBACKGROUND_2 }, R)
    ),
    T.createElement(
      "div",
      { className: "sendbird-chat-header__right" },
      N && T.createElement(dt, { className: "sendbird-chat-header__right__mute", type: Le.NOTIFICATIONS_OFF_FILLED, fillColor: Pe.ON_BACKGROUND_2, width: "24px", height: "24px" }),
      a && !(l != null && l.isEphemeral) && T.createElement(
        Fi,
        { className: "sendbird-chat-header__right__search", width: "32px", height: "32px", onClick: r },
        T.createElement(dt, { type: Le.SEARCH, fillColor: Pe.PRIMARY, width: "24px", height: "24px" })
      ),
      T.createElement(
        Fi,
        { className: "sendbird-chat-header__right__info", width: "32px", height: "32px", onClick: i },
        T.createElement(dt, { type: Le.INFO, fillColor: Pe.PRIMARY, width: "24px", height: "24px" })
      )
    )
  );
}, UY = function(e) {
  var n = e.className, t = fl();
  return T.createElement(s4, ce({}, t, { className: n, currentChannel: t.currentGroupChannel }));
}, o4 = function(e) {
  var n = e.members;
  function t() {
    var l = Gt(Kn).stringSet;
    return !n || n.length === 0 ? "" : n && n.length === 1 ? "".concat(n[0].nickname, " ").concat(l.TYPING_INDICATOR__IS_TYPING) : n && n.length === 2 ? "".concat(n[0].nickname, " ").concat(l.TYPING_INDICATOR__AND, " ").concat(n[1].nickname, " ").concat(l.TYPING_INDICATOR__ARE_TYPING) : l.TYPING_INDICATOR__MULTIPLE_TYPING;
  }
  return T.createElement(T.Fragment, null, t());
}, U4 = function(e) {
  var n, t, l, a = e.channelUrl, d = zn(), r = (t = (n = d == null ? void 0 : d.stores) === null || n === void 0 ? void 0 : n.sdkStore) === null || t === void 0 ? void 0 : t.sdk, i = (l = d == null ? void 0 : d.config) === null || l === void 0 ? void 0 : l.logger, c = me(zr()), V = c[0], s = c[1], o = me([]), U = o[0], N = o[1];
  return _e(function() {
    var R;
    if (!((R = r == null ? void 0 : r.groupChannel) === null || R === void 0) && R.addGroupChannelHandler) {
      r.groupChannel.removeGroupChannelHandler(V);
      var h = zr(), Z = new xW({
        onTypingStatusUpdated: function(W) {
          if (i.info("Channel > Typing Indicator: onTypingStatusUpdated", W), W.url === a) {
            var F = W.getTypingUsers();
            N(F);
          }
        }
      });
      r.groupChannel.addGroupChannelHandler(h, Z), s(h);
    }
    return function() {
      var W;
      N([]), !((W = r == null ? void 0 : r.groupChannel) === null || W === void 0) && W.removeGroupChannelHandler && r.groupChannel.removeGroupChannelHandler(V);
    };
  }, [a]), T.createElement(
    Fe,
    { className: "sendbird-conversation__footer__typing-indicator__text", type: oe.CAPTION_2, color: ie.ONBACKGROUND_2 },
    T.createElement(o4, { members: U })
  );
}, uR;
(function(e) {
  e.Text = "text", e.Bubble = "bubble";
})(uR || (uR = {}));
function N4() {
  var e = Gt(Kn).stringSet;
  return T.createElement(
    "div",
    { className: "sendbird-connection-status" },
    T.createElement(Fe, { type: oe.BODY_2, color: ie.ONBACKGROUND_2 }, e.TRYING_TO_CONNECT),
    T.createElement(dt, { type: Le.DISCONNECTED, fillColor: Pe.SENT, width: "14px", height: "14px" })
  );
}
function Vh(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.width, a = l === void 0 ? "26px" : l, d = e.height, r = d === void 0 ? "26px" : d, i = e.children;
  return T.createElement("div", { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
    "sendbird-loader"
  ], !1).join(" "), style: {
    width: typeof a == "string" ? a : "".concat(a, "px"),
    height: typeof r == "string" ? r : "".concat(r, "px")
  } }, i || T.createElement(dt, { type: Le.SPINNER, width: "26px", height: "26px" }));
}
var _n = {
  LOADING: "LOADING",
  NO_CHANNELS: "NO_CHANNELS",
  NO_MESSAGES: "NO_MESSAGES",
  WRONG: "WRONG",
  SEARCH_IN: "SEARCH_IN",
  SEARCHING: "SEARCHING",
  NO_RESULTS: "NO_RESULTS"
};
function rV(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.type, a = e.iconSize, d = e.searchInString, r = d === void 0 ? "" : d, i = e.retryToConnect, c = i === void 0 ? null : i, V = Gt(Kn).stringSet;
  return T.createElement(
    "div",
    { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
      "sendbird-place-holder"
    ], !1).join(" ") },
    l === _n.LOADING && T.createElement(
      Vh,
      { width: a || "48px", height: a || "48px" },
      T.createElement(dt, { type: Le.SPINNER, fillColor: Pe.PRIMARY, width: a || "48px", height: a || "48px" })
    ),
    (l === _n.NO_CHANNELS || l === _n.NO_MESSAGES || l === _n.WRONG) && T.createElement(
      "div",
      { className: "sendbird-place-holder__body" },
      l === _n.NO_CHANNELS && T.createElement(dt, { className: "sendbird-place-holder__body__icon", type: Le.CHAT, fillColor: Pe.ON_BACKGROUND_3, width: a || "64px", height: a || "64px" }),
      l === _n.WRONG && T.createElement(dt, { className: "sendbird-place-holder__body__icon", type: Le.ERROR, fillColor: Pe.ON_BACKGROUND_3, width: a || "64px", height: a || "64px" }),
      l === _n.NO_MESSAGES && T.createElement(dt, { className: "sendbird-place-holder__body__icon", type: Le.MESSAGE, fillColor: Pe.ON_BACKGROUND_3, width: a || "64px", height: a || "64px" }),
      T.createElement(
        Fe,
        { className: "sendbird-place-holder__body__text", type: oe.BODY_1, color: ie.ONBACKGROUND_2 },
        l === _n.NO_CHANNELS && V.PLACE_HOLDER__NO_CHANNEL,
        l === _n.WRONG && V.PLACE_HOLDER__WRONG,
        l === _n.NO_MESSAGES && V.PLACE_HOLDER__NO_MESSAGES
      ),
      c && T.createElement(
        "div",
        { className: "sendbird-place-holder__body__reconnect", role: "button", onClick: c, onKeyPress: c, tabIndex: 0 },
        T.createElement(dt, { className: "sendbird-place-holder__body__reconnect__icon", type: Le.REFRESH, fillColor: Pe.PRIMARY, width: "20px", height: "20px" }),
        T.createElement(Fe, { className: "sendbird-place-holder__body__reconnect__text", type: oe.BUTTON_1, color: ie.PRIMARY }, V.PLACE_HOLDER__RETRY_TO_CONNECT)
      )
    ),
    (l === _n.NO_RESULTS || l === _n.SEARCH_IN || l === _n.SEARCHING) && T.createElement(
      "div",
      { className: "sendbird-place-holder__body--align-top" },
      l === _n.SEARCH_IN && T.createElement(
        "div",
        { className: "sendbird-place-holder__body--align-top__text" },
        T.createElement(Fe, { className: "sendbird-place-holder__body--align-top__text__search-in", type: oe.BUTTON_2, color: ie.ONBACKGROUND_2 }, V.SEARCH_IN),
        T.createElement(Fe, { className: "sendbird-place-holder__body--align-top__text__channel-name", type: oe.BUTTON_2, color: ie.PRIMARY }, "'".concat(r)),
        T.createElement(Fe, { className: "sendbird-place-holder__body--align-top__text__quote", type: oe.BUTTON_2, color: ie.PRIMARY }, "'")
      ),
      l === _n.SEARCHING && T.createElement(Fe, { className: "sendbird-place-hlder__body--align-top__searching", type: oe.BODY_1, color: ie.ONBACKGROUND_2 }, V.SEARCHING),
      l === _n.NO_RESULTS && T.createElement(Fe, { className: "sendbird-place-hlder__body--align-top__no-result", type: oe.BODY_1, color: ie.ONBACKGROUND_2 }, V.NO_SEARCHED_MESSAGE)
    )
  );
}
var R4 = function(e) {
  var n, t, l, a, d = e.isLoading, r = e.isInvalid, i = e.channelUrl, c = e.renderChannelHeader, V = e.renderMessageList, s = e.renderMessageInput, o = e.renderTypingIndicator, U = e.renderPlaceholderLoader, N = e.renderPlaceholderInvalid, R = zn(), h = R.stores, Z = R.config, W = (n = h == null ? void 0 : h.sdkStore) === null || n === void 0 ? void 0 : n.error, F = Z.logger, m = Z.isOnline;
  return d ? T.createElement("div", { className: "sendbird-conversation" }, (U == null ? void 0 : U()) || T.createElement(rV, { type: _n.LOADING })) : i ? r ? T.createElement("div", { className: "sendbird-conversation" }, (N == null ? void 0 : N()) || T.createElement(rV, { type: _n.WRONG })) : W ? T.createElement("div", { className: "sendbird-conversation" }, (N == null ? void 0 : N()) || T.createElement(rV, { type: _n.WRONG, retryToConnect: function() {
    F.info("Channel: reconnecting");
  } })) : T.createElement(
    "div",
    { className: "sendbird-conversation" },
    c == null ? void 0 : c({ className: "sendbird-conversation__channel-header" }),
    V == null ? void 0 : V(e),
    T.createElement(
      "div",
      { className: "sendbird-conversation__footer" },
      s == null ? void 0 : s(),
      T.createElement(
        "div",
        { className: "sendbird-conversation__footer__typing-indicator" },
        (o == null ? void 0 : o()) || ((t = Z == null ? void 0 : Z.groupChannel) === null || t === void 0 ? void 0 : t.enableTypingIndicator) && ((a = (l = Z == null ? void 0 : Z.groupChannel) === null || l === void 0 ? void 0 : l.typingIndicatorTypes) === null || a === void 0 ? void 0 : a.has(uR.Text)) && T.createElement(U4, { channelUrl: i }),
        !m && T.createElement(N4, null)
      )
    )
  ) : T.createElement("div", { className: "sendbird-conversation" }, (N == null ? void 0 : N()) || T.createElement(rV, { type: _n.NO_CHANNELS }));
}, pR = function(e) {
  return e ? e.isFrozen && e.myRole !== "operator" : !1;
}, Yo = function(e) {
  return e ? e.myMutedState === "muted" : !1;
};
function GM(e) {
  if (e) {
    var n = e.querySelectorAll("[data-sb-mention='true']"), t = Array.from(n);
    return t;
  }
  return [];
}
function NY(e, n) {
  var t = e.ref, l = n.logger, a = t.current, d = me([]), r = d[0], i = d[1];
  return ud(function() {
    if (a) {
      var c = GM(a);
      i(c);
    }
  }, [a]), _e(function() {
    var c = { childList: !0, subtree: !0 }, V = function(o) {
      var U = o.length > 0;
      U && i(GM(a));
    }, s = new MutationObserver(V);
    return a && s.observe(a, c), function() {
      try {
        s.disconnect();
      } catch {
        l.error("useDirtyGetMentions: observer disconnect failed", { observer: s });
      }
    };
  }, [a]), r;
}
var va;
(function(e) {
  e.ONBACKGROUND_1 = "ONBACKGROUND_1", e.ONBACKGROUND_2 = "ONBACKGROUND_2", e.ONBACKGROUND_3 = "ONBACKGROUND_3", e.ONBACKGROUND_4 = "ONBACKGROUND_4", e.ONCONTENT_1 = "ONCONTENT_1", e.ONCONTENT_2 = "ONCONTENT_2", e.PRIMARY = "PRIMARY", e.ERROR = "ERROR";
})(va || (va = {}));
var pF = function(e) {
  switch (e) {
    case va.ONBACKGROUND_1:
      return "sendbird-color--onbackground-1";
    case va.ONBACKGROUND_2:
      return "sendbird-color--onbackground-2";
    case va.ONBACKGROUND_3:
      return "sendbird-color--onbackground-3";
    case va.ONBACKGROUND_4:
      return "sendbird-color--onbackground-4";
    case va.ONCONTENT_1:
      return "sendbird-color--oncontent-1";
    case va.PRIMARY:
      return "sendbird-color--primary";
    case va.ERROR:
      return "sendbird-color--error";
    default:
      return null;
  }
}, h4 = function(e) {
  var n = e.children, t = n === void 0 ? null : n, l = e.className, a = l === void 0 ? "" : l, d = e.separatorColor, r = d === void 0 ? va.ONBACKGROUND_4 : d;
  return T.createElement(
    "div",
    { className: Ut(Ut([], Array.isArray(a) ? a : [a], !0), [
      "sendbird-separator"
    ], !1).join(" ") },
    T.createElement("div", { className: ["sendbird-separator__left", "".concat(pF(r), "--background-color")].join(" ") }),
    T.createElement("div", { className: "sendbird-separator__text" }, t || T.createElement(Fe, { type: oe.CAPTION_2, color: ie.ONBACKGROUND_2 }, "Date Separator")),
    T.createElement("div", { className: ["sendbird-separator__right", "".concat(pF(r), "--background-color")].join(" ") })
  );
}, Wd = {
  Enter: "Enter",
  ArrowUp: "ArrowUp",
  ArrowDown: "ArrowDown",
  Backspace: "Backspace"
}, MF = {
  ElementNode: 1,
  TextNode: 3
}, zZ = {
  Span: "SPAN",
  Br: "BR",
  Div: "DIV"
};
/*! @license DOMPurify 3.0.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.4/LICENSE */
const {
  entries: RY,
  setPrototypeOf: yM,
  isFrozen: Z4,
  getPrototypeOf: T4,
  getOwnPropertyDescriptor: F4
} = Object;
let {
  freeze: ra,
  seal: Ed,
  create: W4
} = Object, {
  apply: EF,
  construct: SF
} = typeof Reflect < "u" && Reflect;
EF || (EF = function(n, t, l) {
  return n.apply(t, l);
});
ra || (ra = function(n) {
  return n;
});
Ed || (Ed = function(n) {
  return n;
});
SF || (SF = function(n, t) {
  return new n(...t);
});
const m4 = rd(Array.prototype.forEach), BM = rd(Array.prototype.pop), ss = rd(Array.prototype.push), GN = rd(String.prototype.toLowerCase), xZ = rd(String.prototype.toString), u4 = rd(String.prototype.match), od = rd(String.prototype.replace), p4 = rd(String.prototype.indexOf), M4 = rd(String.prototype.trim), pa = rd(RegExp.prototype.test), os = E4(TypeError);
function rd(e) {
  return function(n) {
    for (var t = arguments.length, l = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
      l[a - 1] = arguments[a];
    return EF(e, n, l);
  };
}
function E4(e) {
  return function() {
    for (var n = arguments.length, t = new Array(n), l = 0; l < n; l++)
      t[l] = arguments[l];
    return SF(e, t);
  };
}
function an(e, n, t) {
  var l;
  t = (l = t) !== null && l !== void 0 ? l : GN, yM && yM(e, null);
  let a = n.length;
  for (; a--; ) {
    let d = n[a];
    if (typeof d == "string") {
      const r = t(d);
      r !== d && (Z4(n) || (n[a] = r), d = r);
    }
    e[d] = !0;
  }
  return e;
}
function KV(e) {
  const n = W4(null);
  for (const [t, l] of RY(e))
    n[t] = l;
  return n;
}
function tN(e, n) {
  for (; e !== null; ) {
    const l = F4(e, n);
    if (l) {
      if (l.get)
        return rd(l.get);
      if (typeof l.value == "function")
        return rd(l.value);
    }
    e = T4(e);
  }
  function t(l) {
    return console.warn("fallback value for", l), null;
  }
  return t;
}
const DM = ra(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), GZ = ra(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), yZ = ra(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), S4 = ra(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), BZ = ra(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), k4 = ra(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), XM = ra(["#text"]), OM = ra(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), DZ = ra(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), jM = ra(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), nN = ra(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), b4 = Ed(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Y4 = Ed(/<%[\w\W]*|[\w\W]*%>/gm), Q4 = Ed(/\${[\w\W]*}/gm), J4 = Ed(/^data-[\-\w.\u00B7-\uFFFF]/), v4 = Ed(/^aria-[\-\w]+$/), hY = Ed(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), z4 = Ed(/^(?:\w+script|data):/i), x4 = Ed(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), ZY = Ed(/^html$/i);
var HM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: b4,
  ERB_EXPR: Y4,
  TMPLIT_EXPR: Q4,
  DATA_ATTR: J4,
  ARIA_ATTR: v4,
  IS_ALLOWED_URI: hY,
  IS_SCRIPT_OR_DATA: z4,
  ATTR_WHITESPACE: x4,
  DOCTYPE_NAME: ZY
});
const G4 = () => typeof window > "u" ? null : window, y4 = function(n, t) {
  if (typeof n != "object" || typeof n.createPolicy != "function")
    return null;
  let l = null;
  const a = "data-tt-policy-suffix";
  t && t.hasAttribute(a) && (l = t.getAttribute(a));
  const d = "dompurify" + (l ? "#" + l : "");
  try {
    return n.createPolicy(d, {
      createHTML(r) {
        return r;
      },
      createScriptURL(r) {
        return r;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + d + " could not be created."), null;
  }
};
function TY() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : G4();
  const n = (Ee) => TY(Ee);
  if (n.version = "3.0.4", n.removed = [], !e || !e.document || e.document.nodeType !== 9)
    return n.isSupported = !1, n;
  const t = e.document, l = t.currentScript;
  let {
    document: a
  } = e;
  const {
    DocumentFragment: d,
    HTMLTemplateElement: r,
    Node: i,
    Element: c,
    NodeFilter: V,
    NamedNodeMap: s = e.NamedNodeMap || e.MozNamedAttrMap,
    HTMLFormElement: o,
    DOMParser: U,
    trustedTypes: N
  } = e, R = c.prototype, h = tN(R, "cloneNode"), Z = tN(R, "nextSibling"), W = tN(R, "childNodes"), F = tN(R, "parentNode");
  if (typeof r == "function") {
    const Ee = a.createElement("template");
    Ee.content && Ee.content.ownerDocument && (a = Ee.content.ownerDocument);
  }
  let m, E = "";
  const {
    implementation: u,
    createNodeIterator: b,
    createDocumentFragment: k,
    getElementsByTagName: Q
  } = a, {
    importNode: S
  } = t;
  let v = {};
  n.isSupported = typeof RY == "function" && typeof F == "function" && u && u.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: G,
    ERB_EXPR: w,
    TMPLIT_EXPR: y,
    DATA_ATTR: g,
    ARIA_ATTR: f,
    IS_SCRIPT_OR_DATA: I,
    ATTR_WHITESPACE: K
  } = HM;
  let {
    IS_ALLOWED_URI: Ue
  } = HM, q = null;
  const ae = an({}, [...DM, ...GZ, ...yZ, ...BZ, ...XM]);
  let se = null;
  const le = an({}, [...OM, ...DZ, ...jM, ...nN]);
  let L = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), $ = null, ee = null, O = !0, re = !0, te = !1, Qe = !0, Ye = !1, Se = !1, P = !1, ge = !1, Me = !1, We = !1, De = !1, Oe = !0, tt = !1;
  const Be = "user-content-";
  let He = !0, at = !1, Ge = {}, $e = null;
  const fe = an({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Xe = null;
  const pt = an({}, ["audio", "video", "img", "source", "image", "track"]);
  let Vt = null;
  const yt = an({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), xe = "http://www.w3.org/1998/Math/MathML", At = "http://www.w3.org/2000/svg", kt = "http://www.w3.org/1999/xhtml";
  let Kt = kt, ln = !1, vt = null;
  const Rt = an({}, [xe, At, kt], xZ);
  let Ke;
  const Je = ["application/xhtml+xml", "text/html"], de = "text/html";
  let qe, lt = null;
  const ct = a.createElement("form"), Ot = function(H) {
    return H instanceof RegExp || H instanceof Function;
  }, zt = function(H) {
    if (!(lt && lt === H)) {
      if ((!H || typeof H != "object") && (H = {}), H = KV(H), Ke = // eslint-disable-next-line unicorn/prefer-includes
      Je.indexOf(H.PARSER_MEDIA_TYPE) === -1 ? Ke = de : Ke = H.PARSER_MEDIA_TYPE, qe = Ke === "application/xhtml+xml" ? xZ : GN, q = "ALLOWED_TAGS" in H ? an({}, H.ALLOWED_TAGS, qe) : ae, se = "ALLOWED_ATTR" in H ? an({}, H.ALLOWED_ATTR, qe) : le, vt = "ALLOWED_NAMESPACES" in H ? an({}, H.ALLOWED_NAMESPACES, xZ) : Rt, Vt = "ADD_URI_SAFE_ATTR" in H ? an(
        KV(yt),
        // eslint-disable-line indent
        H.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        qe
        // eslint-disable-line indent
      ) : yt, Xe = "ADD_DATA_URI_TAGS" in H ? an(
        KV(pt),
        // eslint-disable-line indent
        H.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        qe
        // eslint-disable-line indent
      ) : pt, $e = "FORBID_CONTENTS" in H ? an({}, H.FORBID_CONTENTS, qe) : fe, $ = "FORBID_TAGS" in H ? an({}, H.FORBID_TAGS, qe) : {}, ee = "FORBID_ATTR" in H ? an({}, H.FORBID_ATTR, qe) : {}, Ge = "USE_PROFILES" in H ? H.USE_PROFILES : !1, O = H.ALLOW_ARIA_ATTR !== !1, re = H.ALLOW_DATA_ATTR !== !1, te = H.ALLOW_UNKNOWN_PROTOCOLS || !1, Qe = H.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Ye = H.SAFE_FOR_TEMPLATES || !1, Se = H.WHOLE_DOCUMENT || !1, Me = H.RETURN_DOM || !1, We = H.RETURN_DOM_FRAGMENT || !1, De = H.RETURN_TRUSTED_TYPE || !1, ge = H.FORCE_BODY || !1, Oe = H.SANITIZE_DOM !== !1, tt = H.SANITIZE_NAMED_PROPS || !1, He = H.KEEP_CONTENT !== !1, at = H.IN_PLACE || !1, Ue = H.ALLOWED_URI_REGEXP || hY, Kt = H.NAMESPACE || kt, L = H.CUSTOM_ELEMENT_HANDLING || {}, H.CUSTOM_ELEMENT_HANDLING && Ot(H.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (L.tagNameCheck = H.CUSTOM_ELEMENT_HANDLING.tagNameCheck), H.CUSTOM_ELEMENT_HANDLING && Ot(H.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (L.attributeNameCheck = H.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), H.CUSTOM_ELEMENT_HANDLING && typeof H.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (L.allowCustomizedBuiltInElements = H.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ye && (re = !1), We && (Me = !0), Ge && (q = an({}, [...XM]), se = [], Ge.html === !0 && (an(q, DM), an(se, OM)), Ge.svg === !0 && (an(q, GZ), an(se, DZ), an(se, nN)), Ge.svgFilters === !0 && (an(q, yZ), an(se, DZ), an(se, nN)), Ge.mathMl === !0 && (an(q, BZ), an(se, jM), an(se, nN))), H.ADD_TAGS && (q === ae && (q = KV(q)), an(q, H.ADD_TAGS, qe)), H.ADD_ATTR && (se === le && (se = KV(se)), an(se, H.ADD_ATTR, qe)), H.ADD_URI_SAFE_ATTR && an(Vt, H.ADD_URI_SAFE_ATTR, qe), H.FORBID_CONTENTS && ($e === fe && ($e = KV($e)), an($e, H.FORBID_CONTENTS, qe)), He && (q["#text"] = !0), Se && an(q, ["html", "head", "body"]), q.table && (an(q, ["tbody"]), delete $.tbody), H.TRUSTED_TYPES_POLICY) {
        if (typeof H.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw os('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof H.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw os('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        m = H.TRUSTED_TYPES_POLICY, E = m.createHTML("");
      } else
        m === void 0 && (m = y4(N, l)), m !== null && typeof E == "string" && (E = m.createHTML(""));
      ra && ra(H), lt = H;
    }
  }, cn = an({}, ["mi", "mo", "mn", "ms", "mtext"]), mt = an({}, ["foreignobject", "desc", "title", "annotation-xml"]), sn = an({}, ["title", "style", "font", "a", "script"]), hn = an({}, GZ);
  an(hn, yZ), an(hn, S4);
  const ft = an({}, BZ);
  an(ft, k4);
  const qt = function(H) {
    let Ve = F(H);
    (!Ve || !Ve.tagName) && (Ve = {
      namespaceURI: Kt,
      tagName: "template"
    });
    const ye = GN(H.tagName), Zt = GN(Ve.tagName);
    return vt[H.namespaceURI] ? H.namespaceURI === At ? Ve.namespaceURI === kt ? ye === "svg" : Ve.namespaceURI === xe ? ye === "svg" && (Zt === "annotation-xml" || cn[Zt]) : !!hn[ye] : H.namespaceURI === xe ? Ve.namespaceURI === kt ? ye === "math" : Ve.namespaceURI === At ? ye === "math" && mt[Zt] : !!ft[ye] : H.namespaceURI === kt ? Ve.namespaceURI === At && !mt[Zt] || Ve.namespaceURI === xe && !cn[Zt] ? !1 : !ft[ye] && (sn[ye] || !hn[ye]) : !!(Ke === "application/xhtml+xml" && vt[H.namespaceURI]) : !1;
  }, jt = function(H) {
    ss(n.removed, {
      element: H
    });
    try {
      H.parentNode.removeChild(H);
    } catch {
      H.remove();
    }
  }, Bt = function(H, Ve) {
    try {
      ss(n.removed, {
        attribute: Ve.getAttributeNode(H),
        from: Ve
      });
    } catch {
      ss(n.removed, {
        attribute: null,
        from: Ve
      });
    }
    if (Ve.removeAttribute(H), H === "is" && !se[H])
      if (Me || We)
        try {
          jt(Ve);
        } catch {
        }
      else
        try {
          Ve.setAttribute(H, "");
        } catch {
        }
  }, Ie = function(H) {
    let Ve, ye;
    if (ge)
      H = "<remove></remove>" + H;
    else {
      const Ct = u4(H, /^[\r\n\t ]+/);
      ye = Ct && Ct[0];
    }
    Ke === "application/xhtml+xml" && Kt === kt && (H = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + H + "</body></html>");
    const Zt = m ? m.createHTML(H) : H;
    if (Kt === kt)
      try {
        Ve = new U().parseFromString(Zt, Ke);
      } catch {
      }
    if (!Ve || !Ve.documentElement) {
      Ve = u.createDocument(Kt, "template", null);
      try {
        Ve.documentElement.innerHTML = ln ? E : Zt;
      } catch {
      }
    }
    const Mt = Ve.body || Ve.documentElement;
    return H && ye && Mt.insertBefore(a.createTextNode(ye), Mt.childNodes[0] || null), Kt === kt ? Q.call(Ve, Se ? "html" : "body")[0] : Se ? Ve.documentElement : Mt;
  }, it = function(H) {
    return b.call(
      H.ownerDocument || H,
      H,
      // eslint-disable-next-line no-bitwise
      V.SHOW_ELEMENT | V.SHOW_COMMENT | V.SHOW_TEXT,
      null,
      !1
    );
  }, ze = function(H) {
    return H instanceof o && (typeof H.nodeName != "string" || typeof H.textContent != "string" || typeof H.removeChild != "function" || !(H.attributes instanceof s) || typeof H.removeAttribute != "function" || typeof H.setAttribute != "function" || typeof H.namespaceURI != "string" || typeof H.insertBefore != "function" || typeof H.hasChildNodes != "function");
  }, ht = function(H) {
    return typeof i == "object" ? H instanceof i : H && typeof H == "object" && typeof H.nodeType == "number" && typeof H.nodeName == "string";
  }, Ft = function(H, Ve, ye) {
    v[H] && m4(v[H], (Zt) => {
      Zt.call(n, Ve, ye, lt);
    });
  }, X = function(H) {
    let Ve;
    if (Ft("beforeSanitizeElements", H, null), ze(H))
      return jt(H), !0;
    const ye = qe(H.nodeName);
    if (Ft("uponSanitizeElement", H, {
      tagName: ye,
      allowedTags: q
    }), H.hasChildNodes() && !ht(H.firstElementChild) && (!ht(H.content) || !ht(H.content.firstElementChild)) && pa(/<[/\w]/g, H.innerHTML) && pa(/<[/\w]/g, H.textContent))
      return jt(H), !0;
    if (!q[ye] || $[ye]) {
      if (!$[ye] && pe(ye) && (L.tagNameCheck instanceof RegExp && pa(L.tagNameCheck, ye) || L.tagNameCheck instanceof Function && L.tagNameCheck(ye)))
        return !1;
      if (He && !$e[ye]) {
        const Zt = F(H) || H.parentNode, Mt = W(H) || H.childNodes;
        if (Mt && Zt) {
          const Ct = Mt.length;
          for (let Ht = Ct - 1; Ht >= 0; --Ht)
            Zt.insertBefore(h(Mt[Ht], !0), Z(H));
        }
      }
      return jt(H), !0;
    }
    return H instanceof c && !qt(H) || (ye === "noscript" || ye === "noembed" || ye === "noframes") && pa(/<\/no(script|embed|frames)/i, H.innerHTML) ? (jt(H), !0) : (Ye && H.nodeType === 3 && (Ve = H.textContent, Ve = od(Ve, G, " "), Ve = od(Ve, w, " "), Ve = od(Ve, y, " "), H.textContent !== Ve && (ss(n.removed, {
      element: H.cloneNode()
    }), H.textContent = Ve)), Ft("afterSanitizeElements", H, null), !1);
  }, Ne = function(H, Ve, ye) {
    if (Oe && (Ve === "id" || Ve === "name") && (ye in a || ye in ct))
      return !1;
    if (!(re && !ee[Ve] && pa(g, Ve))) {
      if (!(O && pa(f, Ve))) {
        if (!se[Ve] || ee[Ve]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(pe(H) && (L.tagNameCheck instanceof RegExp && pa(L.tagNameCheck, H) || L.tagNameCheck instanceof Function && L.tagNameCheck(H)) && (L.attributeNameCheck instanceof RegExp && pa(L.attributeNameCheck, Ve) || L.attributeNameCheck instanceof Function && L.attributeNameCheck(Ve)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            Ve === "is" && L.allowCustomizedBuiltInElements && (L.tagNameCheck instanceof RegExp && pa(L.tagNameCheck, ye) || L.tagNameCheck instanceof Function && L.tagNameCheck(ye)))
          )
            return !1;
        } else if (!Vt[Ve]) {
          if (!pa(Ue, od(ye, K, ""))) {
            if (!((Ve === "src" || Ve === "xlink:href" || Ve === "href") && H !== "script" && p4(ye, "data:") === 0 && Xe[H])) {
              if (!(te && !pa(I, od(ye, K, "")))) {
                if (ye)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, pe = function(H) {
    return H.indexOf("-") > 0;
  }, we = function(H) {
    let Ve, ye, Zt, Mt;
    Ft("beforeSanitizeAttributes", H, null);
    const {
      attributes: Ct
    } = H;
    if (!Ct)
      return;
    const Ht = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: se
    };
    for (Mt = Ct.length; Mt--; ) {
      Ve = Ct[Mt];
      const {
        name: Sn,
        namespaceURI: bt
      } = Ve;
      if (ye = Sn === "value" ? Ve.value : M4(Ve.value), Zt = qe(Sn), Ht.attrName = Zt, Ht.attrValue = ye, Ht.keepAttr = !0, Ht.forceKeepAttr = void 0, Ft("uponSanitizeAttribute", H, Ht), ye = Ht.attrValue, Ht.forceKeepAttr || (Bt(Sn, H), !Ht.keepAttr))
        continue;
      if (!Qe && pa(/\/>/i, ye)) {
        Bt(Sn, H);
        continue;
      }
      Ye && (ye = od(ye, G, " "), ye = od(ye, w, " "), ye = od(ye, y, " "));
      const rn = qe(H.nodeName);
      if (Ne(rn, Zt, ye)) {
        if (tt && (Zt === "id" || Zt === "name") && (Bt(Sn, H), ye = Be + ye), m && typeof N == "object" && typeof N.getAttributeType == "function" && !bt)
          switch (N.getAttributeType(rn, Zt)) {
            case "TrustedHTML": {
              ye = m.createHTML(ye);
              break;
            }
            case "TrustedScriptURL": {
              ye = m.createScriptURL(ye);
              break;
            }
          }
        try {
          bt ? H.setAttributeNS(bt, Sn, ye) : H.setAttribute(Sn, ye), BM(n.removed);
        } catch {
        }
      }
    }
    Ft("afterSanitizeAttributes", H, null);
  }, Nt = function Ee(H) {
    let Ve;
    const ye = it(H);
    for (Ft("beforeSanitizeShadowDOM", H, null); Ve = ye.nextNode(); )
      Ft("uponSanitizeShadowNode", Ve, null), !X(Ve) && (Ve.content instanceof d && Ee(Ve.content), we(Ve));
    Ft("afterSanitizeShadowDOM", H, null);
  };
  return n.sanitize = function(Ee) {
    let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Ve, ye, Zt, Mt;
    if (ln = !Ee, ln && (Ee = "<!-->"), typeof Ee != "string" && !ht(Ee))
      if (typeof Ee.toString == "function") {
        if (Ee = Ee.toString(), typeof Ee != "string")
          throw os("dirty is not a string, aborting");
      } else
        throw os("toString is not a function");
    if (!n.isSupported)
      return Ee;
    if (P || zt(H), n.removed = [], typeof Ee == "string" && (at = !1), at) {
      if (Ee.nodeName) {
        const Sn = qe(Ee.nodeName);
        if (!q[Sn] || $[Sn])
          throw os("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Ee instanceof i)
      Ve = Ie("<!---->"), ye = Ve.ownerDocument.importNode(Ee, !0), ye.nodeType === 1 && ye.nodeName === "BODY" || ye.nodeName === "HTML" ? Ve = ye : Ve.appendChild(ye);
    else {
      if (!Me && !Ye && !Se && // eslint-disable-next-line unicorn/prefer-includes
      Ee.indexOf("<") === -1)
        return m && De ? m.createHTML(Ee) : Ee;
      if (Ve = Ie(Ee), !Ve)
        return Me ? null : De ? E : "";
    }
    Ve && ge && jt(Ve.firstChild);
    const Ct = it(at ? Ee : Ve);
    for (; Zt = Ct.nextNode(); )
      X(Zt) || (Zt.content instanceof d && Nt(Zt.content), we(Zt));
    if (at)
      return Ee;
    if (Me) {
      if (We)
        for (Mt = k.call(Ve.ownerDocument); Ve.firstChild; )
          Mt.appendChild(Ve.firstChild);
      else
        Mt = Ve;
      return (se.shadowroot || se.shadowrootmode) && (Mt = S.call(t, Mt, !0)), Mt;
    }
    let Ht = Se ? Ve.outerHTML : Ve.innerHTML;
    return Se && q["!doctype"] && Ve.ownerDocument && Ve.ownerDocument.doctype && Ve.ownerDocument.doctype.name && pa(ZY, Ve.ownerDocument.doctype.name) && (Ht = "<!DOCTYPE " + Ve.ownerDocument.doctype.name + `>
` + Ht), Ye && (Ht = od(Ht, G, " "), Ht = od(Ht, w, " "), Ht = od(Ht, y, " ")), m && De ? m.createHTML(Ht) : Ht;
  }, n.setConfig = function(Ee) {
    zt(Ee), P = !0;
  }, n.clearConfig = function() {
    lt = null, P = !1;
  }, n.isValidAttribute = function(Ee, H, Ve) {
    lt || zt({});
    const ye = qe(Ee), Zt = qe(H);
    return Ne(ye, Zt, Ve);
  }, n.addHook = function(Ee, H) {
    typeof H == "function" && (v[Ee] = v[Ee] || [], ss(v[Ee], H));
  }, n.removeHook = function(Ee) {
    if (v[Ee])
      return BM(v[Ee]);
  }, n.removeHooks = function(Ee) {
    v[Ee] && (v[Ee] = []);
  }, n.removeAllHooks = function() {
    v = {};
  }, n;
}
var ch = TY(), B4 = "sendbird-mention-user-label", FY = "sendbird-text-message-item-body", WY = "sendbird-og-message-item-body__text-bubble";
function kF(e) {
  var n = e.userId, t = e.nickname, l = '<span data-userid="'.concat(n, '" data-sb-mention="true" class="').concat(B4, '">').concat(t, "</span>"), a = ch(window), d = a.sanitize(l), r = d.split(" "), i = r[0], c = r.slice(1), V = Ut([i, 'contenteditable="false"'], c, !0).join(" ");
  return V;
}
var Qo = function(e) {
  return e == null ? void 0 : e.replace(/[\u00A0-\u9999<>]/gim, function(n) {
    return "".concat("&#", String(n.charCodeAt(0)), ";");
  });
}, yN = function(e) {
  try {
    return Array.from(e);
  } catch {
    return [];
  }
};
function D4(e) {
  var n;
  return e && ((n = e.isGroupChannel) === null || n === void 0 ? void 0 : n.call(e)) && !e.isBroadcast && !e.isSuper;
}
function XZ(e) {
  return e.nodeType === MF.ElementNode;
}
function fM(e) {
  var n = "", t = "";
  return e.forEach(function(l) {
    if (XZ(l) && l.nodeName === zZ.Span) {
      var a = l.innerText, d = l.dataset, r = d === void 0 ? {} : d, i = r.userid, c = i === void 0 ? "" : i;
      n += a, t += "".concat(no, "{").concat(c, "}");
    } else if (XZ(l) && l.nodeName === zZ.Br)
      n += `
`, t += `
`;
    else if (XZ(l) && l.nodeName === zZ.Div) {
      var V = l.textContent, s = V === void 0 ? "" : V;
      n += `
`.concat(s), t += `
`.concat(s);
    } else {
      var o = l.textContent, s = o === void 0 ? "" : o;
      n += s, t += s;
    }
  }), { messageText: n, mentionTemplate: t };
}
function X4(e) {
  var n = e.map(function(t) {
    var l = t.text, a = t.userId;
    return a ? kF({ userId: a, nickname: l }) : Qo(l);
  }).join(" ").concat(" ");
  document.execCommand("insertHTML", !1, n);
}
var wM = "sendbird-uikit__paste-node", O4 = "sendbird-word", mY = "sendbird-word__mention", uY = "sendbird-mention-user-label", pY = ".".concat(mY, ", .").concat(uY);
function gM(e, n) {
  var t = Ut([
    e
  ], Array.from(e.querySelectorAll(n)), !0).find(function(l) {
    return l.matches(n);
  });
  return t;
}
function j4(e) {
  var n = gM(e, ".".concat(WY));
  if (n)
    return yN(n.childNodes);
  var t = gM(e, ".".concat(FY));
  return yN(t ? t.childNodes : e.childNodes);
}
function H4() {
  var e = document.body.querySelector("#".concat(wM));
  e && (e == null || e.remove());
  var n = document.createElement("div");
  return n.id = wM, n.style.display = "none", n;
}
function f4(e) {
  return !!(e != null && e.querySelector(pY));
}
var MY = function(e) {
  var n = "";
  return e.forEach(function(t) {
    var l = t.querySelectorAll(".".concat(O4));
    l.length > 0 && (n += MY(Array.from(l)) + " "), n += t.innerText + " ";
  }), n;
};
function w4(e) {
  var n = e == null ? void 0 : e.reduce(function(t, l) {
    var a, d, r = l == null ? void 0 : l.innerText;
    if (l instanceof Text && (d = !1, r = l.textContent), l instanceof HTMLElement && (d = l.classList.contains(mY) || l.classList.contains(uY) ? l : l.querySelector(pY)), d) {
      var i = l == null ? void 0 : l.innerText, c = (a = d.dataset) === null || a === void 0 ? void 0 : a.userid;
      return Ut(Ut([], t, !0), [
        {
          text: i,
          userId: c
        }
      ], !1);
    }
    return Ut(Ut([], t, !0), [
      {
        text: r
      }
    ], !1);
  }, []);
  return n;
}
function g4(e, n) {
  var t = {}, l = n.members;
  return e.forEach(function(a) {
    if (a.userId) {
      var d = l.find(function(r) {
        return r.userId === a.userId;
      });
      d && (t[a.userId] = d);
    }
  }), Object.values(t);
}
function I4(e) {
  var n = e.ref, t = e.setIsInput, l = e.setHeight, a = e.channel, d = e.setMentionedUsers;
  return Pt(function(r) {
    r.preventDefault();
    var i = r == null ? void 0 : r.clipboardData.getData("text/html");
    if (!i) {
      var c = r == null ? void 0 : r.clipboardData.getData("text");
      document.execCommand("insertHTML", !1, Qo(c)), t(!0), l();
      return;
    }
    var V = ch(window), s = V.sanitize(i), o = H4();
    if (o.innerHTML = s, !f4(o)) {
      var c = MY(Array.from(o.children));
      document.execCommand("insertHTML", !1, Qo(c)), o.remove(), t(!0), l();
      return;
    }
    var U = j4(o), N = w4(U), R = a.isGroupChannel() ? g4(N, a) : [];
    d(R), X4(N), o.remove(), t(!0), l();
  }, [n, t, l, a, d]);
}
var iU = "@", ha = {
  string: "string",
  mention: "mention",
  url: "url",
  undetermined: "undetermined"
};
function L4(e, n) {
  var t = n || iU;
  return RegExp("(".concat(e.map(function(l) {
    var a = l.userId.replace(
      // If user.id includes these patterns, need to convert it into an escaped one
      /([.*+?^${}()|[\]\\])/g,
      "\\$1"
    );
    return "".concat(t, "\\{").concat(a, "\\}");
  }).join("|"), ")"), "g");
}
function C4(e) {
  var n = e.tokens, t = e.mentionedUsers, l = t === void 0 ? [] : t, a = e.templatePrefix, d = a === void 0 ? iU : a;
  if (!(l != null && l.length))
    return n;
  var r = L4(l, d), i = n.map(function(c) {
    if (c.type !== ha.undetermined)
      return c;
    var V = c.value, s = V.split(r), o = s.map(function(U) {
      if (U.match(r)) {
        var N = l.find(function(h) {
          return "@{".concat(h == null ? void 0 : h.userId, "}") === U;
        }), R = (N == null ? void 0 : N.nickname) || "(No name)";
        return { value: R, type: ha.mention, userId: N == null ? void 0 : N.userId };
      } else
        return { value: U, type: ha.undetermined };
    });
    return o;
  }).flat();
  return i;
}
function K4(e) {
  var n = /(?:https?:\/\/|www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.(xn--)?[a-z]{2,20}\b([-a-zA-Z0-9@:%_+[\],.~#?&/=]*[-a-zA-Z0-9@:%_+~#?&/=])*/g, t = e.map(function(l) {
    if (l.type !== ha.undetermined)
      return l;
    var a = l.value, d = a === void 0 ? "" : a, r = Array.from(d.matchAll(n)), i = r.map(function(s) {
      var o, U = s[0], N = (o = s.index) !== null && o !== void 0 ? o : 0, R = N + U.length;
      return { text: U, start: N, end: R };
    }), c = [{ value: d, type: ha.string }], V = 0;
    return i.forEach(function(s) {
      var o = s.text, U = s.start, N = s.end, R = c.pop().value, h = R.slice(0, U - V), Z = o, W = R.slice(N - V);
      h.length > 0 && c.push({ value: h, type: ha.string }), c.push({ value: Z, type: ha.url }), W.length > 0 && c.push({ value: W, type: ha.string }), V = N;
    }), c;
  }).flat();
  return t;
}
function _4(e) {
  var n = e.reduce(function(t, l) {
    var a = t[t.length - 1];
    return (a == null ? void 0 : a.type) === ha.string && l.type === ha.string ? (a.value = "".concat(a.value).concat(l.value), t) : Ut(Ut([], t, !0), [l], !1);
  }, []);
  return n;
}
function Jo(e) {
  var n = e.messageText, t = e.mentionedUsers, l = t === void 0 ? [] : t, a = e.templatePrefix, d = a === void 0 ? iU : a, r = [{
    type: ha.undetermined,
    value: n
  }], i = C4({
    tokens: r,
    mentionedUsers: l,
    templatePrefix: d
  }), c = K4(i), V = _4(c);
  return V;
}
function P4(e) {
  var n = " ", t = e.split(`
`), l = t.map(function(d) {
    var r, i, c = ((r = d.match(/^\s*/)) === null || r === void 0 ? void 0 : r[0]) || "", V = ((i = d.match(/\s*$/)) === null || i === void 0 ? void 0 : i[0]) || "", s = c.replace(/ /g, n), o = V.replace(/ /g, n);
    return s + d.trim() + o;
  }), a = l.join(`
`);
  return a;
}
var MR;
(function(e) {
  e.BASE = "base", e.GROUP = "group", e.OPEN = "open";
})(MR || (MR = {}));
var A4 = function(e) {
  var n = e.channel, t = e.config, l = Va(n == null ? void 0 : n.channelType).with(MR.GROUP, function() {
    var a;
    return (a = t == null ? void 0 : t.groupChannel) === null || a === void 0 ? void 0 : a.enableDocument;
  }).with(MR.OPEN, function() {
    var a;
    return (a = t == null ? void 0 : t.openChannel) === null || a === void 0 ? void 0 : a.enableDocument;
  }).otherwise(function() {
    return !0;
  });
  return l;
}, q4 = "sendbird-message-input-text-field", $4 = 76, eI = 600, Al = function() {
  return null;
}, tI = function(e, n) {
  var t = document.createRange(), l = window.getSelection();
  t.setStart(e.childNodes[0], n), t.collapse(!0), l.removeAllRanges(), l.addRange(t), e.focus();
}, OZ = function(e) {
  try {
    e.current.innerHTML = "";
  } catch {
  }
}, IM = {
  targetString: "",
  startNodeIndex: null,
  startOffsetIndex: null,
  endNodeIndex: null,
  endOffsetIndex: null
}, EY = T.forwardRef(function(e, n) {
  var t, l, a, d, r, i = e.channel, c = e.className, V = c === void 0 ? "" : c, s = e.messageFieldId, o = s === void 0 ? "" : s, U = e.isEdit, N = U === void 0 ? !1 : U, R = e.isMobile, h = R === void 0 ? !1 : R, Z = e.isMentionEnabled, W = Z === void 0 ? !1 : Z, F = e.isVoiceMessageEnabled, m = F === void 0 ? !0 : F, E = e.isSelectingMultipleFilesEnabled, u = E === void 0 ? !1 : E, b = e.disabled, k = b === void 0 ? !1 : b, Q = e.message, S = Q === void 0 ? null : Q, v = e.placeholder, G = v === void 0 ? "" : v, w = e.maxLength, y = w === void 0 ? 5e3 : w, g = e.onFileUpload, f = g === void 0 ? Al : g, I = e.onSendMessage, K = I === void 0 ? Al : I, Ue = e.onUpdateMessage, q = Ue === void 0 ? Al : Ue, ae = e.onCancelEdit, se = ae === void 0 ? Al : ae, le = e.onStartTyping, L = le === void 0 ? Al : le, $ = e.channelUrl, ee = $ === void 0 ? "" : $, O = e.mentionSelectedUser, re = O === void 0 ? null : O, te = e.onUserMentioned, Qe = te === void 0 ? Al : te, Ye = e.onMentionStringChange, Se = Ye === void 0 ? Al : Ye, P = e.onMentionedUserIdsUpdated, ge = P === void 0 ? Al : P, Me = e.onVoiceMessageIconClick, We = Me === void 0 ? Al : Me, De = e.onKeyUp, Oe = De === void 0 ? Al : De, tt = e.onKeyDown, Be = tt === void 0 ? Al : tt, He = e.renderFileUploadIcon, at = He === void 0 ? Al : He, Ge = e.renderVoiceMessageIcon, $e = Ge === void 0 ? Al : Ge, fe = e.renderSendMessageIcon, Xe = fe === void 0 ? Al : fe, pt = e.setMentionedUsers, Vt = pt === void 0 ? Al : pt, yt = e.acceptableMimeTypes, xe = n && "current" in n ? n : null, At = o || q4, kt = ca().stringSet, Kt = zn().config, ln = A4({
    channel: i,
    config: Kt
  }), vt = Wt(null), Rt = me(!1), Ke = Rt[0], Je = Rt[1], de = me([]), qe = de[0], lt = de[1], ct = me(ce({}, IM)), Ot = ct[0], zt = ct[1], cn = Pt(function() {
    var Ie = xe == null ? void 0 : xe.current;
    if (Ie)
      try {
        var it = window.document.body.offsetHeight || eI, ze = it * 0.6;
        Ie.scrollHeight >= $4 ? ze < Ie.scrollHeight ? (Ie.style.height = "auto", Ie.style.height = "".concat(ze, "px")) : (Ie.style.height = "auto", Ie.style.height = "".concat(Ie.scrollHeight, "px")) : Ie.style.height = "";
      } catch {
      }
  }, []), mt = e == null ? void 0 : e.value;
  _e(function() {
    var Ie, it = xe == null ? void 0 : xe.current;
    try {
      it.innerHTML = mt, tI(it, mt == null ? void 0 : mt.length);
    } catch {
    }
    lt([]), Je(((Ie = it == null ? void 0 : it.textContent) === null || Ie === void 0 ? void 0 : Ie.trim().length) > 0), cn();
  }, [mt]), _e(function() {
    N || (Je(!1), OZ(xe));
  }, [ee]), _e(function() {
    var Ie, it, ze;
    if (N && (S != null && S.messageId)) {
      var ht = xe == null ? void 0 : xe.current;
      if (W && ((Ie = S == null ? void 0 : S.mentionedUsers) === null || Ie === void 0 ? void 0 : Ie.length) > 0 && ((it = S == null ? void 0 : S.mentionedMessageTemplate) === null || it === void 0 ? void 0 : it.length) > 0) {
        var Ft = S.mentionedUsers, X = Ft === void 0 ? [] : Ft, Ne = Jo({
          messageText: S == null ? void 0 : S.mentionedMessageTemplate,
          mentionedUsers: X
        });
        ht.innerHTML = Ne.map(function(pe) {
          if (pe.type === ha.mention) {
            var we = X.find(function(Ee) {
              return Ee.userId === pe.userId;
            }), Nt = "".concat(iU).concat((we == null ? void 0 : we.nickname) || pe.value || kt.MENTION_NAME__NO_NAME);
            return kF({
              userId: pe.userId,
              nickname: Nt
            });
          }
          return Qo(pe.value);
        }).join(" ");
      } else {
        try {
          ht.innerHTML = Qo(S == null ? void 0 : S.message);
        } catch {
        }
        lt([]);
      }
      Je(((ze = ht == null ? void 0 : ht.textContent) === null || ze === void 0 ? void 0 : ze.trim().length) > 0), cn();
    }
  }, [N, S]);
  var sn = Pt(function() {
    var Ie, it = xe == null ? void 0 : xe.current;
    if (W) {
      var ze = Array.from(it.getElementsByClassName("sendbird-mention-user-label")).map(
        // @ts-ignore
        function(ht) {
          var Ft;
          return (Ft = ht == null ? void 0 : ht.dataset) === null || Ft === void 0 ? void 0 : Ft.userid;
        }
      );
      (!wj(qe, ze) || ze.length === 0) && (ge(ze), lt(ze));
    }
    Je(((Ie = it.textContent) === null || Ie === void 0 ? void 0 : Ie.trim().length) > 0);
  }, [Ot, W]);
  _e(function() {
    var Ie, it;
    if (W && re) {
      var ze = Ot.targetString, ht = Ot.startNodeIndex, Ft = Ot.startOffsetIndex, X = Ot.endNodeIndex, Ne = Ot.endOffsetIndex;
      if (ze && ht !== null && Ft !== null) {
        var pe = xe == null ? void 0 : xe.current, we = yN(pe == null ? void 0 : pe.childNodes), Nt = document == null ? void 0 : document.createTextNode((Ie = we[ht]) === null || Ie === void 0 ? void 0 : Ie.textContent.slice(0, Ft)), Ee = document == null ? void 0 : document.createTextNode(" ".concat((it = we[X]) === null || it === void 0 ? void 0 : it.textContent.slice(Ne))), H = kF({
          userId: re == null ? void 0 : re.userId,
          nickname: "".concat(no).concat((re == null ? void 0 : re.nickname) || kt.MENTION_NAME__NO_NAME)
        }), Ve = document.createElement("div");
        Ve.innerHTML = H;
        var ye = Ut(Ut(Ut([], we.slice(0, ht), !0), [
          Nt,
          Ve.childNodes[0],
          Ee
        ], !1), we.slice(X + 1), !0);
        if (pe.innerHTML = "", ye.forEach(function(Ct) {
          pe.appendChild(Ct);
        }), Qe(re), window.getSelection || document.getSelection) {
          var Zt = window.getSelection() || document.getSelection();
          Zt.removeAllRanges();
          var Mt = new Range();
          Mt.selectNodeContents(pe), Mt.setStart(pe.childNodes[ht + 2], 1), Mt.setEnd(pe.childNodes[ht + 2], 1), Mt.collapse(!1), Zt.addRange(Mt), pe.focus();
        }
        zt(ce({}, IM)), cn(), sn();
      }
    }
  }, [re, W]);
  var hn = Pt(function() {
    var Ie, it, ze = ((Ie = window == null ? void 0 : window.getSelection) === null || Ie === void 0 ? void 0 : Ie.call(window)) || ((it = document == null ? void 0 : document.getSelection) === null || it === void 0 ? void 0 : it.call(document)), ht = xe == null ? void 0 : xe.current;
    if (ze.anchorNode === ht && Se(""), W && ze && ze.anchorNode === ze.focusNode && ze.anchorOffset === ze.focusOffset)
      for (var Ft = "", X = null, Ne = null, pe = 0; pe < ht.childNodes.length; pe += 1) {
        var we = ht.childNodes[pe];
        if (we.nodeType === MF.TextNode) {
          var Nt = we === ze.anchorNode ? (we == null ? void 0 : we.textContent.slice(0, ze.anchorOffset)) || "" : (we == null ? void 0 : we.textContent) || "";
          if (Ft.length > 0)
            Ft += Nt;
          else {
            for (var Ee = Nt.lastIndexOf(no), H = Ee - 1; H > -1 && Nt[H] === no; H -= 1)
              Ee = H;
            Ee > -1 && (Ft = Nt, X = pe, Ne = Ee);
          }
        } else
          Ft = "", X = null, Ne = null;
        if (we === ze.anchorNode) {
          var Ve = Ft ? Ft.slice(Ne) : "";
          zt({
            targetString: Ve,
            startNodeIndex: X,
            startOffsetIndex: Ne,
            endNodeIndex: pe,
            endOffsetIndex: ze.anchorOffset
          }), Se(Ve);
          return;
        }
      }
  }, [W]), ft = function() {
    var Ie = xe == null ? void 0 : xe.current;
    if (!N && (Ie != null && Ie.textContent)) {
      var it = fM(Ie.childNodes), ze = it.messageText, ht = it.mentionTemplate, Ft = { message: ze, mentionTemplate: ht };
      K(Ft), OZ(xe), Ie.focus(), Je(!1), cn();
    }
  }, qt = !(!((l = (t = xe == null ? void 0 : xe.current) === null || t === void 0 ? void 0 : t.textContent) === null || l === void 0) && l.trim()), jt = function() {
    var Ie = xe == null ? void 0 : xe.current, it = S == null ? void 0 : S.messageId;
    if (N && it) {
      var ze = fM(Ie.childNodes), ht = ze.messageText, Ft = ze.mentionTemplate, X = { messageId: it, message: ht, mentionTemplate: Ft };
      q(X), OZ(xe);
    }
  }, Bt = I4({
    ref: xe,
    setMentionedUsers: Vt,
    channel: i,
    setIsInput: Je,
    setHeight: cn
  });
  return T.createElement(
    "form",
    { className: vn([
      V,
      N ? "sendbird-message-input__edit" : "",
      k ? "sendbird-message-input-form__disabled" : ""
    ]) },
    T.createElement(
      "div",
      { className: vn(["sendbird-message-input", k ? "sendbird-message-input__disabled" : ""]) },
      T.createElement("div", {
        id: "".concat(At).concat(N ? S == null ? void 0 : S.messageId : ""),
        className: "sendbird-message-input--textarea ".concat(At),
        contentEditable: !k,
        role: "textbox",
        "aria-label": "Text Input",
        ref: n,
        // @ts-ignore
        disabled: k,
        maxLength: y,
        onKeyDown: function(Ie) {
          var it, ze, ht, Ft, X, Ne, pe, we, Nt, Ee, H = Be(Ie);
          H ? Ie.preventDefault() : (!Ie.shiftKey && Ie.key === Wd.Enter && !h && ((ze = (it = xe == null ? void 0 : xe.current) === null || it === void 0 ? void 0 : it.textContent) === null || ze === void 0 ? void 0 : ze.trim().length) > 0 && ((ht = Ie == null ? void 0 : Ie.nativeEvent) === null || ht === void 0 ? void 0 : ht.isComposing) !== !0 && (gj(navigator.userAgent) || Ie.preventDefault(), ft()), Ie.key === Wd.Backspace && ((X = (Ft = xe == null ? void 0 : xe.current) === null || Ft === void 0 ? void 0 : Ft.childNodes) === null || X === void 0 ? void 0 : X.length) === 2 && !(!((we = (pe = (Ne = xe == null ? void 0 : xe.current) === null || Ne === void 0 ? void 0 : Ne.childNodes) === null || pe === void 0 ? void 0 : pe[0]) === null || we === void 0) && we.textContent) && ((Ee = (Nt = xe == null ? void 0 : xe.current.childNodes) === null || Nt === void 0 ? void 0 : Nt[1]) === null || Ee === void 0 ? void 0 : Ee.nodeType) === MF.ElementNode && (xe == null || xe.current.removeChild(xe == null ? void 0 : xe.current.childNodes[1])));
        },
        onKeyUp: function(Ie) {
          var it = Oe(Ie);
          it ? Ie.preventDefault() : hn();
        },
        onClick: function() {
          hn();
        },
        onInput: function() {
          var Ie, it;
          cn(), L(), Je(((it = (Ie = xe == null ? void 0 : xe.current) === null || Ie === void 0 ? void 0 : Ie.textContent) === null || it === void 0 ? void 0 : it.trim().length) > 0), sn();
        },
        onPaste: Bt
      }),
      ((r = (d = (a = xe == null ? void 0 : xe.current) === null || a === void 0 ? void 0 : a.textContent) === null || d === void 0 ? void 0 : d.length) !== null && r !== void 0 ? r : 0) === 0 && T.createElement(Fe, { className: "sendbird-message-input--placeholder", type: oe.BODY_1, color: k ? ie.ONBACKGROUND_4 : ie.ONBACKGROUND_3 }, G || kt.MESSAGE_INPUT__PLACE_HOLDER),
      !N && Ke && T.createElement(Fi, { className: "sendbird-message-input--send", height: "32px", width: "32px", onClick: function() {
        return ft();
      } }, (Xe == null ? void 0 : Xe()) || T.createElement(dt, { type: Le.SEND, fillColor: k ? Pe.ON_BACKGROUND_4 : Pe.PRIMARY, width: "20px", height: "20px" })),
      !N && !Ke && ((at == null ? void 0 : at()) || ln && T.createElement(
        Fi,
        { className: "sendbird-message-input--attach ".concat(m ? "is-voice-message-enabled" : ""), height: "32px", width: "32px", onClick: function() {
          var Ie, it;
          (it = (Ie = vt == null ? void 0 : vt.current) === null || Ie === void 0 ? void 0 : Ie.click) === null || it === void 0 || it.call(Ie);
        } },
        T.createElement(dt, { type: Le.ATTACH, fillColor: k ? Pe.ON_BACKGROUND_4 : Pe.CONTENT_INVERSE, width: "20px", height: "20px" }),
        T.createElement("input", {
          className: "sendbird-message-input--attach-input",
          type: "file",
          ref: vt,
          // It will affect to <Channel /> and <Thread />
          onChange: function(Ie) {
            var it = Ie.currentTarget.files;
            f(it && it.length === 1 ? [it[0]] : Array.from(it)), Ie.target.value = "";
          },
          accept: kj(yt),
          multiple: u && D4(i)
        })
      )),
      m && !N && !Ke && T.createElement(Fi, { className: "sendbird-message-input--voice-message", width: "32px", height: "32px", onClick: We }, ($e == null ? void 0 : $e()) || T.createElement(dt, { type: Le.AUDIO_ON_LINED, fillColor: k ? Pe.ON_BACKGROUND_4 : Pe.CONTENT_INVERSE, width: "20px", height: "20px" }))
    ),
    N && T.createElement(
      "div",
      { className: "sendbird-message-input--edit-action" },
      T.createElement(Ql, { className: "sendbird-message-input--edit-action__cancel", type: nl.SECONDARY, size: Ei.SMALL, onClick: se }, kt.BUTTON__CANCEL),
      T.createElement(Ql, { className: "sendbird-message-input--edit-action__save", type: nl.PRIMARY, size: Ei.SMALL, disabled: qt, onClick: function() {
        return jt();
      } }, kt.BUTTON__SAVE)
    )
  );
});
function LM(e) {
  Pn(1, arguments);
  var n = Wa(e);
  return n.setHours(0, 0, 0, 0), n;
}
function l1(e, n) {
  Pn(2, arguments);
  var t = LM(e), l = LM(n);
  return t.getTime() === l.getTime();
}
function nI(e) {
  return Pn(1, arguments), l1(e, Date.now());
}
function lI(e, n) {
  Pn(2, arguments);
  var t = Wa(e), l = Wa(n);
  return t.getFullYear() === l.getFullYear();
}
function aI(e) {
  return Pn(1, arguments), lI(e, Date.now());
}
function dI(e, n) {
  Pn(2, arguments);
  var t = Wa(e), l = xr(n);
  return isNaN(l) ? /* @__PURE__ */ new Date(NaN) : (l && t.setDate(t.getDate() + l), t);
}
function rI(e, n) {
  Pn(2, arguments);
  var t = xr(n);
  return dI(e, -t);
}
function iI(e) {
  return Pn(1, arguments), l1(e, rI(Date.now(), 1));
}
var VI = function(e) {
  var n, t = e.channel, l = e.locale, a = e.stringSet, d = a === void 0 ? wb : a, r = (n = t == null ? void 0 : t.lastMessage) === null || n === void 0 ? void 0 : n.createdAt, i = l ? { locale: l } : null;
  return r ? nI(r) ? Sr(r, "p", i) : iI(r) ? d.MESSAGE_STATUS__YESTERDAY || "Yesterday" : aI(r) ? Sr(r, "MMM d", i) : Sr(r, "yyyy/M/d", i) : "";
};
function cI(e) {
  var n, t, l, a = e.className, d = e.message, r = e.channel, i = e.isDateSeparatorConsidered, c = i === void 0 ? !0 : i, V = ca(), s = V.stringSet, o = V.dateLocale, U = Eb(r, d), N = ((l = r == null ? void 0 : r.isGroupChannel) === null || l === void 0 ? void 0 : l.call(r)) && (r.isSuper || r.isPublic || r.isBroadcast) && !(U === fn.PENDING || U === fn.FAILED), R = (n = {}, n[fn.SENT] = Le.DONE, n[fn.DELIVERED] = Le.DONE_ALL, n[fn.READ] = Le.DONE_ALL, n[fn.FAILED] = Le.ERROR, n), h = (t = {}, t[fn.SENT] = Pe.SENT, t[fn.DELIVERED] = Pe.SENT, t[fn.READ] = Pe.READ, t[fn.FAILED] = Pe.ERROR, t);
  return T.createElement(
    "div",
    { className: Ut(Ut([], Array.isArray(a) ? a : [a], !0), [
      "sendbird-message-status"
    ], !1).join(" ") },
    U === fn.PENDING ? T.createElement(
      Vh,
      { className: "sendbird-message-status__icon", width: "16px", height: "16px" },
      T.createElement(dt, { type: Le.SPINNER, fillColor: Pe.PRIMARY, width: "16px", height: "16px" })
    ) : T.createElement(dt, { className: "sendbird-message-status__icon ".concat(N ? "hide-icon" : "", " ").concat(U === fn.FAILED ? "" : "sendbird-message-status--sent"), type: R[U] || Le.ERROR, fillColor: h[U], width: "16px", height: "16px" }),
    Yj(U) && T.createElement(Fe, { className: "sendbird-message-status__text", type: oe.CAPTION_3, color: ie.ONBACKGROUND_2 }, c ? Sr((d == null ? void 0 : d.createdAt) || 0, "p", { locale: o }) : VI({ channel: r, locale: o, stringSet: s }))
  );
}
var CM = "sendbird-sort-by-row";
function sI(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.maxItemCount, a = e.itemWidth, d = e.itemHeight, r = e.children;
  if (Array.isArray(r) && r.length > l) {
    for (var i = [], c = 0; c < r.length; c += l)
      i.push(T.createElement("div", { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
        CM
      ], !1).join(" "), key: zr(), style: {
        width: a * l,
        height: d
      } }, r.slice(c, c + l)));
    return T.createElement(T.Fragment, null, i);
  }
  return T.createElement("div", { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
    CM
  ], !1).join(" "), style: {
    width: a * (Array.isArray(r) ? r.length : 1),
    height: d
  } }, r);
}
var oI = 60, UI = (
  /** @class */
  function(e) {
    nx(n, e);
    function n(t) {
      var l = e.call(this, t) || this;
      return l.menuRef = T.createRef(), l.setupEvents = function() {
        var a = l.props.closeDropdown, d = l.menuRef, r = function(i) {
          var c, V;
          d != null && d.current && !(!((V = (c = d == null ? void 0 : d.current) === null || c === void 0 ? void 0 : c.contains) === null || V === void 0) && V.call(c, i.target)) && (a == null || a());
        };
        l.setState({
          handleClickOutside: r
        }), document.addEventListener("mousedown", r);
      }, l.cleanUpEvents = function() {
        var a = l.state.handleClickOutside;
        document.removeEventListener("mousedown", a);
      }, l.getMenuPosition = function() {
        var a, d, r = l.props, i = r.parentRef, c = r.openLeft, V = (d = (a = i == null ? void 0 : i.current) === null || a === void 0 ? void 0 : a.getBoundingClientRect) === null || d === void 0 ? void 0 : d.call(a), s = (V == null ? void 0 : V.x) || (V == null ? void 0 : V.left) || 0, o = (V == null ? void 0 : V.y) || (V == null ? void 0 : V.top) || 0, U = {
          top: o,
          left: s
        };
        if (!l.menuRef.current)
          return U;
        var N = window.innerWidth, R = window.innerHeight, h = l.menuRef.current.getBoundingClientRect();
        if (o + h.height + oI > R && (U.top -= h.height), s + h.width > N && !c && (U.left -= h.width), U.top < 0 && (U.top = h.height < R ? (R - h.height) / 2 : 0), U.top += 32, c) {
          var Z = Number.isNaN(h.width - 30) ? 108 : h.width - 30;
          U.left -= Z;
        }
        return U.left < 0 && (U.left = h.width < N ? (N - h.width) / 2 : 0), l.setState({ menuStyle: U }), U;
      }, l.state = {
        menuStyle: {},
        handleClickOutside: function() {
        }
      }, l;
    }
    return n.prototype.componentDidMount = function() {
      this.setupEvents(), this.getMenuPosition();
    }, n.prototype.componentWillUnmount = function() {
      this.cleanUpEvents();
    }, n.prototype.render = function() {
      var t, l = this.state.menuStyle, a = this.props, d = a.children, r = a.style, i = a.className, c = i === void 0 ? "" : i;
      return Yi(T.createElement(
        "div",
        { className: (t = this.props) === null || t === void 0 ? void 0 : t.className },
        T.createElement("div", { className: "sendbird-dropdown__menu-backdrop" }),
        T.createElement("ul", { className: "".concat(c, " sendbird-dropdown__menu"), ref: this.menuRef, style: ce({ display: "inline-block", position: "fixed", left: "".concat(Math.round(l.left), "px"), top: "".concat(Math.round(l.top), "px") }, r) }, d)
      ), document.getElementById("sendbird-dropdown-portal"));
    }, n;
  }(T.Component)
), NI = { x: 0, y: 0, left: 0, top: 0, height: 0 }, RI = function(e) {
  var n = e.children, t = e.parentRef, l = e.parentContainRef, a = e.spaceFromTrigger, d = a === void 0 ? { x: 0, y: 0 } : a, r = e.closeDropdown, i = me({ left: 0, top: 0 }), c = i[0], V = i[1], s = Wt(null);
  _e(function() {
    return l && (l != null && l.current) && l.current.classList.add("sendbird-reactions--pressed"), function() {
      l && (l != null && l.current) && l.current.classList.remove("sendbird-reactions--pressed");
    };
  }, []), _e(function() {
    var U = function(N) {
      var R, h;
      s != null && s.current && !(!((h = (R = s == null ? void 0 : s.current) === null || R === void 0 ? void 0 : R.contains) === null || h === void 0) && h.call(R, N.target)) && r();
    };
    return document.addEventListener("mousedown", U), function() {
      document.removeEventListener("mousedown", U);
    };
  }, []), _e(function() {
    var U, N, R, h = (d == null ? void 0 : d.x) || 0, Z = (d == null ? void 0 : d.y) || 0, W = (N = (U = t == null ? void 0 : t.current) === null || U === void 0 ? void 0 : U.getBoundingClientRect()) !== null && N !== void 0 ? N : NI, F = W.x || W.left, m = W.y || W.top, E = {
      top: m,
      left: F
    };
    if (!(s != null && s.current))
      V(E);
    else {
      var u = (R = s == null ? void 0 : s.current) === null || R === void 0 ? void 0 : R.getBoundingClientRect();
      E.top < u.height ? (E.top += W.height, E.top += Z) : (E.top -= u.height, E.top -= Z), E.left -= u.width / 2, E.left += W.height / 2 - 2, E.left += h;
      var b = window.innerWidth - u.width;
      b < E.left && (E.left = b), E.left < 0 && (E.left = 0), V(E);
    }
  }, []);
  var o = document.getElementById("sendbird-emoji-list-portal");
  return o ? Yi(T.createElement(
    T.Fragment,
    null,
    T.createElement("div", { className: "sendbird-dropdown__menu-backdrop" }),
    T.createElement(
      "ul",
      { className: "sendbird-dropdown__reaction-bar", ref: s, style: {
        display: "inline-block",
        position: "fixed",
        left: "".concat(Math.round(c.left), "px"),
        top: "".concat(Math.round(c.top), "px")
      } },
      T.createElement(sI, { className: "sendbird-dropdown__reaction-bar__row", maxItemCount: 8, itemWidth: 44, itemHeight: 40 }, n)
    )
  ), o) : null;
}, hI = 13, VU = UI, SY = RI, Na = function(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.children, a = e.onClick, d = e.disable, r = d === void 0 ? !1 : d, i = e.dataSbId, c = i === void 0 ? "" : i, V = function(s) {
    !r && a && (a == null || a(s));
  };
  return T.createElement(
    "li",
    { className: vn([t, "sendbird-dropdown__menu-item", r ? "disable" : ""]), role: "menuitem", "aria-disabled": !!r, onClick: V, onKeyPress: function(s) {
      s.keyCode === hI && V(s);
    }, tabIndex: 0, "data-sb-id": c },
    T.createElement(Fe, { className: "sendbird-dropdown__menu-item__text", type: oe.SUBTITLE_2, color: r ? ie.ONBACKGROUND_4 : ie.ONBACKGROUND_1 }, l)
  );
};
function OV(e) {
  var n = e.menuTrigger, t = e.menuItems, l = e.isOpen, a = e.onClick, d = me(!1), r = d[0], i = d[1];
  return T.createElement(
    "div",
    { className: "sendbird-context-menu", style: { display: "inline" }, onClick: a },
    n == null ? void 0 : n(function() {
      return i(!r);
    }),
    (r || l) && t(function() {
      return i(!1);
    })
  );
}
var ZI = {
  OPERATOR: "operator",
  NONE: "none"
};
function TI(e) {
  var n, t = e.className, l = e.message, a = e.channel, d = e.isByMe, r = d === void 0 ? !1 : d, i = e.disabled, c = i === void 0 ? !1 : i, V = e.replyType, s = e.disableDeleteMessage, o = s === void 0 ? null : s, U = e.showEdit, N = e.showRemove, R = e.deleteMessage, h = e.resendMessage, Z = e.setQuoteMessage, W = e.setSupposedHover, F = e.onReplyInThread, m = e.onMoveToParentMessage, E = m === void 0 ? null : m, u = Gt(Kn).stringSet, b = Wt(null), k = Wt(null), Q = dd(l), S = !(a != null && a.isEphemeral) && dd(l) && So(l) && r, v = Ba(l) && (l == null ? void 0 : l.isResendable) && r, G = !(a != null && a.isEphemeral) && !Fd(l) && r, w = E !== null, y = !Ba(l) && !Fd(l) && ((n = a == null ? void 0 : a.isGroupChannel) === null || n === void 0 ? void 0 : n.call(a)) && !(a != null && a.isEphemeral) && ((a == null ? void 0 : a.isBroadcast) && (a == null ? void 0 : a.myRole) === ZI.OPERATOR || !(a != null && a.isBroadcast)), g = y && V === "QUOTE_REPLY", f = y && V === "THREAD" && !(l != null && l.parentMessageId) && F;
  return Q || g || f || w || S || v || G ? T.createElement(
    "div",
    { className: vn([t, "sendbird-message-item-menu"]), ref: k },
    T.createElement(OV, { menuTrigger: function(I) {
      return T.createElement(
        Fi,
        { className: "sendbird-message-item-menu__trigger", ref: b, width: "32px", height: "32px", onClick: function() {
          I(), W(!0);
        }, onBlur: function() {
          W(!1);
        } },
        T.createElement(dt, { className: "sendbird-message-item-menu__trigger__icon", type: Le.MORE, fillColor: Pe.CONTENT_INVERSE, width: "24px", height: "24px" })
      );
    }, menuItems: function(I) {
      var K, Ue = function() {
        I(), W(!1);
      };
      return T.createElement(
        VU,
        { className: "sendbird-message-item-menu__list", parentRef: b, parentContainRef: k, closeDropdown: Ue, openLeft: r },
        Q && T.createElement(Na, { className: "sendbird-message-item-menu__list__menu-item menu-item-copy", onClick: function() {
          jW(l == null ? void 0 : l.message), Ue();
        }, dataSbId: "ui_message_item_menu_copy" }, u.MESSAGE_MENU__COPY),
        g && T.createElement(Na, { className: "sendbird-message-item-menu__list__menu-item menu-item-reply", onClick: function() {
          Z(l), Ue();
        }, disable: (l == null ? void 0 : l.parentMessageId) > 0, dataSbId: "ui_message_item_menu_reply" }, u.MESSAGE_MENU__REPLY),
        f && T.createElement(Na, { className: "sendbird-message-item-menu__list__menu-item menu-item-thread", onClick: function() {
          F == null || F({ message: l }), Ue();
        }, dataSbId: "ui_message_item_menu_thread" }, u.MESSAGE_MENU__THREAD),
        w && T.createElement(Na, { className: "sendbird-message-item-menu__list__menu-item menu-item-open-channel", onClick: function() {
          E == null || E(), Ue();
        }, dataSbId: "ui_message_item_menu_open_in_channel" }, u.MESSAGE_MENU__OPEN_IN_CHANNEL),
        S && T.createElement(Na, { className: "sendbird-message-item-menu__list__menu-item menu-item-edit", onClick: function() {
          c || (U(!0), Ue());
        }, dataSbId: "ui_message_item_menu_edit" }, u.MESSAGE_MENU__EDIT),
        v && T.createElement(Na, { className: "sendbird-message-item-menu__list__menu-item menu-item-resend", onClick: function() {
          c || (h(l), Ue());
        }, dataSbId: "ui_message_item_menu_resend" }, u.MESSAGE_MENU__RESEND),
        G && T.createElement(Na, { className: "sendbird-message-item-menu__list__menu-item menu-item-delete", onClick: function() {
          Ba(l) ? R == null || R(l) : c || (N(!0), Ue());
        }, disable: typeof o == "boolean" ? o : ((K = l == null ? void 0 : l.threadInfo) === null || K === void 0 ? void 0 : K.replyCount) > 0, dataSbId: "ui_message_item_menu_delete" }, u.MESSAGE_MENU__DELETE)
      );
    } })
  ) : null;
}
var FI = 300;
function KM(e) {
  WI(e) && e.touches.length < 2 && e.preventDefault && e.preventDefault();
}
function WI(e) {
  return e && "touches" in e;
}
function cU(e, n) {
  var t = e.onLongPress, l = e.onClick, a = n === void 0 ? {} : n, d = a.delay, r = d === void 0 ? FI : d, i = a.shouldPreventDefault, c = i === void 0 ? !0 : i, V = a.shouldStopPropagation, s = V === void 0 ? !1 : V, o = dr().isMobile, U = me(!1), N = U[0], R = U[1], h = me(!1), Z = h[0], W = h[1], F = Wt(), m = Wt(), E = Pt(function(b) {
    b.persist();
    var k = ce({}, b);
    W(!1), s && b.stopPropagation(), c && b.target && (b.target.addEventListener("touchend", KM, {
      passive: !1
    }), m.current = b.target), F.current = setTimeout(function() {
      t(k), R(!0);
    }, r);
  }, [t, r, c, s, o]), u = Pt(function(b, k, Q) {
    k === void 0 && (k = !0), Q === void 0 && (Q = !1), W(!!Q), F != null && F.current && clearTimeout(F.current), k && !N && !Z && (l == null || l(b)), R(!1), c && m.current && m.current.removeEventListener("touchend", KM);
  }, [c, l, N, Z]);
  return {
    onMouseDown: function(b) {
      return E(b);
    },
    onMouseUp: function(b) {
      return u(b);
    },
    onMouseLeave: function(b) {
      return u(b, !1);
    },
    onTouchStart: function(b) {
      return E(b);
    },
    // setDragTriggered as true on touchmove, so that next onTouchEnd is ignored
    // if we dont do it, onClick?.(e) will be triggred, see inside clear()
    onTouchMove: function(b) {
      return u(b, !1, !0);
    },
    onTouchEnd: function(b) {
      return u(b);
    }
  };
}
var zc = T.forwardRef(function(e, n) {
  var t = e.className, l = e.width, a = e.height, d = e.selected, r = e.dataSbId, i = r === void 0 ? "" : r, c = e.onClick, V = e.children, s = cU({
    onLongPress: dl,
    onClick: c
  }, {
    shouldPreventDefault: !0,
    shouldStopPropagation: !0
  });
  return T.createElement(
    "div",
    ce({ className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
      "sendbird-reaction-button".concat(d ? "--selected" : "")
    ], !1).join(" "), ref: n, role: "button", style: { width: l, height: a } }, s, { tabIndex: 0, "data-sb-id": i }),
    T.createElement("div", { className: "sendbird-reaction-button__inner" }, V)
  );
});
function mI(e) {
  var n = e.className, t = e.message, l = e.userId, a = e.spaceFromTrigger, d = a === void 0 ? { x: 0, y: 0 } : a, r = e.emojiContainer, i = e.toggleReaction, c = e.setSupposedHover, V = Wt(null), s = Wt(null);
  return Fd(t) || Ba(t) ? null : T.createElement(
    "div",
    { className: vn([n, "sendbird-message-item-reaction-menu"]), ref: s },
    T.createElement(OV, { menuTrigger: function(o) {
      return T.createElement(
        Fi,
        { className: "sendbird-message-item-reaction-menu__trigger", ref: V, width: "32px", height: "32px", onClick: function() {
          o(), c(!0);
        }, onBlur: function() {
          c(!1);
        } },
        T.createElement(dt, { className: "sendbird-message-item-reaction-menu__trigger__icon", type: Le.EMOJI_MORE, fillColor: Pe.CONTENT_INVERSE, width: "24px", height: "24px" })
      );
    }, menuItems: function(o) {
      var U = function() {
        o(), c(!1);
      };
      return T.createElement(SY, { parentRef: V, parentContainRef: s, closeDropdown: U, spaceFromTrigger: d }, eh(r).map(function(N) {
        var R, h, Z, W = ((Z = (h = (R = t == null ? void 0 : t.reactions) === null || R === void 0 ? void 0 : R.find(function(F) {
          return F.key === N.key;
        })) === null || h === void 0 ? void 0 : h.userIds) === null || Z === void 0 ? void 0 : Z.some(function(F) {
          return F === l;
        })) || !1;
        return T.createElement(
          zc,
          { key: N.key, width: "36px", height: "36px", selected: W, onClick: function() {
            U(), i(t, N.key, W);
          }, dataSbId: "ui_emoji_reactions_menu_".concat(N.key) },
          T.createElement(el, { url: N.url, width: "28px", height: "28px", placeHolder: function(F) {
            var m = F.style;
            return T.createElement(
              "div",
              { style: m },
              T.createElement(dt, { type: Le.QUESTION, fillColor: Pe.ON_BACKGROUND_3, width: "28px", height: "28px" })
            );
          } })
        );
      }));
    } })
  );
}
var a1 = T.forwardRef(function(e, n) {
  var t = e.className, l = t === void 0 ? "" : t, a = e.children, d = e.count, r = d === void 0 ? "" : d, i = e.isAdd, c = i === void 0 ? !1 : i, V = e.selected, s = V === void 0 ? !1 : V, o = e.onClick, U = o === void 0 ? function() {
  } : o, N = function() {
    return s && !c ? "--selected" : c ? "--is-add" : "";
  };
  return T.createElement(
    "div",
    { className: Ut(Ut([], Array.isArray(l) ? l : [l], !0), [
      "sendbird-reaction-badge".concat(N())
    ], !1).join(" "), role: "button", ref: n, onClick: U, onKeyDown: U, onTouchEnd: U, tabIndex: 0 },
    T.createElement(
      "div",
      { className: "sendbird-reaction-badge__inner" },
      T.createElement("div", { className: "sendbird-reaction-badge__inner__icon" }, a),
      T.createElement(Fe, { className: a && r && "sendbird-reaction-badge__inner__count", type: oe.CAPTION_3, color: ie.ONBACKGROUND_1 }, r)
    )
  );
}), sh = function(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.children, a = e.onBackdropClick, d = Wt();
  return d.current = document.getElementById(ko), d.current || (d.current = document.createElement("div"), d.current.setAttribute("id", ko), document.body.appendChild(d.current)), Yi(T.createElement(
    "div",
    { className: "".concat(t, " sendbird-bottomsheet") },
    T.createElement("div", { className: "sendbird-bottomsheet__content", role: "dialog", "aria-modal": "true", "aria-expanded": "true" }, l),
    T.createElement("div", { className: `
          sendbird-bottomsheet__backdrop
        `, onClick: function(r) {
      r == null || r.stopPropagation(), a();
    } })
  ), d.current);
};
function uI(e) {
  var n = e.height, t = n === void 0 ? 24 : n, l = e.width, a = l === void 0 ? 24 : l;
  return T.createElement(
    "div",
    { className: "sendbird-muted-avatar", style: {
      height: "".concat(t, "px"),
      width: "".concat(a, "px")
    } },
    T.createElement(
      "div",
      { className: "sendbird-muted-avatar__icon" },
      T.createElement("div", { className: "sendbird-muted-avatar__bg", style: {
        height: "".concat(t, "px"),
        width: "".concat(a, "px")
      } }),
      T.createElement(dt, { type: Le.MUTE, fillColor: Pe.WHITE, width: "".concat(t - 8, "px"), height: "".concat(a - 8, "px") })
    )
  );
}
function pI(e) {
  var n = e.id, t = e.checked, l = t === void 0 ? !1 : t, a = e.disabled, d = e.onChange, r = me(l), i = r[0], c = r[1];
  return T.createElement(
    "label",
    { className: [
      "sendbird-checkbox",
      a ? "disabled" : ""
    ].join(" "), htmlFor: n },
    T.createElement("input", { disabled: a, id: n, type: "checkbox", checked: i, onClick: function() {
      a || c(!i);
    }, onChange: d }),
    T.createElement("span", { className: [
      "sendbird-checkbox--checkmark",
      a ? "disabled" : ""
    ].join(" ") })
  );
}
var MI = function(e) {
  var n = e.stores, t = n === void 0 ? {} : n, l = t.sdkStore, a = l === void 0 ? {} : l, d = a.sdk;
  return d;
}, kY = function(e) {
  var n = e.config, t = n === void 0 ? {} : n, l = t.pubSub;
  return l;
}, EI = function(e) {
  return function(n) {
    return new Promise(function(t, l) {
      var a = MI(e), d = kY(e);
      a || l(new Error("Sdk not found")), a.groupChannel || l(new Error("Not found GroupChannelModule")), a.groupChannel.createChannel && typeof a.groupChannel.createChannel == "function" || l(new Error('Not found the function "createChannel"')), a.groupChannel.createChannel(n).then(function(r) {
        t(r), d.publish(Xa.CREATE_CHANNEL, { channel: r });
      }).catch(l);
    });
  };
}, SI = (
  /** @class */
  function() {
    function e() {
      this._onPending = dl, this._onFailed = dl, this._onSucceeded = dl;
    }
    return e.prototype.triggerPending = function(n) {
      this._onPending(n);
    }, e.prototype.triggerFailed = function(n, t) {
      this._onFailed(n, t.isResendable ? t : null);
    }, e.prototype.triggerSucceeded = function(n) {
      this._onSucceeded(n);
    }, e.prototype.onPending = function(n) {
      return typeof n == "function" && (this._onPending = n), this;
    }, e.prototype.onFailed = function(n) {
      return typeof n == "function" && (this._onFailed = n), this;
    }, e.prototype.onSucceeded = function(n) {
      return typeof n == "function" && (this._onSucceeded = n), this;
    }, e;
  }()
), bY = function(e, n) {
  return n === void 0 && (n = []), function(t, l) {
    var a = new SI(), d = kY(e);
    return t.sendUserMessage(l).onFailed(function(r, i) {
      d.publish(Xa.SEND_MESSAGE_FAILED, { error: r, message: i, channel: t, publishingModules: n }), a.triggerFailed(r, i);
    }).onPending(function(r) {
      d.publish(Xa.SEND_MESSAGE_START, { message: r, channel: t, publishingModules: n }), a.triggerPending(r);
    }).onSucceeded(function(r) {
      d.publish(Xa.SEND_USER_MESSAGE, { message: r, channel: t, publishingModules: n }), a.triggerSucceeded(r);
    }), a;
  };
};
function d1(e) {
  var n, t, l = e.user, a = e.currentUserId, d = e.disableMessaging, r = d === void 0 ? !1 : d, i = e.onSuccess, c = zn(), V = EI(c), s = (n = c == null ? void 0 : c.config) === null || n === void 0 ? void 0 : n.logger, o = Gt(Kn).stringSet, U = a || ((t = c == null ? void 0 : c.config) === null || t === void 0 ? void 0 : t.userId), N = Gt(nh).onUserProfileMessage;
  return T.createElement(
    "div",
    { className: "sendbird__user-profile" },
    T.createElement(
      "section",
      { className: "sendbird__user-profile-avatar" },
      T.createElement(da, { height: "80px", width: "80px", src: l == null ? void 0 : l.profileUrl })
    ),
    T.createElement(
      "section",
      { className: "sendbird__user-profile-name" },
      T.createElement(Fe, { type: oe.H_2, color: ie.ONBACKGROUND_1 }, (l == null ? void 0 : l.nickname) || o.NO_NAME)
    ),
    (l == null ? void 0 : l.userId) !== U && !r && T.createElement(
      "section",
      { className: "sendbird__user-profile-message" },
      T.createElement(Ql, { type: nl.SECONDARY, onClick: function() {
        var R = {
          isDistinct: !1,
          invitedUserIds: [l == null ? void 0 : l.userId],
          operatorUserIds: [U]
        };
        i(), V(R).then(function(h) {
          s.info("UserProfile, channel create", h), typeof N == "function" && (N == null || N(h));
        });
      } }, o.USER_PROFILE__MESSAGE)
    ),
    T.createElement("div", { className: "sendbird__user-profile-separator" }),
    T.createElement(
      "section",
      { className: "sendbird__user-profile-userId" },
      T.createElement(Fe, { className: "sendbird__user-profile-userId--label", type: oe.CAPTION_2, color: ie.ONBACKGROUND_2 }, o.USER_PROFILE__USER_ID),
      T.createElement(Fe, { className: "sendbird__user-profile-userId--value", type: oe.BODY_1, color: ie.ONBACKGROUND_1 }, l == null ? void 0 : l.userId)
    )
  );
}
function kI(e) {
  var n = e.user, t = e.className, l = e.checked, a = e.checkBox, d = e.isOperator, r = e.disabled, i = e.disableMessaging, c = e.currentUser, V = e.action, s = e.onChange, o = e.avatarSize, U = o === void 0 ? "40px" : o, N = e.onClick, R = n.userId, h = T.useRef(null), Z = T.useRef(null), W = T.useRef(null), F = Gt(nh), m = F.disableUserProfile, E = F.renderUserProfile, u = Gt(Kn).stringSet;
  return T.createElement(
    "div",
    { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
      "sendbird-user-list-item"
    ], !1).join(" "), ref: Z },
    (n == null ? void 0 : n.isMuted) && T.createElement(uI, { height: 40, width: 40 }),
    T.createElement(OV, { menuTrigger: function(b) {
      return T.createElement(da, { className: "sendbird-user-list-item__avatar", ref: W, src: n.profileUrl, width: U, height: U, onClick: function() {
        m || (b(), N == null || N());
      } });
    }, menuItems: function(b) {
      return E ? E({
        user: n,
        currentUserId: c,
        close: b,
        avatarRef: W
      }) : T.createElement(
        VU,
        {
          openLeft: !0,
          parentRef: W,
          // for catching location(x, y) of MenuItems
          parentContainRef: W,
          // for toggling more options(menus & reactions)
          closeDropdown: b,
          style: { paddingTop: "0px", paddingBottom: "0px" }
        },
        T.createElement(d1, { disableMessaging: i, user: n, currentUserId: c, onSuccess: b })
      );
    } }),
    T.createElement(
      Fe,
      { className: "sendbird-user-list-item__title", type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 },
      n.nickname || u.NO_NAME,
      c === n.userId && " (You)"
    ),
    !n.nickname && T.createElement(Fe, { className: "sendbird-user-list-item__subtitle", type: oe.CAPTION_3, color: ie.ONBACKGROUND_2 }, n.userId),
    a && T.createElement(
      "label",
      { className: "sendbird-user-list-item__checkbox", htmlFor: R },
      T.createElement(pI, { id: R, checked: l, disabled: r, onChange: function(b) {
        return s(b);
      } })
    ),
    d && T.createElement(Fe, { className: [
      "sendbird-user-list-item__operator",
      a ? "checkbox" : ""
    ].join(" "), type: oe.SUBTITLE_2, color: ie.ONBACKGROUND_2 }, u.LABEL__OPERATOR),
    V && T.createElement("div", { className: "sendbird-user-list-item__action", ref: h }, V({ actionRef: h, parentRef: Z }))
  );
}
function bI(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.children, a = l === void 0 ? "" : l;
  return T.createElement(
    "div",
    { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
      "sendbird-tooltip"
    ], !1).join(" ") },
    T.createElement(Fe, { className: "sendbird-tooltip__text", type: oe.CAPTION_2, color: ie.ONCONTENT_1 }, a)
  );
}
var YI = 8;
function QI(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.children, a = e.hoverTooltip, d = me(!1), r = d[0], i = d[1], c = Wt(null);
  return T.createElement(
    "div",
    { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
      "sendbird-tooltip-wrapper"
    ], !1).join(" "), onMouseOver: function() {
      i(!0);
    }, onFocus: function() {
      i(!0);
    }, onMouseOut: function() {
      i(!1);
    }, onBlur: function() {
      i(!1);
    } },
    T.createElement("div", { className: "sendbird-tooltip-wrapper__children", ref: c }, l),
    r && T.createElement(
      "div",
      { className: "sendbird-tooltip-wrapper__hover-tooltip", style: { bottom: "calc(100% + ".concat(YI, "px)") } },
      T.createElement(
        "div",
        { className: "sendbird-tooltip-wrapper__hover-tooltip__inner" },
        T.createElement("div", { className: "sendbird-tooltip-wrapper__hover-tooltip__inner__tooltip-container", style: { left: c.current && "calc(".concat(c.current.offsetWidth / 2, "px - 50%)") } }, a)
      )
    )
  );
}
var JI = {
  message: {},
  isByMe: !1
}, YY = T.createContext(JI), _M = function(e) {
  var n = e.children, t = e.message, l = e.isByMe, a = l === void 0 ? !1 : l;
  return T.createElement(YY.Provider, { value: {
    message: t,
    isByMe: a
  } }, n);
}, QY = function() {
  var e = T.useContext(YY);
  if (e === void 0)
    throw new Error("useMessageContext must be used within a MessageProvider");
  return e;
}, vI = function(e) {
  var n, t, l, a = e.message, d = e.channel, r = e.emojiKey, i = r === void 0 ? "" : r, c = e.hideMenu, V = e.emojiContainer, s = e.onPressUserProfileHandler, o = d.members, U = o === void 0 ? [] : o, N = me(i), R = N[0], h = N[1];
  function Z() {
    if (s && a) {
      var W = a == null ? void 0 : a.sender;
      s(W);
    }
  }
  return T.createElement(
    sh,
    { onBackdropClick: c },
    T.createElement(
      "div",
      { className: "sendbird-message__bottomsheet" },
      T.createElement("div", { className: "sendbird-message__bottomsheet__reacted-members" }, (n = a.reactions) === null || n === void 0 ? void 0 : n.map(function(W) {
        var F = jj(V, W.key);
        return T.createElement(
          "div",
          { key: W.key, className: `
                  sendbird-message__bottomsheet__reacted-members__item
                  `.concat(R === W.key ? "sendbird-message__bottomsheet__reacted-members__item__selected" : "", `
                `), onClick: function() {
            h(W.key);
          } },
          T.createElement(el, { url: F, width: "28px", height: "28px", placeHolder: function(m) {
            var E = m.style;
            return T.createElement(
              "div",
              { style: E },
              T.createElement(dt, { type: Le.QUESTION, fillColor: Pe.ON_BACKGROUND_3, width: "28px", height: "28px" })
            );
          } }),
          T.createElement(Fe, { type: oe.BUTTON_2, color: R === W.key ? ie.PRIMARY : ie.ONBACKGROUND_3 }, W.userIds.length)
        );
      })),
      T.createElement(
        "div",
        { className: "sendbird-message__bottomsheet__reactor-list" },
        // making a member list who reacted to the message with the `selectedEmoji`
        ((l = (t = a.reactions) === null || t === void 0 ? void 0 : t.find(function(W) {
          return W.key === R;
        })) === null || l === void 0 ? void 0 : l.userIds.map(function(W) {
          return U.find(function(F) {
            return F.userId === W;
          });
        }).filter(function(W) {
          return W !== void 0;
        })).map(function(W) {
          return T.createElement(kI, { key: W.userId, className: "sendbird-message__bottomsheet__reactor-list__item", user: W, avatarSize: "36px", onClick: Z });
        })
      )
    )
  );
};
function zI(e) {
  var n, t = e.reaction, l = e.memberNicknamesMap, a = e.setEmojiKey, d = e.toggleReaction, r = e.emojisMap, i = e.channel, c = e.message, V = zn(), s = dr().isMobile, o = QY(), U = Gt(Kn).stringSet, N = V.config.userId, R = Jb(N, t), h = t.userIds.length > 0 && (i == null ? void 0 : i.isGroupChannel()) && !i.isSuper, Z = function() {
    a(""), d == null || d(c ?? (o == null ? void 0 : o.message), t.key, R);
  }, W = cU({
    onLongPress: function() {
      a(t.key);
    },
    onClick: Z
  }, {
    shouldPreventDefault: !0,
    shouldStopPropagation: !0
  });
  return T.createElement(
    QI,
    { className: "sendbird-emoji-reactions__reaction-badge", hoverTooltip: h ? T.createElement(bI, null, Dj(t, N, l, U)) : T.createElement(T.Fragment, null) },
    T.createElement(
      "div",
      ce({}, s ? W : { onClick: Z }),
      T.createElement(
        a1,
        { count: t.userIds.length, selected: R },
        T.createElement(el, { circle: !0, url: ((n = r.get(t == null ? void 0 : t.key)) === null || n === void 0 ? void 0 : n.url) || "", width: "20px", height: "20px", defaultComponent: T.createElement(dt, { width: "20px", height: "20px", type: Le.QUESTION }) })
      )
    )
  );
}
var xI = function(e) {
  var n = e.onClick, t = cU({
    onLongPress: function() {
    },
    onClick: n
  }, {
    shouldPreventDefault: !0,
    shouldStopPropagation: !0
  });
  return T.createElement(
    "div",
    ce({ className: "sendbird-emoji-reactions__add-reaction-badge" }, t),
    T.createElement(
      a1,
      { isAdd: !0 },
      T.createElement(dt, { type: Le.EMOJI_MORE, fillColor: Pe.ON_BACKGROUND_3, width: "20px", height: "20px" })
    )
  );
}, GI = function(e) {
  var n = e.userId, t = e.message, l = e.emojiContainer, a = e.hideMenu, d = e.toggleReaction, r = nn(function() {
    return eh(l);
  }, [l]);
  return T.createElement(
    sh,
    { onBackdropClick: a },
    T.createElement("div", { className: "sendbird-message__bottomsheet sendbird-message__emojis-bottomsheet" }, r.map(function(i) {
      var c, V, s, o, U = (o = (s = (V = (c = t == null ? void 0 : t.reactions) === null || c === void 0 ? void 0 : c.find(function(N) {
        return N.key === i.key;
      })) === null || V === void 0 ? void 0 : V.userIds) === null || s === void 0 ? void 0 : s.some(function(N) {
        return N === n;
      })) !== null && o !== void 0 ? o : !1;
      return T.createElement(
        zc,
        { key: i.key, width: "44px", height: "44px", selected: U, onClick: function(N) {
          N == null || N.stopPropagation(), d == null || d(t, i.key, U), a();
        }, dataSbId: "ui_mobile_emoji_reactions_menu_".concat(i.key) },
        T.createElement(el, { url: i.url, width: "38px", height: "38px", placeHolder: function(N) {
          var R = N.style;
          return T.createElement(
            "div",
            { style: R },
            T.createElement(dt, { type: Le.QUESTION, fillColor: Pe.ON_BACKGROUND_3, width: "28px", height: "28px" })
          );
        } })
      );
    }))
  );
}, yI = function(e) {
  var n, t, l, a, d, r = e.className, i = r === void 0 ? "" : r, c = e.userId, V = e.message, s = e.channel, o = e.emojiContainer, U = e.memberNicknamesMap, N = e.spaceFromTrigger, R = N === void 0 ? { x: 0, y: 0 } : N, h = e.isByMe, Z = h === void 0 ? !1 : h, W = e.toggleReaction, F = e.onPressUserProfile, m = dr().isMobile, E = Wt(null), u = me(!1), b = u[0], k = u[1], Q = me(""), S = Q[0], v = Q[1], G = Xj(o), w = ((t = (n = V.reactions) === null || n === void 0 ? void 0 : n.length) !== null && t !== void 0 ? t : 0) < G.size;
  return T.createElement(
    "div",
    { className: vn([
      i,
      "sendbird-emoji-reactions",
      Z ? "outgoing" : "incoming"
    ]) },
    ((a = (l = V.reactions) === null || l === void 0 ? void 0 : l.length) !== null && a !== void 0 ? a : 0) > 0 && ((d = V.reactions) === null || d === void 0 ? void 0 : d.map(function(y) {
      return T.createElement(zI, { key: y == null ? void 0 : y.key, reaction: y, memberNicknamesMap: U, setEmojiKey: v, toggleReaction: W, emojisMap: G, channel: s, message: V });
    })),
    !m && w && T.createElement(OV, { menuTrigger: function(y) {
      return T.createElement(
        a1,
        { className: "sendbird-emoji-reactions__add-reaction-badge", ref: E, isAdd: !0, onClick: function(g) {
          var f;
          y(), (f = g == null ? void 0 : g.stopPropagation) === null || f === void 0 || f.call(g);
        } },
        T.createElement(dt, { type: Le.EMOJI_MORE, fillColor: Pe.ON_BACKGROUND_3, width: "20px", height: "20px" })
      );
    }, menuItems: function(y) {
      return T.createElement(SY, { parentRef: E, parentContainRef: E, closeDropdown: y, spaceFromTrigger: R }, eh(o).map(function(g) {
        var f, I, K, Ue = ((K = (I = (f = V == null ? void 0 : V.reactions) === null || f === void 0 ? void 0 : f.find(function(q) {
          return q.key === g.key;
        })) === null || I === void 0 ? void 0 : I.userIds) === null || K === void 0 ? void 0 : K.some(function(q) {
          return q === c;
        })) || !1;
        return T.createElement(
          zc,
          { key: g.key, width: "36px", height: "36px", selected: Ue, onClick: function(q) {
            y(), W == null || W(V, g.key, Ue), q == null || q.stopPropagation();
          }, dataSbId: "ui_emoji_reactions_menu_".concat(g.key) },
          T.createElement(el, { url: (g == null ? void 0 : g.url) || "", width: "28px", height: "28px", placeHolder: function(q) {
            var ae = q.style;
            return T.createElement(
              "div",
              { style: ae },
              T.createElement(dt, { type: Le.QUESTION, fillColor: Pe.ON_BACKGROUND_3, width: "28px", height: "28px" })
            );
          } })
        );
      }));
    } }),
    m && w && T.createElement(xI, { onClick: function() {
      k(!0);
    } }),
    m && b && T.createElement(GI, { userId: c, message: V, emojiContainer: o, hideMenu: function() {
      k(!1);
    }, toggleReaction: W }),
    m && S && s !== null && T.createElement(vI, { message: V, channel: s, emojiKey: S, hideMenu: function() {
      v("");
    }, emojiContainer: o, onPressUserProfileHandler: F })
  );
};
function BI(e) {
  var n, t = e.className, l = t === void 0 ? "" : t, a = e.message;
  return !(a != null && a.isAdminMessage || a != null && a.messageType) || !(!((n = a == null ? void 0 : a.isAdminMessage) === null || n === void 0) && n.call(a)) || (a == null ? void 0 : a.messageType) !== "admin" ? null : T.createElement(
    "div",
    { className: Ut(Ut([], Array.isArray(l) ? l : [l], !0), [
      "sendbird-admin-message"
    ], !1).join(" ") },
    T.createElement(Fe, { className: "sendbird-admin-message__text", type: oe.CAPTION_2, color: ie.ONBACKGROUND_2 }, a == null ? void 0 : a.message)
  );
}
function ER(e) {
  return Va(e).when(wa, function() {
    var n;
    return (n = e == null ? void 0 : e.type) !== null && n !== void 0 ? n : "";
  }).when(Fa, function() {
    var n, t;
    return (t = (n = oh(e)) === null || n === void 0 ? void 0 : n.mimeType) !== null && t !== void 0 ? t : "";
  }).otherwise(function() {
    return "";
  });
}
function oh(e) {
  var n = e.fileInfoList;
  return n.length > 0 ? n[0] : null;
}
function JY(e) {
  return Va(e).when(wa, function() {
    var n;
    return (n = e == null ? void 0 : e.name) !== null && n !== void 0 ? n : "";
  }).when(Fa, function() {
    var n, t;
    return (t = (n = oh(e)) === null || n === void 0 ? void 0 : n.fileName) !== null && t !== void 0 ? t : "";
  }).otherwise(function() {
    return "";
  });
}
function SR(e) {
  return Va(e).when(wa, function() {
    var n;
    return (n = e == null ? void 0 : e.url) !== null && n !== void 0 ? n : "";
  }).when(Fa, function() {
    var n, t;
    return (t = (n = oh(e)) === null || n === void 0 ? void 0 : n.url) !== null && t !== void 0 ? t : "";
  }).otherwise(function() {
    return "";
  });
}
function DI(e) {
  return Va(e).when(wa, function() {
    return e.thumbnails;
  }).when(Fa, function() {
    var n, t;
    return (t = (n = oh(e)) === null || n === void 0 ? void 0 : n.thumbnails) !== null && t !== void 0 ? t : [];
  }).otherwise(function() {
    return [];
  });
}
function vY(e) {
  var n = DI(e);
  return n && n.length > 0 ? n[0].url : "";
}
function XI(e) {
  var n, t, l, a, d, r, i, c = e.message, V = e.userId, s = V === void 0 ? "" : V, o = e.isByMe, U = o === void 0 ? !1 : o, N = e.className, R = N === void 0 ? "" : N, h = e.isUnavailable, Z = h === void 0 ? !1 : h, W = e.onClick, F = Gt(Kn).stringSet, m = c.parentMessage, E = m == null ? void 0 : m.sender, u = s === (E == null ? void 0 : E.userId) ? F.QUOTED_MESSAGE__CURRENT_USER : E == null ? void 0 : E.nickname, b = SR(m), k = ER(m), Q = s === ((t = c == null ? void 0 : c.sender) === null || t === void 0 ? void 0 : t.userId) ? F.QUOTED_MESSAGE__CURRENT_USER : (l = c == null ? void 0 : c.sender) === null || l === void 0 ? void 0 : l.nickname, S = me(!1), v = S[0], G = S[1], w = bj(), y = (d = (a = JY(m)) === null || a === void 0 ? void 0 : a.split("/")) !== null && d !== void 0 ? d : b.split("/");
  return T.createElement(
    "div",
    { className: vn([R, "sendbird-quote-message", U ? "outgoing" : "incoming", Z ? "unavailable" : ""]), key: m == null ? void 0 : m.messageId, onClick: function() {
      !Z && W && W();
    }, onTouchEnd: function() {
      !Z && W && W();
    } },
    T.createElement(
      "div",
      { className: "sendbird-quote-message__replied-to" },
      T.createElement(dt, { className: "sendbird-quote-message__replied-to__icon", type: Le.REPLY, fillColor: Pe.ON_BACKGROUND_3, width: "12px", height: "12px" }),
      T.createElement(
        Fe,
        { className: "sendbird-quote-message__replied-to__text", type: oe.CAPTION_2, color: ie.ONBACKGROUND_3 },
        T.createElement("span", { className: "sendbird-quote-message__replied-to__text__nickname" }, Q),
        T.createElement("span", { className: "sendbird-quote-message__replied-to__text__text" }, F.QUOTED_MESSAGE__REPLIED_TO),
        T.createElement("span", { className: "sendbird-quote-message__replied-to__text__nickname" }, u)
      )
    ),
    T.createElement(
      "div",
      { className: "sendbird-quote-message__replied-message" },
      Z && T.createElement(
        "div",
        { className: "sendbird-quote-message__replied-message__text-message" },
        T.createElement(Fe, { className: "sendbird-quote-message__replied-message__text-message__word", type: oe.BODY_2, color: ie.ONBACKGROUND_1 }, F.QUOTED_MESSAGE__UNAVAILABLE)
      ),
      dd(m) && ((r = m == null ? void 0 : m.message) === null || r === void 0 ? void 0 : r.length) > 0 && !Z && T.createElement(
        "div",
        { className: "sendbird-quote-message__replied-message__text-message" },
        T.createElement(Fe, { className: "sendbird-quote-message__replied-message__text-message__word", type: oe.BODY_2, color: ie.ONBACKGROUND_1 }, m == null ? void 0 : m.message)
      ),
      Mi(m) && b && !Z && T.createElement(
        "div",
        { className: "sendbird-quote-message__replied-message__text-message" },
        T.createElement(Fe, { className: "sendbird-quote-message__replied-message__text-message__word", type: oe.BODY_2, color: ie.ONBACKGROUND_1 }, F.VOICE_MESSAGE)
      ),
      (Qi(m) || Fa(m)) && b && !Z && T.createElement(
        "div",
        { className: "sendbird-quote-message__replied-message__thumbnail-message" },
        T.createElement(el, { className: "sendbird-quote-message__replied-message__thumbnail-message__image", url: b, alt: k, width: "144px", height: "108px", onLoad: function() {
          return G(!0);
        }, defaultComponent: T.createElement(
          "div",
          { className: "sendbird-quote-message__replied-message__thumbnail-message__placeholder" },
          T.createElement(
            "div",
            { className: "sendbird-quote-message__replied-message__thumbnail-message__placeholder__icon" },
            T.createElement(dt, { type: YV(k) ? Le.PLAY : Le.PHOTO, fillColor: Pe.ON_BACKGROUND_2, width: "22px", height: "22px" })
          )
        ) }),
        YV(k) && !(((i = m == null ? void 0 : m.thumbnails) === null || i === void 0 ? void 0 : i.length) > 0) && T.createElement(
          T.Fragment,
          null,
          T.createElement(
            "video",
            { className: "sendbird-quote-message__replied-message__thumbnail-message__video" },
            T.createElement("source", { src: b, type: k })
          ),
          T.createElement(
            "div",
            { className: "sendbird-quote-message__replied-message__thumbnail-message__cover" },
            T.createElement(
              "div",
              { className: "sendbird-quote-message__replied-message__thumbnail-message__cover__icon" },
              T.createElement(dt, { type: Le.PLAY, fillColor: Pe.ON_BACKGROUND_2, width: "14px", height: "14px" })
            )
          )
        ),
        v && aU(k) && T.createElement(
          "div",
          { className: "sendbird-quote-message__replied-message__thumbnail-message__cover" },
          T.createElement(
            "div",
            { className: "sendbird-quote-message__replied-message__thumbnail-message__cover__icon" },
            T.createElement(dt, { type: Le.GIF, fillColor: Pe.THUMBNAIL_ICON, width: "14px", height: "14px" })
          )
        )
      ),
      XW(m) === vd.FILE && b && !Z && T.createElement(
        "div",
        { className: "sendbird-quote-message__replied-message__file-message" },
        T.createElement(dt, { className: "sendbird-quote-message__replied-message__file-message__type-icon", type: (n = {}, n[w.IMAGE] = Le.PHOTO, n[w.VIDEO] = Le.PLAY, n[w.AUDIO] = Le.FILE_AUDIO, n[w.GIF] = Le.GIF, n[w.OTHERS] = Le.FILE_DOCUMENT, n)[kb(k)], fillColor: Pe.ON_BACKGROUND_3, width: "16px", height: "16px" }),
        T.createElement(Fe, { className: "sendbird-quote-message__replied-message__file-message__file-name", type: oe.BODY_2, color: ie.ONBACKGROUND_3 }, vb(y[y.length - 1]))
      )
    )
  );
}
var OI = function(e) {
  var n, t, l, a = e.hideMenu, d = e.channel, r = e.message, i = e.replyType, c = e.userId, V = e.resendMessage, s = e.showEdit, o = e.showRemove, U = e.deleteMenuState, N = e.deleteMessage, R = e.setQuoteMessage, h = e.parentRef, Z = e.onReplyInThread, W = e.isOpenedFromThread, F = W === void 0 ? !1 : W, m = ((n = r == null ? void 0 : r.sender) === null || n === void 0 ? void 0 : n.userId) === c, E = ca().stringSet, u = dd(r), b = dd(r) && So(r) && m, k = Ba(r) && (r == null ? void 0 : r.isResendable) && m, Q = !Fd(r) && m, S = m && (U === void 0 || U !== "HIDE"), v = S && Q, G = U !== void 0 && U === "DISABLE" || ((l = (t = r == null ? void 0 : r.threadInfo) === null || t === void 0 ? void 0 : t.replyCount) !== null && l !== void 0 ? l : 0) > 0, w = !Fd(r) && wa(r) && !(Mi(r) && (d != null && d.isSuper || d != null && d.isBroadcast)), y = i === "QUOTE_REPLY" && !Ba(r) && !Fd(r) && (d == null ? void 0 : d.isGroupChannel()), g = i === "THREAD" && !F && !Ba(r) && !Fd(r) && !bb(r) && (d == null ? void 0 : d.isGroupChannel()), f = r;
  return T.createElement(OV, { isOpen: !0, menuItems: function() {
    var I, K, Ue;
    return T.createElement(
      VU,
      { className: "sendbird-message__mobile-context-menu", parentRef: h, parentContainRef: h, closeDropdown: a },
      u && T.createElement(
        Na,
        { className: "sendbird-message__mobile-context-menu-item menu-item-copy", onClick: function() {
          a(), jW(r == null ? void 0 : r.message);
        }, dataSbId: "ui_mobile_message_item_menu_copy" },
        T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, E == null ? void 0 : E.MESSAGE_MENU__COPY),
        T.createElement(dt, { type: Le.COPY, fillColor: Pe.PRIMARY, width: "24px", height: "24px" })
      ),
      y && T.createElement(
        Na,
        { className: "sendbird-message__mobile-context-menu-item menu-item-reply", onClick: function() {
          a(), R(r);
        }, disable: ((I = r == null ? void 0 : r.parentMessageId) !== null && I !== void 0 ? I : 0) > 0, dataSbId: "ui_mobile_message_item_menu_reply" },
        T.createElement(Fe, { type: oe.SUBTITLE_1, color: ((K = r == null ? void 0 : r.parentMessageId) !== null && K !== void 0 ? K : 0) > 0 ? ie.ONBACKGROUND_4 : ie.ONBACKGROUND_1 }, E.MESSAGE_MENU__REPLY),
        T.createElement(dt, { type: Le.REPLY, fillColor: ((Ue = r == null ? void 0 : r.parentMessageId) !== null && Ue !== void 0 ? Ue : 0) > 0 ? Pe.ON_BACKGROUND_4 : Pe.PRIMARY, width: "24px", height: "24px" })
      ),
      g && T.createElement(
        Na,
        { className: "sendbird-message__mobile-context-menu-item menu-item-reply", onClick: function() {
          a(), Z == null || Z({ message: r });
        }, dataSbId: "ui_mobile_message_item_menu_thread" },
        T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, E.MESSAGE_MENU__THREAD),
        T.createElement(dt, { type: Le.THREAD, fillColor: Pe.PRIMARY, width: "24px", height: "24px" })
      ),
      b && T.createElement(
        Na,
        { className: "sendbird-message__mobile-context-menu-item menu-item-edit", onClick: function() {
          a(), s(!0);
        }, dataSbId: "ui_mobile_message_item_menu_edit" },
        T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, E.MESSAGE_MENU__EDIT),
        T.createElement(dt, { type: Le.EDIT, fillColor: Pe.PRIMARY, width: "24px", height: "24px" })
      ),
      k && T.createElement(
        Na,
        { className: "sendbird-message__mobile-context-menu-item menu-item-resend", onClick: function() {
          a(), V(r);
        }, dataSbId: "ui_mobile_message_item_menu_resend" },
        T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, E.MESSAGE_MENU__RESEND),
        T.createElement(dt, { type: Le.REFRESH, fillColor: Pe.PRIMARY, width: "24px", height: "24px" })
      ),
      v && T.createElement(
        Na,
        { className: "sendbird-message__mobile-context-menu-item menu-item-delete", onClick: function() {
          Ba(r) ? (a(), N == null || N(r)) : G || (a(), o == null || o(!0));
        }, disable: G, dataSbId: "ui_mobile_message_item_menu_delete" },
        T.createElement(Fe, { type: oe.SUBTITLE_1, color: G ? ie.ONBACKGROUND_4 : ie.ONBACKGROUND_1 }, E.MESSAGE_MENU__DELETE),
        T.createElement(dt, { type: Le.DELETE, fillColor: G ? Pe.ON_BACKGROUND_4 : Pe.PRIMARY, width: "24px", height: "24px" })
      ),
      w && T.createElement(
        Na,
        { className: "sendbird-message__mobile-context-menu-item menu-item-save", onClick: function() {
          a();
        }, dataSbId: "ui_mobile_message_item_menu_download_file" },
        T.createElement(
          "a",
          { className: "sendbird-message__contextmenu--hyperlink", rel: "noopener noreferrer", href: f == null ? void 0 : f.url, target: "_blank" },
          T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, E.MESSAGE_MENU__SAVE),
          T.createElement(dt, { type: Le.DOWNLOAD, fillColor: Pe.PRIMARY, width: "24px", height: "24px" })
        )
      )
    );
  } });
}, jZ = 38, jI = function(e) {
  var n, t, l, a = e.hideMenu, d = e.channel, r = e.emojiContainer, i = e.message, c = e.replyType, V = e.userId, s = e.resendMessage, o = e.deleteMessage, U = e.toggleReaction, N = e.isReactionEnabled, R = e.showEdit, h = e.showRemove, Z = e.deleteMenuState, W = e.setQuoteMessage, F = e.onReplyInThread, m = e.isOpenedFromThread, E = m === void 0 ? !1 : m, u = ((n = i == null ? void 0 : i.sender) === null || n === void 0 ? void 0 : n.userId) === V, b = ca().stringSet, k = zn(), Q = k.config.isOnline, S = dd(i), v = dd(i) && So(i) && u, G = Q && Ba(i) && (i == null ? void 0 : i.isResendable) && u, w = !Fd(i) && u, y = u && (Z === void 0 || Z !== "HIDE"), g = y && w, f = Z !== void 0 && Z === "DISABLE" || ((l = (t = i == null ? void 0 : i.threadInfo) === null || t === void 0 ? void 0 : t.replyCount) !== null && l !== void 0 ? l : 0) > 0, I = So(i) && wa(i) && !Mi(i), K = !Ba(i) && !Fd(i) && N, Ue = c === "QUOTE_REPLY" && !Ba(i) && !Fd(i) && (d == null ? void 0 : d.isGroupChannel()) && !(d != null && d.isBroadcast), q = c === "THREAD" && !E && !Ba(i) && !Fd(i) && !bb(i) && (d == null ? void 0 : d.isGroupChannel()) && !(d != null && d.isBroadcast), ae = (i == null ? void 0 : i.parentMessageId) > 0, se = i, le = Math.floor(window.innerWidth / jZ) - 1, L = me(!1), $ = L[0], ee = L[1], O = eh(r), re = $ ? O : O == null ? void 0 : O.slice(0, le), te = O.length > le;
  return T.createElement(
    sh,
    { onBackdropClick: a },
    T.createElement(
      "div",
      { className: "sendbird-message__bottomsheet" },
      K && T.createElement(
        "div",
        { className: "sendbird-message__bottomsheet-reactions" },
        T.createElement(
          "ul",
          { className: "sendbird-message__bottomsheet-reaction-bar" },
          T.createElement(
            "div",
            { className: `
                    sendbird-message__bottomsheet-reaction-bar__row
                    `.concat($ ? "sendbird-message__bottomsheet-reaction-bar__all" : "", `
                  `) },
            re.map(function(Qe) {
              var Ye, Se, P, ge = (P = (Se = (Ye = i == null ? void 0 : i.reactions) === null || Ye === void 0 ? void 0 : Ye.filter(function(Me) {
                return Me.key === Qe.key;
              })[0]) === null || Se === void 0 ? void 0 : Se.userIds) === null || P === void 0 ? void 0 : P.some(function(Me) {
                return Me === V;
              });
              return T.createElement(
                zc,
                { key: Qe.key, width: "".concat(jZ, "px"), height: "".concat(jZ, "px"), selected: ge, onClick: function() {
                  a(), U(i, Qe.key, ge);
                }, dataSbId: "ui_mobile_emoji_reactions_menu_".concat(Qe.key) },
                T.createElement(el, { url: (Qe == null ? void 0 : Qe.url) || "", width: "28px", height: "28px", placeHolder: function(Me) {
                  var We = Me.style;
                  return T.createElement(
                    "div",
                    { style: We },
                    T.createElement(dt, { type: Le.QUESTION, fillColor: Pe.ON_BACKGROUND_3, width: "28px", height: "28px" })
                  );
                } })
              );
            }),
            te && !$ && T.createElement(
              zc,
              { key: "emoji_more", width: "38px", height: "38px", onClick: function() {
                ee(!0);
              }, dataSbId: "ui_mobile_emoji_reactions_menu_emojiadd" },
              T.createElement(el, { url: "", width: "28px", height: "28px", placeHolder: function(Qe) {
                var Ye = Qe.style;
                return T.createElement(
                  "div",
                  { style: Ye },
                  T.createElement(dt, { type: Le.EMOJI_MORE, fillColor: Pe.ON_BACKGROUND_3, width: "28px", height: "28px" })
                );
              } })
            )
          )
        )
      ),
      !$ && T.createElement(
        "div",
        { className: "sendbird-message__bottomsheet--actions" },
        S && T.createElement(
          "div",
          { className: "sendbird-message__bottomsheet--action", onClick: function() {
            a(), jW(i == null ? void 0 : i.message);
          } },
          T.createElement(dt, { type: Le.COPY, fillColor: Pe.PRIMARY, width: "24px", height: "24px" }),
          T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, b == null ? void 0 : b.MESSAGE_MENU__COPY)
        ),
        v && T.createElement(
          "div",
          { className: "sendbird-message__bottomsheet--action", onClick: function() {
            a(), R(!0);
          } },
          T.createElement(dt, { type: Le.EDIT, fillColor: Pe.PRIMARY, width: "24px", height: "24px" }),
          T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, b == null ? void 0 : b.MESSAGE_MENU__EDIT)
        ),
        G && T.createElement(
          "div",
          { className: "sendbird-message__bottomsheet--action", onClick: function() {
            a(), s(i);
          } },
          T.createElement(dt, { type: Le.REFRESH, fillColor: Pe.PRIMARY, width: "24px", height: "24px" }),
          T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, b == null ? void 0 : b.MESSAGE_MENU__RESEND)
        ),
        Ue && T.createElement(
          "div",
          { className: `sendbird-message__bottomsheet--action
                      `.concat(ae ? "sendbird-message__bottomsheet--action-disabled" : "", `
                    `), role: "menuitem", "aria-disabled": !!ae, onClick: function() {
            ae || (a(), W(i));
          } },
          T.createElement(dt, { type: Le.REPLY, fillColor: ae ? Pe.ON_BACKGROUND_3 : Pe.PRIMARY, width: "24px", height: "24px" }),
          T.createElement(Fe, { type: oe.SUBTITLE_1, color: ae ? ie.ONBACKGROUND_4 : ie.ONBACKGROUND_1 }, b == null ? void 0 : b.MESSAGE_MENU__REPLY)
        ),
        q && T.createElement(
          "div",
          { className: "sendbird-message__bottomsheet--action", onClick: function() {
            a(), F == null || F({ message: i });
          } },
          T.createElement(dt, { type: Le.THREAD, fillColor: Pe.PRIMARY, width: "24px", height: "24px" }),
          T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, b.MESSAGE_MENU__THREAD)
        ),
        g && T.createElement(
          "div",
          { className: "sendbird-message__bottomsheet--action", onClick: function() {
            Ba(i) ? (a(), o == null || o(i)) : f || (a(), h == null || h(!0));
          } },
          T.createElement(dt, { type: Le.DELETE, fillColor: f ? Pe.ON_BACKGROUND_4 : Pe.PRIMARY, width: "24px", height: "24px" }),
          T.createElement(Fe, { type: oe.SUBTITLE_1, color: f ? ie.ONBACKGROUND_4 : ie.ONBACKGROUND_1 }, b == null ? void 0 : b.MESSAGE_MENU__DELETE)
        ),
        I && T.createElement(
          "div",
          { className: "sendbird-message__bottomsheet--action", onClick: function() {
            a();
          } },
          T.createElement(
            "a",
            { className: "sendbird-message__bottomsheet--hyperlink", rel: "noopener noreferrer", href: se == null ? void 0 : se.url, target: "_blank" },
            T.createElement(dt, { type: Le.DOWNLOAD, fillColor: Pe.PRIMARY, width: "24px", height: "24px" }),
            T.createElement(Fe, { type: oe.SUBTITLE_1, color: ie.ONBACKGROUND_1 }, b == null ? void 0 : b.MESSAGE_MENU__SAVE)
          )
        )
      )
    )
  );
}, HI = function(e) {
  var n = e.message, t = e.hideMenu, l = e.userId, a = e.channel, d = e.isReactionEnabled, r = d === void 0 ? !1 : d, i = e.isByMe, c = e.replyType, V = e.disabled, s = e.deleteMenuState, o = e.showRemove, U = e.showEdit, N = e.resendMessage, R = e.deleteMessage, h = e.setQuoteMessage, Z = e.emojiContainer, W = e.toggleReaction, F = e.parentRef, m = e.onReplyInThread, E = e.isOpenedFromThread;
  return T.createElement(T.Fragment, null, r ? T.createElement(jI, { channel: a, message: n, hideMenu: t, isByMe: i, userId: l, replyType: c, disabled: V, showRemove: o, showEdit: U, deleteMenuState: s, resendMessage: N, deleteMessage: R, setQuoteMessage: h, emojiContainer: Z, toggleReaction: W, isReactionEnabled: r, onReplyInThread: m, isOpenedFromThread: E }) : T.createElement(OI, { channel: a, userId: l, message: n, hideMenu: t, isByMe: i, showEdit: U, replyType: c, disabled: V, deleteMenuState: s, showRemove: o, resendMessage: N, deleteMessage: R, setQuoteMessage: h, parentRef: F, onReplyInThread: m, isOpenedFromThread: E }));
};
function fI(e) {
  var n, t = e.className, l = e.threadInfo, a = e.onClick, d = l.mostRepliedUsers, r = d === void 0 ? [] : d, i = l.replyCount, c = ca().stringSet;
  return T.createElement(
    "div",
    { className: "sendbird-ui-thread-replies ".concat(t), role: "button", onClick: function(V) {
      a(V), V == null || V.stopPropagation();
    }, onKeyDown: function(V) {
      a(V), V == null || V.stopPropagation();
    } },
    T.createElement(
      "div",
      { className: "sendbird-ui-thread-replies__user-profiles" },
      r.slice(0, 4).map(function(V) {
        return T.createElement(da, { key: V.userId, className: "sendbird-ui-thread-replies__user-profiles__avatar", src: V == null ? void 0 : V.profileUrl, alt: "user profile", width: "20px", height: "20px" });
      }),
      (r == null ? void 0 : r.length) >= 5 && T.createElement(
        "div",
        { className: "sendbird-ui-thread-replies__user-profiles__avatar" },
        T.createElement(da, { className: "sendbird-ui-thread-replies__user-profiles__avatar__image", src: (n = r == null ? void 0 : r[4]) === null || n === void 0 ? void 0 : n.profileUrl, alt: "user profile", width: "20px", height: "20px" }),
        T.createElement("div", { className: "sendbird-ui-thread-replies__user-profiles__avatar__cover" }),
        T.createElement(
          "div",
          { className: "sendbird-ui-thread-replies__user-profiles__avatar__plus" },
          T.createElement(dt, { type: Le.PLUS, fillColor: Pe.WHITE, width: "16px", height: "16px" })
        )
      )
    ),
    T.createElement(Fe, { className: "sendbird-ui-thread-replies__reply-counts", type: oe.CAPTION_2, color: ie.PRIMARY }, i === 1 ? "".concat(i, " ").concat(c.CHANNEL__THREAD_REPLY) : "".concat(i > 99 ? c.CHANNEL__THREAD_OVER_MAX : i, " ").concat(c.CHANNEL__THREAD_REPLIES)),
    T.createElement(dt, { className: "sendbird-ui-thread-replies__icon", type: Le.CHEVRON_RIGHT, fillColor: Pe.PRIMARY, width: "16px", height: "16px" })
  );
}
function wI(e) {
  var n, t, l, a = e.mentionTemplate, d = e.mentionedUserId, r = e.mentionedUserNickname, i = e.isByMe, c = Wt(), V = zn(), s = (n = V == null ? void 0 : V.config) === null || n === void 0 ? void 0 : n.userId, o = (l = (t = V == null ? void 0 : V.stores) === null || t === void 0 ? void 0 : t.sdkStore) === null || l === void 0 ? void 0 : l.sdk, U = s === d, N = me(), R = N[0], h = N[1], Z = Pt(function(W) {
    if (R || !(o != null && o.createApplicationUserListQuery)) {
      W();
      return;
    }
    var F = o == null ? void 0 : o.createApplicationUserListQuery({
      userIdsFilter: [d]
    });
    F.next().then(function(m) {
      (m == null ? void 0 : m.length) > 0 && h(m[0]), W();
    });
  }, [o, d]);
  return T.createElement(OV, { menuTrigger: function(W) {
    return T.createElement(
      "a",
      { className: `
            sendbird-word__mention
            `.concat(U ? "sendbird-word__mention--me" : "", `
          `), onClick: function() {
        return Z(W);
      }, ref: c, "data-userid": d, "data-nickname": r, "data-sb-mention": !0 },
      T.createElement(Fe, { type: oe.CAPTION_1, color: i ? ie.ONCONTENT_1 : ie.ONBACKGROUND_1 }, "".concat(a).concat(r))
    );
  }, menuItems: function(W) {
    return T.createElement(
      VU,
      {
        /**
        * parentRef: For catching location(x, y) of MenuItems
        * parentContainRef: For toggling more options(menus & reactions)
        */
        parentRef: c,
        parentContainRef: c,
        closeDropdown: W,
        style: { paddingTop: "0px", paddingBottom: "0px" }
      },
      T.createElement(d1, { user: R, onSuccess: W, currentUserId: s })
    );
  } });
}
var gI = /https?:\/\//;
function II(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.src, a = e.type, d = e.color, r = e.children, i = gI.test(l) ? l : "http://".concat(l);
  return T.createElement(
    "a",
    {
      className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
        "sendbird-link-label",
        fb(d)
      ], !1).join(" "),
      href: i,
      target: "_blank",
      rel: "noopener noreferrer",
      // for mobile
      onTouchEnd: function(c) {
        c.preventDefault(), c.nativeEvent.stopImmediatePropagation(), window.open(i, "_blank", "noopener,noreferrer");
      }
    },
    T.createElement(Fe, { className: "sendbird-link-label__label", type: a, color: d }, r)
  );
}
function LI(e, n, t) {
  return "sb-msg_".concat(e, "_").concat(n, "_").concat(t);
}
function zY(e) {
  var n = e.tokens, t = QY(), l = t == null ? void 0 : t.message, a = t == null ? void 0 : t.isByMe, d = l.updatedAt, r = l.createdAt;
  return T.createElement(T.Fragment, null, n == null ? void 0 : n.map(function(i, c) {
    var V = LI(r, d, c);
    return Va(i.type).with(ha.mention, function() {
      return T.createElement(
        "span",
        { className: "sendbird-word", key: V },
        T.createElement(wI, {
          mentionTemplate: iU,
          // @ts-ignore
          mentionedUserId: i.userId,
          mentionedUserNickname: i.value,
          isByMe: a
        })
      );
    }).with(ha.url, function() {
      return T.createElement(
        "span",
        { className: "sendbird-word", key: V },
        T.createElement(II, { className: "sendbird-word__url", src: i.value, type: oe.BODY_1 }, i.value)
      );
    }).otherwise(function() {
      return T.createElement(T.Fragment, { key: V }, P4(i.value));
    });
  }));
}
function CI(e) {
  var n, t, l, a, d, r, i, c, V, s, o, U, N = e.className, R = e.message, h = e.isByMe, Z = h === void 0 ? !1 : h, W = e.mouseHover, F = W === void 0 ? !1 : W, m = e.isMentionEnabled, E = m === void 0 ? !1 : m, u = e.isReactionEnabled, b = u === void 0 ? !1 : u, k = e.onMessageHeightChange, Q = k === void 0 ? function() {
  } : k, S = Wt(null), v = Gt(Kn).stringSet, G = function() {
    var g, f = (g = R == null ? void 0 : R.ogMetaData) === null || g === void 0 ? void 0 : g.url;
    f && (!f.startsWith("http://") && !f.startsWith("https://") && (f = "https://" + f), window.open(f));
  }, w = E && ((n = R == null ? void 0 : R.mentionedMessageTemplate) === null || n === void 0 ? void 0 : n.length) > 0 && ((t = R == null ? void 0 : R.mentionedUsers) === null || t === void 0 ? void 0 : t.length) > 0, y = nn(function() {
    return Jo(w ? {
      mentionedUsers: R == null ? void 0 : R.mentionedUsers,
      messageText: R == null ? void 0 : R.mentionedMessageTemplate
    } : {
      messageText: R == null ? void 0 : R.message
    });
  }, [R == null ? void 0 : R.updatedAt, R == null ? void 0 : R.message]);
  return T.createElement(
    "div",
    { className: vn([
      N,
      "sendbird-og-message-item-body",
      Z ? "outgoing" : "incoming",
      F ? "mouse-hover" : "",
      b && ((l = R == null ? void 0 : R.reactions) === null || l === void 0 ? void 0 : l.length) > 0 ? "reactions" : ""
    ]) },
    T.createElement(
      Fe,
      { type: oe.BODY_1, color: Z ? ie.ONCONTENT_1 : ie.ONBACKGROUND_1 },
      T.createElement(
        "div",
        { className: WY },
        T.createElement(zY, { tokens: y }),
        Qb(R) && T.createElement(Fe, { className: "sendbird-og-message-item-body__text-bubble__message", type: oe.BODY_1, color: Z ? ie.ONCONTENT_2 : ie.ONBACKGROUND_2 }, " ".concat(v.MESSAGE_EDITED, " "))
      )
    ),
    T.createElement(
      "div",
      { ref: S, className: `sendbird-og-message-item-body__og-thumbnail
          `.concat(!((d = (a = R == null ? void 0 : R.ogMetaData) === null || a === void 0 ? void 0 : a.defaultImage) === null || d === void 0) && d.url ? "" : "sendbird-og-message-item-body__og-thumbnail__empty", `
        `), onClick: G },
      T.createElement(el, { className: "sendbird-og-message-item-body__og-thumbnail__image", url: ((i = (r = R == null ? void 0 : R.ogMetaData) === null || r === void 0 ? void 0 : r.defaultImage) === null || i === void 0 ? void 0 : i.url) || "", alt: (V = (c = R == null ? void 0 : R.ogMetaData) === null || c === void 0 ? void 0 : c.defaultImage) === null || V === void 0 ? void 0 : V.alt, width: "100%", onLoad: Q, onError: function() {
        var g, f;
        try {
          (f = (g = S == null ? void 0 : S.current) === null || g === void 0 ? void 0 : g.classList) === null || f === void 0 || f.add("sendbird-og-message-item-body__og-thumbnail__empty");
        } catch {
        }
      }, defaultComponent: T.createElement(
        "div",
        { className: "sendbird-og-message-item-body__og-thumbnail__place-holder" },
        T.createElement(dt, { className: "sendbird-og-message-item-body__og-thumbnail__place-holder__icon", type: Le.THUMBNAIL_NONE, width: "56px", height: "56px" })
      ) })
    ),
    T.createElement(
      "div",
      { className: "sendbird-og-message-item-body__description", onClick: G },
      ((s = R == null ? void 0 : R.ogMetaData) === null || s === void 0 ? void 0 : s.title) && T.createElement(Fe, { className: "sendbird-og-message-item-body__description__title", type: oe.SUBTITLE_2, color: ie.ONBACKGROUND_1 }, R.ogMetaData.title),
      ((o = R == null ? void 0 : R.ogMetaData) === null || o === void 0 ? void 0 : o.description) && T.createElement(Fe, { className: "sendbird-og-message-item-body__description__description", type: oe.BODY_2, color: ie.ONBACKGROUND_1 }, R.ogMetaData.description),
      ((U = R == null ? void 0 : R.ogMetaData) === null || U === void 0 ? void 0 : U.url) && T.createElement(Fe, { className: "sendbird-og-message-item-body__description__url", type: oe.CAPTION_3, color: ie.ONBACKGROUND_2 }, R.ogMetaData.url)
    ),
    T.createElement("div", { className: "sendbird-og-message-item-body__cover" })
  );
}
function KI(e) {
  var n, t, l, a = e.className, d = a === void 0 ? "" : a, r = e.message, i = e.isByMe, c = i === void 0 ? !1 : i, V = e.mouseHover, s = V === void 0 ? !1 : V, o = e.isMentionEnabled, U = o === void 0 ? !1 : o, N = e.isReactionEnabled, R = N === void 0 ? !1 : N, h = Gt(Kn).stringSet, Z = U && ((n = r == null ? void 0 : r.mentionedMessageTemplate) === null || n === void 0 ? void 0 : n.length) > 0 && ((t = r == null ? void 0 : r.mentionedUsers) === null || t === void 0 ? void 0 : t.length) > 0, W = nn(function() {
    return Jo(Z ? {
      mentionedUsers: r == null ? void 0 : r.mentionedUsers,
      messageText: r == null ? void 0 : r.mentionedMessageTemplate
    } : {
      messageText: r == null ? void 0 : r.message
    });
  }, [r == null ? void 0 : r.updatedAt, r == null ? void 0 : r.message]);
  return T.createElement(
    Fe,
    { type: oe.BODY_1, color: c ? ie.ONCONTENT_1 : ie.ONBACKGROUND_1 },
    T.createElement(
      "div",
      { className: vn([
        d,
        FY,
        c ? "outgoing" : "incoming",
        s ? "mouse-hover" : "",
        R && ((l = r == null ? void 0 : r.reactions) === null || l === void 0 ? void 0 : l.length) > 0 ? "reactions" : ""
      ]) },
      T.createElement(zY, { tokens: W }),
      Qb(r) && T.createElement(Fe, { className: "sendbird-text-message-item-body__message edited", type: oe.BODY_1, color: c ? ie.ONCONTENT_2 : ie.ONBACKGROUND_2 }, " ".concat(h.MESSAGE_EDITED, " "))
    )
  );
}
var xY = function(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.color, a = l === void 0 ? va.ONBACKGROUND_1 : l, d = e.disabled, r = d === void 0 ? !1 : d, i = e.disableUnderline, c = i === void 0 ? !1 : i, V = e.onClick, s = V === void 0 ? function() {
  } : V, o = e.children;
  return T.createElement("div", { className: Ut(Ut([], Array.isArray(t) ? t : [t], !0), [
    pF(a),
    c ? "sendbird-textbutton--not-underline" : "sendbird-textbutton",
    r ? "sendbird-textbutton--disabled" : ""
  ], !1).join(" "), role: "button", tabIndex: 0, onClick: function(U) {
    return s(U);
  }, onKeyPress: function(U) {
    return s(U);
  } }, o);
};
function _I(e) {
  var n, t = e.className, l = e.message, a = e.isByMe, d = a === void 0 ? !1 : a, r = e.mouseHover, i = r === void 0 ? !1 : r, c = e.isReactionEnabled, V = c === void 0 ? !1 : c, s = e.truncateLimit, o = s === void 0 ? null : s, U = dr().isMobile, N = o || (U ? 20 : null);
  return T.createElement(
    "div",
    { className: vn([
      t,
      "sendbird-file-message-item-body",
      d ? "outgoing" : "incoming",
      i ? "mouse-hover" : "",
      V && ((n = l == null ? void 0 : l.reactions) === null || n === void 0 ? void 0 : n.length) > 0 ? "reactions" : ""
    ]) },
    T.createElement(
      "div",
      { className: "sendbird-file-message-item-body__file-icon" },
      T.createElement(dt, { className: "sendbird-file-message-item-body__file-icon__icon", type: {
        IMAGE: Le.PHOTO,
        VIDEO: Le.PLAY,
        AUDIO: Le.FILE_AUDIO,
        GIF: Le.GIF,
        OTHERS: Le.FILE_DOCUMENT
      }[kb(l == null ? void 0 : l.type)], fillColor: Pe.PRIMARY, width: "24px", height: "24px" })
    ),
    T.createElement(
      xY,
      { className: "sendbird-file-message-item-body__file-name", onClick: function() {
        window.open(l == null ? void 0 : l.url);
      }, color: d ? va.ONCONTENT_1 : va.ONBACKGROUND_1 },
      T.createElement(Fe, { className: "sendbird-file-message-item-body__file-name__text", type: oe.BODY_1, color: d ? ie.ONCONTENT_1 : ie.ONBACKGROUND_1 }, vb((l == null ? void 0 : l.name) || (l == null ? void 0 : l.url), N))
    )
  );
}
function r1(e, n) {
  ud(function() {
    var l;
    (l = e.current) === null || l === void 0 || l.focus();
  }, [e.current]);
  var t = lU(function(l) {
    var a = n[l.key];
    a == null || a(l), l.stopPropagation();
  });
  return t;
}
var PI = {
  IMAGE: [
    "image/jpeg",
    "image/jpg",
    "image/png",
    "image/gif",
    "image/svg+xml",
    "image/webp"
  ],
  VIDEO: [
    "video/mpeg",
    "video/ogg",
    "video/webm",
    "video/mp4"
  ]
};
ce({}, PI);
var sU = {
  SINGLE: "SINGLE",
  MULTI: "MULTI"
};
function AI(e) {
  var n = e.props;
  if (n.viewerType === sU.MULTI) {
    var t = n, l = t.fileInfoList, a = t.currentIndex;
    return l[a];
  }
  var d = n;
  return {
    name: d.name,
    type: d.type,
    url: d.url
  };
}
function qI(e) {
  if (e.viewerType !== sU.MULTI) {
    var n = e.onDelete, t = e.isByMe, l = e.disableDelete, a = e.className;
    return t ? T.createElement(
      "div",
      { className: "sendbird-fileviewer__header__right__actions__delete ".concat(a) },
      T.createElement(dt, { className: l ? "disabled" : "", type: Le.DELETE, fillColor: l ? Pe.GRAY : Pe.ON_BACKGROUND_1, height: "24px", width: "24px", onClick: function(d) {
        l || n == null || n(d);
      } })
    ) : T.createElement(T.Fragment, null);
  }
  return T.createElement(T.Fragment, null);
}
function $I(e) {
  if (e.viewerType === sU.MULTI) {
    var n = e.onClickLeft, t = e.onClickRight;
    return T.createElement(
      "div",
      { className: "sendbird-file-viewer-slider" },
      T.createElement(
        "div",
        { className: "sendbird-file-viewer-arrow--left" },
        T.createElement(dt, { type: Le.SLIDE_LEFT, fillColor: Pe.ON_BACKGROUND_1, height: eN, width: eN, onClick: function(l) {
          n == null || n(), l.stopPropagation();
        } })
      ),
      T.createElement(
        "div",
        { className: "sendbird-file-viewer-arrow--right" },
        T.createElement(dt, { type: Le.SLIDE_LEFT, fillColor: Pe.ON_BACKGROUND_1, height: eN, width: eN, onClick: function(l) {
          l.stopPropagation(), t == null || t();
        } })
      )
    );
  }
  return T.createElement(T.Fragment, null);
}
var PM = function(e) {
  var n = Wt(null), t = e.profileUrl, l = e.nickname, a = e.onClose, d = e, r = d.onClickLeft, i = d.onClickRight, c = r1(n, {
    Escape: function(R) {
      return a == null ? void 0 : a(R);
    },
    ArrowLeft: function() {
      return r == null ? void 0 : r();
    },
    ArrowRight: function() {
      return i == null ? void 0 : i();
    }
  }), V = AI({ props: e }), s = V.name, o = V.type, U = V.url, N = Gt(Kn).stringSet;
  return T.createElement(
    "div",
    {
      className: "sendbird-fileviewer",
      onKeyDown: c,
      // to focus
      tabIndex: 1,
      ref: n
    },
    T.createElement(
      "div",
      { className: "sendbird-fileviewer__header" },
      T.createElement(
        "div",
        { className: "sendbird-fileviewer__header__left" },
        T.createElement(
          "div",
          { className: "sendbird-fileviewer__header__left__avatar" },
          T.createElement(da, { height: "32px", width: "32px", src: t })
        ),
        T.createElement(Fe, { className: "sendbird-fileviewer__header__left__filename", type: oe.H_2, color: ie.ONBACKGROUND_1 }, s),
        T.createElement(Fe, { className: "sendbird-fileviewer__header__left__sender-name", type: oe.BODY_1, color: ie.ONBACKGROUND_2 }, l)
      ),
      T.createElement(
        "div",
        { className: "sendbird-fileviewer__header__right" },
        Eo(o) && T.createElement(
          "div",
          { className: "sendbird-fileviewer__header__right__actions" },
          T.createElement(
            "a",
            { className: "sendbird-fileviewer__header__right__actions__download", rel: "noopener noreferrer", href: U, target: "_blank" },
            T.createElement(dt, { type: Le.DOWNLOAD, fillColor: Pe.ON_BACKGROUND_1, height: "24px", width: "24px" })
          ),
          T.createElement(qI, ce({ className: "sendbird-fileviewer__header__right__actions__delete" }, e))
        ),
        T.createElement(
          "div",
          { className: "sendbird-fileviewer__header__right__actions__close" },
          T.createElement(dt, { type: Le.CLOSE, fillColor: Pe.ON_BACKGROUND_1, height: "24px", width: "24px", onClick: function(R) {
            return a == null ? void 0 : a(R);
          } })
        )
      )
    ),
    T.createElement(
      "div",
      { className: "sendbird-fileviewer__content" },
      YV(o) && T.createElement(
        "video",
        { controls: !0, className: "sendbird-fileviewer__content__video" },
        T.createElement("source", { src: U, type: o })
      ),
      XV(o) && T.createElement("img", { src: U, alt: s, className: e.viewerType === sU.MULTI ? "sendbird-fileviewer__content__img__multi" : "sendbird-fileviewer__content__img" }),
      !Eo(o) && T.createElement(
        "div",
        { className: "sendbird-fileviewer__content__unsupported" },
        T.createElement(Fe, { type: oe.H_1, color: ie.ONBACKGROUND_1 }, (N == null ? void 0 : N.UI__FILE_VIEWER__UNSUPPORT) || "Unsupported message")
      ),
      T.createElement($I, ce({}, e))
    )
  );
};
function e9(e) {
  var n, t, l, a = e.message, d = e.statefulFileInfoList, r = d === void 0 ? [] : d, i = e.onClose, c = e.isByMe, V = c === void 0 ? !1 : c, s = e.onDelete, o = e.currentIndex, U = e.onClickLeft, N = e.onClickRight;
  if (Fa(a)) {
    var R = a;
    return T.createElement(PM, { profileUrl: R.sender.profileUrl, nickname: R.sender.nickname, viewerType: sU.MULTI, fileInfoList: r.filter(function(h) {
      return h.url;
    }).map(function(h) {
      return {
        name: h.fileName || "",
        type: h.mimeType || "",
        url: h.url
      };
    }), currentIndex: o || 0, onClickLeft: U || dl, onClickRight: N || dl, onClose: i });
  } else if (wa(a)) {
    var R = a;
    return Yi(T.createElement(PM, { profileUrl: (n = R.sender) === null || n === void 0 ? void 0 : n.profileUrl, nickname: (t = R.sender) === null || t === void 0 ? void 0 : t.nickname, name: R.name, type: R.type, url: R == null ? void 0 : R.url, isByMe: V, disableDelete: (((l = R.threadInfo) === null || l === void 0 ? void 0 : l.replyCount) || 0) > 0, onClose: i, onDelete: s || dl }), document.getElementById(ko));
  }
  return T.createElement(T.Fragment, null);
}
function t9(e) {
  var n, t = e.children, l = e.className, a = e.message, d = e.isReactionEnabled;
  return T.createElement(
    "div",
    { className: "sendbird-image-grid-wrap" },
    T.createElement("div", { className: vn([
      l,
      "sendbird-image-grid",
      d && ((n = a == null ? void 0 : a.reactions) === null || n === void 0 ? void 0 : n.length) > 0 ? "reactions" : ""
    ]) }, t)
  );
}
var n9 = 400, HZ = 8, _V = 4, l9 = 54, lN = 40, a9 = 48, d9 = 320, AM = 28, qM = 12, r9 = 200, i9 = 8, V9 = 32, c9 = 60, fZ = {
  CHAT_WEB: "calc(".concat(n9 / 2, "px - ").concat((HZ + _V) / 2, "px)"),
  CHAT_MOBILE: "calc(50vw - ".concat((a9 + lN + l9 + HZ + _V) / 2, "px)"),
  THREAD_PARENT_WEB: "calc(".concat((d9 - (AM + lN + qM + _V)) / 2, "px)"),
  THREAD_PARENT_MOBILE: "calc(50vw - ".concat((AM + lN + qM + _V) / 2, "px)"),
  THREAD_CHILD_WEB: "calc(".concat((r9 - i9 - _V) / 2, "px)"),
  THREAD_CHILD_MOBILE: "calc(50vw - ".concat((V9 + lN + c9 + HZ + _V) / 2, "px)")
}, s9 = {
  CHAT_WEB: "6px",
  CHAT_MOBILE: "6px",
  THREAD_PARENT_WEB: "6px",
  THREAD_PARENT_MOBILE: "6px",
  THREAD_CHILD_WEB: "6px",
  THREAD_CHILD_MOBILE: "6px"
}, PV = "34px", $M = {
  PARENT: "parent",
  CHILD: "child"
};
function o9(e) {
  var n = e.className, t = e.message, l = e.isReactionEnabled, a = l === void 0 ? !1 : l, d = e.threadMessageKindKey, r = e.statefulFileInfoList, i = r === void 0 ? [] : r, c = me(-1), V = c[0], s = c[1];
  function o() {
    s(-1);
  }
  function U() {
    s(V === 0 ? i.length - 1 : V - 1);
  }
  function N() {
    s(V === i.length - 1 ? 0 : V + 1);
  }
  return d && T.createElement(
    T.Fragment,
    null,
    V > -1 && T.createElement(e9, { message: t, statefulFileInfoList: i, currentIndex: V, onClickLeft: U, onClickRight: N, onClose: o }),
    T.createElement(t9, { className: n, message: t, isReactionEnabled: a }, i.map(function(R, h) {
      var Z, W, F;
      return T.createElement(
        "div",
        { className: "sendbird-multiple-files-image-renderer-wrapper", onClick: t.sendingStatus === $t.SUCCEEDED ? function() {
          return s(h);
        } : void 0, key: "sendbird-multiple-files-image-renderer-".concat(h, "-").concat(R.url) },
        T.createElement(el, { url: (F = (W = (Z = R.thumbnails) === null || Z === void 0 ? void 0 : Z[0]) === null || W === void 0 ? void 0 : W.url) !== null && F !== void 0 ? F : R.url, fixedSize: !1, width: fZ[d], maxSideLength: fZ.CHAT_WEB, height: fZ[d], borderRadius: l4(s9[d], h, i.length), shadeOnHover: !0, isUploaded: !!R.isUploaded, placeHolder: function(m) {
          var E = m.style;
          return aU(R.mimeType) ? T.createElement(wZ.GIF, { style: E }) : T.createElement(wZ.Default, { style: E });
        }, defaultComponent: T.createElement(wZ.LoadError, null) })
      );
    }))
  );
}
var wZ = {
  Default: function(e) {
    var n = e.style;
    return T.createElement(
      "div",
      { className: "sendbird-multiple-files-image-renderer__thumbnail__placeholder", style: n },
      T.createElement(dt, { type: Le.PHOTO, fillColor: Pe.ON_BACKGROUND_2, width: PV, height: PV })
    );
  },
  GIF: function(e) {
    var n = e.style;
    return T.createElement(
      "div",
      { className: "sendbird-multiple-files-image-renderer__thumbnail__placeholder", style: n },
      T.createElement(
        "div",
        { className: "sendbird-multiple-files-image-renderer__thumbnail__placeholder__icon" },
        T.createElement(dt, { type: Le.GIF, fillColor: Pe.THUMBNAIL_ICON, width: PV, height: PV })
      )
    );
  },
  LoadError: function() {
    return T.createElement(
      "div",
      { className: "sendbird-multiple-files-image-renderer__thumbnail__placeholder" },
      T.createElement(dt, { type: Le.THUMBNAIL_NONE, fillColor: Pe.ON_BACKGROUND_2, width: PV, height: PV })
    );
  }
};
function U9(e) {
  var n = e.threadMessageKind, t = e.isMobile, l = nn(function() {
    return Va(n).with($M.PARENT, function() {
      return t ? "THREAD_PARENT_MOBILE" : "THREAD_PARENT_WEB";
    }).with($M.CHILD, function() {
      return t ? "THREAD_CHILD_MOBILE" : "THREAD_CHILD_WEB";
    }).otherwise(function() {
      return t ? "CHAT_MOBILE" : "CHAT_WEB";
    });
  }, [t, n]);
  return l;
}
var N9 = function(e) {
  var n = Wt(/* @__PURE__ */ new Map()), t = function(a, d) {
    return !n.current.has(a) && d && n.current.set(a, URL.createObjectURL(d)), n.current.get(a);
  }, l = function() {
    n.current.size > 0 && (n.current.forEach(function(a) {
      return URL.revokeObjectURL(a);
    }), n.current.clear());
  };
  return _e(function() {
    return function() {
      return l();
    };
  }, []), !e || !e.isMultipleFilesMessage || !e.isMultipleFilesMessage() ? [] : e.sendingStatus === $t.SUCCEEDED ? (l(), e.fileInfoList.map(function(a) {
    return ce(ce({}, a), { url: a.url, isUploaded: !0 });
  })) : e.messageParams.fileInfoList.map(function(a, d) {
    var r, i;
    return ce(ce({}, a), { url: (i = (r = t(d)) !== null && r !== void 0 ? r : a.fileUrl) !== null && i !== void 0 ? i : a.file instanceof Blob ? t(d, a.file) : void 0, isUploaded: !a.file && typeof a.fileUrl == "string" && a.fileUrl.length > 0 });
  });
}, bF = {
  PRIMARY: "progress-bar-color--primary",
  GRAY: "progress-bar-color--gray"
}, GY = function(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.disabled, a = l === void 0 ? !1 : l, d = e.maxSize, r = e.currentSize, i = r === void 0 ? 0 : r, c = e.colorType, V = c === void 0 ? bF.PRIMARY : c, s = nn(function() {
    return "".concat(i / d * 100, "%");
  }, [i, d]);
  return T.createElement(
    "div",
    { className: "sendbird-progress-bar ".concat(t, " ").concat(V, " ").concat(a ? "progress-bar--disabled" : "") },
    T.createElement("div", { className: "sendbird-progress-bar__fill", style: { width: s } })
  );
}, R9 = function(e, n) {
  return e === void 0 && (e = ""), n === void 0 && (n = ""), "".concat(e, "-").concat(n);
}, yY = function(e) {
  var n, t = e.key, l = t === void 0 ? "" : t, a = e.channelUrl, d = a === void 0 ? "" : a, r = e.audioFile, i = r === void 0 ? null : r, c = e.audioFileUrl, V = c === void 0 ? "" : c, s = me(R9(d, l))[0], o = aH(), U = o.play, N = o.pause, R = o.stop, h = o.voicePlayerStore, Z = Ib().isRecordable, W = ((n = h == null ? void 0 : h.audioStorage) === null || n === void 0 ? void 0 : n[s]) || Ai(), F = function() {
    Z || U == null || U({
      groupKey: s,
      audioFile: i,
      audioFileUrl: V
    });
  }, m = function() {
    N == null || N(s);
  }, E = function(u) {
    u === void 0 && (u = ""), R == null || R(u);
  };
  return _e(function() {
    return function() {
      var u;
      if (i || V) {
        var b = document.getElementById(U0);
        (u = b == null ? void 0 : b.pause) === null || u === void 0 || u.call(b);
      }
    };
  }, []), {
    play: F,
    pause: m,
    stop: E,
    /**
     * The reason why we multiply this by *1000 is,
     * The unit of playbackTime and duration should be millisecond
     */
    playbackTime: ((W == null ? void 0 : W.playbackTime) || 0) * 1e3,
    duration: ((W == null ? void 0 : W.duration) || 0) * 1e3,
    playingStatus: W.playingStatus
  };
}, BY = function(e) {
  var n = e.className, t = e.time, l = t === void 0 ? 0 : t, a = e.labelType, d = a === void 0 ? oe.CAPTION_2 : a, r = e.labelColor, i = r === void 0 ? ie.ONCONTENT_1 : r, c = l < 0 ? 0 : l, V = Math.floor(c / 36e5), s = Math.floor(c % 36e5 / 6e4), o = Math.floor(c % 36e5 % 6e4 / 1e3);
  return T.createElement(
    "div",
    { className: "sendbird-ui-play-time ".concat(n) },
    T.createElement(Fe, { type: d, color: i }, "".concat(V ? V + ":" : "").concat(s < 10 ? "0" : "").concat(s || "0", ":").concat(o < 10 ? "0" : "").concat(o))
  );
}, h9 = function(e) {
  var n, t = e.className, l = e.message, a = e.channelUrl, d = e.isByMe, r = d === void 0 ? !1 : d, i = e.isReactionEnabled, c = i === void 0 ? !1 : i, V = me(!1), s = V[0], o = V[1], U = yY({
    channelUrl: a,
    key: "".concat(l == null ? void 0 : l.messageId),
    audioFileUrl: l == null ? void 0 : l.url
  }), N = U.play, R = U.pause, h = U.playbackTime, Z = h === void 0 ? 0 : h, W = U.duration, F = U.playingStatus, m = F === void 0 ? Td.IDLE : F;
  _e(function() {
    var u;
    c && ((u = l == null ? void 0 : l.reactions) === null || u === void 0 ? void 0 : u.length) > 0 ? o(!0) : o(!1);
  }, [c, (n = l == null ? void 0 : l.reactions) === null || n === void 0 ? void 0 : n.length]);
  var E = nn(function() {
    var u;
    if (l != null && l.metaArrays) {
      var b = (u = l == null ? void 0 : l.metaArrays.find(function(k) {
        return k.key === "KEY_VOICE_MESSAGE_DURATION";
      })) === null || u === void 0 ? void 0 : u.value[0];
      return b && parseInt(b);
    }
    return 1;
  }, [l == null ? void 0 : l.metaArrays]);
  return T.createElement(
    "div",
    { className: "sendbird-voice-message-item-body ".concat(t, " ").concat(s ? "is-reactions-contained" : "") },
    T.createElement(GY, { className: "sendbird-voice-message-item-body__progress-bar", maxSize: W || E, currentSize: Z, colorType: r ? bF.PRIMARY : bF.GRAY }),
    T.createElement(
      "div",
      { className: "sendbird-voice-message-item-body__status-button" },
      (m === Td.IDLE || m === Td.PAUSED) && T.createElement(
        "div",
        { className: "sendbird-voice-message-item-body__status-button__button", onClick: N },
        T.createElement(dt, { width: "18px", height: "18px", type: Le.PLAY, fillColor: Pe.PRIMARY })
      ),
      m === Td.PREPARING && T.createElement(
        Vh,
        { width: "22.2px", height: "22.2px" },
        T.createElement(dt, { width: "22.2px", height: "22.2px", type: Le.SPINNER, fillColor: Pe.PRIMARY_2 })
      ),
      m === Td.PLAYING && T.createElement(
        "div",
        { className: "sendbird-voice-message-item-body__status-button__button", onClick: function() {
          R();
        } },
        T.createElement(
          "div",
          { className: "sendbird-voice-message-item-body__status-button__button__pause" },
          T.createElement("div", { className: "sendbird-voice-message-item-body__status-button__button__pause__inner" }),
          T.createElement("div", { className: "sendbird-voice-message-item-body__status-button__button__pause__inner" })
        )
      )
    ),
    T.createElement(BY, { className: "sendbird-voice-message-item-body__playback-time", time: E - Z, labelType: oe.BODY_1, labelColor: r ? ie.ONCONTENT_1 : ie.ONBACKGROUND_1 })
  );
};
function Z9(e) {
  var n, t, l = e.className, a = l === void 0 ? "" : l, d = e.message, r = e.isByMe, i = r === void 0 ? !1 : r, c = e.mouseHover, V = c === void 0 ? !1 : c, s = e.isReactionEnabled, o = s === void 0 ? !1 : s, U = e.showFileViewer, N = U === void 0 ? dl : U, R = e.style, h = R === void 0 ? {} : R, Z = vY(d), W = me(!1), F = W[0], m = W[1], E = cU({
    onLongPress: dl,
    onClick: function() {
      So(d) && (N == null || N(!0));
    }
  });
  return T.createElement(
    "div",
    ce({ className: vn([
      a,
      "sendbird-thumbnail-message-item-body",
      i ? "outgoing" : "incoming",
      V ? "mouse-hover" : "",
      o && ((t = (n = d.reactions) === null || n === void 0 ? void 0 : n.length) !== null && t !== void 0 ? t : 0) > 0 ? "reactions" : ""
    ]) }, E),
    T.createElement(el, { className: "sendbird-thumbnail-message-item-body__thumbnail", url: Z || SR(d), alt: ER(d), width: (h == null ? void 0 : h.width) || "360px", height: (h == null ? void 0 : h.height) || "270px", onLoad: function() {
      m(!0);
    }, placeHolder: function(u) {
      var b = u.style;
      return T.createElement("div", { className: "sendbird-thumbnail-message-item-body__placeholder", style: b });
    } }),
    dc(d) && !Z && !F && T.createElement(
      "video",
      { className: "sendbird-thumbnail-message-item-body__video" },
      T.createElement("source", { src: SR(d), type: ER(d) })
    ),
    T.createElement("div", { className: "sendbird-thumbnail-message-item-body__image-cover" }),
    (dc(d) || o0(d)) && T.createElement(
      "div",
      { className: "sendbird-thumbnail-message-item-body__icon-wrapper" },
      T.createElement(
        "div",
        { className: "sendbird-thumbnail-message-item-body__icon-wrapper__icon" },
        T.createElement(dt, { type: dc(d) ? Le.PLAY : Le.GIF, fillColor: Pe.THUMBNAIL_ICON, width: "34px", height: "34px" })
      )
    )
  );
}
function T9(e) {
  var n, t = e.className, l = e.message, a = e.isByMe, d = a === void 0 ? !1 : a, r = e.mouseHover, i = r === void 0 ? !1 : r, c = e.isReactionEnabled, V = c === void 0 ? !1 : c, s = Gt(Kn).stringSet;
  return T.createElement(
    "div",
    { className: vn([
      t,
      "sendbird-unknown-message-item-body",
      d ? "outgoing" : "incoming",
      i ? "mouse-hover" : "",
      V && ((n = l == null ? void 0 : l.reactions) === null || n === void 0 ? void 0 : n.length) > 0 ? "reactions" : ""
    ]) },
    T.createElement(Fe, { className: "sendbird-unknown-message-item-body__header", type: oe.BODY_1, color: d ? ie.ONCONTENT_1 : ie.ONBACKGROUND_1 }, s.UNKNOWN__UNKNOWN_MESSAGE_TYPE),
    T.createElement(Fe, { className: "sendbird-unknown-message-item-body__description", type: oe.BODY_1, color: d ? ie.ONCONTENT_2 : ie.ONBACKGROUND_2 }, s.UNKNOWN__CANNOT_READ_MESSAGE)
  );
}
var rt;
(function(e) {
  e.Box = "box", e.Text = "text", e.Image = "image", e.TextButton = "textButton", e.ImageButton = "imageButton";
})(rt || (rt = {}));
const F9 = () => {
}, DY = (e) => {
  const n = (e == null ? void 0 : e.defaultMapper) || F9, t = {
    defaultMapper: n,
    mapBoxProps: (e == null ? void 0 : e.mapBoxProps) || n,
    mapTextProps: (e == null ? void 0 : e.mapTextProps) || n,
    mapImageProps: (e == null ? void 0 : e.mapImageProps) || n,
    mapTextButtonProps: (e == null ? void 0 : e.mapTextButtonProps) || n,
    mapImageButtonProps: (e == null ? void 0 : e.mapImageButtonProps) || n
  };
  return {
    parse(l, a) {
      switch (l.type) {
        case rt.Box:
          return { properties: t.mapBoxProps(l, a) };
        case rt.Text:
          return { properties: t.mapTextProps(l, a) };
        case rt.Image:
          return { properties: t.mapImageProps(l, a) };
        case rt.TextButton:
          return { properties: t.mapTextButtonProps(l, a) };
        case rt.ImageButton:
          return { properties: t.mapImageButtonProps(l, a) };
        default:
          return { properties: void 0 };
      }
    }
  };
}, Us = ({ children: e }) => T.createElement(T.Fragment, null, e);
function XY(e) {
  var n, t, l, a, d;
  return {
    box: ((n = e == null ? void 0 : e.views) === null || n === void 0 ? void 0 : n.box) || Us,
    text: ((t = e == null ? void 0 : e.views) === null || t === void 0 ? void 0 : t.text) || Us,
    image: ((l = e == null ? void 0 : e.views) === null || l === void 0 ? void 0 : l.image) || Us,
    imageButton: ((a = e == null ? void 0 : e.views) === null || a === void 0 ? void 0 : a.imageButton) || Us,
    textButton: ((d = e == null ? void 0 : e.views) === null || d === void 0 ? void 0 : d.textButton) || Us
  };
}
var W9 = function(e, n) {
  var t = {};
  for (var l in e)
    Object.prototype.hasOwnProperty.call(e, l) && n.indexOf(l) < 0 && (t[l] = e[l]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, l = Object.getOwnPropertySymbols(e); a < l.length; a++)
      n.indexOf(l[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, l[a]) && (t[l[a]] = e[l[a]]);
  return t;
};
const OY = _l({
  sizes: {},
  updateSize: () => {
  }
}), m9 = ({ children: e }) => {
  const [n, t] = me({}), l = Pt((a) => {
    var { id: d } = a, r = W9(a, ["id"]);
    d && t((i) => Object.assign(Object.assign({}, i), { [d]: r }));
  }, []);
  return T.createElement(OY.Provider, { value: { sizes: n, updateSize: l } }, e);
}, u9 = () => Gt(OY), p9 = (e) => {
  const n = /* @__PURE__ */ new Map(), t = function(l) {
    return (n.has(l) || n.set(l, e.call(this, l))) && n.get(l);
  };
  return t.cache = n, t;
}, M9 = p9((e) => {
  const n = (t, l) => {
    "items" in t && (t == null ? void 0 : t.items) != null && t.items.forEach((a, d) => {
      const r = `${l}-${d}`;
      a.id = r, n(a, r);
    });
  };
  return e.forEach((t, l) => {
    const a = `${l}`;
    t.id = a, n(t, a);
  }), e;
});
var Nn;
(function(e) {
  e.Row = "row", e.Column = "column";
})(Nn || (Nn = {}));
var Fn;
(function(e) {
  e.Center = "center", e.Left = "left", e.Right = "right", e.Top = "top", e.Bottom = "bottom";
})(Fn || (Fn = {}));
var Zn;
(function(e) {
  e[e.FillParent = 0] = "FillParent", e[e.WrapContent = 1] = "WrapContent";
})(Zn || (Zn = {}));
var Fl;
(function(e) {
  e.Normal = "normal", e.Bold = "bold";
})(Fl || (Fl = {}));
var jl;
(function(e) {
  e.AspectFit = "aspectFit", e.AspectFill = "aspectFill", e.ScalesToFill = "scalesToFill";
})(jl || (jl = {}));
const br = {
  rootLayout: Nn.Column,
  view: {
    size: {
      width: { type: "flex", value: Zn.FillParent },
      height: { type: "flex", value: Zn.WrapContent }
    }
  },
  box: {
    layout: Nn.Row,
    align: { vertical: Fn.Top, horizontal: Fn.Left }
  }
}, jY = (e) => {
  const n = e.Container || T.Fragment, t = e.UnknownMessage || (() => null), l = e.parser || DY(), a = e.renderer || XY(), d = (r) => {
    var i;
    const c = r.templateItems, V = (i = r.parentLayout) !== null && i !== void 0 ? i : br.box.layout;
    return T.createElement(T.Fragment, null, c.map((s, o, U) => {
      const { properties: N } = l.parse(s, { parentLayout: V, elemIdx: o, siblings: U }), R = {
        key: o,
        parentLayout: V,
        parsedProperties: N,
        siblings: U
      };
      switch (s.type) {
        case rt.Box:
          return T.createElement(
            a.box,
            Object.assign({}, s, R),
            T.createElement(d, { templateItems: s.items || [], parentLayout: s.layout })
          );
        case rt.Text:
          return T.createElement(a.text, Object.assign({}, s, R));
        case rt.Image:
          return T.createElement(a.image, Object.assign({}, s, R));
        case rt.TextButton:
          return T.createElement(a.textButton, Object.assign({}, s, R));
        case rt.ImageButton:
          return T.createElement(a.imageButton, Object.assign({}, s, R));
        default:
          return T.createElement(t, { item: s });
      }
    }));
  };
  return {
    MessageTemplate: ({ parentLayout: r = br.rootLayout, templateItems: i }) => {
      const c = M9(i);
      return T.createElement(
        m9,
        null,
        T.createElement(
          n,
          null,
          T.createElement(d, { parentLayout: r, templateItems: c })
        )
      );
    },
    MessageTemplateBase: d
  };
};
var Oa;
(function(e) {
  e.Web = "web", e.Custom = "custom", e.UIKit = "uikit";
})(Oa || (Oa = {}));
const aN = (e) => {
  switch (e) {
    case Fn.Right:
    case Fn.Bottom:
      return "flex-end";
    case Fn.Center:
      return "center";
    case Fn.Left:
    case Fn.Top:
    default:
      return "flex-start";
  }
};
rt.Image, Oa.Web, jl.AspectFill, rt.Box, Nn.Column, Zn.FillParent, rt.Box, Zn.FillParent, Zn.FillParent, rt.Box, Nn.Column, Zn.FillParent, Zn.WrapContent, rt.Text, Fn.Center, Fn.Center, Zn.FillParent, rt.Image, Oa.Web, Zn.FillParent, jl.AspectFill, rt.Box, Zn.FillParent, rt.Box, Zn.FillParent, Zn.FillParent, rt.Box, Nn.Column, rt.Box, Fn.Left, Fn.Center, Nn.Row, Zn.FillParent, rt.Text, Zn.FillParent, Fn.Center, Fn.Left, Fl.Bold, rt.ImageButton, Oa.UIKit, jl.AspectFit, rt.Text, rt.TextButton, Oa.Web, Fl.Bold;
rt.Image, Oa.Web, jl.AspectFill, rt.Box, Nn.Column, Zn.FillParent, rt.Box, Zn.FillParent, Nn.Row, rt.TextButton, Oa.Web, Fl.Bold, rt.TextButton, Oa.Web, Zn.FillParent, Fl.Bold, rt.Box, Zn.FillParent, Nn.Row, rt.Text, Zn.FillParent, Fl.Bold, rt.ImageButton, Oa.UIKit, jl.AspectFit, rt.Text;
rt.Box, Nn.Column, rt.Image, jl.AspectFill, rt.Box, Nn.Column, rt.Text, Fl.Bold, rt.Text, rt.Box, Fn.Left, Fn.Center, Nn.Row, rt.Image, jl.AspectFill, rt.Box, Fn.Left, Fn.Center, Nn.Column, rt.Text, Fl.Bold, rt.Text, Fl.Bold, rt.Box, Fn.Left, Fn.Center, Nn.Row, rt.Image, jl.AspectFill, rt.Box, Fn.Left, Fn.Center, Nn.Column, rt.Text, Fl.Bold, rt.Text, Fl.Bold, rt.Box, Fn.Left, Fn.Center, Nn.Row, rt.Image, jl.AspectFill, rt.Box, Fn.Left, Fn.Center, Nn.Column, rt.Text, Fl.Bold, rt.Text, Fl.Bold, rt.Box, Fn.Left, Fn.Center, Nn.Row, rt.TextButton, Oa.Web, Fl.Bold, rt.TextButton, Oa.Web, Fl.Bold;
rt.Box, Nn.Column, rt.Image, rt.Box, Nn.Column, rt.Box, Nn.Row, rt.Box, Nn.Column, rt.Text, Fl.Bold, rt.Text, rt.ImageButton, Oa.UIKit, rt.Box, Nn.Column, rt.Box, Fn.Left, Fn.Center, Nn.Row, rt.Image, jl.AspectFill, rt.Box, Nn.Column, rt.Text, Fl.Bold, rt.Text, rt.Box, Fn.Left, Fn.Center, Nn.Row, rt.Image, jl.AspectFill, rt.Box, Nn.Column, rt.Text, Fl.Bold, rt.Text;
Zn.FillParent, Zn.FillParent, Zn.FillParent, Zn.FillParent, Zn.FillParent, Zn.FillParent;
var E9 = function(e, n) {
  var t = {};
  for (var l in e)
    Object.prototype.hasOwnProperty.call(e, l) && n.indexOf(l) < 0 && (t[l] = e[l]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, l = Object.getOwnPropertySymbols(e); a < l.length; a++)
      n.indexOf(l[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, l[a]) && (t[l[a]] = e[l[a]]);
  return t;
};
const S9 = (e) => {
  const { imageSize: n, canvasRef: t, canvasProps: l } = k9(e);
  return T.createElement("canvas", Object.assign({}, l, { ref: t, width: n == null ? void 0 : n.width, height: n == null ? void 0 : n.height, onError: e.onError }));
}, k9 = (e) => {
  var { metaData: n, tintColor: t } = e, l = E9(e, ["metaData", "tintColor"]);
  const a = Wt(null), [d, r] = me(), i = nn(() => n != null && n.pixelHeight && (n != null && n.pixelWidth) ? { width: n.pixelWidth, height: n.pixelHeight } : d, [d, n == null ? void 0 : n.pixelHeight, n == null ? void 0 : n.pixelWidth]);
  return _e(() => {
    if (i == null && (console.log("Canvas_ReactMessageTemplateImage: no metaData, render fit to container"), a.current)) {
      a.current.style.width = "100%", a.current.style.height = "100%";
      const c = a.current.getBoundingClientRect();
      r(c);
    }
  }, [i]), _e(() => {
    if (l.src) {
      const c = new Image(), V = () => {
        if (a.current && t && i) {
          const o = a.current.getContext("2d");
          if (o) {
            const { width: U, height: N } = i;
            o.clearRect(0, 0, U, N), o.beginPath(), o.globalCompositeOperation = "source-over", o.fillStyle = "#000", o.drawImage(c, 0, 0, U, N), o.globalCompositeOperation = "source-atop", o.fillStyle = t, o.fillRect(0, 0, U, N);
          }
        }
      }, s = (o) => {
        var U;
        (U = l.onError) === null || U === void 0 || U.call(l, o);
      };
      return c.addEventListener("load", V), c.addEventListener("error", s), c.src = l.src, () => {
        c.removeEventListener("load", V), c.removeEventListener("error", s);
      };
    }
  }, [l.src, i, t]), {
    canvasRef: a,
    canvasProps: l,
    imageSize: i
  };
}, b9 = (e) => T.createElement("img", Object.assign({}, e, { onError: e.onError, referrerPolicy: "no-referrer" })), Y9 = (e) => T.createElement("div", { style: Object.assign(Object.assign({}, e.style), { backgroundColor: "transparent" }) });
var Q9 = function(e, n) {
  var t = {};
  for (var l in e)
    Object.prototype.hasOwnProperty.call(e, l) && n.indexOf(l) < 0 && (t[l] = e[l]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, l = Object.getOwnPropertySymbols(e); a < l.length; a++)
      n.indexOf(l[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, l[a]) && (t[l[a]] = e[l[a]]);
  return t;
};
const e2 = (e) => {
  var { tintColor: n, metaData: t } = e, l = Q9(e, ["tintColor", "metaData"]);
  const { hasError: a, onError: d } = J9(l.src);
  return l.onError && console.warn("`onError` is intercepted and not executed in the ReactMessageTemplateImage."), a ? T.createElement(Y9, Object.assign({}, l)) : n ? T.createElement(S9, Object.assign({}, l, { onError: d, tintColor: n, metaData: t })) : T.createElement(b9, Object.assign({}, l, { onError: d }));
}, J9 = (e) => {
  const [n, t] = me(!1);
  return _e(() => t(!1), [e]), {
    hasError: n,
    onError: Pt(() => t(!0), [])
  };
}, HY = T.createContext(null), v9 = (e) => {
  const { message: n, handleWebAction: t, handleCustomAction: l, handlePredefinedAction: a, children: d } = e, r = T.useMemo(() => ({
    message: n,
    handleWebAction: t,
    handleCustomAction: l,
    handlePredefinedAction: a
  }), [n == null ? void 0 : n.updatedAt]);
  return T.createElement(HY.Provider, { value: r }, d);
}, z9 = () => T.useContext(HY);
function x9(e) {
  var n;
  return e.type === rt.Text && ((n = e.width) === null || n === void 0 ? void 0 : n.value) == Zn.WrapContent;
}
const t2 = ({ size: e, option: n }) => n === "wrap" ? e.type === "flex" && e.value == Zn.WrapContent : n === "fill" ? e.type === "flex" && e.value == Zn.FillParent : e.type === "fixed";
function fY(e) {
  const n = Wt(e);
  return _e(() => {
    n.current = e;
  }, [e]), Pt((...t) => n.current(...t), [n]);
}
function G9(e, n) {
  const t = fY(e), l = Wt(n2);
  return Pt((d) => {
    if (l.current(), l.current = n2, d != null) {
      const r = e(d);
      typeof r == "function" && (l.current = r);
    }
  }, [t, ...n]);
}
function n2() {
}
function y9(e) {
  const n = fY(e);
  return G9((l) => {
    const a = new ResizeObserver((d) => {
      d[0] != null && n(d[0]);
    });
    return a.observe(l), () => {
      a.unobserve(l);
    };
  }, [n]);
}
function B9() {
  const [e, n] = me(-1), [t, l] = me(-1), [a, d] = me(-1), [r, i] = me(-1), [c, V] = me(-1), [s, o] = me(-1);
  return { ref: y9((N) => {
    const { width: R, height: h } = N.contentRect, Z = N.target, { width: W, height: F } = Z.getBoundingClientRect();
    n(W), l(F), d(R), i(h), V(W - R), o(F - h);
  }), width: e, height: t, contentWidth: a, contentHeight: r, paddingWidth: c, paddingHeight: s };
}
var D9 = function(e, n) {
  var t = {};
  for (var l in e)
    Object.prototype.hasOwnProperty.call(e, l) && n.indexOf(l) < 0 && (t[l] = e[l]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, l = Object.getOwnPropertySymbols(e); a < l.length; a++)
      n.indexOf(l[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, l[a]) && (t[l[a]] = e[l[a]]);
  return t;
};
function dN({ width: e = br.view.size.width, height: n = br.view.size.height, parentLayout: t = br.box.layout, option: l }) {
  return t === Nn.Row ? t2({
    size: e,
    option: l
  }) : t2({
    size: n,
    option: l
  });
}
function X9(e) {
  const { style: n, props: t } = e, l = B9(), { ref: a } = l, d = D9(l, ["ref"]), { updateSize: r, sizes: i } = u9(), { id: c, siblings: V, parentLayout: s } = t, { width: o, height: U, paddingWidth: N, paddingHeight: R, contentWidth: h, contentHeight: Z } = d;
  return _e(() => {
    r({
      id: t.id,
      width: o,
      height: U,
      paddingWidth: N,
      paddingHeight: R,
      contentWidth: h,
      contentHeight: Z
    });
  }, [t.id, o, U, N, R, h, Z, r]), { recalculatedStyle: nn(() => {
    const F = (E = 0, u) => {
      var b, k, Q, S;
      return s === Nn.Row ? E + ((k = (b = i[u.id]) === null || b === void 0 ? void 0 : b.contentWidth) !== null && k !== void 0 ? k : 0) : E + ((S = (Q = i[u.id]) === null || Q === void 0 ? void 0 : Q.contentHeight) !== null && S !== void 0 ? S : 0);
    };
    if (dN({
      width: t.width,
      height: t.height,
      parentLayout: s,
      option: "fill"
    })) {
      const E = V.filter(({ width: k, height: Q }) => !dN({
        width: k,
        height: Q,
        parentLayout: s,
        option: "fill"
      })).reduce(F, 0), u = V.filter(({ width: k, height: Q }) => dN({
        width: k,
        height: Q,
        parentLayout: s,
        option: "fill"
      })).length, b = (() => s === Nn.Row ? {
        maxWidth: `calc((100% - ${E}px) / ${u})`
      } : {
        maxHeight: `calc((100% - ${E}px) / ${u})`
      })();
      return Object.assign(Object.assign(Object.assign({}, n), b), o == 0 && { height: 0 });
    } else {
      const E = V.findIndex((b) => b.id === c), u = V.slice(0, E).filter(({ width: b, height: k }) => dN({
        width: b,
        height: k,
        parentLayout: s,
        option: "wrap"
      })).reduce(F, 0);
      return Object.assign(Object.assign(Object.assign({}, n), o === 0 && { height: 0 }), s === Nn.Row ? {
        maxWidth: `calc(100% - ${u}px)`
      } : {
        maxHeight: `calc(100% - ${u}px)`
      });
    }
  }, [t.width, t.height, s, i, V, n, o, c]), elemRef: a };
}
function Ns(e) {
  return Object.assign({ display: "flex", overflow: "hidden", boxSizing: "border-box" }, e);
}
function Rs(e, n, t) {
  f9(e, n, t), j9(e, n);
}
function O9(e, n, t, l) {
  n && (e["--border-width"] = `${n}px`, e["--border-color"] = t || "transparent"), l && (e.borderRadius = Number(l), e["--border-radius"] = `${l}px`);
}
function j9(e, n) {
  var t, l, a, d;
  const { viewStyle: r } = n;
  !((t = r == null ? void 0 : r.margin) === null || t === void 0) && t.top && (e.marginTop = Number(r.margin.top)), !((l = r == null ? void 0 : r.margin) === null || l === void 0) && l.bottom && (e.marginBottom = Number(r.margin.bottom)), !((a = r == null ? void 0 : r.margin) === null || a === void 0) && a.left && (e.marginLeft = Number(r.margin.left)), !((d = r == null ? void 0 : r.margin) === null || d === void 0) && d.right && (e.marginRight = Number(r.margin.right)), r != null && r.backgroundColor && (e.backgroundColor = r.backgroundColor), r != null && r.backgroundImageUrl && (e.backgroundImage = `url(${JSON.stringify(r.backgroundImageUrl)})`), O9(e, r == null ? void 0 : r.borderWidth, r == null ? void 0 : r.borderColor, r == null ? void 0 : r.radius);
}
function H9(e, n, t) {
  const l = {};
  return e.type === "flex" && e.value == Zn.FillParent ? (l.width = "100%", t === Nn.Row && (l.flex = 1)) : e.type === "fixed" && e.value >= 0 && (l.width = Number(e.value)), n.type === "flex" && n.value == Zn.FillParent ? (l.height = "100%", t === Nn.Column && (l.flex = 1)) : n.type === "fixed" && n.value >= 0 && (l.height = Number(n.value)), l;
}
function f9(e, n, t) {
  var l, a;
  const { width: d, height: r } = br.view.size, { parentLayout: i } = t, c = H9((l = n.width) !== null && l !== void 0 ? l : d, (a = n.height) !== null && a !== void 0 ? a : r, i);
  Object.assign(e, c);
}
function l2(e, n = br.box.layout, t = br.box.align) {
  n === Nn.Row && (e.flexDirection = "row", e.alignItems = aN(t.vertical), e.justifyContent = aN(t.horizontal)), n === Nn.Column && (e.flexDirection = "column", e.alignItems = aN(t.horizontal), e.justifyContent = aN(t.vertical));
}
function w9(e, n = br.box.align.horizontal) {
  e.textAlign = n;
}
function a2(e, n) {
  const { contentMode: t = jl.AspectFit } = n || {};
  if (t)
    switch (t) {
      case jl.AspectFill:
        e.objectFit = "cover";
        break;
      case jl.AspectFit:
        e.objectFit = "contain";
        break;
      case jl.ScalesToFill:
        e.objectFit = "fill";
        break;
    }
}
function d2(e, n) {
  var t, l, a, d;
  const r = n == null ? void 0 : n.metaData;
  !(r != null && r.pixelHeight) || !(r != null && r.pixelWidth) || ((t = n == null ? void 0 : n.width) === null || t === void 0 ? void 0 : t.type) === "fixed" || ((l = n == null ? void 0 : n.height) === null || l === void 0 ? void 0 : l.type) === "fixed" || (e.aspectRatio = `${(a = n == null ? void 0 : n.metaData) === null || a === void 0 ? void 0 : a.pixelWidth} / ${(d = n == null ? void 0 : n.metaData) === null || d === void 0 ? void 0 : d.pixelHeight}`);
}
function g9(e) {
  return {
    WebkitLineClamp: e,
    WebkitBoxOrient: "vertical",
    display: "-webkit-box",
    overflow: "hidden",
    overflowWrap: "anywhere",
    flex: 1
  };
}
function r2(e, n, t) {
  const { textStyle: l, width: a } = n, { size: d, color: r, weight: i = "normal" } = l || {};
  if (d && (e.fontSize = Number(d)), r && (e.color = r), i && (e.fontWeight = i), (a == null ? void 0 : a.value) == Zn.WrapContent && (e.maxWidth = "100%"), n.type === rt.Text) {
    const { siblings: c, elemIdx: V } = t;
    c != null && c.length >= 2 && c.every(x9) && (e.flexShrink = c.length - 1 === V ? 1 : 0);
  }
}
var I9 = function(e, n) {
  var t = {};
  for (var l in e)
    Object.prototype.hasOwnProperty.call(e, l) && n.indexOf(l) < 0 && (t[l] = e[l]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, l = Object.getOwnPropertySymbols(e); a < l.length; a++)
      n.indexOf(l[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, l[a]) && (t[l[a]] = e[l[a]]);
  return t;
};
const L9 = (e = "") => ["http://", "https://", "ftp://"].some((n) => e.startsWith(n)), C9 = (e = "") => L9(e) ? e : `https://${e}`, hs = ({ className: e = "", style: n, children: t, props: l }) => {
  var a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E;
  const { recalculatedStyle: u, elemRef: b } = X9({ style: n, props: l }), { message: k, handleWebAction: Q, handleCustomAction: S, handlePredefinedAction: v } = z9(), G = (q) => {
    var ae, se, le, L, $;
    ((ae = l == null ? void 0 : l.action) === null || ae === void 0 ? void 0 : ae.type) === "web" && (Q ? Q == null || Q(q, l.action, k) : (le = window == null ? void 0 : window.open(C9((se = l == null ? void 0 : l.action) === null || se === void 0 ? void 0 : se.data), "_blank", "noopener noreferrer")) === null || le === void 0 || le.focus()), ((L = l == null ? void 0 : l.action) === null || L === void 0 ? void 0 : L.type) === "custom" && (S == null || S(q, l.action, k)), (($ = l == null ? void 0 : l.action) === null || $ === void 0 ? void 0 : $.type) === "uikit" && (v == null || v(q, l.action, k));
  }, w = !((a = l.viewStyle) === null || a === void 0) && a.borderWidth ? " sb-message-template__border" : "";
  if (e === "sb-message-template__text-button")
    return T.createElement("button", { className: `${e}${w}`, "data-sb-template-id": l.elementId, style: Object.assign(Object.assign({}, n), { paddingTop: (r = (d = l.viewStyle) === null || d === void 0 ? void 0 : d.padding) === null || r === void 0 ? void 0 : r.top, paddingRight: (c = (i = l.viewStyle) === null || i === void 0 ? void 0 : i.padding) === null || c === void 0 ? void 0 : c.right, paddingBottom: (s = (V = l.viewStyle) === null || V === void 0 ? void 0 : V.padding) === null || s === void 0 ? void 0 : s.bottom, paddingLeft: (U = (o = l.viewStyle) === null || o === void 0 ? void 0 : o.padding) === null || U === void 0 ? void 0 : U.left }), onClick: G }, t);
  const { display: y, flexDirection: g, justifyContent: f, alignItems: I, objectFit: K } = u, Ue = I9(u, ["display", "flexDirection", "justifyContent", "alignItems", "objectFit"]);
  return T.createElement(
    "div",
    { ref: b, className: `${e}${w} ${l != null && l.action ? "sb-message-template__action" : ""}`, "data-sb-template-id": l.elementId, style: Ue, onClick: G },
    T.createElement("div", { style: {
      display: y,
      flexDirection: g,
      justifyContent: f,
      alignItems: I,
      objectFit: K,
      width: "100%",
      height: "100%",
      paddingTop: (R = (N = l.viewStyle) === null || N === void 0 ? void 0 : N.padding) === null || R === void 0 ? void 0 : R.top,
      paddingRight: (Z = (h = l.viewStyle) === null || h === void 0 ? void 0 : h.padding) === null || Z === void 0 ? void 0 : Z.right,
      paddingBottom: (F = (W = l.viewStyle) === null || W === void 0 ? void 0 : W.padding) === null || F === void 0 ? void 0 : F.bottom,
      paddingLeft: (E = (m = l.viewStyle) === null || m === void 0 ? void 0 : m.padding) === null || E === void 0 ? void 0 : E.left
    } }, t)
  );
};
function K9(e) {
  var n, t, l, a;
  const d = (n = e == null ? void 0 : e.height) === null || n === void 0 ? void 0 : n.type, r = (t = e == null ? void 0 : e.width) === null || t === void 0 ? void 0 : t.type, i = d === "fixed" || r === "fixed", c = d === "flex" && ((l = e == null ? void 0 : e.height) === null || l === void 0 ? void 0 : l.value) === Zn.FillParent || r === "flex" && ((a = e == null ? void 0 : e.width) === null || a === void 0 ? void 0 : a.value) === Zn.FillParent;
  return i || c;
}
function i2(e) {
  const { text: n, maxTextLines: t } = e, l = K9(e), a = t != null && t > 0;
  if (a || l) {
    const d = Object.assign(Object.assign({}, (a || l) && { maxWidth: "100%" }), l && { maxHeight: "100%", overflow: "hidden" });
    return T.createElement("div", { style: d }, a ? T.createElement("div", { style: g9(t) }, n) : n);
  }
  return n;
}
const wY = XY({
  views: {
    box(e) {
      return T.createElement(hs, { className: "sb-message-template__box", elementId: e.elementId, style: e.parsedProperties, props: e }, e.children);
    },
    text(e) {
      return T.createElement(hs, { className: "sb-message-template__text", elementId: e.elementId, style: e.parsedProperties, props: e }, i2(e));
    },
    image(e) {
      var n;
      return T.createElement(
        hs,
        { className: "sb-message-template__image-container", elementId: e.elementId, style: e.parsedProperties, props: e },
        T.createElement(e2, { className: "sb-message-template__image", alt: "image", src: e.imageUrl, style: { width: "100%", height: "100%", aspectRatio: "inherit", objectFit: "inherit" }, tintColor: (n = e.imageStyle) === null || n === void 0 ? void 0 : n.tintColor, metaData: e.metaData })
      );
    },
    textButton(e) {
      return T.createElement(hs, { className: "sb-message-template__text-button", elementId: e.elementId, style: e.parsedProperties, props: e }, i2(e));
    },
    imageButton(e) {
      var n;
      return T.createElement(
        hs,
        { className: "sb-message-template__image-container sb-message-template__image-button", elementId: e.elementId, style: e.parsedProperties, props: e },
        T.createElement(e2, { className: "sb-message-template__image", alt: "image-button", src: e.imageUrl, style: { width: "100%", height: "100%", aspectRatio: "inherit", objectFit: "inherit" }, tintColor: (n = e.imageStyle) === null || n === void 0 ? void 0 : n.tintColor, metaData: e.metaData })
      );
    }
  }
}), gY = DY({
  mapBoxProps(e, n) {
    const t = Ns();
    return Rs(t, e, n), l2(t, e.layout, e.align), t;
  },
  mapTextProps(e, n) {
    var t;
    const l = Ns({ whiteSpace: "pre-line" });
    return Rs(l, e, n), r2(l, e, n), l2(l, Nn.Row, e.align), w9(l, (t = e.align) === null || t === void 0 ? void 0 : t.horizontal), l;
  },
  mapImageProps(e, n) {
    const t = Ns();
    return Rs(t, e, n), a2(t, e.imageStyle), d2(t, e), t;
  },
  mapTextButtonProps(e, n) {
    const t = Ns({ whiteSpace: "pre-line", alignItems: "center", justifyContent: "center" });
    return Rs(t, e, n), r2(t, Object.assign(Object.assign({}, e), { textStyle: Object.assign({ weight: 500 }, e.textStyle) }), n), t;
  },
  mapImageButtonProps(e, n) {
    const t = Ns();
    return Rs(t, e, n), a2(t, e.imageStyle), d2(t, e), t;
  }
});
jY({
  renderer: wY,
  parser: gY,
  Container: ({ children: e }) => T.createElement("div", { className: "sb-message-template__parent", style: {
    display: "flex",
    flexDirection: "column",
    maxWidth: 400,
    backgroundColor: "#cecece",
    marginBottom: 24,
    borderRadius: "8px"
  } }, e)
});
var _9 = jY({
  parser: gY,
  renderer: wY,
  Container: function(e) {
    var n = e.children;
    return T.createElement("div", { className: [
      "sb-message-template__parent",
      "sendbird-message-template__root"
    ].join(" ") }, n);
  }
}).MessageTemplate;
function P9(e) {
  var n = e.templateItems;
  return T.createElement(_9, { templateItems: n });
}
function gZ(e) {
  var n = e.className, t = e.message, l = e.isByMe, a = Gt(Kn).stringSet, d = t.message;
  return T.createElement("div", { className: vn([
    n,
    l ? "outgoing" : "incoming",
    "sendbird-template-message-item-body__fallback_message"
  ]) }, d ? T.createElement(
    T.Fragment,
    null,
    T.createElement(Fe, { type: oe.BODY_1, color: ie.ONCONTENT_INVERSE_1 }, d)
  ) : T.createElement(
    T.Fragment,
    null,
    T.createElement(Fe, { className: "sendbird-template-message-item-body__fallback_message__header", type: oe.BODY_1, color: ie.ONCONTENT_INVERSE_1 }, a.UNKNOWN__TEMPLATE_ERROR),
    T.createElement(Fe, { className: "sendbird-template-message-item-body__fallback_message__description", type: oe.BODY_1, color: ie.ONCONTENT_INVERSE_5 }, a.UNKNOWN__CANNOT_READ_TEMPLATE)
  ));
}
var rN = "40px";
function A9(e) {
  var n = e.className, t = e.isByMe;
  return T.createElement(
    "div",
    { className: vn([
      n,
      t ? "outgoing" : "incoming",
      "sendbird-template-loading-message-item-body"
    ]) },
    T.createElement(
      Vh,
      { className: "sendbird-message-status__icon", width: rN, height: rN },
      T.createElement(dt, { type: Le.SPINNER, fillColor: Pe.CONTENT_INVERSE_5, width: rN, height: rN })
    )
  );
}
var q9 = function(e) {
  var n = e.message, t = e.templateItems;
  return T.createElement(
    v9,
    { message: n },
    T.createElement(P9, { templateItems: t })
  );
}, $9 = [
  "version",
  "size",
  "top",
  "left",
  "right",
  "bottom",
  "maxTextLines",
  "value",
  "pixelWidth",
  "pixelHeight",
  "radius"
];
function YF(e, n) {
  if (Array.isArray(e))
    return e.map(function(l) {
      return YF(l);
    });
  if (typeof e == "object")
    return Object.keys(e).reduce(function(l, a) {
      return l[a] = YF(e[a], a), l;
    }, {});
  if (n != null && $9.includes(n)) {
    var t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
var IY = function(e, n, t) {
  t === void 0 && (t = "");
  for (var l = 0, a = Object.entries(e); l < a.length; l++) {
    var d = a[l], r = d[0], i = d[1], c = t ? "".concat(t, ".").concat(r) : r;
    i && typeof i == "object" ? IY(i, n, c) : n[c] = i;
  }
};
function eL(e) {
  var n = {};
  return IY(e, n), n;
}
function LY(e) {
  var n = e.template, t = e.source;
  if (!["object", "string"].includes(typeof n) || !n)
    return n;
  var l = /\{([^}]+)\}/g, a = eL(t);
  function d(V) {
    return typeof V == "string" ? V.replace(l, function(s, o) {
      var U = a[o];
      return U || "{".concat(o, "}");
    }) : LY({ template: V, source: t });
  }
  if (typeof n == "string")
    return d(n);
  if (Array.isArray(n))
    return n.map(d);
  var r = {};
  for (var i in n)
    if (Object.prototype.hasOwnProperty.call(n, i)) {
      var c = n[i];
      r[i] = d(c);
    }
  return r;
}
function V2(e) {
  return e.startsWith("#") ? e.length === 9 ? "#".concat(e.slice(3)).concat(e[1]).concat(e[2]) : e.length === 5 ? "#".concat(e.slice(2)).concat(e[1]) : e : e;
}
var CY = function(e) {
  var n = {}, t = {};
  for (var l in e)
    if (Object.prototype.hasOwnProperty.call(e, l)) {
      var a = e[l];
      if (typeof a == "object" && a !== null) {
        var d = CY(a), r = d[0], i = d[1];
        n[l] = r, t[l] = i;
      } else if (typeof a == "string") {
        var c = a.split(","), V = c[0], s = c[1];
        n[l] = V2(V), t[l] = V2(s || V);
      } else
        n[l] = a, t[l] = a;
    }
  return [n, t];
};
function tL(e) {
  var n = e.colorVariables, t = e.theme, l = CY(n), a = l[0], d = l[1];
  return t === "light" ? a : d;
}
var nL = 500, c2 = function(e, n, t, l) {
  var a = tL({
    colorVariables: t,
    theme: l
  }), d = LY({
    template: YF(e),
    source: ce(ce({}, n), a)
  });
  return d;
};
function lL(e) {
  var n, t = e.className, l = t === void 0 ? "" : t, a = e.message, d = e.isByMe, r = d === void 0 ? !1 : d, i = e.theme, c = i === void 0 ? "light" : i, V = (n = a.extendedMessagePayload) === null || n === void 0 ? void 0 : n.template;
  if (!(V != null && V.key))
    return T.createElement(gZ, { className: l, message: a, isByMe: r });
  var s = V.key, o = zn();
  if (!o)
    return T.createElement(gZ, { className: l, message: a, isByMe: r });
  var U = o.utils, N = U.getCachedTemplate, R = U.updateMessageTemplatesInfo, h = o.stores.appInfoStore.waitingTemplateKeysMap, Z = me(function() {
    var k, Q = N(V.key);
    return Q ? c2(JSON.parse(Q.uiTemplate), (k = V.variables) !== null && k !== void 0 ? k : {}, Q.colorVariables, c) : [];
  }), W = Z[0], F = Z[1], m = me(!1), E = m[0], u = m[1], b = Object.entries(h).map(function(k) {
    var Q = k[0], S = k[1];
    return [Q, S.requestedAt, S.isError].join("-");
  }).join(",");
  return _e(function() {
    var k;
    if (W.length === 0) {
      var Q = N(s);
      if (Q) {
        var S = c2(JSON.parse(Q.uiTemplate), (k = V.variables) !== null && k !== void 0 ? k : {}, Q.colorVariables, c);
        F(S);
      } else if (!E) {
        var v = h[s], G = Date.now();
        !v || G > v.requestedAt + nL ? R(V.key, Date.now()) : v && v.isError && u(!0);
      }
    }
  }, [V.key, b]), W.length === 0 ? E ? T.createElement(gZ, { className: l, message: a, isByMe: r }) : T.createElement(A9, { className: l, isByMe: r }) : T.createElement(
    "div",
    { className: vn([
      l,
      r ? "outgoing" : "incoming",
      "sendbird-template-message-item-body"
    ]) },
    T.createElement(q9, { message: a, templateItems: W })
  );
}
var s2 = T.forwardRef(function(e, n) {
  var t = e.children, l = e.isSelected, a = e.onClick, d = a === void 0 ? function() {
  } : a, r = e.disabled, i = r === void 0 ? !1 : r;
  return T.createElement(
    "button",
    { className: [
      "sendbird-iconbutton__feedback",
      l ? "sendbird-iconbutton__feedback__pressed" : "",
      i ? "sendbird-iconbutton__feedback__disabled" : ""
    ].join(" "), ref: n, type: "button", onClick: function(c) {
      d == null || d(c);
    }, disabled: i },
    T.createElement("span", { className: [
      "sendbird-iconbutton__feedback__inner",
      l ? "sendbird-iconbutton__feedback__inner__pressed" : "",
      i ? "sendbird-iconbutton__feedback__inner__disabled" : ""
    ].join(" ") }, t)
  );
});
function aL(e) {
  var n = e.hideMenu, t = e.onEditFeedback, l = e.onRemoveFeedback, a = ca().stringSet;
  return T.createElement(
    sh,
    { onBackdropClick: n },
    T.createElement(
      "div",
      { className: "sendbird-message__bottomsheet--feedback-options-menu" },
      T.createElement(
        "div",
        { className: "sendbird-message__bottomsheet--feedback-option", onClick: function() {
          n(), t();
        } },
        T.createElement(Fe, { type: oe.BODY_1, color: ie.ONBACKGROUND_1 }, a.EDIT_COMMENT)
      ),
      T.createElement(
        "div",
        { className: "sendbird-message__bottomsheet--feedback-option", onClick: function() {
          n(), l();
        } },
        T.createElement(Fe, { type: oe.BODY_1, color: ie.ERROR }, a.REMOVE_FEEDBACK)
      )
    )
  );
}
var dL = T.forwardRef(function(e, n) {
  var t = e.name, l = e.required, a = e.disabled, d = e.value, r = e.placeHolder, i = e.autoFocus, c = i === void 0 ? !1 : i, V = me(d), s = V[0], o = V[1];
  return T.createElement(
    "div",
    { className: "sendbird-input" },
    T.createElement("input", { className: "sendbird-input__input", ref: n, name: t, required: l, disabled: a, value: s, onChange: function(U) {
      o(U.target.value);
    }, autoFocus: c }),
    r && !s && T.createElement(Fe, { className: "sendbird-input__placeholder", type: oe.BODY_1, color: ie.ONBACKGROUND_3 }, r)
  );
});
function rL(e) {
  var n, t, l = e.selectedFeedback, a = e.message, d = e.onClose, r = e.onSubmit, i = e.onUpdate, c = e.onRemove, V = Gt(Kn).stringSet, s = dr().isMobile, o = (a == null ? void 0 : a.myFeedback) && l === a.myFeedback.rating, U = (n = a == null ? void 0 : a.myFeedback) === null || n === void 0 ? void 0 : n.comment, N = function() {
    var W;
    if (l) {
      var F = (W = h.current.value) !== null && W !== void 0 ? W : "";
      o ? F !== a.myFeedback.comment ? i == null || i(l, F) : d == null || d() : a.myFeedback || r == null || r(l, F);
    }
  }, R = Wt(null), h = Wt(null), Z = r1(R, {
    Enter: function() {
      return N();
    },
    Escape: function() {
      return d == null ? void 0 : d();
    }
  });
  return T.createElement(
    "div",
    { onKeyDown: Z },
    T.createElement(
      Ic,
      { contentClassName: "sendbird-message-feedback-modal-content__mobile", type: nl.PRIMARY, onCancel: d, onSubmit: function() {
        N();
      }, submitText: V.BUTTON__SUBMIT, renderHeader: function() {
        return T.createElement(
          "div",
          { className: "sendbird-modal__header" },
          T.createElement(Fe, { type: oe.H_1, color: ie.ONBACKGROUND_1, className: "sendbird-message-feedback-modal-header" }, V.FEEDBACK_MODAL_TITLE)
        );
      }, customFooter: T.createElement(
        "div",
        { className: "sendbird-message-feedback-modal-footer__root" },
        !s && (a != null && a.myFeedback) && l === a.myFeedback.rating ? T.createElement(Ql, { type: nl.WARNING, onClick: c, labelType: oe.BUTTON_3 }, V.BUTTON__REMOVE_FEEDBACK) : T.createElement("div", null),
        T.createElement(
          "div",
          { className: "sendbird-message-feedback-modal-footer__right-content" },
          T.createElement(
            Ql,
            { type: nl.SECONDARY, onClick: d },
            T.createElement(Fe, { type: oe.BUTTON_3, color: ie.ONBACKGROUND_1 }, V.BUTTON__CANCEL)
          ),
          T.createElement(
            Ql,
            { onClick: function() {
              return N();
            } },
            T.createElement(Fe, { type: oe.BUTTON_3, color: ie.ONCONTENT_1 }, U ? V.BUTTON__SAVE : V.BUTTON__SUBMIT)
          )
        )
      ) },
      T.createElement(
        "div",
        { className: "sendbird-message-feedback-modal-body__root" },
        T.createElement(dL, { name: "sendbird-message-feedback-modal-body__root", ref: h, value: o ? (t = a.myFeedback) === null || t === void 0 ? void 0 : t.comment : void 0, placeHolder: V.FEEDBACK_CONTENT_PLACEHOLDER, autoFocus: !0 })
      )
    )
  );
}
function iL(e) {
  var n = e.message, t = e.channel, l = e.userId, a = e.chainBottom, d = a === void 0 ? !1 : a, r = e.isByMe, i = e.displayThreadReplies, c = Wt(null), V = Gt(nh), s = V.disableUserProfile, o = V.renderUserProfile;
  return r || d || !th(n) ? null : T.createElement(OV, { menuTrigger: function(U) {
    var N, R;
    return T.createElement(da, {
      className: "sendbird-message-content__left__avatar ".concat(i ? "use-thread-replies" : ""),
      src: ((R = (N = t == null ? void 0 : t.members) === null || N === void 0 ? void 0 : N.find(function(h) {
        return (h == null ? void 0 : h.userId) === n.sender.userId;
      })) === null || R === void 0 ? void 0 : R.profileUrl) || n.sender.profileUrl || "",
      // TODO: Divide getting profileUrl logic to utils
      ref: c,
      width: "28px",
      height: "28px",
      onClick: function() {
        s || U();
      }
    });
  }, menuItems: function(U) {
    return o ? o({
      user: n.sender,
      close: U,
      currentUserId: l,
      avatarRef: c
    }) : T.createElement(
      VU,
      {
        /**
         * parentRef: For catching location(x, y) of MenuItems
         * parentContainRef: For toggling more options(menus & reactions)
        */
        parentRef: c,
        parentContainRef: c,
        closeDropdown: U,
        style: { paddingTop: "0px", paddingBottom: "0px" }
      },
      T.createElement(d1, { user: n.sender, onSuccess: U })
    );
  } });
}
var wr = "sendbird-message-content__middle__message-item-body";
function VL(e) {
  var n = e.message, t = e.channel, l = e.showFileViewer, a = e.onMessageHeightChange, d = e.mouseHover, r = e.isMobile, i = e.config, c = e.isReactionEnabledInChannel, V = e.isByMe, s = U9({
    isMobile: r
  }), o = N9(n), U = yj(), N = (t == null ? void 0 : t.isGroupChannel()) && i.groupChannel.enableOgtag;
  return Va(n).when(zN, function() {
    return T.createElement(lL, { className: wr, message: n, isByMe: V, theme: i == null ? void 0 : i.theme });
  }).when(function(R) {
    return N && th(R) && DW(R);
  }, function() {
    return T.createElement(CI, { className: wr, message: n, isByMe: V, mouseHover: d, isMentionEnabled: (i == null ? void 0 : i.isMentionEnabled) || !1, isReactionEnabled: c, onMessageHeightChange: a });
  }).when(Jj, function() {
    return T.createElement(KI, { className: wr, message: n, isByMe: V, mouseHover: d, isMentionEnabled: (i == null ? void 0 : i.isMentionEnabled) || !1, isReactionEnabled: c });
  }).when(function(R) {
    return XW(R) === U.FILE;
  }, function() {
    return T.createElement(_I, { className: wr, message: n, isByMe: V, mouseHover: d, isReactionEnabled: c });
  }).when(Fa, function() {
    return T.createElement(o9, { className: wr, message: n, isByMe: V, mouseHover: d, isReactionEnabled: c, threadMessageKindKey: s, statefulFileInfoList: o });
  }).when(Mi, function() {
    var R;
    return T.createElement(h9, { className: wr, message: n, channelUrl: (R = t == null ? void 0 : t.url) !== null && R !== void 0 ? R : "", isByMe: V, isReactionEnabled: c });
  }).when(Qi, function() {
    return T.createElement(Z9, { className: wr, message: n, isByMe: V, mouseHover: d, isReactionEnabled: c, showFileViewer: l, style: r ? { width: "100%" } : {} });
  }).otherwise(function(R) {
    return T.createElement(T9, { className: wr, message: R, isByMe: V, mouseHover: d, isReactionEnabled: c });
  });
}
function cL(e) {
  var n, t, l = e.channel, a = e.message;
  return T.createElement(
    Fe,
    { className: "sendbird-message-content__middle__sender-name", type: oe.CAPTION_2, color: ie.ONBACKGROUND_2 },
    /**
     * To use the latest member profile information, message.sender might be outdated
     */
    ((t = (n = l == null ? void 0 : l.members) === null || n === void 0 ? void 0 : n.find(function(d) {
      var r;
      return (d == null ? void 0 : d.userId) === ((r = a == null ? void 0 : a.sender) === null || r === void 0 ? void 0 : r.userId);
    })) === null || t === void 0 ? void 0 : t.nickname) || fj(a)
    // TODO: Divide getting profileUrl logic to utils
  );
}
var QF;
(function(e) {
  e.NOT_APPLICABLE = "NOT_APPLICABLE", e.NO_FEEDBACK = "NO_FEEDBACK", e.SUBMITTED = "SUBMITTED";
})(QF || (QF = {}));
function sL(e) {
  var n = e.text, t = e.onCancel, l = Gt(Kn).stringSet, a = Wt(null), d = r1(a, {
    Enter: function() {
      return t == null ? void 0 : t();
    },
    Escape: function() {
      return t == null ? void 0 : t();
    }
  });
  return T.createElement(
    "div",
    { onKeyDown: d },
    T.createElement(Ic, { contentClassName: "sendbird-message-feedback-modal-content__mobile", type: nl.PRIMARY, onSubmit: t, onClose: t, submitText: l.BUTTON__OK, renderHeader: function() {
      return T.createElement(
        "div",
        { className: "sendbird-modal__header" },
        T.createElement(Fe, { type: oe.H_1, color: ie.ONBACKGROUND_1, className: "sendbird-message-feedback-modal-header" }, n)
      );
    }, customFooter: T.createElement(
      "div",
      { className: "sendbird-message-feedback-modal-footer__root_failed" },
      T.createElement(
        Ql,
        { onClick: t },
        T.createElement(Fe, { type: oe.BUTTON_3, color: ie.ONCONTENT_1 }, l.BUTTON__OK)
      )
    ) })
  );
}
function oL(e) {
  var n = this, t, l, a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F = e.className, m = e.userId, E = e.channel, u = e.message, b = e.disabled, k = b === void 0 ? !1 : b, Q = e.chainTop, S = Q === void 0 ? !1 : Q, v = e.chainBottom, G = v === void 0 ? !1 : v, w = e.isReactionEnabled, y = w === void 0 ? !1 : w, g = e.disableQuoteMessage, f = g === void 0 ? !1 : g, I = e.replyType, K = e.threadReplySelectType, Ue = e.nicknamesMap, q = e.emojiContainer, ae = e.scrollToMessage, se = e.showEdit, le = e.showRemove, L = e.showFileViewer, $ = e.resendMessage, ee = e.deleteMessage, O = e.toggleReaction, re = e.setQuoteMessage, te = e.onReplyInThread, Qe = e.onQuoteMessageClick, Ye = e.onMessageHeightChange, Se = e.renderSenderProfile, P = Se === void 0 ? function(bt) {
    return T.createElement(iL, ce({}, bt));
  } : Se, ge = e.renderMessageBody, Me = ge === void 0 ? function(bt) {
    return T.createElement(VL, ce({}, bt));
  } : ge, We = e.renderMessageHeader, De = We === void 0 ? function(bt) {
    return T.createElement(cL, ce({}, bt));
  } : We, Oe = e.renderMessageMenu, tt = Oe === void 0 ? function(bt) {
    return T.createElement(TI, ce({}, bt));
  } : Oe, Be = e.renderEmojiMenu, He = Be === void 0 ? function(bt) {
    return T.createElement(mI, ce({}, bt));
  } : Be, at = e.renderEmojiReactions, Ge = at === void 0 ? function(bt) {
    return T.createElement(yI, ce({}, bt));
  } : at, $e = e.renderMobileMenuOnLongPress, fe = $e === void 0 ? function(bt) {
    return T.createElement(HI, ce({}, bt));
  } : $e, Xe = ca().dateLocale, pt = (zn == null ? void 0 : zn()) || {}, Vt = pt.config, yt = pt.eventHandlers, xe = (t = yt == null ? void 0 : yt.reaction) === null || t === void 0 ? void 0 : t.onPressUserProfile, At = Wt(null), kt = dr().isMobile, Kt = me(!1), ln = Kt[0], vt = Kt[1], Rt = me(!1), Ke = Rt[0], Je = Rt[1], de = me(!1), qe = de[0], lt = de[1], ct = me(!1), Ot = ct[0], zt = ct[1], cn = me(!1), mt = cn[0], sn = cn[1], hn = me(""), ft = hn[0], qt = hn[1], jt = Gt(Kn).stringSet, Bt = m === ((l = u == null ? void 0 : u.sender) === null || l === void 0 ? void 0 : l.userId) || (u == null ? void 0 : u.sendingStatus) === "pending" || (u == null ? void 0 : u.sendingStatus) === "failed", Ie = Bt ? "outgoing" : "incoming", it = S ? "chain-top" : "", ze = y && !(E != null && E.isEphemeral), ht = ze ? "use-reactions" : "", Ft = qe ? "sendbird-mouse-hover" : "", X = !!((I === "QUOTE_REPLY" || I === "THREAD") && (u != null && u.parentMessageId) && (u != null && u.parentMessage) && !f), Ne = X ? "use-quote" : "", pe = ((a = u == null ? void 0 : u.threadInfo) === null || a === void 0 ? void 0 : a.replyCount) > 0 && I === "THREAD", we = !Bt && (u == null ? void 0 : u.myFeedbackStatus) && u.myFeedbackStatus !== QF.NOT_APPLICABLE, Nt = ((d = Vt == null ? void 0 : Vt.groupChannel) === null || d === void 0 ? void 0 : d.enableFeedback) && we, Ee = Nt ? "sendbird-message-content__feedback" : "", H = !zN(u), Ve = H && kt, ye = H && Bt && !kt, Zt = H && pe, Mt = H && !Bt && !kt, Ct = function() {
    sn(!1);
  }, Ht = function() {
    kt ? zt(!0) : sn(!0);
  }, Sn = cU({
    onLongPress: function() {
      Ve && vt(!0);
    },
    onClick: dl
  }, {
    delay: 300,
    shouldPreventDefault: !1
  });
  return !((r = u == null ? void 0 : u.isAdminMessage) === null || r === void 0) && r.call(u) || (u == null ? void 0 : u.messageType) === "admin" ? T.createElement(BI, { message: u }) : T.createElement(
    "div",
    { className: vn([F, "sendbird-message-content", Ie, Ee]), onMouseOver: function() {
      return Je(!0);
    }, onMouseLeave: function() {
      return Je(!1);
    } },
    T.createElement(
      "div",
      { className: vn(["sendbird-message-content__left", ht, Ie, Ne]) },
      P(ce(ce({}, e), { isByMe: Bt, displayThreadReplies: pe })),
      ye && T.createElement(
        "div",
        { className: vn(["sendbird-message-content-menu", ht, Ft, Ie]) },
        tt({
          channel: E,
          message: u,
          isByMe: Bt,
          replyType: I,
          disabled: k,
          showEdit: se,
          showRemove: le,
          resendMessage: $,
          setQuoteMessage: re,
          setSupposedHover: lt,
          onReplyInThread: function(bt) {
            var rn, en = bt.message;
            K === Rd.THREAD ? te({ message: en }) : K === Rd.PARENT && ae((rn = en.parentMessage) === null || rn === void 0 ? void 0 : rn.createdAt, en.parentMessageId);
          },
          deleteMessage: ee
        }),
        ze && He({
          message: u,
          userId: m,
          emojiContainer: q,
          toggleReaction: O,
          setSupposedHover: lt
        })
      )
    ),
    T.createElement(
      "div",
      ce({ className: vn([
        "sendbird-message-content__middle",
        zN(u) ? "sendbird-message-content__middle__for_template_message" : ""
      ]) }, kt ? ce({}, Sn) : {}, { ref: At }),
      !Bt && !S && !X && De(e),
      X ? T.createElement(
        "div",
        { className: vn(["sendbird-message-content__middle__quote-message", Bt ? "outgoing" : "incoming", Ne]) },
        T.createElement(XI, { className: "sendbird-message-content__middle__quote-message__quote", message: u, userId: m, isByMe: Bt, isUnavailable: ((i = E == null ? void 0 : E.messageOffsetTimestamp) !== null && i !== void 0 ? i : 0) > ((V = (c = u.parentMessage) === null || c === void 0 ? void 0 : c.createdAt) !== null && V !== void 0 ? V : 0), onClick: function() {
          var bt;
          I === "THREAD" && K === Rd.THREAD && (Qe == null || Qe({ message: u })), (I === "QUOTE_REPLY" || I === "THREAD" && K === Rd.PARENT) && (!((bt = u == null ? void 0 : u.parentMessage) === null || bt === void 0) && bt.createdAt) && (u != null && u.parentMessageId) && ae(u.parentMessage.createdAt, u.parentMessageId);
        } })
      ) : null,
      T.createElement(
        "div",
        { className: vn([
          "sendbird-message-content__middle__body-container",
          zN(u) ? "sendbird-message-content__middle__for_template_message" : ""
        ]) },
        Bt && !G && T.createElement(
          "div",
          { className: vn(["sendbird-message-content__middle__body-container__created-at", "left", Ft]) },
          T.createElement(
            "div",
            { className: "sendbird-message-content__middle__body-container__created-at__component-container" },
            T.createElement(cI, { message: u, channel: E })
          )
        ),
        Me({
          message: u,
          channel: E,
          showFileViewer: L,
          onMessageHeightChange: Ye,
          mouseHover: Ke,
          isMobile: kt,
          config: Vt,
          isReactionEnabledInChannel: ze,
          isByMe: Bt
        }),
        ze && ((s = u == null ? void 0 : u.reactions) === null || s === void 0 ? void 0 : s.length) > 0 && T.createElement("div", { className: vn([
          "sendbird-message-content-reactions",
          Fa(u) ? "image-grid" : !Bt || Qi(u) || DW(u) ? "" : "primary",
          Ke ? "mouse-hover" : ""
        ]) }, Ge({
          userId: m,
          message: u,
          channel: E,
          isByMe: Bt,
          emojiContainer: q,
          memberNicknamesMap: Ue,
          toggleReaction: O,
          onPressUserProfile: xe
        })),
        Nt && T.createElement(
          "div",
          { className: vn([
            "sendbird-message-content__middle__body-container__feedback-buttons-container",
            pe ? "sendbird-message-content__middle__body-container__feedback-buttons-container_with-thread-replies" : ""
          ]) },
          T.createElement(
            s2,
            { isSelected: ((o = u == null ? void 0 : u.myFeedback) === null || o === void 0 ? void 0 : o.rating) === _r.GOOD, onClick: function() {
              return ol(n, void 0, void 0, function() {
                var bt, rn, en, gn;
                return Ul(this, function(An) {
                  switch (An.label) {
                    case 0:
                      if (!((rn = u == null ? void 0 : u.myFeedback) === null || rn === void 0) && rn.rating)
                        return [3, 5];
                      An.label = 1;
                    case 1:
                      return An.trys.push([1, 3, , 4]), [4, u.submitFeedback({
                        rating: _r.GOOD
                      })];
                    case 2:
                      return An.sent(), Ht(), [3, 4];
                    case 3:
                      return bt = An.sent(), (gn = (en = Vt == null ? void 0 : Vt.logger) === null || en === void 0 ? void 0 : en.error) === null || gn === void 0 || gn.call(en, "Channel: Submit feedback failed.", bt), qt(jt.FEEDBACK_FAILED_SUBMIT), [3, 4];
                    case 4:
                      return [3, 6];
                    case 5:
                      Ht(), An.label = 6;
                    case 6:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }, disabled: (u == null ? void 0 : u.myFeedback) && u.myFeedback.rating !== _r.GOOD },
            T.createElement(dt, { type: Le.FEEDBACK_LIKE, width: "24px", height: "24px" })
          ),
          T.createElement(
            s2,
            { isSelected: ((U = u == null ? void 0 : u.myFeedback) === null || U === void 0 ? void 0 : U.rating) === _r.BAD, onClick: function() {
              return ol(n, void 0, void 0, function() {
                var bt, rn, en, gn;
                return Ul(this, function(An) {
                  switch (An.label) {
                    case 0:
                      if (!((rn = u == null ? void 0 : u.myFeedback) === null || rn === void 0) && rn.rating)
                        return [3, 5];
                      An.label = 1;
                    case 1:
                      return An.trys.push([1, 3, , 4]), [4, u.submitFeedback({
                        rating: _r.BAD
                      })];
                    case 2:
                      return An.sent(), Ht(), [3, 4];
                    case 3:
                      return bt = An.sent(), (gn = (en = Vt == null ? void 0 : Vt.logger) === null || en === void 0 ? void 0 : en.error) === null || gn === void 0 || gn.call(en, "Channel: Submit feedback failed.", bt), qt(jt.FEEDBACK_FAILED_SUBMIT), [3, 4];
                    case 4:
                      return [3, 6];
                    case 5:
                      Ht(), An.label = 6;
                    case 6:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }, disabled: (u == null ? void 0 : u.myFeedback) && u.myFeedback.rating !== _r.BAD },
            T.createElement(dt, { type: Le.FEEDBACK_DISLIKE, width: "24px", height: "24px" })
          )
        ),
        !Bt && !G && T.createElement(Fe, { className: vn(["sendbird-message-content__middle__body-container__created-at", "right", Ft]), type: oe.CAPTION_3, color: ie.ONBACKGROUND_2 }, Sr((u == null ? void 0 : u.createdAt) || 0, "p", {
          locale: Xe
        }))
      ),
      Zt && T.createElement(fI, { className: "sendbird-message-content__middle__thread-replies", threadInfo: u == null ? void 0 : u.threadInfo, onClick: function() {
        return te == null ? void 0 : te({ message: u });
      } })
    ),
    T.createElement("div", { className: vn(["sendbird-message-content__right", it, ht, Ne]) }, Mt && T.createElement(
      "div",
      { className: vn(["sendbird-message-content-menu", it, Ft, Ie]) },
      ze && He({
        className: "sendbird-message-content-menu__reaction-menu",
        message: u,
        userId: m,
        emojiContainer: q,
        toggleReaction: O,
        setSupposedHover: lt
      }),
      tt({
        className: "sendbird-message-content-menu__normal-menu",
        channel: E,
        message: u,
        isByMe: Bt,
        replyType: I,
        disabled: k,
        showRemove: le,
        resendMessage: $,
        setQuoteMessage: re,
        setSupposedHover: lt,
        onReplyInThread: function(bt) {
          var rn, en = bt.message;
          K === Rd.THREAD ? te({ message: en }) : K === Rd.PARENT && ae((rn = en.parentMessage) === null || rn === void 0 ? void 0 : rn.createdAt, en.parentMessageId);
        },
        deleteMessage: ee
      })
    )),
    ln && (((N = u == null ? void 0 : u.isUserMessage) === null || N === void 0 ? void 0 : N.call(u)) || ((R = u == null ? void 0 : u.isFileMessage) === null || R === void 0 ? void 0 : R.call(u)) || ((h = u == null ? void 0 : u.isMultipleFilesMessage) === null || h === void 0 ? void 0 : h.call(u))) && fe({
      parentRef: At,
      channel: E,
      hideMenu: function() {
        vt(!1);
      },
      message: u,
      isReactionEnabled: ze,
      isByMe: Bt,
      userId: m,
      replyType: I,
      disabled: k,
      showRemove: le,
      emojiContainer: q,
      resendMessage: $,
      deleteMessage: ee,
      setQuoteMessage: re,
      toggleReaction: O,
      showEdit: se,
      onReplyInThread: function(bt) {
        var rn, en = bt.message;
        K === Rd.THREAD ? te == null || te({ message: en }) : K === Rd.PARENT && (ae == null || ae(((rn = en == null ? void 0 : en.parentMessage) === null || rn === void 0 ? void 0 : rn.createdAt) || 0, (en == null ? void 0 : en.parentMessageId) || 0));
      }
    }),
    ((Z = u == null ? void 0 : u.myFeedback) === null || Z === void 0 ? void 0 : Z.rating) && Ot && T.createElement(aL, { hideMenu: function() {
      zt(!1);
    }, onEditFeedback: function() {
      zt(!1), sn(!0);
    }, onRemoveFeedback: function() {
      return ol(n, void 0, void 0, function() {
        var bt, rn, en;
        return Ul(this, function(gn) {
          switch (gn.label) {
            case 0:
              return gn.trys.push([0, 2, , 3]), [4, u.deleteFeedback(u.myFeedback.id)];
            case 1:
              return gn.sent(), [3, 3];
            case 2:
              return bt = gn.sent(), (en = (rn = Vt == null ? void 0 : Vt.logger) === null || rn === void 0 ? void 0 : rn.error) === null || en === void 0 || en.call(rn, "Channel: Delete feedback failed.", bt), qt(jt.FEEDBACK_FAILED_DELETE), [3, 3];
            case 3:
              return zt(!1), [
                2
                /*return*/
              ];
          }
        });
      });
    } }),
    ((W = u == null ? void 0 : u.myFeedback) === null || W === void 0 ? void 0 : W.rating) && mt && T.createElement(rL, { selectedFeedback: u.myFeedback.rating, message: u, onUpdate: function(bt, rn) {
      return ol(n, void 0, void 0, function() {
        var en, gn, An, xi;
        return Ul(this, function(ir) {
          switch (ir.label) {
            case 0:
              en = new TV({
                id: u.myFeedback.id,
                rating: bt,
                comment: rn
              }), ir.label = 1;
            case 1:
              return ir.trys.push([1, 3, , 4]), [4, u.updateFeedback(en)];
            case 2:
              return ir.sent(), [3, 4];
            case 3:
              return gn = ir.sent(), (xi = (An = Vt == null ? void 0 : Vt.logger) === null || An === void 0 ? void 0 : An.error) === null || xi === void 0 || xi.call(An, "Channel: Update feedback failed.", gn), qt(jt.FEEDBACK_FAILED_SAVE), [3, 4];
            case 4:
              return Ct(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, onClose: Ct, onRemove: function() {
      return ol(n, void 0, void 0, function() {
        var bt, rn, en;
        return Ul(this, function(gn) {
          switch (gn.label) {
            case 0:
              return gn.trys.push([0, 2, , 3]), [4, u.deleteFeedback(u.myFeedback.id)];
            case 1:
              return gn.sent(), [3, 3];
            case 2:
              return bt = gn.sent(), (en = (rn = Vt == null ? void 0 : Vt.logger) === null || rn === void 0 ? void 0 : rn.error) === null || en === void 0 || en.call(rn, "Channel: Delete feedback failed.", bt), qt(jt.FEEDBACK_FAILED_DELETE), [3, 3];
            case 3:
              return Ct(), [
                2
                /*return*/
              ];
          }
        });
      });
    } }),
    ft && T.createElement(sL, { text: ft, onCancel: function() {
      qt("");
    } })
  );
}
var UL = function(e) {
  var n = e.replyOptions, t = e.onSendMessage, l = me(!1), a = l[0], d = l[1], r = function(i, c) {
    i.preventDefault(), t({ message: c }), d(!0);
  };
  return a ? null : T.createElement("div", { className: "sendbird-suggested-replies" }, n.map(function(i, c) {
    return T.createElement("div", { className: "sendbird-suggested-replies__option", id: i, key: c + i, onClick: function(V) {
      return r(V, i);
    } }, i);
  }));
};
function NL(e) {
  var n = e.member, t = e.isFocused, l = t === void 0 ? !1 : t, a = e.parentScrollRef, d = e.onClick, r = e.onMouseOver, i = e.onMouseMove, c = e.renderUserMentionItem, V = Wt(null), s = Gt(Kn).stringSet;
  _e(function() {
    l && (a == null ? void 0 : a.current) != null && (V == null ? void 0 : V.current) != null && (a.current.scrollTop >= V.current.offsetTop || a.current.scrollTop + a.current.clientHeight <= V.current.offsetTop) && V.current.scrollIntoView({ block: "nearest", inline: "nearest" });
  }, [l]);
  var o = nn(function() {
    if (c)
      return T.createElement("div", { className: "sendbird-mention-suggest-list__user-item", onClick: function(U) {
        return d == null ? void 0 : d({ event: U, member: n, itemRef: V });
      }, onMouseOver: function(U) {
        return r == null ? void 0 : r({ event: U, member: n, itemRef: V });
      }, onMouseMove: function(U) {
        return i == null ? void 0 : i({ event: U, member: n, itemRef: V });
      }, key: (n == null ? void 0 : n.userId) || zr(), ref: V }, c({ user: n }));
  }, [c]);
  return o || T.createElement(
    "div",
    { className: "sendbird-mention-suggest-list__user-item ".concat(l ? "focused" : ""), onClick: function(U) {
      return d == null ? void 0 : d({ event: U, member: n, itemRef: V });
    }, onMouseOver: function(U) {
      return r == null ? void 0 : r({ event: U, member: n, itemRef: V });
    }, onMouseMove: function(U) {
      return i == null ? void 0 : i({ event: U, member: n, itemRef: V });
    }, key: (n == null ? void 0 : n.userId) || zr(), ref: V },
    T.createElement(da, { className: "sendbird-mention-suggest-list__user-item__avatar", src: n == null ? void 0 : n.profileUrl, alt: "user-profile", width: "24px", height: "24px" }),
    T.createElement(Fe, { className: "sendbird-mention-suggest-list__user-item__nickname", type: oe.SUBTITLE_2, color: n != null && n.nickname ? ie.ONBACKGROUND_1 : ie.ONBACKGROUND_3 }, (n == null ? void 0 : n.nickname) || (s == null ? void 0 : s.MENTION_NAME__NO_NAME)),
    T.createElement(Fe, { className: "sendbird-mention-suggest-list__user-item__user-id", type: oe.SUBTITLE_2, color: ie.ONBACKGROUND_2 }, n == null ? void 0 : n.userId)
  );
}
function RL(e, n, t, l) {
  return ol(this, void 0, void 0, function() {
    return Ul(this, function(a) {
      return [2, n.members.sort(function(d, r) {
        var i;
        return (i = d.nickname) === null || i === void 0 ? void 0 : i.localeCompare(r.nickname);
      }).filter(function(d) {
        var r;
        return ((r = d.nickname) === null || r === void 0 ? void 0 : r.toLowerCase().startsWith(l.toLowerCase())) && d.userId !== e && d.isActive;
      }).slice(0, t)];
    });
  });
}
function hL(e, n, t, l) {
  return ol(this, void 0, void 0, function() {
    var a;
    return Ul(this, function(d) {
      return a = n.createMemberListQuery({
        limit: t + 1,
        nicknameStartsWithFilter: l
      }), [2, a.next().then(function(r) {
        return r.filter(function(i) {
          return e !== (i == null ? void 0 : i.userId);
        }).slice(0, t);
      })];
    });
  });
}
var ZL = 300, KY = function(e) {
  var n, t, l, a = e.className, d = e.currentChannel, r = e.targetNickname, i = r === void 0 ? "" : r, c = e.onUserItemClick, V = e.onFocusItemChange, s = e.onFetchUsers, o = e.renderUserMentionItem, U = e.inputEvent, N = e.ableAddMention, R = N === void 0 ? !0 : N, h = e.maxMentionCount, Z = h === void 0 ? $b : h, W = e.maxSuggestionCount, F = W === void 0 ? eY : W, m = zn(), E = m.config, u = m.stores, b = E.logger, k = ((l = (t = (n = u == null ? void 0 : u.sdkStore) === null || n === void 0 ? void 0 : n.sdk) === null || t === void 0 ? void 0 : t.currentUser) === null || l === void 0 ? void 0 : l.userId) || "", Q = Wt(null), S = ca().stringSet, v = me(null), G = v[0], w = v[1], y = me(""), g = y[0], f = y[1], I = me(""), K = I[0], Ue = I[1], q = me(null), ae = q[0], se = q[1], le = me([]), L = le[0], $ = le[1];
  return _e(function() {
    clearTimeout(G), w(setTimeout(function() {
      f(i);
    }, ZL));
  }, [i]), _e(function() {
    if ((U == null ? void 0 : U.key) === Wd.Enter && L.length > 0 && c(ae), (U == null ? void 0 : U.key) === Wd.ArrowUp) {
      var ee = L.findIndex(function(O) {
        return (O == null ? void 0 : O.userId) === (ae == null ? void 0 : ae.userId);
      });
      0 < ee && (se(L[ee - 1]), V(L[ee - 1]));
    }
    if ((U == null ? void 0 : U.key) === Wd.ArrowDown) {
      var ee = L.findIndex(function(re) {
        return (re == null ? void 0 : re.userId) === (ae == null ? void 0 : ae.userId);
      });
      ee < L.length - 1 && (se(L[ee + 1]), V(L[ee + 1]));
    }
  }, [U]), _e(function() {
    if (!(K && g.indexOf(K) === 0 && L.length === 0)) {
      if (d != null && d.isSuper && !(d != null && d.createMemberListQuery)) {
        b.warning("SuggestedMentionList: Creating member list query failed");
        return;
      }
      var ee = d != null && d.isSuper ? hL : RL;
      ee(k, d, F, g.slice(no.length)).then(function(O) {
        O.length < 1 ? b.info("SuggestedMentionList: Fetched member list is empty") : (b.info("SuggestedMentionList: Fetching member list succeeded", { memberList: O }), se(O[0])), Ue(g), s(O), $(O);
      }).catch(function(O) {
        O && b.error("SuggestedMentionList: Fetching member list failed", O);
      });
    }
  }, [
    d == null ? void 0 : d.url,
    // We have to be specific like this or React would not recognize the changes in instances.
    d == null ? void 0 : d.members.map(function(ee) {
      return ee.nickname;
    }).join(),
    d == null ? void 0 : d.members.map(function(ee) {
      return ee.isActive;
    }).join(),
    g,
    F,
    k,
    L.length,
    K
  ]), !R && L.length === 0 ? null : T.createElement(
    "div",
    { className: "sendbird-mention-suggest-list ".concat(a), key: "sendbird-mention-suggest-list", ref: Q },
    R && (L == null ? void 0 : L.map(function(ee) {
      return T.createElement(NL, { key: (ee == null ? void 0 : ee.userId) || zr(), member: ee, isFocused: (ee == null ? void 0 : ee.userId) === (ae == null ? void 0 : ae.userId), parentScrollRef: Q, onClick: function(O) {
        var re = O.member;
        c(re);
      }, onMouseOver: function(O) {
        var re = O.member;
        se(re);
      }, renderUserMentionItem: o });
    })),
    !R && T.createElement(
      "div",
      { className: "sendbird-mention-suggest-list__notice-item" },
      T.createElement(dt, { className: "sendbird-mention-suggest-list__notice-item__icon", type: Le.INFO, fillColor: Pe.ON_BACKGROUND_2, width: "20px", height: "20px" }),
      T.createElement(Fe, { className: "sendbird-mention-suggest-list__notice-item__text", type: oe.SUBTITLE_2, color: ie.ONBACKGROUND_2 }, S.MENTION_COUNT__OVER_LIMIT.replace("%d", String(Z)))
    )
  );
}, o2 = function(e, n) {
  var t = me(!1), l = t[0], a = t[1];
  _e(function() {
    l ? e() : a(!0);
  }, n);
}, TL = function(e) {
  var n, t, l = e.message, a = e.renderMessage, d = e.children, r = e.renderMessageContent, i = r === void 0 ? function(ze) {
    return T.createElement(oL, ce({}, ze));
  } : r, c = e.renderSuggestedReplies, V = c === void 0 ? function(ze) {
    return T.createElement(UL, ce({}, ze));
  } : c, s = e.renderCustomSeparator, o = e.renderEditInput, U = e.hasSeparator, N = e.chainTop, R = e.chainBottom, h = e.handleScroll, Z = e.channel, W = e.emojiContainer, F = e.editInputDisabled, m = e.shouldRenderSuggestedReplies, E = e.isReactionEnabled, u = e.replyType, b = e.threadReplySelectType, k = e.nicknamesMap, Q = e.renderUserMentionItem, S = e.scrollToMessage, v = e.toggleReaction, G = e.setQuoteMessage, w = e.onQuoteMessageClick, y = e.onReplyInThreadClick, g = e.sendUserMessage, f = e.updateUserMessage, I = e.resendMessage, K = e.deleteMessage, Ue = e.renderFileViewer, q = e.renderRemoveMessageModal, ae = e.setAnimatedMessageId, se = e.animatedMessageId, le = e.onMessageAnimated, L = e.usedInLegacy, $ = L === void 0 ? !0 : L, ee = ca(), O = ee.dateLocale, re = ee.stringSet, te = zn(), Qe = te.config, Ye = Qe.userId, Se = Qe.isOnline, P = Qe.isMentionEnabled, ge = Qe.userMention, Me = Qe.logger, We = (ge == null ? void 0 : ge.maxMentionCount) || $b, De = (ge == null ? void 0 : ge.maxSuggestionCount) || eY, Oe = me(!1), tt = Oe[0], Be = Oe[1], He = me(!1), at = He[0], Ge = He[1], $e = me(!1), fe = $e[0], Xe = $e[1], pt = me(!1), Vt = pt[0], yt = pt[1], xe = me(""), At = xe[0], kt = xe[1], Kt = me([]), ln = Kt[0], vt = Kt[1], Rt = me([]), Ke = Rt[0], Je = Rt[1], de = me(null), qe = de[0], lt = de[1], ct = me(null), Ot = ct[0], zt = ct[1], cn = me([]), mt = cn[0], sn = cn[1], hn = Wt(null), ft = Wt(null), qt = Se && P && At.length > 0 && !pR(Z) && !Yo(Z), jt = NY({ ref: hn }, { logger: Me }), Bt = (jt == null ? void 0 : jt.length) < We;
  _e(function() {
    vt(ln.filter(function(ze) {
      var ht = ze.userId, Ft = Ke.indexOf(ht);
      return Ft < 0 ? !1 : (Ke.splice(Ft, 1), !0);
    }));
  }, [Ke]), o2(function() {
    h == null || h();
  }, [tt, (n = l == null ? void 0 : l.reactions) === null || n === void 0 ? void 0 : n.length]), o2(function() {
    h == null || h(!0);
  }, [l == null ? void 0 : l.updatedAt, l == null ? void 0 : l.message]), ud(function() {
    $ && (h == null || h(!0));
  }, []), ud(function() {
    var ze = [];
    return se === l.messageId && (ft != null && ft.current) ? (ze.push(setTimeout(function() {
      yt(!0);
    }, 500)), ze.push(setTimeout(function() {
      ae(null), le == null || le();
    }, 1600))) : yt(!1), function() {
      ze.forEach(function(ht) {
        return clearTimeout(ht);
      });
    };
  }, [se, ft.current, l.messageId]);
  var Ie = nn(function() {
    var ze;
    return (ze = s == null ? void 0 : s({ message: l })) !== null && ze !== void 0 ? ze : null;
  }, [l, s]), it = function() {
    if (d)
      return d;
    if (a) {
      var ze = ce(ce({}, e), { renderMessage: void 0 });
      return a(ze);
    }
    return T.createElement(
      T.Fragment,
      null,
      i({
        className: "sendbird-message-hoc__message-content",
        userId: Ye,
        scrollToMessage: S,
        channel: Z,
        message: l,
        disabled: !Se,
        chainTop: N,
        chainBottom: R,
        isReactionEnabled: E,
        replyType: u,
        threadReplySelectType: b,
        nicknamesMap: k,
        emojiContainer: W,
        showEdit: Be,
        showRemove: Ge,
        showFileViewer: Xe,
        resendMessage: I,
        deleteMessage: K,
        toggleReaction: v,
        setQuoteMessage: G,
        onReplyInThread: y,
        onQuoteMessageClick: w,
        onMessageHeightChange: h
      }),
      m && V({
        replyOptions: OW(l),
        onSendMessage: g,
        message: l
      }),
      at && q({ message: l, onCancel: function() {
        return Ge(!1);
      } }),
      fe && Ue({ message: l, onCancel: function() {
        return Xe(!1);
      } })
    );
  };
  return tt && (!((t = l == null ? void 0 : l.isUserMessage) === null || t === void 0) && t.call(l)) ? (o == null ? void 0 : o()) || T.createElement(
    T.Fragment,
    null,
    qt && T.createElement(KY, { currentChannel: Z, targetNickname: At, inputEvent: qe, renderUserMentionItem: Q, onUserItemClick: function(ze) {
      ze && vt(Ut(Ut([], ln, !0), [ze], !1)), kt(""), zt(ze), lt(null);
    }, onFocusItemChange: function() {
      lt(null);
    }, onFetchUsers: function(ze) {
      sn(ze);
    }, ableAddMention: Bt, maxMentionCount: We, maxSuggestionCount: De }),
    T.createElement(EY, { isEdit: !0, channel: Z, disabled: F, ref: hn, mentionSelectedUser: Ot, isMentionEnabled: P, message: l, onStartTyping: function() {
      var ze;
      (ze = Z == null ? void 0 : Z.startTyping) === null || ze === void 0 || ze.call(Z);
    }, onUpdateMessage: function(ze) {
      var ht, Ft = ze.messageId, X = ze.message, Ne = ze.mentionTemplate;
      f(Ft, {
        message: X,
        mentionedUsers: ln,
        mentionedMessageTemplate: Ne
      }), Be(!1), (ht = Z == null ? void 0 : Z.endTyping) === null || ht === void 0 || ht.call(Z);
    }, onCancelEdit: function() {
      var ze;
      kt(""), vt([]), Je([]), sn([]), Be(!1), (ze = Z == null ? void 0 : Z.endTyping) === null || ze === void 0 || ze.call(Z);
    }, onUserMentioned: function(ze) {
      (Ot == null ? void 0 : Ot.userId) === (ze == null ? void 0 : ze.userId) && (zt(null), kt(""));
    }, onMentionStringChange: function(ze) {
      kt(ze);
    }, onMentionedUserIdsUpdated: function(ze) {
      Je(ze);
    }, onKeyDown: function(ze) {
      return qt && (mt == null ? void 0 : mt.length) > 0 && (ze.key === Wd.Enter && Bt || ze.key === Wd.ArrowUp || ze.key === Wd.ArrowDown) ? (lt(ze), !0) : !1;
    } })
  ) : T.createElement(
    "div",
    { className: vn([
      "sendbird-msg-hoc sendbird-msg--scroll-ref",
      Vt ? "sendbird-msg-hoc__animated" : ""
    ]), style: d || a ? void 0 : { marginBottom: "2px" }, "data-sb-message-id": l.messageId, "data-sb-created-at": l.createdAt, ref: ft },
    U && (Ie || T.createElement(
      h4,
      null,
      T.createElement(Fe, { type: oe.CAPTION_2, color: ie.ONBACKGROUND_2 }, Sr(l.createdAt, re.DATE_FORMAT__MESSAGE_LIST__DATE_SEPARATOR, {
        locale: O
      }))
    )),
    it()
  );
}, FL = function(e) {
  var n = e.message, t = e.onCancel, l = e.deleteMessage, a = n.sender, d = n.type, r = n.url, i = n.name, c = i === void 0 ? "" : i, V = n.threadInfo, s = a.profileUrl, o = a.nickname, U = a.userId, N = zn().config;
  return Yi(T.createElement(WL, { profileUrl: s, nickname: o, type: d, url: r, name: c, onCancel: t, onDelete: function() {
    return l(n).then(function() {
      return t();
    });
  }, isByMe: N.userId === U, disableDelete: (V == null ? void 0 : V.replyCount) > 0 }), document.getElementById(ko));
}, WL = function(e) {
  var n = e.profileUrl, t = e.nickname, l = e.name, a = e.type, d = e.url, r = e.isByMe, i = e.onCancel, c = e.onDelete, V = e.disableDelete;
  return T.createElement(
    "div",
    { className: "sendbird-fileviewer" },
    T.createElement(
      "div",
      { className: "sendbird-fileviewer__header" },
      T.createElement(
        "div",
        { className: "sendbird-fileviewer__header__left" },
        T.createElement(
          "div",
          { className: "sendbird-fileviewer__header__left__avatar" },
          T.createElement(da, { height: "32px", width: "32px", src: n })
        ),
        T.createElement(Fe, { className: "sendbird-fileviewer__header__left__filename", type: oe.H_2, color: ie.ONBACKGROUND_1 }, l),
        T.createElement(Fe, { className: "sendbird-fileviewer__header__left__sender-name", type: oe.BODY_1, color: ie.ONBACKGROUND_2 }, t)
      ),
      T.createElement(
        "div",
        { className: "sendbird-fileviewer__header__right" },
        Eo(a) && T.createElement(
          "div",
          { className: "sendbird-fileviewer__header__right__actions" },
          T.createElement(
            "a",
            { className: "sendbird-fileviewer__header__right__actions__download", rel: "noopener noreferrer", href: d, target: "_blank" },
            T.createElement(dt, { type: Le.DOWNLOAD, fillColor: Pe.ON_BACKGROUND_1, height: "24px", width: "24px" })
          ),
          c && r && T.createElement(
            "div",
            { className: "sendbird-fileviewer__header__right__actions__delete" },
            T.createElement(dt, { className: V ? "disabled" : "", type: Le.DELETE, fillColor: V ? Pe.GRAY : Pe.ON_BACKGROUND_1, height: "24px", width: "24px", onClick: function() {
              V || c();
            } })
          )
        ),
        T.createElement(
          "div",
          { className: "sendbird-fileviewer__header__right__actions__close" },
          T.createElement(dt, { type: Le.CLOSE, fillColor: Pe.ON_BACKGROUND_1, height: "24px", width: "24px", onClick: i })
        )
      )
    ),
    T.createElement(
      "div",
      { className: "sendbird-fileviewer__content" },
      YV(a) && T.createElement(
        "video",
        { controls: !0, className: "sendbird-fileviewer__content__video" },
        T.createElement("source", { src: d, type: a })
      ),
      XV(a) && T.createElement("img", { src: d, alt: l, className: "sendbird-fileviewer__content__img" }),
      !Eo(a) && T.createElement(
        "div",
        { className: "sendbird-fileviewer__content__unsupported" },
        T.createElement(Fe, { type: oe.H_1, color: ie.ONBACKGROUND_1 }, "Unsupoprted message")
      )
    )
  );
}, mL = function(e) {
  var n = fl().deleteMessage;
  return T.createElement(FL, ce({}, e, { deleteMessage: n }));
};
function uL(e, n) {
  return Va(n).when(Fa, function() {
    var t = n.fileInfoList.length;
    return "Do you want to delete all ".concat(t, " photos?");
  }).otherwise(function() {
    return e.MODAL__DELETE_MESSAGE__TITLE;
  });
}
var pL = function(e) {
  var n, t = e.onSubmit, l = t === void 0 ? function() {
  } : t, a = e.onCancel, d = e.message, r = e.deleteMessage, i = Gt(Kn).stringSet;
  return T.createElement(Ic, { type: nl.DANGER, disabled: ((n = d == null ? void 0 : d.threadInfo) === null || n === void 0 ? void 0 : n.replyCount) > 0, onCancel: a, onSubmit: function() {
    (d.isUserMessage() || d.isFileMessage() || d.isMultipleFilesMessage()) && r(d).then(function() {
      l(), a();
    });
  }, submitText: i.MESSAGE_MENU__DELETE, titleText: uL(i, d) });
}, ML = function(e) {
  var n = fl().deleteMessage;
  return T.createElement(pL, ce({}, e, { deleteMessage: n }));
}, U2 = function(e) {
  var n, t, l, a = zn().config, d = fl(), r = d.initialized, i = d.currentGroupChannel, c = d.animatedMessageId, V = d.setAnimatedMessageId, s = d.updateMessage, o = d.scrollToMessage, U = d.replyType, N = d.threadReplySelectType, R = d.isReactionEnabled, h = d.toggleReaction, Z = d.emojiContainer, W = d.nicknamesMap, F = d.setQuoteMessage, m = d.resendMessage, E = d.deleteMessage, u = d.renderUserMentionItem, b = d.onReplyInThread, k = d.onQuoteMessageClick, Q = d.onMessageAnimated, S = d.sendMessage, v = d.localMessages, G = e.message;
  return T.createElement(TL, ce({}, e, { channel: i, emojiContainer: Z, editInputDisabled: !r || Lw(i) || Cw(i) || !a.isOnline, shouldRenderSuggestedReplies: ((n = a == null ? void 0 : a.groupChannel) === null || n === void 0 ? void 0 : n.enableSuggestedReplies) && (((t = a == null ? void 0 : a.groupChannel) === null || t === void 0 ? void 0 : t.showSuggestedRepliesFor) === "all_messages" ? !0 : G.messageId === ((l = i == null ? void 0 : i.lastMessage) === null || l === void 0 ? void 0 : l.messageId)) && (v == null ? void 0 : v.length) === 0 && OW(G).length > 0, isReactionEnabled: R, replyType: U, threadReplySelectType: N, nicknamesMap: W, renderUserMentionItem: u, scrollToMessage: o, toggleReaction: h, setQuoteMessage: F, onQuoteMessageClick: k, onReplyInThreadClick: b, sendUserMessage: function(w) {
    S({
      message: w.message,
      mentionedUsers: w.mentionedUsers,
      mentionTemplate: w.mentionedMessageTemplate
    });
  }, updateUserMessage: function(w, y) {
    s({
      messageId: w,
      message: y.message,
      mentionedUsers: y.mentionedUsers,
      mentionTemplate: y.mentionedMessageTemplate
    });
  }, resendMessage: m, deleteMessage: E, animatedMessageId: c, setAnimatedMessageId: V, onMessageAnimated: Q, renderFileViewer: function(w) {
    return T.createElement(mL, ce({}, w));
  }, renderRemoveMessageModal: function(w) {
    return T.createElement(ML, ce({}, w));
  } }));
}, EL = function(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = e.count, a = l === void 0 ? 0 : l, d = e.time, r = d === void 0 ? "" : d, i = e.onClick, c = e.lastReadAt, V = Gt(Kn), s = V.stringSet, o = V.dateLocale, U = nn(function() {
    var N, R;
    if (s.CHANNEL__MESSAGE_LIST__NOTIFICATION__ON !== "on") {
      var h = ((R = (N = r == null ? void 0 : r.toString) === null || N === void 0 ? void 0 : N.call(r)) === null || R === void 0 ? void 0 : R.split(" ")) || [];
      return h == null || h.splice(-2, 0, s.CHANNEL__MESSAGE_LIST__NOTIFICATION__ON), h.join(" ");
    } else if (c)
      return Sr(c, s.DATE_FORMAT__MESSAGE_LIST__NOTIFICATION__UNREAD_SINCE, { locale: o });
  }, [r, c]);
  return T.createElement(
    "div",
    { className: "sendbird-notification".concat(a < 1 ? "--hide" : "", " ").concat(t), onClick: i },
    T.createElement(
      Fe,
      { className: "sendbird-notification__text", color: ie.ONCONTENT_1, type: oe.CAPTION_2 },
      "".concat(a, " "),
      s.CHANNEL__MESSAGE_LIST__NOTIFICATION__NEW_MESSAGE,
      " ".concat(U)
    ),
    T.createElement(dt, { width: "24px", height: "24px", type: Le.CHEVRON_DOWN, fillColor: Pe.CONTENT })
  );
}, SL = function(e) {
  var n = e.className, t = n === void 0 ? "" : n, l = Gt(Kn).stringSet;
  return T.createElement(
    "div",
    { className: "sendbird-notification sendbird-notification--frozen ".concat(t) },
    T.createElement(Fe, { className: "sendbird-notification__text", type: oe.CAPTION_2 }, l.CHANNEL_FROZEN)
  );
};
function i1(e, n, t) {
  t === void 0 && (t = {
    leading: !0,
    trailing: !1
  });
  var l = Wt(null), a = Wt(null);
  return _e(function() {
    return function() {
      l.current && clearTimeout(l.current);
    };
  }, []), lU(function() {
    for (var d = [], r = 0; r < arguments.length; r++)
      d[r] = arguments[r];
    if (l.current) {
      a.current = d;
      return;
    }
    t.leading ? e.apply(void 0, d) : a.current = d;
    var i = function() {
      t.trailing && a.current ? (e.apply(void 0, a.current), a.current = null, l.current = setTimeout(i, n)) : l.current = null;
    };
    l.current = setTimeout(i, n);
  });
}
var kL = 100;
function bL(e, n) {
  return e - n;
}
function YL(e) {
  var n = e.hasMore, t = e.hasNext, l = e.onScroll, a = e.scrollRef, d = e.setShowScrollDownButton, r = lU(function() {
    var i = a == null ? void 0 : a.current;
    if (i != null) {
      var c = i.scrollTop, V = i.scrollHeight, s = i.clientHeight, o = bL(V, c);
      typeof d == "function" && d(V > c + s + 1), n && pV(c, 0, Vi) && l(function() {
        var U = i.scrollHeight > V;
        U && (i.scrollTop = i.scrollHeight - o);
      }), t && pV(s + c, V, Vi) && l(function() {
        var U = i.scrollHeight > V;
        U && (i.scrollTop = c);
      });
    }
  });
  return i1(r, kL, { trailing: !0 });
}
var QL = function() {
  return T.createElement(
    "div",
    { className: "typing-dots-container" },
    T.createElement("span", null),
    T.createElement("span", null),
    T.createElement("span", null)
  );
}, _Y = 2, vo = 28, N2 = vo + _Y * 2, JF = 24, iN = 3, JL = _Y, vL = function(e) {
  var n = e.sources, t = e.max;
  return T.createElement(
    T.Fragment,
    null,
    " ",
    n.slice(0, t).map(function(l, a) {
      return T.createElement(da, {
        className: "sendbird-message-content__left__avatar multiple",
        src: l || "",
        key: "avatar_stack_item_".concat(l),
        // TODO: Divide getting profileUrl logic to utils
        width: "".concat(vo, "px"),
        height: "".concat(vo, "px"),
        zIndex: a,
        left: "".concat(a * JF - JL, "px")
      });
    }),
    " "
  );
}, zL = function(e) {
  var n = e.typingMembers, t = n.length, l = Math.min(t, 4), a = t - iN, d = (l - 1) * (N2 - JF), r = 12;
  return T.createElement(
    "div",
    { className: "sendbird-message-content__left incoming", style: {
      minWidth: l * N2 - d + r
    } },
    T.createElement(vL, { sources: n.map(function(i) {
      return i.profileUrl;
    }), max: iN }),
    a > 0 ? T.createElement(da, {
      className: "sendbird-message-content__left__avatar multiple",
      // TODO: Divide getting profileUrl logic to utils
      width: "".concat(vo, "px"),
      height: "".concat(vo, "px"),
      zIndex: iN,
      left: "".concat(iN * JF, "px"),
      customDefaultComponent: function(i) {
        var c = i.width, V = i.height;
        return T.createElement(sY, { width: c, height: V, text: "+".concat(a) });
      }
    }) : null
  );
}, xL = function(e) {
  var n = e.typingMembers, t = e.handleScroll;
  return n.length === 0 ? null : (ud(function() {
    t == null || t(!0);
  }, []), T.createElement(
    "div",
    { className: "sendbird-message-content incoming", style: { marginBottom: "2px" } },
    T.createElement(zL, { typingMembers: n }),
    T.createElement(
      "div",
      { className: "sendbird-message-content__middle" },
      T.createElement(QL, null)
    )
  ));
}, GL = 100;
function yL(e) {
  var n = e.onReachedTop, t = e.onReachedBottom, l = e.onInBetween, a = lU(function(d) {
    if (d != null && d.target) {
      var r = d.target, i = r.scrollTop, c = r.scrollHeight, V = r.clientHeight, s = {
        distanceFromBottom: c - i - V
      };
      n && pV(i, 0, Vi) ? n(s) : t && pV(c, V + i, Vi) ? t(s) : l && l(s);
    }
  });
  return i1(a, GL, { trailing: !0 });
}
var BL = function(e, n, t, l, a) {
  if (!l || l.channelType !== "group")
    return [
      VN(e, n),
      VN(n, t)
    ];
  if (a === "THREAD" && (n != null && n.threadInfo))
    return [!1, !1];
  var d = (n == null ? void 0 : n.sendingStatus) || "", r = d !== "pending" && d !== "failed";
  return [
    VN(e, n, l) && r,
    VN(n, t, l) && r
  ];
}, R2 = function(e) {
  return Sr(e.createdAt, "p");
}, VN = function(e, n, t) {
  var l, a;
  return e && n && e.messageType && e.messageType !== "admin" && n.messageType && (n == null ? void 0 : n.messageType) !== "admin" && "sender" in e && "sender" in n && e.createdAt && n.createdAt && e.sender.userId && n.sender.userId ? (e == null ? void 0 : e.sendingStatus) === (n == null ? void 0 : n.sendingStatus) && ((l = e == null ? void 0 : e.sender) === null || l === void 0 ? void 0 : l.userId) === ((a = n == null ? void 0 : n.sender) === null || a === void 0 ? void 0 : a.userId) && R2(e) === R2(n) && (t ? dp(t, e) === dp(t, n) : !0) : !1;
}, h2 = function(e) {
  var n = e.allMessages, t = n === void 0 ? [] : n, l = e.isMessageGroupingEnabled, a = l === void 0 ? !0 : l, d = e.currentIndex, r = d === void 0 ? 0 : d, i = e.currentMessage, c = i === void 0 ? null : i, V = e.currentChannel, s = V === void 0 ? null : V, o = e.replyType, U = o === void 0 ? "" : o, N = t[r - 1], R = t[r + 1], h = a ? BL(N, c, R, s, U) : [!1, !1], Z = h[0], W = h[1], F = N == null ? void 0 : N.createdAt, m = c.createdAt, E = "sendingStatus" in c && c.sendingStatus !== "succeeded", u = E ? !1 : !(F && l1(m, F));
  return {
    chainTop: Z,
    chainBottom: W,
    hasSeparator: u
  };
}, DL = 100;
function XL(e) {
  var n = e.loading, t = me(0), l = t[0], a = t[1];
  _e(function() {
    n && a(0);
  }, [n]);
  var d = function(r) {
    var i = r.target;
    try {
      a(i.scrollHeight - i.scrollTop - i.offsetHeight);
    } catch {
    }
  };
  return {
    scrollBottom: l,
    scrollToBottomHandler: i1(d, DL, { trailing: !0 })
  };
}
function OL() {
  var e = fl(), n = e.scrollRef, t = e.scrollBehavior, l = t === void 0 ? "auto" : t;
  return _e(function() {
    n.current && (n.current.style.scrollBehavior = l);
  }, [n.current]), null;
}
var jL = 50, HL = function(e) {
  var n, t, l, a, d, r = e.className, i = r === void 0 ? "" : r, c = e.renderMessage, V = e.renderMessageContent, s = e.renderSuggestedReplies, o = e.renderCustomSeparator, U = e.renderPlaceholderLoader, N = U === void 0 ? function() {
    return T.createElement(rV, { type: _n.LOADING });
  } : U, R = e.renderPlaceholderEmpty, h = R === void 0 ? function() {
    return T.createElement(rV, { className: "sendbird-conversation__no-messages", type: _n.NO_MESSAGES });
  } : R, Z = e.renderFrozenNotification, W = Z === void 0 ? function() {
    return T.createElement(SL, { className: "sendbird-conversation__messages__notification" });
  } : Z, F = fl(), m = F.allMessages, E = F.localMessages, u = F.hasMorePrev, b = F.hasMoreNext, k = F.setInitialTimeStamp, Q = F.setAnimatedMessageId, S = F.setHighLightedMessageId, v = F.isMessageGroupingEnabled, G = F.scrollRef, w = F.onScrollCallback, y = F.onScrollDownCallback, g = F.messagesDispatcher, f = F.messageActionTypes, I = F.currentGroupChannel, K = F.disableMarkAsRead, Ue = F.filterMessageList, q = F.replyType, ae = F.loading, se = F.isScrolled, le = F.unreadSince, L = F.unreadSinceDate, $ = F.typingMembers, ee = zn(), O = typeof Ue == "function" ? m.filter(Ue) : m, re = ee.config.markAsReadScheduler, te = me(!1), Qe = te[0], Ye = te[1];
  OL();
  var Se = function(Be) {
    var He = G == null ? void 0 : G.current;
    if (He != null) {
      var at = He.scrollTop, Ge = He.clientHeight, $e = He.scrollHeight;
      u && pV(at, 0, Vi) && w(Be), b && pV(Ge + at, $e, Vi) && y(Be), !K && pV(Ge + at, $e, Vi) && I && (g({
        type: f.MARK_AS_READ,
        payload: { channel: I }
      }), re.push(I));
    }
  }, P = function() {
    var Be, He, at, Ge, $e;
    k == null || k(null), Q == null || Q(null), S == null || S(null), ((Be = G == null ? void 0 : G.current) === null || Be === void 0 ? void 0 : Be.scrollTop) > -1 && (G.current.scrollTop = ((at = (He = G == null ? void 0 : G.current) === null || He === void 0 ? void 0 : He.scrollHeight) !== null && at !== void 0 ? at : 0) - (($e = (Ge = G == null ? void 0 : G.current) === null || Ge === void 0 ? void 0 : Ge.offsetHeight) !== null && $e !== void 0 ? $e : 0));
  }, ge = function(Be) {
    Be === void 0 && (Be = !1);
    var He = G == null ? void 0 : G.current;
    if (He) {
      var at = He.scrollHeight - He.scrollTop - He.offsetHeight;
      tt < at && (!Be || tt < Vi) && (He.scrollTop += at - tt);
    }
  }, Me = YL({
    hasMore: u,
    hasNext: b,
    onScroll: Se,
    scrollRef: G
  }), We = yL({
    onReachedBottom: function() {
      !b && !K && I && (g({
        type: f.MARK_AS_READ,
        payload: { channel: I }
      }), re.push(I)), Ye(!0);
    },
    onReachedTop: function() {
      Ye(!1);
    },
    onInBetween: function() {
      Ye(!1);
    }
  }), De = XL({ loading: ae }), Oe = De.scrollToBottomHandler, tt = De.scrollBottom;
  return ae ? N() : O.length < 1 ? h() : T.createElement(
    T.Fragment,
    null,
    !se && T.createElement(rV, { type: _n.LOADING }),
    T.createElement(
      "div",
      { className: "sendbird-conversation__messages ".concat(i) },
      T.createElement(
        "div",
        { className: "sendbird-conversation__scroll-container" },
        T.createElement("div", { className: "sendbird-conversation__padding" }),
        T.createElement(
          "div",
          { className: "sendbird-conversation__messages-padding", ref: G, onScroll: function(Be) {
            Me(), Oe(Be), We(Be);
          } },
          O.map(function(Be, He) {
            var at, Ge, $e = h2({
              allMessages: O,
              replyType: q,
              isMessageGroupingEnabled: v,
              currentIndex: He,
              currentMessage: Be,
              currentChannel: I
            }), fe = $e.chainTop, Xe = $e.chainBottom, pt = $e.hasSeparator, Vt = ((at = Be == null ? void 0 : Be.sender) === null || at === void 0 ? void 0 : at.userId) === ((Ge = ee == null ? void 0 : ee.config) === null || Ge === void 0 ? void 0 : Ge.userId);
            return T.createElement(
              _M,
              { message: Be, key: Be == null ? void 0 : Be.messageId, isByMe: Vt },
              T.createElement(U2, {
                handleScroll: ge,
                message: Be,
                hasSeparator: pt,
                chainTop: fe,
                chainBottom: Xe,
                renderMessageContent: V,
                renderSuggestedReplies: s,
                renderCustomSeparator: o,
                // backward compatibility
                renderMessage: c
              })
            );
          }),
          E.map(function(Be, He) {
            var at, Ge, $e = h2({
              allMessages: O,
              replyType: q,
              isMessageGroupingEnabled: v,
              currentIndex: He,
              currentMessage: Be,
              currentChannel: I
            }), fe = $e.chainTop, Xe = $e.chainBottom, pt = ((at = Be == null ? void 0 : Be.sender) === null || at === void 0 ? void 0 : at.userId) === ((Ge = ee == null ? void 0 : ee.config) === null || Ge === void 0 ? void 0 : Ge.userId);
            return T.createElement(
              _M,
              { message: Be, key: Be == null ? void 0 : Be.messageId, isByMe: pt },
              T.createElement(U2, {
                handleScroll: ge,
                message: Be,
                chainTop: fe,
                chainBottom: Xe,
                renderMessageContent: V,
                renderSuggestedReplies: s,
                renderCustomSeparator: o,
                // backward compatibility
                renderMessage: c
              })
            );
          }),
          !b && ((t = (n = ee == null ? void 0 : ee.config) === null || n === void 0 ? void 0 : n.groupChannel) === null || t === void 0 ? void 0 : t.enableTypingIndicator) && ((d = (a = (l = ee == null ? void 0 : ee.config) === null || l === void 0 ? void 0 : l.groupChannel) === null || a === void 0 ? void 0 : a.typingIndicatorTypes) === null || d === void 0 ? void 0 : d.has(uR.Bubble)) && T.createElement(xL, { typingMembers: $, handleScroll: ge })
        )
      ),
      (I == null ? void 0 : I.isFrozen) && W(),
      /**
       * Show unread count IFF scroll is not bottom or is bottom but hasNext is true.
       */
      (!Qe || b) && (le || L) && T.createElement(EL, { className: "sendbird-conversation__messages__notification", count: I == null ? void 0 : I.unreadMessageCount, time: le, lastReadAt: L, onClick: function() {
        G != null && G.current && (G.current.scrollTop = G.current.scrollHeight), !K && I && (re.push(I), g({
          type: f.MARK_AS_READ,
          payload: { channel: I }
        })), k(null), Q(null), S(null);
      } }),
      // This flag is an unmatched variable
      tt > jL && T.createElement(
        "div",
        { className: "sendbird-conversation__scroll-bottom-button", onClick: P, onKeyDown: P, tabIndex: 0, role: "button" },
        T.createElement(dt, { width: "24px", height: "24px", type: Le.CHEVRON_DOWN, fillColor: Pe.PRIMARY })
      )
    )
  );
}, fL = function(e) {
  return T.createElement(KY, ce({}, e));
}, cN = "sendbird-quote_message_input__avatar";
function wL(e) {
  var n, t, l = e.message;
  if (!wa(l) && !Fa(l) || Mi(l))
    return null;
  var a = vY(l);
  return a || (!((n = l.isFileMessage) === null || n === void 0) && n.call(l) && (Yb(l) || dc(l)) ? a = SR(l) : !((t = l.isMultipleFilesMessage) === null || t === void 0) && t.call(l) && l.fileInfoList.length > 0 && vj(l.fileInfoList[0]) && (a = l.fileInfoList[0].url)), dc(l) && a ? T.createElement(
    "div",
    { className: cN },
    T.createElement("video", { style: {
      width: "44px",
      height: "44px"
    }, src: a })
  ) : (Qi(l) || Fa(l)) && a ? T.createElement(el, { className: cN, url: a, alt: ER(l), width: "44px", height: "44px", fixedSize: !0 }) : zj(l) ? T.createElement(
    "div",
    { className: cN },
    T.createElement(dt, { type: Le.FILE_AUDIO, fillColor: Pe.ON_BACKGROUND_2, width: "24px", height: "24px" })
  ) : T.createElement(
    "div",
    { className: cN },
    T.createElement(dt, { type: Le.FILE_DOCUMENT, fillColor: Pe.ON_BACKGROUND_2, width: "24px", height: "24px" })
  );
}
function gL(e) {
  var n = e.className, t = e.replyingMessage, l = e.onClose, a = Gt(Kn).stringSet, d = t, r = t == null ? void 0 : t.sender, i = (wa(t) || Fa(t)) && !Mi(t);
  return T.createElement(
    "div",
    { className: vn(["sendbird-quote_message_input", n]) },
    i && T.createElement(wL, { message: d }),
    T.createElement(
      "div",
      { className: "sendbird-quote_message_input__body", style: {
        width: "calc(100% - ".concat(i ? "164px" : "120px", ")"),
        left: i ? "92px" : "40px"
      } },
      T.createElement(Fe, { className: "sendbird-quote_message_input__body__sender-name", type: oe.CAPTION_1, color: ie.ONBACKGROUND_1 }, "".concat(a.QUOTE_MESSAGE_INPUT__REPLY_TO, " ").concat(r && r.nickname ? r.nickname : a.NO_NAME)),
      T.createElement(
        Fe,
        { className: "sendbird-quote_message_input__body__message-content", type: oe.BODY_2, color: ie.ONBACKGROUND_3 },
        Yb(d) && !o0(d) && a.QUOTE_MESSAGE_INPUT__FILE_TYPE_IMAGE,
        dc(d) && a.QUOTE_MESSAGE_INPUT__FILE_TYPE__VIDEO,
        o0(d) && a.QUOTE_MESSAGE_INPUT__FILE_TYPE_GIF,
        dd(t) && t.message,
        XW(t) === vd.FILE && JY(d),
        Fa(t) && "".concat(d.fileInfoList.length, " Photos"),
        Mi(t) && a.VOICE_MESSAGE
      )
    ),
    T.createElement(dt, { className: "sendbird-quote_message_input__close-button", type: Le.CLOSE, fillColor: Pe.ON_BACKGROUND_2, width: "24px", height: "24px", onClick: function() {
      return l(t);
    } })
  );
}
var qi = {
  PREPARING: "PREPARING",
  READY_TO_RECORD: "READY_TO_RECORD",
  RECORDING: "RECORDING",
  COMPLETED: "COMPLETED"
}, Z2 = function() {
}, IL = function(e) {
  var n = e.onRecordingStarted, t = n === void 0 ? Z2 : n, l = e.onRecordingEnded, a = l === void 0 ? Z2 : l, d = zn().config, r = d.voiceRecord, i = r.maxRecordingTime, c = Ib(), V = c.isRecordable, s = me(null), o = s[0], U = s[1], N = me(qi.PREPARING), R = N[0], h = N[1];
  _e(function() {
    V && R === qi.PREPARING && h(qi.READY_TO_RECORD);
  }, [V]);
  var Z = Pt(function() {
    c == null || c.start({
      onRecordingStarted: function() {
        h(qi.RECORDING), t(), k();
      },
      onRecordingEnded: function(S) {
        h(qi.COMPLETED), a(S), U(S), Q();
      }
    });
  }, [t, a]), W = Pt(function() {
    c == null || c.stop(), Q();
  }, [c]), F = Pt(function() {
    W(), U(null);
  }, [c]), m = me(0), E = m[0], u = m[1], b = null;
  function k() {
    Q(), u(0);
    var S = setInterval(function() {
      u(function(v) {
        var G = v + 100;
        return G > i && Q(), G;
      });
    }, 100);
    b = S;
  }
  function Q() {
    clearInterval(b), b = null;
  }
  return _e(function() {
    E > i && W();
  }, [E, i, W]), {
    start: Z,
    stop: W,
    cancel: F,
    recordingStatus: R,
    recordingTime: E,
    recordedFile: o,
    recordingLimit: i
  };
}, $n = {
  READY_TO_RECORD: "READY_TO_RECORD",
  RECORDING: "RECORDING",
  READY_TO_PLAY: "READY_TO_PLAY",
  PLAYING: "PLAYING"
}, LL = function(e) {
  var n = e.inputState;
  switch (n) {
    case $n.READY_TO_RECORD:
      return T.createElement("div", { className: "sendbird-controler-icon record-icon" });
    case $n.RECORDING:
      return T.createElement("div", { className: "sendbird-controler-icon stop-icon" });
    case $n.READY_TO_PLAY:
      return T.createElement(dt, { className: "sendbird-controler-icon play-icon", width: "20px", height: "20px", type: Le.PLAY, fillColor: Pe.ON_BACKGROUND_1 });
    case $n.PLAYING:
      return T.createElement(
        "div",
        { className: "sendbird-controler-icon pause-icon" },
        T.createElement("div", { className: "sendbird-controler-icon pause-icon-inner" }),
        T.createElement("div", { className: "sendbird-controler-icon pause-icon-inner" })
      );
    default:
      return null;
  }
}, CL = function(e) {
  var n = e.minRecordTime, t = n === void 0 ? HW : n, l = e.maximumValue, a = e.currentValue, d = a === void 0 ? 0 : a, r = e.currentType, i = e.onCancelClick, c = e.onControlClick, V = e.onSubmitClick, s = e.renderCancelButton, o = e.renderControlButton, U = e.renderSubmitButton, N = me(0), R = N[0], h = N[1], Z = nn(function() {
    return r === $n.READY_TO_RECORD;
  }, [r]), W = nn(function() {
    return r === $n.RECORDING;
  }, [r]), F = nn(function() {
    return r === $n.READY_TO_RECORD || r === $n.RECORDING ? t > d : !1;
  }, [r, t, d]), m = nn(function() {
    return r === $n.READY_TO_PLAY || r === $n.PLAYING;
  }, [r]), E = ca().stringSet, u = function() {
    var Q = Date.now();
    Q - R > SZ && (i(), h(Q));
  }, b = Pt(function() {
    var Q = Date.now();
    Q - R > SZ && (c(r), h(Q));
  }, [r]), k = function() {
    var Q = Date.now();
    Q - R > SZ && (F || V(), h(Q));
  };
  return T.createElement(
    "div",
    { className: "sendbird-voice-message-input" },
    T.createElement(
      "div",
      { className: "sendbird-voice-message-input__indicator" },
      T.createElement(
        "div",
        { className: "sendbird-voice-message-input__indicator__progress-bar" },
        T.createElement(GY, { className: "sendbird-voice-message-input__indicator__progress-bar__bar", disabled: Z, maxSize: l, currentSize: d })
      ),
      W ? T.createElement("div", { className: "sendbird-voice-message-input__indicator__on-rec" }) : null,
      T.createElement(BY, { className: "sendbird-voice-message-input__indicator__playback-time", time: m ? l - d : d, labelColor: Z ? ie.ONBACKGROUND_4 : ie.ONCONTENT_1 })
    ),
    T.createElement(
      "div",
      { className: "sendbird-voice-message-input__controler" },
      (s == null ? void 0 : s()) || T.createElement(
        xY,
        { className: "sendbird-voice-message-input__controler__cancel", onClick: u, disableUnderline: !0 },
        T.createElement(Fe, { type: oe.BUTTON_1, color: ie.PRIMARY }, E.BUTTON__CANCEL)
      ),
      (o == null ? void 0 : o(r)) || T.createElement(
        "div",
        { className: "sendbird-voice-message-input__controler__main", onClick: b },
        T.createElement(LL, { inputState: r })
      ),
      (U == null ? void 0 : U()) || T.createElement(
        "div",
        { className: "sendbird-voice-message-input__controler__submit ".concat(F ? "voice-message--disabled" : ""), onClick: k },
        T.createElement(dt, { width: "19px", height: "19px", type: Le.SEND, fillColor: F ? Pe.ON_BACKGROUND_4 : Pe.CONTENT })
      )
    )
  );
}, KL = function(e) {
  var n = e.imageFile, t = e.compressionRate, l = e.resizingWidth, a = e.resizingHeight, d = document.createElement("img");
  return new Promise(function(r, i) {
    d.src = URL.createObjectURL(n), d.onerror = i, d.onload = function() {
      URL.revokeObjectURL(d.src);
      var c = document.createElement("canvas"), V = d.width, s = d.height, o = !l || l > V ? V : l, U = !a || a > s ? s : a, N = V / o, R = s / U;
      N > R ? U = s / (l ? N : 1) : R > N && (o = V / (a ? R : 1)), c.width = o, c.height = U;
      var h = c.getContext("2d");
      if (!h) {
        i(new Error("Failed to get canvas 2d context"));
        return;
      }
      h.drawImage(d, 0, 0, o, U), h.canvas.toBlob(function(Z) {
        if (Z) {
          var W = new File([Z], n.name, { type: n.type });
          r(W);
        } else
          i(new Error("Failed to compress image"));
      }, n.type, t);
    };
  });
}, _L = function(e) {
  var n = e.files, t = e.logger, l = e.imageCompression;
  return ol(void 0, void 0, void 0, function() {
    var a, d, r, i;
    return Ul(this, function(c) {
      switch (c.label) {
        case 0:
          return a = l.compressionRate, d = mR(l.resizingWidth), r = mR(l.resizingHeight), i = {
            failedIndexes: [],
            compressedFiles: []
          }, Array.isArray(n) && n.length > 0 ? a < 0 || 1 < a ? (t == null || t.warning("utils - compressImages: The compressionRate is not acceptable.", a), [2, i]) : [4, Promise.all(n.map(function(V, s) {
            return ol(void 0, void 0, void 0, function() {
              var o, U;
              return Ul(this, function(N) {
                switch (N.label) {
                  case 0:
                    if (!(V.type === "image/jpg" || V.type === "image/png" || V.type === "image/jpeg"))
                      return t == null || t.warning("utils - compressImages: The fileType is not compressible.", { file: V, index: s }), i.failedIndexes.push(s), i.compressedFiles.push(V), [
                        2
                        /*return*/
                      ];
                    N.label = 1;
                  case 1:
                    return N.trys.push([1, 3, , 4]), [4, KL({
                      imageFile: V,
                      compressionRate: a,
                      resizingWidth: d,
                      resizingHeight: r
                    })];
                  case 2:
                    return o = N.sent(), i.compressedFiles.push(o), [3, 4];
                  case 3:
                    return U = N.sent(), i.failedIndexes.push(s), t == null || t.warning("utils - compressImages: Failed to compress image file", { file: V, err: U }), [3, 4];
                  case 4:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }))] : (t == null || t.warning("utils - compressImages: There are no files.", n), [2, i]);
        case 1:
          return c.sent(), t == null || t.info("utils - compressImages: Finished compressing images", i), [2, i];
      }
    });
  });
}, PL = function(e) {
  var n, t = e.channel, l = e.onCancelClick, a = e.onSubmitClick, d = Wt(zr()).current, r = me(null), i = r[0], c = r[1], V = me($n.READY_TO_RECORD), s = V[0], o = V[1], U = me(!1), N = U[0], R = U[1], h = me(!1), Z = h[0], W = h[1], F = me(!1), m = F[0], E = F[1], u = ca().stringSet, b = zn().config, k = ((n = b == null ? void 0 : b.voiceRecord) === null || n === void 0 ? void 0 : n.minRecordingTime) || HW, Q = IL({
    onRecordingStarted: function() {
      o($n.RECORDING);
    },
    onRecordingEnded: function(se) {
      c(se);
    }
  }), S = Q.start, v = Q.stop, G = Q.cancel, w = Q.recordingTime, y = Q.recordingStatus, g = Q.recordingLimit, f = yY({
    channelUrl: t == null ? void 0 : t.url,
    key: d,
    audioFile: i
  }), I = f.play, K = f.pause, Ue = f.playbackTime, q = f.playingStatus, ae = f.stop;
  return _e(function() {
    pR(t) || Yo(t) ? W(!0) : W(!1);
  }, [t == null ? void 0 : t.myRole, t == null ? void 0 : t.isFrozen, t == null ? void 0 : t.myMutedState]), _e(function() {
    N && i && (a(i, w), R(!1), c(null));
  }, [N, i, w]), _e(function() {
    i && (w < k ? (o($n.READY_TO_RECORD), c(null)) : q === Td.PLAYING ? o($n.PLAYING) : o($n.READY_TO_PLAY));
  }, [i, w, q]), T.createElement(
    "div",
    { className: "sendbird-voice-message-input-wrapper" },
    T.createElement(CL, { currentValue: y === qi.COMPLETED ? Ue : w, maximumValue: y === qi.COMPLETED ? w : g, currentType: s, onCancelClick: function() {
      l(), G(), ae();
    }, onSubmitClick: function() {
      Z ? (E(!0), o($n.READY_TO_RECORD)) : (v(), K(), R(!0));
    }, onControlClick: function(se) {
      switch (se) {
        case $n.READY_TO_RECORD: {
          ae(), S();
          break;
        }
        case $n.RECORDING: {
          w >= k && !Z ? v() : Z ? (G(), E(!0), o($n.READY_TO_RECORD)) : (G(), o($n.READY_TO_RECORD));
          break;
        }
        case $n.READY_TO_PLAY: {
          I();
          break;
        }
        case $n.PLAYING: {
          K();
          break;
        }
      }
    } }),
    m && T.createElement(
      Ic,
      { className: "sendbird-voice-message-input-wrapper-alert", titleText: Yo(t) ? u.MODAL__VOICE_MESSAGE_INPUT_DISABLED__TITLE_MUTED : u.MODAL__VOICE_MESSAGE_INPUT_DISABLED__TITLE_FROZEN, hideFooter: !0, isCloseOnClickOutside: !0, onCancel: function() {
        E(!1), l();
      } },
      T.createElement(
        "div",
        { className: "sendbird-voice-message-input-wrapper-alert__body" },
        T.createElement(Ql, { className: "sendbird-voice-message-input-wrapper-alert__body__ok-button", type: nl.PRIMARY, size: Ei.BIG, onClick: function() {
          E(!1), l();
        } }, u.BUTTON__OK)
      )
    )
  );
}, AL = function(e, n) {
  var t = e.sendFileMessage, l = e.sendMultipleFilesMessage, a = e.quoteMessage, d = n.logger, r = ca().stringSet, i = zn().config, c = i.imageCompression, V = i == null ? void 0 : i.uikitUploadSizeLimit, s = i == null ? void 0 : i.uikitMultipleFilesMessageLimit, o = sw().openModal;
  return Pt(function(U) {
    return ol(void 0, void 0, void 0, function() {
      var N, R, h, Z, W, F;
      return Ul(this, function(m) {
        switch (m.label) {
          case 0:
            return U.length === 0 ? (d.warning("Channel|useHandleUploadFiles: given file list is empty.", { files: U }), [
              2
              /*return*/
            ]) : U.length > s ? (d.info("Channel|useHandleUploadFiles: Cannot upload files more than ".concat(s)), o({
              modalProps: {
                titleText: r.FILE_UPLOAD_NOTIFICATION__COUNT_LIMIT.replace("%d", "".concat(V)),
                hideFooter: !0
              },
              childElement: function(E) {
                var u = E.closeModal;
                return T.createElement(mF, { type: nl.PRIMARY, submitText: r.BUTTON__OK, hideCancelButton: !0, onCancel: u, onSubmit: u });
              }
            }), [
              2
              /*return*/
            ]) : U.some(function(E) {
              return E.size > V;
            }) ? (d.info("Channel|useHandleUploadFiles: Cannot upload file size exceeding ".concat(V)), N = 1024 * 1024, o({
              modalProps: {
                titleText: r.FILE_UPLOAD_NOTIFICATION__SIZE_LIMIT.replace("%d", "".concat(Math.floor(V / N))),
                hideFooter: !0
              },
              childElement: function(E) {
                var u = E.closeModal;
                return T.createElement(mF, { type: nl.PRIMARY, submitText: r.BUTTON__OK, hideCancelButton: !0, onCancel: u, onSubmit: u });
              }
            }), [
              2
              /*return*/
            ]) : [4, _L({
              files: U,
              imageCompression: c,
              logger: d
            })];
          case 1:
            return R = m.sent().compressedFiles, h = R, h.length === 1 ? (d.info("Channel|useHandleUploadFiles: sending one file."), Z = h[0], [2, t({ file: Z, parentMessageId: a == null ? void 0 : a.messageId })]) : h.length > 1 ? (d.info("Channel|useHandleUploadFiles: sending multiple files."), W = [], F = [], h.forEach(function(E) {
              XV(E.type) ? W.push(E) : F.push(E);
            }), [2, F.reduce(function(E, u) {
              return E.then(function() {
                return t({ file: u, parentMessageId: a == null ? void 0 : a.messageId });
              });
            }, function() {
              return W.length === 0 ? Promise.resolve() : W.length === 1 ? t({ file: W[0] }) : l({
                fileInfoList: W.map(function(E) {
                  return {
                    file: E,
                    fileName: E.name,
                    fileSize: E.size,
                    mimeType: E.type
                  };
                }),
                parentMessageId: a == null ? void 0 : a.messageId
              });
            }())]) : [
              2
              /*return*/
            ];
        }
      });
    });
  }, [t, l, a]);
}, qL = T.forwardRef(function(e, n) {
  var t = e.currentChannel, l = e.isMultipleFilesMessageEnabled, a = e.loading, d = e.quoteMessage, r = e.setQuoteMessage, i = e.messageInputRef, c = e.sendUserMessage, V = e.sendFileMessage, s = e.sendVoiceMessage, o = e.sendMultipleFilesMessage, U = e.renderUserMentionItem, N = e.renderFileUploadIcon, R = e.renderVoiceMessageIcon, h = e.renderSendMessageIcon, Z = e.acceptableMimeTypes, W = e.disabled, F = ca().stringSet, m = dr().isMobile, E = zn(), u = E.stores, b = E.config, k = b.isOnline, Q = b.isMentionEnabled, S = b.isVoiceMessageEnabled, v = b.isMultipleFilesMessageEnabled, G = b.userMention, w = b.logger, y = u.sdkStore.sdk, g = G.maxMentionCount, f = G.maxSuggestionCount, I = t == null ? void 0 : t.isBroadcast, K = (t == null ? void 0 : t.myRole) === "operator", Ue = me(""), q = Ue[0], ae = Ue[1], se = me([]), le = se[0], L = se[1], $ = me([]), ee = $[0], O = $[1], re = me(null), te = re[0], Qe = re[1], Ye = me([]), Se = Ye[0], P = Ye[1], ge = me(null), Me = ge[0], We = ge[1], De = me(!1), Oe = De[0], tt = De[1], Be = a || !t || pR(t) || Yo(t) || !k && !(y != null && y.isCacheEnabled) || W, He = !Be && Q && q.length > 0 && !I, at = l ?? v, Ge = NY({ ref: n || i }, { logger: w }), $e = (Ge == null ? void 0 : Ge.length) < g;
  _e(function() {
    ae(""), L([]), O([]), Qe(null), P([]), We(null), tt(!1);
  }, [t == null ? void 0 : t.url]), _e(function() {
    L(le.filter(function(Xe) {
      var pt = Xe.userId, Vt = ee.indexOf(pt);
      return Vt < 0 ? !1 : (ee.splice(Vt, 1), !0);
    }));
  }, [ee]);
  var fe = AL({
    sendFileMessage: V,
    sendMultipleFilesMessage: o,
    quoteMessage: d
  }, { logger: w });
  return I && !K ? null : T.createElement(
    "div",
    { className: "sendbird-message-input-wrapper".concat(Oe ? "--voice-message" : "") },
    He && T.createElement(fL, { currentChannel: t, targetNickname: q, inputEvent: Me, renderUserMentionItem: U, onUserItemClick: function(Xe) {
      Xe && L(Ut(Ut([], le, !0), [Xe], !1)), ae(""), Qe(Xe), We(null);
    }, onFocusItemChange: function() {
      We(null);
    }, onFetchUsers: function(Xe) {
      P(Xe);
    }, ableAddMention: $e, maxMentionCount: g, maxSuggestionCount: f }),
    d && T.createElement(
      "div",
      { className: "sendbird-message-input-wrapper__quote-message-input" },
      T.createElement(gL, { replyingMessage: d, onClose: function() {
        return r(null);
      } })
    ),
    Oe ? T.createElement(PL, { channel: t, onSubmitClick: function(Xe, pt) {
      s({ file: Xe, parentMessageId: d == null ? void 0 : d.messageId }, pt), r(null), tt(!1);
    }, onCancelClick: function() {
      tt(!1);
    } }) : T.createElement(EY, { className: "sendbird-message-input-wrapper__message-input", channel: t, channelUrl: t == null ? void 0 : t.url, isMobile: m, acceptableMimeTypes: Z, mentionSelectedUser: te, isMentionEnabled: Q, isVoiceMessageEnabled: S, isSelectingMultipleFilesEnabled: at, onVoiceMessageIconClick: function() {
      tt(!0);
    }, setMentionedUsers: L, placeholder: d && F.MESSAGE_INPUT__QUOTE_REPLY__PLACE_HOLDER || (W || pR(t)) && F.MESSAGE_INPUT__PLACE_HOLDER__DISABLED || Yo(t) && (m ? F.MESSAGE_INPUT__PLACE_HOLDER__MUTED_SHORT : F.MESSAGE_INPUT__PLACE_HOLDER__MUTED), ref: n || i, disabled: Be, renderFileUploadIcon: N, renderSendMessageIcon: h, renderVoiceMessageIcon: R, onStartTyping: function() {
      t == null || t.startTyping();
    }, onSendMessage: function(Xe) {
      var pt, Vt = Xe.message, yt = Xe.mentionTemplate;
      c({
        message: Vt,
        mentionedUsers: le,
        mentionedMessageTemplate: yt,
        parentMessageId: d == null ? void 0 : d.messageId
      }), ae(""), L([]), r(null), (pt = t == null ? void 0 : t.endTyping) === null || pt === void 0 || pt.call(t);
    }, onFileUpload: function(Xe) {
      fe(Xe), r(null);
    }, onUserMentioned: function(Xe) {
      (te == null ? void 0 : te.userId) === (Xe == null ? void 0 : Xe.userId) && (Qe(null), ae(""));
    }, onMentionStringChange: function(Xe) {
      ae(Xe);
    }, onMentionedUserIdsUpdated: function(Xe) {
      O(Xe);
    }, onKeyDown: function(Xe) {
      return He && (Se == null ? void 0 : Se.length) > 0 && (Xe.key === Wd.Enter && $e || Xe.key === Wd.ArrowUp || Xe.key === Wd.ArrowDown) ? (We(Xe), !0) : !1;
    } })
  );
}), $L = function(e) {
  var n, t, l = zn().config, a = fl(), d = a.quoteMessage, r = a.localMessages, i = a.currentGroupChannel, c = a.sendMessage, V = a.sendFileMessage, s = a.sendVoiceMessage, o = a.sendMultipleFilesMessage, U = i == null ? void 0 : i.lastMessage, N = ((n = l == null ? void 0 : l.groupChannel) === null || n === void 0 ? void 0 : n.enableSuggestedReplies) && OW(U).length > 0 && (r == null ? void 0 : r.length) === 0, R = e.disabled || N && !!(!((t = U.extendedMessagePayload) === null || t === void 0) && t.disable_chat_input);
  return T.createElement(qL, ce({}, e, a, { disabled: R, currentChannel: i, sendUserMessage: function(h) {
    return c({
      message: h.message,
      mentionTemplate: h.mentionedMessageTemplate,
      mentionedUsers: h.mentionedUsers,
      quoteMessage: d
    });
  }, sendFileMessage: function(h) {
    return V(h.file, d);
  }, sendVoiceMessage: function(h, Z) {
    var W = h.file;
    return s(W, Z, d);
  }, sendMultipleFilesMessage: function(h) {
    var Z = h.fileInfoList;
    return o(Z.map(function(W) {
      return W.file;
    }), d);
  } }));
}, eC = function(e) {
  var n = fl(), t = n.channelUrl, l = n.isInvalid, a = e.renderChannelHeader, d = a === void 0 ? function(s) {
    return T.createElement(UY, ce({}, s));
  } : a, r = e.renderMessageList, i = r === void 0 ? function(s) {
    return T.createElement(HL, ce({}, s, { className: "sendbird-conversation__message-list" }));
  } : r, c = e.renderMessageInput, V = c === void 0 ? function() {
    return T.createElement($L, ce({}, e));
  } : c;
  return T.createElement(R4, ce({}, e, n, { isLoading: e == null ? void 0 : e.isLoading, isInvalid: l, channelUrl: t, renderChannelHeader: d, renderMessageList: i, renderMessageInput: V }));
};
const PY = (e) => /* @__PURE__ */ z.createElement("svg", { width: 32, height: 32, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13 3C13 1.34315 14.3431 0 16 0C17.6569 0 19 1.34315 19 3C19 4.4865 17.9189 5.72048 16.5 5.95852V8H20C25.036 8 29.2816 11.3842 30.5866 16.0025C31.3747 16.0473 32 16.7007 32 17.5V21.5C32 22.3284 31.3284 23 30.5 23C30.4175 23 30.3366 22.9933 30.2577 22.9805C28.6626 27.0882 24.6714 30 20 30H12C7.32865 30 3.3374 27.0882 1.7423 22.9805C1.66342 22.9933 1.58249 23 1.5 23C0.671573 23 0 22.3284 0 21.5V17.5C0 16.7007 0.625255 16.0473 1.41337 16.0025C2.71841 11.3842 6.964 8 12 8H15.5V5.95852C14.0811 5.72048 13 4.4865 13 3ZM12 12C8.13401 12 5 15.134 5 19C5 22.866 8.13401 26 12 26H20C23.866 26 27 22.866 27 19C27 15.134 23.866 12 20 12H12ZM9 19C9 17.8954 9.89543 17 11 17C12.1046 17 13 17.8954 13 19C13 20.1046 12.1046 21 11 21C9.89543 21 9 20.1046 9 19ZM21 17C19.8954 17 19 17.8954 19 19C19 20.1046 19.8954 21 21 21C22.1046 21 23 20.1046 23 19C23 17.8954 22.1046 17 21 17Z", fill: "white" })), tC = (e) => /* @__PURE__ */ z.createElement("svg", { width: 20, height: 18, viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.3026 2.41113L15.5134 2.61281L18 4.92515L18.0001 2.00003C18.0001 1.4872 18.3861 1.06453 18.8835 1.00676L19.0001 1.00003C19.5129 1.00003 19.9356 1.38607 19.9934 1.88341L20.0001 2.00003V8.00003C20.0001 8.51287 19.6141 8.93554 19.1167 8.99331L19.0001 9.00003H13.0001C12.4478 9.00003 12.0001 8.55232 12.0001 8.00003C12.0001 7.4872 12.3861 7.06453 12.8835 7.00676L13.0001 7.00003L17.2946 7.00003L14.1295 4.05645C11.8929 1.84645 8.44149 1.36302 5.66851 2.87286C2.90115 4.37964 1.47901 7.50688 2.17556 10.5437C2.87284 13.5837 5.52644 15.8054 8.68662 15.9879C11.8477 16.1705 14.7472 14.2685 15.7992 11.3281C15.9852 10.8081 16.5576 10.5374 17.0776 10.7234C17.5976 10.9095 17.8683 11.4818 17.6823 12.0018C16.3302 15.7809 12.6148 18.2182 8.57128 17.9846C4.52685 17.751 1.12311 14.9013 0.226178 10.9908C-0.671496 7.07716 1.15961 3.05063 4.71213 1.11635C8.17252 -0.767774 12.4557 -0.225629 15.3026 2.41113Z", fill: "#30308F" })), nC = (e) => /* @__PURE__ */ z.createElement("svg", { width: 743, height: 240, viewBox: "0 0 743 240", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("g", { clipPath: "url(#clip0_4054_22884)" }, /* @__PURE__ */ z.createElement("rect", { width: 743, height: 240, fill: "url(#paint0_linear_4054_22884)" }), /* @__PURE__ */ z.createElement("rect", { opacity: 0.5, x: 1032, y: 228, width: 486, height: 11.9999, transform: "rotate(-180 1032 228)", fill: "url(#paint1_linear_4054_22884)" }), /* @__PURE__ */ z.createElement("rect", { opacity: 0.5, x: 996, y: 204, width: 416, height: 12, transform: "rotate(-180 996 204)", fill: "url(#paint2_linear_4054_22884)" }), /* @__PURE__ */ z.createElement("rect", { opacity: 0.4, x: 1058, y: 180, width: 1058, height: 11.9999, transform: "rotate(-180 1058 180)", fill: "url(#paint3_linear_4054_22884)" }), /* @__PURE__ */ z.createElement("rect", { opacity: 0.5, x: 1045, y: 155, width: 1045, height: 11.9999, transform: "rotate(-180 1045 155)", fill: "url(#paint4_linear_4054_22884)" }), /* @__PURE__ */ z.createElement("rect", { opacity: 0.5, x: 891, y: 61, width: 294, height: 12, transform: "rotate(-180 891 61)", fill: "url(#paint5_linear_4054_22884)" }), /* @__PURE__ */ z.createElement("rect", { opacity: 0.5, x: 891, y: 37, width: 351, height: 12, transform: "rotate(-180 891 37)", fill: "url(#paint6_linear_4054_22884)" }), /* @__PURE__ */ z.createElement("rect", { opacity: 0.5, x: 891, y: 13, width: 396, height: 11.9999, transform: "rotate(-180 891 13)", fill: "url(#paint7_linear_4054_22884)" })), /* @__PURE__ */ z.createElement("defs", null, /* @__PURE__ */ z.createElement("linearGradient", { id: "paint0_linear_4054_22884", x1: 391.933, y1: -707575e-12, x2: 404.375, y2: 278.354, gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ z.createElement("stop", { stopColor: "#0D0D0D" }), /* @__PURE__ */ z.createElement("stop", { offset: 0.652043, stopColor: "#6210CC" }), /* @__PURE__ */ z.createElement("stop", { offset: 1, stopColor: "#4DCD90" })), /* @__PURE__ */ z.createElement("linearGradient", { id: "paint1_linear_4054_22884", x1: 1056.33, y1: 234, x2: 1547.59, y2: 234, gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ z.createElement("stop", { stopColor: "#431185", stopOpacity: 0.11 }), /* @__PURE__ */ z.createElement("stop", { offset: 0.129489, stopColor: "#431185", stopOpacity: 0.909817 }), /* @__PURE__ */ z.createElement("stop", { offset: 0.14409, stopColor: "#431185" }), /* @__PURE__ */ z.createElement("stop", { offset: 0.552083, stopColor: "#5C4886", stopOpacity: 0.46 }), /* @__PURE__ */ z.createElement("stop", { offset: 0.921875, stopColor: "#B0FF8B", stopOpacity: 0 })), /* @__PURE__ */ z.createElement("linearGradient", { id: "paint2_linear_4054_22884", x1: 1016.83, y1: 210, x2: 1437.33, y2: 210, gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ z.createElement("stop", { stopColor: "#431185", stopOpacity: 0.09 }), /* @__PURE__ */ z.createElement("stop", { offset: 0.314529, stopColor: "#431185" }), /* @__PURE__ */ z.createElement("stop", { offset: 0.921875, stopColor: "#B0FF8B", stopOpacity: 0 })), /* @__PURE__ */ z.createElement("linearGradient", { id: "paint3_linear_4054_22884", x1: 1110.97, y1: 186, x2: 2059.95, y2: 186, gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ z.createElement("stop", { stopColor: "#431185", stopOpacity: 0.15 }), /* @__PURE__ */ z.createElement("stop", { offset: 0.190609, stopColor: "#431185" }), /* @__PURE__ */ z.createElement("stop", { offset: 0.935022, stopColor: "#B0FF8B", stopOpacity: 0 })), /* @__PURE__ */ z.createElement("linearGradient", { id: "paint4_linear_4054_22884", x1: 1097.32, y1: 160.999, x2: 2090, y2: 161, gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ z.createElement("stop", { stopColor: "#471185", stopOpacity: 0.11 }), /* @__PURE__ */ z.createElement("stop", { offset: 0.128465, stopColor: "#471185" }), /* @__PURE__ */ z.createElement("stop", { offset: 1, stopColor: "#A383C7", stopOpacity: 0 })), /* @__PURE__ */ z.createElement("linearGradient", { id: "paint5_linear_4054_22884", x1: 905.72, y1: 66.9998, x2: 1202.9, y2: 66.9998, gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ z.createElement("stop", { stopColor: "#471185" }), /* @__PURE__ */ z.createElement("stop", { offset: 1, stopColor: "#A383C7", stopOpacity: 0 })), /* @__PURE__ */ z.createElement("linearGradient", { id: "paint6_linear_4054_22884", x1: 908.574, y1: 42.9998, x2: 1263.37, y2: 42.9998, gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ z.createElement("stop", { stopColor: "#471185" }), /* @__PURE__ */ z.createElement("stop", { offset: 1, stopColor: "#A383C7", stopOpacity: 0 })), /* @__PURE__ */ z.createElement("linearGradient", { id: "paint7_linear_4054_22884", x1: 910.827, y1: 18.9995, x2: 1287, y2: 18.9996, gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ z.createElement("stop", { stopColor: "#471185" }), /* @__PURE__ */ z.createElement("stop", { offset: 1, stopColor: "#A383C7", stopOpacity: 0 })), /* @__PURE__ */ z.createElement("clipPath", { id: "clip0_4054_22884" }, /* @__PURE__ */ z.createElement("rect", { width: 743, height: 240, fill: "white" }))));
function lC() {
  let e = (/* @__PURE__ */ new Date()).getTime();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (n) => {
    const t = (e + Math.random() * 16) % 16 | 0;
    return e = Math.floor(e / 16), (n === "x" ? t : t & 3 | 8).toString(16);
  });
}
function kR(e) {
  const n = new Date(e);
  let t = n.getHours();
  const l = t >= 12 ? "PM" : "AM";
  t = t % 12, t = t || 12;
  const a = n.getMinutes(), d = (a < 10 ? "0" : "") + a;
  return t + ":" + d + " " + l;
}
function T2(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var AY = /* @__PURE__ */ ((e) => (e.string = "String", e.codeSnippet = "codeSnippet", e))(AY || {});
const aC = (e) => {
  const n = /```([a-zA-Z]+)([\s\S]*)```/, t = e.match(n);
  return t ? {
    type: "codeSnippet",
    value: t[2],
    language: t[1]
  } : {
    type: "codeSnippet",
    value: e.substring(3, e.length - 3).trim(),
    language: "unknown"
    /* unknown */
  };
};
function dC(e) {
  const n = "```", t = [];
  let l = "", a = !1;
  for (let d = 0; d < e.length; d++) {
    const r = e[d];
    a ? F2(d, e, n) ? (l += n, t.push(l), l = "", a = !1, d += n.length - 1) : l += r : F2(d, e, n) ? (t.push(l), l = n, a = !0, d += n.length - 1) : l += r;
  }
  return t.push(l), t;
}
function F2(e, n, t) {
  return n.substring(e, e + t.length) === t;
}
function rC(e) {
  return dC(e).map((l) => l.startsWith("```") && l.endsWith("```") ? aC(l) : {
    type: "String",
    value: l.trim()
  });
}
function iC(e) {
  return !e || Object.values($Y).indexOf(e) === -1;
}
function VC(e) {
  if (typeof e != "string")
    return !1;
  try {
    return JSON.parse(e), !0;
  } catch {
    return !1;
  }
}
function Uh(e) {
  const n = e.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
  return ch.sanitize(n);
}
function cC(e, n) {
  let t = e;
  for (let l = 0; l < n.length; l++) {
    const [a, d] = n[l];
    t = sC(t, a, d);
  }
  return t;
}
function sC(e, n, t) {
  const l = new RegExp(n, "gi");
  return e.replace(l, t);
}
function oC(e) {
  const n = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#/%?=~_|!:,.;]*[-A-Z0-9+&@#/%=~_|])/gi;
  return e.replace(n, function(t) {
    return `<a href="${t}" target="_blank">${t}</a>`;
  });
}
function UC(e, n) {
  return n.findIndex((t) => e.includes(t)) > -1;
}
function V1(e, n) {
  if (!e)
    throw new Error(n);
}
function W2() {
}
const NC = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
function qY(e) {
  const n = e.toLocaleString("en-us", { month: "short" }), t = e.getUTCDate(), l = `${n}, ${t}`, a = ("0" + e.getUTCHours()).slice(-2), d = ("0" + e.getUTCMinutes()).slice(-2), r = `${a}:${d}`;
  return { formattedDate: l, formattedTime: r };
}
const IZ = "chat-ai-widget", oU = () => {
  const e = {};
  return {
    getItem: (n) => {
      const t = `${IZ}_${n}`;
      try {
        return localStorage.getItem(t);
      } catch {
        return e[t];
      }
    },
    setItem: (n, t) => {
      const l = `${IZ}_${n}`;
      try {
        localStorage.setItem(l, t);
      } catch {
        e[l] = t;
      }
    },
    removeItem: (n) => {
      const t = `${IZ}_${n}`;
      try {
        localStorage.removeItem(t);
      } catch {
      }
    }
  };
}, RC = lC(), hC = {
  botCategory: "fintech",
  botNickName: "Khan Academy Support Bot",
  userId: RC,
  userNickName: "User",
  betaMark: !0,
  customBetaMarkText: "BETA",
  suggestedMessageContent: {
    replyContents: [
      {
        title: "Yes, it was helpful! 👍",
        text: "Thanks for your feedback! You can also build your own AI chatbot in Sendbird.",
        buttonText: "Try free trial",
        link: "https://dashboard.sendbird.com/auth/signup"
      },
      {
        title: "No, I need more help. 💬",
        text: "I'm sorry, we couldn't help you. Let us know how we can improve by talking to one of our teammates.",
        buttonText: "Talk to an expert",
        link: "https://sendbird.com/contact-sales"
      }
    ],
    messageFilterList: [
      "Can you please clarify?",
      "How can I assist you",
      "How can I help you",
      "Can you clarify",
      "That's not a question I can answer unfortunately",
      "Try again",
      "I couldn't find the answer to your question",
      "Can you try again?",
      "I apologize for any confusion",
      "I'm sorry, I couldn't understand your question",
      "That's not a valid question",
      "Is there a specific question you have",
      "I'm here to help you with any questions you have",
      "Ask away"
    ]
  },
  firstMessageData: [
    // {
    //   data: {
    //     suggested_replies: [
    //       'What can I learn from Pre-K 8th grade?',
    //       'Tell me about Math',
    //     ],
    //   },
    //   message: "Hi~ I'm Khan Academy Support ChatBot. Ask me anything!",
    // },
  ],
  createGroupChannelParams: {
    name: "Sendbird AI Chatbot",
    coverUrl: "https://images.unsplash.com/photo-1526304640581-d334cdbbf45e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2070&q=80"
  },
  startingPageContent: {
    headerContent: {
      headerOne: "",
      headerTwo: "Ask me anything!"
    },
    messageContent: {
      header: "AI ChatBot",
      body: "Hi~ I'm Khan Academy Support ChatBot. Ask me anything!"
    },
    logoContent: {
      Component: PY,
      width: "30px"
    },
    backGroundContent: {
      Component: nC,
      height: "240px"
    }
  },
  chatBottomContent: {
    text: "Sendbird AI ChatBot",
    backgroundColor: "linear-gradient(273.73deg, #4DCD90 -0.83%, #6210CC 48.04%, #6210CC 75.45%)"
  },
  messageBottomContent: {
    text: "AI-generated response powered by OpenAI",
    infoIconText: "In this beta version, the AI-generated responses may lack complete accuracy."
  },
  replacementTextList: [["the Text extracts", "ChatBot Knowledge Base"]],
  instantConnect: !0,
  customRefreshComponent: {
    icon: tC,
    width: "20px",
    height: "18px"
  },
  enableSourceMessage: !0,
  enableEmojiFeedback: !1,
  enableMention: !0
}, BN = "luke", $Y = {
  linkSuggestion: "linkSuggestion",
  confirmation: "confirmation"
}, qn = hC, eQ = _l({
  applicationId: null,
  botId: null,
  ...qn
}), ZC = (e) => {
  const n = nn(
    () => {
      var t, l, a, d, r, i;
      return {
        apiHost: e.apiHost,
        applicationId: e.applicationId,
        botId: e.botId,
        botCategory: e.botCategory ?? qn.botCategory,
        botNickName: e.botNickName ?? qn.botNickName,
        userId: e.userId ?? qn.userId,
        userNickName: e.userNickName ?? qn.userNickName,
        betaMark: e.betaMark ?? qn.betaMark,
        customBetaMarkText: e.customBetaMarkText ?? qn.customBetaMarkText,
        suggestedMessageContent: e.suggestedMessageContent ?? qn.suggestedMessageContent,
        firstMessageData: e.firstMessageData ?? [],
        createGroupChannelParams: e.createGroupChannelParams ?? qn.createGroupChannelParams,
        startingPageContent: e.startingPageContent ?? qn.startingPageContent,
        chatBottomContent: e.chatBottomContent ?? qn.chatBottomContent,
        messageBottomContent: e.messageBottomContent ?? qn.messageBottomContent,
        replacementTextList: e.replacementTextList ?? qn.replacementTextList,
        instantConnect: e.instantConnect ?? qn.instantConnect,
        customRefreshComponent: {
          icon: ((t = e.customRefreshComponent) == null ? void 0 : t.icon) ?? qn.customRefreshComponent.icon,
          width: ((l = e.customRefreshComponent) == null ? void 0 : l.width) ?? qn.customRefreshComponent.width,
          height: ((a = e.customRefreshComponent) == null ? void 0 : a.height) ?? qn.customRefreshComponent.height,
          onClick: ((d = e.customRefreshComponent) == null ? void 0 : d.onClick) ?? qn.customRefreshComponent.onClick,
          style: {
            ...qn.customRefreshComponent.style,
            ...(r = e.customRefreshComponent) == null ? void 0 : r.style
          }
        },
        configureSession: e.configureSession,
        enableSourceMessage: e.enableSourceMessage ?? qn.enableSourceMessage,
        enableEmojiFeedback: e.enableEmojiFeedback ?? qn.enableEmojiFeedback,
        enableMention: e.enableMention ?? qn.enableMention,
        inputValue: (i = e.inputValue) != null && i.value ? e.inputValue : {
          value: "",
          id: 1
        }
      };
    },
    [e]
  );
  return /* @__PURE__ */ Y.jsx(eQ.Provider, { value: n, children: e.children });
}, jn = () => Gt(eQ), tQ = _l({
  sbConnectionStatus: "INIT",
  setSbConnectionStatus: W2,
  firstMessage: null,
  setFirstMessage: W2
}), TC = (e) => {
  const { instantConnect: n } = jn(), [t, l] = (
    // Don't need to use this state if instantConnect is true
    me(n ? "CONNECTED" : "INIT")
  ), [a, d] = me(null);
  return /* @__PURE__ */ Y.jsx(
    tQ.Provider,
    {
      value: {
        sbConnectionStatus: t,
        setSbConnectionStatus: l,
        firstMessage: a,
        setFirstMessage: d
      },
      children: e.children
    }
  );
}, UU = () => Gt(tQ), nQ = "load-time", lQ = "num-of-messages", FC = "member-ids", WC = "bot-id";
function mC(e) {
  const n = Wt(oU());
  _e(() => {
    n.current.setItem(WC, e), window.dispatchEvent(new Event("storage"));
  }, []);
}
function uC() {
  const e = Wt(oU());
  _e(() => {
    e.current.setItem(
      nQ,
      Math.floor(Date.now() / 1e3).toString()
    ), window.dispatchEvent(new Event("storage"));
  }, []);
}
function pC(e) {
  const n = Wt(oU()), { allMessages: t } = fl(), l = (t == null ? void 0 : t.filter((a) => {
    var d;
    return ((d = a.sender) == null ? void 0 : d.userId) === e;
  }).length) ?? 0;
  _e(() => {
    n.current.setItem(lQ, l.toString()), window.dispatchEvent(new Event("storage"));
  }, [l]);
}
function MC() {
  const e = Wt(oU());
  return () => {
    e.current.setItem(
      nQ,
      Math.floor(Date.now() / 1e3).toString()
    ), e.current.setItem(lQ, "0"), window.dispatchEvent(new Event("storage"));
  };
}
function EC() {
  const e = Wt(oU()), { currentGroupChannel: n } = fl(), t = (n == null ? void 0 : n.members.map((l) => l.userId)) ?? [];
  _e(() => {
    e.current.setItem(FC, t.toString()), window.dispatchEvent(new Event("storage"));
  }, [t]);
}
const Nh = "data:image/png;base64,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", SC = (e) => /* @__PURE__ */ z.createElement("svg", { width: 26, height: 12, viewBox: "0 0 26 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("rect", { opacity: 0.35, x: 1.3719, y: 0.826485, width: 21.0337, height: 10.3499, rx: 2.17014, stroke: "black", strokeWidth: 1.0016 }), /* @__PURE__ */ z.createElement("path", { opacity: 0.4, d: "M23.9082 3.99829V8.0047C24.7142 7.66538 25.2384 6.87603 25.2384 6.0015C25.2384 5.12696 24.7142 4.33761 23.9082 3.99829", fill: "black" }), /* @__PURE__ */ z.createElement("rect", { x: 2.87402, y: 2.32886, width: 18.0289, height: 7.34509, rx: 1.33547, fill: "black" })), kC = (e) => /* @__PURE__ */ z.createElement("svg", { width: 17, height: 12, viewBox: "0 0 17 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.9999 0.659912H14.9999C14.4477 0.659912 13.9999 1.10835 13.9999 1.66152V10.3421C13.9999 10.8952 14.4477 11.3437 14.9999 11.3437H15.9999C16.5522 11.3437 16.9999 10.8952 16.9999 10.3421V1.66152C16.9999 1.10835 16.5522 0.659912 15.9999 0.659912ZM10.3333 2.9969H11.3333C11.8856 2.9969 12.3333 3.44534 12.3333 3.99851V10.342C12.3333 10.8952 11.8856 11.3436 11.3333 11.3436H10.3333C9.78101 11.3436 9.3333 10.8952 9.3333 10.342V3.99851C9.3333 3.44534 9.78101 2.9969 10.3333 2.9969ZM6.66666 5.33414H5.66665C5.11437 5.33414 4.66665 5.78257 4.66665 6.33574V10.3422C4.66665 10.8953 5.11437 11.3438 5.66665 11.3438H6.66666C7.21894 11.3438 7.66666 10.8953 7.66666 10.3422V6.33574C7.66666 5.78257 7.21894 5.33414 6.66666 5.33414ZM2.00001 7.33735H1C0.447717 7.33735 0 7.78578 0 8.33895V10.3422C0 10.8953 0.447717 11.3438 1 11.3438H2.00001C2.55229 11.3438 3.00001 10.8953 3.00001 10.3422V8.33895C3.00001 7.78578 2.55229 7.33735 2.00001 7.33735Z", fill: "black" })), bC = (e) => /* @__PURE__ */ z.createElement("svg", { width: 16, height: 12, viewBox: "0 0 16 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.66708 2.61114C9.89181 2.61123 12.0315 3.46671 13.6438 5.00076C13.7652 5.1192 13.9593 5.1177 14.0789 4.99741L15.2395 3.82521C15.3001 3.7642 15.3338 3.68155 15.3333 3.59557C15.3328 3.50958 15.2981 3.42734 15.2368 3.36704C11.0049 -0.691683 4.32857 -0.691683 0.0966566 3.36704C0.0353544 3.4273 0.00057226 3.50951 6.99895e-06 3.5955C-0.000558291 3.68148 0.0331399 3.76415 0.0936447 3.82521L1.25459 4.99741C1.3741 5.11788 1.56831 5.11938 1.68965 5.00076C3.30222 3.46661 5.44212 2.61113 7.66708 2.61114ZM7.66737 6.42478C8.88971 6.42471 10.0684 6.87939 10.9745 7.70048C11.0971 7.81701 11.2901 7.81448 11.4096 7.69478L12.5688 6.52258C12.6299 6.46109 12.6638 6.37768 12.6629 6.29101C12.662 6.20433 12.6264 6.12163 12.5642 6.0614C9.805 3.49288 5.53208 3.49288 2.77292 6.0614C2.71059 6.12163 2.67503 6.20437 2.67422 6.29107C2.6734 6.37778 2.70739 6.46118 2.76857 6.52258L3.92751 7.69478C4.04697 7.81448 4.24002 7.81701 4.36257 7.70048C5.26804 6.87993 6.44583 6.42529 7.66737 6.42478ZM9.98916 8.99076C9.99093 9.07768 9.95679 9.16148 9.89479 9.22237L7.88949 11.2476C7.83071 11.3071 7.75057 11.3406 7.66694 11.3406C7.58332 11.3406 7.50318 11.3071 7.44439 11.2476L5.43877 9.22237C5.37681 9.16143 5.34272 9.07761 5.34456 8.99069C5.3464 8.90377 5.38399 8.82146 5.44847 8.7632C6.72913 7.67919 8.60476 7.67919 9.88542 8.7632C9.94985 8.82151 9.98738 8.90384 9.98916 8.99076Z", fill: "black" })), Sl = {
  fintech: {
    "--sendbird-light-primary-300": "#30308f",
    "--sendbird-light-background-50-0": "#e7f1ff",
    "--sendbird-light-background-50": "#FFFFFF",
    "background-header-color": "#FFFFFF",
    "input-container-color": "#FFFFFF",
    "input-message-background-color": "#EEEEEE",
    "icon-color": "#30308F",
    //TODO: Could not find the way to change the icon color
    "sendbird-conversation__messages-background-color": "#FFFFFF"
  },
  ecommerce: {
    "--sendbird-light-primary-300": "#508537",
    "--sendbird-light-background-50-0": "#FFFFFF",
    "--sendbird-light-background-50": "#FFFFFF",
    "background-header-color": "#FFFFFF",
    "input-container-color": "#FFFFFF",
    "input-message-background-color": "#EEEEEE",
    "icon-color": "#508537",
    "sendbird-conversation__messages-background-color": "#F7F7F7"
  },
  healthcare: {
    "--sendbird-light-primary-300": "#3C7EFF",
    "--sendbird-light-background-50-0": "#FFFFFF",
    "--sendbird-light-background-50": "#C8D9FA",
    "background-header-color": "#C8D9FA",
    "input-container-color": "#FFFFFF",
    "input-message-background-color": "rgba(255, 255, 255, 0.38)",
    "icon-color": "#000000",
    "sendbird-conversation__messages-background-color": "#C8D9FA"
  }
}, YC = A.div`
  ${({ botCategory: e }) => e && aa`
      background: ${Sl[e]["background-header-color"]};
    `}
  border-top-left-radius: 15px;
  border-top-right-radius: 15px;
`, QC = A.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-style: normal;
  border: none;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
  padding: 0 12px 12px;
`, JC = A.div`
  display: flex;
  gap: 8px;
  align-items: center;
`, vC = A.div`
  font-weight: 700;
  font-size: 16px;
  line-height: 20px;
  letter-spacing: -0.2px;
  color: rgba(0, 0, 0, 0.88);
  max-width: 200px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
`, zC = A.div`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 24px;
  height: 24px;
  cursor: pointer;
  margin-right: 4px;
`, xC = A.div`
  display: flex;
  height: fit-content;
  width: fit-content;
  align-items: center;
  gap: 6px;
`, GC = A.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px 12px;
`;
function yC(e) {
  const { channel: n, createGroupChannel: t, botUser: l } = e, { customRefreshComponent: a } = jn(), { botCategory: d } = jn(), { setFirstMessage: r } = UU(), i = MC();
  function c() {
    var V;
    r(null), t(), i(), ((V = a == null ? void 0 : a.onClick) == null ? void 0 : V.call(a)) ?? window.location.reload();
  }
  return /* @__PURE__ */ Y.jsxs(YC, { botCategory: d, children: [
    /* @__PURE__ */ Y.jsxs(GC, { children: [
      /* @__PURE__ */ Y.jsx("div", { style: { fontSize: 16, marginLeft: 8 }, children: "9:41" }),
      /* @__PURE__ */ Y.jsxs("div", { style: { display: "flex" }, children: [
        /* @__PURE__ */ Y.jsx(kC, {}),
        /* @__PURE__ */ Y.jsx(bC, { style: { marginLeft: 7 } }),
        /* @__PURE__ */ Y.jsx(SC, { style: { marginLeft: 7 } })
      ] })
    ] }),
    /* @__PURE__ */ Y.jsxs(QC, { children: [
      /* @__PURE__ */ Y.jsxs(JC, { children: [
        /* @__PURE__ */ Y.jsx(
          da,
          {
            src: (l == null ? void 0 : l.profileUrl) || Nh,
            alt: "channelHeaderImage",
            height: "34px",
            width: "34px"
          }
        ),
        /* @__PURE__ */ Y.jsx(vC, { children: (l == null ? void 0 : l.nickname) || n.name })
      ] }),
      /* @__PURE__ */ Y.jsx(xC, { children: /* @__PURE__ */ Y.jsx(zC, { onClick: c, children: /* @__PURE__ */ Y.jsx(
        "div",
        {
          style: {
            width: 24,
            height: 24
          },
          children: /* @__PURE__ */ Y.jsx(
            "svg",
            {
              width: "20",
              height: "18",
              viewBox: "0 0 20 18",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              children: /* @__PURE__ */ Y.jsx(
                "path",
                {
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M15.3026 2.41113L15.5134 2.61281L18 4.92515L18.0001 2.00003C18.0001 1.4872 18.3861 1.06453 18.8835 1.00676L19.0001 1.00003C19.5129 1.00003 19.9356 1.38607 19.9934 1.88341L20.0001 2.00003V8.00003C20.0001 8.51287 19.6141 8.93554 19.1167 8.99331L19.0001 9.00003H13.0001C12.4478 9.00003 12.0001 8.55232 12.0001 8.00003C12.0001 7.4872 12.3861 7.06453 12.8835 7.00676L13.0001 7.00003L17.2946 7.00003L14.1295 4.05645C11.8929 1.84645 8.44149 1.36302 5.66851 2.87286C2.90115 4.37964 1.47901 7.50688 2.17556 10.5437C2.87284 13.5837 5.52644 15.8054 8.68662 15.9879C11.8477 16.1705 14.7472 14.2685 15.7992 11.3281C15.9852 10.8081 16.5576 10.5374 17.0776 10.7234C17.5976 10.9095 17.8683 11.4818 17.6823 12.0018C16.3302 15.7809 12.6148 18.2182 8.57128 17.9846C4.52685 17.751 1.12311 14.9013 0.226178 10.9908C-0.671496 7.07716 1.15961 3.05063 4.71213 1.11635C8.17252 -0.767774 12.4557 -0.225629 15.3026 2.41113Z",
                  fill: Sl[d]["--sendbird-light-primary-300"]
                }
              )
            }
          )
        }
      ) }) })
    ] })
  ] });
}
var NU = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(e) {
    return this.listeners.add(e), this.onSubscribe(), () => {
      this.listeners.delete(e), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, xc = typeof window > "u" || "Deno" in window;
function Pa() {
}
function BC(e, n) {
  return typeof e == "function" ? e(n) : e;
}
function vF(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function aQ(e, n) {
  return Math.max(e + (n || 0) - Date.now(), 0);
}
function m2(e, n) {
  const {
    type: t = "all",
    exact: l,
    fetchStatus: a,
    predicate: d,
    queryKey: r,
    stale: i
  } = e;
  if (r) {
    if (l) {
      if (n.queryHash !== c1(r, n.options))
        return !1;
    } else if (!xo(n.queryKey, r))
      return !1;
  }
  if (t !== "all") {
    const c = n.isActive();
    if (t === "active" && !c || t === "inactive" && c)
      return !1;
  }
  return !(typeof i == "boolean" && n.isStale() !== i || a && a !== n.state.fetchStatus || d && !d(n));
}
function u2(e, n) {
  const { exact: t, status: l, predicate: a, mutationKey: d } = e;
  if (d) {
    if (!n.options.mutationKey)
      return !1;
    if (t) {
      if (zo(n.options.mutationKey) !== zo(d))
        return !1;
    } else if (!xo(n.options.mutationKey, d))
      return !1;
  }
  return !(l && n.state.status !== l || a && !a(n));
}
function c1(e, n) {
  return ((n == null ? void 0 : n.queryKeyHashFn) || zo)(e);
}
function zo(e) {
  return JSON.stringify(
    e,
    (n, t) => xF(t) ? Object.keys(t).sort().reduce((l, a) => (l[a] = t[a], l), {}) : t
  );
}
function xo(e, n) {
  return e === n ? !0 : typeof e != typeof n ? !1 : e && n && typeof e == "object" && typeof n == "object" ? !Object.keys(n).some((t) => !xo(e[t], n[t])) : !1;
}
function dQ(e, n) {
  if (e === n)
    return e;
  const t = p2(e) && p2(n);
  if (t || xF(e) && xF(n)) {
    const l = t ? e : Object.keys(e), a = l.length, d = t ? n : Object.keys(n), r = d.length, i = t ? [] : {};
    let c = 0;
    for (let V = 0; V < r; V++) {
      const s = t ? V : d[V];
      !t && e[s] === void 0 && n[s] === void 0 && l.includes(s) ? (i[s] = void 0, c++) : (i[s] = dQ(e[s], n[s]), i[s] === e[s] && e[s] !== void 0 && c++);
    }
    return a === r && c === a ? e : i;
  }
  return n;
}
function zF(e, n) {
  if (!n || Object.keys(e).length !== Object.keys(n).length)
    return !1;
  for (const t in e)
    if (e[t] !== n[t])
      return !1;
  return !0;
}
function p2(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function xF(e) {
  if (!M2(e))
    return !1;
  const n = e.constructor;
  if (n === void 0)
    return !0;
  const t = n.prototype;
  return !(!M2(t) || !t.hasOwnProperty("isPrototypeOf"));
}
function M2(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function DC(e) {
  return new Promise((n) => {
    setTimeout(n, e);
  });
}
function GF(e, n, t) {
  return typeof t.structuralSharing == "function" ? t.structuralSharing(e, n) : t.structuralSharing !== !1 ? dQ(e, n) : n;
}
function XC(e, n, t = 0) {
  const l = [...e, n];
  return t && l.length > t ? l.slice(1) : l;
}
function OC(e, n, t = 0) {
  const l = [n, ...e];
  return t && l.length > t ? l.slice(0, -1) : l;
}
var Go = Symbol(), VV, ei, rc, wS, jC = (wS = class extends NU {
  constructor() {
    super();
    Yt(this, VV, void 0);
    Yt(this, ei, void 0);
    Yt(this, rc, void 0);
    Tt(this, rc, (n) => {
      if (!xc && window.addEventListener) {
        const t = () => n();
        return window.addEventListener("visibilitychange", t, !1), () => {
          window.removeEventListener("visibilitychange", t);
        };
      }
    });
  }
  onSubscribe() {
    _(this, ei) || this.setEventListener(_(this, rc));
  }
  onUnsubscribe() {
    var n;
    this.hasListeners() || ((n = _(this, ei)) == null || n.call(this), Tt(this, ei, void 0));
  }
  setEventListener(n) {
    var t;
    Tt(this, rc, n), (t = _(this, ei)) == null || t.call(this), Tt(this, ei, n((l) => {
      typeof l == "boolean" ? this.setFocused(l) : this.onFocus();
    }));
  }
  setFocused(n) {
    _(this, VV) !== n && (Tt(this, VV, n), this.onFocus());
  }
  onFocus() {
    this.listeners.forEach((n) => {
      n();
    });
  }
  isFocused() {
    var n;
    return typeof _(this, VV) == "boolean" ? _(this, VV) : ((n = globalThis.document) == null ? void 0 : n.visibilityState) !== "hidden";
  }
}, VV = new WeakMap(), ei = new WeakMap(), rc = new WeakMap(), wS), bR = new jC(), ic, ti, Vc, gS, HC = (gS = class extends NU {
  constructor() {
    super();
    Yt(this, ic, !0);
    Yt(this, ti, void 0);
    Yt(this, Vc, void 0);
    Tt(this, Vc, (n) => {
      if (!xc && window.addEventListener) {
        const t = () => n(!0), l = () => n(!1);
        return window.addEventListener("online", t, !1), window.addEventListener("offline", l, !1), () => {
          window.removeEventListener("online", t), window.removeEventListener("offline", l);
        };
      }
    });
  }
  onSubscribe() {
    _(this, ti) || this.setEventListener(_(this, Vc));
  }
  onUnsubscribe() {
    var n;
    this.hasListeners() || ((n = _(this, ti)) == null || n.call(this), Tt(this, ti, void 0));
  }
  setEventListener(n) {
    var t;
    Tt(this, Vc, n), (t = _(this, ti)) == null || t.call(this), Tt(this, ti, n(this.setOnline.bind(this)));
  }
  setOnline(n) {
    _(this, ic) !== n && (Tt(this, ic, n), this.listeners.forEach((l) => {
      l(n);
    }));
  }
  isOnline() {
    return _(this, ic);
  }
}, ic = new WeakMap(), ti = new WeakMap(), Vc = new WeakMap(), gS), YR = new HC();
function fC(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function Rh(e) {
  return (e ?? "online") === "online" ? YR.isOnline() : !0;
}
var rQ = class {
  constructor(e) {
    this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent;
  }
};
function LZ(e) {
  return e instanceof rQ;
}
function iQ(e) {
  let n = !1, t = 0, l = !1, a, d, r;
  const i = new Promise((Z, W) => {
    d = Z, r = W;
  }), c = (Z) => {
    var W;
    l || (N(new rQ(Z)), (W = e.abort) == null || W.call(e));
  }, V = () => {
    n = !0;
  }, s = () => {
    n = !1;
  }, o = () => !bR.isFocused() || e.networkMode !== "always" && !YR.isOnline(), U = (Z) => {
    var W;
    l || (l = !0, (W = e.onSuccess) == null || W.call(e, Z), a == null || a(), d(Z));
  }, N = (Z) => {
    var W;
    l || (l = !0, (W = e.onError) == null || W.call(e, Z), a == null || a(), r(Z));
  }, R = () => new Promise((Z) => {
    var W;
    a = (F) => {
      const m = l || !o();
      return m && Z(F), m;
    }, (W = e.onPause) == null || W.call(e);
  }).then(() => {
    var Z;
    a = void 0, l || (Z = e.onContinue) == null || Z.call(e);
  }), h = () => {
    if (l)
      return;
    let Z;
    try {
      Z = e.fn();
    } catch (W) {
      Z = Promise.reject(W);
    }
    Promise.resolve(Z).then(U).catch((W) => {
      var b;
      if (l)
        return;
      const F = e.retry ?? (xc ? 0 : 3), m = e.retryDelay ?? fC, E = typeof m == "function" ? m(t, W) : m, u = F === !0 || typeof F == "number" && t < F || typeof F == "function" && F(t, W);
      if (n || !u) {
        N(W);
        return;
      }
      t++, (b = e.onFail) == null || b.call(e, t, W), DC(E).then(() => {
        if (o())
          return R();
      }).then(() => {
        n ? N(W) : h();
      });
    });
  };
  return Rh(e.networkMode) ? h() : R().then(h), {
    promise: i,
    cancel: c,
    continue: () => (a == null ? void 0 : a()) ? i : Promise.resolve(),
    cancelRetry: V,
    continueRetry: s
  };
}
function wC() {
  let e = [], n = 0, t = (U) => {
    U();
  }, l = (U) => {
    U();
  }, a = (U) => setTimeout(U, 0);
  const d = (U) => {
    a = U;
  }, r = (U) => {
    let N;
    n++;
    try {
      N = U();
    } finally {
      n--, n || V();
    }
    return N;
  }, i = (U) => {
    n ? e.push(U) : a(() => {
      t(U);
    });
  }, c = (U) => (...N) => {
    i(() => {
      U(...N);
    });
  }, V = () => {
    const U = e;
    e = [], U.length && a(() => {
      l(() => {
        U.forEach((N) => {
          t(N);
        });
      });
    });
  };
  return {
    batch: r,
    batchCalls: c,
    schedule: i,
    setNotifyFunction: (U) => {
      t = U;
    },
    setBatchNotifyFunction: (U) => {
      l = U;
    },
    setScheduler: d
  };
}
var Xl = wC(), cV, IS, VQ = (IS = class {
  constructor() {
    Yt(this, cV, void 0);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), vF(this.gcTime) && Tt(this, cV, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(e) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      e ?? (xc ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    _(this, cV) && (clearTimeout(_(this, cV)), Tt(this, cV, void 0));
  }
}, cV = new WeakMap(), IS), cc, sc, Ca, ni, Ka, ul, fo, sV, oc, DN, hd, or, LS, gC = (LS = class extends VQ {
  constructor(n) {
    super();
    Yt(this, oc);
    Yt(this, hd);
    Yt(this, cc, void 0);
    Yt(this, sc, void 0);
    Yt(this, Ca, void 0);
    Yt(this, ni, void 0);
    Yt(this, Ka, void 0);
    Yt(this, ul, void 0);
    Yt(this, fo, void 0);
    Yt(this, sV, void 0);
    Tt(this, sV, !1), Tt(this, fo, n.defaultOptions), Un(this, oc, DN).call(this, n.options), Tt(this, ul, []), Tt(this, Ca, n.cache), this.queryKey = n.queryKey, this.queryHash = n.queryHash, Tt(this, cc, n.state || IC(this.options)), this.state = _(this, cc), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  optionalRemove() {
    !_(this, ul).length && this.state.fetchStatus === "idle" && _(this, Ca).remove(this);
  }
  setData(n, t) {
    const l = GF(this.state.data, n, this.options);
    return Un(this, hd, or).call(this, {
      data: l,
      type: "success",
      dataUpdatedAt: t == null ? void 0 : t.updatedAt,
      manual: t == null ? void 0 : t.manual
    }), l;
  }
  setState(n, t) {
    Un(this, hd, or).call(this, { type: "setState", state: n, setStateOptions: t });
  }
  cancel(n) {
    var l;
    const t = _(this, ni);
    return (l = _(this, Ka)) == null || l.cancel(n), t ? t.then(Pa).catch(Pa) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(_(this, cc));
  }
  isActive() {
    return _(this, ul).some(
      (n) => n.options.enabled !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || this.state.data === void 0 || _(this, ul).some((n) => n.getCurrentResult().isStale);
  }
  isStaleByTime(n = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !aQ(this.state.dataUpdatedAt, n);
  }
  onFocus() {
    var t;
    const n = _(this, ul).find((l) => l.shouldFetchOnWindowFocus());
    n == null || n.refetch({ cancelRefetch: !1 }), (t = _(this, Ka)) == null || t.continue();
  }
  onOnline() {
    var t;
    const n = _(this, ul).find((l) => l.shouldFetchOnReconnect());
    n == null || n.refetch({ cancelRefetch: !1 }), (t = _(this, Ka)) == null || t.continue();
  }
  addObserver(n) {
    _(this, ul).includes(n) || (_(this, ul).push(n), this.clearGcTimeout(), _(this, Ca).notify({ type: "observerAdded", query: this, observer: n }));
  }
  removeObserver(n) {
    _(this, ul).includes(n) && (Tt(this, ul, _(this, ul).filter((t) => t !== n)), _(this, ul).length || (_(this, Ka) && (_(this, sV) ? _(this, Ka).cancel({ revert: !0 }) : _(this, Ka).cancelRetry()), this.scheduleGc()), _(this, Ca).notify({ type: "observerRemoved", query: this, observer: n }));
  }
  getObserversCount() {
    return _(this, ul).length;
  }
  invalidate() {
    this.state.isInvalidated || Un(this, hd, or).call(this, { type: "invalidate" });
  }
  fetch(n, t) {
    var V, s, o, U;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (t != null && t.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (_(this, ni))
        return (V = _(this, Ka)) == null || V.continueRetry(), _(this, ni);
    }
    if (n && Un(this, oc, DN).call(this, n), !this.options.queryFn) {
      const N = _(this, ul).find((R) => R.options.queryFn);
      N && Un(this, oc, DN).call(this, N.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const l = new AbortController(), a = {
      queryKey: this.queryKey,
      meta: this.meta
    }, d = (N) => {
      Object.defineProperty(N, "signal", {
        enumerable: !0,
        get: () => (Tt(this, sV, !0), l.signal)
      });
    };
    d(a);
    const r = () => (process.env.NODE_ENV !== "production" && this.options.queryFn === Go && console.error(
      `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`
    ), !this.options.queryFn || this.options.queryFn === Go ? Promise.reject(
      new Error(`Missing queryFn: '${this.options.queryHash}'`)
    ) : (Tt(this, sV, !1), this.options.persister ? this.options.persister(
      this.options.queryFn,
      a,
      this
    ) : this.options.queryFn(
      a
    ))), i = {
      fetchOptions: t,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: r
    };
    d(i), (s = this.options.behavior) == null || s.onFetch(
      i,
      this
    ), Tt(this, sc, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((o = i.fetchOptions) == null ? void 0 : o.meta)) && Un(this, hd, or).call(this, { type: "fetch", meta: (U = i.fetchOptions) == null ? void 0 : U.meta });
    const c = (N) => {
      var R, h, Z, W;
      LZ(N) && N.silent || Un(this, hd, or).call(this, {
        type: "error",
        error: N
      }), LZ(N) || ((h = (R = _(this, Ca).config).onError) == null || h.call(
        R,
        N,
        this
      ), (W = (Z = _(this, Ca).config).onSettled) == null || W.call(
        Z,
        this.state.data,
        N,
        this
      )), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
    };
    return Tt(this, Ka, iQ({
      fn: i.fetchFn,
      abort: l.abort.bind(l),
      onSuccess: (N) => {
        var R, h, Z, W;
        if (N === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), c(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        this.setData(N), (h = (R = _(this, Ca).config).onSuccess) == null || h.call(R, N, this), (W = (Z = _(this, Ca).config).onSettled) == null || W.call(
          Z,
          N,
          this.state.error,
          this
        ), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
      },
      onError: c,
      onFail: (N, R) => {
        Un(this, hd, or).call(this, { type: "failed", failureCount: N, error: R });
      },
      onPause: () => {
        Un(this, hd, or).call(this, { type: "pause" });
      },
      onContinue: () => {
        Un(this, hd, or).call(this, { type: "continue" });
      },
      retry: i.options.retry,
      retryDelay: i.options.retryDelay,
      networkMode: i.options.networkMode
    })), Tt(this, ni, _(this, Ka).promise), _(this, ni);
  }
}, cc = new WeakMap(), sc = new WeakMap(), Ca = new WeakMap(), ni = new WeakMap(), Ka = new WeakMap(), ul = new WeakMap(), fo = new WeakMap(), sV = new WeakMap(), oc = new WeakSet(), DN = function(n) {
  this.options = { ..._(this, fo), ...n }, this.updateGcTime(this.options.gcTime);
}, hd = new WeakSet(), or = function(n) {
  const t = (l) => {
    switch (n.type) {
      case "failed":
        return {
          ...l,
          fetchFailureCount: n.failureCount,
          fetchFailureReason: n.error
        };
      case "pause":
        return {
          ...l,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...l,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...l,
          fetchFailureCount: 0,
          fetchFailureReason: null,
          fetchMeta: n.meta ?? null,
          fetchStatus: Rh(this.options.networkMode) ? "fetching" : "paused",
          ...l.data === void 0 && {
            error: null,
            status: "pending"
          }
        };
      case "success":
        return {
          ...l,
          data: n.data,
          dataUpdateCount: l.dataUpdateCount + 1,
          dataUpdatedAt: n.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!n.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const a = n.error;
        return LZ(a) && a.revert && _(this, sc) ? { ..._(this, sc), fetchStatus: "idle" } : {
          ...l,
          error: a,
          errorUpdateCount: l.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: l.fetchFailureCount + 1,
          fetchFailureReason: a,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...l,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...l,
          ...n.state
        };
    }
  };
  this.state = t(this.state), Xl.batch(() => {
    _(this, ul).forEach((l) => {
      l.onQueryUpdate();
    }), _(this, Ca).notify({ query: this, type: "updated", action: n });
  });
}, LS);
function IC(e) {
  const n = typeof e.initialData == "function" ? e.initialData() : e.initialData, t = n !== void 0, l = t ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: n,
    dataUpdateCount: 0,
    dataUpdatedAt: t ? l ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: t ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var zd, CS, LC = (CS = class extends NU {
  constructor(n = {}) {
    super();
    Yt(this, zd, void 0);
    this.config = n, Tt(this, zd, /* @__PURE__ */ new Map());
  }
  build(n, t, l) {
    const a = t.queryKey, d = t.queryHash ?? c1(a, t);
    let r = this.get(d);
    return r || (r = new gC({
      cache: this,
      queryKey: a,
      queryHash: d,
      options: n.defaultQueryOptions(t),
      state: l,
      defaultOptions: n.getQueryDefaults(a)
    }), this.add(r)), r;
  }
  add(n) {
    _(this, zd).has(n.queryHash) || (_(this, zd).set(n.queryHash, n), this.notify({
      type: "added",
      query: n
    }));
  }
  remove(n) {
    const t = _(this, zd).get(n.queryHash);
    t && (n.destroy(), t === n && _(this, zd).delete(n.queryHash), this.notify({ type: "removed", query: n }));
  }
  clear() {
    Xl.batch(() => {
      this.getAll().forEach((n) => {
        this.remove(n);
      });
    });
  }
  get(n) {
    return _(this, zd).get(n);
  }
  getAll() {
    return [..._(this, zd).values()];
  }
  find(n) {
    const t = { exact: !0, ...n };
    return this.getAll().find(
      (l) => m2(t, l)
    );
  }
  findAll(n = {}) {
    const t = this.getAll();
    return Object.keys(n).length > 0 ? t.filter((l) => m2(n, l)) : t;
  }
  notify(n) {
    Xl.batch(() => {
      this.listeners.forEach((t) => {
        t(n);
      });
    });
  }
  onFocus() {
    Xl.batch(() => {
      this.getAll().forEach((n) => {
        n.onFocus();
      });
    });
  }
  onOnline() {
    Xl.batch(() => {
      this.getAll().forEach((n) => {
        n.onOnline();
      });
    });
  }
}, zd = new WeakMap(), CS), xd, wo, Ya, Uc, Gd, Ir, KS, CC = (KS = class extends VQ {
  constructor(n) {
    super();
    Yt(this, Gd);
    Yt(this, xd, void 0);
    Yt(this, wo, void 0);
    Yt(this, Ya, void 0);
    Yt(this, Uc, void 0);
    this.mutationId = n.mutationId, Tt(this, wo, n.defaultOptions), Tt(this, Ya, n.mutationCache), Tt(this, xd, []), this.state = n.state || KC(), this.setOptions(n.options), this.scheduleGc();
  }
  setOptions(n) {
    this.options = { ..._(this, wo), ...n }, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(n) {
    _(this, xd).includes(n) || (_(this, xd).push(n), this.clearGcTimeout(), _(this, Ya).notify({
      type: "observerAdded",
      mutation: this,
      observer: n
    }));
  }
  removeObserver(n) {
    Tt(this, xd, _(this, xd).filter((t) => t !== n)), this.scheduleGc(), _(this, Ya).notify({
      type: "observerRemoved",
      mutation: this,
      observer: n
    });
  }
  optionalRemove() {
    _(this, xd).length || (this.state.status === "pending" ? this.scheduleGc() : _(this, Ya).remove(this));
  }
  continue() {
    var n;
    return ((n = _(this, Uc)) == null ? void 0 : n.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(n) {
    var a, d, r, i, c, V, s, o, U, N, R, h, Z, W, F, m, E, u, b, k;
    const t = () => (Tt(this, Uc, iQ({
      fn: () => this.options.mutationFn ? this.options.mutationFn(n) : Promise.reject(new Error("No mutationFn found")),
      onFail: (Q, S) => {
        Un(this, Gd, Ir).call(this, { type: "failed", failureCount: Q, error: S });
      },
      onPause: () => {
        Un(this, Gd, Ir).call(this, { type: "pause" });
      },
      onContinue: () => {
        Un(this, Gd, Ir).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode
    })), _(this, Uc).promise), l = this.state.status === "pending";
    try {
      if (!l) {
        Un(this, Gd, Ir).call(this, { type: "pending", variables: n }), await ((d = (a = _(this, Ya).config).onMutate) == null ? void 0 : d.call(
          a,
          n,
          this
        ));
        const S = await ((i = (r = this.options).onMutate) == null ? void 0 : i.call(r, n));
        S !== this.state.context && Un(this, Gd, Ir).call(this, {
          type: "pending",
          context: S,
          variables: n
        });
      }
      const Q = await t();
      return await ((V = (c = _(this, Ya).config).onSuccess) == null ? void 0 : V.call(
        c,
        Q,
        n,
        this.state.context,
        this
      )), await ((o = (s = this.options).onSuccess) == null ? void 0 : o.call(s, Q, n, this.state.context)), await ((N = (U = _(this, Ya).config).onSettled) == null ? void 0 : N.call(
        U,
        Q,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((h = (R = this.options).onSettled) == null ? void 0 : h.call(R, Q, null, n, this.state.context)), Un(this, Gd, Ir).call(this, { type: "success", data: Q }), Q;
    } catch (Q) {
      try {
        throw await ((W = (Z = _(this, Ya).config).onError) == null ? void 0 : W.call(
          Z,
          Q,
          n,
          this.state.context,
          this
        )), await ((m = (F = this.options).onError) == null ? void 0 : m.call(
          F,
          Q,
          n,
          this.state.context
        )), await ((u = (E = _(this, Ya).config).onSettled) == null ? void 0 : u.call(
          E,
          void 0,
          Q,
          this.state.variables,
          this.state.context,
          this
        )), await ((k = (b = this.options).onSettled) == null ? void 0 : k.call(
          b,
          void 0,
          Q,
          n,
          this.state.context
        )), Q;
      } finally {
        Un(this, Gd, Ir).call(this, { type: "error", error: Q });
      }
    }
  }
}, xd = new WeakMap(), wo = new WeakMap(), Ya = new WeakMap(), Uc = new WeakMap(), Gd = new WeakSet(), Ir = function(n) {
  const t = (l) => {
    switch (n.type) {
      case "failed":
        return {
          ...l,
          failureCount: n.failureCount,
          failureReason: n.error
        };
      case "pause":
        return {
          ...l,
          isPaused: !0
        };
      case "continue":
        return {
          ...l,
          isPaused: !1
        };
      case "pending":
        return {
          ...l,
          context: n.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: !Rh(this.options.networkMode),
          status: "pending",
          variables: n.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...l,
          data: n.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...l,
          data: void 0,
          error: n.error,
          failureCount: l.failureCount + 1,
          failureReason: n.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = t(this.state), Xl.batch(() => {
    _(this, xd).forEach((l) => {
      l.onMutationUpdate(n);
    }), _(this, Ya).notify({
      mutation: this,
      type: "updated",
      action: n
    });
  });
}, KS);
function KC() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var _a, go, oV, _S, _C = (_S = class extends NU {
  constructor(n = {}) {
    super();
    Yt(this, _a, void 0);
    Yt(this, go, void 0);
    Yt(this, oV, void 0);
    this.config = n, Tt(this, _a, []), Tt(this, go, 0);
  }
  build(n, t, l) {
    const a = new CC({
      mutationCache: this,
      mutationId: ++vU(this, go)._,
      options: n.defaultMutationOptions(t),
      state: l
    });
    return this.add(a), a;
  }
  add(n) {
    _(this, _a).push(n), this.notify({ type: "added", mutation: n });
  }
  remove(n) {
    Tt(this, _a, _(this, _a).filter((t) => t !== n)), this.notify({ type: "removed", mutation: n });
  }
  clear() {
    Xl.batch(() => {
      _(this, _a).forEach((n) => {
        this.remove(n);
      });
    });
  }
  getAll() {
    return _(this, _a);
  }
  find(n) {
    const t = { exact: !0, ...n };
    return _(this, _a).find(
      (l) => u2(t, l)
    );
  }
  findAll(n = {}) {
    return _(this, _a).filter(
      (t) => u2(n, t)
    );
  }
  notify(n) {
    Xl.batch(() => {
      this.listeners.forEach((t) => {
        t(n);
      });
    });
  }
  resumePausedMutations() {
    return Tt(this, oV, (_(this, oV) ?? Promise.resolve()).then(() => {
      const n = _(this, _a).filter((t) => t.state.isPaused);
      return Xl.batch(
        () => n.reduce(
          (t, l) => t.then(() => l.continue().catch(Pa)),
          Promise.resolve()
        )
      );
    }).then(() => {
      Tt(this, oV, void 0);
    })), _(this, oV);
  }
}, _a = new WeakMap(), go = new WeakMap(), oV = new WeakMap(), _S);
function PC(e) {
  return {
    onFetch: (n, t) => {
      const l = async () => {
        var R, h, Z, W, F;
        const a = n.options, d = (Z = (h = (R = n.fetchOptions) == null ? void 0 : R.meta) == null ? void 0 : h.fetchMore) == null ? void 0 : Z.direction, r = ((W = n.state.data) == null ? void 0 : W.pages) || [], i = ((F = n.state.data) == null ? void 0 : F.pageParams) || [], c = { pages: [], pageParams: [] };
        let V = !1;
        const s = (m) => {
          Object.defineProperty(m, "signal", {
            enumerable: !0,
            get: () => (n.signal.aborted ? V = !0 : n.signal.addEventListener("abort", () => {
              V = !0;
            }), n.signal)
          });
        }, o = n.options.queryFn && n.options.queryFn !== Go ? n.options.queryFn : () => (process.env.NODE_ENV !== "production" && n.options.queryFn === Go && console.error(
          `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${n.options.queryHash}'`
        ), Promise.reject(
          new Error(`Missing queryFn: '${n.options.queryHash}'`)
        )), U = async (m, E, u) => {
          if (V)
            return Promise.reject();
          if (E == null && m.pages.length)
            return Promise.resolve(m);
          const b = {
            queryKey: n.queryKey,
            pageParam: E,
            direction: u ? "backward" : "forward",
            meta: n.options.meta
          };
          s(b);
          const k = await o(
            b
          ), { maxPages: Q } = n.options, S = u ? OC : XC;
          return {
            pages: S(m.pages, k, Q),
            pageParams: S(m.pageParams, E, Q)
          };
        };
        let N;
        if (d && r.length) {
          const m = d === "backward", E = m ? AC : E2, u = {
            pages: r,
            pageParams: i
          }, b = E(a, u);
          N = await U(u, b, m);
        } else {
          N = await U(
            c,
            i[0] ?? a.initialPageParam
          );
          const m = e ?? r.length;
          for (let E = 1; E < m; E++) {
            const u = E2(a, N);
            N = await U(N, u);
          }
        }
        return N;
      };
      n.options.persister ? n.fetchFn = () => {
        var a, d;
        return (d = (a = n.options).persister) == null ? void 0 : d.call(
          a,
          l,
          {
            queryKey: n.queryKey,
            meta: n.options.meta,
            signal: n.signal
          },
          t
        );
      } : n.fetchFn = l;
    }
  };
}
function E2(e, { pages: n, pageParams: t }) {
  const l = n.length - 1;
  return e.getNextPageParam(
    n[l],
    n,
    t[l],
    t
  );
}
function AC(e, { pages: n, pageParams: t }) {
  var l;
  return (l = e.getPreviousPageParam) == null ? void 0 : l.call(
    e,
    n[0],
    n,
    t[0],
    t
  );
}
var Tl, li, ai, Nc, Rc, di, hc, Zc, PS, qC = (PS = class {
  constructor(e = {}) {
    Yt(this, Tl, void 0);
    Yt(this, li, void 0);
    Yt(this, ai, void 0);
    Yt(this, Nc, void 0);
    Yt(this, Rc, void 0);
    Yt(this, di, void 0);
    Yt(this, hc, void 0);
    Yt(this, Zc, void 0);
    Tt(this, Tl, e.queryCache || new LC()), Tt(this, li, e.mutationCache || new _C()), Tt(this, ai, e.defaultOptions || {}), Tt(this, Nc, /* @__PURE__ */ new Map()), Tt(this, Rc, /* @__PURE__ */ new Map()), Tt(this, di, 0);
  }
  mount() {
    vU(this, di)._++, _(this, di) === 1 && (Tt(this, hc, bR.subscribe(() => {
      bR.isFocused() && (this.resumePausedMutations(), _(this, Tl).onFocus());
    })), Tt(this, Zc, YR.subscribe((e) => {
      e && (this.resumePausedMutations(), _(this, Tl).onOnline());
    })));
  }
  unmount() {
    var e, n;
    vU(this, di)._--, _(this, di) === 0 && ((e = _(this, hc)) == null || e.call(this), Tt(this, hc, void 0), (n = _(this, Zc)) == null || n.call(this), Tt(this, Zc, void 0));
  }
  isFetching(e) {
    return _(this, Tl).findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return _(this, li).findAll({ ...e, status: "pending" }).length;
  }
  getQueryData(e) {
    var t;
    const n = this.defaultQueryOptions({ queryKey: e });
    return (t = _(this, Tl).get(n.queryHash)) == null ? void 0 : t.state.data;
  }
  ensureQueryData(e) {
    const n = this.getQueryData(e.queryKey);
    return n !== void 0 ? Promise.resolve(n) : this.fetchQuery(e);
  }
  getQueriesData(e) {
    return this.getQueryCache().findAll(e).map(({ queryKey: n, state: t }) => {
      const l = t.data;
      return [n, l];
    });
  }
  setQueryData(e, n, t) {
    const l = this.defaultQueryOptions({ queryKey: e }), a = _(this, Tl).get(
      l.queryHash
    ), d = a == null ? void 0 : a.state.data, r = BC(n, d);
    if (r !== void 0)
      return _(this, Tl).build(this, l).setData(r, { ...t, manual: !0 });
  }
  setQueriesData(e, n, t) {
    return Xl.batch(
      () => this.getQueryCache().findAll(e).map(({ queryKey: l }) => [
        l,
        this.setQueryData(l, n, t)
      ])
    );
  }
  getQueryState(e) {
    var t;
    const n = this.defaultQueryOptions({ queryKey: e });
    return (t = _(this, Tl).get(n.queryHash)) == null ? void 0 : t.state;
  }
  removeQueries(e) {
    const n = _(this, Tl);
    Xl.batch(() => {
      n.findAll(e).forEach((t) => {
        n.remove(t);
      });
    });
  }
  resetQueries(e, n) {
    const t = _(this, Tl), l = {
      type: "active",
      ...e
    };
    return Xl.batch(() => (t.findAll(e).forEach((a) => {
      a.reset();
    }), this.refetchQueries(l, n)));
  }
  cancelQueries(e = {}, n = {}) {
    const t = { revert: !0, ...n }, l = Xl.batch(
      () => _(this, Tl).findAll(e).map((a) => a.cancel(t))
    );
    return Promise.all(l).then(Pa).catch(Pa);
  }
  invalidateQueries(e = {}, n = {}) {
    return Xl.batch(() => {
      if (_(this, Tl).findAll(e).forEach((l) => {
        l.invalidate();
      }), e.refetchType === "none")
        return Promise.resolve();
      const t = {
        ...e,
        type: e.refetchType ?? e.type ?? "active"
      };
      return this.refetchQueries(t, n);
    });
  }
  refetchQueries(e = {}, n) {
    const t = {
      ...n,
      cancelRefetch: (n == null ? void 0 : n.cancelRefetch) ?? !0
    }, l = Xl.batch(
      () => _(this, Tl).findAll(e).filter((a) => !a.isDisabled()).map((a) => {
        let d = a.fetch(void 0, t);
        return t.throwOnError || (d = d.catch(Pa)), a.state.fetchStatus === "paused" ? Promise.resolve() : d;
      })
    );
    return Promise.all(l).then(Pa);
  }
  fetchQuery(e) {
    const n = this.defaultQueryOptions(e);
    n.retry === void 0 && (n.retry = !1);
    const t = _(this, Tl).build(this, n);
    return t.isStaleByTime(n.staleTime) ? t.fetch(n) : Promise.resolve(t.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(Pa).catch(Pa);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = PC(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(Pa).catch(Pa);
  }
  resumePausedMutations() {
    return YR.isOnline() ? _(this, li).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return _(this, Tl);
  }
  getMutationCache() {
    return _(this, li);
  }
  getDefaultOptions() {
    return _(this, ai);
  }
  setDefaultOptions(e) {
    Tt(this, ai, e);
  }
  setQueryDefaults(e, n) {
    _(this, Nc).set(zo(e), {
      queryKey: e,
      defaultOptions: n
    });
  }
  getQueryDefaults(e) {
    const n = [..._(this, Nc).values()];
    let t = {};
    return n.forEach((l) => {
      xo(e, l.queryKey) && (t = { ...t, ...l.defaultOptions });
    }), t;
  }
  setMutationDefaults(e, n) {
    _(this, Rc).set(zo(e), {
      mutationKey: e,
      defaultOptions: n
    });
  }
  getMutationDefaults(e) {
    const n = [..._(this, Rc).values()];
    let t = {};
    return n.forEach((l) => {
      xo(e, l.mutationKey) && (t = { ...t, ...l.defaultOptions });
    }), t;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const n = {
      ..._(this, ai).queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return n.queryHash || (n.queryHash = c1(
      n.queryKey,
      n
    )), n.refetchOnReconnect === void 0 && (n.refetchOnReconnect = n.networkMode !== "always"), n.throwOnError === void 0 && (n.throwOnError = !!n.suspense), !n.networkMode && n.persister && (n.networkMode = "offlineFirst"), n.enabled !== !0 && n.queryFn === Go && (n.enabled = !1), n;
  }
  defaultMutationOptions(e) {
    return e != null && e._defaulted ? e : {
      ..._(this, ai).mutations,
      ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    _(this, Tl).clear(), _(this, li).clear();
  }
}, Tl = new WeakMap(), li = new WeakMap(), ai = new WeakMap(), Nc = new WeakMap(), Rc = new WeakMap(), di = new WeakMap(), hc = new WeakMap(), Zc = new WeakMap(), PS), sa, Hn, Io, ql, UV, Tc, yd, Lo, Fc, Wc, NV, RV, ri, mc, hV, Js, Co, yF, Ko, BF, _o, DF, Po, XF, Ao, OF, qo, jF, $o, HF, HR, cQ, AS, $C = (AS = class extends NU {
  constructor(n, t) {
    super();
    Yt(this, hV);
    Yt(this, Co);
    Yt(this, Ko);
    Yt(this, _o);
    Yt(this, Po);
    Yt(this, Ao);
    Yt(this, qo);
    Yt(this, $o);
    Yt(this, HR);
    Yt(this, sa, void 0);
    Yt(this, Hn, void 0);
    Yt(this, Io, void 0);
    Yt(this, ql, void 0);
    Yt(this, UV, void 0);
    Yt(this, Tc, void 0);
    Yt(this, yd, void 0);
    Yt(this, Lo, void 0);
    Yt(this, Fc, void 0);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    Yt(this, Wc, void 0);
    Yt(this, NV, void 0);
    Yt(this, RV, void 0);
    Yt(this, ri, void 0);
    Yt(this, mc, /* @__PURE__ */ new Set());
    this.options = t, Tt(this, sa, n), Tt(this, yd, null), this.bindMethods(), this.setOptions(t);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (_(this, Hn).addObserver(this), S2(_(this, Hn), this.options) ? Un(this, hV, Js).call(this) : this.updateResult(), Un(this, Po, XF).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return fF(
      _(this, Hn),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return fF(
      _(this, Hn),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), Un(this, Ao, OF).call(this), Un(this, qo, jF).call(this), _(this, Hn).removeObserver(this);
  }
  setOptions(n, t) {
    const l = this.options, a = _(this, Hn);
    if (this.options = _(this, sa).defaultQueryOptions(n), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean")
      throw new Error("Expected enabled to be a boolean");
    Un(this, $o, HF).call(this), zF(this.options, l) || _(this, sa).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: _(this, Hn),
      observer: this
    });
    const d = this.hasListeners();
    d && k2(
      _(this, Hn),
      a,
      this.options,
      l
    ) && Un(this, hV, Js).call(this), this.updateResult(t), d && (_(this, Hn) !== a || this.options.enabled !== l.enabled || this.options.staleTime !== l.staleTime) && Un(this, Co, yF).call(this);
    const r = Un(this, Ko, BF).call(this);
    d && (_(this, Hn) !== a || this.options.enabled !== l.enabled || r !== _(this, ri)) && Un(this, _o, DF).call(this, r);
  }
  getOptimisticResult(n) {
    const t = _(this, sa).getQueryCache().build(_(this, sa), n), l = this.createResult(t, n);
    return tK(this, l) && (Tt(this, ql, l), Tt(this, Tc, this.options), Tt(this, UV, _(this, Hn).state)), l;
  }
  getCurrentResult() {
    return _(this, ql);
  }
  trackResult(n, t) {
    const l = {};
    return Object.keys(n).forEach((a) => {
      Object.defineProperty(l, a, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackProp(a), t == null || t(a), n[a])
      });
    }), l;
  }
  trackProp(n) {
    _(this, mc).add(n);
  }
  getCurrentQuery() {
    return _(this, Hn);
  }
  refetch({ ...n } = {}) {
    return this.fetch({
      ...n
    });
  }
  fetchOptimistic(n) {
    const t = _(this, sa).defaultQueryOptions(n), l = _(this, sa).getQueryCache().build(_(this, sa), t);
    return l.isFetchingOptimistic = !0, l.fetch().then(() => this.createResult(l, t));
  }
  fetch(n) {
    return Un(this, hV, Js).call(this, {
      ...n,
      cancelRefetch: n.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), _(this, ql)));
  }
  createResult(n, t) {
    var k;
    const l = _(this, Hn), a = this.options, d = _(this, ql), r = _(this, UV), i = _(this, Tc), V = n !== l ? n.state : _(this, Io), { state: s } = n;
    let { error: o, errorUpdatedAt: U, fetchStatus: N, status: R } = s, h = !1, Z;
    if (t._optimisticResults) {
      const Q = this.hasListeners(), S = !Q && S2(n, t), v = Q && k2(n, l, t, a);
      (S || v) && (N = Rh(n.options.networkMode) ? "fetching" : "paused", s.data === void 0 && (R = "pending")), t._optimisticResults === "isRestoring" && (N = "idle");
    }
    if (t.select && s.data !== void 0)
      if (d && s.data === (r == null ? void 0 : r.data) && t.select === _(this, Lo))
        Z = _(this, Fc);
      else
        try {
          Tt(this, Lo, t.select), Z = t.select(s.data), Z = GF(d == null ? void 0 : d.data, Z, t), Tt(this, Fc, Z), Tt(this, yd, null);
        } catch (Q) {
          Tt(this, yd, Q);
        }
    else
      Z = s.data;
    if (t.placeholderData !== void 0 && Z === void 0 && R === "pending") {
      let Q;
      if (d != null && d.isPlaceholderData && t.placeholderData === (i == null ? void 0 : i.placeholderData))
        Q = d.data;
      else if (Q = typeof t.placeholderData == "function" ? t.placeholderData(
        (k = _(this, Wc)) == null ? void 0 : k.state.data,
        _(this, Wc)
      ) : t.placeholderData, t.select && Q !== void 0)
        try {
          Q = t.select(Q), Tt(this, yd, null);
        } catch (S) {
          Tt(this, yd, S);
        }
      Q !== void 0 && (R = "success", Z = GF(
        d == null ? void 0 : d.data,
        Q,
        t
      ), h = !0);
    }
    _(this, yd) && (o = _(this, yd), Z = _(this, Fc), U = Date.now(), R = "error");
    const W = N === "fetching", F = R === "pending", m = R === "error", E = F && W, u = s.data !== void 0;
    return {
      status: R,
      fetchStatus: N,
      isPending: F,
      isSuccess: R === "success",
      isError: m,
      isInitialLoading: E,
      isLoading: E,
      data: Z,
      dataUpdatedAt: s.dataUpdatedAt,
      error: o,
      errorUpdatedAt: U,
      failureCount: s.fetchFailureCount,
      failureReason: s.fetchFailureReason,
      errorUpdateCount: s.errorUpdateCount,
      isFetched: s.dataUpdateCount > 0 || s.errorUpdateCount > 0,
      isFetchedAfterMount: s.dataUpdateCount > V.dataUpdateCount || s.errorUpdateCount > V.errorUpdateCount,
      isFetching: W,
      isRefetching: W && !F,
      isLoadingError: m && !u,
      isPaused: N === "paused",
      isPlaceholderData: h,
      isRefetchError: m && u,
      isStale: s1(n, t),
      refetch: this.refetch
    };
  }
  updateResult(n) {
    const t = _(this, ql), l = this.createResult(_(this, Hn), this.options);
    if (Tt(this, UV, _(this, Hn).state), Tt(this, Tc, this.options), _(this, UV).data !== void 0 && Tt(this, Wc, _(this, Hn)), zF(l, t))
      return;
    Tt(this, ql, l);
    const a = {}, d = () => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: r } = this.options, i = typeof r == "function" ? r() : r;
      if (i === "all" || !i && !_(this, mc).size)
        return !0;
      const c = new Set(
        i ?? _(this, mc)
      );
      return this.options.throwOnError && c.add("error"), Object.keys(_(this, ql)).some((V) => {
        const s = V;
        return _(this, ql)[s] !== t[s] && c.has(s);
      });
    };
    (n == null ? void 0 : n.listeners) !== !1 && d() && (a.listeners = !0), Un(this, HR, cQ).call(this, { ...a, ...n });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && Un(this, Po, XF).call(this);
  }
}, sa = new WeakMap(), Hn = new WeakMap(), Io = new WeakMap(), ql = new WeakMap(), UV = new WeakMap(), Tc = new WeakMap(), yd = new WeakMap(), Lo = new WeakMap(), Fc = new WeakMap(), Wc = new WeakMap(), NV = new WeakMap(), RV = new WeakMap(), ri = new WeakMap(), mc = new WeakMap(), hV = new WeakSet(), Js = function(n) {
  Un(this, $o, HF).call(this);
  let t = _(this, Hn).fetch(
    this.options,
    n
  );
  return n != null && n.throwOnError || (t = t.catch(Pa)), t;
}, Co = new WeakSet(), yF = function() {
  if (Un(this, Ao, OF).call(this), xc || _(this, ql).isStale || !vF(this.options.staleTime))
    return;
  const t = aQ(
    _(this, ql).dataUpdatedAt,
    this.options.staleTime
  ) + 1;
  Tt(this, NV, setTimeout(() => {
    _(this, ql).isStale || this.updateResult();
  }, t));
}, Ko = new WeakSet(), BF = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(_(this, Hn)) : this.options.refetchInterval) ?? !1;
}, _o = new WeakSet(), DF = function(n) {
  Un(this, qo, jF).call(this), Tt(this, ri, n), !(xc || this.options.enabled === !1 || !vF(_(this, ri)) || _(this, ri) === 0) && Tt(this, RV, setInterval(() => {
    (this.options.refetchIntervalInBackground || bR.isFocused()) && Un(this, hV, Js).call(this);
  }, _(this, ri)));
}, Po = new WeakSet(), XF = function() {
  Un(this, Co, yF).call(this), Un(this, _o, DF).call(this, Un(this, Ko, BF).call(this));
}, Ao = new WeakSet(), OF = function() {
  _(this, NV) && (clearTimeout(_(this, NV)), Tt(this, NV, void 0));
}, qo = new WeakSet(), jF = function() {
  _(this, RV) && (clearInterval(_(this, RV)), Tt(this, RV, void 0));
}, $o = new WeakSet(), HF = function() {
  const n = _(this, sa).getQueryCache().build(_(this, sa), this.options);
  if (n === _(this, Hn))
    return;
  const t = _(this, Hn);
  Tt(this, Hn, n), Tt(this, Io, n.state), this.hasListeners() && (t == null || t.removeObserver(this), n.addObserver(this));
}, HR = new WeakSet(), cQ = function(n) {
  Xl.batch(() => {
    n.listeners && this.listeners.forEach((t) => {
      t(_(this, ql));
    }), _(this, sa).getQueryCache().notify({
      query: _(this, Hn),
      type: "observerResultsUpdated"
    });
  });
}, AS);
function eK(e, n) {
  return n.enabled !== !1 && e.state.data === void 0 && !(e.state.status === "error" && n.retryOnMount === !1);
}
function S2(e, n) {
  return eK(e, n) || e.state.data !== void 0 && fF(e, n, n.refetchOnMount);
}
function fF(e, n, t) {
  if (n.enabled !== !1) {
    const l = typeof t == "function" ? t(e) : t;
    return l === "always" || l !== !1 && s1(e, n);
  }
  return !1;
}
function k2(e, n, t, l) {
  return t.enabled !== !1 && (e !== n || l.enabled === !1) && (!t.suspense || e.state.status !== "error") && s1(e, t);
}
function s1(e, n) {
  return e.isStaleByTime(n.staleTime);
}
function tK(e, n) {
  return !zF(e.getCurrentResult(), n);
}
var sQ = z.createContext(
  void 0
), nK = (e) => {
  const n = z.useContext(sQ);
  if (e)
    return e;
  if (!n)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return n;
}, lK = ({
  client: e,
  children: n
}) => (z.useEffect(() => (e.mount(), () => {
  e.unmount();
}), [e]), /* @__PURE__ */ Y.jsx(sQ.Provider, { value: e, children: n })), oQ = z.createContext(!1), aK = () => z.useContext(oQ);
oQ.Provider;
function dK() {
  let e = !1;
  return {
    clearReset: () => {
      e = !1;
    },
    reset: () => {
      e = !0;
    },
    isReset: () => e
  };
}
var rK = z.createContext(dK()), iK = () => z.useContext(rK);
function VK(e, n) {
  return typeof e == "function" ? e(...n) : !!e;
}
var cK = (e, n) => {
  (e.suspense || e.throwOnError) && (n.isReset() || (e.retryOnMount = !1));
}, sK = (e) => {
  z.useEffect(() => {
    e.clearReset();
  }, [e]);
}, oK = ({
  result: e,
  errorResetBoundary: n,
  throwOnError: t,
  query: l
}) => e.isError && !n.isReset() && !e.isFetching && l && VK(t, [e.error, l]), UK = (e) => {
  e.suspense && typeof e.staleTime != "number" && (e.staleTime = 1e3);
}, NK = (e, n) => (e == null ? void 0 : e.suspense) && n.isPending, RK = (e, n, t) => n.fetchOptimistic(e).catch(() => {
  t.clearReset();
});
function hK(e, n, t) {
  if (process.env.NODE_ENV !== "production" && (typeof e != "object" || Array.isArray(e)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const l = nK(t), a = aK(), d = iK(), r = l.defaultQueryOptions(e);
  r._optimisticResults = a ? "isRestoring" : "optimistic", UK(r), cK(r, d), sK(d);
  const [i] = z.useState(
    () => new n(
      l,
      r
    )
  ), c = i.getOptimisticResult(r);
  if (z.useSyncExternalStore(
    z.useCallback(
      (V) => {
        const s = a ? () => {
        } : i.subscribe(Xl.batchCalls(V));
        return i.updateResult(), s;
      },
      [i, a]
    ),
    () => i.getCurrentResult(),
    () => i.getCurrentResult()
  ), z.useEffect(() => {
    i.setOptions(r, { listeners: !1 });
  }, [r, i]), NK(r, c))
    throw RK(r, i, d);
  if (oK({
    result: c,
    errorResetBoundary: d,
    throwOnError: r.throwOnError,
    query: l.getQueryCache().get(r.queryHash)
  }))
    throw c.error;
  return r.notifyOnChangeProps ? c : i.trackResult(c);
}
function ZK(e, n) {
  return hK(e, $C, n);
}
function UQ(e, n) {
  return function() {
    return e.apply(n, arguments);
  };
}
const { toString: TK } = Object.prototype, { getPrototypeOf: o1 } = Object, hh = ((e) => (n) => {
  const t = TK.call(n);
  return e[t] || (e[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), rr = (e) => (e = e.toLowerCase(), (n) => hh(n) === e), Zh = (e) => (n) => typeof n === e, { isArray: Lc } = Array, yo = Zh("undefined");
function FK(e) {
  return e !== null && !yo(e) && e.constructor !== null && !yo(e.constructor) && td(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const NQ = rr("ArrayBuffer");
function WK(e) {
  let n;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? n = ArrayBuffer.isView(e) : n = e && e.buffer && NQ(e.buffer), n;
}
const mK = Zh("string"), td = Zh("function"), RQ = Zh("number"), Th = (e) => e !== null && typeof e == "object", uK = (e) => e === !0 || e === !1, XN = (e) => {
  if (hh(e) !== "object")
    return !1;
  const n = o1(e);
  return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, pK = rr("Date"), MK = rr("File"), EK = rr("Blob"), SK = rr("FileList"), kK = (e) => Th(e) && td(e.pipe), bK = (e) => {
  let n;
  return e && (typeof FormData == "function" && e instanceof FormData || td(e.append) && ((n = hh(e)) === "formdata" || // detect form-data instance
  n === "object" && td(e.toString) && e.toString() === "[object FormData]"));
}, YK = rr("URLSearchParams"), QK = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function RU(e, n, { allOwnKeys: t = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let l, a;
  if (typeof e != "object" && (e = [e]), Lc(e))
    for (l = 0, a = e.length; l < a; l++)
      n.call(null, e[l], l, e);
  else {
    const d = t ? Object.getOwnPropertyNames(e) : Object.keys(e), r = d.length;
    let i;
    for (l = 0; l < r; l++)
      i = d[l], n.call(null, e[i], i, e);
  }
}
function hQ(e, n) {
  n = n.toLowerCase();
  const t = Object.keys(e);
  let l = t.length, a;
  for (; l-- > 0; )
    if (a = t[l], n === a.toLowerCase())
      return a;
  return null;
}
const ZQ = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), TQ = (e) => !yo(e) && e !== ZQ;
function wF() {
  const { caseless: e } = TQ(this) && this || {}, n = {}, t = (l, a) => {
    const d = e && hQ(n, a) || a;
    XN(n[d]) && XN(l) ? n[d] = wF(n[d], l) : XN(l) ? n[d] = wF({}, l) : Lc(l) ? n[d] = l.slice() : n[d] = l;
  };
  for (let l = 0, a = arguments.length; l < a; l++)
    arguments[l] && RU(arguments[l], t);
  return n;
}
const JK = (e, n, t, { allOwnKeys: l } = {}) => (RU(n, (a, d) => {
  t && td(a) ? e[d] = UQ(a, t) : e[d] = a;
}, { allOwnKeys: l }), e), vK = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), zK = (e, n, t, l) => {
  e.prototype = Object.create(n.prototype, l), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: n.prototype
  }), t && Object.assign(e.prototype, t);
}, xK = (e, n, t, l) => {
  let a, d, r;
  const i = {};
  if (n = n || {}, e == null)
    return n;
  do {
    for (a = Object.getOwnPropertyNames(e), d = a.length; d-- > 0; )
      r = a[d], (!l || l(r, e, n)) && !i[r] && (n[r] = e[r], i[r] = !0);
    e = t !== !1 && o1(e);
  } while (e && (!t || t(e, n)) && e !== Object.prototype);
  return n;
}, GK = (e, n, t) => {
  e = String(e), (t === void 0 || t > e.length) && (t = e.length), t -= n.length;
  const l = e.indexOf(n, t);
  return l !== -1 && l === t;
}, yK = (e) => {
  if (!e)
    return null;
  if (Lc(e))
    return e;
  let n = e.length;
  if (!RQ(n))
    return null;
  const t = new Array(n);
  for (; n-- > 0; )
    t[n] = e[n];
  return t;
}, BK = ((e) => (n) => e && n instanceof e)(typeof Uint8Array < "u" && o1(Uint8Array)), DK = (e, n) => {
  const l = (e && e[Symbol.iterator]).call(e);
  let a;
  for (; (a = l.next()) && !a.done; ) {
    const d = a.value;
    n.call(e, d[0], d[1]);
  }
}, XK = (e, n) => {
  let t;
  const l = [];
  for (; (t = e.exec(n)) !== null; )
    l.push(t);
  return l;
}, OK = rr("HTMLFormElement"), jK = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, l, a) {
    return l.toUpperCase() + a;
  }
), b2 = (({ hasOwnProperty: e }) => (n, t) => e.call(n, t))(Object.prototype), HK = rr("RegExp"), FQ = (e, n) => {
  const t = Object.getOwnPropertyDescriptors(e), l = {};
  RU(t, (a, d) => {
    let r;
    (r = n(a, d, e)) !== !1 && (l[d] = r || a);
  }), Object.defineProperties(e, l);
}, fK = (e) => {
  FQ(e, (n, t) => {
    if (td(e) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const l = e[t];
    if (td(l)) {
      if (n.enumerable = !1, "writable" in n) {
        n.writable = !1;
        return;
      }
      n.set || (n.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, wK = (e, n) => {
  const t = {}, l = (a) => {
    a.forEach((d) => {
      t[d] = !0;
    });
  };
  return Lc(e) ? l(e) : l(String(e).split(n)), t;
}, gK = () => {
}, IK = (e, n) => (e = +e, Number.isFinite(e) ? e : n), CZ = "abcdefghijklmnopqrstuvwxyz", Y2 = "0123456789", WQ = {
  DIGIT: Y2,
  ALPHA: CZ,
  ALPHA_DIGIT: CZ + CZ.toUpperCase() + Y2
}, LK = (e = 16, n = WQ.ALPHA_DIGIT) => {
  let t = "";
  const { length: l } = n;
  for (; e--; )
    t += n[Math.random() * l | 0];
  return t;
};
function CK(e) {
  return !!(e && td(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const KK = (e) => {
  const n = new Array(10), t = (l, a) => {
    if (Th(l)) {
      if (n.indexOf(l) >= 0)
        return;
      if (!("toJSON" in l)) {
        n[a] = l;
        const d = Lc(l) ? [] : {};
        return RU(l, (r, i) => {
          const c = t(r, a + 1);
          !yo(c) && (d[i] = c);
        }), n[a] = void 0, d;
      }
    }
    return l;
  };
  return t(e, 0);
}, _K = rr("AsyncFunction"), PK = (e) => e && (Th(e) || td(e)) && td(e.then) && td(e.catch), ve = {
  isArray: Lc,
  isArrayBuffer: NQ,
  isBuffer: FK,
  isFormData: bK,
  isArrayBufferView: WK,
  isString: mK,
  isNumber: RQ,
  isBoolean: uK,
  isObject: Th,
  isPlainObject: XN,
  isUndefined: yo,
  isDate: pK,
  isFile: MK,
  isBlob: EK,
  isRegExp: HK,
  isFunction: td,
  isStream: kK,
  isURLSearchParams: YK,
  isTypedArray: BK,
  isFileList: SK,
  forEach: RU,
  merge: wF,
  extend: JK,
  trim: QK,
  stripBOM: vK,
  inherits: zK,
  toFlatObject: xK,
  kindOf: hh,
  kindOfTest: rr,
  endsWith: GK,
  toArray: yK,
  forEachEntry: DK,
  matchAll: XK,
  isHTMLForm: OK,
  hasOwnProperty: b2,
  hasOwnProp: b2,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: FQ,
  freezeMethods: fK,
  toObjectSet: wK,
  toCamelCase: jK,
  noop: gK,
  toFiniteNumber: IK,
  findKey: hQ,
  global: ZQ,
  isContextDefined: TQ,
  ALPHABET: WQ,
  generateString: LK,
  isSpecCompliantForm: CK,
  toJSONObject: KK,
  isAsyncFn: _K,
  isThenable: PK
};
function Tn(e, n, t, l, a) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", n && (this.code = n), t && (this.config = t), l && (this.request = l), a && (this.response = a);
}
ve.inherits(Tn, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ve.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const mQ = Tn.prototype, uQ = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  uQ[e] = { value: e };
});
Object.defineProperties(Tn, uQ);
Object.defineProperty(mQ, "isAxiosError", { value: !0 });
Tn.from = (e, n, t, l, a, d) => {
  const r = Object.create(mQ);
  return ve.toFlatObject(e, r, function(c) {
    return c !== Error.prototype;
  }, (i) => i !== "isAxiosError"), Tn.call(r, e.message, n, t, l, a), r.cause = e, r.name = e.name, d && Object.assign(r, d), r;
};
const AK = null;
function gF(e) {
  return ve.isPlainObject(e) || ve.isArray(e);
}
function pQ(e) {
  return ve.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Q2(e, n, t) {
  return e ? e.concat(n).map(function(a, d) {
    return a = pQ(a), !t && d ? "[" + a + "]" : a;
  }).join(t ? "." : "") : n;
}
function qK(e) {
  return ve.isArray(e) && !e.some(gF);
}
const $K = ve.toFlatObject(ve, {}, null, function(n) {
  return /^is[A-Z]/.test(n);
});
function Fh(e, n, t) {
  if (!ve.isObject(e))
    throw new TypeError("target must be an object");
  n = n || new FormData(), t = ve.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(h, Z) {
    return !ve.isUndefined(Z[h]);
  });
  const l = t.metaTokens, a = t.visitor || s, d = t.dots, r = t.indexes, c = (t.Blob || typeof Blob < "u" && Blob) && ve.isSpecCompliantForm(n);
  if (!ve.isFunction(a))
    throw new TypeError("visitor must be a function");
  function V(R) {
    if (R === null)
      return "";
    if (ve.isDate(R))
      return R.toISOString();
    if (!c && ve.isBlob(R))
      throw new Tn("Blob is not supported. Use a Buffer instead.");
    return ve.isArrayBuffer(R) || ve.isTypedArray(R) ? c && typeof Blob == "function" ? new Blob([R]) : Buffer.from(R) : R;
  }
  function s(R, h, Z) {
    let W = R;
    if (R && !Z && typeof R == "object") {
      if (ve.endsWith(h, "{}"))
        h = l ? h : h.slice(0, -2), R = JSON.stringify(R);
      else if (ve.isArray(R) && qK(R) || (ve.isFileList(R) || ve.endsWith(h, "[]")) && (W = ve.toArray(R)))
        return h = pQ(h), W.forEach(function(m, E) {
          !(ve.isUndefined(m) || m === null) && n.append(
            // eslint-disable-next-line no-nested-ternary
            r === !0 ? Q2([h], E, d) : r === null ? h : h + "[]",
            V(m)
          );
        }), !1;
    }
    return gF(R) ? !0 : (n.append(Q2(Z, h, d), V(R)), !1);
  }
  const o = [], U = Object.assign($K, {
    defaultVisitor: s,
    convertValue: V,
    isVisitable: gF
  });
  function N(R, h) {
    if (!ve.isUndefined(R)) {
      if (o.indexOf(R) !== -1)
        throw Error("Circular reference detected in " + h.join("."));
      o.push(R), ve.forEach(R, function(W, F) {
        (!(ve.isUndefined(W) || W === null) && a.call(
          n,
          W,
          ve.isString(F) ? F.trim() : F,
          h,
          U
        )) === !0 && N(W, h ? h.concat(F) : [F]);
      }), o.pop();
    }
  }
  if (!ve.isObject(e))
    throw new TypeError("data must be an object");
  return N(e), n;
}
function J2(e) {
  const n = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(l) {
    return n[l];
  });
}
function U1(e, n) {
  this._pairs = [], e && Fh(e, this, n);
}
const MQ = U1.prototype;
MQ.append = function(n, t) {
  this._pairs.push([n, t]);
};
MQ.toString = function(n) {
  const t = n ? function(l) {
    return n.call(this, l, J2);
  } : J2;
  return this._pairs.map(function(a) {
    return t(a[0]) + "=" + t(a[1]);
  }, "").join("&");
};
function e6(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function EQ(e, n, t) {
  if (!n)
    return e;
  const l = t && t.encode || e6, a = t && t.serialize;
  let d;
  if (a ? d = a(n, t) : d = ve.isURLSearchParams(n) ? n.toString() : new U1(n, t).toString(l), d) {
    const r = e.indexOf("#");
    r !== -1 && (e = e.slice(0, r)), e += (e.indexOf("?") === -1 ? "?" : "&") + d;
  }
  return e;
}
class t6 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(n, t, l) {
    return this.handlers.push({
      fulfilled: n,
      rejected: t,
      synchronous: l ? l.synchronous : !1,
      runWhen: l ? l.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(n) {
    this.handlers[n] && (this.handlers[n] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(n) {
    ve.forEach(this.handlers, function(l) {
      l !== null && n(l);
    });
  }
}
const v2 = t6, SQ = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, n6 = typeof URLSearchParams < "u" ? URLSearchParams : U1, l6 = typeof FormData < "u" ? FormData : null, a6 = typeof Blob < "u" ? Blob : null, d6 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: n6,
    FormData: l6,
    Blob: a6
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, kQ = typeof window < "u" && typeof document < "u", r6 = ((e) => kQ && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), i6 = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), V6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: kQ,
  hasStandardBrowserEnv: r6,
  hasStandardBrowserWebWorkerEnv: i6
}, Symbol.toStringTag, { value: "Module" })), Id = {
  ...V6,
  ...d6
};
function c6(e, n) {
  return Fh(e, new Id.classes.URLSearchParams(), Object.assign({
    visitor: function(t, l, a, d) {
      return Id.isNode && ve.isBuffer(t) ? (this.append(l, t.toString("base64")), !1) : d.defaultVisitor.apply(this, arguments);
    }
  }, n));
}
function s6(e) {
  return ve.matchAll(/\w+|\[(\w*)]/g, e).map((n) => n[0] === "[]" ? "" : n[1] || n[0]);
}
function o6(e) {
  const n = {}, t = Object.keys(e);
  let l;
  const a = t.length;
  let d;
  for (l = 0; l < a; l++)
    d = t[l], n[d] = e[d];
  return n;
}
function bQ(e) {
  function n(t, l, a, d) {
    let r = t[d++];
    if (r === "__proto__")
      return !0;
    const i = Number.isFinite(+r), c = d >= t.length;
    return r = !r && ve.isArray(a) ? a.length : r, c ? (ve.hasOwnProp(a, r) ? a[r] = [a[r], l] : a[r] = l, !i) : ((!a[r] || !ve.isObject(a[r])) && (a[r] = []), n(t, l, a[r], d) && ve.isArray(a[r]) && (a[r] = o6(a[r])), !i);
  }
  if (ve.isFormData(e) && ve.isFunction(e.entries)) {
    const t = {};
    return ve.forEachEntry(e, (l, a) => {
      n(s6(l), a, t, 0);
    }), t;
  }
  return null;
}
function U6(e, n, t) {
  if (ve.isString(e))
    try {
      return (n || JSON.parse)(e), ve.trim(e);
    } catch (l) {
      if (l.name !== "SyntaxError")
        throw l;
    }
  return (t || JSON.stringify)(e);
}
const N1 = {
  transitional: SQ,
  adapter: ["xhr", "http"],
  transformRequest: [function(n, t) {
    const l = t.getContentType() || "", a = l.indexOf("application/json") > -1, d = ve.isObject(n);
    if (d && ve.isHTMLForm(n) && (n = new FormData(n)), ve.isFormData(n))
      return a ? JSON.stringify(bQ(n)) : n;
    if (ve.isArrayBuffer(n) || ve.isBuffer(n) || ve.isStream(n) || ve.isFile(n) || ve.isBlob(n))
      return n;
    if (ve.isArrayBufferView(n))
      return n.buffer;
    if (ve.isURLSearchParams(n))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), n.toString();
    let i;
    if (d) {
      if (l.indexOf("application/x-www-form-urlencoded") > -1)
        return c6(n, this.formSerializer).toString();
      if ((i = ve.isFileList(n)) || l.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Fh(
          i ? { "files[]": n } : n,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return d || a ? (t.setContentType("application/json", !1), U6(n)) : n;
  }],
  transformResponse: [function(n) {
    const t = this.transitional || N1.transitional, l = t && t.forcedJSONParsing, a = this.responseType === "json";
    if (n && ve.isString(n) && (l && !this.responseType || a)) {
      const r = !(t && t.silentJSONParsing) && a;
      try {
        return JSON.parse(n);
      } catch (i) {
        if (r)
          throw i.name === "SyntaxError" ? Tn.from(i, Tn.ERR_BAD_RESPONSE, this, null, this.response) : i;
      }
    }
    return n;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Id.classes.FormData,
    Blob: Id.classes.Blob
  },
  validateStatus: function(n) {
    return n >= 200 && n < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ve.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  N1.headers[e] = {};
});
const R1 = N1, N6 = ve.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), R6 = (e) => {
  const n = {};
  let t, l, a;
  return e && e.split(`
`).forEach(function(r) {
    a = r.indexOf(":"), t = r.substring(0, a).trim().toLowerCase(), l = r.substring(a + 1).trim(), !(!t || n[t] && N6[t]) && (t === "set-cookie" ? n[t] ? n[t].push(l) : n[t] = [l] : n[t] = n[t] ? n[t] + ", " + l : l);
  }), n;
}, z2 = Symbol("internals");
function Zs(e) {
  return e && String(e).trim().toLowerCase();
}
function ON(e) {
  return e === !1 || e == null ? e : ve.isArray(e) ? e.map(ON) : String(e);
}
function h6(e) {
  const n = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let l;
  for (; l = t.exec(e); )
    n[l[1]] = l[2];
  return n;
}
const Z6 = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function KZ(e, n, t, l, a) {
  if (ve.isFunction(l))
    return l.call(this, n, t);
  if (a && (n = t), !!ve.isString(n)) {
    if (ve.isString(l))
      return n.indexOf(l) !== -1;
    if (ve.isRegExp(l))
      return l.test(n);
  }
}
function T6(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (n, t, l) => t.toUpperCase() + l);
}
function F6(e, n) {
  const t = ve.toCamelCase(" " + n);
  ["get", "set", "has"].forEach((l) => {
    Object.defineProperty(e, l + t, {
      value: function(a, d, r) {
        return this[l].call(this, n, a, d, r);
      },
      configurable: !0
    });
  });
}
class Wh {
  constructor(n) {
    n && this.set(n);
  }
  set(n, t, l) {
    const a = this;
    function d(i, c, V) {
      const s = Zs(c);
      if (!s)
        throw new Error("header name must be a non-empty string");
      const o = ve.findKey(a, s);
      (!o || a[o] === void 0 || V === !0 || V === void 0 && a[o] !== !1) && (a[o || c] = ON(i));
    }
    const r = (i, c) => ve.forEach(i, (V, s) => d(V, s, c));
    return ve.isPlainObject(n) || n instanceof this.constructor ? r(n, t) : ve.isString(n) && (n = n.trim()) && !Z6(n) ? r(R6(n), t) : n != null && d(t, n, l), this;
  }
  get(n, t) {
    if (n = Zs(n), n) {
      const l = ve.findKey(this, n);
      if (l) {
        const a = this[l];
        if (!t)
          return a;
        if (t === !0)
          return h6(a);
        if (ve.isFunction(t))
          return t.call(this, a, l);
        if (ve.isRegExp(t))
          return t.exec(a);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(n, t) {
    if (n = Zs(n), n) {
      const l = ve.findKey(this, n);
      return !!(l && this[l] !== void 0 && (!t || KZ(this, this[l], l, t)));
    }
    return !1;
  }
  delete(n, t) {
    const l = this;
    let a = !1;
    function d(r) {
      if (r = Zs(r), r) {
        const i = ve.findKey(l, r);
        i && (!t || KZ(l, l[i], i, t)) && (delete l[i], a = !0);
      }
    }
    return ve.isArray(n) ? n.forEach(d) : d(n), a;
  }
  clear(n) {
    const t = Object.keys(this);
    let l = t.length, a = !1;
    for (; l--; ) {
      const d = t[l];
      (!n || KZ(this, this[d], d, n, !0)) && (delete this[d], a = !0);
    }
    return a;
  }
  normalize(n) {
    const t = this, l = {};
    return ve.forEach(this, (a, d) => {
      const r = ve.findKey(l, d);
      if (r) {
        t[r] = ON(a), delete t[d];
        return;
      }
      const i = n ? T6(d) : String(d).trim();
      i !== d && delete t[d], t[i] = ON(a), l[i] = !0;
    }), this;
  }
  concat(...n) {
    return this.constructor.concat(this, ...n);
  }
  toJSON(n) {
    const t = /* @__PURE__ */ Object.create(null);
    return ve.forEach(this, (l, a) => {
      l != null && l !== !1 && (t[a] = n && ve.isArray(l) ? l.join(", ") : l);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([n, t]) => n + ": " + t).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(n) {
    return n instanceof this ? n : new this(n);
  }
  static concat(n, ...t) {
    const l = new this(n);
    return t.forEach((a) => l.set(a)), l;
  }
  static accessor(n) {
    const l = (this[z2] = this[z2] = {
      accessors: {}
    }).accessors, a = this.prototype;
    function d(r) {
      const i = Zs(r);
      l[i] || (F6(a, r), l[i] = !0);
    }
    return ve.isArray(n) ? n.forEach(d) : d(n), this;
  }
}
Wh.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ve.reduceDescriptors(Wh.prototype, ({ value: e }, n) => {
  let t = n[0].toUpperCase() + n.slice(1);
  return {
    get: () => e,
    set(l) {
      this[t] = l;
    }
  };
});
ve.freezeMethods(Wh);
const Yr = Wh;
function _Z(e, n) {
  const t = this || R1, l = n || t, a = Yr.from(l.headers);
  let d = l.data;
  return ve.forEach(e, function(i) {
    d = i.call(t, d, a.normalize(), n ? n.status : void 0);
  }), a.normalize(), d;
}
function YQ(e) {
  return !!(e && e.__CANCEL__);
}
function hU(e, n, t) {
  Tn.call(this, e ?? "canceled", Tn.ERR_CANCELED, n, t), this.name = "CanceledError";
}
ve.inherits(hU, Tn, {
  __CANCEL__: !0
});
function W6(e, n, t) {
  const l = t.config.validateStatus;
  !t.status || !l || l(t.status) ? e(t) : n(new Tn(
    "Request failed with status code " + t.status,
    [Tn.ERR_BAD_REQUEST, Tn.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],
    t.config,
    t.request,
    t
  ));
}
const m6 = Id.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, n, t, l, a, d) {
      const r = [e + "=" + encodeURIComponent(n)];
      ve.isNumber(t) && r.push("expires=" + new Date(t).toGMTString()), ve.isString(l) && r.push("path=" + l), ve.isString(a) && r.push("domain=" + a), d === !0 && r.push("secure"), document.cookie = r.join("; ");
    },
    read(e) {
      const n = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return n ? decodeURIComponent(n[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function u6(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function p6(e, n) {
  return n ? e.replace(/\/?\/$/, "") + "/" + n.replace(/^\/+/, "") : e;
}
function QQ(e, n) {
  return e && !u6(n) ? p6(e, n) : n;
}
const M6 = Id.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const n = /(msie|trident)/i.test(navigator.userAgent), t = document.createElement("a");
    let l;
    function a(d) {
      let r = d;
      return n && (t.setAttribute("href", r), r = t.href), t.setAttribute("href", r), {
        href: t.href,
        protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
        host: t.host,
        search: t.search ? t.search.replace(/^\?/, "") : "",
        hash: t.hash ? t.hash.replace(/^#/, "") : "",
        hostname: t.hostname,
        port: t.port,
        pathname: t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname
      };
    }
    return l = a(window.location.href), function(r) {
      const i = ve.isString(r) ? a(r) : r;
      return i.protocol === l.protocol && i.host === l.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);
function E6(e) {
  const n = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return n && n[1] || "";
}
function S6(e, n) {
  e = e || 10;
  const t = new Array(e), l = new Array(e);
  let a = 0, d = 0, r;
  return n = n !== void 0 ? n : 1e3, function(c) {
    const V = Date.now(), s = l[d];
    r || (r = V), t[a] = c, l[a] = V;
    let o = d, U = 0;
    for (; o !== a; )
      U += t[o++], o = o % e;
    if (a = (a + 1) % e, a === d && (d = (d + 1) % e), V - r < n)
      return;
    const N = s && V - s;
    return N ? Math.round(U * 1e3 / N) : void 0;
  };
}
function x2(e, n) {
  let t = 0;
  const l = S6(50, 250);
  return (a) => {
    const d = a.loaded, r = a.lengthComputable ? a.total : void 0, i = d - t, c = l(i), V = d <= r;
    t = d;
    const s = {
      loaded: d,
      total: r,
      progress: r ? d / r : void 0,
      bytes: i,
      rate: c || void 0,
      estimated: c && r && V ? (r - d) / c : void 0,
      event: a
    };
    s[n ? "download" : "upload"] = !0, e(s);
  };
}
const k6 = typeof XMLHttpRequest < "u", b6 = k6 && function(e) {
  return new Promise(function(t, l) {
    let a = e.data;
    const d = Yr.from(e.headers).normalize();
    let { responseType: r, withXSRFToken: i } = e, c;
    function V() {
      e.cancelToken && e.cancelToken.unsubscribe(c), e.signal && e.signal.removeEventListener("abort", c);
    }
    let s;
    if (ve.isFormData(a)) {
      if (Id.hasStandardBrowserEnv || Id.hasStandardBrowserWebWorkerEnv)
        d.setContentType(!1);
      else if ((s = d.getContentType()) !== !1) {
        const [h, ...Z] = s ? s.split(";").map((W) => W.trim()).filter(Boolean) : [];
        d.setContentType([h || "multipart/form-data", ...Z].join("; "));
      }
    }
    let o = new XMLHttpRequest();
    if (e.auth) {
      const h = e.auth.username || "", Z = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      d.set("Authorization", "Basic " + btoa(h + ":" + Z));
    }
    const U = QQ(e.baseURL, e.url);
    o.open(e.method.toUpperCase(), EQ(U, e.params, e.paramsSerializer), !0), o.timeout = e.timeout;
    function N() {
      if (!o)
        return;
      const h = Yr.from(
        "getAllResponseHeaders" in o && o.getAllResponseHeaders()
      ), W = {
        data: !r || r === "text" || r === "json" ? o.responseText : o.response,
        status: o.status,
        statusText: o.statusText,
        headers: h,
        config: e,
        request: o
      };
      W6(function(m) {
        t(m), V();
      }, function(m) {
        l(m), V();
      }, W), o = null;
    }
    if ("onloadend" in o ? o.onloadend = N : o.onreadystatechange = function() {
      !o || o.readyState !== 4 || o.status === 0 && !(o.responseURL && o.responseURL.indexOf("file:") === 0) || setTimeout(N);
    }, o.onabort = function() {
      o && (l(new Tn("Request aborted", Tn.ECONNABORTED, e, o)), o = null);
    }, o.onerror = function() {
      l(new Tn("Network Error", Tn.ERR_NETWORK, e, o)), o = null;
    }, o.ontimeout = function() {
      let Z = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const W = e.transitional || SQ;
      e.timeoutErrorMessage && (Z = e.timeoutErrorMessage), l(new Tn(
        Z,
        W.clarifyTimeoutError ? Tn.ETIMEDOUT : Tn.ECONNABORTED,
        e,
        o
      )), o = null;
    }, Id.hasStandardBrowserEnv && (i && ve.isFunction(i) && (i = i(e)), i || i !== !1 && M6(U))) {
      const h = e.xsrfHeaderName && e.xsrfCookieName && m6.read(e.xsrfCookieName);
      h && d.set(e.xsrfHeaderName, h);
    }
    a === void 0 && d.setContentType(null), "setRequestHeader" in o && ve.forEach(d.toJSON(), function(Z, W) {
      o.setRequestHeader(W, Z);
    }), ve.isUndefined(e.withCredentials) || (o.withCredentials = !!e.withCredentials), r && r !== "json" && (o.responseType = e.responseType), typeof e.onDownloadProgress == "function" && o.addEventListener("progress", x2(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && o.upload && o.upload.addEventListener("progress", x2(e.onUploadProgress)), (e.cancelToken || e.signal) && (c = (h) => {
      o && (l(!h || h.type ? new hU(null, e, o) : h), o.abort(), o = null);
    }, e.cancelToken && e.cancelToken.subscribe(c), e.signal && (e.signal.aborted ? c() : e.signal.addEventListener("abort", c)));
    const R = E6(U);
    if (R && Id.protocols.indexOf(R) === -1) {
      l(new Tn("Unsupported protocol " + R + ":", Tn.ERR_BAD_REQUEST, e));
      return;
    }
    o.send(a || null);
  });
}, IF = {
  http: AK,
  xhr: b6
};
ve.forEach(IF, (e, n) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: n });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: n });
  }
});
const G2 = (e) => `- ${e}`, Y6 = (e) => ve.isFunction(e) || e === null || e === !1, JQ = {
  getAdapter: (e) => {
    e = ve.isArray(e) ? e : [e];
    const { length: n } = e;
    let t, l;
    const a = {};
    for (let d = 0; d < n; d++) {
      t = e[d];
      let r;
      if (l = t, !Y6(t) && (l = IF[(r = String(t)).toLowerCase()], l === void 0))
        throw new Tn(`Unknown adapter '${r}'`);
      if (l)
        break;
      a[r || "#" + d] = l;
    }
    if (!l) {
      const d = Object.entries(a).map(
        ([i, c]) => `adapter ${i} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let r = n ? d.length > 1 ? `since :
` + d.map(G2).join(`
`) : " " + G2(d[0]) : "as no adapter specified";
      throw new Tn(
        "There is no suitable adapter to dispatch the request " + r,
        "ERR_NOT_SUPPORT"
      );
    }
    return l;
  },
  adapters: IF
};
function PZ(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new hU(null, e);
}
function y2(e) {
  return PZ(e), e.headers = Yr.from(e.headers), e.data = _Z.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), JQ.getAdapter(e.adapter || R1.adapter)(e).then(function(l) {
    return PZ(e), l.data = _Z.call(
      e,
      e.transformResponse,
      l
    ), l.headers = Yr.from(l.headers), l;
  }, function(l) {
    return YQ(l) || (PZ(e), l && l.response && (l.response.data = _Z.call(
      e,
      e.transformResponse,
      l.response
    ), l.response.headers = Yr.from(l.response.headers))), Promise.reject(l);
  });
}
const B2 = (e) => e instanceof Yr ? e.toJSON() : e;
function Gc(e, n) {
  n = n || {};
  const t = {};
  function l(V, s, o) {
    return ve.isPlainObject(V) && ve.isPlainObject(s) ? ve.merge.call({ caseless: o }, V, s) : ve.isPlainObject(s) ? ve.merge({}, s) : ve.isArray(s) ? s.slice() : s;
  }
  function a(V, s, o) {
    if (ve.isUndefined(s)) {
      if (!ve.isUndefined(V))
        return l(void 0, V, o);
    } else
      return l(V, s, o);
  }
  function d(V, s) {
    if (!ve.isUndefined(s))
      return l(void 0, s);
  }
  function r(V, s) {
    if (ve.isUndefined(s)) {
      if (!ve.isUndefined(V))
        return l(void 0, V);
    } else
      return l(void 0, s);
  }
  function i(V, s, o) {
    if (o in n)
      return l(V, s);
    if (o in e)
      return l(void 0, V);
  }
  const c = {
    url: d,
    method: d,
    data: d,
    baseURL: r,
    transformRequest: r,
    transformResponse: r,
    paramsSerializer: r,
    timeout: r,
    timeoutMessage: r,
    withCredentials: r,
    withXSRFToken: r,
    adapter: r,
    responseType: r,
    xsrfCookieName: r,
    xsrfHeaderName: r,
    onUploadProgress: r,
    onDownloadProgress: r,
    decompress: r,
    maxContentLength: r,
    maxBodyLength: r,
    beforeRedirect: r,
    transport: r,
    httpAgent: r,
    httpsAgent: r,
    cancelToken: r,
    socketPath: r,
    responseEncoding: r,
    validateStatus: i,
    headers: (V, s) => a(B2(V), B2(s), !0)
  };
  return ve.forEach(Object.keys(Object.assign({}, e, n)), function(s) {
    const o = c[s] || a, U = o(e[s], n[s], s);
    ve.isUndefined(U) && o !== i || (t[s] = U);
  }), t;
}
const vQ = "1.6.7", h1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, n) => {
  h1[e] = function(l) {
    return typeof l === e || "a" + (n < 1 ? "n " : " ") + e;
  };
});
const D2 = {};
h1.transitional = function(n, t, l) {
  function a(d, r) {
    return "[Axios v" + vQ + "] Transitional option '" + d + "'" + r + (l ? ". " + l : "");
  }
  return (d, r, i) => {
    if (n === !1)
      throw new Tn(
        a(r, " has been removed" + (t ? " in " + t : "")),
        Tn.ERR_DEPRECATED
      );
    return t && !D2[r] && (D2[r] = !0, console.warn(
      a(
        r,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), n ? n(d, r, i) : !0;
  };
};
function Q6(e, n, t) {
  if (typeof e != "object")
    throw new Tn("options must be an object", Tn.ERR_BAD_OPTION_VALUE);
  const l = Object.keys(e);
  let a = l.length;
  for (; a-- > 0; ) {
    const d = l[a], r = n[d];
    if (r) {
      const i = e[d], c = i === void 0 || r(i, d, e);
      if (c !== !0)
        throw new Tn("option " + d + " must be " + c, Tn.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new Tn("Unknown option " + d, Tn.ERR_BAD_OPTION);
  }
}
const LF = {
  assertOptions: Q6,
  validators: h1
}, gr = LF.validators;
class QR {
  constructor(n) {
    this.defaults = n, this.interceptors = {
      request: new v2(),
      response: new v2()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(n, t) {
    try {
      return await this._request(n, t);
    } catch (l) {
      if (l instanceof Error) {
        let a;
        Error.captureStackTrace ? Error.captureStackTrace(a = {}) : a = new Error();
        const d = a.stack ? a.stack.replace(/^.+\n/, "") : "";
        l.stack ? d && !String(l.stack).endsWith(d.replace(/^.+\n.+\n/, "")) && (l.stack += `
` + d) : l.stack = d;
      }
      throw l;
    }
  }
  _request(n, t) {
    typeof n == "string" ? (t = t || {}, t.url = n) : t = n || {}, t = Gc(this.defaults, t);
    const { transitional: l, paramsSerializer: a, headers: d } = t;
    l !== void 0 && LF.assertOptions(l, {
      silentJSONParsing: gr.transitional(gr.boolean),
      forcedJSONParsing: gr.transitional(gr.boolean),
      clarifyTimeoutError: gr.transitional(gr.boolean)
    }, !1), a != null && (ve.isFunction(a) ? t.paramsSerializer = {
      serialize: a
    } : LF.assertOptions(a, {
      encode: gr.function,
      serialize: gr.function
    }, !0)), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let r = d && ve.merge(
      d.common,
      d[t.method]
    );
    d && ve.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (R) => {
        delete d[R];
      }
    ), t.headers = Yr.concat(r, d);
    const i = [];
    let c = !0;
    this.interceptors.request.forEach(function(h) {
      typeof h.runWhen == "function" && h.runWhen(t) === !1 || (c = c && h.synchronous, i.unshift(h.fulfilled, h.rejected));
    });
    const V = [];
    this.interceptors.response.forEach(function(h) {
      V.push(h.fulfilled, h.rejected);
    });
    let s, o = 0, U;
    if (!c) {
      const R = [y2.bind(this), void 0];
      for (R.unshift.apply(R, i), R.push.apply(R, V), U = R.length, s = Promise.resolve(t); o < U; )
        s = s.then(R[o++], R[o++]);
      return s;
    }
    U = i.length;
    let N = t;
    for (o = 0; o < U; ) {
      const R = i[o++], h = i[o++];
      try {
        N = R(N);
      } catch (Z) {
        h.call(this, Z);
        break;
      }
    }
    try {
      s = y2.call(this, N);
    } catch (R) {
      return Promise.reject(R);
    }
    for (o = 0, U = V.length; o < U; )
      s = s.then(V[o++], V[o++]);
    return s;
  }
  getUri(n) {
    n = Gc(this.defaults, n);
    const t = QQ(n.baseURL, n.url);
    return EQ(t, n.params, n.paramsSerializer);
  }
}
ve.forEach(["delete", "get", "head", "options"], function(n) {
  QR.prototype[n] = function(t, l) {
    return this.request(Gc(l || {}, {
      method: n,
      url: t,
      data: (l || {}).data
    }));
  };
});
ve.forEach(["post", "put", "patch"], function(n) {
  function t(l) {
    return function(d, r, i) {
      return this.request(Gc(i || {}, {
        method: n,
        headers: l ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: d,
        data: r
      }));
    };
  }
  QR.prototype[n] = t(), QR.prototype[n + "Form"] = t(!0);
});
const jN = QR;
class Z1 {
  constructor(n) {
    if (typeof n != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(d) {
      t = d;
    });
    const l = this;
    this.promise.then((a) => {
      if (!l._listeners)
        return;
      let d = l._listeners.length;
      for (; d-- > 0; )
        l._listeners[d](a);
      l._listeners = null;
    }), this.promise.then = (a) => {
      let d;
      const r = new Promise((i) => {
        l.subscribe(i), d = i;
      }).then(a);
      return r.cancel = function() {
        l.unsubscribe(d);
      }, r;
    }, n(function(d, r, i) {
      l.reason || (l.reason = new hU(d, r, i), t(l.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(n) {
    if (this.reason) {
      n(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(n) : this._listeners = [n];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(n) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(n);
    t !== -1 && this._listeners.splice(t, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let n;
    return {
      token: new Z1(function(a) {
        n = a;
      }),
      cancel: n
    };
  }
}
const J6 = Z1;
function v6(e) {
  return function(t) {
    return e.apply(null, t);
  };
}
function z6(e) {
  return ve.isObject(e) && e.isAxiosError === !0;
}
const CF = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(CF).forEach(([e, n]) => {
  CF[n] = e;
});
const x6 = CF;
function zQ(e) {
  const n = new jN(e), t = UQ(jN.prototype.request, n);
  return ve.extend(t, jN.prototype, n, { allOwnKeys: !0 }), ve.extend(t, n, null, { allOwnKeys: !0 }), t.create = function(a) {
    return zQ(Gc(e, a));
  }, t;
}
const hl = zQ(R1);
hl.Axios = jN;
hl.CanceledError = hU;
hl.CancelToken = J6;
hl.isCancel = YQ;
hl.VERSION = vQ;
hl.toFormData = Fh;
hl.AxiosError = Tn;
hl.Cancel = hl.CanceledError;
hl.all = function(n) {
  return Promise.all(n);
};
hl.spread = v6;
hl.isAxiosError = z6;
hl.mergeConfig = Gc;
hl.AxiosHeaders = Yr;
hl.formToJSON = (e) => bQ(ve.isHTMLForm(e) ? new FormData(e) : e);
hl.getAdapter = JQ.getAdapter;
hl.HttpStatusCode = x6;
hl.default = hl;
const X2 = hl, O2 = () => {
  const [e, n] = me(0);
  return _e(() => {
    const t = setInterval(() => {
      n((l) => (l + 1) % 3);
    }, 300);
    return () => clearInterval(t);
  }, []), /* @__PURE__ */ Y.jsxs(
    "svg",
    {
      width: "39",
      height: "10",
      viewBox: "0 0 39 10",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [
        /* @__PURE__ */ Y.jsx(
          "circle",
          {
            cx: "5.5",
            cy: "5",
            r: "5",
            fill: "black",
            fillOpacity: e === 0 ? 0.8 : 0.08
          }
        ),
        /* @__PURE__ */ Y.jsx(
          "circle",
          {
            cx: "19.5",
            cy: "5",
            r: "5",
            fill: "black",
            fillOpacity: e === 1 ? 0.8 : 0.2
          }
        ),
        /* @__PURE__ */ Y.jsx(
          "circle",
          {
            cx: "33.5",
            cy: "5",
            r: "5",
            fill: "black",
            fillOpacity: e === 2 ? 0.8 : 0.2
          }
        )
      ]
    }
  );
};
function Ji() {
  const e = zn(), n = bY(e), { currentGroupChannel: t } = fl(), [l, a] = me(!1);
  return Pt(
    async (d) => {
      if (!l) {
        a(!0);
        try {
          n(t, { message: d }).onSucceeded(() => {
            a(!1);
          }).onFailed(() => {
            a(!1);
          });
        } catch (r) {
          console.error(r), a(!1);
        }
      }
    },
    [t, n]
  );
}
const G6 = (e) => /* @__PURE__ */ z.createElement("svg", { width: 12, height: 12, viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 0.333008C5.44772 0.333008 5 0.780723 5 1.33301C5 1.70315 5.2011 2.02632 5.5 2.19923V3.33301H1.5V9.08301C1.5 9.77336 2.05964 10.333 2.75 10.333H9.25C9.94036 10.333 10.5 9.77336 10.5 9.08301V4.58301C10.5 3.89265 9.94036 3.33301 9.25 3.33301H6.5V2.19923C6.7989 2.02632 7 1.70315 7 1.33301C7 0.780723 6.55228 0.333008 6 0.333008ZM4.25 5.08301C3.69772 5.08301 3.25 5.53072 3.25 6.08301C3.25 6.63529 3.69772 7.08301 4.25 7.08301C4.80228 7.08301 5.25 6.63529 5.25 6.08301C5.25 5.53072 4.80228 5.08301 4.25 5.08301ZM6.75 6.08301C6.75 5.53072 7.19772 5.08301 7.75 5.08301C8.30228 5.08301 8.75 5.53072 8.75 6.08301C8.75 6.63529 8.30228 7.08301 7.75 7.08301C7.19772 7.08301 6.75 6.63529 6.75 6.08301Z", fill: "black", fillOpacity: 0.5 }), /* @__PURE__ */ z.createElement("path", { d: "M0 4.83301V7.83301H1L1 4.83301H0Z", fill: "black", fillOpacity: 0.5 }), /* @__PURE__ */ z.createElement("path", { d: "M11 4.83301V7.83301H12V4.83301H11Z", fill: "black", fillOpacity: 0.5 })), y6 = (e) => /* @__PURE__ */ z.createElement("svg", { width: 14, height: 8, viewBox: "0 0 14 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.75584 0.28607C1.4304 -0.039367 0.902767 -0.039367 0.57733 0.28607C0.251893 0.611507 0.251893 1.13914 0.57733 1.46458L6.41066 7.29791C6.7361 7.62335 7.26374 7.62335 7.58917 7.29791L13.4225 1.46458C13.7479 1.13914 13.7479 0.611507 13.4225 0.28607C13.0971 -0.039367 12.5694 -0.039367 12.244 0.28607L6.99992 5.53015L1.75584 0.28607Z", fill: "black", fillOpacity: 0.88 })), B6 = (e) => /* @__PURE__ */ z.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.2974 15.2438C13.6229 15.5692 13.6229 16.0968 13.2974 16.4223C12.972 16.7477 12.4444 16.7477 12.1189 16.4223L6.28558 10.5889C5.96015 10.2635 5.96015 9.73586 6.28558 9.41042L12.1189 3.57709C12.4444 3.25165 12.972 3.25165 13.2974 3.57709C13.6229 3.90252 13.6229 4.43016 13.2974 4.7556L8.05335 9.99967L13.2974 15.2438Z", fill: "black", fillOpacity: 0.88 })), D6 = (e) => /* @__PURE__ */ z.createElement("svg", { width: 16, height: 16, viewBox: "0 0 9 6", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.0285645 4.52887L0.971374 5.47168L4.49997 1.94308L8.02856 5.47168L8.97137 4.52887L4.49997 0.0574662L0.0285645 4.52887Z", fill: "black", fillOpacity: 0.88 })), X6 = (e) => /* @__PURE__ */ z.createElement("svg", { width: 12, height: 12, viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { d: "M1.49999 0.75L0.75 1.49999L1.49999 2.24999L2.24999 1.49999L1.49999 0.75Z", fill: "black", fillOpacity: 0.5 }), /* @__PURE__ */ z.createElement("path", { d: "M5.25 1.5L5.99999 0.750007L6.74999 1.5L5.99999 2.24999L5.25 1.5Z", fill: "black", fillOpacity: 0.5 }), /* @__PURE__ */ z.createElement("path", { d: "M0.75 5.99999L1.49999 5.24999L2.24999 5.99999L1.49999 6.74998L0.75 5.99999Z", fill: "black", fillOpacity: 0.5 }), /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.67161 1.55024L1.55029 3.67156L9.32847 11.4497L11.4498 9.32842L3.67161 1.55024ZM5.39651 4.68935L3.67161 2.96446L2.96451 3.67156L4.6894 5.39646L5.39651 4.68935Z", fill: "black", fillOpacity: 0.5 })), O6 = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzc1IiBoZWlnaHQ9IjI0MCIgdmlld0JveD0iMCAwIDM3NSAyNDAiIGZpbGw9Im5vbmUiPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMTU5Ml8xMTY5OSkiPgo8cGF0aCBkPSJNMCAwSDM3NVYyNDBIMFYwWiIgZmlsbD0idXJsKCNwYXR0ZXJuMF8xNTkyXzExNjk5KSIvPgo8L2c+CjxkZWZzPgo8cGF0dGVybiBpZD0icGF0dGVybjBfMTU5Ml8xMTY5OSIgcGF0dGVybkNvbnRlbnRVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHdpZHRoPSIxIiBoZWlnaHQ9IjEiPgo8dXNlIHhsaW5rOmhyZWY9IiNpbWFnZTBfMTU5Ml8xMTY5OSIgdHJhbnNmb3JtPSJzY2FsZSgwLjAwMDI2NjY2NyAwLjAwMDQxNjY2NykiLz4KPC9wYXR0ZXJuPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzE1OTJfMTE2OTkiPgo8cGF0aCBkPSJNMCAwSDM3NVYyNDBIMFYwWiIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPGltYWdlIGlkPSJpbWFnZTBfMTU5Ml8xMTY5OSIgd2lkdGg9IjM3NTAiIGhlaWdodD0iMjQwMCIgeGxpbms6aHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQURxWUFBQWxnQ0FZQUFBQlExMmNMQUFBQUNYQklXWE1BQUc2NkFBQnV1Z0hXM3JFWEFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFEV3YyU1VSQlZIZ0I3SjFwa3VRNHpGakZjZnYrTi9RZkg4TVJRMzlkVTFuRlpBSUV3RVhyZXhFelhSTFg1QUlDb0VTbC8vTi8vMS9ldmtuLzg5L1BSY1gvK3QvYmZNckNraEtXbEdzcER6QnBOYmtXTndscDl5cGJpMS9uNWFtYk45NHRhUDNRR1IzNnFNWmNRR3R5V1cyYmpEeG1UVmg0SEtjY01pY1k1eEgxSXpuQ1Q5UE9VVDNMSTYrc0JnQVlJS0pIU21rMklmMi93cjIzZEVJRzZYOGlac2IzdGZESUtmU25wZlNZL1h0Z2xkMnEwK0ZydWlVVUdkLzNSOVBkdEhnMTMrbktOYzFhNDd4RHlWcC9HWXB3QnlMcjE2dzFZMGFaUDJrTkdXS2E0RDJPMlRwekthOWVXclpwV1labC85Yng0VFMwVkpzVlE4cktqelZ0RWhHZDFlcG9TM25mR3VGZTJGY0o0ZkhqekxJSHZmdUQwVFFBQUplbmQ5M3hyc3VlOWJqWGIrWGRCTmlGTXlnQkk4cE81R21hTW85Wm5kQ2pGY3pJVTZQK25aSEIxMnNBRzVQcFExSEpjcHdQUjk3bUtMckRDNjdsSFgyT3hYdmZ5MGkzQXdBY3hhZ2FnYnliaHVuejNtTE52ZG9YWWJtOHBmaFNHWjdmWGNmVk1KZHl4aXVBVEZSUDdpbkNhUjUwNS8vOWI2U01xQ1hpMmJKN2pKang3bWxFRnd2b1JtdnFYZzlLWkIyT2lvcFYzcDFMTXVvU0c1SGJsazlVaTNmeGp2dG5Bd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJ3OEtlOG1IRHdRcHY2ZFhIcnNEbnBPanZEb1pzemZhVkdpejlTMWkwWk9meFNRenNhS20vTXMxNnNrMlcxc056SWcyTXRJSUEwbmJYcjhuNlpkdGZsMWx2WXhFclZ2M1BWaVhpSGkxSFBNVk5SV2pLT2RRTUdHVm5tdFBPdlBZZFFiNjA0Y0UwOHVpMjI1VlE4aDRDdDFqT2s2VzI1RkU3ZC9aRjEvQkFsRHBaakhiTmNEM1JsSEtRcWo5WXc4ZnByR0dyd0JLeFR4VWRzUTh0MTVNazdCKy9YQWQ0NjJZR08rRE5PSEMwRlVNdHZHZnBoQ2w1blNpdDliOWtQd0dHU05kTkk2V1kyTmE3eFNiUnNNbW1PU1dsN1pVY3k2cUtGU2RmZU1qMTUzQUJ0KzdjMVozcDlQUjVaWVcycklJNEI0QkZFUHFXUU85SzE4bnZsVTYvZFZob0xiMzVUaVNyOEVhK0tWNmxwV1o4UkM3UlZKK3M2K2xtSUdhdXN0dXFQREFETGdwRHdLSzBEMWt4MmVPUnlWVmE5V1pXKzg4akdKRW5WZlduVHE4N2o3ZWNMdnpPcW03ZWVReElUYlAvVnUwZTJBQURzaGJZMFdESVFPYlliM2ladmFWM2w5YWJFSy9PWTdZdUl1TEcwK3g2dFVuWEhlWDFuakd1QWQ3d1ROT3JiTHZLeHpBRE5yVDV6dWlJQ09oblowNURDWVFtOWVvUm0va2E2VFp1L20xS1dsajZTNWpaNGxTNlB3dFM2MzRvYmRSbGR2RlA0WWlvQUFBQjhnWjBDeTJCd0FRQUFBQUFBQUFDQUJUNGtBQUNBL1dIOUJSaUVTUVFBQUJVc0RRQUFBQUFBOENEK1NEZi9ubTZ5NUd0QW50ZXhvMGZEakI0bDh6Qzg1LzJWZUUvTGFMMHdycDJRN0gzeHU5Vzl2WWQ5M29vZVo0YlZ1Tmw1RDJ6Mk9BR052b0VPUEVQUGUrTEtGb3luRnRESzFNcGpBcGFxa3BSNGtZOGk3T1ovanB5MFVzZUwvaUN0TEduUlIxNUJCejNEV1VyN2RmMTlvejdSOGVkQTZhS2d0SFhhUll6Mzg5QWFNTlpKY3ZUakVDMHpmKyttOVh3VG9PZEV1dVZFbFljZUJRWHVSZlMwNGl4SDA3TE9qYXgyVk5rQlRvUG5aUFRvUVp3Umw1SGw2OVJNdFd4ODFPUXpRWFZkNHpsR3ZyenZJZkxEUnVteGc3ZEFtcEg0RHlPeWYrRGRxL0RHazY2dFBMVThJRWlQZzFJTGo0VDFiazdWOXhrQVgzam5hb25WZENQdXlSbDVsK0FlQUlCYkUzMHV4N29mMlVpTStyNU95MnNsMGxhbXpYRi8yK0lLaHZidGpjaXFxT1UxMGluV0F5aWFJNzVWcDFhOVdscjhERm9PdHJ5Wmh1TEgxMHlyK3ovSmhMcC9iRklaL2ZPeDBlVkVxK05IdWQ5eDM2cFUxYWwzTXlCOS9HSEVBd0E0RWNaUzBKMGZNbTg2UFM2a2xpWlFYbnQ5RVpIbm9UVnR3OEsxL0JacVk2cXVROXFWVlJqakdaNU8vUnlsZEw4TXErYlVoOW13alZWQktDSzhqekpDVkJUY1huUkVIT2RwbTdPZkFoOW8zcG9hcjY1ZzNlOGh1dWZSV3A0Zk96UThEMWRzVzN4UDB0S0ZIalJ2MVMrbUpnUVNBQUFBN01WTUxSek9BL29rQUFBQXdHMUF0UU1BQUFDQUh0QWpBUURnQXhZSEFBQUFBQUFBZUJMWXdRQUFjR1BldnBqNnMrYWQ2ZVVRN2VpRmJNVGJsSGlnTXZQVW5qS2U5MzRyYit2Ti9aR1RDbTVGZmFKS2NzYUZ0ZlFjRjk0VGIzWmF1QTNTT2JuV0FSdTlKeCtGaDFxUHdSMWRrQ1pnclU5VzJwNnppWWZ4SENTOG9tUDNPQUlJSGtmckRPeW9IUHZIZTJCMEhoaTJqUGZ6RURyT1UwaFRwcU5mUXlUSHZTUDk3dDREeXc3dGRxdUJ0UEVkT1ZVUjdvSHpSTlg2Mm5NWTRDdWVwUWN6eE9BSlJBL0hmTVh0TWFjOEIzSkc1MTNZbFBhYzlOOTdVbWlQcjh6cjBJaGlLUU5XUEppTzVNN1lpbnRsblByK1p0eVA3bWxnQ2l6QTAzbUdEdE9WNSthTU0zdWpyQ1M2S0p3WXk5UWUrWms5Si9aNzVuYmtJR3dBQU5qNlB3RmxNV09Sa1BJNjB0SG8xanFqeWsyUDhSTnQ0R2haVVl2WUU5Y1R6L09VMGV2djJTdTZsbWMyd2czclFyV2JBd1A3eDA2dU1yTytuUG94WlBONzJpd1ZWS2NOanMvV3NPOFo2Z0FBVjJKVXZwMUc1N2tmbG5ycGNWTmJlVnYremFpL2NoWXBWNy9qKzQ5VS8zQ2xBcm5JNXkxZWZjMlloYWZUdTZtaHFmVDEvT3lZWTFyUi94amhFdFp6c2RZMUlzS0I5aXlRdGRjS2JucTlDTjdIZEZybE9aZGR0ZXhlZmVSMlJKNHgwT2dWV0QzUE5keFVYL3BuQXdBQUFJRDdnckVKQUFBQUFBT2dUZ0lBQUFBQUFBQUF3RFU0d3BPRjl3d0FBQUFBQUFBQUFKN0wyeGRURDNzYnV2VXBGZTFONGVnSmphQmlIVDQzZW1wUFQ5blJBM1I2RDZlT3BqazlQZjV1clNFZWMwekNBVmluS0hqYTNIdllKLzBIVzF2R2VrNWwwZEpPeFhQc2kzWEsyb0x4SGwwamUrTk1SV3BMN1FRVzc3RTlMVGxsSFFnTXNBaExoZG1VY1BkSlVlbjlYaFlTL2h3NnpkZy9EejBuWDFuaDlPOHl6dEMwczA2cjNZVUpwMS9DUTFFR3N1ZERCZEVpdEh4d01jQ1ZHYkVMdmVxRmRRcHhxNHpVaWlmWWg5YTgvUGl3U3NzdWxKVHhsbENKSEJFcjRYRm9TSEVqOTF0MVNzWTFUTVhyaXFqRFBIbjJybk9lb1NlbGdRWXo5alEwZjVjbFBMM0NWU3JESzF1a1BHNUE2Z3dYbGlYVEZyUGkxM0Y2bGlGdnVLY3NBSURiWUJsQ0xXb2pwY3pMYTFkRXl4bG1SSHZUVmdYTmdPamQxWkRxbUJyM3RUcVZjYjJhdFZhRzlQY3JucFdYaFJYUG8xbk13Tm9JTlJSRDFlak9lalpmWHkzTm03cjU5RE9VbEhDekdmSnZPV0w4TFA3NVczaVIxaXFqN2tkdlYybEREUURnakRRZHRKdnV0L0NHSXdmZFdJK1RhWnBRblVmazBZRVp2b2JXRUlvc2lSR05UdjE5K1QxdS9VTnlwVWFvS0tvQXdHT0ptbDVhK2xhZXd1V0l5ZTJwa21VdFJiY0ZIeWN5ZWplNU5pRWQ4bllZell0VFhtK2Jya2YwYmhNbG8wNVNPbTJadFhTY1RRaS8xTkR4S0ZaYklPeVZwN1h4Sk9YVGNzZGw1ZnJtOE1WVUFJQ3JnaUlKQUJHUUdRQUFPc2hJQUFBQUFJQlRnOG9PY0gyWXh3QUE4QUdMQXdBQUFOd0pkQnNBQUFBQWdHdUJEaitGUDU1SXRQVzk4UjY0NERreHFJenJlYm03ZFhpRGREOXlPSVJWaDRlOGZQNkxkUXFSdHpPMHRJOXIwQUZHanQ5NjJPa0pzRC9SUTNpbUY5d1RaNGZLV2lMVWMyQ0tGVzhhbmlOMFhtVG5mZTJFeGl5a3NjcEdmc0Zrb3ZQeWRWLzdLcFY2aUZINnZtWU1uNXZvaWZ0VytMWWh0eGJnT2FWVnVsNUI1TFRhdy9HTXpiVEpncEZ4L0N5c3NlSVlTNk5tUGtNTzdrUkUzNXhsLzBYWHdsd255a1VhNXduOFAyVlZoYWtmVUluWWhiTVc5UmtPYWExeFBYbWZXbEc0SDdWdDl2cDN4QlV4Mm1XUk9jN3dHTUJ5eEcxSytJaU1zQVJ2OUdoMytHQ2xDTFcyVFR5dVp5bStaOGdBQU53Rzd5Y1lMQi9EcHNUenhJa0s3S2w0Slh2TEVFckcvVldLaExxcnNZMGJTdHJuSDdUMHIvRFdhdXBWOWl4bURCalA3OTBhOTRTOFRMM1IwUithWWY0S2E0VkxaV3NHLzJmQlJWT2tJaDlsWE9kTnVGOFgrcGxNQ3Y0WXRvZktBd0NBSUZHZjZLbDBvSHVSZzllZVBIcmp6K2hXUzJ1S3F1ck5QWTMwcmlxVUtzRldxQjhwV3RsWnFoL0ExZEEyRTdJdldiWjgzV1Yrci9tWjJtcDF2VS9pa1JHdCt6UFNlcGJLdE5rVzZXV0o3RTFLRFlGc25jcW9IaEhSSWRLMlAxRWQ1M1pJY3lodi9icTU1ZkxLMjFwRjhZVHd4VlFBZ0t1Uk5nQUFBQUFBQUFBQUFJREhnV3NVQUFBQUFBQUFBQUFBQUFBdUFac2FBQURuQlBrOGxhOHZwcVlrbjY3d3VyLzhEV25wS0FQdmNTOWFPbmdqY2xxRWRncEc1SlNNM3ZNa3JRTno2TjRCdktkdzlVREg5TkV6c0pGOTBJRzJCclFPSXZYa1ZlYWhuYW8yTkRTanh6Tk5LZlF6T3dsTFRaSGlXbVVzWGZNaUJ4MUg4bXVoSFF3TnNCanZRVU5aaTUvRlArVzRkZVk5Y2d2MnAvY0lNL1N1WVN3OXdudXE2eDVkY0ludTl2cEx5cmlNMzJmZ25XeGxzT0lidElxd2xqeUdIdHdKangzWVVpTnlJSjFuN253Y3ROa3krRGRURlB6S2dLVGM5NkQ5MEJrR2J6YktzazRnWGVsNG51eUxBSjJvajJWbHQvUitxZUR4UkRhcnBEVFMvUjRIblNVam9zWktpeHZMQ0swN3JmWExpdE1xYSthMlNoM3VHVktJZkFDNExVRmZnaXV2bHM0dWhWK0NpR1ZYMzllKzgrSjFTTGVNTGEwc2J3TkhueUxTd25OVkJ5bWR0Zksybkp1enNaUkVDZVBUUjJwM2ZxZlR2bmFhcFR3M09jMUhlUDFIVXZLdXhsU1dKbVdkWjNVL2ZhZHJwZTJoTlF5MHFRTUFjSGE4RzU5V09oaG1oUXZZeXRQcml5ai8xclNuVFNuN0h5Rk1TN05aY2ZKNzN2Vit3OC92MWZZYXRZb3pqdUdwZEFxY0hGMEROQlcrSFhVYW1sbnZWZUcxbjJ0ZFA0SmU4eDZtNC9GYWVOSzNQQkRST2VMZDAyanBLNWVjVnlON2M1WUxLS293UnQxNlpaMXVxdStiWDB4TktJWUFBQUNQZ0NVZnBzT2dBZ0FBQUFBQStBTHpDQUFBQUFBQW9BSkRDZUNDTUhFQkFBQUFBS0FOVmdNQWdNQ05oZVBYRjFQenlKRXBNM2k5L2R0ejNMdzMvT0dVTDMxYlRiMFY4U0wzSTNoZk9wOVpCc0JwOEp4MDRCM0FESFJ3NEZrRGVvZFN6N25BM1lYc3FKRHRXYVMxSms1alJzZjNuSWdOc0pqUkpmUHRjS1RndUQzY2pvSjlvVi9EakpyNW8vRWZpM1FzSlkzM2JMSWpLTHVUQUVBSEs5dzgyUk9oUENrNXFydjJDSUk5aGNjZXZ3ZE93eGxjcGVpdVFWcEhuWHMzcWF5OFo3SnlrRDFrTUl6dVBYcmpyOWlqaklTem5BREFZMWdwY0wyQytIWVBha1ZYdFpGTzZEV1lyTytBYUp1TkhpL3dpcy9DalpiZHcraW5qN1Q3Q3daODl2VGZWMFJIdkN4RWJXMCtKeUcrVURmUDF6SnkwYzg4M1E0QVZ5UzYvSHJ6UUNhNjJjT1hNQ045UzdPUlhHcExYV1M5RGh6R0pjQmNwTGxWZjMzUFNLcXg4ajJOV1JicEt3elJJa0REN01ic0xhMWU3MGRQdUxYWGNlc2gxS3ZMekloZk5tNzlBa2NyajR0M3lKL3RMQ1RqT3ByUENxMzc0dlM4bkxwdDg1djBiRjN6dUNHajdTVjRmZEN3TDlKRDVRQWRlTmNBbHRINW5HSWFhM3BXTnE2OWVlZkdOY0RPV0k5TmFHbXlPK0lXQitGNkRwQlB1eUxwSFQzemMyOXU0M1Jqdk1OZkRKMVBlNDRoTzdLMGlyRFNNVHpoaWlRamJHUmNhK3BpdHhwWkxNUi9uL0VzZGQxa1BCdnFZdllQUmw4R0o1WnJlOVVRWW1nT0lEa2lMYVhiaXArTmVDczZERG5sWW1UdmNVVVRSNWNybGljQUFBSExXSW5rSWVWVGh4L0dGYVIrNys1SE5FMlpUbnBpVHVwUVRRdFl1YUZpbFQxQ3ozaW8wbndZM3ptVS9DZVAzTk9HRnRWTG50bmJ6MEllUmhIMjgwaDVhNytjV2prNEFBRE95T3c5T2UveXZXSUp2RG5XOGpTakczdTFpTWd6Zlo3OFhubk5KdTFSQ01BZDhUNnI2VFdEeXV0Q3ZUOTZTcTU2MytTMlM5NW9nNkVMN0labnE2dkhTelBLcUc1enV5RWsrbGEyWTRTajluTHF0dDFXanpydXhWVEpqelhEVDRtaSs0TWxMTHhOUHJ0SlBmTjd6MjY4M1pEUmZwQWx4Smc3QUxmbkpYODlXenVuSkUrS3M0RFcybmJLTnMzQjY1RzhBRTdLeDJITTNqZHhlb3hWNXNWK1dBODVuTUVUK3hCYUcyaEhkb0g1SE14MmNscU5pY01aRER6UHNmWHNkYlhTc1M4TlQyRjBqRSsxSjZXMVFkS0JSZ29kMlNCOTFVZTZmd1F6Zmk5Q2JocTlmcXZWWFlBWk1ZaFhaN1Uyclk1Nk14bmNSRXlTbGU1SjYzNDBId0NBUnpORHlIcjg3cDUwUzMxZlYxZ0Y5cWlqVlViTHl6dkxVZW50K0pZSGVwU2V0czdLNVVDL2ZTWDFibDcxNXQ4S3RKd0tIV1YvbEpuMEozemZmai9PYndBNE1iT2N3OXFiQmRwU2dHZ01NK0o3c1BLeTd2ZmtaY1UvZEw5YktTVHlVWFNBUjVFSHIxOW9MemR0My9Odnd0eXpaSXducmZlK3hlMnRnVkdCamF6ZGxSbDZ4RjdlaXpQVTdSQjJVWUlDV1B1ZU42UDlZdXFxemR6YU56amlLMlREV2NUYnBMVXJzVXhiRTJucXFHdDBwQnZQOG9EektXQWVYSlBvNVBMR0JSRFk4L1MwMEVONzJvT3pXcHd5Zk1GOFNCM2hvZCs3bldRNjcxa0o1QmNzSWlyWFh2em95N254Y21wUzhraS9hZUdDUkkwVitybWJsWThHOVhENXJ0UjhLVnQxSHlBd0RscnZPU1ArQU5xMFRCenZITkx5MEo1QjJwVDRZb0RtZ08ydGhJZFI0YkduTTJMVUlZMlFuTTRLdlhIbG5nWkR3RUJyL01pbTFRcG15YWthQmtSNG1Sa3RaMlI1WWo0REFBeGcyUStiRXQ2SzZ5M2pVRVlOQ0E4amplcWwxd0E4b29NOTdiYW5CN3JsUmF2dnpTNDZWUnRTU1kvM1ZoV2xiczBxVjIzNlZYYVphQ3NTQzIzdWZRdWxycXZVZlc4dnB3SUFYSmdaL2xkRTRlRkVYVXJkUG42RGtUcDQ0cnFkcERQMkV3RGdFMHQ0Yk84cWQ2Ny95THBLUHZKeWFHOCtYaGVDSncrb29HRXVRejBQUE42TFZYcUV4bDZlbFZNVDFXVmFuZUoxVjkyc3NZLzVZdXFyc1JHS3k5Q2EyTnA4WFUxdnQrY0ZlZDRHYndOZzlKMmZxQWNENEU3MGpQOGQ1a3V0Mkk4WXlWcmVBSEFzTDRmYzIvNTJyVi9sdDMvZ1NxQmZ3VGQ1TVB3VTFJNHJLUnhnSnhwN1lXSThnQ2N5VXcxeDV5UG9zbG02bmxwb1I1bzhtTDRuNzk1NHM5T0N5bG0zalJUekVMeWN5U1pEWDU2TzFyMGpydDQ5OU1zOWxnb0FBTGdiUnhnUVYxMzFTZzFhY21qT1Zzb2ltc2VxT2t5ZzlYbWp0NSszYzkyYlRadjg4VnZ2UEVzK2IzUjNBQUE0R2FQYVVpUzk5ZjdDVW4vRjdFME4xblNBTVFTQjRIbjJaZWFleGhuM2JSNEREWDhMTEhQNHlHNnV2VGNNdVFBMDJBZk5GMU9YZmdFb2VxcHdORDQwalJNSjY2MTY2eUNjTEtUUjh1bXQyOVlJZitUY2JqWHE2REZOVmx6bVhqL0pDSk1tMCtzKzdRNFRrZloyb29kOVdBY0hoRUJKMncvdFNCMUxHZkIwdkxaR0lMOWdaOHdYeTZWVDViYmk1ZFJOU2RnaUtreGhQa201SitsUmxyeUtIazhHYnF5bW05Mmt0M3FlcGZYa3Q1VnUyeGl2VDZPU1o2bTZYNHJHVkkwdFMwMjAzSGNNTmJnalhoV2h4REt0clBoZFNMcHMzajQrUnFKZTkvZ0d2YjdDcUZEeGxPMkpIeTBERHNPYUc5SDFKeExmczZjeDRrdTdQUzBCVjh1bDJ1ZGR4L01hQ3BZL0s4S0lMK3poMUNaM011NmZ1U2xIWEo4QUFKZEhXd3UxY0k4QzV2V3paNk1NSzk1U1JsYXczbFZqendjMzFCMlVMWjVIbVUvZTNyV0NNbXhtMlZhYW1ZUEZVRkovdml5YTVmZ3VvN3ZNSzIvK3RsR2NnRDFOK3pHa3RFeWNiZXZSMmFWaG5MZWQ1em9Bd0VTaTZvUDNlUjBwREc1QmRDbjArbEQvTmVKN0tsWHZIMnhWR1pZS0R3QUc5Y1JWTmlycVBiMHkzbzhwOHA1RWRiOTdxMVRuMThwRHMwenhvM2JnZmZZSGJvRmw1V3ZYZFhwTmhFaHE2UjRlbEZOUWIxSko0ZHZXbHI5V09zTlZGTjRvczRUdHlmbm5GUFZHU0Q2Q1ZqZTM1cWFYUnlvd1NmbTNoMGdub0MydTVUR3JQc0Eza2haOVFUbnpDTkdJL0llbndGZ0htTVlaVk5oYk9zOXFMTGwxVWYwSzFySmliakRVQU9hd1lpN1ZlZjU5eHJWOEhqWlVadS9EVUIrVjJNYWUwd2JvSkxxM0tGMno1bldTakg5SG9FTU93OXJTT0Zwc1I3YStQS1lWQUFBSTlDcFlwMmRFNnh0SmQvU0tjOFRESXhmWHNLZjVaOVA0ME5IS0dsWjJPaWF3MXcvQU16SUFBTDlnZU42Q0dkcFVhMW5mdHNYYWsvWXMzNGllQVFEZFdMTGdoMHAvM21OUEE1VjlNcEtzVFVZNFhBNjZEKzRvUEwrK21QcHhLb0xub0xiWldLY2RXdGVia2g3Y2FFMnJ2Wnp0ZWVGYkt5T0tsUzRiY1Z0K3pjc1BsV1JjVyttWUsrZWtGc3psL1cyajM2Q0x5SkRLem5CdmZtYWw4dFovMmsrOUNFeWNINXFJemZ0Vm9aL1c0bWgxb0NkZjZWaXRIcVVBZVFhZGFPYUFKYjgySzd5UVM4bTcvNCtYN1R4WWR1SXJUSkpYMFpPd2tGOXV2TGJteXFYQisxekxaYnExZGp5Ly9zVWVmQVpSbjVrbTc3Ny9yRjlPazRyU2l0Nk1vZ0R1aEhWUWZWYkNKQ3cxeEtxRFp0K0hkTmNzWHNZbWRQUm9aQytlT21nMjZTZ2U1ZUEwaHYvejZOVWZwVzd0M2RQdzdKZDQ3dCtPaUYyY25OZlppS2M5Qk5mVDZMMU9ocDZ5Ympvb2FsTzd0dnVrK050bTY1ZGJGVThxVTd1VzRtL2IySG9MQUhCYlJuMmxaUnpMLzlyTGFQckQ4Rzc4anloQlZsbGVlbGRCajJQU3F4V3NSUE5NejJBMHI5UU95a0laNmlhV1ZwZHFyUDAwUSt2cHIxVFZRUTZlb21CWlpRQUFYQVZyWXlVcjkydHhqUHpyWm9ZYnA3VXMxYjZJVnA0enlueWx0NFpFUlAyV3lncTV0Nm9mcHZsM0FLRENhMnRISnBNeEFhUFdUOHNDamM1MWI5a3RxL2dSY2tWcnFGTDRKeU1jcHJIUy9DM3pqbmhTbkZiK3gvMVdtcnFNUytIcGpKWjh6VnRNOFhtbGk5WkY4NVZhZVYyVVB4dkFqdFJDMUNzb3JXc3ByYWN1QUFCUFFuT096U1JzNjFoZXRWZWMxcldVcHBOb2tRdXFNSjhWSFkxQkN6Zmc3d3M0WDBPNUdNK2VPUzVudGdHQWs3TXRJYmZZSkh2cFUwbTVMNEhjdWo0amc3WWFMNjJoQWdEbklyeTNVdTl1dmU3Tll0VTYwN09KTkV1UVJSNjRoNlZvS3M3ZWpPNDNNRndPWU0rQmM0WkIrbUNpZmh6MkR3RUE0Qmk4bW1MUFNqWjcxYkxlcE5tSzY5NzZXNDlMM3NKak81Zlp4b2FhcnZFMHdWNEd6MWtNUVFDQU0xRExRMlNqbTlGbHkzb0hxSFhkVzJZazd0NStpM1NHU2dCQUcyR2lNazB2aExVdjJxTURZRnAzczhyOGxmU0wxZVl2NW5YRkVTOU4xQjEvNHc3NVU3dVV2bDdHM1hzMVV2eGFabHpwR3NKb2I3NnZjbUZyejh2MjVvbkFERUtEblFmUDNvdjNaSVpWRXhkdXg2Z0lHRGxveE13MFVzakJhS2N6bmFMS0xiMUtlOU5XdTYvbDB5clgyeERJSytqRWVvRThjdHBhL3Y3RCsyWFVyM2pTSEdNOG40Y1JlVVUvTHNlN0xHbnA2S0lHUFNlendYWFIrdHQ2anE4aDgyYnBzcFk2eVZBRWtQbjMrOTlhcDMwaHpSMXIzcWJpRDhuZm4xSTdYYTRtN2l0K2FPOUFxK1JNb1hBYVl4eEdrVXd0NzNhUk5hU21QNis5YmF4dFVWcitxbGJjVnZ6V3lYS1duMHA3NXI1bkVFVUhnWGZnWGdqUGxvWm5iV3ZSYXE3b1VvRE9DZ0JRNEQyWk5TTElMZityeDRkYnh0ZnFjQWhuV1MyOHExOVU2WW5FS3pza291eU5sRG1MRldWNEZjcUIzL214U1JXY3VEOUY1ODk4ZjVLbjM3aFp5UGRuUTYzNlBhcS8waGxQcWljQXdOM3hQUERnMFo5bUxNUHdnL1FJMnd3WDl5eS9ScXU3SS82T3FQcS9LZnNEU1Z2aWNhNEF5UFNhQlMxQjVHVFVGTGZraGljdjZFUjZXWVkxLzNSRXVxaGMrL05tUHdJMHNxZGhiWmRka2g2L3BiWFhXS2ZWbnJGdjFjZWFsemVmdDN3eEZYYWpSNkNobEF6Z2VSc0R6a0ZMcXdDQXkzQWFzYnJDZ2tCT3djbVlPUnhUdmNmKytrTW9KUGQ0MlFEZ2xOeCtPck4ydzg3Z2dnQ1lTK2g1STAxM0xTOEVPMUY5d1RRWjVmVStKYk1LQk5CdGFKaGloM0dyVGRxemdJNEtDNWkxOThoOEJ3QllnUFplNUdVNVlyWEl6bnZTL1pWZTBGNWpUTE40clNmOFVDU1hEYitXZjZEZU9QdHdOaGg1Uk1vQ0FBQVp6d1B1TEpYVFdPWDY5cnpMNEtIM0dlekk4RWhhSnEzN2pEK0F5MkpONHoyWG1Mb3NSRXVCWk43VFFLY2lhdTZlUVlXN3pSQmlQcHlDdHhkVGQzZWhlZzdYWXhkd0twTFAzM0wzUnR6QkZyMEhOcXlRRmJjZVlsSkhXejkwWmtlREQ4OEpaNzNlRG1Rb0NQVHMrNjdjcmpUcFhUUjJMRkthYXFuanVzNWptRmNobHVmQXF3VGtiVndlYWVFQVFheDU2UjFpMGhlaTN2YllOOTJwcjM0dGl2WDNXcmdIU3pBK2ZORmE2NUp5MzVQWGFtN1IzWjVqOVdvWTUvZkFxN3grMC9ycW9iWUdScXZDa0lJN29KbFZIblBKTzVlQzAvZjlwZFR2ZjM4K1dtSmtFcDJmYng5T3FmTDZEQ2pDdGZ1anBHQ1prWHkzUlhtREc4L1FrdGh6VDBNTFo0Z29hQTVKN1g1NWJUa210VTJ1VnByNnZtYXNXT2xuY05OQjA5dVUwYTJzbnVhTGxsSERQQWVBVzlLNzkxTmo2ZE90UEtNRzBlblowNENJV3AyOXEyQk5qMGRYcTROWElXczVPOCtnbFgrWFhXOGdmV3dvVlhWTUFZZWR0LzgrbWtQenpEdEl4Ui9aVTVhYWdVTCsvU2RkYnJJREFNVHcraUkyNWI3SGx3SWg5dEFnSW1WSTNlaFJyejFsUlBjRHRFVEo2L0JoVEFLMDhXNXFPTlhwTXU2SzZXZTU2bXNzVVdFOW9vb0lhVkM2QVR4bU1peGpoaDR4Nm9XeFJFVlcvdmFrT2NVUWlqU3k5Y0NHMTVWbDZkbVdBTlBTWmtlZUY1KzN4MzR4dFJTT3NBc3ptM3pQeGI4MTMzcC96KzJHWHRraHRlTGhUUThBdCtieXkrNkJ5cGZIbVBhdWkxRkRIUURXOHpGL05iM3FGV3haK3dBUVdodlB4R1duOFdqRmtWK1BaSVo5d0pJSXNCWnpMaFVMN2pTZmIyVjdOL1BOays1SE9FTHdJTlFPNFdnL2xxWEwzbVNQRU9BeXJGeENldU1CQUVCQnJ5UHdsc3JVR1ZjU3J5RTFROHVkWFpiM3Fkdk5VU2Z2bTBBRFJEZUM4d0l2K2d5N2VUZkY2YW83Q1FBQUI0REluTTRlV3R1SzVYY3B2Uzl0ZU1NQklJWlg3aWM3aVdZVndZVkF0cDZLVWJQNXpOMTVtNkcyeHcrSnlPbWI2L0xpaTZtN0xqcldHNytXQXVzdDQyRXJxT2VBSks4TmtEdkRab0FDNUVUeXc5Zmpma1NRU1huUktmMTRUa3NZYldQNkJ4VHF3ei9xNWJZMVBLRXRTaytqTDBxeVB6dXZ0Ync4QTBHVFd3d2VXSXlsNjFwOHFGR2FYdlg5VC9sU0tsOU9QU0VlSThmU3N6UWJGY0pFemZrOXA0NVYxcVdtc1ZUSkd6dXlvTURTNFJ4b0IvUkZ4NzdsM2tPVXdwV0pxQWIxbk9vZCt5RVRMQm5oeGZWVVp2Z0tWd29KNzRNeDJVaUhBTnNOYWJ6V1E4dHJlbzEybTJRV2VtSHRtNERIcml2ajFVaWQ0RlY2ZXUxN092NERiemZXOFVmUWxxUFI3UllBZ0ZzUkZZb1JKNXAzWGRXdW80dkhMb3dzOHQ3R251bXBiRDErTElWSERTU3JUSStoMk5PbTFzdXBveXQ5cTA3UlNkT2pZT1oybVg4M28xcGZVblYvZGJWM2t0VjFxZTZWZVVZZlNQTkhBZ0E0UDE0Wk9MSnNJVEpQeHhtZXQ4c0RoYWJpajc4cWhEZHArdmdEQUZ6MGJHcDBxUGVSdlkwVjAzaTJPNzFsMWQ0Q2EwOERia2xybm83TWtUSjlmVS95UkZqdXVrUFpRMitPUGp2dmNldG9lVmdkZm5IKzJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFISWhmVE4zamxCYTFRTzhKeUpFRDhIYi9RY2ZUYytDU2RSYWlWWjduN01OWnpEeXY4QmEwNW9QMnB2N00wMDNMTkErY2IyRTg4a3VTZFRNT1ZJVkhzWEo1M1dXb1dhZUY3RkNKeHNGU2IrRjFuSllJUFVSVWV0c3VvbCtWYWZKMndJOENhTlB6VVpOYzNYZ2RLcDJVMHlIclE2Yy92cURLdXJ3L00wNlJvNyttNGptUFg3cytnZ1BValRoMW83Wk9ZOVAwS09UVVBRZ2VuMmpwdG5VV0l5YW81OUJBZ0t2aHNROW5qWEZyVHJuektCSmtwMDcwb2RPT1ZFSkw2eFVlV2w3aGhqRHlhOVdseDA2R0xpUmZTbkNwYytYZGltT1Y3U21QSVZKaGRXSXJySGRQUTZMWHllbE45L0NPSDFrYmU3c2dnbld3ZFIydkJsMFdBRzVGVkpqbHdmQUlscUR1em5URXd6R3lPbmlWbGw0anE5WmVwV3RQUHRzVzgrQlk5VStOdUZKOGo3V3Q1UmY5bmRwMXBCK0REM0NvUm5ZclRaVjFOc1pTZGxwUVpuZG5PVTF1NUdtaFZTMnFZSlZPampSRk9BQUF6TWRTSXpUL1JtdXBnU1ZvanhUTVZHMUhmUkZTWEhlaFBVbU10TW1yTGx0NzBnQlBKN3FwWVVUSmhSbFlxc20xZFNqOTI4cDMyK1p1MVpYcHlyd3RTODI2ZjNsYWplM1ZEOUFqZGlmcVNlbnhBczNNeTF2VzdZWk83eVp5eEVYV3lyT2xNOTEwbnZMRlZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQnc4V2M3TzVIRDhSNk05aEoxZmI5MUh1SElLUmpXUVRnYTBRTnpSazRKZUR3cmprbllkc2p6VG5nRzlNZnBsMXRmR1FCYjdBU2hVNTRPYjYzOU81d2EwbHZFb1ZPeHRkaTM0a2p4UFBTZUxBT3dDRzI0bTRjUUNXUHo2MHVwVzJQWVZwbG5xekp3REpyT3BZWEJGQ0puekZzYzBWMm5IaHJhNThRa2hlNFVTaDBjUmpVbWtuRWNzelMwSmxjQjRGSm9Kd25YNFZKWWVUOHluN3k2YkhudjUwUmtyZERxd3lqMS9mckRLMTFmU3JWK3BPVThqaHkvSEhVOFd3YUI5MHNGVWwxZ0NNOGM4cVJ0MGJPdndOcDFJQkhCNjZGSGZuazNxUjRxQTFybTlXYUVaV2VlbG5odTBkc3RsdGtFQVBCSVJqLy9zQm54UFdWUFlkV2k3ZG5vMSs1YmRlcFJQSG9mS3JDVW4vcitWb1Y3VjNpSjJidXc1ZjEvakxnUk9nM0FueStsMWdHT3ZFVERQUHUvWHBvc2cxOEpGNHBzS211NXZpR1VvWDBDU1RNSXRmdXB2Z0VBY0dLOHl5Umk3VEFzZjNzcm5pZXYzanBzUWgwOGVXaXFlOFNub3BiOXZlYm5laSt4dW1ZOEEzelRhVDc4SlBlbzZoOTY4bmVhbi8vOXhwTlVlb3Vac3MreWJsa1N2NG51aFNCekQ4VTdqblBqZXJRTGUvWTBGRS9EUi9qdGhwZWwzR1VsL29qTEs3cVpkcFBHNTR1cEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPRGk2NHVweWlIcVh3d2MzR0RUZXZVN2VzcDZuVS9ybFBnYmtvTDNlL0plY1phZ2xyZjFleml3M2lCeTVFR2RKaHZ4WG5FZjM4Z2RlRTZEdEk2a3NFNmJuVGxoNGZhMDVMRzJMTzg2dEt6RlljZHhyN1dMOUZVcEtVNXJtdTlDcjBMUWFsdnZ3YzliSXcrQUNVVE5Ca2wwcUFjY1JXd09MWFBZbDhpQjlKYkFoaUc4WDgxcHNWTC84SjVZZHlwYTQ5dHJWRzlLUE1iKytWaDVYS0l5bHNwMVR6SkZjeFcvek90U2N3bkFpV1dDenZDNzFubDc3Ny9LLzFrQ0JMM21iZDdtNHU5Ni9tcW5MODlZSTd6Q29VZVBqaW9VdmVHdnNqUjlFb0hYVGMrZVJzc1ZzVzMya3RjN3JGcytOSWJBUkN6ZnR4YmZxZXRzbm8xUXkxQjR1UDdzNlNLdHFiM3oxeEx2dlYvN2FQbHZOK1crWngwR0FMZ3RvNzd2MHd0SnIxWVhXWGswUXlGcVFIanFFdTJBMFUyTjFpcVpHdVZKYUczdVhhR1RVcmFtNEVscEl3UFUwZ2kwSXBSMEgxOVM3UmtUNmZlZjNBZ1BLY3hsMnF3N0NXckZxbTZEK3ZkOUZGVTVJellobnFVUUFnQ2NIV3Q1N1pWenlNcHBXQnFCeDdVVUxjTzdkOTdTOUZMdzJySGltM3g4Z0wxSUx3WnNWUVRHS2p3TnI2QlFoSVJucnk0cjVYMnAySVU2SGpYalovSmhOaFQzeTdwRVpPVXRpR3d3NFlBK0RLdnBlL1NJMFRyTTJ0TW80ODFTVVU5QnExT2tINm9wZTFvZW5ySTFXZ0w1WnZxUytjVlU5RUtZRFdNS0FBQUFBQUJPQ2NZS0FJQUtJaElBQU00QTZ4Rk1oMEcxR3pRMUFBQUFBQUFBQUFBQXdQM0JGd3d3Qm5NSXJzYlhGMU0vWHV4OUhZQzJMY1p6REl6blZJQVN6NXZPRDBZN3BWaUxJMTF2SGVucTB5KzAwM3BtbkhyaGZiSDljVmhIRzh3NkZCSStpUXhzN3hGWTBhTmtBQXBhOGxtS3MxWHhXL0dtRGozdjZZRXpqcXB6VnNXRDFaYXpEMXh4MGJ2QVdwV1JLdDE3OGhkQUo1NURoMXJ4VS9XSEpDTS9BcFlLUHhqQ09pS3MxWSthck95UmhSRGlDQlhXVWpOTzJaM1crSDdSc2lNMklTNmNreDdIU1BCbzBkeWp3em5qZStZUy9ocTRHbDVUdEF6M3FoR2JrcmRiTFJHY3Zya3FLQ21GWjAxMmVCYm8rZ2UzNnVVaDJtQ3E4cjRUQ0xFbENNUDVneEhYZHBuZTZ3OTdwV25ONjB2cWwwZmc2V0FwcmhUZnN1azg5bDhVUzk5NmFFZDdWRmZ2bGtZZHY5WEVYdEVmN2Y2ZVBBRUFMb3QzNDY4TzEreUhWdHBOeWNzYjM0WG51eGFybldmV0JuK3ZJdUZaQlRVakxXcGxhdkhyY3VxbmdMSWpiWjNINjk5L2xmQVdkZG1SK0pzempaWkhqV1ZrYjFYNEsxb1M3cWZmZjhyNzlZWlZydkxReXZpb2FsWG0yM1ZXNm1DTklja1pzVFdjRWRXdEtmTWZBT0JrV01abzFEbU1yUHdnNmhMMitDS3lVa2F2MXFGZHQrSW41VHFxWldWSGVhVWE4WGZKTjEzMGxpckxPQVZvWTIxT1dCc04yNmVaOEpaRmNmL3ZmTTFiZkxwR3JDVXBEMG1XbG1GYU9rLzRaYkVhZGVTWk51aG1oUjdSaWwrV2FhbUZ2WHBFYTZoNVZkRkw0dlZMUmdUVXpFNTZ5THpWdjVpSzRBSUFBSGdFTFBrQUFBQUFBQUFBQUFBQUFBQUFBSEJOMlBFR0FBQUFBQUE0R2l3ekFJQm44a2U2YVIyZXRpdVJveGZBUkRxM3NBNkxIbUxUT3BTaDkxekMrbjZOZFZvR0NGaW5sakxYMXVFOXB1cUZkbktENTZTRytwcCtCWUhXR2JhdHVDWGVvVGdWNi9pbWlZWDNGS1Vkc09LNTE3by9GVzhoMXFrdkxYbWs1Uld0QTBDUWFRZURaZkhQTjM0T2o5WWlNczdQaDNVcWxYVHFuSGN3MGQ5TjZwUGY2bnRhM0wzd0xIbVh3YVBNWVI4OEU2Vy9JeWMwUm92U2ZFeFNYSUNyNEJuZm5sT0dwZmhTdk0ySTkxYVc0K01vT1ZoSThuenNwZlVEUmlaNXBDeHZIdDdUaUxjSlpjTVEyc2NnV25zYVZoNDFMUk11TmVKSllXZlVjUS9GczluanRiVzBQUTFMMFpDVW0xNDhaVWpYRHlXaVYzcnZSMldDWmY2M3dHd0NnRWNURmN3akQ0RnN5djBjdk44c3REZDhKdHJLMUt0SWVIWjRlNjNNU0VmWFpVYTlTZEdPMThyVTh2Qm9BejBEdTFVSDZmZGJSdlltWDVmcFc1dFViMTlTemIvMzMrcFd0ZTNISEtvM3UxTDFNL043bUpDbDdwQlFmbTl5R2dPdDdnWUFPRHV6ZkJFYXlNZ2ZvczNzVlhuL1VtczRtc1lUZFR0TFpZZlVYVWQ4cXk1djJtTitEL3RJWTQxbmIyVll6d0hhSk9QNlJYYnM5eWxCSHN2TG92VjRsU1pMdDgwdTQvYisySWlySWhuWHlOVnBSUFNDMXYwYXhTSnY2aEZXWHB0UnB4RnZ4NlhvOFV2T3lydW5FU1dGOHNiOHM4RWpZVDBDQUlBYTFnWUFBSGdzTElJQUFBQ3dFNmdkQUgwd2R3QUFBQUFBd09ZSXkrRXBaUUlBZ0J2RU5BQUFBQUFBUElnL3JjRFJ3M3U2OEw0S2Z2dmpFY1lZT1JqSmV0RTdjc3FQVlEvckxNUVZMNTgvQ3FrRG1EdkgwNXBNc3gxVDlETnM3UU4wcERpdCs5NjFZSWpvMFc2UkgrVEVleEtOcHlxbndydUl6L3dodHorR0IvWm0xWUdMOWFIUHphUGN0TUwybkZ2UXh1cS9iTVNWN3RPUFhXam4rRy9ic1ZQR09nM3k4dnZGMnFscmpOOTdZL25RYXNwVGtMOC90RERxZjlGT2Y3U1dWNFltWElHZUF6aXQ3NmZVZWZhc1E3bFY2T3U2S1Bqbkl5M2JKbGZDWXMrRmVpU050Z1phQnYzbGxZRHIwdU1pbmFYS2U3YWhMUDBSdm9ucUl4S2FJcUdGZS9LUzZwTURkWWp3UU9YR00zKzlUUjRwS3hKV2hudjNIclV0SE9ZOUFOeUtxRkR6T3VoYmNUUXU0YWhiYVJCNVY2aFgzTHpaOVlnMnFsZGpUa2FaSGd0WXU5NmMxeEplYlNDYVRvcGpwTkcra09vYVExV2JwQ29mOVdmVTZTb0hnTnI5WmQ1bG1adGRSUzNUais1dGhKOXlyZ01BTk9nMWNEVm5jQjB1NVpNYThhQ2JTRGYyYWhGZVgwUWR0MGNUMnBRMDJwQVR5L1k4NUYzYysvbmlxbGZGQTNnNk00V0dwTG9uUFN0ckgxL0ozdlY0VlU5OHFTNVN1bHVKa2NoaVVGL1grb2VsUjhCeXZMcUJOcDQ5NXZDTVBZM3l2bFMyRnVlVVdFSkZ3dExkVytsNnk5WmNZejMxdUJEbUYxT1JVd0FBQUFBQUFBQXdBcjRGQUFCNE9rdlh3cHR2WWdBQXdEM0FMZ1FBQUFBQUFBQUFBQUM0TC9pQUFRQ2VTZk9McWMxVFVGYWh2ZEh2UFRHSWgzQys4Qnd1NTIxcVR4bGFuaGJaV1hiazlCNnRqRnRoSFFjaWhWdkhuREIzOXFNMXlUekhXWGo2Q3BrSUJUMm5xSGxQSy9LV2I4YVBqT3VldElQMHRObmgwelhhU2RFMHJieGF5Z0Z5Q1Rxd1ZKOGVXc05lbmI5WlNUTlRlWVVZUFVlTWJrVWFiUUJJOGVuSGFWZ0hwa1p0MHg0c1diSkhIYWJSc2l2dytqOFRSWDQxaDBYdTgvUE1tTCtJVjdnYUVUM1NlOHFwNVE0cTg2L3ZmNVdacWpoSlR0L0tQRVdPUkxiSXpyeFcyNkpTM2pNY0hsRW5PTGp3N0dsNDBrclgxcENUaHM1bTNJTUZXSXJGcG9SdlN2aldpT2UxRHk5bEdPeEhQV2VrK1Z1R1MvZDd5MXpSRlhRdkFNQUFFWC9zQys5bklFNnBoSGtzd1RydUxBUENzK0pxZFJndHM1VmYybnk3MGRFQm9TRnA3MUVQMWdpai9kbGhYUDlVLzMvS3prTC9mM3lkMWRLY0xPMG4yME5NczhHdE50YUdrSFhQTXRvQUFQYkVFdVZlSDBOOTM0b0gwOUg4N1p0eWYwOWZoR2ZaOWU0L05QYzAwdmIrWWZiOGU3OVVDWkpTdUhZZkFDYlJtdUF2YzhHNVhsakxrTWY2cy9MdTVURkwzOGdlcE5SSUVYMERwbU90eDlJNlhONkxkRkhVcXJmU1MzbGRtaDQ5eFB2Z29FWHZQTXpPZUJmQy9HTHFJU0FNZDRPbUJyZ2dURndBdUJySUxRQUFBSURMZ2lvSEFBQUFqd0NsWnhrMExRQUFBS3dIalFNQUFFNEV5eElBQUFBQUFHamMwRjc0NDRtVVY1NWk4amR2NiszOTFuMXYrRU41SFp3dzhsYTlkZTBKNC9DNnlWZ2RXNTZZd2R5NUZ6T090d0FvMkdPb3VNcUlIQzEza2ZGOStNK1IyclJYejRyRWl5Z09BRTVtNkxTUlJNUERsbkYvRFVabElyZzVvNW52UFhUc0VzTWhva2NCYk8zeFAwdDlaRWpDblJuMWpZNlVrUjMzZXVkbjNtUGk3bWt2WGpWdldMS25ZZDJYeXZSK3lBYzZzRHA0cHFJeHkrZTFvc3lic0xkZXVLSjVSOVpkQUlESGNvUkE5RHIwZG1mV2F1aU5GOWtBN0MwcnF2ejBkSXIydlE4THIvYmVLbk5rRURuTHFvM3NHVWEzbG9kNmY0dkZWeE9sK0lOa2FoTUxmWkNML3JTZWdjSW9BNEFyNEYxbWtXbUhvOW45bnYyekZXVnJZYU5EcWxtV1E3MUluc3h3bUFDTTRaMzRxZmhYTW90WVc2NVBSSjd5ck5DaGFOUFcrdnF3cG1mTWVDNjJ4MXQwQzlFUmRYTllhV2JSNjY2N2FJZTRYa3hkUmk3KzdXM0Fuay92UG93VURLL0g5R2pUU2tLdTFJMWFkYkowcTJqWnQ4TFRzVGtZZjl1WVMyZEY2MC82Q3dab0RSOUxPVjdDQlhXQlNEc2RZZ2RhaTN4OVgwdmY4OE9RVXpDWlhsWEdQUlNGQ0NsdCt6eWdELzBrNVZyVGc1Rlh1OU15U2E3ZTVLZnk4Zlk4aHdYUDRmVmMxL2ZZME54eFBVT24xK2NFY0FkbXFoQTljMFZ5RldWSHZHNDhsUnd0TEMzSUcxM3ZraXkzL3hwNXR0SkxXMW1zZFVGYSs0SjFCNDd1YWRBWmg2RE5wUlZ6WlM4emlLVUVBQjZGOTBHTkhxTUZKaEsxQUZldlpwSnkxNHQzY3pLUzE2Ymt1WU5sbjc3djU4Q2srdHFjMmo3dnQ5S0k0VWJkbXUyVDlLemZvcVhQcEI4SldsUUdRbXNvelJwaUFBQjdFeFhiME0zTTU1Mjl5OUZxZjRSSEk1cFpCMjJwLzhGNnVKenhEQkFqT3BFTEFaWHFzMTZxY0sybzZIc2JYbzEraE1lTGpwSDlVZVR1TktTOTl4ZXpYdCtRdXNzeGZidkw4VDcyUGJQc1hWaXhVYXlWc1MwczYyYno5OWdYVTE4amVxUlJjV1F2WTFiVGVnVjFlUjBaRW84ZkF0RTV4RU1heDlQVDF0bTRCdWlnWmJPY1lvaDV4LzNDeW1yK3RKYUJjQ3EwTlNMaXpPaU5nNXlDbmZFT3hTeE01T2doMDNCaUxBK3B0UGpSejd0enBxVmpwTXhUNmt2UmNIZ0d5amhJZHBUVlZRQzRORWVQYTdmSlBFdjNHYkVQWjVUUnUrWWhnRzdKNnU2Mkh1ZGZVU1kwb0pFdnhaN2llT1dTTmhJZkFPRFN6UFExalFwcUhxNnMyTU1vNjZYVldUTTNKVDE1SFBXMFVlOUdrN0Nwa2F2cjhLWkc3KzlxUGNTWGkzL1N4KzNQNk5WRXpzNHltZmNBY0VkV2lXMzRZSFpUem55MFlIUjEzZ3ZwK1pxaDVSbmRIcUJOZElJbkpRdEZsWS9zYWJETmRpRGUvZEVacGplbzdQRzR1dFNkTTE2bmE1VVRxY3RsMkVOZzdhSEQzMHhQT3ZiRjFMLzBIaTB6ODQxbWVNTjYrY2JUNUsyWFVYdnFzZzNVcGJmTVN3eXRYUHc3MnNqTXBlUFErcTcxOUJQOUJaUFFaUDZwaHRnRktsbXZlYWQ2VVNXeVJsZ24zZFgzSTNraXQyQW52RU11YjU4UnhkUGtwREk2RHJpR25VbEdXQTZrcFI5dmlmZHdZazBsUDlWYUwzR2FTc0loR0hKc3BaaGpDWVNuTXZ0bHRZaXJxSlZIbGh5MHRVeFFkTnY2SlBUYzhsTUorYXFWOHNZZFpZK1RVcU1nSkhlanA2bG43Mm5RelFPa3dmQ1JNaXlaUVFkL01XT2Q2aTJ6cHd5Mm5BRUFHbmlkWkpzejNneEQ2TlFDZVhSRld2WGpSdk8yREtoTkNQY29aWlloS2NYTlJqeXJyTmJHNklnaXVkcmhtaHEzVXRzby8rZ21vNTRmQnIrUnAzamlsZEtXNWhSSlFqemxkd0FBM0kzZTUzYmdVSG8xZ0ptK2lPampEWkV5UE0vSXZLMzhLOVFzZ0R2aW5ialdzNW5HM0xKVStWYWFGS3hLQzYrc1JGUU1nQjV4T2F5NVZLNnYwZmVsSW5xRXhTMkd6QXpGeXR2b1dyZ1VSNHMvc3dOUHhQRXZwa29nRkIrUFY5ZGE0ZnE5MUJ4L05VQXl3bHZjVEtnQlFEK25YWDVQTEtleTgxN3IvaktzTlNMQ3JId0F6a2loTCtYYTR0Y2M3K2hYQUc1bUxrZG40VFJUM0xPWmdUd0NBSGdrYncrSmRLNEYyWk11dXNqdnVTNmR4amcvU2RuUXpabUgrU1hadzBEQWozVVlLMDJRa1h4eDR3QUF3RHhXcmtnanJGN3RyS2Z4WG5HaXB4ZEY0bTFHbVRkMGhrWi96ckltWDlpMmtuMGdQYXdKQUFDd0l6MGFUYzJvZHVhcGcvTzlOUjlSUFlJMUdtQWZHcjV1enpiWURIa0dKNEY5ajh0aHZmTkVkejZNT3o1QVdmSDFZdXFwM0hQSkdiN3lKTVliMG5ySjJuczZSbTk1cTNuOHM3YmVPVk5mZTYxYjV0SjhyRU5BSTNsazVicU8xMU1HUElyb2dUcTdEQ1h2Z25VU2VTVVpEb2RQT1dzTmlMU2RaOTJJdktrTE1CbTNISk1PZ2k3SDc4em5HTkNuemtmTHc1T05hK2dtR2RkSE52WGwxV1hMYzRrUDVmck04RXdyL1R4amlmT0dNOVRnRHJRTzBpdkR2QWR4YnR2NFBIUWR4R25aMHQ3eXZ1TkhQcFF5RmU4Sm82dkxScER0aG1jSjFIUzVXWHNha3BsWWwvM1lJZUhkWUpLSXB0RWFPemZpdGZUZjNFaXJYZGRsb3R5b1dDYktpcTJwMXBwb25lVWpsVVgzQXNDajZIMEEzYU1MYUJ0bnZldndIbmJIRkhwWElDdWVKOTNvYnFXM2pKcGFjKzV4YUVWWFlFbGIvMGVKTXdOcDRFYmF5YWpMejg5djlOL2JKODIyTGF5Y2ZoajJrVW1WcWlybHovdGFmQ0c2RlBVdFhubDltYmtQQUtCZ0daL0l1V1ZFdEl1V2hoUEplMlJyMXFwRGRLaTA5alRlcmdNTjlJcWJxdnRXT29ESFlRa0JLMzd0NjVhRVIvcE00bEducldsWnl3NlBMTFZjQnRtUmg1VHU5a1ROL0paOWhMeWRqbVgxbC9FaWVYcUk2aEVlRDFMTDlJYk5idFNvZ0pJYS8rWjYwNS95ZDk1aWtPR1VFbWx0eWg2Qk5uZWo2VzgzZmxmUTJ6QTA2UGxBdHNGVHNCUzRBK1NUdDhqYURud015Q2U0TUtZZU9hSm9vazhkQjNZaEJNbkc5YTVFblZrdk9SWGRNZldFdy9HMCt2ZkVNTFRnU2V6aGw4ek9lK0o5UTRhNEgvbjE3RGl2NUNqbk5ydDBoM0VHbi85ai9UeFhCVHZ3ZE16b2pqd1FwOWNjWXI0REFFemtrUTl5ckhMSWpheUtNOU5aU3BmbGFmVThlZXZCNHpTekhvOCtFZG1oekk0cUwxR0hnWlFtV29jWjNRd0FBTkRKeURLMHlxZGd1ZG1sRjhpOHkzRWszN2RBYnliU2RmUWxPd0JZaGxjdWVhMGkzTzA3MEdQbTB6RzdNY3ZEY2daUHhPMkh6Qm5taGFiRVBXaSsvaWt2YWlWMmxqdHdDR3MyU3BVOHRNTG41ZFcvWHB2QWF6T1VlWHVZZVhwQU9WOGZ1YWRoWVoyaVVjYXhqa2FDK2JRbW15YVE2N1RhdFhVZndFbjAxS0tsbFRpdzZJaHgwRG9NNGpSVE1yTElSL093NGlHWFlERXJkTm0zUTZqejUvM2NNNjVSWHRkUW54cjR1aGN4UWxZOUp3TXFucFBiOXVLeTNXMjlsTW80dmphanAza3B3YThvRWRmQktBeEZ1RExKQ0N2VmovcCt6VzV6b0RUbXYzOUFTbklVVGJmdDBuazl1OWt6S0g3WFc5a3pCSnZIbGtXbm40cWt1a1QzTkRZbDNrZzNqWm9UdDBWcjVCbCt2R3lVMmRyVHNBUnhOdTVyMTFzd1hDcmpoclQweXQ2aDRPMStxY3hSdkw1Z1JEOEFQQXJ2R20vcDRDMmxicVllY1F0R2RpT3RQTHlhY2xLdUJTT3pXUWZOa0NyejBzcnlNRlB6ajFMVi8rZm41cmZidjZUM1pFMXZnZVpscUxOTTcyV1dkZm02N1ZGeWMySDRhOUY3dER5bFRoR1FDUUJ3VlhxZFJKYURxeFVmbWZuR3FKL084bmZNMWpqS1BEV1g5MWFFUy9jdGNwa2dOMVQwdElsN0FhanNBSlB3eXZvZVc5eUlxOG5HN016K2xVY2tmblFyRGhteitSNCs5cGprME0yc3RiN0hrMktSalRKNjV0UnQxbmlQd0pHVUg2dFJyWEtzaDBpc090MklQeHM4aXRlY09uSWNyekRPb0tEczRFaGoweWtBY0hhOGl0N0NJaTNEdWlWK0ViTUE1K0xsVEUvRkEvb2ZCMUpYMTdVRFBvOU1iSVRDUHVDSWd5Q1htWnFXWVk4aUFnNTZYQWNhUFh0akFIZG54aHdibmpOQzRlcXo0Q3NuNko1NXozaVp6SnNHb1RZVmJlOWk3LzJFM2pvd0hFNk01MEVPNkdMUFBjZnN2RGV6RElZSEFJQ0Q2RUtBdjlaQm5oUkhpaGYxNEhnN2JPYk9xT2NKUDJNejV3aU9VQ1JtbFdFcVdpMXJMVmlHOTMxbVpBVUFnQTB5VTJXbEMzakZFdThwUTlwdmlHcHMzc3IvUER2VEE4NFVBSUJ4SW5zYTRjVUFMS0pMV1dRYitheXFHOE1IWnZESGVzSGlMN3NPTnUvdXZ2VTJNcWhZWndacWI4KzNtcjRNeXhQS1hzRWpuakdRamxYd09IYkx0QjU0WUdNTzRXT3JBSHlVd3lVNTd0ZGhaZmdoeTI1a2ovTXZKNW9mMXN1cEVyditERzhobmtyMTdua0RMTWFTYnpWL0hlcmx5Nm5sL1o4TUtzZjd4MWVqc0UzT1E5U0lqUmd2TUV4MDZUakQxRHFrRGkxQjVqa0ZFVm4wUE5TM3pPVG9TWWluNmE2ajh6RzZMZ09jRWN0LzJYcElwTDZlT1FmcWVhc3VDYjA2VFRLdXoyNFRyaFJjK0VhWGtZejd2Y1BPbTc2bFptbHpqcUh3VGErc2tScDF6ejBOcjJ5TGxQa3E2eUdEUSt1dVdUL2YwL1R1TlZFSjc1VVpBQURkWEVHZnJJVmh6MzZSWlV4WjkwL0JqRlZoNVk1aEsrKzl0VmRMNGZJTUpvbGFPNisxZGt1TGIxMXZTbmlramxYY2p3MmtEcG9QSWVkMk92RkdydW9tQi8vU1VOSi82cGJlZ3oreUdKallwNVlKQUFBT3NuTHROYUFqY2hDWnVZeW95bTUxNzZqYnVYNGViZHZHSGdHejBxYnZ5bnpVUHpybUdLTUFNdGJEdVo1blJySmR4TjZ1QjAwK2FmZTlQL2VSZVBZMDl1NWdjR0d0MDVMM3dwdG5tVWY1NzRqWFI4djc5dTQ2VXhrS3htL0Y4OHpuRzhBWFV5Rk1qMENNcG9rSXlwRjVmZ3UweHJXY0ZpTXJCOHJNR2w0TER3WTVUT0t5UThucmREMnBMT3JaVGdXQTlkUmZTUDBoNlhIVjY0OEVHNXdOUzZkQzMzb2MydU5MMWxBNDFmUXVkeHU5ZGlDQXhBUzdNN0tSM3JvUEFPOTBQZnBheldsMWl0YzZyWE1SN0pxL1o1ajB2WFh3S0FrSXRkdFNQOVplM3E5aEdFemlpS2RqNEJKRXRyQ3ljVzNGajRZREFNQ1QySE5WbUZsV2RIV001dmU2Wngzbm9xWDFsdkhLVXlxamRwYk9ZS0xUYkhvZWdYb05PK2dhYldybFBldjVvOXFaejU0T0FBRHN6T3hudnp6NWpXcE5VNGlxV1QyVllXMEgyQVh2OUQzemRIeWtxUERZY3l2TVlaaUdkODAvdy9pKzVCbHlaNk8zTTIvWXlGOHZwbHB5YVpyTXNuYnl5L3VXcnpKU0tRU3ZxK2s5YVZ2M3JMaVdMOUZENzh2bnQ2VnMzRkVCUmVQdVIwdWpiOGxHYVNMVFR5RGdGUWVSdGVHVUwyWHNVS21ldHBUeWFLMkIwMzlHUzFaNHJ6MmdYOEZKQ2UyclMrbnJPVlJjLzMycGxXRi9VaVM1NW4yT3haczNkT0ZabHFTNDB2Vm9IUzY3eCtXMUd6d05oaDF4VHh5SExueFJ2bVNtSGRpZ1pNV1FnU2RqVENtVkdmUEduSVBWSXFldWVYbWdqRDFaV1JuTEh2Ym1nVUJjanVWanNlSkU4NVRLa1BSUzc1YldqS0YyU2J5K0plM2hpVHFzdksrVjRkblRpR3htdGVvU0FUbnhoYmFsOFNMYVRMM3I4U3BZRWdCZ2lDc0lrRm1DdXN6UGNncDY5WWpUT3ZqT3NEcElLM0JyUlpiU2I1dC81MVBTbEsyZFVlM2F1dS9KeTFJc3ZZK0hqbUNsOTFnTWxtTHNyY04zT3ZVcnJsTFo5UlBPM29sYmwxbG5yZVRUMHRldG9RWUFjRFZXK2lKQUpPS0xhR2t3MlJGdkx5S2FYWGZlK1ZkOVVMK2NxbUdOWjlaMmdQL0l3ZXRXbUtXNkM5RzN6ZFRvdzQ5aHRjS2wrTnVtLyt6YmlvZFphMzRwUTVHbHl5aWIxdElocERqV25rWmtLY3lENGEvNmFIckVTdjFpQ1QxdW4xTEFSR1JzVDMyMnFxemJDN2YvMlBlTHFVZHI1US9tMWZSSGpPZEl0NC9vV28razd0aWVPVWFqQWp5R0k5ZUNxWnhBYmtXcVlQbmFwb08rQlJBaVNUZEtENEFFY3d6QXpka2V4N3I4OUxYZWlrQSt3VVE4ZGdORERtQU1hdzlpeFBaOHUyNnNFZmxNRTNsbFhhS081c2dMYmpDVjFrTmdaNmhEZEErRFlWT0J6bnByOXBpL1o5bS9aeGdEQUZUY1lnTnlsTDFYaHpSUWh4V2JIOTRIVjJhczVnOGRjTDNkNDA3WDBhYTlUNUpiZFdvTnBiTW9oQUFBY0hwR24rMDY0MUxqY2ExSkw1T0ZmMHV2S3VkWjQ3RWRBT1pSNjgzTXJYTXowMjNRZWhFT3BqRHFZZEU0WXJwYW91THlXM2ZJdjFPdzc0dXBmeGw5ODdmVWxyMndPL2hGY29aSFQ2eW8yZHRJZS94ekRLbHgzWE5FQTZ6SGN4eVg5OEJKZ0NDWDBMMXVNczRQUFRWUDA3ZDZIWVNlUG5uOGdneG5RWDFmS3lJQXBRbjhnbkYrVHBJUlZ2WWJmYmc3M29OUlY5Zmg4dVpSK1hadDlPVlVISERYUVZ0L2V2Snd2bG5hVTZSMTZxTjJmMVBDQWM2TVowcU5ta09XaVNiTkxXK1pxZnJqOVNMcXFkWSsvRjFRTWJvZXpVam5WYXNZdHQvMDJOeVd3ckFwNGJNRXJ1Y0Y5Qmw2OUExOVpxMjVZVzBEejJxS251Y01OQmRwYTcwdDcyOUtPQURBTGJIV1hVazRTZ0swdGQ0bUpTK3JUb2V5MG5qeHJreGwyRm1ZNGREU0huelIza3FVdEFIdkd4UXoray9iU0tyeVRpMUg3dWFzaXZjdHpnbnB2MzVXRWY5di9YTXh3Yit1VzNsVWJkM1Q1S2x4alNJR0FGZkVXcTQwQXhxNm1lMUNHc0dqNFVscWM5cjgva2tQWmxzb2hWaytGUE1aVjYwc0FQQ1JBbEZTbjJXV2pXdXI3T3hJNHkwRDhTQ0FQYlE3MnZvYlNUOGpUaXRkZEUvREU2YXU5VmZCY2hONUJkWUlEMzlHZGY4WFUvL3lhblJXa0V0emxpNWtuWFd5d3RjT0FMQ0NFV3QzTWhHRlhhTFVNM2YvR1RQMUxmUTJ1Q1BmTCtLVXp3Ums0NWtGMUNlQWF5TTVEeS9oVVBNb0pGNEJoU0E3UHp2NnpQWVk5N2dpQUdKRTFxWDhpbWpJalB6eHgvZmxtU1lrd2dGMnhydlV0dnc2dUVrR0dkM1poOGV3MG1iRGpBSUFXRWg5WW9FV2ZqbDZWb1hlRlNjSDRzN0kwNU8rN3Roa3BFMkJ1bWl2YVdocExqS0lQRDl6VlZuVDhpajZPOWYzSS9sczQzWEVqZ0FBQUFlemxzUWpmUkYxR2ttcm1scS8za1piNmJnQmdKQXc2ckc0SmxjQlZvSWR0QnVqVFcwZTZsREZYYVZ2ak9SN2FiY2RBdXN3dmw1TVBVUldhZjVINzJ2WTBmQ0gwZU9PdFI2c3lJNDBzL0crMlYrR2FlRlczby9GMDlGbFhPYllQRHg3U2RycENReGdjQkJaQzZ6bDFZcTNCRXN6MXhhRHlQMU90UGJjb2VnWTJvbXlQWjZISEx4R1RzSEJaR2Y0M3dmeWZ3NThkdko2bVRVejdzK0gxeENRRmtsTHJsbnh3YVJ1dWlPYU1LcmJuSzY3TlUrbEZJOHhlbDJpanRKYVgwNzkyVWZueEl3NXduQ0ZzK054VjlkdUhLOGFNV1ZmSkgxZWZwVGZtR1NhYnF2cXZHb2hFeGtSTGkyL1FNa2V1aDU2WTRoYVJlOVIyU05ON3UyVzZIQ24yeXVraml5dnZUN3lPcDBVVDZKMU9rMGtyNUVPdmVGZ2tNYTU1Y0sxMXJ5WmVpYjZKUURBQkN4RlN3dVgwSlM3dXF6ZVJhU0xQUjVBT3RPSzVOMGd0T0paOTdMd2IyOEg1aUs5TllnaWVmYlMrK0JHaDlYeXNXbFZsZjN6MWRKY1phblU2Y1BBYnluQmxoZEV1ZjRwMHBuK294a0MvYnRFSmdBQVRNUnlaUFU4ekJ0Tmc2ejh3cXZadEZaeGIxUE8wQjdMdkY2YVVGMFg3K01RcmZ2WktLdU1rNzRqdkYwRHdEdzhBcWtVUnNyK1Y2OFB0WFcvWmYyODd2VStiek5UWmw0S3p3K1A3bW5BTWthM25EY2hYaExTUmZTTnlKeVI1cDNuOTF4K2lGbnVHYXNoVm00KzMxeFgvMmNEQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhEd1p6dVMxcEhYMGFOenJkTUROa2U4RzZFMW45VGtWbFB2MFdUYVdZS1JBN0c5SjIrVWFXNkRkaHBHNUkzNkdXL3lRd3pQUkxWT2Jxanpvbytnd0x1VS9zVnpTTWh1ZU9iR05oQW53TWp2UHZWMFhMRW9hZ2NGQSt4RWRHbE1EUVh6VFQ0S0dXVHYrZ3o3NDlHSjZoT3cxRUdpNUVVL3V6ajdnWDJqaHhUdnlvaHVwT1hGT0w0SGxud2E2Ry90a0VEdjNKbDVhQ0RBV1duTkVjM2UxcWJwdjBZKzVqeko0cC8vNVZHZGxGeC9LRVhUYmJOSG4rckYrMEdabWV1V1YwWWlsQTZqdFpab1E4TGFUNWpWblpJNmhsazRpTWRnMFB4WHBzRmZoTGVVRnlsOHIwSFY0a0k2dTJldnpudnl2cWM3Nit2STlra3IvdVlzR3dCZ0dNM1l2Z0xlRS8vLzR2MEV3MVNpalJ2NVFiMTF5TXI5bFVTL28yVjVlcVNWT20yMk10ZlM1amVsVEMwUHFWNjkvZDB6Q0MxTndxdkZCTWpLamRlWFZHdURQUmZoVWo2cXp1dndiR1FwZzBheW56S1NtTjFubmZKN0dzK2VEUURBMmZFdXI1dHlQMVgvUmtCV3ZtRTFkU1NQcUVZdzZsUHd1c3NpZVRWWC9rSzl5bElFSmVGUCtoRjFDK0RPZVBmREJ2TFQ1STlXMU1nN0kxWjF2U0xBdXoxNE8zSkhITytlQml3bnNqVlYvcXR0ZGIzQ1BKNFRMNXBhdVcxNlhXNC83elIzWGMwc09WMlhMZVdqMlFjWDd3UyttQW9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTHI2K21QcHhudDMzSVdzLzE5dGs2bGU5dCtxNjlmcTE5K1FnclR6NHdUbzBZY1laa05MOTNGRm02K0NvMFJNMmJzSE1vNUJHajJ1Q1Qxb0RXTHV2blpJd3N3eDRITmJ5cThXVnJqV1dETFVaQzlSZ2hhd0RTazQvdGZZOGlIblA4Z0FLZW9kZkpINXRKOEdKOGRpUjNpUE1vSXNVQ050cm5aVjBJVzlacHg4V3RmMkFmZkFNT2llVDViZlI0bmlxb0lWZlRuOEdhS0ROb1RMY084WmY4ZjZwcnNPa3pWMlh0eFBRdCszand5cTVqcWlVMGRTTExiK1c5MGhscXd6UGtiSTlEdWRaSU95R2lBd2Q3UlJpRDJtemh3a0VxT2VXeHQ1N0dyMkN1a3pqTFd1VUN3KzgxbW5ibXhEbXljczdwRnA0aDR4MVhlY3hFZzRBRCtYS2dzSDd5UlZKSjYvdjEzbE9FZnBuYnR6eWgvVStoVlBtbzhYUkdybGxLSGtiMitwZ0tieEdLOVBqelBjOGlkVEtZOFRxMXRyVW0wN3B2NVlSL2xXRTlDa2taUktsT3R4d0dxcU9BQTJ0VC9UTHo5K2wxYldvaDVUUHB1WHJpQXNBY0RSUmg5Vk1ReGhFak5YNUxXeFdXWnVqVE5XSHY4V1dQcSsvbzA3enBjSGw5enpVdE1yU2JzSWFEay9GdTZrUkNFOUZlR3ViektxU2Q5a1pzVWhiOGNzOFczTHJzU0xENjFPQlpiVFdaeWw4cThLOXBFQWNhNDJQenFYTER5T1BnR3AxbEVkb1JUdThaMkRjWkQ2clgweE5SLzVBaE9VdG9Wc0JBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHQjNlTGx0S24ra20vVWhhOTRURE55TXZOcnRPU3dQZnFqZmRJL01IMjhYbEdWbDQ3NVdCK084UHRlTDdLa1I5amlrSXc2OEIxQzJHajhaMXlCanRibUVkUXlObGM1N0h4NUZ6OUNMRHAwbFE2M25XS2JKOGtrVHBkNERVeUpWVzZMYVdLZXlqQlNLY2c0bnBYYzQvN1dGUHFaSTd6akhWamtlNjVqVHlQR0I5T2N3bG0wWk9iMTFGcGQwTWN3NDBtNVU2WU5ya05xM3kyNy9HUkxwM1M4WVZhdXRvWVZMQWU1QWF3NjEwdlFjMU9uT3MveUFTbkZTdVdZdXYrVlRmVEJGV3h6TGo1cGtLVE5ScURUaXRNZ2RjWG9WaVI3RDNyb1BRMmpqMVZLQld2VHNhVmhwdFRTUFY2OTZmT0V2dkVlMVd6NUNLMTVQSFRibEdwcFlObCtMSEVnaitWKzEvT3EvdGZ6S2VOTHZzUEpncUFDQWl5dnBrOUhQbmtqcHZCdGsyclhHaUtMNGtUQTdyMXNWMFg1b2IyZDc2akJxQVBVcVFaRU9yZS8vYThTM09yTmNrV2Q3bWx2NUJUV0pWTlV4SytsTDQ3eU9VMjVTU2Vtejhucy9EUDc2L252VjZ1UkNKWVhoL1gxUk9pUEtmOVg5RnVIM2Zqa20zNHVUcWdBQWNCaGUzVzEwODlIajFJVWhacmgvTE45Qm5WZXZHN29zSjZxcGVwWjQ3YmZYKzRYRFdIWUN3TjNwdGYrRnVhUHQwWlh6dDdqZHl1cUxmNFM0VWp5dFdua2JXK0xLKzFMWmxweTlOQ05yL3EwYjV0eEU5WWdacWwzUUUrSGEwN2pGME9uUnpWL3BaalNxbGM0YUREZWJ2LzlzQUFBQUFBQUFBSURERGdCQUFORUlNQWZtRXNBWXpDR0E2OE04QmdBQUFBQUFBQUM0QnZoeEFDYkRwQUlBZ0J2ejljWFVtUWViREZPL0FldzkyTTc3RnZMREdEbU0yb3BubFJONXMxL3I5a2czUHJyTGV4cTdqbThkNFNEZFk1N0Y4TFJ4ZlRJT2JRd0xhSWtNUzRUMHlPZHV0SVdwcm9SSFh1MkFkckJWOUVTY3BWV2ZkVHdWNndHY0NPczBwK2dwa1I4SFNOZnAwdmIydFNpUlhZWGx3K2s1UWNvNjVnOVp0NHlqVmQzV01MRnMwbE4wZi9UNFBNYnNOWW4yYzVuRzZSdHJtYUxxK21jVURYQm5MTk5VaSsvSkk2cHVxQWRzSm4yZFRXWENNbzYyK0cxeXBYSlN5bW9LbFMzR0VYcTBaVUMwUUFndW9mVVZnQnB2RjFoMm9CYlBFKzVjZnU5SGp5MG1wUy96OEhhTXRhY3hRNWJNN0VqTmFYaERaalM1Tmd5aWM4MmpWbnZOZjhROUFDempDZ0xHV3A4OTYyNnZ2dUJsS1A4VnE4R3NqcDJoYVhxZDNwcEMxY3EzRlRjMzhvN1dhWE5lYjBvOXlyaldnSTBva3M2ZDRhYnhyQ2Q3RHpNMk5lcU5yWStOcnZUMnoyZVQxNXFUVU43cnMybmxadG5yZnBublIvY2xzY3EvWFZLRnI1WVhBQUF6cVVWbTFDY2E5Vjk0REYwSTRWakpmL0M2ZDd6K0RlOCtRbythSGRFYTFXRmNxUlYxM3ZVek15bnluRm5hR01Qd1BIcE56RnJGVjhML2kvU1pYSklubG5YVWtsUFJwYTRtTysvWGRid2RyVDBONzBMazlkZkFNcUxUZWthWFJMMDdQVnhpQ0VVRTJFaGpsSGxhK1VXVXRwdk9UNzZZQ2dBQUFBQUFBQUM3Z084VEFBQUFBQUFBQUFBQUFBQUFBRzRIRzZFQUFBQUFBUEJBL3BRWDNsTmRsbElmcDJBZHpGZWZ1Z1pmakJ5UU5Ick9vdldtZk9UQWhqcmVTRGVmWW56UHB1Y0hSUStraEhsNFR6eVljWnlWVlEvNkdaenNJaHFzZzI5UEtLZG1uZ3F6eTgreDlDcnIrQjZjNTNCaVpoeEs5QmFlOWJBUE1WVWZPZzM3b3cyQVpJUy93dWk3NVhqc3Y3MlcrTndvOHhibVVNUVJnUDEzWG5yMHJwN2pUSjFaMXNsZjkvL2Qya1h0Y1RBaHdGNUUzRFNlYjhwRXl2U3NVNUk3dldYU1plbm05cG1vUG4yNVBBSDlMWStSQ1I3eFUwWjFONjlzN0RVZ1lEcWVRL05udVNlMG9kWGpsbjNzVU9udGpCeUlZKzBIZXYxYUVxbFJyaFJ2eHZIU0Q4RHJveW5qV3ZQUGsrZnNKdTZSQlFBQXQ4WHRXQytRZEhlUFFtWDVlcGV3VXJxUE9xQkhHc0M3c21yaDFpcmUrcHhMVkp1djc3KytyL0N2STYzRks2K1ppcVJHMnVTc1d4WjZHVjdFZTMyZFZDekRVVWZOOE0vZU1aV1VQTk5uVmF3bXRaNlJrZG9wTFozMEFBRDk1T0MxUnU5eWpIZ2NKdUxtcVgzcU03VUdUNW10ZXpYV0l4Sm1vVm5QUzlzM2FPWVh1UThBTWxtNVROVzBUYTdrWXRqTS9aQ2t4TEhrcnNjeXU2WDRpQ3dxU2ZsYlM0ZTg3Y2F5dUwxNlJPUlJ4ZFJaRnltK2RLMlZKWm56V2w2bnhMTy9QK3ZaQWszUnlrcjhyVkd2bTgvUGMzNHhGYUVJQUxBRzVDc0FBQUFBQUFBRXdJd0VBQUNBUjREU0F3QUFBQUFBQUFBQUFBRFFEVzUyZ0Rrd2wrQnEvRG50b08wNWlxRk10K0pJbWdzaG5VL283ZXZJaWZ3MW50TXd5bmplK0ZwNDVNWDJXdzRKcVdIcnp5TlliKzVIM3RpSHRmUWN4N1dpRExnTjJvRTQwaG94a3Vjd1BVTC9ZQ0tuMmtocGQvOHAxcEU0MW1sS0xXVkNPcVZ4NU9RWmdNbG93OTF6MXZiUG9kVGZpYk0wdmlVWTgrZmhjUWJDOGRSVHBQZGsxNW0wcHExMWFPdXBob21sZ0hpVVBId205OFk2UlR2TFNiUWgwN3FYalB0ZVZ3VEFsZW1ZY3VFOFBYazFYWUg1ODlUa256eU5DdFlmTFZreWJ5T1pXclpuTHoyTkRrdnc3R2w0Vlp3WmV4cGEzalBMdmpXYUVtN3RhVWg1V0tjUWV6cWhsaG5lRGtLdmJ0SnE0dksrRkQvYUJkb3dzTkpJdXE0MVpFN24yd1VBT0JOZTVTY1plZlFvZlZzalh0cE95RXBGd3Z0MGpMYXBNYUlGYXgxbmJTSjZ2VWxhL3BHOHJkODU4dnVsQVZ4dUpHMUtsdDk1dm96eG4ydWh6R3pWTy9uS2VLdHpWWVo2M3hvN1NoYmVxcXBObi9SNHA1emZBQUFDVVlQUmtxWEl2MjYwNWNmeUQ3enVhYjRFci9hMWJYRmZoSlNtVHJ0MWhsdTA2cEtNdFZ6N2dtcXQ4Z0NBZ2RlMnpvS3NTSEpVcXlqdCt2VTgzVCsvUlpwNExTK3Y5UmRaVG0rQlowRTZ3OE5YTjBkcTZ0WTY3Vm5iNi95aWRmR1c1ZkZBdFliU0xVMXd6YjBSVGQrRFZtYXZzbmNSenZuRlZMZzFySU1BazJBeUFjQlZRRjRCQUFBQUFBQUF3RVhCclFFd0IrWVNBQUQ4d0tJQXQ0SUJEUUFBMzdBa0FBQUFBQURBQTBuLzUvLyt2OC9ERTlMbkFXci82Mzl2NitoNXpmcHh4eUhzaC9kZ3UyaCtyVHhiYWNwMDFxa0M4STJuMFQxSFFNRSt0QTdhMUs3TCsyVWU5Q01JZUliU0xBNFpnaWNjNzN1MnVWbTRGaVl4VTZaSWNxdzNMd0FIdmFlb1NRZFB0MDV0TE9PcmgwL0RlZEJrNHFHQytsbEVtdmFJcFVKYjhtYlp3MHZ3MkEvbGZTME4zQS9QTVlpYmJ6aG9Jbk5TRlFCdXlZeng3VjJYOHNjZlcxalhXYUxMOWdxUFBjdU1HZ3c5WmNCVVJ2VEo2UG9UR1E1UkZ3dDg0OW03OEtRdDAydjN0WFN3akJWYkdxM3VXMlhPUitZdkxnVUFPQzJqQXNyN3FhZWVPa1IxZ0psWXpyOVRFVzFzalJtYmRjbkljMFpIdDdTRFZKV1Z2LzgrNDBwc2FUdlY1NHl5NTNkWDk3OGU2cXZqdHVyZ3JXdVpkeFhscmE2ZXZKSXYydXZlMldRRkFNQUkwZVhKc3luNVVKazRhNlgzK0NLOFphM1VQclRIcktSNDI5YXYwZlg4em84MmRDNzlQN0RXQTdTSitMU1RFUy9KbDRhRjBpMWJYbWxuUExKNmV6eU5IRm1RWUJmTU5iRzZqdVJWM2gvQnErdG9QRUx0bkszRVJRVmRKSytMb240eE5TR3dBQUFBQUdBRTlFa0F1QXJJS3dBQUZVUWtBQUFBQUFBQUFBQUFBQUNBRXpaVzRBWXdqQUVBQUFEQXl4L3A1cTVmL0ltV2RiYkQ3aTdNNnd6Qjh0cUszME1TeW9xV1FiYzc4RFl5bkIrcEg1a2NFTUE2akd6bDZXMUxoMlRQRVRPVGkwcEd2SzI0emxXYzNZZ3N2RFVySzR1OGdwUHlkZmh6TlQ0LzlPUXNIOXpEbDFKUFRBNkUwWStuNFVoWHhLV0dSZXNJUGNZM1RDTHF4OEVkQVU5azVmalBSbGsvSWwreS83eHJ4QXFPV0hmMjJGOWdQVDJNMGFiditXckFySDBTaG8xQzdUU3I1ZGNNb1Vyam40SXJMenVSZkJsdUFIQmE5bGFrYWo2TWx5cnYxbjc0YWlmRFpad1kwUlZwaFdKVjVoY05tMW1IVjE2ekJ2YktRZUIwMEdielJpUHREcHZrcnpZdnUxSGFVUHRNT0ZCbWdTWWpjRUlDd0JYbzlWZHF6MEk5V1BiTld2SHlwRGlSZURPdzFPYWUvSHJqV2hwQVVtOG9zS1lEeUhnRmxtWnpKemw2NjlxNjc4RmJ4dU9adlNBaFMwL0I2RjdraW0yeHFEbzU4c2o1cFpqNXpNUUtRYmVYYjNRUmYxcUJyNGV2bC9tMFdIa09aeThoRWkyajU1Mmoxck81VzBkK2wwSjdrQU91UWFUUGVpWUhQSmFXU0xCZXNNeEdPczhRM091NTF6TWd0Zldodjk4clY3U0JBSEJCUmxTZzFzdXByL3ZheTZsd01WcHlEajFyT2Q1bDU4aXV1TXd3aUJyQXJQblB3RHBWNWZzNjVmZG9kVlNQaThGck53QThnUm51dUNGZnFPSDhUTlVmSHh0UjlSNkE5bU5HSEs4ekZsaXZrUjAxeHRFQlQ4dFJxbnRMbmNvNzFlSDI3UEZ5YXFRdXIzSTk4YllxUGdQQlpMU0pWalF4M1FZQTBDQXFKS1g0aWovaUxkN2VhLzRtMU9XUVFsc2E1ZWd1YlAzeTVveWQ0bGFkSkExWnExT2RUc3V6RmE5Kyt2b29va1pubVc0VG1yZzJ5Z05sZjIxdWJWdTNWcU4yUmRYbWIwMmZsR0ZjalJsdGlMWEtiblhyMGJJREFHQW12YjRJY0hOR3U3KzNUcXVXdnRaVzg1SjJZendEeUhqZUZ2dUxZR3Fsd2p6eVdteGxWajNUMHBJUnZkWWVCUENhL1hCcTluaXZxa3czTys0bDhDbzdvL3VFbnJLMU1tOUc4OFhVNVY4QWVrZ2puNTA4R0w1SEhUenhjeUR1N1hqTnBhUmNieHNhM0JuUU5QcEkzNXhod3NLbGlDNnpNNGZZc3VGNDREaHZHZWFubm43V0lobDU4TmdET2gyY2dBK2YzUGVOMUhvT285Q2Z4SG5PT250dDBLTk9BMTBScFBXU1lkVHVvM0dmaGFIcmVmWXNlbjB0RERWNEdxTmozcHZlakNmNDI3WG5TK3RuWU92d2tGMTNKZ2N5QXVnMnRCNXdPS0ticzNIOVdIcGt4aXUrVndGWjZXY2FsUzBNaEI5Nm0vSU04eGtBQUFxaUJyLzI0SWJsaDIvRjY5VXZUc3NLUlVKN3NzNktWemV1MWFGYUhlc0hVMXB4bzNsTFpVVTlWeXVaWEtZN082SE5WM3k5OUsyTTFNanlPOXpkN2E4NlY1dHdyZTQxcWdRQWNEc3dWcWNSMVVyMklLcjVsTmNyd05VRmNESTYzamJMdm1pbXhSWXh3V2ZKVjh0U2hRYVdhVTBqVHFmWG0xRlRQOXAxdHEzNDJ5RjFYSTg3eThwWFEzdTNxNjdMalhoN01iVzEwYitNMFViVi9LVmdFajM5WW8rbVR0dHhaVitlWkZ4cjhTT05lb2lRZ0M2WU5JOG1lc0JvSzQ5TnlPc3dySVZMMjRQdHFMeTN2VzQzMVVaK0VFWXRuSlRRc0s3Mnc5Vm8zeEY0VWZYRXROYUkwU1A4MExPbWMwU1RXbXJFS2J0WmNrelZuc3V0RWI0MXdoblA5eUxRcjFIZnA2V1NJMExoU2JUR2M5cmFZbm1wZnpWMW1uUzlPbTdVdCtoSkcybW9VZDJ1SjkycU11RURyODRHRjJXMklxRTVSWm1MeTVuUjVGN1JHVEgzZThWMXhBM05FQU9BMnhNVjBCNG5ReG0zZmtDcnpHTmE1VjV4ZTR5WFBhUzhwUlI1NmpMN3dTdHJOYXpUUmxaSFM1bUxocFhoM29FNm8zK1YzMWtiMTlwcHFSOVZhR2djSDRhKzBqOC90M05mbmNRS3RpZ21zQ3ZQZ2FJaThRQUE5a1phQ3JkdHpsc0xzSlNvTnJrSjhhT2EyeDZhWFEvYU1INEYvUHkrOUprT0FDWmlPU3duWkRsejNtcldYOVR2ZWx2L2FzOFBqTG92NERCRzl6UmFyck5vbVN2bithM3crQ0ZuQ3FhV3k2OW5BSnljUHh2QWp2VE9JZFpZQjNYanJoQllkQVRBcFhqWktKZlhYVHhQQUZscEo0TTRCTGdmcFYvblo0NHJrNTBYVW04QWpyekhNNkplSEVaTHFiTXF6bmlIQmlNaThUR2JSZ0FUV0c2YmZ6c0FkcHVINWFiTmtldFFYaFRlOHh5MU54d0E0R2JzYVdKSFhtV1p0UVNNTEFrQUFJOGp1ams1WkNnZGFXak1aSWFCTVZyZjdMeHV2VzFjUDkwWHJWT3JqQXZ0ZUVjVWlRZ3pGUzYxcVFmYWVPS0Q4d0FBQUhzUldWcTljV2RwZHRhTHNPWDk1Y3V1K0RCTkVLbXlGMUx4QUs2SU5zVjJreDBkSUJhMkhldyttTVdvYmtEWFBKd2JEb0MzRjFOM2Y1aE0wNWlsT0swM2htR0k2Tm1DdlUzZmVzTy9kMS9DT2pub01jT2pibHlwc1Z0N0JOSTFjMnMrM2o1NE1kSUg5Qjk4MDZ1NzdHNlhlSFNDT3Z5QWNkNTdXdDdXa1c3cXo3TVdjMitIdHlwWDVvRU1nZ093WGpMekhOYjhObnlGY2Z4MUtIVldFaXBwWUdjaUM1Z21yeXlQRVAwOGpMVU1IZEhFcCs1ZWF6elhlcFJsS0c4YjQvZ3BCR1RoYStob3o1QkZoMHpFZndOd1ZTTGplb1h2czB5VEc0N1hqenk5ZGw4a1RyMythRS9OWEIxdG5jVU9ua0xFTlZTbjJVUEZzZWJuWTlXc1VlZGptVWZVUDdVNTRuczdKTnFCNk5VZjFQcWtwbDlxV1BGYVRSNWRaNW0vQUhBNnppeUllbnlsdlFaUU5QMWxtZEhocTR3UXo0Wmk5TUVUN2JvbUcvZGJaZmMrdlJUZCtjMERlWGkxblVaYWRaTktVYVNUOVRDUThEQlJjMmpsOTd5emxKZFc1TzBuTmdBOENXMUowSzQzSlR5Ni93ZExpYnArVi9raXRNZUF0K3AraEM3dFUxRXJmajdBcnNRemFUM2ZEUEJFTkxPaXRTRmhQWlNhM204bnBRaU5McG5ScUU3cmZuYkVRVVFvMERDbm9XZmZvVmVQNlBGbVdQRnVOWlJhc3RPTEpZUTg4bnJFQlhSaGp2MWk2a3ZCUkRoZWl0NHVxKzJKT3F5OGI3bVRrNUNuRnZjUjFITkphbXhOMkhvYkgvYW5OY0FCN29abnZCOGdwMVlZMkt2UzdRSjZHOXlVdjg3emx5UDlSeHdKY29rdnBWNFk5S3JET0V2VFcwdllaWWFIdEtIUU1yYWoxd0NUd0ZjRE1FWmtycnpwcmtrT1QycEM0ZGxRVCtFZSszM0Vkcnlhc0VDNFRlSHMyMFZldHhVNHdVYTdKVFBtc2VmWnF5MFFCZ0FBTzNINi9hTXpyUll6NnJMWDc5RWVFMDdCNjIyekgxanBLZHNiZm9WSG0rdTZGd3J6Vy9VRGl2U01CekEzcWV5MFpsLy85SElFQU9BZ2tJMjdrQ2ZkUHlOZFM2eTBKKzJOWDE1ckwzT2MzUmtNY0ZXVWZVSWw2UFJjWGtTc1hDeThwamNzSjZvcm5LbUxiamRjcnFCYjNIaU9IdnRpNmwraXZzZVJveGpZNkhiWkN4NlhiRzh6UnJ2QTA5M1N1dnBJSkNQdTRlUDl0SGllckVoQ0hQb1RKaU1OT2NzdnRIUVlSaFd1WFNyMVhsU3I2TkhwdW1zYmU2MGhLWDQ1U09vRzhKejJBckNZV282WmUrUDU5MS9QeTZrU080b2owUEE0MkdvNTVUM1JTbnZoRDl3Y1BVZktMcFRVN01zZ2JlalZtM2NBZi9IWW5NVTl6MFArMmp6MjJnMmEvc3l3aFN0Unp3ZlBGUE9FVFNPMXl4OWUrNklMK294Q1Z5b1JLUEdueE5xTHNGUjJ1QmlhaldicE1qMk9URXZ4aUE0aUJ0MFgxcGJHYXF4dW5hVnZJbXNBWURsWEVqQXRvU2l0elRtUWg3WEdUK0hNM2docnhWbXhJbmtiV1hLV3A4QjFwQXdMemRqTVJ2aldTS1BWeGJGQityYWhKT1FaNnJacThLdGZTSzAzc3p5ZXVQSys5Mmt4VDFwblczdjNxS2M0TUFBQUZxTXNDUjk0Wlo5M0F3WlU5clRiUjd0OUpwRWhJZzJ2M0xpUnE4U3BVd1ZveG1lTXd4TnhQOHpXRWQ0NXAvNnBzclRjODYrdzJyVmZoOWRwdGtiNDdjVkJ6K0xnTWFsYjloTXkxbzJucWV2NFd6Qk5uWFkybHJvcGNkc2hZZ2tXYjhjZDRZYTdlS2NjLzJJcTdFcFVlQjVkaHg1QitSZ2tMYTdHcTVpMHJtRWRPTlVCMm93YTREc3pXaDNFTDhBeHZQYjFTMGQ2RHE3UnpOOExjUWFEQ0haSDZ2WlRPYmk5RDk2M2ZnakFUdlRPbmV5OEIzQUZMdWZPc1NvODZxaWRuV1ptK3RsNUk3Z2VCZDI5RXk4ZEZ6LzVKZG5yeGRCZXZPYlR4ZHpRQUFEWDV2QTEvOHhTL2NnVnFmZXB2ZnBsVkUrNDVRUzFHSGs0eGt0QVFWM2RiZXJMcWR1NHIvZ01pcHIyampIMkFRQUFCRGlUaGpmaWl6aDBHN2hSV0dyRnQ5YnNxS29IQUQ1MmNMeGFham1QWHdWZ1QvTFVYTW1VOW9KWi9jMGVnb3JHL2tGOE1mVlVFMmJtMjhZSTZTK3NreWFrc3c1N3lyQTJvNlc4VXpEK1NCMHVqV1NGV28ybjNXZGU3RS9aOWxyZnJad2NBQUs5MjQyN2NPQTQ5eDVRNHFuYTd1dVM1d0NEU0I2Uk1JQUQwSFJZN1JHSHQ3VDFTNm12aUY0aEFNZlJzNUZSSDkxWDU2VmR3elEwbTNSbGswY2ZhenB0OTg5U0tMQWo3azMwQ0ZJbHlzanc4S3kvQUZkRGMrZDRIaUNaVWFZbmJtMEdTcnB0S2lPVWNiUjhwWGlha0pnbFBIQUNQNXFqWEJIYUkvVnBwL0p2VDh0UFpWMWI5ejIrZENtT0pzZTJ6ZC9aNk5XcWlaMnFmNzMyMzhoV3lCSExFQURBNDlBRWVtMHdTVmdQcG1qeGVuekFsMkNDQTZlN1RHKzhYbXZVazFlUFZ1QjlFbWt6eXZKNHJyeXZrWHhmZjcxQTZvbS8vY2IvQ201Tm9sVGtMZHpYNm1MaW1WUzFKYVNrNlZYMnJMMDQ3VDRBd0puSXdmQmVneGlHNlhVN2I0NTBNelEycno4ak9rUkc5akNpN2ptMzN3NEFaRHJtaW5hR2pTVy9QTmFRSit5VmwrUUdpQzZSOVgyV1JBR3Y2UTNUaWU0N1JPYVloWGV1Uk5iNmV0N2VZdWkwR3NLcjFHbDVlZHhhTTkweEYrYWNYMHhGT0Q2ZVh2ZnBZN0FVakJJMHRlc1ExVjRBbnNvQjgwVFRLUzhCOGgvQUpIdWZMNGlHQThBSFJ5OUxUT3R2a0YvUFp1S0RYYjBiMXdEd1R1VFJXQ3VQdCt2QzE1UTlPMVJTdnRHblZrYjhXejNwV05OZ0FhOWhITjJyQkFkN0tBY1RkWjFUbFhWaTl0amE4Q3hIbzNWZ25nTUFUSUQ5N2dCSGVpcDdOMFdpZWZRb1NoZDl3Q1hhWFZtNmtScTMwalpmK2F6ejA4cG9sSjJEMXhIUXRRRUFZQkl6M2M2emZSR1JQRnJuT1d6YjRtV1R0OGdBemtFeDEzajI1V0Y0T3h4NVBKMWhjNzhLTzhQWlRMZHozK0UvT0FYbmV6RjF4UUY5MENUeVFyZUZkdnBGSzM0RXVyM0EwM2plVGl2anRwNkFZeU9wRDYxdEk0ZDh6dGdiZ3NjVDJRYlUxZ0l0ZkJjdXNnZ2MvdEJpcEtObkxQNmJFWmZGR3hZek92U3lkbElTT3RBMTZEbDVzMWMyd2pBOTNTV2xuL0d1eTZuOFVlRWpaNDI0clIvS3VINFd5cVRKeGIya3JISGF4anErWEFEN2V5SVJVZXMxeWFSNDdyS2NFY1V2b3diQ2U4cDA1Vk15OGtLczFkaDFHWjZ5c1JPV1l6WHhURmRFYTJobzNhK0ZRWUdtbTNvYU5icGZXT1pkNXJIYTM4NGcrS0x1WGt1YzdqR0hqclpCQVFCdXlZejliaTJQYkZ6WCtVaDVUT09JVmVESWxjZHJNRzFLdkswUkx4bDVlV2xwR0I0cnVzNnJSWTlUTmJyWldqcm50dTM5aTZoRm5GekUwZHF3K2ZWVjRmcWp6UFNlbDFqbDlQdVAxeS93VTBaNUkwaFZQUUNBUzZBdEFUa1l2aW5oclRqUXhPdDZHdEhHWnVUWldtNW5MNDJ2THk3V3JqUzFqU3ExdzZ3TFl4WGduZDVOamVCY1dtMVZXbkswOStjOFRtVDBiQUFqVnc5amxoNVJyK1ZadVMrVktlVVZpVi9Ielp2ZkUzUjZzbkZkMDZ1emEvbHN6dmczNXB4ZlRJWEhNbk11UG5aZWo2NCtQVS82QUFEc3dZNHl5R01jL0tYY0JzeEcydDJxLzZvTVJpaUFpNWVqL1ExcFU4ZTcyUTRBeXhoZDNtNHpqZXNmSW5rc3RXdUFnajJXT0lZZ1BJRVZjNmhMbkE5V3dyU0RJL25QYXBDWlplWko5Nk54NEJaZ0RnNmcrYWxvVk5nQmhoZ0FBUFJ6eENxeVI1bTlobEZ5eEYzTm5odWdKOXRvN2JWM2UrTHZiYytud1hBQWdDZkJzMEREbkdrSlBBMno5SWpvU3hzQUVNT1MvK2s5cWpmTEtpbnNUWGJlcThNOW5VWUhUMmRrUzdsRTJ5NDdvcXRhajUvQkltN2N5TTBYVXlOdlRVOURlM25PZTN3Q3U0eGZqQWdKNzBrVVBldGhMOUVUQUI3TFhnM0NReU14dk1ka2FHbXpjcitFL29ERmpKeXMwczNJZ2pRWjcySE1wNW1LV29XVEVyNHA4V2ZVNFpEQkEwOWloa2hJcFlNdXkvZGZoV1hHN2pWb3lScHN5bDNwc1UxN3VzL0xEUC9PS2RaODZZZU1WSXJ4ZjM0OGs4bXlPVjhmTnNpZmFTelRjNWJvWktqQmxXbE5NZTFFVVcrZVpUN1MvWEJHRXVudG40OGZrcFg0WW9UV1l1aU5KNVhsalpzRDRTc0VWYTh5Z0JBVUdYa2dUSE83cm5CRjlPNnpQSzY3SldIWjBrMGlBeUI2TkxSV245bHlhWlFiREphV3Fxck56OTZITmJTeTJCNERBTmlKSGdmQnFQNGNLYXVaMlIyVmVNMEFLcGxaZDg5S0hHM3I2TU1URXRtNDF0S3Y4RVJYeG5ldXI1VjhQNzU2NnFqTHo5ZE5yZCtmZitOTHdWYmQ1TWliaityM0I1SUFBRndXeTFFbCtTcWthMm5aUlVhRzhLNWFJNXJMbnE2amFMakh4ZTF0bTJRNFhsVVZad09BTjZJVFd0algxOHhBajNYb0lhTHhSMXoxcmJ3OVMrQWxHWEVwdE16N3ZObDZCQXd6dWhkZzdXbHNqdnRCeTF1OXRuU0NXNlBOSldzUDB0djRFWUZsYmFCZG5IODJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIelMrbTduR2F5MGRCM2s4eGVPTS9sQlNJRTMyeHUrZWxiRzgzYVMrQ1d3ZEpqWERiSVRUcitCTUo1bHNma1NNdHJHT3BySk1hNE5Gb1F5cHlTSTQxWEhjZGFwRkZJQTJHRjlHa0ttek8rNmNqdWhEUCtHR1hielM0S3RZWGM0WVBHbXFkU0Fibkk2Si8wWTlMa003TnQ4ejZQYnRDa3hXdDYyWDEyK01rTk90MFpqZ3ZrWEZoMll2RzZjVWRXYm12QWE2TU5yNnRORDNmRy9ITW5TeGxJQVIrZlVDbFdNQ3lVcGhaQjJreHJIK2d0cjVZUm5aRVNIaVBjUGZHZnpFaVoxZW51emtqVFg5bWxlYjIzVzBwOTE2Uzg1Nm5MajF4ZXZYalBYeG9GeUN5QlJYVkt6Y2xmSVc1RkJrR2lISUF1QzJqKzBpZS9XN3BXc3JiNUdYRTdDR1ZWNVRoZlNoS1d6MW5sdTM5VkVPOTZ1ZXRYVC9OZ053MiszZDVmMmRFRTltVU9zem9YeVZQZFk0WVJyajBXNzZhWFBpOTBhK3Zaa096MHI2bytwWkhWUWV0ZjdXOHRDRUdBSEJIb2t1OUZnKzZpYnFHcmNmTlp0SXFjOWJ5R1NraktYOXJDVkpxWHdPQVFsUXdCY01qVTNGazJucjNQOHY0MjJiTE04eUZBbTB2MW1PU1M5Y1F4dHJUc082dkhNODkzbzFIREFtcE0wYmRiNXBicTZWZ1JkMVVONEV2cGdJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUMvR0xxZDVEZWFZUk9SRjU5Q1NoaHlPZEdXaWNZNmZtRVdueWJOUkJ5MXQ3dVp6RHFCVmFKMTU0RDlUVU9nWG1ZUnhFNmFMbnVBdDRETkkwbGc3aWtPU3h0Y3p1Z3ZjMEgybFJpSjRVNUtSbjNZbWVETFVMbG95UExMU24vSUVBK2pCV3pZdGlIRXVuT0xhK0p1YzVQUG85d1JaTUFOMjBqQTd0bnBRV2RtR0ZuZWZGa2hWTDZ6VERMaWp6a1poNWRDNmNuNkJTTDMwOHdWTHhMUFZ4YzFZRjRNcEVSR3QyaGx0K1drKytiL00zVldad3N2MndieGx0bSt1cnlrMzdQVHNLODhxdEdjTEU2L1NPNXBtTjY5NjhINHhIdFlrMjZXZ1g5UGpRYnQvdGV6b0xMYUU0c3FlUm5YbU0rT052N0VPTE5MM1ZoTm8rNEF5L2JGVEhsZkxiZ25rQ0FGd09yM0pqclpGYWV1MjZpeDRKM0NQdFYyRjVRN1Z3YjkxNmxLRk5LVE1GMHJUaXRPSy9ydjgxNHRVcnNSVytCZXZWaTVGbjdZQkxTdnEzYk5MdlAzL1Q1U3F2TWw0dUUxZGxtWFZKWWxYS3JEN3VxM2xxMTV1UG42RlgvZDRzVkpCUHNnSEExYkY4RVY0eDUxbjZIazZQUzFpejk2UGFaRS9aV3A1YUdWNjN1MWN6Y2kzNW1rb0RBSE5wclJXRldweUwrK1VlWVltMTNGaXlwVWNtV3ZHOXN2THllSDBsRWVmMUxEMENUQjkvSFc2dG01YVhSeXVqaDZoZTRrbC9pNkhqOFd0WWlwTW5ieWtmVDJON2xiU0x3aGRUQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1ERjF4ZFRyVGU2cDlOeldvLzFoci8zdGZPSGt4eGhLODVabE1yeDVHVjF1NWJ2WTdvOThtYS85M1NNeUZGUTBJY2w5enh0VFg5QUFPdGpBc1ZCU3FIRGVKWVQvVkpCSys2a0gyS2R2VHRUbjlwVmxlbnArSExRSUpQZ1FMd0hnYW1IRmhVbk8rYnFWTG44SGY0NmxQb25TWkdtcTdLd25vakF4bmJjalZmVGEvTnpkUmRFRGlFN1pQMk40dkd0YUkzZGMxUWZuQi92Q1g3MUthbU9DYURwdXRZNkd4SEhBRmRCV3pza1BDZXRsdnlyM0RkOW9ia2gwcldQbFdqM3RZSThma2hWNlZiQ1Z3cUJYa1VqNGl1MWZnOUNyZ3Z2M1ByTHFpYTI1bHcwN1NXSkNMdWVmS1c4dFRLdGE0L1AwTHN4dGNKWWtlcDNNL2t3YzB2RDQ4dVd3bWFjWEs2Um5mY0FBRzZKSlVUUElCQTlQckszQ0JFbG9BZnZZdC9weUdtbTB6YnZva3FkdGZLVzVZMlcrYTlSWmtTcG02MjhUcUQrT21rT2pJMmZwazN5SnBZMkZyU3lha2RCWGNjNkxILzg4ZTVJekk0eTZtSHNtcVBhNVFuN0Z3Q2d4Rm9LYy9EK3BzVHp4SVV2VnFxcWxsbzg0b3VROXRUcjYvTGZ6U2pibytscUdsMGRJU2xxUlBMdVZkZjNwVEFBK0tXeFJyek5WU0Y4ZEUrakphK2kxcDlWeGd4TC9OUllpNFozVDZNR1dUcUUxeXN6azk1dTZ0M1Q4THdqY051aDQ5VzlvNXRYdVpGT2U0WkNVK1p1Qmw5TUJRQUFlRGpZSkFBQUFMQVg2QjBBMTRYNUN3QUFBREFKRkNzQUFBQUFBQUNBKzRHOUR3QUFBQUFBRCtUcmk2bnVBL3RtRVhtTHYzVlNpaWM5dU5HYXpQcjZoZWQwWWkranAxNUlMNWRyMTdkQU9zcWdwdWRVTFcvZU1JWjFXa0o5VFQvQUlLMERjcUtucTlYNTdEbzg2MElYVk1MSzJqcTVmeFBTUmRlaHFXMGFQZTdHMDZiMW9JbHl5T0NCSnhNZWFrV0MzRG84dXFSSGNZWTVXUEpLdXlmSk1mcnJ0aVRIdmN0MmUvUW9QOGIzdmZBcXE2L28rVDFxeEU2bzQ0MmNic293aEt1aUhWb3IzWStPODRpSmxqMlYrdjRuSy9mTEpObWEwTks5Vm9WNzdFWFBTYU4xR1JyZS9ZVWUzUThCZGpnclhCSGxrUEorYmVEV1dFN0JXZm4yekQydlkwNUsyeHRlbHpFeUdHNDRrS0xiVDJXYXFEN1owd1Zldnl6dUFBQzRGZEZOS1M4ekh1U28wWVM5bDFEOHFITy9oMVlaUGZsN1Z6R1BOUnAwSW9uS1c5bFJrY2JYeXJZMkw2TjFqTlRsSCtYK3dieStrUHJpNjgvMGErRG5hckw4RE45Y3hIL0xjQlBKUnJpVVhzMWJxOVBXVDY5TUFBRFlHODBYR3ZHM1d2R2l5KzVEV2VtMmlXcHlrYnA0TkRuUDR3MldXbTM1UkxVNElsRmZtdmMrd0ZPSlBHOVc3djl0YlZyeXBJN2pzWTZrWjR6cmF5MnRGQjYxL2k1TGp5dGlWTTVpVDAzSHU2ZlJTaWQxaXpDOWwrNXBuTVR6c1M4ekh1U3c4cGJ5OVFyTm04QVhVd0VBQU9BTGJCQUFBQUFBQUtqQlRnQUFBQUNBRWRBbkFRQUFBQUFBQUFBQUFBQUFmTEN2Y2xOdTNMRmZYMHpOWjN6MVdUc0dvZWZVZ09oeE5UZEdlcXUrdnZhZVhDRzkwTDBKZVVUZTJOOGNaWG5qV05lM3ducmJ2cFhHYzhKS0djWmNtb2ZWQjVzU0RqQ0I2TENLbnZJeWhEWUhyTk45dEx3NkttbWR4aFJwRCsxd3hGM3h0bW5QMFRrckQzZ0djR0RwdEc0UlVpU3M3YU5VaEdmRyt6bHBkWERyMUNuUGlWZzl4NHRCaUNPYjJIc1M0eW03UDFKSmJJeDc0UjI0citqMXVsYkZTOFhIRkRTUmFZR29oQ2ZTYzlwNEwxNS9yU1FIeWcrcmZGMHJNaUVyMTgwZk1IdlN0MzZvNW9EV3dyVjQwYnEwOHRaQUtIWlJON2wwdnc2ZjVkOHF3M0NCVjFoR2RUU2ZWMTZ0RG84cTZaRTlEVzhIdXdVdnRKaXhoSGk2d2xvU3JMSkd1aG1aQVFDbnBWYzRSWVdpeHk4cnhXMHBlVkplcmZBcHJIQUtyL3krUlkxM05ZdzhCVlRHMzRUMGxnWmRseG45blJGbnA1WXUraVJTVDE4NCs5bjZ5cWthdDJyckQ2TjlheGo2OVU2WlFySW0zM2VjWEYrL1pTSm44ZEdrK1RmOTIvM04zck5aS2dNQUFBYUlMdUhhY3FNdG5WWSs4TU1LKzd4ZWpiV3l0T2RVV3ZsdVN0NmJVbGJhM3BmTGY1VjRVcnE2VEMxTnNsUWJSZTFRNHpGT0FYeFlKbHBxQi9YSVAwMW10S1p2RGw1SG4rRnJsWGRMY2RLenArSFpMeTMvaFduTVV2bTBlSkd5dkhuZmZnNjEwSlE0YTA1cFJCcGJ1N2RDV1QwUmZERVZBQUFBQUFBQW5nME9PUUFBQUFBQWdPUEJOZ01BQUhnR3JQbHdLeGpRQUFBQUFBQUFBQUNYQkxmT0ZQNTRJaDNTMXQ0MytEMUh6Tno4N1dJUDBvdmRrWk4yckR5MWt6ZnkxbjdiM2lwRGU2TmZ5K2R4YUkzck9TRFMwN0dSTU9nbmNnUVd3QURlcjdtVVlZZnFXOTZUb0NKeXEvZUlLQ0diT251cHpUd0hyaXlqMWNGMUhPMTRQT3U2L3J1Rjk1Z2VnTWw0aC9XTG5ON1QvajBBT2hjSE9KY25QdFlIUERPK1Q0aDJnTHMzVGZrdkRCTTlDR3lQcGNOckZsMWlHWXQ4UWdpdVI4dTU0blNTcEdxTTFGbjJtS2FXU0wza1hBTG9wTWRjaXBpM3pmQnNWeXhyOXd0ZHQ3eXU0NVVaMUI5S2FaWDdSamJpanZnbFZRVS9XTmFNZFJUaDEwV3I2NndEb0swOG82NGtqMHZsTWN6NjRaNThSbjJCWG9kZFpFNUdqWmlIb2MyVnlIMkxGSXpUMG1WN3RzVmFaVWIwWmdDQXl4RFYyVDJDTUNueHZYckdLUjVZbXBGSHhBZ3BhU2t2Mm1jZU5BTXBXclluWG5UbC9hZEs1Nm5yN01IU294Vm9BOW40L1QvZGw1VnJwUzY1NkVkeFk2b3NxakxvYzNBaTU1YjFwVGdWUGpiSTZ2RHE5MnQxZmQycmgrMWpEVEFBdUJWUldhWTVzaXg2OUt1TEV2VXRSRnhBbGxZbHhTOFo4VVVvcSs5SHZQcGV6eENwK1dqVDNQYU5mcmpwS2hYbkk0R25VcXo3QVBGNVVNeWgzQklpRG1vTGJWT3lpc2dTVFlaYVM1MVZoMGZRMnROb2dTeWRqbGZ2Nk5tTGpOUkJvbGMvZWRUeTY5bHpqQWdxci90dWM4Uy9hZVB6eGRTSHd2b0RBQUFBQUFBQUFBQUFBQUJYZ0QwTmdPdkRQQVlBQUlEMW9IRUFBQUFBQUFDTU1tcFpZWmtCd09sQlVFM2w2NHVwNWh2ZFJ6UzY5K1J5ejF2STBhTnlia2h5M0l1Y1FERmFkaDFXbCsxOTJYemtkT1ZiREFudmtVcWI0L3JoYytRUXRJRnZ4UWNJNGpubFpPVlNIMTZHcmFQZFBJdEU5Q2k3WUpWNnp3VWVxRUtjeUFLOE9hOUhRSWJCVHZRTzY0L0RtWXVUSUJORzZQVXA1WjYxemlDdmR1T01wc2pLayt5bTA5Sjk0SDcwckVYMWh3bXFnWjN5NysxeXpTdnZsMWxKZHNXLzFmV21YTmZmd0FDNEV6Mm5yWHZ6Y0x1K1czcE45WUdWanpXdXZwOCtzNmdyWTM1ODVTMWhnNUdGVm12VXFLNDMzUGhHdUpVSHFINnJHV2FZcDdzOTNTaVpFWmZRRjgrTVo5Tkt1eC9aTUpJNlVJdG41ZFdxMjR6RjRJSjQzYmZsMzFiM2VmY3VwVGdXV2w0OTg1bzVEd0MzSmJMT1dubTgwcFVDTnVLbnZUMHpES0xjdUk3bVY1S1Y4SkVWMEdOSXpzeTNEUE9XMGZFN1h4dEtXaDRmYzhtWmQvbGwwZkxycW0vWksyVU1iWDRVWlpWZmJhM3ovdEZ0cmJLVThOcjU4Rmc1QUFDM3BGNldXL0ZLZXBmWkI4blFhQk9OK08veVlMaFdoNjI2Ym1sMG0zTGY2bkxOejFIWHFmNzdMWDNoeDJvTjU2UVU5dkVsVmEwQkFKNk9WMENsOXo5enc3YTI5alEyNS8xTkNXL0Z0ZEpZK3l5SWhvSjZjYWloc1phamRZRTFiWHYySEQxMXFQT1J3bHZ6dkZmVnZDeFN4N1UycmFUMDIrWjNaM24zQ1c4TVgwd0ZBQUFBQUFBQUFBQ0FKdXh0QUl6QkhBSUFBQUFBQVBnR0F3bHVCUU1hQUFBcVdCcmdSakNjQVFBQUFNRGk2NHVwNXVrdUsxNlIvcHRuUkdQdGVhMjhKRzBQZk5WYnhtcDY3MXY0cmJTajVPRDFTTjYzcEJ6djFuRW1jQzZRVXpBWmovejByQWt6NjlBZDBhc0xwRURhSUpkZGYzcmJ0amNld0VLaVprUlhHVm0vVHZWcDczQit5a0ZUNjhub3hvY3lhM25xS2RQYjlidE84NTREL0RXN0Q1NkpvZnpuNmc5UmJjNWRXVS8xMndCY0RZL2J1WGRPQkw1bEl2T3FYR3JNVThXbS9naVg5S211U2puaURmL3dyYi9SSTV5aERqZmdhSlZHODVWSlpzUkNsOU4xaU9xc1doNHBjTitUbnpjc0IrczBVdlpJM0F0Uk45MFZmaWE2TEFCQWc1VWJnOUo2Mi9QTTBHMTh1ak5Ybk5acU52SmdWbStqZStLdkhHd3I4dE9jWnBNMGlWeGZDRWI0MzdKQ1hUSFFQbG16bEFhejluNXA1QldYUFJ3QXVDSlIzMmpueDZkaExxdDlBUjZOb2JYNnR2eVQzckpDV21IMmxaRzBBQUR3MGJGbXZDVVJoRU9lcEVldmRIMGpLZ0xNM3RPQUxscDdtYjF6cGQ1WGlUekhINjJEOVBIUTI5UGJVYXNFMmdNYS9ZOFZZWW53WC9FZ3NPZHo1cDZIWm03T1NOTjdtcmdYMXNZRnJCenZ6S1UxakxUcHlna0tsNlZXSkkzdG95YkxoMWlQMXBzRzBnYXBpN3JObEJ2NVlhd0ZjQ0F0WGRiYXR4a3VPMWN2cDVhRk1pZk9oMlFBOFhMcVk3bmxGSTE2RDVGVHo4QzVMbzJJd0JsNk1lb2szSW5vZU43emdJU1VGc3kxMWcrT09DUE9hR1NqR3g2Q2R3N1YzYk55eUNUakdqcXhiTEZWTnByM3BmcVpaVDlBMmFtN3MyY3RySmNDTGR5VFZ4MWZNNWRtYk1XTTVnTUFjRHFpUXJKWHA2Lzl0THN6dW1MdHdld3lKU1hIS3FQbkFheTlPN1RIZ3JEaUxYd2F5dDA4eHFhR3FMTTY2NStTSE8zRDBKclFyeW1ZcnY1ZGx0MEFBSEFGZXZXcnJVcUhMSnhHejRwdnViaTNLczhacnUvb3N6Qm1Sa0VWUi95OXlZaFRsWlVZc3dEL01kdldicGwzUnJ4VjAzS1dyL1hXekZpQXBBVUpIV0ZYUnFlekZGYUdyM2l0enJvSERtWThVLytReGpkZlROWGFaeHFTYzZtbjhYTm4yTU40OWVmc0p2YWsxWjR4MkxadUd3aEtOSVhUODVCWVQxbHdMdWdUY0NEWktqV0hEYVVlZVpVRGNVRW1HOWVSdEFBNzR0Rmx6ZWRmS29mNDF3UDd6bkU5NndCc21FQnRVTlQzclh0NFhSN0xxV3pSbnNKYitsRnl4SU43NCt4MzRkRTJOelBtRHNNVHJvYW1kbXpGZmUrNDlqeXJQY3ozbXRDZGw2Ynpwa0NhVjN4TGZ6NlRRRUE0SFlZMWg0NTR6QjIxYWdHUlRTcnJpYjRJc3dUMGlqSXZUTjJkbnJXd3QxbG1iQVBQNkJKa0FRRGNscWlBNjlYcFBRK05MR1gwaCs2QnQzRkhyRkRMb2Q1VEIrdXBvRjY4VnZqSUFGclp6NjhYU251OGFVTGNEOFVyOEx1ek10bXlkakhRcHIzT3hwNjBBQUJucFZmdGFMMXdCRjJzMk10YTVZdXczTy9Ta3BsYUNaUXlvbzlPWkUyZFpOMEdhRFBiMW02OWI2T284bFlWamx4bWRuVUhITW1NWjRJc3dmMll4dHlmMlhzYTJxcytNN3RPR2c1T2tmRXNQTDZJNkgzUFMrUmhwZTRhdkwyWTJxTndUcUhWMkpvQzYzbndHRVNTY1gra0tiVzU5UG8zT3Bhc3d6L2dtMVlqZXh1Tnh0MmZaSVI1K29KK2d5Q2phL3JTSVplYzRaSEN2WE1wa04wbEdkV2JyT043a0VHd0k3M3pVQnZHNVJkUXJaZFRJeSt2d2dXd0RLTVg5UGswTFBQK1RFM3RxZFAwSmRBcjRLejFPRytzejAvRmNLS2tobnlUSHVXenhuK2pxTkM4WnJqQ25mRHNYWXptcStYOVZuYUhRelpGMWlGdHgwek5YTWpEd3d5OXpCSklLeGI5R1dVK0ZHazkycnZNYlVPdGFqS2pVMloxN0I2MkcvUFZ4Rm9TUnB0UTB6TzM2djRNdEtGSjl3UEFvK25kbTF2QjFIejNXT1JITi94bkdDdWp4a3kwRHRxVGRWbzZpV3lFZS9JWXBXTjhmRzBnbFdrV2pMSGFjUC80K1dtd1NFR0xzN296cXB3bHZTaFhlZ0NBSjdHSFl3eFVXcy9TejE2dVBGM2Q0Zkp2NWovcitVRi9BQUFNa2Q3L3pJMU5qQi9UWkhMUm8rK1dsSG5zWVpHZmtway9ISGw3V3F4SHJiZkFmVzlaTmRGOXp4Nzk0dkxNZmdoWmlsUEdhNzB2ZVJQTUw2WWVBc0x5VnRSdWFBbnZmWHlRQ3E5R0huSFkwcmpuQVJrSWs1QkV3eVdJTGhZOWVUbVRNUjIvZWFUbEFVK2gzTWUzWGpybHBkUWJnVXg3SEN2TW8wTkV3c3puek9CNTdLalRSWVlpd3hhZXlBcWJNMy84b1Z4cjZiV1gySnVGS2RmYS9lZ1ByaHRxeFZxM1l0SFBnK0VQNTJpVmhqMEpnSEZtK3FWSDV1VG8vR1grQXdEY21UMmt2TGVNa1kzUjJjWkh6OG9iZmNOd3BrVThxbkcwanI0STVydDhTSldiV1hhVS9qS1UzejR5VEMyaXpiM0NxUUlBQUZEUnUvVE5XaHBmU0s3eFMvb3JXTDhCNWxLcjdzVjFyeFhZZXNHTnFUdUptUUtjamprdDJSbTJSL2Q1aHdsRENXYnc5bUxxY29XMW5rMlIwOVRxdDR2WkRaeEdyODVmZDRrVk53L21BUWJSa3dwcC9QUGcwVFEwMlVqL2dZRlh0bnNkWjRjb29KYThPb2s4cTljNno5YnJFa1prU3N2RDROay9sc3BHVHNGa292SklHNHIxQS9kWjA1K0UrNiswdktoNkFyUmo5VFE1VjRkSmZVaS9UcUcxSFBXYTk3MUxpMmQ1T25UWjZsSFl2RDZWYUIwWS8vZENrM0hKRjgyVHRUWGtPUDBVN29TbFhuaE1zVHBkdEV3VHoxcWhGWExtaVNsdHJrZHBkU0FjZ3FVdnRsd1JkYnBaNjB6UEZMb1ZYa0hXU2p0aWkxbDV6WlJYM2c1R1ZvajB1QjlIeGJEM0VHb3J2TXhqWkVnOVVrWUF3RDJ4aEtQbFJKT0VxWlpHQ210aDZSY2hmV1dXNUc2dkh1MDFzbDJIMzUvbFhhRXM1MkRFSy9wWkN6bCtxdzVXMlZLWVJOUlpXaHVNWmRnSXZYbTBObHUzemcybThxVlVqeVpXbDFYZDk1YjFrV3pFWUZDS2ticXhCUW9ZQUZ3WmJabXluc1VwMDQ3RWV4QTlQb2hlbFRYNlNKc1ZYeG9lcnpUL2ZQLzdiNVdYbDRoUHhhMkNSOVV2NzVvUGNGZWlRaUU1OGpMaXpuaEdadFNYNi8xNWxwVjdPVmJ2YVNCVGx4RFZDWHIwamxlODJjL2J0Sjc5MGZaZUh6dUVWT1hHbWM0VDVoMGNOK21FZmIrWStoclJTYm1HU3hIdE9tbE5oRVZvQ2tnZEJ3RGdURVMwNVVqNGhDcFk4Wklqem02Z1g4RUQyRzE0S3hPWkYxSlBqQ2Iva0kySE1iUEplN3V3Tkk5NjFZMVQ0dmxoWHBCcnoySkFIa1o5czVackF1QU9SS2RUeTIzWHRYRWwrZHM5aVpWQ1Q2L3JSdXVINEFFbnI2bjBhTFBoS1EyQVhYZ0pldlRJcUJ0NXhENWtlUUVBK09ZeXVzTStrdHYzNnFuRnlFb1VlY1doWk1iTG85Wmc4SzdFM2dGVkc4Q1JnWGlsbFR5OS9kTmtoU051ZGxPMW5JdXQ0U3Y1UFFBQTdrcnZRN240TzM3b1dTcDZsNWRadm9oV21GZkxTcDNwdTdBMk5WcHZ6akJlQWZ3STgyV1ZPbXpKRXVoZ1ZtZjFtTnAwWkRkN2VoajJYaEl4cVhma2dYTnczeGRULzJLZDBLRDVQeTJmSkxPa0crdHQrcGJCNG5GZjUrcTZWUWN0SHkyKzl5UUNienh2bnBjZytwWTljMmcrMXFUS2pUVGUrd0FEU1BMNXNLSG1xY3lPbFl4c2VjNHFhK3JQYWkzZXN5dWhIYVdEM0lKRldNTWJ2OHBES2VXWXRuNUVqeG1ETGp6MjM2ejhJM2h0MDh1QjEvRCt0UHJYY0xLOFhpNUxTcjcxbklodW5tK09xbG5WWi9qQ2xZbnNBVWJTbHVIbUhKS2V3VFVXdlorOHM3TXNLWUkxZ2FORzljem5zK0V5U0NwOGRHak5jRVhVSnNRLzIvdzE3elQwYk5iTUtLdSsxeXNFa3hIdXlST1dzT2NlWEdSWktydDlsUzhjblJZQUxrOVVvWkwydS9QV3QvL2RHMjlvWGUrVjNQNUM2MjJ6M3VwK3B0OUQ4L1ErTGFTUnQ4RU9DbEsvbk5xVDNuUGZvM2tFTjJHYlgwNU56VXV6S25XZHpDK25KaVZQSWZPL2VlVXl6Tm5mNXZETjcyWFV0MnUvQndEQUZhaGxYK1FacUZxL3NzUXVzbkU1bXR1OXNhcStoVnRMWVRiS3JQMlhyYnpLOUs5NHVaRzNsRmRZRzdSK29EUWZHTGZ3SkxRNTRwa3p4bVNYMU9kV2xqUFI5bllzR1JLUk1iM1c2YWxZc2FmaFhaaWdpNW5MbExXbjBTcXJWNDlveFkvTzE5dGhLVUdhYTh5UzE5Nnl5N3h1MXZqN3Y1Z0tzT2x6MVR1dkl1dm1iZGRZYlNXSy9tQ1VFQUE0R3hFdjNFNTQxcW5lNmlHR0FTYmpWQ3h6dFI5dmIrQURnSWZYVkRyYVozS0w2Wnc3dytBWm5Nd3g2ZDFEaThZQmVDcm1jNXF2NTBDOXUxWkYybHpGTWIrUUdubmVOaG9QSnkrY2hOWkxiVE9IOGVHY1JWbUgyekhpVWxtNXBaVW4zZThwQXdEZ2NWeEd4OWhueFZxamRxMWNkYXpWc1Q3dW9iV3gwdU1sYXBXOUNYWFE0c3hpNFlBMnE1ejhhV2ZaNW1wYzRVbm5qL0NlZkxkR25UcmEzYmt2Q0FCd09mRGhuSXJSWmJkbjIvZFNQb2ZJeTNhTWJZQjVKTnRDZXpGRHBodzFmUzh2TW5vZHo3VXB2ald1WVRxem12aUlKVEdhTDhzeXpPQ1A1d1g1N3NGVythZk0rMUtoa1ZlNDRRZnRyZnF0dWk5ZGo3NDBxdFZEeW5NRjFnYjRMWWFROXNBWjgrSmNXSk9xamxkRGYwSW5ubVcybFdZVDB1ZnEzMVBJVXUyWXVZbFplam5GZEcwdDl0Nm5LQ01kKzFwd2MzVmRobnZ6QWxCb3lUTk5SLzIzdW04Tjc3OFA0bmUvbkpxMjk3d1o3L3NSTlZKYUJoTHlhanBlODM5VjA5T1ZXMXlld2Zub1Vlb3Iwc2NmUXQ3VkxWd01BRFlSODhrcmpzUFRYTnRscm4yRlpmeTZ6Tzk0bWc1cmhYK1U3U2h6Q2w1QjVUMjlGR0czTzVyN0ltL3hCN3lpN3RlZUlYTTc4NkhYK2FVUnRjMTY4cHp4d0FWemZUbldtdGZqZml6ajEvbU0xS1dNNTgwVEFPQ3hSTlpqVFFtejBsbkMzck9JYUVxYndpd1Z4dVA3OUtTVlNGVU91VWlSbkt0ZFZ2TFNZLzZXSU4rWGpNK1dOemppSGZac1pyYktpdUNKYnhtN1hvM0RhelMzSmtKNk44N1ZyNWJtMy9BNmkrYjlWM0twVGEySCtvSjhESzJSZmdRQU9EbWVwZTB2TFFlWFIrY3FRWlJPSTdwZjV2VXhqUG9peW1GaHJkWXREVTkxbTFkcVIzbi9LMjErejZzdTY2TXVVdVVZcC9CRXZIdFZsbUdwcU0vYXR1Rk1KR3V3RHR1TSt5a1kva2lrZmQvSTJrOGpUcWZ6Y2RJZlpxaHVtdHJvMlpPeDdqMW15RmliMFpZcnpGTGlQTzZORmNMNVJCejd4VlNFM3pKZWMwZFROTTdhOURQbW05ZW1qNlk3RlhVSGIxdjhCOXhjdUFIQUE5aEJqbDFhVktKbkFieWplc0szL2hkSzg5cy9jR1lzQXdtV2NmYW12dTB3WUh6REFxVDV6RkNESnlOdHZQYmtVWkxxZ05ZR2g2YmJPQ2VxcFFPYk9uTHJ4NjhVRHQ2OGU1M0VzRHRuYzE4d2RBRDg3RGwvdlE5WTRCSUZBSGdndHhYKzh1cVhHbUYyZk9zcE9xMXNiM2tlNDNSV2gwa1B6VnlaK3JkOC83N1hXeURsV3lLekg0cmEwOGo1S0V2b3gxNjczM3JCQ3dEZzdpRHZwbkpHSDZIbjJBd3J2VGxNWnVzUjZpWUlBQXdoUGZ1bVJKMGxyL2F3d081azRYWFRhNDVqRDUwRzloRWZCb0xyaHorZXdUOXRnbWc3ZzltSTI3clA3Rlh4SG9JUWZjWm9wTW0xZGE1MThOUG1xTk5teEw4bDFoeEtqZnRsR3UvZUEvUVRiWFA2QWdhUlRqaUxIbEJnRGR1bkRWUHZtcm9MZFVkR09yYkdHOSt6VnFDandVNVl5MmxLN1hSMXZOWnBqM1c0ZGpva0hJaTJrZEhTZzh2cnZDR3ZkZ0NUQTJBQ0xaMHZ0NU9reGpOcnRUb1o5UkVCM0JGcm4wNnl1YTI4bGxFOG83cDE2cW9mSjUxcmVuS1BBTkJzMXBWT1g4dE9SaUU1bk1oUTBsemNMeXhYUkZRUFpYZ1VSQjlpcU1PdEYrdEg2Z0NIb1EyRGxydlNRdlh2YkhIUVZRRUFGakRqNFpBYWJkUFJvMGVVMFpOOHY4emk2MzdsNDYvRHl6alcvb0xuWWYreURpMXphTTJXM251cHZWOVdmWDJkdFc5dDlScUMxdXJ2VVFKbnIvNFJ4ZE5yZlVSMjJhdlJVUS9JbjAwcXBTMWJHMStiVkpmNnZsWWZLU3R0QWlwNU54OCtLT0pJWDIyTlB0Z0FBSEJIdEgxdERPSERXZGtGVVIrTGgyeVVaV2xzOWYzdzcrZmxEUUNaeUY2V2N3NVpNc1JiWkFya2FURmlhUUdjblRPWnBsSmRwTGxWcnYyM24ydld5eFJlTjQ4bmIyK2pldmRjTDhJK1gwd3RIY2dvbG85RzYvNm9FSmJtR3o1R0p6UVV3R05ZNGFCYXdvWGswcW1xdXFkK2hmNEdCK0VhM3VJbXRwN0llc0FrTlFyanBkUUxndXg2SEpkODZVQ1RZL0JzOEtFQjNKSnNCT1NPSjVQVlp6K2QxRHB1OW02dWVPcnFmWXJGRzk0RDZ5bzRZYWhNQXYwRm5LeXczWHIzR2dFQTRLSlVlc2ZyblQzdFhiNTBnSTZ5NzE2dDUwbWNsYlVwT3lUeXl6MHZxRWFNMEo2T2xwNUlQSXFpL0t5RkcyOXRoNm5iemVySE5ENlUxS2Zldnllczk2VlVLUytVUEFBQTJKSFYydFh0d0c4SXNDc3piRkpjL2pmaG9pKzZuWUhWMjlmMXUxQXp1c2pLaDFmN1RzQU5HNzM1WXVyd001SEp1TmZ6dGpFUGFvcTBCRlNOMXFSMW1sV243YlFFV0ZLdVd5ZnY3T3ZNdndDOWdvcTVOWjk2a3Mxc1kvb0xuTlFIY0xUaWxleTJmK1BKK0dMamZmbTYxS05mYVcxb0hYWFZPakpITzBJSFlESlIvZERNcUpId2lBZFRJSWdsdDdScjVOUHVITkhrRWJzWTRCSjBubzUzcEFzTlV4WHVnRFgxdEhoVDM3bXNuNy84L2lQM0xIWkp2alRyWXpXRTVlU04yUHQxM25CcnJPRWFkVVZJOXpmamZpdGU0OUhyK3c5Uno1NmR4K2ZkMjFCZS85VU0yWUVmcTR1ZTl3Szg0ZWlSQUFEUDVVZTljSzc1U1V6OC9ZOTVJS1VuMHhicE81WFg0TWxoblRWVktYSjF2eXc3Q1JYWHpNYjN2T1RyejNSZXhVc3lGR2R1dVB5eitiV01sckhxWVpZMll2WDhRQjIvWHQ0c2IwUXRINmxmNjhtMC9WNFBPVFE2Nk4yc1E2RUVnTE1UbFZObGZPMzVIRTIwdzZXbzNWU1cyeW9aMXoyTUxwK2F1bTBkSEEvd2VHYXRDVkorNlROcEhWM0xwc2J6N1BISXRtQnJpV1NwKzhiYnlHVjhHTUs3SG8rdW9mVzdVQzJ2aHJWUDJoSVZkUnJ0K25aNE41OW52SC9sRVpZUzJ0N3J4ZGpuaTZrYXI0NUcrTzNHa2NLa0ZwcXZleElSSWYxNG4ySTJycVBwWVgrUWc3Q1lxTU5xT2RFeHY2T2NtbEhVNFdJVi9RcmdEYzNSTFgwSmlpK2lBbHdicjZQdXRDQ0Q0SVRnWWdEUW1iTFc1TTdncUUxZHhIZnJ2SjVObU1nYmhwNnlab0FnZ29LZXZVVHZDd01BTUpmUnJTNEFBQUFmWXl0TUxsNDA5Y1R1TGNWVGRtckU3V2ZraEpHb1o5YjdvcW0zeGFOUDZWNllQWDdtakNkci85THpwSzQyaEVhbkZIdm5BSEFWdkVzcHp3WmRrdXk0NTlXU05BNGRFcXk3QU1kU21FVlJXZUo5WCtvSUVDa2JtMWNIRUoxREkxMUJOOTZBQjdtbE5Kb3ZwZzYzalhEeXdnZldtNUxNTkJkWGVjTjlkTTYxZkphUG5NK1JvNUpnZjd4eXJ6Vnh5elN0RXhzQURPcURrVFNEMFRwUlpSalBudVQwUXVjeFVyVmR4WFRQOFZKU2ZJQXJvQ2k1a2ZuNmRiZzA0LzZjZUJjbVYwZHZ5TGNkT05wRXNSNkJzazZEUEdTSVdBTHJ4TG9SVEtBMWFiUko1QndUbm5HZUhlbGJNRHpoam5nM1lxVzQzWGgxMlBUK3B5Z2lwSmRROCsvOXJPVVp0UnM5OUNvRFBYVkExN3NGWG5Wb2o3Mk4ycGQyUzFwN2VKWWlzYUpSOW55WkhYa3h4QXdUM091K3RCNkk4c0FTQVFCd01pcWhySzRKUVY5WjZlUDNmcEZKWHg5MG95Ulh0MThmcnl6WHJ2cTZsWE9xUWw1ZlJFMUNIWDdUL0s1dUVaV3Uvc0xxYndtNXV0K2pjYWNpbnl6a2tjUzZ2ZTVyN2ZCZlhsNysrY2hkcmtQRTh2ZGFCdHFteGNwTkRhWGVIdzRBbzI0LzhWc2oxNmhTMU5GdU5VdnQzSThxZjFLZUFBQkhrd1AzdmJMTDY4K0JZYUsraFpWdTk1VzRmMmYxZ3pUdGlpK2xBdXpBcCtIM2ZyK21jMTdXS25vZDVzMGptbDR6QzZSSEsyNUJyek03RFlaRE55djJOTHowZUJxODVub2QvM0pEcUhiUXRlSnRtKzBxNm5IaldHbWlHMk1uNTU4TkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNREIyeGRUZTEreVZ4bDVXN2ZuV0FSb3ZtWHZmWWw2MW1rOW5wTW9vbVZFemgrOE5Wcmp6amhhNlNySE01MFI2eFQ1a1pNWjZRK1lRTThoZTlOT2JwT09LN3JBV3Q5ekVJbW1UMDMvV1NOSDhWbmhQUjFlSHdVTk1CR1BYbGtQMjQ4VG9RTGpraStvbm9qZUU5MTJFY1R3bDNwK2xuTnhtaDdSV1pkTktIK0dhaDRpS3hWcFhkZHBKVDBLN2ttdFQya244aGxqd0JyZnJmQzBIVEJQQUU3T3JMRXZxUzA1eGNyNkVRTzV3MWY3bmVEdFF5aGJRN1JvNjFSTEZsbGZNN0dVOWswcGM4YnhybkE0bnZYRjYxUHBYQ0xWOUwxeERzZGE1QzFhSDdIS3pqSXMzWmE1ZVVraSt1Q29MOVNhMzFiOG1YVUJBSGdpbXN4ZmlxRTNKT1hyUzBuTFI4aW10bjllMUg3L1ZCWDJHNXlydk4rLzRwbVVzajNrS2s5TjhjckdDcGFyK3VVaVJTcENwRHkxTDZKKy9FNUZxWHR2clZUODM4YXF3MmFHUzdGZk5ha2RhdjgwWW05dktmWHdySlRsVll5MXN2UnkydmRhWlhyRHMzTFphUE1QZjZXejdKZmp3MnNmYU01OHJ5OUNxSUpwaEZyM0FRQldzOUtIY29peWQwK2lXb1RsTXR1RWRNbHg3YWxiVkF2cElWVzZlazI5LzdCVit4SlNHTUNqV0xtcFlUeFlseFdmdjViY21xS1NuUExLcStTNEw1a0ZkYnhiSVRWR3hGYnhMa0F3RGEvbExwRzJPU3FnWjR0T2ZGYkJjZSt5UTZkc2pKYUNWZDdmdHJpZzJwVHdPazR0MEtTOG8vNk5rOEVYVXdFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQXhkc1hVMWNjdXJOWkJYamVGZ1kzMnB2dHJiZmNyUzd3dnZqOUNzdEsrZEtwRmY5dWJhS0hnbHdlN3h2dnJ6aDVtOTg0ek1FNDNzblVHeC9Bb0VkMFdMVFA2TzNBT3E1b3gvRXZyWlhlNlpxZDZYYkhlNXlOdCtMUm8vNDhhUUVHYUI3MkV6eDBXVG9odlQ0TmpxK2w3b3hITUd2cnlHa0Y4M1B3SEdCK1ZMY3NXYTQwbzF1alB2MnN2R2NwSU5Fd3VCWTkvUnpVMGJ3cVg4c1BwQjNBT2MxT0FEZ1F5NWF1V2FGdWZPUlpWZW9uM0RvOXM4RFNaVTNkMTFPV3BKdTFGdjFvNDNrZDBIQktSZzUxOVlTVjlCNHE3ajNFdHJVbW5wcm9EeDBwdzNzTmwwSWJPdEw5MGE0ZU1ZOUc0Z0lBd0gvMHFnSkQ1TGQvUHI2MjlIRmRKdzhJL004dnBGYnJ4WGVFanl3L0d1YTlVcm5SY0syUDAyUlhpcXlFcHUvUTMyK2ovbjRwTlNzNTVFMHU0VGY5SnNTb3Z3WXFxNUhwTzU5WEc2Wk5MK2szei9vcnJIVjRqUDlxVWQ4cnkvZnhiNVZXTm9UZnkvSXEzYjdkNXRyMmVDZVpNZVM4bFhpcCtpU1NHTWNJci9PMkp0R0hNMEtvbTdYQm9PMFR0ZktScmx1VDFDb1RBR0FGdnFXaUQrVFljbnBkM3Badk5CdlhaWHh2bVI0c0Y3OFo3NlZtNUhaNDJLRXJWUUxneWtRbmNJZXZ2N1ovZjdMVXpJU3RqVlprY3NiMTBCSVJqMVhSczNIOVFyTjNrSjNUV2JtbjBmdmNna2VkclBVS2J4bVh4N3VmcWJtRXREbmw4YWxZZ3lSYTVzbmhpNm13RzZ4dEFBQUFBQUFBQUFBQUFBQVFoZjBGQUFBQUFKakJrWG9sT2kwQUFBQUFBQUFBQUFEY2pUL1NUZTJFRlpQSXlReFdHbzBaSndFOWlQcTBpMnpFZWNWcmhYdTYwN3J2N2ZaSU4zdmY0TDhrVWtmT09QZ1I0clJPbW9tMk8vMEVnM2hscTNUcVNUVHZMcUpIck95RTU3QlQ2MkNobnJWd0dxMDF3WHN5YkN2UE1sNUVDUUJZaU9kUTVwOWhxNHoza1ZQVjRRQTB3WnlDMTdBTVRTMk82QnV6OE5pNTA0Z1lzWnhFQ0I1YWlxaFRqMzZ0YWIwaTBXTS9XSzRJeEM1Y2tlaGhsNlpabFlzNFNWOFNYUE1seTNGTEhmYWpqQlRVY2JVSjdMbmZja2kwMWtKdlhYcU03bHM3aDYrRk5iZTJLcnhPTzlOLzFlUGUwT3B3eXVHVmpQdXRSdDRhY1VaQU9iZ1ZzK2ZCaXVIR1VBTUFXSU9seTJueDZ6UXRtK1hEQnF2MENOVTBxUkpLZGxEeSt2QTB2OHhIK0dzalFsOTV2SHJrWjVGWnZGK255TUtxbDkwcm9mZDdIc25NWC90S3E1eGpFdko2L3h4RTFHVmFsbXVab0w4bCtuNWZVc3A0ejgwaXVvbWh0WU9rdEFzYlgxa0lyemZLUG14dXJTNUZwbm1yOHF6TGxJdTB4ckhMVnNtKyt6OWx6akJDcGZ2ZTlBQUFzL0FZNFdGSHN4SVgrYlViVVplOXgvMXVhUm1iY2I4T2I4VUorMnZyOVZwN25tY3I3SU42VGE4ckFQQkVvbXRDSkF0Rk9HaExoU1VyUExKRUMvZjhUSzA4eXg2OERack5Vb1p2bTM5eGdHRWlhM3ROeXdUVnpHRnZ2dHZXbmxPU0hxSE5JVW5mdUR5OWpkOVN6T3J3U0lkRk92d2luYUYrTVJVNUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUR3TEhpWEFBQUE0Rms4YnUwLzRnZmZzSkhULy9tLy84LzE0dmIvK3Q5Ym5KRlh3bCswVGt0N01OWXBOM1ZZNUxBRTYzNFU2VzM3OHRwSzQ4VTZGS0tNMTF2R2RLSnZzRWM2MkRwYUJQcUlER2l0elNOOTR4M1k4RWk4NTZ5MjhLNFYzYlRtek01RTFoOXZtemJPa1YzSEhoM0xHZ0lucFQ0OThTM3M0dy94OHVPQWMvRkVSamlHNkhHaFpScnN4dDJ3VEpnOXVpQnlJdU5oU0pWa3ZFS0xoZU5oZE9pMWhqUEFIWWtlVE5tNi8yYWE5VGhvWDhHQzdqcU5QZFlwcll5dHVtL2xnZkM1RktQdWlJRXBNenlQbCtKeFVNMHFvMmMrYTUyQUVuQlpJa051WkV1akphYTErRmFjVmwyaVU0bWhDd0F3QjhzM1dNZXI0M3JXQkxXc2hsMVV4dkhZVGRyK2dxWHlKT1Z1Nnl1ZTdiU1JOVEI5eDg5djkzeGx2NmROVlczMC9VK1BWaTdsOEJ2dVYzbmwxcy9DYUVyRmRTNCtNZkg3TytVY1A2LzNWSEo5aHZIN3I3VzgzNXBHMWRhMFBuKy9ITysvU0NuVVBQb1hnSk44MmJQSjd2VmpXRTN1SlRLaEFRQlc0M1dlU2ZITE5NaXhaZlQ2TzJhV0VlM2VxSS9GUTB2TGtyNk1tck12SGdCMDRKeExIdXZJZW1SZXV6L2krOVhpUEpib0hnNnk5SEI2OXpSVzBldW5nd0F0WWRscWRLK2Y0NlQ4c3dFQVFEK3N3SEFqR000M2hZNkZHOEZ3dmpsME1BQUFBQUFBd0huQVJnTUFBQUFBQUFBQUFBQUFBQUFBR09mR2U2OS90cjJSM2dCdVhWdEhFZTV4Y04wSjhZNUp6K0Z5MFVQam9sOERHSmsvM2hmQXRYdmJRTHhkOEI2TG1ZejRkZHpmUXlGaGxIcGdTMzFnSGZ1U0czbEd5Z2VvU01wMTlNVDZiVnM0MU1wS1pXZGxka0phdDZMVGRtUTlVckVXNWhiV0d1QTlNUmJaQTJjbGZRL3p2UDJjbUdnTjE0OWgzNWhUZkMxMVoxcUNXSXM3UTcrQ3FSelI5RDJuS3c2ckg1S0JyQm5OVmxyRzZ6MnhUcXFMaklQT0FXdFZJWnIrbFllbTBtdHBBTTZPWlM2NTFRM05HVnJkYjUzMG5hczAxcGRSUDc3cU16SUp2VC9VNDcvVTVKWW5yUmNFemluUWhyMFdwNHpudmUvcGFxOGRhTWIzL0NBdlh0M1FVemxMajdBWVdhZ2pUakM0QkpHaFBXdGVSb2ExVlFlUDI1TGhDUUFnTTZMcWFPckhxSnJTS3V1bmpPL01VdmJWNVcxYkxIL21WZHBOcit2WFBXdDlxbTIzTEZRbUNTdVJsRzk4dlVyRi8yWEtMNkRtTFJkdGxaVDFPTDJsMC9OOWoxL2ZmOC96OS85WjBDS3Mxa21ObUZJdDNuK25wNVhlMDc3bm1LdHdxWFE1UEwzOUpZVzhENWI2OXlYRlFrcFROUnV0akNyOFo2QXI3ZWcyc0Q3SHpHK1M3N2IvTGlzWGsvWW5SVjIrMDdiNm1NOWVmNzJRMTBkNDJzWUVIQURBYkVhWENjdm9SdVlONCswaVNSdEp4blZkaHJXbnNUWHV6K3BxdGV6MEh2NVRsL3lwVXplWDIxejhYc1luZ0l5bXkxclU1a0NWWGNRblhGZkJXbFkwRThOYi9aVnk3ZlJNMnlCVDRzTXdNL2MwdktxYXBlSkpaYWR0Zkw1ZkNrMnhrdUpKZUJxMzdjVFQ0K2V0WGRaRk9PY1hVeEZ5QUFBQUFBQ2dnTGtBQUFBQUFBQUFBQUFBQUFCUmpuaWcvWWc5RGZaUjlvVFdCZ0FBQUFBQUFBQ0E1NkorTVZVKzZVMElMQ05FWHBlMnJyM0h1RVRLdmpIU1NUbFp1YTdqbGRmYlpuZVJSbytyTlFmRGI5Zk4xamp1R2Q4UG53dlRrWTVhdFk2QzFZNmxxdU1ETEVJU0haRlQwYWFnblNRcUxVZzdWYUVtTmRLazRQVVV2R3ZDcG9ScjkxNXBXMjNmODhPOEo4Z0FCSEFQcWNacGI5YXBVM3dWOVFDMEU1OGlncmlWRit6Q0dacCtwQTdEOVk4cUU2OXdTU0hEajNFdk5EdXhEdGZpUjNRNkoxRVIyaXB1ZHpzQzRBRENIOUl3NW4zb0lXZnROT0lxajF6SGEwekMrb3RBdzFoeXJvN2pjVWJBWllrTWIrOFd6eXV1dEtjaDVaa2JaYmlIbkpSSkw1Ynp5RXEzTmVwaTZSRmFQQS80ZGFCZzFwWkd4QnphcW10cmU4eFRKNFkxQU1BN0kyck9xSXJVa3RzdFhhK01iUG4yVzNrbVkxOU1zNjFTVWxhbXlpWXI2NVRMU216Nm1oWmZwM0x4ZjAvTThqbzN3NjJ2V3RiWDBoZEdwYSswdnVlYnhGcm9kc0lyL0orUHVyUlViRW0xLzlRanRKRDNsRWxvOC9mZkovMmlzbzF5MFdhdk9GWVBhbjN4Ky8vUG1KSUZwZWVsNVM0TzJpS0xYQXp3Wk9WZE5lM24ySkdqMTNWK3E0clU4VUp6SnE5aDJGSWdZNVBUVDJ2d0FnRHNnZWEzOHFZcjB6NmNYcCtENXQ5bytVWTNJVTZFYk5SbFUrb1E0ZU4zMWJwQWx1TnBaQ0VpUXcvQWlXVGU1RVo0bmJ3MkR4bzZyR3hKOWQyVDhtdWh5VXBreFRjdFo0UVVUMXVRb0p2ZVBZMVd1QlJQWXBZTzBVcDcrZUVSMVlPVE05d2pielU1dmNvWGNSRG4vR0lxN0FackNBQUF3RU5nMFFjQUFBQUFBQUNBaTRON0F3QUFBT0Q2UEZXbmU5cnZUZy84eGZjc0N3QUFBQUFBTGdYbUFnREF1Ym1obkU3LzUvLytQOWU3dHYvcmYyL2plRi9sdnRuYnYwY2luYXhUWGx0cFJzcVM3dGRFRDJQYWpMd2VNM1NzUnBVNmczblZSMnNTbGZlM2pUYUczYkJPVlBHZXROSTFaQ09uNlVueTZJQjVFcG5HVXByZHNZNmM4VlR1VVlzaTNJRXM2QzZpUHRsU1pwMXpKeUxHWURJOVIzdHBKN3JSY2FmaHlLNklxQ0ZMQ3JXTzZJZG40ajArY01GWVdYMndQOEFWYWJuSXpHbXA2U0ZWK0ZzWmIxOFcyVDc0K3BxcFZDZGxvclcra0RyOXk2aFJtM05yeE84NVFSUXV5eG03TlZzQkh2dkQ2M2pycVV4VWo3UUVsdWZUQzFLZXN6Wm1yTEpnVnlMN2dsNDM1R2czdDlaakFBRFlqeEhWdlRkdnk1VVd6YlBPdnlkZE04K0dEZlpmZVBvT2w0eTAxei8vZlVsVUNmNzU2MU9sazFmZTM3dXZkUG92ck12K3ZON2U4dHdjSVpzWVZ4OU5kUzJUOG52ZlU3VnM5ZnIzK0dwWTV1a3RTMnY3VmhsVzJycmZQc2RCRmxMWE9jdHRYdmRzK2docHo3clBFZmZlMXB0MHYzWnNmT1NaUDlLL1F0NUxLMmpZSnByUDVTc3NWem1PQ0pua0NJOE5DQUNBWTdERXI3VWd3MjU0M1pNdEhkNnJMMGYwcDFGVVBVeDVia2ZNSStsN0lnRFFnWGQvb1NNcktic3lYa1FPUmNwK3BHcnV0VWtHK2hmVzBMYjNmOWxydmJhR1VobHYyMUFmcDhsUWoxSm5YZGZwVHNZNXY1aUtFQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT2lDeDY4QUFBQUE0R3Fnd3dJQUFBQmNpei9iWHVUQmNBZ2pIZTcyZXNzOStvYTlCeWx2aTVuZGZzc2gxUE9HZXphdUlVWTlzTDFIUlFDY2hCeThQdzN2OFVpTHlKUHVYeGJrRkp5TjZoU2YrbENmdHhNUHBSTVNHenJReDRuSVd0bSsyekNDZFhxVHhsRUdCSVN3RHVNNm9nNHQxWHk0ZnA0ZnpIaDhKak0rRXpXSmxVT1E0UTEzb2VXdkhCM242b25mMjZaK1hTZFhsYkcrZUpyM25JeVJzankrL3BZREdpRnphVmJOcVI2NmRWVE5WckUyVU5LTXdyZDRZM25tWENTK040NEg1dlBwMExZMFJoN29pdzRwSGg0RUFGaURwc0pJOXkyVlhMdnYrWEtUSjc2VUp2SnhRZzhyMUJEYlJtdCtLdkw3bjl6c2pKODhVcXkxczdrWjhsMTI4M29sa2daUzFrRWV1YjkxZXYreTZ2dVhSWC96YnZtRTMzTzI3MmNsUm54TDQvTmJwYi9YV2g5RStpWTM0dWd6dlM0N0diL3M5WVZkOVd1cHdzQ085a1Z5UkpKSDBuL3pzeWx6NnFrVnNkbXFlVHFzM0dyREhnQmdKU1ArV09UVzdveTQ3N3c2blRlZXBwdVBMSUVqY1hiZEZ3RjRBcjFyZ0tETUgybTM5OHErMnl4dHZZWndIYzVhdnp1V0tibzNzL1dJMjlNenQxbytobGJlRjIvMGZWNU10VGJ1WVRvdEg1blhpZHJUUGQ3MWFxU01SOU5yOGNFWTJpU2FOWUNaRUJDazU4dnZuazA2VjJieG5UaWI0Y3E5YzV1cEZKRU5XaHNpWCtCQ3ZMMmNXcE4vTjVMVmZXVG5NeHhNaXdPUWRGaDBXcGpFWkRWaUxxZXVISFFSNmM4REZweFpSV3BxSmNNWnJrcTNXeWVncjJndnBZbzZycURiSG9LM0lheU42RHB1THVJaFBHNUgzYjNicHA5TEUxMDJkOWxHcWl0bjJTcXRqWmJlTWxlbDJUTS9PRDJyVFhCcEtwVjR0ckpteUE0QUFKQnBxZVFSOWI0WDc0dUQwYlZpaE9tLzI2cGMzajRQNUV6dkxkUDliSTNRZUs4WENyMmtuNWRBMjQvcy9wWWRlV3hSZXFYUVUzYUw5enkxY1IxcGdYYUt6L0FVTkJUcTN6bTY3WnVGRVAxRlUxOXBTYnpuZVNuMU4wWlkwelNxOWpGbFhrbnlmL2NrVzNTYXNQQUl6WnJaaWpZQWdJYW1ZSTBxVkJqanU3R0hIdDZEdHNLLy9wMjkxSVUwd085eHovQUVVTkJNbERvOE9JblVaQTJoNFBFRFJNcjBWSDNjTHJ3cE5NU2xpWnFrZTZETno4dmhGVlJlcFUzYmM5YXVQV1Zhalh6eXh2OTZNYlZlSzZUckVMa3pERXkwUmJmVlg5SCtYTjFGK09VMlczQXdoL1pIbTB5ZUFUdkR3UTNRZ2VmWjBleU1PNDBlN1hOeTVVWU4zZE9Rald0dkdNQ1pNR1JFNitYVStuNTlPSGg5RXZKSCtBYkw4TXFybDREMlBMOUFoNTJXbFYxekFqVmlMb3pqWjdPdy8zUHd2aForSmw4UndFcXlGZUQwejZrcWp2SlNxblJ0NVJWaCtOVHdGUk03WXNmQ0pXbXA5Q05ZUXljYnU3QkRRNjMxZzZRZkhDMnNwM0t6NXc1ekVTcnk0dkNlUEJpbUFQQmtMUDBxS2lOYis0T3p5OHJPZTk2MGtmQUl5OWFaeHFia3AzMll4ZXVVWGk4dy9tYTViWTA2aS9wdzdCZG1jeVZPNHQydGNmZVZMcXZ4c3BFNlYyWFhMZklaVTd2ZUdtbTFGSExvYndmWFh4S3RZMy9XS1N0NTJ1aS9yNnpaNXd1azhSZUpwYkovZjJmNXd2UFAvZnlLOTE4TVBSL2wvbXZjdjlYL2s4aGpPa2tMNktINGZlbnRqODFYaVdYQ0JnQWVUNi9pTk1VUnZjMTNCajZZc3kwVmx1dHpWdmYzN0dkOEpTbjA3WSt2b3dNOG5iWnAxcDl0NjVrdloxV2lzbVBHTm9xMUZENUdkSmdiYnQvLzN1WnR3L3V4YWkrMmw5dk1yVDJVTUdrL3UrRTdGTk9WMTVaYjYyU04vNmQwU1BlK3BPdWlkV29QanBscDFPTTUwcDk3K01taTQvL3h2anZ2Vy9kMUd1WlVQNW93bE5BR0tFNW5PSWlrM0l2WW9OM0RWanY5NHlEMGJVRmZ1a09uNzBnbFd2cFdtYWRWQm5JTVpsT05xWlo0U0VuUWFYTTcvbWJFZ1ozd3lJNldnRDZUVndVK3NIeVNSMHpCcFdVbUl3eVpBelVuc2crOXFsL0xWOVRhaEFhNEVqa1FFRjNiNm9jZnpDK2xCdk9RNGkzUmVWZklLZGJLVzJPNVN1dHJyeXZpRmVkanZkSVdzSzJ2RERHaXh3Y2N2UitaQTE1L3poN2dFM29rWjdEdkxCaWFBSEJYWnJoR28vdURaVm1XTzhNcXM2V0hSVldjc0UzbWpEZVZIejIwZUhteStxRi9YelRORGVQdDUwWFVxSUdYeWo5algwZ3QwMzJWYmFUOTdGODluZnlDWVc3a1p1ZjV6dnZzc0grMVZFYzV4R2VqQ0M5bmR0RnVoKzBuMVA2Ri9pK2x4dW9xL2M1eVBMLy8vbFQ4di94VlNhelJWdmQzdzgvUjNjTFd6MjhKbVdJZWY4amx2TmtHNzZhRUF3RE1SblNlYlg2aUN0UU1aUldXMGFzLzEvRmIrNFZsZUlTWmV4bzhFd1FReEd2UVY1ZlpFZDk2aHNCNjlENHF0emFqak5kMW1kY2h2b0k5OFRwYm9nM0RXaitkVnBPMzF0MHk3VXFzK2R5S0R3V2FVM1JyWE45VVlQMnBGNEVhYStBRHRNakIrNzN4Ymt1UHY1Z0pPMGJwUjBmUmdvdXg2NUQxT0RwUElJK2liWUlJQlRnUWJjSm1YN1NmY0NZeUFIaXdiQzNQemgzeUJtNEErdzd3S09xbnJ6Vzd0bVB3ZTcrVVdwZmw5cEVldWViMGxNMGFDUk5wdmVnOVBOVHdBUU9FMEY3bWlKaEh2Zk9XcFFVQTdzcGQxSkg2Tit6eGV3NXB0KzlDLzN0QnJ4VkpSdjY2VTJ5VlMwTy9lbXhGL1h3aHR2V0NwUFlrV3U5RE1KNzRzelNHOS9KV3p0UDZaVmZycGVPMHJSejFnbGFYNi9ESkpUYnN2YkNDNmEyZThWeUQyTitlWnlNQUFPNEFmckpsckZnNkJyWTAxaTl0TXpMc2ZlaVBNUXdRSWpKZG5kdWZ3L1F1UjQrWS9sNzdLZG9aeU03cDVJNHc4N25ZNzMrdDl4eGhCOUNiUC9qejkzL2E2UUhhOVFmMWFKYmUzclVFb1RaRDRJMWVQVHR2ZXBOSzNUV0RVZC9oclprcGlLSkhGc0E3cmRYWTIwOFBPY2tBamlOeWlJMzJjSkNWdDBreTdwOXduSmZibmJOT1g5cjE1M3BlbEttVnVGbUdKM0lMVnFHTTYxeE0yRlRwTnRJUS81clg2ZjJlSmlNM0xaeFRGZWZScTl0bTV6MVlpbGZQOEN4TG84d3drNFJIWjlheGEyRndLRkkvMTVOa3NSUEVVd1ZOVi9XNDNyUjM5UENqd2xYNUdOK0NnVmpya3gvekxEVXZmOHNxSDE1TUIraVhrbk0vRy9HM1RYY2dzTGFCUUQzRTZudWJJenc3TXMvS1JQdWFXMFZjOTNEVnhybDFMenZpZWZMMnNsaVBDSUVNZUFTOXZ0Rk5TTmZ6Y3FwVWwxUDZad0VBZHNMeXU2WGdmYXVzdlBrZThaR3VXNzRJclY1VzJWbkpVMHBmMTYxM1BkQysxbG0vT0pvYlB1eHlyeUczMHFUM011dXlQbjkzZXJ0K2ZhMHlKVjNoMUY1bVROK3QvdG5HeXUvL3ViODF5OXFLL0hJalppdjBzeTRXdWFodkVrcklIM1hVeGxiK1NDR1hWNUxlNnRGREZ1djIrbDJ0bDFPMWwxR3ptbWRiWTZwZnEvNjh5dUxZYU0zZittdWx2MTlmVFZYNDUyK3BmU205dHFZK1ErSWtiZmhXZTR0SkNRY0FXSWFsckdsWUNxZDByNldFU3M1Q1dFNWJ1NUxqUzBTMkUzcHA2NU5WSFVwOXVyRlptUmhyQUQ2eU05eHJmRS9FOGpGWWNXdWJSTEpSTnVYNnNhVGdOVXluYmFGL1VpeDkwK3Z4NXI4cTdtdnhKVmJZNEtjaW9oaEZPc3NyNk1yN3FoTm1PeVZmTDZaYWRzSUt4UlBXY0JhN0x3ZnZQNDZvb01pT3ZBQUFqdUJBR1JUVnNjbzFjdVJoS3dCWXdHdUNKbCswTCtxSFA2cTRwcCtOQ1Ewd3hDcEhXRjNHdHNYbTl5NVRHL254UEM2MnllNTVaa0JMNDcwUGNIYWFEMU1FTjJSL0hqWjBQS0I4Q2gzVCsvdnFhelllNFNpaTltQmkzUUk0RStYMGJhNi9FOHNEQUlEenNJZVBjRGJlMXlBbkZ2Wk41QkZFNGU3L0dKei8yYVUrejA3cUtFT1ByWDBoTnIzRmtwOXd0YlQzNkFpU1hxTjgvK3VLMUMrbjdsdTIzcXIvWFRucUZmUkYvUFdmcU1PNUY4dmZFUjBlcVpHblZZZWUzMVYzeEJVRkxBRGNCODNRcis4anAzWmwxQ2ZxZVIvQ20zWnExNCt1cnppTEFFN0x4ZDZwdWlkTEJUaDRXSGtBQk4xNUF0Q0pmL2dqMlEwbHJza3dZOFZBT1F4aG5TampvZGYzWnFHTktVK2RzU0crYVhYT3RmM3A1eU1xcjZJbklVaGwwWC9neERyTngvT3loamJjaGtXSlZvbmNLT1FFOHV0VUl0U3l2RDBWTGROa0kzemJrRDl3YnBJalBEZWlEWXh6MUNzblBXODZSZUxBSVhodEwybEp1ZlM4aVJyT0x4QVc5OFJ5anJYdUx5YnlJdmEvMnpwWUsrSHN0SjZOY1Qrc01hSlBwcTM1VW1yMFM2b3A4Rkxzc3ZtSkhRa0tYbGZEUjNqTEpuQ3VzLzk4eC92WGsyZnJmcys0dG55OWxpTlB5d2RnRWxQMmU1WDBsanVnOVhKcTd6NWhOQndBNEdyTWNFVlk2c25ybm1mZnNKVkhxMHpwbnJWdWFOZGErbXpFOStEWmZ2Z3F3OU9vRmRwVzNjZVhWS3MvVW1YNFpZZE8vRi9VL1BIMTFNOXFhNitSdmw3THplSjE2K2ZMVGZEU0FuNTdxUzc3NTR1Wkh5bXpXbFpadDYyNkw2RjlJZlUzM002anhhdTFabWdpcmUrdDF2MWlwZi84OHUzN0w5WDc5N09GUHVldE1TQ3JQYnZXci9ydi8rbWpodC9EK2R2blVmeXUvN254NXZmNExzdmJyMWE4MnVjaXhSVnYxSFdxN2cxUks5YjFOUURBS0xXZzErUll4RytIZkRvZGtlWEowbXptYUQ2K3pLMXlQTU8wSFFBQVh3UjFXSFdQcHd3c0xsdStpQmxrNTNWU3JoL0RiRnNGdWxuUkZSRVZyaWJxaC9QR3U4MGMwMzZZcHdOYkFpazN5ckRxSXVWM1l2NjhmdS9vSnVWSFFwUzhYYkdhZkttaG9KU2wrT2RjUEg0OVJDRUFnTDJJcnRtVzF0bTZ0N05zYStrNHQwSjc2Z3ZnQ2xSR1U1TENxbXQxWGcrTWY2WU9nSjg5MXRaRDV1Ump2ZElBUGxncjRmK3o5MjVabHF1NkFxWEp5dXAvQysvWGJjWWRZMU9WbWVFSWpDVWtBWDZ1T2ZjNUdjdThqVUVJWWNQajhjeVhEUC9taDZVTnY5UXh0dFI1WmVuRm9hOUJPWmZYSTF3OGg0ZG5jYmJLOUdqN0R1dGxjREpITkRmUFN3Njl3NngzS3Nhd0JBQnY0KzFMT25kU2Z3NHR5MlUzT3Z0ck9ObmRWbVdsUlVydGJhR2p0SlIzS2R2cHh2ZXpXWHZ2YklMaUU4dFY2cm1SZVcrbXdyWDJmcWdZSjVwSDdaNENjVWNWWndBQWdDODZselNPSDJwR3gzVEdRb0JUMkhWVjQyWGNlbFo0QllpSFphenlXYytheXVpaktEbjZlMk1lTzh6Zzk1OS9yQVhFcEhuV0hydXR6UnE4M2RKK01OS0gwTmtJVzFkNXp3ZmRYclNQVW5uc1h5VGpHcTVERTM2YThWdnpzOUlHY0NESit0TGQycFRPTkRCcDY0TXY0dGEzTmJMRFNwMkdkSjJWM3dBWG9qYjNYTDJ3bjl2eFM3SFZtcExBWkt5QlIzTkhIajBLVGYrdzNJNGdNbzR6MTRScFNEWXZhWjU0Y0lQclNiNGVHK2tUOEFsSWRrZk5kTDNaRENVMytraVNMN3Y2WlhCUzJqcTFRd3E3Q2FZTmh0WWdHZDJaRStIeUVYaWFqSGF0cmxPa3l0K1pTVGtQckU4UjNxVTFhbHVKeExOZUZ2YUVCWmlBdHFUUjh1LzlpTFNYRVhNbjNRY0Ezb0lrajYwNWpEcTNxZHpOOWNBQTBmQlgyTzhpS3A4MXJpUWx0VzlYSlpONnJwY1g0ZHV5M0k1VHU2dW50UW9CZi9UaVB5ZGQ1cDlDYUhFVjZrMlFkSk8rNUpPcTR2NHJTLzRPdDMzaSs2cE1pbnRWeG9iUG1wZTJYcFNYZHQ3NzU1NDJLVzlEakxWZUtXM0pYMEtMazR2WTNyVHFYSC8rbGR2eE51VHlmWHJwenFPYW5LMm4rdVpjdDZCL2QvUGp2NzhQYTA2NWJMTlMzWlhMYlpxN0g4dllvNDRJUlN1dmFGb0FBQzAwQmFySGxsYUhSMTRkanRmRVB5dXZJeWgxM2x5NGlTZVlmOTF3RnVLVzFQNEE0RVI3WnpVU3QrSDlkSG4xT3FLTEFubWhjaTlnbHMyc04yOEo3NnNEcjhFeWlGaDJPOC82Y0RRTnE1SnZwcFAvTGk4aTYrandlYlIwRU84NDlIRnRySzZZSGtWT1NoT3VCOFVMM2tCRW03MkI3RUdFQXJ5STFnc1p4VHNVMGd2UHpGa2VCTVlxQ0dMWll5Snh4UUE5N1JIaEFuOVlCNkNIeVRTYUwzd3ltKzQ2T0FaNCtwS3Fvd1k3b2hrK1Z6ODlMMDRHMHB3U0RsN0JsUXVnSmN6L0FQeWtRZitqR0htM0ZRRGdUWnloWDExaHVuaCtucDFQWlVvaE92UGV2TUZmcExHeFgxMmhTVWV0dSsyVlg3dUs1eHZzOHQrUFhLL1JtcTR4UGY3TE5aUzM5ekU3SDc5TE5tcnZYV25YSTR6YVNMeEdKTzhMZHF5eEFjRFpJSHNleVIyR1F2TzdpU3lFOFk2bkdJc0FiazkwOXRlZURjSlVOSmxLNWQrS1dVTWRqL2RFMEp0My9GN3JKTlNndGE5emt4RW5DM0hBaFZYRnJhL1Z2UU4rblpiM3crOGpOMG5RbEpCSE5KK1Jpbm4walQ4TXFVNVhlYVYxUEFZU3VJaVdyQjlOMUMxbVpzaWpTYXZ2TXpZY1BVMjh0akxYWkl4bklMWUtQbnZYUXdBbjNpRjB0NnQ0OWZKL2RxVGhoV1ovQU40RjlqOU1rdjF3SERjWTJsMzVMRDE1OWN6TkVCcWZoZWQ1ZTkvMEgzaWZVVXV5OXJleXN0UklnRGNoVFk5Mkg2V3VmeTNEcXJQL1JrNDFuWVdhWjVkeEg4QkgzYlJxayttTzljWGlxcjNXODc3dkxtY3Nhb2hqWS9weXozdjNPZ2s1MDBYT3J3NDdxaHhyZVFGTVJMTzkxUDZ0TUJvOVMxVGFwcmFsZjBTbkJRQzRHNWJjOVdEcVUwSjRxUXhhdUVqYVdwcmVaYVdlUEh2ejhxUlZ4bzI4bHRTN3pMWTZSdW83Sy9yeWZyRTJmMTJtcjJ6eXZpeGZINmZ1VGs1TlJSaTV5QnUrVDYxVVl0UWZhZXF2VnVTaWJhUXF4YlFMWDZabFRBdUtQT284OTdIOWJVbC9jdVhIcVZLOWFOT0ZmVjNGdFp4Yy9Mc29lV1JIQzg4aFErWS93MExyZVdTaGJQczYyaTU4MTg4L1YvSHEwcGo5UFMrNzA5TzhKSS9DdkN3Ym0wdXFDdWRwcjZLL3NnNzZmVDhTWllYa3BhNWFBQUFmM2tsM1M3bXpKdnJ3R081aWcvbHVXdjlVV2JmT3FqVkpyMTRKOEhvc2hYckZPU2FrWkFjWDMyUElTZ0E3eXliaHRhb2lITURUOEhiblNIckw0cGh6QjlLdzdKTlN1by9zang0Rm8xY1FaZU02T2NQZGpOK2wvWUo1QTNnbzdWN0w4dE4yVWlQTVNGNnQ2MXRUR3dzbHZMTWlPaWNBbkkwbW4yYklvd3RrbXRlWWRSck1mT0h0REU2V05QMVNDOXRUSkFCNEhsMzl1TGZ6SXpRK2s1Y1l4N3p2R1FDOERza2dtUmJiVUttOGlNaTBEZUE2Y3FjNy9SWStrVm5yY1QxNGxzR1dTZjRBQUFCM1l1NzQ2MXVVM2VaWmYwRjNqQkgwSjgvYzlOMjdTOWZoVC9wTzRFNHppU3UxdXZNWXVzdlJacTdaak1vd1d0eGw4T25rYlpiSm1TY0F3R2w4eGpEMFdGNDNORERXQWR5YTdtOWNQV3V5Y0Ira1BZWjRmcmRsWkRwODFpUDFmRjhHQjNHVFN2NWRYbmhNaHFMbmpNK3BsMEJhSDhSTU0yZ3kwczZLdTRUMnJVR2RUbVFmUHVuNjhVaGJkY0Q5eWNGcmdJdndMVlBHMGxMeEN1d0RCWG12Q0QyMXk5WXlQeklHV0YvZGVXNmt6dE1hN0FFT29yZTVsM0hYWFJLdDhGWTZuanpCUUpNbFZQS2prV3lNcFh0UFdxTk1iMUtSY1ppNTJtY2l5VFB2RnB0YVdqY2tHWDR0RlJiZ01iUU1ra2tPdWtQUmRkS0FUdnFkZEtIYnJ0ZC8wenlpdzQxMjVBdm0rL0JzdnB0RzFhNDl1MnBMaUNwYytuS3YwMVlXTlZUL2FBRjZvSS9Bd1VoVGRHMmFYc2VKNWxHVEZEZWFQUUM4RWMxMlpvV1RaS0lXdDljV1pxbnNudlNzdlNTdFpTWHZrbFVydkZYK251V3g3QWpuVGRNS3R5di9uMU5MUFpNOEpVamEvZmhKZDQzMlR5ZmVmeWxYNnNwU290K25XMVk3TVhsMDl5d20rdE15NnRNNWY5cFErdkwvaWJWTjVkZFgrUDhXaSt6MHQ1ZERVeFV1cnNXVWVXWFZaNStuZGhmYmswZnp0MXZlcGV0aG05ZFAya253TFYwV05UZE5mdFVoOW1uckMwbFpkTi9iVGtyM1A1RnllVjJtbUlYd2dyOTRMMHFlLzBxNkw0TVV2L2pqZWx4Sk1zaXUwUVhiRVFCQUZ6M0tXMHN4WkNIcEZLSlZxNzIrTWVQeGFNTlZYRmZZczllamx5V2lSbXZhRnNESEV1MzBsdkZBNjJ4YStDTHMzLzY4ZDNZanlacm9rS2JkM210bGhWZjRlOEloVUEvbnFHWDgycjhrTzh2U3EwZlVhMVZKOEhza21xSzFWTzVTbk5XL3oxUmtLM2MzcmRoZkN3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FnL1EvLy90LzJmUFI3UC96L3k1KzJCSG5jQ0lmWDF2MGZ1SHUzZFhDK2lCY0NqdHo5NTViNGYyQy9mVVZjUUdST21Xbkw3aUExczRqMWpnZGJwNnQ5ajFqbStXRDhXN2FvNDAvbDNkblRSNTV0N05CSHNFRHlaYk9ZOFd2b25yMFVMcktCQTRiaUFyUXN5NW41dHd5a3ArVXB5Zk9VR2FSbmY5b2w1L05DYzkvWklwcVlaOE9BZkFnSXR0OVN0RThzdDhZREQxOVNEckZvdWMwVlBNa1ZlYUZjRERhNlRUTkptY01hcnQycllScmR0ZTFEUG5uMnBNbXdKdUltQlNOQTUyKytVOXg3eG1HUEhsaXp3R0FxK2l4UjJscDlNYVA1REVEYTczTUc5OGJ0MGNkOHk2VEhXRTdPWk5kK1N1SDd4TlJ2NVJiNnpUSU1vbWxQcVhWV3ZkTlZ1bms2NTJ1SUJ6cnVNMDZDMlgrdXMvS3ozS1hVa3hDNmxJYVd2aXhKUTJ0a3BkbUdmYmg1VHIybmVJcVA1ZWZNdXgvZWRLeCs5Z01hU3FrYlp5U2xpcUJObFZXSnF1UGJmTlV1NVRXeUtMVjVGSHFTMzhBZ0N1NXMyTDlZWXpvNGlVajh3YUxJN1FJelVaTTB3TDRvdmREalFFRGRLbTdSNVpvYS9jSXZmYUxqOE9lUUNKQWIwelBlT3ROdzVwNmV0TnBsWUdtVmVFVmdsNTVmUk00TVJVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVhQejI3bnpXcEdmTFFoZ2lHZTdhQmdiU0k0aytKdSttQ1pHZGoyZnVVSGc1STUzSjNHYXZjZ2NiclE1YnU3cGtKUTJBQTRsc1hPSGRKTU9kbVNmekMzZXNxN08yN2pjNzBqcWR5S0RvU2NQQ3U0TXE4ZzFtSUxUdlhKMWlVNU1DcDA5NXQyV2lPUS9TMnE3SzBsRTl1K1ZGOG9YRGtJYWpzNmNha2QxWHU5V09ucHVnTFg0R25qbjJTZnB1TXZ5MEp0a3FhaGJDTEVKNG1qczhFbU4zeU4xaExacHVFNWt3cnJ0clY3cXJkYXFwZHVKa3k5L2p0eW1FaEdTUXBjT0RrL0wwcHJycDVHVlpQS2N1ZlRzckE0NTVJckNReFpwTUhTZEg3YmNqZ3lBREtKeU10YVJSWDN2Vy9kWityUXgxTzdTMFcrcTBwYjk2NTU1ME9RQTRnaGxyY01rWnJwVmVjcmpQUWhzTE5FYmxiOHU4clBsYlptY3IzQkZvcDNkRzB5amo3MUtxRk9aYXQvMXZYVjlaOWltWFAvK2VXcnBUbEJmNVdxM2s5bjN1Nnp4TFJmbDd2ejlKcHlwT3FyTCt0VWtySzczSnRvRmxvYnhyM1ArVXZMZC9mVzByZmYrYnF6c3R0U0J2UDlicU5CZWxTNEovbWFQV1creFRaejN4Wk9OQy9UenJxNUYrV2pkamF6NW9uU3Fjbkd1VnhlTVR2Y3F5bVBweGJhZXE0aTE1SHovdGZnaitsaUFWTXdNQU9BbDVDTGZESTYrNjBYUjZheHkyeHVjZVhkNmJ0NVNlaG5XSytpN3ZoZzVSbHlVNTAwbTBUM2dUVVRtdHhaT21DNUpNTDZlb2FlOHRKUm14ZVM5R1duVWFtdjlyOFZaZWE3SlRUM2ZydEdFWWVjWXRoeXV4ekR1OTNUMlNsbGVQZUcxejhRZ1hiOStKenU4OWxYK0RpdWZFVkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCdzhmdlBoN0xleldyY0hoK3p2Y0QxZUhlY2FUMlM2QTRUdVJFK0tlbCtWSlBvMlc3RGlrT2Y2aWNOK3E5aGVBWndFTktHRmRGTjRzTE4wek1vYUhMcGdyNFFHYWQ2aTllejI1S0wxbzRrVnhZV21RWXprWGJ5TlhZamp1eHl1Q2diZnZmdTBnUVZubTIzTkgvbWc0L21DWTlwU2huckhSdmhNM25nSEZ1enFTUm5ISTg3d0JQSTJvNjZqUzEwczFkSHFVK3p5R3FTSWkwZHQ5N1pPNS9SQWVua01FTFpYcVhCSm4ycFZZSmVsUnBwYlp5TmsyaTg3bDFnUTRFSEVkMUYza3BEbXc3MW1BTmFjYlc4Njkvb3JBRHdGTHhMT3BHbEg2K002NVdKcmJKSWNqZFMxcGx5dXM3YmE3WnBIUnFnSGVwaDViM1BJKy9DTDhFMGM3TzE3RWZtM2VtT2kxNjZ6YS8wNzBUTUxDbmEzM1BwTC85NjhlWTdJYmtzYXpqUHliSDFDYUxabUh6L25HYTZ6VXR2djl2VFdLVXkvZFJzcnRMY1BzR2V1VWQ5Vno5bHlPNDB0dUh5ZDdyYmVIbVhxMVNhMUV3emJWTEtYWGZjRG12MVg3M1RhRDE0bjdZVjByS3g3QTRTZHR5dWRVSmJMc0tKZWF6K2pyeDM5NW1ycDE4RjBQVG9aRmFVNFE4QTBJdWxVSGxCVG9YSmcvNnQrWUk1eHQ4WXp5bW5yZWJHS2Fud01YaUZSTXNna0J0UjB6NjZscFNHUEF1YVo0dXc4cExDUFFicmh2cW5nWXpaRThuR3RlYVhuUEY3djBId29QVWhiOStTd2o2SzNCR21WKzcyaHJzWVRrd0ZBQUFBQUFBQUFBQUFBQUFBQUFBQUFQZ1FybndaN0ZQenZvSlBlZEdlOTJQUGc3b0dBQUFBQUFBQUFJQ1MzNUpqdmJ1QWFsU3lkdDFxTVdzTGc1ZWg3blNtWE5meFN1VDlGdWZoL2ZxK0RLdjV2N29wU0Rldm5VZ0l4MkYxbnRUd2Y4bE9CSEF2V3VPc0piL0R3MitkV1NzQmJRdVZDOXU1dFhPU3BiT2NVbVNQNHRTN0RVMWQ5ejA3cndBTXNOc2xzWEJJU29kTTFTNW8yazdCWGlMRE04MC9TT1NvRlNyM2NYaFZnRHJza1hoMlJ1c3VpMmV5R2RtcURlNk5aM3ZBMWp6UGsrNkJ0RlREcUxyWFl6TXE0OUlONEhRQzg2ZWtOUEFzTlBoSWU5NFVvWXIwbldXdDJ5cUpTKzdESjZSNmpiOHRmenIzWjFPZnJKSkU3NlU2RUdrejJkcWQvTHNvV1JsdHJlNUwvNjNYUWxqcGhCeXgrUnY5RXVETnpGelNPSW9icU5zQThFQTgwNFN6OHE3MUVXL2NWdmlJYkl5K015SXRIMFhMcmFXcGhhL3hqRWU5ejFXN1Q2OU5SUXJ2dFVOR2JEVDJuRlQyM1oxNHFoWXViWDc5aWJjN0VWTnN3T1hFZVZzYjZVdXgvcW5iYkJiNVQ1eTk4MCttLzA0VWJTUmd2TENSRytHekdGOEt1YVkxcm5uVWFVaW42dmJrb3QvbnozUFZUb2pWMHNocTc3Q01wN1dMOWl4YU1iOXkyRVh5MTA2dXd1Y3FGKzBqYTgxK1k0VnZwYkc2V2FldkpzVk9sVnBDTlcxdFQ3dW5wdVR4ZmQwU2drdkREcEQxTkFFQXduamtpRFhzSUlzT3c5SjFzOVB0aUx4YjlOcDZ0ZkU1M01TeVBvNEN2SktzWEh1bkQ4WGNNM3VORUIzOU0yS1B5SXRuMXROMmZ4MlJ3U0ExM09GVXNuRnRqYmVhNVVYeXE4TllkZzZyYksxeVBCSlBoWlhYV2h5djBWSUtHMjBBRjhHSnFRQUFBRGNFWFI0QUFBQUFBQUFBQUFBQWpnRDdNd0NBRGpMeW5kenNYYTFYODJsOUNKa0JBQUFBQUFCd1Bjek5BT1pBWDRJZS9wNlk2amJBZXIvS2phUUZHNnhkTHJYd05mVW1pUFZIMkxrS3UzVGtMYVVaK1VKK2piY3NjNXFEOVlYKzRXaGZ1cmUrZ1BkdTVSSFptUUsyOU1vdDZoWU9wbWRIRWlsc0dkNGxVMXVEZ3lTN2J0Z1h0RzVkK3ZXbTJVMVorVjc1NGgwRVBidFBBUnhJcW5meEZkcjdidGZBcXAxN2R6YTBkbEFhVWF2QWlmVVFyREJ3S3p6OUpLUkhESEJJdWozekpOcnY4NGthSTVibDFydkhTYmVqWFMrVm41VEdzc1J1aXk0Qmx6QlJrWk5PbVBCRVNvMzhUWkhTQ0ZDZk1GbTZ0K0tycHorMjVvOTBZQ2lwMjBwMVNrdDkra3VxNW5LU2tVWGJhVjd5Q3hXeGFzK1NTU1VwMXlQNUF6eVYxbEFnaFN1WnRZd1VXVC8wcmsxcThRRGdjN0hXeGtiUTdNb3RFME52ZVNJMmJzczlNajFZR21HdE1rV0lqQWxMVllhb3JJK3NsN1pPbGt3RFpZaGdwKzJjRE5mckx0L09XWWhhUGVGNmZwdmxDZS8zSEZTSm1OWVRNMVBVNkxhNlNMMHViOU91L0xXVTFqaXR2cVBGOWJUUFJVeDNMVlBlNWJVdFUrUk0xbFQ4dXdneDdaVDBObDZYZDF2WHk4YTFqQ2VsbXhvNlhIa21xemR0clNkcnoxZnYrZEdUVUxWNW8ycURNZUs1d2xiOWQ5Zm5oQVpySHI1U0M0TWtsNkUrSFU1ekJ3Q1lUaTJubHVvNk9oRERkSHJuS0szNDN2ZmFzeERPSEpPY0JpM3Q1UEo2SEM3OWtwRXY0eVdBZ0Q1QjJJZEpTckFrQnF1OVEvTEttdWQ3aDZIWDkzdW5LYUxwcHowNG1JN1V6cGNsWm9mVDB1MGwyc2RhVGU2UlRjaHEvOW5wdHFiUjB3ZTlhSlZ0S1h1VDRNVFVENFd4QVFBQUFBQUFBQUFlRHdZT0FBQ0EwMG1NdndBQUFQQkNybFJ4VUsrT2h6b0dBQUFBQUFBQUFBQ0F5M2l4Z2ZLM1o3UDF6V1o3cFlOV01hM1BzYVBiUUg0b3ZSc0l0WGFEMEs0OWFVWHhQazU5MTd3NGx6Y2Zxei84b1hkckRrOUgvVVFpMnlob3V3aEsyektObEFOZ0F0b3cyNzBoaldlOHR2ckloWmk3aEZiWGgrQjVLR21KNlVEV0lLaWw5Zmd0Wk9CcDdKcWMwTDYxcmxGdnBtM3RRbHluNlZGOUdJWTcwV1JKUzg1NXQ1SHIyWElUaHJDR0JzKzg3K2doUldvZU0xVnlNek40RDhuaFZ6Y3FxN0ZkMEdaQzlqaG5XdEY0QUxmQk0zZ0ZCcXJOcVk2N0g4dE9Ocmo3V3FYTFNycHQ5TFFOODZSVTdSbytBOCt1cGtud0w4TlVBMDUyek5HMGszK3QwMmswdFBsaDdkOXk4NjVwQUx3Qjd4RFlzd2EzdWtYMXpNaXdWSzlGZXVJQXdMczV5L2JVeW52Tlgxb09rOEpLMTBzVnI4ZFVLc240aUZ4dXBhUDVXM3FVWmpyeDVyMDQ0a2ZyU3J0dXNaN2pxRDNuM25Gb05QNjJEZnBTc2VyNDMwWGFCUlNYSm12bC9VdXAvejczY3RlWTB0WTUxN2tMWjRTbWVqNnhQb3V2VTJ5L0p4SS9LZXdTRVBseHQydE9uakRaYlMrSlpkcWVsT283R1RVSnY3WnA5VWxEK2ZUVzdRbkJXcDFxN3Y3K3VqMGhOUXZ0b0Q0NTFlclBpNW1uUGU5VFR3SlY3RFphL0RwTXpvdTVmbW1ldHVvTXQwMTBFVzk0blp2WC9iRSs4Zmk3aml1SFhmZXZzbXpSMTFvQjRIWEl3NnRmTWJJVTdCNmxENGJ3ekZFc2Q4dFdaRDNXMXB4c2w1amx2VmRMMjlIemZxd0crRWlzemhKVjNxVmdMU0h3NTAveUZVV0lLbVp2ejIwK2VOaUpHbVZtNUlXTU5mSFk2ZkxpZjN5dGRDVDNWdHphWHh2alBTS2tmS1grOFdpVjJub2hzbzd2ZVRBU25zcHY5YitUSHNLOVRreEZFSjBPVlE0QUFIQWlETHdBOERTUVd3QUFBQUFBQUFBQUFBQUFFT1NhNVlYUFdOUklsOTRuQzBkblFVMERBQUFBQU5pZ053TUFYTS92OVVmcmcvZHZnZDM3MlhWSnp3NExIMHo5OGJMMm5Hci9SUWh2YlVMVXU1bFJLMHhTeW1MRmV5VDFsKzQ5MjgxNTNlRWYybzRDa3AvVkFDMGh5TE9BeWJTYVZIUW5FaythdmdETEk5cTZ0Z1BMb1l6b09KYi95SFpNeUNZNGdkUlFLS083Q2E0N29ubWFlNzBERkhUaTBZMnMzWmk4QXZjbDQ4d2I4V3kwTmZ2UmFHcjFWSU93dGZVYnZBdlBITnU1UTZjWjcwQjZzNkpadzhlZ25UaXhuZ3FoUkJ2WjNkcmNHRGpIM0RkcHA2VjVFbVdtYzRORWoxM1pNQlpaSjhWRSt0RHUxTlhhZjJuN2U3QjJDZ1o0RTlvNllPMWZNMk5KdzhvclloYXdkdkRXeW5TcWpSY0FMcUZuYWg2Tm84NFRpbkRSRXdlc1BCY2p6NWxwT1ZVK2RVTjhqM3llV1IvU3F4S1JkMFNpOVNMRm5XV0RQR044c3ZWbjRZNXpOazZnK0tyMWJHa1Mzd20ydzZYdmJIOTgwcytUL1RlZjJEN3BMNS9kNlk3NkpNU3VDYmw4dVJHMy9RVHRjMUJiWWRielE1UGlPNDZXOTQrcjFOdkt1Nit2OHliK3oybXNsaFJkcXBoYlA3bHM4cldXUzNiRTJiVVlJek90K1plbm1YcnRNbEc3azlkbTlITWh4RlBtM21iYTlWcHMydjR0NzN0eitISXU1aVNwbWZRMEdRc0FOeWM2d2RmaWFVcnRvbHpETURub1htTHA4dDY1U1RUdmxzMUljNjlQS0xkT0QxK1VzUkRnNDVobGpLakRTT3VoeXBpZ0pUbGlVNUZuUno5dVhqbjBjV0loSW9EcjhJenAzZlNNaXlYSjZkKzJIY1h5am9xT1JTbkQ0L0VvUDdNTXNkNEgzY3IveEVxLzE0bXBBQUFBQUFBQUFIQW8yQUlCQUFBQUFBQUFBQURnRDlnS0FaNE1QUmdBQUFBQUFHN0lCVk1WWmtjQWNIdGVMS2orbnBqcSt1cmE4Mld1OSt0ZG1FNXIxNGlqSDB1NWkvUHJ2M0tQc0ZZSW1zNDFlTGRqOHZnajIrQUFKSm01MHQxY3JXMTdXcGsrZ0dpM1BvUXJ0a1lHdUFzT0dWTHYwaHZkYmN6U0p6M3VINDgyRmtRcWpNcDlOSGQ1ZkZwL2JzNVZ0UjBYUjdac2cvZlFNOGUrUWJ1SU5HTXJEWURiNDluVzFod01xdUNHZmludGFwMlZQSGJPYTl6bE9MTHp0QTZBRGRLWWw0M3dCdFlPOENOdDB4dVZLUW1BajVFK3RZb09TMlFFaCtQdThuajg2ZThBN3lGcXhwRU9WZENtL1ZIWkdFbDdOa2ZLdFI1WjJ5dWZSOUFPMitqTjZ4YnJnMVhlM3JaVTNyZDMvTjNua1R2U3ptSmVQeWN1NXUzMWQ4Q3RlMzJuZjA1Si9STTNiU2JoeFkrME9FcWZWSitpQ09MYzVkOTlTWGRtMWU2MkJxTFBVVUtxYzErODR6V3Z2THRmcGE1M3Z5SVMrRjhOak45Tm1sSWpYVG1uSlR3WEhyWHJsSG1HOHc2NmYvdHJBZEkyYmhJR3l4bDlCUUJlU0s5QXN0SkQyTnlDMmJwM25oUkdqR2UweGUrbWxkcDUwL1FBRERvNjhpeGI4Wkd2aG5odjY2TmxSTXVBdHl5Q3NhRzZodWxZVlo2TnVJZStGK0Z3KytnK05XcUU4b1NwWDhJK3ViSi9leFluTnc1YXdHVVoxMEpoUjI5N2tCYWZSNHo5UzVXT3g4OGpUS0pONTNGTnpicGgrczU4WHQrbzRFMTRUbEgzeEE4MVgwMVFqM3pBZERLdCs1NDExcm1KUE1UZUNSaHlDdTdFcEU1V04ydHBYZ1FYUWVVL2twNmg0b3poeGZPSzBCUm90NStEWlpkYXNkckVoZnBWSk92WmRoeTZDcHlPOWw2b1pMaXNNUnJ1K2lKQitUTGY1b1hDS285STFsb2VIbllmeUs3dWl6d0ZwMStDU3N2UVh2dGI4YlUwckNUUzB2WFM3VWpXUjYxcEFOeVo2UHhJRzBNaWM2NVovcmV3endMQTQyakpxMTZaT0R0c0dUNGIvb3NScmhXbmp0YzdUL0RFODA3QkZrZGF2YmpuWXRYMTA4ZVYrcDFOcTkzbm5ZOCs0a3BwdCtlL1ZaclJocjRzeWtlcFA5ZXJ2L3Jja3BacHV6RHJ4NVdlajFPUG5IT252eDlTcm1XSnk1WXlwZVU3RlQwUGI1bEs5QmRWMTJlanBaMi84cTVUMnVmMUw0MlJHdWlJNXhRT3FmclIycGdzTk85dGhLdHRTSzBQWUt3ODk4OXRlMTJtNDhrek8yd0tTWEUzb2dFQXRCbFY5dUVVSksxcWRZL01WWHI5VzNuT1lsMC9VdjBYbWllOG5HTW5TRDQ5dVJHOVJKSVJvLzNUZS90YVdUNVdSbGlHakNQYTB3Y3orT3FFTzE2clBVZnowUHFNbEk1bEc3czFUbHZFTG14VzNNdnJXZjFJcXR3TEt2bDNxeUZueStISXdlckQwYXA2SkkwekhsUGRucTB5Uk10MHU2YVdIZjZwRVo2KzA0L0RlTnFkRHNCSnRQU09hSHlYaHllVEcvUUphNUVsTytKT0owOEsweE1lT1FWWFlNMUM4L1p5Rk93WE44RTlNWVNyT1dLK2VEUnJ2M2FWVlJ2OHJiZjM0QjIwbnJjVzFodGVpamNacmZnOVdjNjJRUUtjem9FMk1lbWx1aHpJdzZOdlJqL0lTMFdlbUFDaEMya1FNWFIwVmI5U0JxUkl1KzQ5Q1dha3ZkTjM0Qk53ejR1Q1JPWmNucVd0WG4vNkxRQllTUEtxZDluWE1tZDYxS3BlSXVhTE9vN1hmK1l5MHFqc0grR0o3NFQwUEY4cnJXaGUyUmh4cGZkeXduWG5uUmdMSDZPVzVmdjVxRzEvK21XdUpoWnA5d1djcjlUcng1cmxSNWo1TzUydFZEbTJQZWZtOVRpeEUwUzM5VkdYTFU3MXRIWXVlLzhqcVo2cjg0YjBQaVc3V3lSSGhMcHM5Ylcya1ptWWxuRnQ1ZG16MGRwdVhLNGRoUERMNGgrcmoyNHBBSEJUTElIc1RRTWhjaGdqU3ppajRXdTNXcmVkL2RnOTR5OU5EVjdMa1pQeW9HNnIrVnNmeXExaHozZzNhc2I3V0krbkplUWxZd1FNTXpydVdqYlNsUlRJdzh2b3V2RHQrMWl2N25yRzE3aWpsZitIaWVYNnZhWm5sc3NUS0dZM2hJbmNvZXFsdnZQcWNjYzdDa2pDaEw0eVJtc0VMUnRmS3l6QXhVaUtvU1lxNmpocTg3YmF2YVhjdEZiK0g5YVhEaHQvdFBvN0lyTzY3cTJ0WkFCbTRaa1FmYlU5MWR1NTZKbWNmalR6Q2ZUSUVQU3BSMk50d25YRll3M2JNank2VFJtV01mSmRSSFhYUjFncysyQk1oRWZTR29nbXpqMTdYcmFyczdUeTF2Skl5cVNkNFFpR1djYzBTWWxibGwyam1qMEVXbXFWeDF3aCtVdjVTUEVBM3N6UmE5RGVGOE90K0pGK3lWZ0hBQ3NSdWVhWjUxcm02VlpjS2ExV1dUenB2RVYzaWNwdDY3NW5MbDFwZVhuMXoyVkNHU3hTTUxmWXVCdHJaZi82U0NwSzRML2pWT1cxdXk5dEl2dzk3ODM3c2doZjc3WEs5SFB5cHA5a1NBVzlCbFBqeW84MlJZdWhsZFZhTWN0cUduTDQxblVFeTVDenZmTDJVMDEyTE4vdVA1cHpUMXZaNUtVMDUxYllveWpMVUorY0dqcTlkZG5HcTlPMi9LVngrSHZjTFJ4RzYyT1hOZ0I4QmxIRjJYb1BDeUZ5Q05KWXNMcWZQZWVKYWk3V3FlRzltelhRMUFBR01JU0hkMmlJREFueUxDa3V3NnlaMk92cE1iS2xLaTZjUm04N0wrT081dDNyWC9OYVZVOFRWQjVqOThQNXZmNjRRcUdFZVJ6WktXdkRZU3VNZHYxS1dwM0dxZ0E2MnhnKzJ6Y0FTT1JKN2hQUnhyQ1JyQkd6QUFQVUV5TEp2eWFvRFBib2x6QUpKbjZ2NUM1R0d2MGxra25seXdFLzJqbThpTllDQzhDbFdHOFhSdUoweXZFL0x4UzBGaWsxbS84dW9KR0hYWkRObjlwWkN3NGdVemZjNUF0K0JKRzBQZk04S1R6QUorSHMxb2R4eE5JVmZSa0E3c3hkYkdadjVvbzZucEducHJ0YWM3alU4QjB0VjgvSm0vOU9FUDFINnhXS0xNUmNsc0MwZm5OenVWR1d0TG1PVWRaeU5rTG1JaWQvclVmbkxGSmNLLzVJSHA0eXpIMy8xOXRxNTJ1eGRtb1Q4bFNhVWN1VzFIelFzdzJ6WjY5cFJGNkl6WE9lOXRYekh3QjRDSmFnUUloTXAxN0hYeHJYZDJDblh6a0wvZDIwSXU4YU0zQUJIRUxrbThjL2FLbzQzZk1BWnJ5a3pZTTVqUm1QNnc5SDJ5emdJaTUrQUwvTEM5T0dVbjltL1FTdDlPSFVWYTRaR2ZOaVY3LzFmT3U4dkVUQ1MrVitOTktXRy9TRGM1RHF2c1RUSVR6aEFFNWdiYzdUWG1COWtMRDFybjIwNHA2Q3B4RFdHQkNWUzB6YzRFcUs5cndiYm9VT1d6ZlgwZjdwZjNrQ3Z0RWVnaVJEdElGSEE3M3B0cFNQcG41dHAxdVA2RVRTWXlMdk9md05Zd1pZNE5PSTZrTTNiQ09qelZmcVE0eUpjRnQ2NWk2YWZTZmIwZFpnVXRDUnZtT2RrSnFWeVR2OUVzSllSdi9hVFdoazFzbTlLZENYRnFWWWtiZ3p3MStWSnNEUmFLYmJXaFJrSmQ2b1hybW0xWk5PeE95Y25PRUE0SE9KMklDdDExUmE0V3ViV1ozWHFBMHRHMld3d3BWaEkvZlZ5K2hTVld2K05VcmtXVmpMY1MyZDFqVXZYR0xJTnRBNUZwejFKTkpjVEViL2ZBQzZmdmhaejN0YmFjUWJkcXJjR2ozMzcvL3kzN3p5MS9XL3ZJVzAvbi8rKzdxZmVrN3pyNng2M2UzdmUvdHJtOWVjMmNwV2R1aGFqaSszYklUMWxLSDI4L1JVS2FZVWRwdld6NU5JaTV5M1RGWmN5dE5Qc3hrbmllNUpEcVlkOEx2NHlpZTRaNmw5VnVHcmRoNDVvYzIrZjM5YXJYaGJ4Mlg1N3A1NVVVOUV0VTVLdFY2ZFNJNndBUEJpMmtPTEhrY2F4aEFpVTRuTVVXYmxsUWZ6emtLaS8rVkZ6S01aUDIzamFJRy9WVjVQZUlCUElkVFpsT3ZVdkF3VlE4dGljUmJCcTRlWGZoOHJDeVJqMm9wbUhvQVFjeXhIY1VyVmF5U05aWkh0c042NGo2YkhXT3AxVDhhMUpaeHlJTzVFUWZlN1R1dXFCZzdQbzZlZHZLNXRSVFFVQUlEWldMT25CeWo2SHIwRDBRcHdFVjhkZE8ybkc1RnlRTWUwSnJ6SWdrNW1XQkxndHR6bDhiYnNqZVZZbjVXSTJXc0VBWGc1ZForTzJpb0Jia1g5WnV6a1ZRaHJERXhML3ppcHZlaTNlOEdSemdpenVGQ3BPelBySTdvTTNSQ2dqOTYrRTRsSC93U0FLUFgwWVVSSHFlTmZvV3E5MVN4N3B5VklyU3hTRzVvOTl2bStyN0EvTUhRWElyWFQxdHJiZUR1VVMxdC9yTGk2cE8rUEY3OCtUazFTaW5YWjB5YWx0ZFQ2OC8yWGR2a0JjTjZrNXI5ajc3dDR0WTA3TmRMcTV5ZmxiUjcxQjZKbmNGd1B6OEZuNUV6ME9IcnRXWUlONmJCYWRRb3FzUTIxWGxZZDRLMWpJQUNjeEl3SkFZaU1ESm5SdU5yUWFMMFQxTkxoODJnaE5IcldzZ0EraVFOazhxaWQrY3doNHFNL1NxMUJSazducWlxOVU3dCtiQis3Zzc3cWVXa200ajdJOTRtcDVydENkWUJsUWNBY1NES3VwUStLSmJMeXU0eVRGZjhlb3BzalBKcldEU1dIdnpjdDhLSFY0WWk4WXJJSkU2aGxvblN0TFhyVmhKdnpRd3gxMnBnWHRROU42YTRlUzFnWnpuS1QwRlkzclVXanFCL0FESXFQVTFjOFRUS3E2clFXOUJtT0RUeURSaXRNUk1hZ3cxNk9OSFRrWmM3akhpM1Rtb2VaZDZNUTVwaU9MZUtkYUFZTzQyV2V1eFBWNmV1eHNFYzFCRGdkeXlBcDJaTVZyT21SZERxRTFSK1MwOTlNUjhnYm9JbldvSzIzYmtxQzloejFnMnF0S0VXN2pvNDUxaGluWFd2aFc3WXpnRGZUODRLZVJiUVBUYmRIQXdBc2ZYTEljcmZlYzVEa2xXUnJsdExVWktmMUxvV2w2clhzZEJyV2ZaMGhqN1g3L0cvcHAxZkg4NDVEMnJwQzZSL04wNHZXem1KNXJoOGo1czMxSmhWSGd2azdidDVFK2V1ZTk3bisrL2ZMbzJQaSsvZGswN3hQYytNdkZWeFZncXFubG4rOHQ2ZXViajlzek5XdjdVZXJaYnppZnMxQzFYSHpwbWEzenoxdGF0eHVRNjJXbmF2NVVhcXVmMEpKN2kyWGYvSDJLV25sVys4M3EybG9XQlBpdkt0QkRVMTJhRGxJOFZ2K2Y4T2tiYk92cjN0dFJxMXlEMVBkbU5XcVV4VTFDMkcrTDVJL3JWMThaeHdBZUNGZXBVMExueHBoSkxJekhFeGh0cTNKMHArdGRkSmxjZGlkRzZxdE9BL01oYjZaTm4rYThRRmVpMlprbVpXVzVLOFFsU1dPSlBXMTZBV29oUHNRSFgrOWFZN1FiMUY1OGZqWmttMGVaU1pxQkU1QytLaDhUYzV3SGZ3dUwyWTNZSGdHbGxsUUMrL3hLd2YvSTRUa3BiUnV5TE02QWdBZmhTVUxwNHp0TDVFdDBkdEFwQUlNY29LbEphSXlTZXNJcjlNakFWN0UyajliQzBoaUJDRmd0aEpBRUx5YjF1b0IvSVV1QUxjbEI4UDB2Q0hjMFFFc3NlTE9tczRIWi9PUzhiQm5rWkh1Qm5BdUxHVUJ3TnZCMUJESHE4UDE2SHBuTXZyc3ZXc2E5UnBHejVyRy9nVFJmcU9vL0ZHbUhPNFBxYnBlOGMybDl4UDkxRkdXTXZ5L05Pb1BYRnR4TmlFWHJhNmk3VlVMcjluQ3k1eEgrNUQxR2xKeWhwUFNCb0hSTllnekZPYkJNbTNhYkNPdDVGbmtDVFlxMmlBQXVJZ3FicWtqRG5SenhORG9DVFB5amxENHBQSjZ6WXEyQlhBNTJLVXZnb3EvRFVjK0NvWTZPSXEvSDZhNmxUanJpMW9FMG1GRWpaZmVOS1Yzd3J4MkplOU9hTFZ4MUJQbk1mUzhTQWZqZUdlblpWaXJnVnRmeGdCMG9tM3M1dGtGeEpTWnJ4T3FXN3pkZUlnNjhaR0JObW9WaSs0SWhVeUNzMUJtbjMrYm9MT2Q5elRYT3VuSVlud1ovdU82aXJXYlRNdS9ERE5yaFFBT1JSc2JXMkhYOEVjK1BzLzdDbEtFNy9zWktkeklxaFJjUTJ0T0p2bTFHdkFOaGI5VnBCN2RsbVlPajBkNnlhOXEyTzYrVXcwNjJxa1c1UXVoeVdtL0d4RXA5RlBZa0l4cmp6SlhodXZJdXZXUzgxOS82MlhVcWkvTnhMcHRnRGZpMWZuS3NORnh5V052OXRKVEZzWkNBRmp4MnE4ODVrbExyU3JUa3ZLdWY5ZHBhYWFJVmp3dFhTMGR6ZC9qWjVXdFp3NFRsZGZhTXRwL2pqamF0VVhQc3I2VW43TFUwWm03SEVwMisxZkxlcnZleHM0VFJ0Qi9KMnZtci9UV1BBSWFTTGFNYjEvQnlqVHoxbWRaL3AzdStlZDAxazFadm8rc2t0UGNuV2lWdHU3TFV1ZFQvNnJydmgxdkVlUHBzZFl6UzlmVFM5TzNUeGxLNmx1YUZMQ2Z5MDhyekdMc24vNllCRjlmeW1YOGJTN3JzL1AySGsxS0xNN3JyYysrWnZjeGM2ZS9SR2x2eXRsUmcxVjc3ZW05OWFtc2VzQi9HWmhqZ1dJcks3dGVMaU1zUy9PRDc1K0VkSG51ZmI4RkFENkVpT0dpNVNlcFlRaWMyK0xWelNQeklpdXVPNEkwZnFhMm5yRngvQk0vN1pMY1hBTzhHa3NCWGQwQ0N2ZHVXaGdRQnM1bDNsQ1lhUHhYOVAwUmdleE5FNlpqTFRGblovajZPaS85ajgrckE1UmhhanVzZFYrUEltS1FydjJqQ2xXazMxcVZla0NsL3k3VGhjK2pwUnQ0MjZPSDE3YXhHUk5yaU9OVmFnSGdVWDNsSTdvMWt6RjRBaTJMemtFZFZlb2EwYXhRRFJSR0xBbHdlKzcyZU5YeUtBdUlVMDZnby9QRFE2bjdTMXIwUGtRemg5UFFET0FqS3dPVzRUR0s5ZkpLdzkxci93ZTREUSsxZ2ViZ05jQW5jR1Izem9wYjlJV2RWcHBudlBBREFQQTJQc1VzNjVrZW5sRVh2VlBQSEk3aFM2TmRIL05IVGV2VVZTMVBxeXhaK0dXWFJjNGpLY2FHWFZtL2pyaEtRaTJXYlVteXBWa3ZaRXJwV2VGYTlycWoyclZpVG5lRmorV1RxM3B1V1NqZmowdG5QM05Od3l2WWVneGVucmZ0TzE0by9OeldBd0JUa0JiTzRMYU1EbWM5Y2MyUGNLejFveVJmMDlRQUREUWxMMkQwbmlrTFN2ZVovZmYxdXV4OFU0UnZVZzFEekxOMy9hUHN0bEhid3lpV3lLQVpIY0RKbGZyYkV5aDkvMU1odFV5WWl2ZDlNQTlhaC81bDVDV2wwL0tmeVpsNWhkRU1kYmx4RFgxSW81OTNGY0Y3RFhBU1hydC94SC9IcllXbnpObEtycHFaZDZCdDdYS2l5WDV2WHVoWGNEWktlNjlQbnhwcGt6TjBXZmpDbWlCNEJwcms5RWNPM1k2b0huSG1JeXlIcnlSNUxGcUFCcEYyRHMvRDh6eWxnU01ydnk5aVpHeXp4RFBBcVl6MEowdTNXTU00OHRpZGxPSklldWNuNUJXWm9pMmRaUU13aWRnbjY3ZXR0U1R6Tm5nMjBxdkRTMFhSMnZpb3FSdFZEajRkeXpRWVhkS1E0dFV2RmN4ZW9yTHlCSURuVS9kdnlhOTNXY1dUZHUxdm1VSVhveXhhbm5teFgreUt6aGRhYVhteDhwengvb1kxL2tRLzVQT3VjVVpNZ3RheldSeGxtSzI3ZXNmcjBqMEZTMkUvay8ySG5PVkpxUkdTa0ZZa3JoUlB2VnVsRXVzNTlucXlhbDZQcmF3L2VNcy8wWlB3RWNHWVBySXRYUDBzL3NtTUh6OWZ1MjczMktUNHkrWjB1WFoveWltWDMycFYrZXUvL2NlcHJWSWxNUzI5YlAzVWQyMk5DWmFNWEl4d1VwNUxJTzdmK0x0MnZiMXVwZUU5U1RVWDRldTBTM2RQR3JWalVoNnYxQ2NrOS9WM3E4NjlZd0VBdkJCTDJjbkxYc0RBYmZBOHZwbEUwdHVOaVVLaDh0Yy9tL0UyNitPbVQrTUIrQ0JheXJhazdGbnpRRVZoM0oyc2FtU1psN256QVU5Nkg0bjBuS21nVzlEVFhxWEhKODNqam1ETnV4WVJqeHhua3pPTTUrRllEOUlyNENJY1VPbS9QZmVMN0lDcnVFWGIweWE4bW1SdVhVTWZLREVBLzdCV1crcHdEK2ZXSWxYVHhMRkV3Wk5vR2ZYenovQ2J5ckFuRmdFQW5vTTZaby9LRHVaWDhHSFF4T0YwdEhtTkpuKzliNDk3YkdhdE1vMVM2N0xMV0pHK3crZG1sZ0NYY2ZWOHlqdXZvNThBektVZXhxVXhqMzRIQUZGcVBYb0dzOU83YTU1UDV3aGJ2ZlJ1YXN2ZGswNXZuQ3VZZFRKcSs5bjA1V0dmbEtybm1wdHhXclB3V0pueVYzS3BDbFYvMGhtWjkzdk5HOWFMeW5YZVM2TU1XcHBhTzliU1dEOEludEZIcytqaVMvbG8rWHJacTBHek1xM1MrVG9BdUN2dWNQaWVlN0lFdE5YQUdYd0JvQWZOd0FHM3dxdmp6RWg3T0M4allQMXhLbTBPNER4R1pVWTkvNlA3M2dScnNzMkR1Z1dSZHlkNFpBN3VJSVJ1SmdqL25wZ2FOdXowakF5WFdZL3V4NHlPcTMyYjFCUG5xSStvYzhEOXNXZ3JLRm80K2tBLzlUWUpwZnV5b01BQUxNdHJUMjh4TmxJNlJzUmFnMk5MSGtYVHR1UVhZd2ljVGRIV29pZWxwcXE5UnI0L1lBaDNFcTJvR1RJRU9RUU5jc1FqS2RlSER1cHdPZlh6amVnODJqendSbGkyZFdzS3V5alhkWnhXbDZMTFFCZWVSZmVSUnRhd21XMjYrVmNEMy9XVmp2bHRmYkpFcXNwd2hWMFNrL2dINE5GNXZJT0JGU2ZiV2FuSktmMHdOY3BTWnlrVkY1TTRRSnNaNjRGVyt0cmVlWkcrRjlWZEFlRGRlRGVic09iRHRWOXJlY1dpOTkwSUtjL0loMlFqdE1wYTU5bTczQjJSMnkzZGJtVE1TSTZ5TmFhSHpTbHBEL0V4Y0h0SHVmQlpLcGRaM0hOOHRTWXhyWmpsQ2FybDZadkpTRVZlVVBvNU9YWDV0aGY4YzhwRitMU0p0ajlCOVN1TnIwQjJuZWZ2ZXluamVVaTd2S3hlb2ZYY24zQ3RqMU8zSWJkM21JSUduam8xeVZVS3NlMjNhOStSVSt2QmF4SzJubXQwelBCZ3JZUFdjKzMxQUdBcnpUSmNiU3Z6bk1KYXV0ZGxrZkxTeU5XRmRtS1Y1MVJXSzQ5ZWZRTUFIa3hMZVpXVVFtbTlzSTRMMDJucDdwSDRQZXVldlhTVnN4eC9wZmJuekl1bUNCK0x0b1lWVmM0ZG5jaWE1WGdaa1R2b3BuQTBjWHRXKzFxakhQSjY3WFhlYnV5eFBUNnliOVU2ckJiR1k5aHdHeU1hOFZvUFpJWUJPc0R2bVFvZStGamIybE02MGN6MjkrajI1dTI0bnJqUXgreFpLY0FGVEduR3lnckhYY2NXclZ5MWtxc3R4MG54V3RjQVVPRjlReVExL0tKNStaekRZYUNESjAwODROWm9va0xWYlNRUDVrM1E0c1BsVld1ZUVIVUhNSkhmYnJUbDloRnlmR1lEejVzLy8xNmcyM3VmQ3YwVTdrN09ZeStVYnRJeXJnRStrVE9XTkdhazd4Mk9jeUF1QUVETkZkUCtLMDBOM3J4N3lxZlo2WHJ2ZDhaNFZaZXBYdmZ6bE92SU1VMFBuMFB1UC83OTlFNkRwVExORzRlanBmcDV3bGw4eTIxMXI2OGRPZTZPbUZ3L2NLM2V0Q29hV2Q2a3VtOXRlNTFHN2tWNVFHcG9yeE41WDc1czFiUVVWK3ByVWpndERTczNxU1pHWklWMnY0OHpCM3NySUZKUmVmRGFTcTltNWlURnV3Q2M5a1VBQU9nR0lYSW9zK1lGbzJFT0kyb0VvNzBCbkVvMi9NN29rbG8rSHkwT3ZPOFd0TUpEazdnOVM4WnJmN3Y2SFlvU2h0cjM4TnNkc3Jac3JXNlIrUENOOXl0eXk3MEhyNEV6d3VpWCtsRWo3YWxvaFZuN1JHN0VXUmJhL2dqU0drWmQ1OVF2UEJCcEk3ZXB0djhiQ1ZGdDBWbHl2MFd4clFGcVpLR25OeTV5RG83QzZIUlJtOEt5SE5OY1Vhc1VMTU40ZG9SZGlqaVI4SEFaMmtzYnA3d2NYR2Rhb1BiVG1Vb09QSitlaG52ajlxUFpNVFIveTMxTjQ2aDVBc0Eza3ExRnUvYTh5T1lKOXhWV09wRmhlQnBVbENFdk1mTmRJeWtBbTVFM2JIb2FXVDR1cXh5WUU4NkF2Z1p2cHJXazRmMWdZR2JmYUMxaFdYcHBXUlpQMmRCZEFaNUphM29naFdtRjA4SjcvVWJ5OUtTbHlXT3ZmSjZSdCtUZWlqZVNwOWQ5TWNwUzg1OFJQaS8rajFPOWVSNDFSaDZWcHVUUyt0QjFmMHBuY0xLOXJIWHR2eHZyWk5DVy8vZGRwZlR2STlLOXp5S2RvUG9UOUN2Y2wwTkt2NzR1aTlheXlmYlBkZHJFL1c1Ym00NWR4RS9WZlh3Zk5ma1RaSE85VlBrMVNOVjlacWRVU2RVdlQ3eTBrMXcvcDlOdSs1clZkdmIxdHcwbmZhQzc1cEhFbEZvdUVXclowRFBWMXN4Wm1yelN3bnVJam1QUzZhYjFxYVZXUy9DMU1MLy92MEw4L01tTmlGbUp0L05YbWtFV0JnSHRlYnU2SndBOEcwMEF0d1R6ZmlqMGdUQ1p4aEZ6bGtoZXM4ZUtuUjZSdG83WnlJTW1CZkJGMVhmY3hvalVTRStMbDlxMkJZc2VlY1V3NHNReVgxQ0IwNGxZaktTNGRWK1N4dGtvbnJVbUxieFhQYndWSHZPZFpoVHVOVWowR0M0dXFNUmZDd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNBZy9RLy8vdC9ybTlvZi84NVczWGtNMnRvNHYwNDJiTlIwRktFbWZtb3RJMHJ2UHMwdnI3WlNMczF3VnkwaG02RkFUZ0JiUk9NbnAzRHdqdlMzN2pkZTNkVWFlMXdacm1mZ3Fjd3lINjRPOVl1Wk5rWGJTVExIajZ5YTdWMG5sN2hpTTcwS0ViMWlETWZiKzRaN0FIKzhQQTJNZEpQZThJQnVJa1lDYjJEeG9nZVVlU3hHVEtxNHhIRVhhcVhSVDNKVWZRWDdxZk9jM05DaFJERzQ3NG8va29SNEcwY1lRY0k5akdQRFdVbTBtMTY3RnBhV0phWjRCTVk2U01qZVZsaWFiYllvaDhEUEoramRZaG9IcjE2eElnT3Z6alRpako2Z2tFcjdwbnZhVmoyRHkyOGxIZHJhaXJsTmVONVhvRy96bU90SkNtbldtcWhwWFI3VDJmOWliZTR3cSt4eERKOFRlajM4LzF0bVZMYWxrMFB2MG04U0VGcVExV2FRZjgxVEZuMy82N0wwTnMwNmpyWDhwQk9xVTFDejh2Q2pEQlZmc213V0xiN1ZqdlBwUGJZS1B2N0tLOGkvWHUwSkhYZWRicVN2MlhIc3V4YWRkeXNOZWM4WVR3U3lwS015c3JmLzFScHJOZkw5cnJuSWJSYjZaem5DUUFQeHJ1bU1XdFlnbUY2NTE1NTBML01LNDFrcGtXckVxM0hlb0NQdzVyb2E4TEFPLzFOTHFkZDhxMXcwYXhiODRDUHhab29TZUVnUk8rWUY3RWRSdFVyQzJzY0hyRUpmeHd6amVLV25LN2pUb1FUVXdFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQXhaOXpVUDJiZ1l4dXcvWGhSRGJyYWU5UTUzc1V2WStyTGx2UHg5WGVQQllsajF0Qyt6OGY2d3Y5dlBCYzREWWs0OXJjNGFzSWtKTS83bmNDcm9EblV4YXR0VU9aWi9PTnlPNHU3c1M4dXpSNUh1aXNnZGR5QitoRjI4bFBDVnVmSmlYcGh0YU9TVmJmOXVpVEg5a0ZKSm1qeWFkb0JTRlRIc0hJZk9ub1I5emE0VHRwL2grL3Rka0wwSVI5eis2WG8xdFZYb2cwYm5sdlMwcWo5UGRVTVlBTGp4NVJ1M3NablBOOHQvZThIeS9xMHh1c0V5WCtxM1RaK2lTSDBtOHA4dDFjTDNKNExXdjY0ME94QkxVV3ZxUTE4YkVFZVN0dDVVU1ZDSVBkMHJ6ZFZWU2tSUjc3ZXVadzlDVjRNek9XTktKaXEwWGRUM3Z0cTZPbUNBQTRqdWpVTzdxZTd6SHpXR2JMeUhTL1Y0K0l6clhyc0RtUVZsUm10dkxTc1BLSzFHMDk5a1RWNHBIN0xmMGpmbG83MXA2TjV1L0JMbitxL0hQbHZvK3BUY0VYTmFTUFBOVkt2TDN6K2o1LzV1alp6UHZueE5BNmZ6bnRuTFVuWEQyTjdSOGhhR29FMkthNEtNOXJMN2ZzT3E3RDdOTmM2MHdMWDVleDFaYms4bG85dVQ0UnQ0NlhxbkE5TWlJU1VpSTM3aWJhbDcxcmtkbzdDdElZa0t4QnNMWXhLZGZhYWFXYmQwT1VHOWJjdGROWU5adUNKLzNkcWExZlJvRGQ3ZGI5TWpxb0xJdHArN0RHM1ZGN093Q2NnRWRKdGNKcEJzZ2VwUk5Pd1NPUExhSnpzOXBkVEhDTmtJM01raExWblprTTR4RThrcFpDVnN0bmJ5ZjN5bThoWEU2eHFLbjY2N1VsdE93NGc2TGcrVVNmTXdJdlRBNzZXMk5rUzcwcTQrVEZ0anQ2YWQxRFdtSTZ3ZU94YmxnMVJpd3hMRDE2RVg0ZkNDZW1BZ0FBQUFBQTNCa01OZ0FBdHdUeERBQUEzekFvQUFBQXdBdEJ4UUVBQUFBQUFBQUFBQUFBbU1nTERlL3BmLzczLzF3ZklQLytmNWV4WFd4QXhOcmh5MXZsV3JvOWVNdkU0LzZpM3RhRzloL0h1N1hkR29ZNmhnY1NicmJTbGxuZVJCNGdvRnM3Z2swcmRrcytSN2RPbmJHMW13VURLeHhOMWE2MUUxTzE0YmYwdHpZeTY5MHA3R09idjdWRFVobkdlOTFLRzMzcWNkenBjYWxEcEhmY3BlMTlIaTh3SW5oMDE5cjlQeU44blI1ZEE0YnhqUG1lNjFiYUVlTmdhcCs4c0R1Sm9YRC9tMlJXaXFEb3NubHhwTDNFMUs3UmNQQlFOTUZlKzg5RU8zRkZDS0w1VDg1YTVZbzhBWjVFWkFwdWpVdVJhZjRpaE1VY0FQRFpuS0hTWERHbXo1aXllR1ZoWlByajhUOER6L1JPQzEvSDg5cjRJL2VyalZQUnVoN0pheVFkaVZqYTI5YVhxdFQzcDJNbTBYMmYwamorc3Z5RWFLVW0zV2RXbnZCMzNsVmx0MjBLcVRoNTlTZnVkODc1SjE2WlZrcHluWHJhM0wrVFlmTW1UbTc0bCs3YnRMZjE4Sk8zL1p6TDU1U3JWT1V5TDhzMngvWnpicWUxN3cwdEdhS0Y5Y2dTai93Nml5UDE1L0xrMEh6ZzRLR2QyaXJsYmRycnZpT3RIbFhBd0NTa1BqazFPcjU2c3dhQUd6QlRVZDRQanZBUUJvWU1kMXJHa3BXY1ZqMzJLWWxyNHhaTkVENlcza2wzMU9pdzlDOXZTK2xJV2Mva05USmgxa1FJSVRtTVpUT3p1dFJkNWtsZWthSGQzMnZwZVlDamVkVk1yR3hPVEFVQUFBQUFBQUFBQUFDQVUyRXRDbUFNK2hEQTg2RWZBd0FBQUx3SnRMczM4bWxQbFZZTUFBQUFBQUFBQUZGK3UwTjZ0a3M4Y2h1Qmw3SnVLaEQ5MlBqSUQ2RzFORi8vZUtOYjlHVWpESXdqN1VCRUhjTkRhSW1VM2U0ZlplRGk5N2RjcmhMYnVXdVoxMmxlZ0dlL1hFdjhkbzk1bmtFMXV2Vm1LNTYxUFZOdldRQmFPSGJ1MC9wQ1pHRXhON0xVL0ZaL3FTZzA5eTk2WklaVm1aRTA0TGJNR0J0bnF3QS91OHJYSGtLbVJkZ3NoWVBuSTQwL3ZmTHBSb09ETnF5V1JiVFV3eVRFWDVTMHlyOEFZYlJHbDUxeHBBWWRiWkJHWG5VLzJQUWxKYTdtbm9wMC8xNG5QWHh1eVp1QlRvY3UrMUFzeGNvYnJzY080RzAwdVhrWkxrSXJqWjQwbDJYT2JTN0JjQUIzUmhNWmtTVU5xeTk0TjQ5djJXV2llVm93RmdMY255T1hOS3o1Ykk4dDJLdWlkNnBWemVWODYvNmowNlZlMlZpV0o2cG5lVzBSa2VkYzB4cDNJbWxFeHNRWmJXdldXSlduam42NXVwTFRiSjJVS3FlMGpkdUtwNTJZYVoyY21ZVmYzdGEwcHEzZDE0LzlXSC9DV1NsM25VaXVPa05lcW12RllKQ3QrZUt5dlk4czFKaDkrcWpXMHBNWkl5M3RBdXB0UnF1M0pLYTdmN3J5azEvOVV5UHRSUWhmaHF2emx1eXYyL1QzWWZVOHRuK3RKWTFOR29YRG4rWXlTNVpvZGl6dGROTFdxYVYxM1AzSndOdHJqKzFzemROcnIxUHpiRHdjYTV3ZHRUVTR1akVBWE1VTVllcGQwOUFVUnpnTnp6SnhXbUp5dm5jdXVoVGpsZXIzOVR0OWhiTUtwTDR6QWZBbW9tdk9XaHFXVVdaWlhOT2tYSVdyZGM3MkxFZ1A1OEd6RENqcHVJOFZFZHA0NjRtM0xLN25DVEc4WGFZM1RTbSs5M0ZaYTFqVy9PODE5QmpCUFl1TG8zbldZWHY5QTNCaTZnMUEzZ0lBd0k0Wmhqa0FBQUFBQUFBQUFEaVBDNHo5ckM4QUFBQUF6T0ZLdllwMzlRQUFZT1ZUeHdMR1FBQUF1QkxHSVlESmZFaW5RbllBQVB6RGYyS3FCQi9OVEVmZjJWQU9GOTBoekpPMzloSDJFWG5laWhIdFFOdXFEM3g0dnZTUDdxenkyb1lLVDhGcWdya09YRy8vbVJ1N1dpN09UQ3kvRTJqdFFEUnpVNDlRWVR5Wmoyd2xvMTIzeWdQUWk5VEpqTGI0TFZ1V1JwTEticnhsUEtrcldlcVVaNGVrVjZOdEErbU40M0ZIdGp5YTZDYXZrYlRDWmFuMEVFLzY2ZnVmOXU3YWNDTjYzM3EwdHJEdktjTU5pTnlDdHFIZGYwSTRMZjZ5eEhiWWhBK243bXZSWFJNOVlVTVRXU05lZGNMRVVvNHJIUTA3S3c0aDFjZmE2WG9aODRlYkVPMHIwVWxNeXk5cUYyZ0UxM1paYnNWcGhTdlRsY0pwUTd0bm1HZHFBcUFPZ1NMZTVTUnRUUzZ5NlhMVTM0TCtESEFOcWczR0NOTnlIdzI3Q0dYcE1ROVllc1FhSmdmeml0ak82aVU2clN4SHljRFd1TkNyMjYxKzJ2alVNNTFzNlk4OWNVZmFwdmQrNXp5enZNdG43enFYN09nWnFRcjNjNHBuTzY1OVN1dFBLZmF4LzdoNmUvaStwcklhUm8ralJsYlhyN1pwcmlla2ZxKzEvd1NVY1FneSsyUlVEZm4rc2lyaHBEQnJ5TlQwLzNHWFUwNXEzclZNVEVWYjI0ZVZXNG1WZDlyRmJjbXJSVWhIZTB6L1ZlNlI4V2pscURVTlQ3cXBFdFNwaW1lZFptcWRuRHBhdmszNDlZY25EK05CMU9Pdzk3bEZ3d1BBaGN4UW9EUmx0UFk3U0k2RGphNXY3UEhPWDYyNTJxTGtXWHVrVnFRcUQyME55MXVHUlNzTHdKUHd5Rkt0ZzFyS1hWUk9DeE1GcFp1cVVldjV3V3g3UkptMnR5eTNwWFdEbWpGR2lxYzlkNFJqTjNNdEVWczNhMDA2YW4rMTV2dWE2S2pMOUJnaUFta2tEUythWWIzMlA2Q3lPVEVWQUo0UHlnb0FSRUJtQUFBQUFNQUVVQ3NCQUFBQVlBVDBTUUFBRzJRbEFBQjhLcDh5QmpMV0E4QVFDQkVBZ0h1QlhBWUErRWpHVGt5RkVNTEdEYTRkWWlSbWJDVGt4ZHBGVHd1L2hvbVU4Y3o3Mm1IZFdHdkR4a3NLL0dKR3RsZ0Z1QW5tWmhLMXNHeHM4NW10SFN0dWpMWDdpY1FwYzlQb0FDWEZYNHcwckR5c0xaU1FiM0FTb3J6eTdOd3JCSTNxdHRwbVdoL1gvRFhocUZWUUt3MWt4Nk94NWx5bnpQK3ljbDN2S3AvdHVQQUFlbmNxekU2M0R5QzZtVndybkhmSFRZQU5yVUhEczUxbFZuNUw4VHpiWHE2WFN0alJzU0p5MnNOc21LbzlCRzAzNXFqdDkrSUhIZDJVdVBSdnhmZUloVFdjdHRHMUYvb0tmQUtTcUltc29jMmd0VlNsN1hTdDJXbnZ1RVlKQUQ1Vlg0dlRzdGRHeC9xSUh0RXFpNGU2M0ROa3FuWi9QVFpzTGYxSStEVk9aRG44VjNYZHF1dGE1bXRqZ0phWGRtMjVTK1dSd3ZmV1Z6VE83TFN2SGZ1eThFdStic1V0K1RtOXN2MkVjak85OWxFTWFkZURmeWw1V2xJbU4veStVc3l5SnFhNVI3Sk1LUzNTS2JYYnlKSGVGZkhmcG0yUEFkWDlLKzVKa2E0L1QzOTd4MUthVWk3NzBGb29LVTg5ak9hV25Ya3NocnVGMVFLOWxDZWpwcnBKRGdpWitxVFVtZXpzY1ZVbDcwNGxGamhLai9DbXE0WDN4QUdBUVVZVUtFM3dlNFY5VkVoQU42MjVwNWUyVnVrdmc1U2VKL3hmdDNVOHJSTXgybHdrTDVvaFhFNnZNWGdwNG5tVnMyZzRiYUxnQ0xvWVVVZmtWSFI5VElyL2FFWUZjdTJPSUhRek1xNTY0MlVqN3lqVy9ENDU0MXBoSDRGbGtLNk4zN2JCeHhmT00vRTlvSEk1TVJVQUFBQStFeVk0QUhCM2tGTUFBQUFBQUhIUW93RUFBT0RGb09vQUFOd1ZKRFFBQUFBQUFBQUFBSHdlbkpoNklwN2QzS0s3dExRK2ZJN3UwS0NscmVYaDJjWEZ1L09tbE9icFJMYkh3SjQ4Rjg5MlJhMHRHVHk3Q1Z6YXVPQU5hRTJxVjNSc2RvMHNkcTlzTnRVSHRXZXJXN1kyc0J1K1BjK2cyTnFHZFZuNnRreXE4emh5bXhxQVNIdXVMcE54SGFYZXRiQVZ4cFBucTd2QURJRTNvNUxoVWxyZE43b3A0TXpIVysvRXJlNkE3U2xFQ3JyRGZiQW05M1hZbHo3UGlMM0Rrd2JBRURNblRsN2JTaTNqdFRLczNvMnkvSjNuRHZqWFJmcWVQMjh2WFVTclVxc0dlQmhlZzA0ZHZ1U2tNYS9WTm10YlN1MHV4ZkZndGY4eUhGTVJnQmk5L1hHbXJUUTczV2ZKRGdDWVMwdEZuN1drVVlhZkxRczhPb0UwRlducE5xbVJqaFIrRWRLeVZMdGUxYzhqYzN2VEh0a00zMk52OUpRcG92TnB1cXRVamdpUjlFYmJzMTNuNTJ1OSt1bW0vMXpYTU5sczRUL2hzK0krVXpQWngvaFBURHVscjVOVXN6MUwrWHQ2YWM0Ti82VktTN0d3cDd3dFpCMjhpRmJYNjkvclRRZVh5NTJyUkpQaVhwY3VVdFB0dHVISnN5V3B0ajM2WHh2VGM3SEdxYm9NZVplQ1hySkZTVnR6MTJ0NGNlVzl1dWV2SHlud1VGcDVseWViNXFvUW5qSzV5eEN3eDVXbnJFcnU2dnJSSXZ0dkF4ZS9pM0E1N1lPMWRKOVdzb3VjaFJobnRGNEI0R1JhUWlBdnRyQzNoQVZDWVRwZUczSXJiakxpUnEvcnRFUjN6YU1ZdDR2TDhFbmxORFc0RlpISlJrOTREMXBIRlFSQmU0YXlUM0l4a3B4dGoxZ0NaWGtzaG93Y0VzelFwTGZLUExQL210RjJLejFtcmI5NjAzbzhYb04welVnRjlPWnBOUnBIbVRneEZRQ2VEek0zZUJFMFp3QUFBQUFBQVBna21BY0RqRUVmQWdBQUFKZ0wraFVBQUt4ODJwaHc1ZjB5L2dKQUNJUUdBQUFBQU1CdDRNVFVpL256RVhFeS9FZlNuaG5PU3VPbys3Z2R5bTV1Y0JIUnJVZ0FUcUsxQzQ3V0xMTzJBNUFWOFlhb080d0ovdTdiNnRuR0pacjJTRjdJR3ppVHRSTjFHTnRuZHhuUERzWjBqeStrM2JablZSYVYvaGdHdXU4M1V4N3ZrWVhJUVhjNG44Q09aanpQZjlCODRYSWl4enpNeXN2eWQ4cVExbWFNMW1tcDFzYXFQZENmWDg0UlJ2R0RHNDFuSitVcmh1TlpVeE9BTjNEa01EdzZuYWZQQVR3WFNiYVU1cHFXRGVrSlN4cmU5Q1ByUlROMG9tZ2V2WE1RajQ0bmhUM3JuWXZSOFdha2JUMWg3TW9UUXN3bXUwbzF1L2FQWE5UWXh2K3hEMWlyN0tseHF1cFNwWldzQUswaTJSMC9aT3pQeGI5NzkyMmltcC9sdnZwdWJ5Q3A4YU1yZkszd3lTaFQrOW9icG9lb1BCYWZ3QUZkWG5vM1pNYjZVVS9lZjY2bEU5KzBycElqOWRGWmQzZWNGL1hxQkFCd0Fwb1FtTG13QUtmUTgvNVJWSWNRMTZ3czlWQWJFK3NmYWZQbjI0dW1CMUFSVU42OGZUeWk5ODhpdWlUNVdGblFhMHp6eG9mRG1MRjI1VlducnVpRGp5RVB1dmRVcHRRUEkrOElkdVQ1VzR1SEREaVBHWXBuM2VramVZK21VYVoxMVgyY3doRWZRZ0hBWTBqR3RUZGUxZ0xseHZWRDhhN1ZIWmE1Si9IZWdjY1Q3eVhQRVc2TXA1UDlJWXVYUHd1TVdZN3FuZmRnUk8xQWVzTXN5cTBWWjdEbzFTT21VYjd0dHk2T2ZQMnRGMVcrM2V1NDhCbDRkTlFQa0VjOXRoTnRIc0NZQ1dHMFJqZlM5eTZZcTVRdnQ3VmVYdFBHSXpYOG1xWVJodUhyZzlFTU9qZHVGSzA1bHRXZVo5MWV2akJ2Z0U5aVpJMnVwODk1UG5NQWdQTlp4MzdCWEROTmxmR3NWWTNxelNOVGwyamVUOU03ckkrZzZ1dW83YkJscnZIazJadkhMRVp0TFdlUXZuTFB0MjExdmIzb2pMeEdhVWxKZzdSK21Qa3ZybVpyU0YvaGRoKzhlckpTRnR2NjIweDl2MzZpZWNiNnQ2L09VMGVJM2xjbHJIRm5VZncxSWkzTXNsK2xZUGhXM0puOEtVZnJZOU9VOUhoL3czd0hOdnlWY0QwOHpBUUtBRS9oU0dFTDNVUWZ5eUZqeE9UQm8wT0RCWGdIM2kvWHJQQVRTSVo3Wk82aGhUL0RkbkpMZWhjMTREQ09YQ2VPbHNFSzg4citjdGFOV1VaaHpjalNvNUFFd3Y5ZTgraU1ENTE0WC9RZlRjL0M4OUZCcEQxY0tjaW1rWTFyT0I3cUhHNUlXQ1lLRVRhRytsa3J3ZytpMW5YV3Y5TnZOeG1aZTl5OS9rZkZCZWdoS0toeTFvUDNMSk5Ea0ZITE01WCtLRzczdUlzQjJOcmRFL3ZBaDFFLytOcEExWXJ6WUNMdGZkWVlpUmlIYm80UTBORTM5Snp4ZW9wbzdqcnRkSStHbVJrUFRpWnFZN21CY3VQcHhyMGZic3hxdDFJZWpHa0E0NlpDNlFNelM5MmVDZjBWNEo1WU9vSDE4dHNTOEQ4cWJpdCs3b2pUbTlkTXZIVnRmUUExSXZ0SC9LVTFPU3VPbGM3VlhHbXZ2TzhIcVN0SGwrK00ydmYybm5nWjdMNlVmWkdURmFCd2JTM0NtZVdKaG05TDRLd1V3cDlQY3NUWjVoVjd6eXc3OC9ENTIvbTEzVncyWW1jaHJwQWNhOW1rWG1zZUZ0eFo0SzU0VlhmT2l0S3pTMXI3Q0ZiSm9vcldkQWVBRjZJWk9PbjhwK09WMnpFZDRwaHl6RWh3aHI0QjhHZ1UzYTRaM2tOQXFac3A4cU5Ma1IvRHg5NzRmVG5DTm15NVc3YlJTSnBSUGthMXMweG1yYkJyK05JZ2ZWQ0YvWGFIYkwzdEFDRWkxYWgxMXBudG9UZXRucS9xYVViUURZMEhIb0ltRzNQOTQ4REIvWTVJOVJIK09OWGF2bWlFSHUyNGpJZDhncXNKdEVHYTdZMzRzTEhnVTdudDBOL1lHVnNKL2hka3gwdUlORVpwTjdXVmx6VUl4REtBZ2pFSVNON2V2cFMrWk15WjRnUVQwNHVRRkMzdi9QNUd5azJ2blQwYUo1b2VmUVhnaDlFKzE1b1hXbW5YL3EweGRzYm1Zd0J3SHBiTzdKRWRkZGd6ME9TU2RxMmxZYjBqVTd1WFdQYzdVb1k2M3VpN0ZKNjh2WHFYZGw5Vy9lU0JQS05sOGNiTms5TzhraituVk9idTFxYUZYNVk1TmRFeTdHbmh5eEpvclVtUCt4TnVjWVRiNXJhOWRsZ2JlcXUydDQ3ejh2ZDAxVnc2cUpua1FmY1dVUTJ5ZHZlbmw4d1BSbVBsMzRmV1I3c3I1SlpYNW4rMzFwNUJjSlJnSHRKcHJhbitJUFNZck1YSXFjd3pWN2JCdk9pbnJ5N3RNclRHd3BaMGFrazFMVzhBdUlCUmRlcXBpdVlMaUZhOVI5dnNtUSsyVGcxM1lhMlRWWVcyZEpqSStBUHdXSTVvNkpLQm8zUnZNRG9qbzk4RzBNWmg2S1pYbFpsdFlacVJoalJYKzNnVmJVWkZXUHB5bVVmUFlxVUQ4Y05VOU85akdUV1d6ZWJNc3RDMkFPRFQrT1FKaVhYdmp4NFRtR25DbGRUdHovUDJUQ0E1TFl1WlRSNmRzT0p1RXdTWXl2cDQ3emhzZUJaZ01vYkN6K1JEZFowWnQreFpzSUFQeHpOUjh1aDZ2WlR2ZDk3QktKaGp3YjMrRnFoZkFGdTBlU0VBektFY2Q2SkRmVmF1a3lNc0FEeWJtVHJycDAzelIrKzNwKzVIbmxVMnJudmRvMkVpbkhHLzN2aFhrOE9qdVozaVBLemFsdDhXdGU5SmV4TjRKdmVVWFBQYlgzMmZkN3JuMUgyL2ZublZYa0dwOWVoSW5qMDFHVGJMT2J0QjVBQmRzK1U3SDhwYWQzL3lUcDFwZEljM1dOZW1VbytkVXBrUVNUMUpTaEtiSU1DRG9RTS9rcDVITmpMdlVkTnNSRTR6TWxIR3A2dVc1QUJlQzUzcUdVUVhOWGdmemVRTzcwYTBIaVBBSC93bnBpTEFwMUtiZDMzbVg3KzdGOCtIMGRyMVlzUjlYWk9KVkRKS1Q1dkk2UFJ0TFYwQUxzVXJBM01kSVJkTlBuMU9VOVpldExvTTdlMUtTN2EzL0pGTGNBVjE1K3BwaCt1T3RQa25xYkt2YWxsSS9UbXkwWTUwL1ZxMEcyNVZRUFI1YW5JTmJvbjJJb1BWSjg3b083dmRPL1B4ZWNJTjhPZytWc044RWRZM2dnRFRzQ1pLbHVKVmhySGNwVENTKzRoeE1PdEYyY3lERzNtVTRUYnV5bmdVTmM4dGpmQldsYmJpd3NGb3RrUFB3NGkrcVhvQjNtNTdoaWxDRy9vbG5iVjJCM2dUbXRqUi9IdjZyMlJqaVl4UHJmd2k0UUhnV2RUTHBDTTY3RkY2UkgzdFVlV2s4cmZ1MDVMVEV0bnc4NzZIRWFVMzNsTTVZeHk2ZHF3YnliM1g2Tjh6QSs3TjA1T2VWb2FvVWNHYlY0bHhMNnFOOHl1dGJCZzRVMnE3YjQ2WS9QSTJ2akJjUCtYTVZSby9XYVd2bkdxcG1IWlpiVE12dzBZbnZwRkZxL1p6MDUvNmlCVHR5M09HYkpEU2J1bnFvMnlmdE96dkNiZWhxb2l5V2YrOWo3eTMwelc3VHRaYmtMY01IdXJ1VjUrVXF0a0tXNmJSdXQ0MC9jTFNtNnk2SDlVVkFHQ0F1bU5ML3BIckZmOVFDRGZHbXFPMndxb0JsTFpXcTR2V1dMTzZIYUZmQU55YWx2SW1FWmlpUkU5Q0R1dTR5NzdmWnNYZHl1djFRMHZ2NUt4ckFnUVMxaHhuRFdPTmlUbVFablRXTDZsd2xpMTRxZndYcC90bGFFSkN1aTdEYXhYUms3ZlhYZk1mcUZUL2g2bHdTMFpsOFlpeUd4bFViNDNYWWhTNUtXWVFBRkNSUENzTUx3V1JDREJJNzZRaG1KNjBXTGYrMVJaaGU1ZStQeFlNS2JCcys5U2R5WFJnZ0NaMENlaWlWS2hHRmFsZU81VzJzdUNOZnhUT1BLSzMzVE1WcDMvREorSFJTK2tUOENrY1BVZWIzWmZvbXdBQS9jeTB6M25uRlhlekJjNGFSMjQwWGJ4aDdyMXZaSjVKMVBqUVkxU1l3WE1XVjJiWUd1NnM1OTJobGM1S3gycFJrZmZwWnIwMDIvVU9YOFJtbVBlWFUzcVdWV2p2bTg2bGYyZkJuaU10QU9CV1BHVUJINXJNK3FZanJUOXFqMGg4eFpHbUJtQVE2Q0IvdTZXalV3MnFsekNUMXNPb255UENNb1NubmZPZTcwMllaWkFlL1lEd0FQZ3c5U1o0bjI5VzNHN1l0cDdQeUF3RnRtZ2pucWR1SlFzdXp3UnVpTllzVThmYmZkcE9sRytSUzlITlFIYjBXSkt1Zk9NWXVRVWpTRzJuczAxRkpxQjFtRjlMTzh1UFZadXNsZWJjaUtOdEJUVmFCcmdkMGhnWG5ZT2QrWmpOemVUaEhYeW9JY0FhQzN0Zk5DcXgwc2JVQU1Qemc5RkdKTzA0b2szS0FrbEdvL1h1ZXVsTnUweTM5WTRiUEpoNmNkTDdFdVFOQlBMTUxMWGI4TjdlV25VOWZRNXpCendWenh4dDVwS0dOOTRaS2pyOUZ1QWFldlRsTXA3bDFwdEhhNWY4MXZUQXE3dGJjK2ZjQ091OXp4bFRxenJ0by9Eb1hORzZqNFN6eG9EUk9yMmJ2U010Zjg2dFBMczBieDVwVzYzczZQdTJadmdCZHNhSXF0eko4VGF6bWJqbFBMS3d0TVpJbFV0TWUwMVZ1THhFeW1lUmluOTljcnZWZ2p3dHpaSS9XbGs4REpyTWZPR3JURWJuQmRucEovVXNkMDlXSW9pSERSYzN0RHV0TlZmZExvcy9OM2w2eXVyUkkwYkcyelBtYmdBZ0VCSElYc1ZaOHhzUi9qQ005ejNDMlhNUVVldFVGSW1zK1ZmeGM1Rm9xc2F5S2hwTkRaNk5WMW4zZEdTdm9yZjJxVFJubnRES3pySmpXV24yekVVdXBUVkpPNUw2UFlhTlFJWVJQT3ZGRmlPUFF1b0RrVDcxT0dyaDRSVUNtaEVsS2l2THZNdHJMWnlVWG9mZzRzUFVENmFXMTk2MmpJd0hBQkJRaE9RZkEwT3k0b3k2M3hEdkF0S3lQT3EyNGpCb3dpamVDVUxKQlozcTFmMFk0S1hrdkg4aDRBK0pzUXZBSkdLSFo0eUViMmF2akIrWlJtY2U0dHBRSGx1NzZvbjNVWE5PK01kVkM2UXZvc2YyVDVYRFUxbEZ4b3lwejhpNjJSWGpGZjBXQUN5ZWFoYnl5T09vN0QveVhZbm8rbG52ZS9lTE0vNE03amJHNUZlTWVqTm14RWNRWGJTcTQvVnVDZUpkSUh1YUpJdVhlZlFwWDZGM2V0OHRqNlRSS3lNOTl6K3JqbDFQTnYvOHFkL2hHNWxuV0hIRmVkRVJSbStQSGJMODRqTlg4YXl2a1RyQmxBUUFUV1lhanlDTWQreU91dGRoa2lQT2JoOFQ1K0RSZkYrMFRHK2hxY0dMT2JKaGwrODZMZWZ3VWZwajlFWm5oYS9uQlFqSE1IZTFKTUZGbkN5NGZ0ZDVyOURJenNXeXA5UjR3MWx4ejVMYnR4NlFSeW9BUzVWTTNhRHJPaDVwd05RM25FVHZRb1lyakNFNzN0TE1MYjJpVzRSNlpJcTFDNU5XTUd1WHBzVUlYN29CektLelRXbkRzZVh1U2NzS3Z3amh2WEVlUlZSbXpBU2Q2TGEwaG9Ub3ZPOG8xZ1dVK3VQVUZweWsraklpei9GRjgxN1B1T1M5M1o2OUkrQ0RtVG9oQ2pBcEQrOTdZSG14MTVIKy9OaWRqdUNnWit5a245NFl6ZWdTZVpNa09ySHh2czF5QXRiR2tQWHZTQnFqdE5ZTE1JWERtN0RtYXByN2pENmdqVS9ldEsrZVR3SkFuSmtmbGN4YzBwaTFEbWFsMDZQcmVOS0lVTmFQOTlPMm81ZzVQZlRVeTlHNlhhc00wZldFZTNER0d6dFgwcXQ1TEVJOHE5ZlBKTkp6QmFPRFpkemUzV2JleHBYaTdmS3dMQ0tLWnBtLy9rbFNuRmFHKy9EN3A1dUVVS1YvNUUySFhnMTZuQ2ZNUmIzbURZMTZuTnBjVzBZRXcyRDM3UzBVS2dVcnQrNUtudlVsNjEyWjd5NmcySGMwWFNjaXpheFhSN3k5RndBdUpHSTNMdWtSSXJVOGdzZmlXVEpRaDhJSmcwQ3Z4ZzN3U0JSZGRFZHYzeEttb3BhT3AxMUxTWHJ4NnBWV25oL1g3M3NNV0FqSElYcXFiMlpma2RJczdkRzllRVhOYmVoOVA4R0tGekZDcklMTFdsandDcklHdjcxbGdudXpLc216MG9wY2Z6UlVCc0NyT1ZScGVjSUtpb09XRHVKOVdTRWE3MWJNSElBQklwd3NRMlpQQ2dIZXpObzlVM1g5RkxSM2MvZ2dGV0RMTFBzaFBCeXZrVllhRE01b0RDYzF6TkMwS0E5NWg1Q3FuT25iUTNtSkRVWGpqTGJwWFVOS2pqUUFJSWJ3enN5MDlBQUFvbHloRTQva1djZnRmUyttdHRlVmFTME5kK2w2Qk04N1FyUFNzOExNdXM5cytEMXZEall5a1g3Q0tEM3pTVnV2K0h2Q3RkQjY3cEdmVzFmcGV4dndxUTFkejZ4M2JiNmZjMjc4L1B1YWwxZmsvWHgxWGFsSzVQdWpVTVcvRHJjSmF4V3djRTZlOEQyVkgzMmdUSUFBNEFpZXFhaENrSkg1MGlIamoyY1NTcnNFY0lPYStDQzhBaGtaT0kxZUcyb1o5OGc4WUpDYjlwZmZDMHpEcXpkSzRYTDFWM1AzNXU4SjUzMEp4WlB1cTk0TjBuWmRRSXZ4NDkwVThXTWJHVHdCUzBidTVIVnJGYUdNVVB1OXRGM1B1RjIzaUpBRzJ1Z2FwNWFacHhBc2pzQlZHSjFLRzQ3cmEwczNwRWszR0trOEt2YlZXTjhqYWZPK084SkpxUTlBVTd4S1ArczZtdjVENlZIMVBPa0F1UEJ1MjdvczF6VXlwVk1rUjJlWk5RWFR3bG4rRWJzb2l5TTN3TEtoV0g1WitYMHp2TzFiTW1OWU5wVFpwZ2o2Qlh3Nlh0T2dkcTF4eG50bGx2MEhBTzVIWkdyK3BDV04yYWJRMW5zU1BlbHA2dVI2YmIzSE1aUFc5SEFrdnp2YUdqOTdEaWExS3UrTEVVc2c3RWdlTmFNdHNPeTVXcStTNG1udWRacGwyb0cwNnVNZGEyTjNyaTZTNmlsa1dUMnZYWEFsNzZURXIrTnRNMXRrdk5wcS9uSk5YMWN0VGJLV21uV2F2bWN3SXBjc1U1bzFSaTZHdjFkWEh4bHp0UEZHakZQZGNQSW1hZ1NUbmw2cmNuUFd5K3BwcFZHK3U4YjNQejlsK2V1a05PY3p4N3JSTmdjQUI2QU5mWXZoWHFjaENUcHRHSVhUc2Vab1BZL2YwcGJENDNHU3cyV2hiZFVxcDFpWVhJMk5DMDBSSGtvT3VrZlMwdGF4RHlRSC9UVzU5TnIrN0ozNFdWUGExb1FKVGlGaWllaEpNMnJWOEZvaWJvT3BhSHo5dFFaNWo2ek1SaG04Q3RMRVN1WEQxQU5Jd3ZXZFpLVzNMSkh4UHpybzNvcTJUUllBd0VmRUd2QkMrWExFTFNHR0FTcE83QlQwUDRBWFVFMzhjdTR6eVBKQjZnUEJVQXR3UFZHald2MnUzMVhNWENRY3pIS1cvNnc0QUdkU0xxNGQxVjZQZUprVUFMWmNNS3pTbHdFZUJ1OWF6Y2Y3YVpieS9tL3oybkwzK2tmeTZ1VklQYktIengyZmVwOTB0TWFranplOWVWaFN5SnRlQ3BRbE84dFNTOG55elN2Sm1KSWNhVHA1dVlBK3MwK081SFdVSE00ZGNXYVJsTHpUK2tOeUx4MGFXSzNlYk5Mcmh6WFZ4Nm11dUxQd0RHRGV3UjRBd0FPVHNsdlRPK1piM3lNMzB6UUNwQ3lIVjV2UjdOMHZBR0JMOG44TGlkcDRJTE5ORVRDTjZHc3JIbmNlM3dNNTZhSHhZZXBFVXFlZkZNNzdrWEtVMXFZQ3ZSc1dvQi9ETjZNVzRLUGlBZ3pRcTFTRlpPWGRWb2duNGIwdDkrMjNkdmhZL1dmVlkrOGdDWEFVSFczUHUyUFEwUy9CdkpvWjFxdVhqZ0d3cUx1SW5mSzRxNG5mOTBzRWpZOVRPUm4xZ1pUUHlucmI1RU9mcTNjc2xPTDA0aDF2NGFYMDlybnl2Y3BvWG1VYVZoa2lrN1JsUHlha2F1Zm5rVEZqZFBvbTNXWXlydUVDV3U4WHQ5eGJQR2kxeTdMMUx3NzNYdEVRemZOUzNSWGdaQ1ExT3ZyWlJDUVBiL3hSMVozK0NuQS83cjZrY1pUK2ZFZFRoUFp1UkkvNjZabDZ0ZEk2b2w1NjlNZ242bm8vcHp3ZVdmSXJXL0JJM21jKzBlVHc5eGd1TFVvcHVhYnhhOWtadjlWcktjbEFIYW1UcXRST3h6b0IxVlVkNVgwclh6OXM4dG9WUWtpbi9LdmxwNVZoTWYxN3B2Y2Ezdkhwek40NjJzT3NXcXpIS2MyOWxWWTA3MWFnWDE4My9KOFZmbTNXQSt0THU2NldGSGNsL05JUnptcmRVZHNLQUZ5SXBweEg3TTlQVTRwZmlEUUdqcVRqbWJQTjFwNXp3K1B2cGcrTGpqYjJBVHlDMFVXc25yZ0g0NWsxUlcvN2RYcmxiQ0VLdzh5Y0g4OTh2TFYxbzJIdDJJVmZsZ2Myc3h6MG56SEJ0YkFXRGlZS3BGOExBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUFEVGt5ZFNMMGJna1pxdVBYdXl0emFSQ0lwNGF3ZEdDSjc1YjBDcTFKbmJ2SDNWcnhmelZOMzhHQU8yYURpUlgyaUpRYThZMXlZMWhhcHRYOTBkNDh6ZGlRQktQRW9jVTY4TzduL1V2dzFSbmI4ZWlROU1zVFNLMWMzU1NtSFZ4UGQrR29vZzZLTmJlYUJ4UTdXZjM2WDErVmZUazU5R0Y2ZHBRNy9vYnBNNzhadlVoZHJoWkZBZlh3UW5xTVlJZyswZDJ0SjQ2Q05IYTJHbXAxbFV0TCtIak1XUDcwYjVScEZjYVZKUDdzQjBhTW5Yc3JvZU5OS3M2N0MvNHg0RVgzVTJyVVc0S24wck5ITm9IZE1RMzhFK0F4bUwybDRkQWl2WGhDVlF6M2hldlVOUzdZZThXNUV6N1JRT2hYQXlrZnlpMDRQcFRKRTR2U2l0ZWRSamowcDlTZVhOa2VPekRON3dXZzZyUjdocWFQb0cxTVdsbkdqZFIyZzlYanowdkFzdytWMm1xbjJhQlZrcVlSbHJxS05QZitmb25sdXZGMnZka2w4NlVocGVmVm9TejRmMFh1OWN0bGEvbTFoOXM2MGRhL1hmTHprcXBCaVBTazNiQjBpbkQyRFhIWDV2VmFWRkhlbFNUVzdieEdsSmMyME5tTzFMUUE0RWEyRDFrUTZhdlJkRURyL05GcHowY2djeGhwL3JURTFOL3lXZXZ6Undwa2VSWkMwTk9lSmpEZndDS0pUYUV1SmI3bTNoTVVpOU9rcyszdjczT3JXTTM4NFl5NXlLYSs1a2ZjdzQ1RWNPYzVFeXpkRHRic1Z2Y0trbGQ2eStDYkFYaU9KOVY2aEEwNU1CUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFYbkpnNkVXbkh6ZG03UVhwM1c0dWVYRkNtMGRvSnBoVnZkYnYxUmdqZTdVSjc0MzQ2MFVZRThHQ3NIU2RiRzFLWXUwSStDTys0TkVTUGJMRzJUUEZpYlZmMHFFRVFIa0ZvUzc0K2VuY2Foc1hlQ1NpeUV4d1ZEQUxoWGZMcU5xbHM2VmZxSGZWSnFkOUowU2J2VHowbU5CWE9SbHlQKzh2cEhWSWpKNjFRNVEra3BYZEZ0eVgyN09JYTNlbzVzbU9zTjgzY2RrNVYycGFOVUVxMnJMSldjVWJza2RHOFBHbEJnYmZkMStGYmNYcTJDSjQwSHpxU1dhWlJ6N1RCdTVucFl2aGJhZ1JURjNneWxqaVMvSHZIQm8vb2sveGJmZEM3aVR4OUZPQTZvcHVKdC9ydEVYckUwc2huRGV0SjN6dXRxSGRFLzg5WnBxVUtKNlh2bll1VWNWcjUxTzl6ZUhTZTZHa1gycnNqSS9wVnp6ekpFM2ZHV09MUllkL0J6THVMdGlwdm1wN1pkMVNUaUdoV2RZdlh5cUNsa1l4d1N5UE53ZWZUckRwbGdmLzdaWUdsbmVhM2YxTGlLeU5BV3YrSlBGZXRFTFdycDQ0MTdUWHlmTXJ3Mm9oWEU4OHJCNjg5Sk9YM0VmTjhMWTZXWjY1K3FDZEVWV2xxTmZ1bkNhYXY5UDdFRld1OVExeDUxNTZTMGpXMElxZ2VSVHFwVGtkcFNsNzl5MnJGTFQyclZmZDFYTWtmQUNxOEhYVXh3cFhwZVRzaUhYUWFSOHhGTkhldlhxQSszcXprcFdTK3l6c0o0NUtjaGJwRUNmQklldVcxUnppa256OS8rNW95cFl6T2VpTTJKU3N0N1RZL1h2ZUxtQXBnR3A1eFY1cXphTzAzT3N1WHlsT25xZEdieDIwWU1TSkkxelBLWUQzWVNIcGZjVGd4RlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCY3BQLzUzLzl6ZlR2N203TlYzVWhmaTN2RDEzaDM1WnBCZEJmUXgyTjlSZjY2R3o2QjNrWkVYY05OOE1qdmJEbWt6Wi9kVHBWLy9kTHkybFBKUnZmd0ZkT0l5QXp2TmlyYWxwUXpuOHVzcmQzZ3M5RGFkYUF0OVRZN1RRYTJkbk45Tlo0S2tmeTFNUEI2TEQzaWpHYXhPUmwxOStPOStnZDg0VEV1ZkdnYmlPNkMrUWZQT1FSMEtmakdzMU9oNTZDUW16UXFhNWZMMFdJZWRadmVma24vblV6VUdGN0g4ZktRQjljeU5SelZwNVpHbm90eWJZVUgrQVJtdFB1NlA5ZnVKYjFpakdVVmdHdnhtQUt0T0ZZLzF1TFZZZCs2cEJFeHczcnBxWjh6Nm5pVUk4djAzbkhseW9tRVpRandsbXRFMC9BWUk3UTBQZVhwV1VIcW1TbHBQZlFHZUJmK3JlTWdVM1VoR3Z0M2lWYlhlWko3N2IrRzBaL0IvcWxaYVMrN0dGS2FNOFlDS2FkV25KRnhLZEs3clhVa3EvemUrMXViWHE3ZVYxa2o5RWlPM2RQdE1YZ1lEN2d1OS9mMUlxZTk2MkpMUDcxU09ycStVTWFKOWs0QWNHSjFhSzBEMTl4VURYa0xVVTNXazk2eTlJL0hVaUxXRUpjcWo1NXhhWGUvVmFZMFBYZ2xVY1hMU3F0RFhrZjZscFNGUjIrMi9EK21mNCthTitBYmI5Znh6aHQ3OHE3VG5QR0l2SDNuOWtTVkdPOEVjVWFlSGhOUUsxd0RUa3k5QWNoS0FBQ0FDMkFBQm9BZWtCMEFBQUFBQUtEQWRBRUFBQUNPQWowREFPQ21KQ1EwQUFBQUFJeURWZ2t3eUFXZGlINExBUEFQemtFOWdQS2paZTlYNE5vWDNpTzdiM21JaEk5c2JGWVQzVVh1Rk5UdGF5cjNtVHR5dkluV3ppSldnNjc5cVZ1NENlS21aOVZPVmpzUlVlOHc2WkFkYnp5dExMS2ZxcFdHaWtmV2VPdjJEQm1QYklNVzFrYlFaYmhnVzVyUnJDWDFxTlp0Nzc1Ny9EQTlscVBJVHB2d09ubzJkb3R1a09VdHc2YS9GaDFYMmhuN08yN0REeTRtc3VXaWxVYlBybW9QUXB2ZWU2ZjUzcWt0UEp5V1BjTUtaNDMxM253amZpYzJ4Qm56T2c5SGlhTG9kQkFtRVhtZ0x4UzBrYTU5aFNuaWlEeG02N0FBczlHR2Vrczg1VVphSHZQTm92aEpZWlpHZUc4L3BoOENuSU5ueXBDY2NVZVdSMnU3N0JsNmhJVjJQMTZ6YW5hNnRkTDB6dXUxOEMyL1h0M3RxYWFYTTNUVmN6bXl0M2lwZTI3dEhrMW5wQXhSLzFhdksrL0w2blV0TEEycnp0Y0tFOGxySWw2RGV2T0UxS1ZTS0xQc2w0eHdZbUpyUkErMVZ0c2F5YmJQcEw5bWsxa2F5eVN1MTBMK0NoZHJOeU5tamdqUlZ0MDl2cXp2dXhTWFdyTzFKS2RhNWc1amhHcGJxTmFxdk45OTUwYUZpdThCTFhZNHIrU3c1cEoxejFxTThGTGVJMjBONEtPSmRPQldSMnNKRWpyb01GR05Kam8zMDJSK1Z2TElSU1JydnA4MWo5Vy9NZUNJYVdkbk9JQzNNR0tNTURxbzk1MlFDSmJhYTcyWFlsMlhicS9HZXM0SVBoTnZWK21mcS9lbjJXclAxbnVUa2I0aXBYOGJlaXUrVjlueGh0MmJjK1J3blhCaUtnQUFnTVlSV2hrQUFBQkFBZlkwQUFBQUFBQ0E2MkZ1QmdCUEFYa0ZBQURYd2tnRUFBQUFBQUFBQU9OZ1lUaVJneXViRTFNUDVNemRNRDJiajFsdGFXU25MNHZMTndpU1ByL25nN014OU0wUTliQkxFUWZnQ1NUSHpsZEtlODZOclRyKzdPcjQ5TlBJUEx1U2VYZjJNb2x1UzRxTWdTZVFsT3VKN2RlN2M1Qm44N0VqOU1OSDQ1Vkw2SjBmU1dTb0cyNGFlV25tdmRubDA4aU1rMUp2aExZMTlsSmRTOXZHZWROK0tacDQxbllaMTlLdy9PR2xlSTVlMEJxWjV0L1NHWGFDMnNqYmNwK0FOK2xlTTgrTUlvL2N2clFEWjI5YXQ2Vm56bDNIOVR4Z2F6dFRLdy90T2hMM0p0eWhIWG5HTGUrdTg2UDVBZHdCYWVtaUZWWTdIU0dhMTFMOTlvcEtUZnhxZVdCcUFEaVhsdjVvelVHbE5KWkdlbWN6dXB6eW41QmV5UlgzRlpuUDk2cXdkWHFXdmQxREV1Skh5aktUOTR3dlI5OUp4TW9VTFV1UFFTRGE4aXp0eDZNZHRiU2V4UWh2cGIwRTh2ZWtNYXVuZHJTcjliakgrdmpIM1hHUWVaK2Q0UHpQL2V0bGcxemw4WTIzbk5GbkVhbnpxRkhDbDZ2SHZmYnBNVDFFeDRoa2hGaFBiZlhjaTNkTThPb1JtN1QvdlArUzlYRFdtRmM3cUFjQk93clhlOWh3RCtKekVpcmRPK2JQSEFITzYwa0E4QmVQT2xXRzlRaGlPSXdqMXFKNnRVWXIzTzY5aldSa3JxbHlTWGdudFJxbmFIcndzZFNLc3FHODlhcVJFVjJ2eHF1Yjk4eUtINEZsTEkwbzBOckVDQ0hZVGFkVll4Ti9XZUkyOEZZWTc5Z21ta1lDOFcrUGRZTWp6SnFjT3VERVZBQUFBQUFBQUFBQUFBQUFnRTVZQndWNEx2UmZBQUFBQUhnY0NTMFdBQUFBQUFBQUFBRHVBU2VtQnVqNUtqc3B2K3R3ZFpqZS9lc2lPMmlPN3BuWDh4RjJaUE9ES1VqYlVVZTJpMXNXL1VFZFh2aUhZRzFPNlhFSHVBbVMvTTYxcHlYQWFuOGgzQnRPSlBOc2JwTmJFYlhkYmJURXBIQVNrY0ZNS21UdjRBZ1F4V3JuMlJkZHd0cXAzU3JDNnRhNmZuWFg2S25jbnJUZ2RmVHNodWRPVkJzREcrUFdib2dyT2pKTjgrWWNvWStjTmdtL0J1K3dxdTA4V2FydUh0V1RQdlJ3V3BNV1Mrbnh6Z09sOEsxNVQwVC9PTEFCZXZ0U1pJcFdobC9qZUc1WGlpdGRMNEcwSTJrOWxzaDdxZGFjUEpLbXR6MC9tRWc3MW1nZWVLUGsxY3F6SldKYWFRRzhGYy80NUxWdlJJZDhUeG96MG95RUE0QTJFZHZvSW9TUnJxTkxHcEgrUEh0Snc1ci9hdnJJc3JUclRncHZwZW5SOGFOekVBL1p5TE84bHNKYmRZMjkvV3BtVDA0aWszT3R4M3FKYUNoV2E5SmF0TFU0MityQnMxdXdaYm5UU0kweTllWVZzU280cVY4TTJKMlVLcUVkRGVQTUszazFUSTlod0JvVlJ5V3pKUzE3R0I4dE5ETkhmRXhJaHY4K3IzM055blh0YlJrYlUyZ1ZLU2xOclc2ZTZvRy9VaWJMSXI0UFkra2JxWGFNMnF1VVBOVjZHbWdtVWQzRmt0SXRkd0NZakZmRzFHR2w0V3JXVUFncTFselQ4cGZTYThuYm5qSGYvZmhUMFpTcXRwT1hkaUZjNnFOQW1SZDdtc0R0c0tiWTBiWDN3SFJ3UGRFNHRZTjVrakxuQzcwenNzY1MxZVVqT3I3MXdKQnpKbEpWZWRxN0Z0YjdXSHZTN28zLzJtWVFOY3lYV0daR2I5L1N6SklGbkpoNkljaEFBQUNBQzJFZ0JnQUFBQUFBQUFBQUFBQ0FCOENTQmdCQUM2UWtBQUFBbkFScUJ3REF2YmhRTGpNa0FBRDhneE5USFVRL0NON3NOaWJFYlgwd2JIMDkzdG9Fb2d6VDg5VzV0d3lqWDZYUFNzTk11S3lJQ0FkdWh2aEtwQjBwb28xbVpKc0VnQUZhRzZxb2N2ZkQycWsxL25SUHJKSWpNODMvREdadTV3TFF3dHBLU0tIVkpMVWtVK0JhMjUzMzFVaTdYTmJYeUFBbzhPeTJWVGVsYVpsbFBiL2ErN3Y1VHBBdmNEQkhWdnJMSDZpMk9iRjNKOTJJK2tuZmVBR3RNWDkxYThXeDBveUdrZkxQeTYzbUpFZG1HVDAxSUtJSGc4S29zUHhRbTJtUHpUK0t0bTZRRzM2ZU5LUTQ5QmQ0TXA2aGV4SENqRXpyZThZbjczeHdocG9CQU9OMHIzVTB1UE9TUnNzV3JJWFY4dlMrWTFEN3RhWTlGak9tUzFFNVBXUFhmOHpNWnpLN2xpUHBqV3JsUGNjZWVCYzFvbm5XTDRBc3lyVldya2djaS9yK1NuZHBscllFeXRBandZdzh2cFA0Q2xzZk5kazgraW9ydDV1KzRoVngvMXpuM3VlNkNQNHRQdzlSeVc3TnRxL0YyNE5XWnM2NXM1cnF4UHJKamJJMmpHOTFjMjdkOEs3NUZ1NnBjRmZ2emprWlM1N3VYWldoN0s1UkhXSnh4ckZzU0pxZUVlMUpBQkJrcHFwSWh6MmRHVnEwSjcxSW10L3l2QjRqMXpTME1iY01sMkxMTHk0dEs5MVZ5d0xvSUtxYzF3MC90YjBqL1VSNlA2Vzh0dER5YXMzTUhvWDMyZnloWlNUMFBneFFrY1l4Ynp2dHRRNzB0T3Zvbkt4T2I2WnFkeW5hRFhsdXNMY1M2enlTVWhaSFgrUEUxSmZ3bWc0RkFBQUFBRzZZVzU4SWxRMEFjR3NRMHdBQWNDV01Rd0FBQUFBQUFIQTZpZGtvd0F6TzdFbjBXZ0FBMEdDTUFIZ3U5RitBTWVoRHo0Y1RVd1ZtN1E2eWZuaXM3WHExZExoYjE1Njg2bkRSTXR5T3NwTExyNzE3dDQ3Z0s5OFlVa09QUXAzRFRaQTJqQWczejVlMjU5NXh5a3cwR2Y1SE1Ub2dBL1FTYUV1U0h1blY5WHJJVHJkWEVsVzZBUW9pdTFZZWxmZE00d3pOL1FTT2VIQWZpcVpPanFoNjlJRVhJdTNzSjltT1duSFA0cVQ1MGF5cFdPUlVnR1haUHdLUEdFUXRtMEJVV0dyK1ZQNWZSa3loMGZIcENKTTJqeEhleUIxTWlCOXRVd0c0S1o2VEI2VHJ1eTUzSHJWMDRkbEl2VGVQSHB0WmEvN2dqZWZsaW1VaXhnYjR4eEc5N3N3SlhHdVNLZlhja1h6V3RNbzA2N3hudkxDaTVSMzFLL3gzajBTSmx5TUxoOWtYOS9zMDFpVkk5UG1Oekl4blBrY3R6V2N4M212bGVzaTdxNlQ0ZmNWTzBSeDhwV3Jkb1BqMGc4Mjc3ZzVKRUIyNXVqYXlVb2xLaUpIM1JpUE1sb1FBVU5BelRMMWplSG9VTStlRnZmRjM0OUVTaUx4R3NBYUxZSnM2UWxzR0dPWW9ZMVJIM0N0bjRONVo3K3Z4R2lnUlpHRk83RXBEZHZZWjg2RlhjTVdDL3d5Qjl0VS8rVERWZ2V2SWU0ZWZ0SkF5cTExWWkycFNHRythdCs3czVTcFV5MGJxR1pBZWNjTTNoYnFGRjZISjA5VnduYXZaZ0dYd2ZodHEvVlRYZFp5ZHV5YS9aK0dackZqeFM1QmZjRFJWSjZxN2lIWTlrcFdTOWJmYnh6VDcxbzFiRllHT0F3WGhzWEEwVVlBUFIxSW5aNlhaNHFQR3lMZGgyWTZrOEVzUlh2T1Q4TWh2U2Uvd01EZzJITkYzckx5V1JkZEJGOFc5NS9ib253Mmt1YmRuUXUvbHd5cC9WdnZWSGtXVW82cWVQZ1YzNVFxejNlajR0QXpFQjRCajBQcTFwQ2RyWStKTXM4MnNjVGVpVDh3ZTYzdldqMXBsYWFtd1M2ZjdFaXpENmo0ckQzZ0RuaFdWYU8reVd0bWkrR3RwUlJZMXZMUDF1Z3kxdEJ4WitQWGthYVU1YWxTWnBlMEphZXhlTWpEY3Y5T3MybFRySllTa0xESnUwcE04dkcrN1JaaFpsM080VWw3UFhUZEtqU3RQV2ovOU5QMy8vNGwydTJNZWdZdnZYbDUxaldaWGFmQW5mTkpFUi9XdXo2aEVzSjd6SXZoYmVVVExvRWxuQUFqZ1ZhTzBhN2cxc3pUMkdsV09qeWdCOVRoVnBkWFQ5R2l1OEJoNmpVaXR0RHF5OERKYnB5dmpmQnl0NTRxeU81WDRYTFNQbVk4ckRmby9qaG1UMVZtTEdnRlRJUittVGtBeTJWcUxWa2QyYUVzdWo2WnpLK3BLYmIxZ0dIbmhFTnBvbzhXc3hnZHdBZHJ5MmZlMUlsUHl6Sm5LZ3duZi90R0Q0bWlheUMwWUpmTFdqZUMvZGhGSnRZa3VRRmt2QkxYaWZnUjFaWmVnUDRKQXoyT2YxbFNjQ1owMTl3UTRHMmxzUE52QVNKKzZNWGxDbUZrUHVLY3NVU1d2RTgyVWRnVGFlTlNjZXkvOVBMSi9lcFJ6VHhxZStOWUVZWVFQRVk1V1ZZL2EzKzlXall4NWNCZTBkVmR2ZU0zTkd6Y1MzK0tzQlg4QXNMbWJDblQwVkVSN244RVQxNXRuOUVWZFQ1aGUvYXRuTE1pVDNPSHRlRnJYNk13ZzZqK1NsbmNseWRMSVd0WUc2eFZkaTVtV2l5TjZ0QkczWjFmck1zNzZWVU5xZkp5YWc4KzkvdUp2K0JsNThqN2JpcnN2d1RHcEpsZW92V3U2NEhXR3BPYWRpeDh1RTlQRVNzMTUrMkdzK1o3T0xvRjIycTBiMHZ6cnplcEhwSFN2MUVIUEFMZ0E3NlRFR2picHdMY2txckZyMnEvNzhScmpVM0xFelVtUHZ5bVVmUG1kMUhWYUdFQUhJMFlrTFZ3eW9nOU1XV2JwZEpyZDdpUDZiOFQ0NXdtSDBITnh4bHJWRWVQU3h6em1HZWFyR1dtVTRiVktMMTdlKzdYQWpyVE1hZlJaU2Z0SWF2bnJ1WmRraExYOEwwZWIrREc0SEVPcmdWdmN0aEVCL01QVnJJUHQrTTk2VG5wd3U3ZHVkNmhiZXlQUGtCM3BnRFFCTkR6Q3hORUdrK1BhbzZPTk5QZVA2U2JJQTdnN2RVZit1djUyRmpxNkpVTUFub1kwRmZYYU8wYWc3N3dBcjNGc2RwcWpIRGhmMGt4cEIyU2xMamlVZjBmeSt2aXAzY3pLMU1LMzRuOVE1ZmVZUkNOVkNRRDlXSDByTDc3RjZ0eVI5cXl4RVFEbVk2MTdXK0dPeUR1YVJrK2FwY3p6NEZFamsrRnZ4ZmVHcitPdVJNenRNNlovVmxyb2RKL0tIVWI5dTdRK3p3Ung1S1dTTXIyejcvZklQSlcwV3k4VDFPNXIyUHIvYWxhajkzUEU4N3ZyeUhzV2R0L292NU4vOWRBZWYrM1VaOXJyUEhPMTc3K0s4cE5MLzBqbVJTYkp5TnhiWHErZU1hSS9BY0JONFQzWjF6TmpEdStkczVkLzFRQVRtS0dSQXp3Q3B6STNROWViRlZjTG41Vy9yOGZ6QVIxajZuU3NPWXMydHh6dFM1TmVyWDRYWjVwUW9tWHd4bDA0TWZVUS90VHRXWU5CdlppKzVwMkVNRllhM3J4dVNjK05ReDluTm5DQU94TGNRc3ZjNWVwaGFEdUNSZUlBdkpvYktGYTltOXBFL1Y0THVnNE1NcVVKT1JQNG5nL21yVnRyZmdqd1ZJNW96NXBOUlFvREwyZHdaOVZEZUVEamExVkhaSFBUSHY5b09CZ0FaZUlTdEdwbkRSWWd6cEhUL09qSFgvUmJBTGlheUpSR3NqRlo0VXVTNFI5aDV2d2dIK3dQYitYdFQzNkdWaE8xcW8wWVdZN1NyTzZrc2FFNVBoRzdKeDIvYWpQRHZ1M3Q1YTM0eTZMckVaTDc3cjJhbVlwRW1VWkV1Um1FSldjQWdHY3hVMjVybW01VEU4ak9SSnp3cmdqQWxsN2IwaFY5NkNQN3I4ZUVNREpKZ1c5Nit3SlYvZUU0aEJJZnBncEU5VG50QStYdlhidU1zS1Y3VnE0amFOOW1KdU02bXY3dEJJeDI0MVo0SktXTVpCVXNyNlVHWG9lbmJ1SEJtSGJ1UUR0L1ExZnczcTRhenBJcFVpUnJJSTdJR3JSa09JTUQybFdyNjNUM1I5aGlyWVNXN2xLYzBwL0svZ2c4ai91cXhlWmMvUDF1enF4OG40dFUxMTdkQjB3MDlUQUgzYTA4ZURRUDVRNTlTelB3TFpYN0JYaFVHOHM5dWtnUldUQWJubk0rRmF1Q29ucW5aeHhhakRTbEJ6OVQwTDZFSTAwUldoK1Mwb3VhV0JqajRJbk1HSit1N2dNOVkrTUsvUmRnREcxTWpHeWk0aDFYbjdTa29la1JMWDNEKzU2RGgxbnZMYlRTWDRKNVlBK0FmdTdZZWl3cjJxaUcwWnF0YVBWeHBkVkJROHE3SmQwNzZtczkwWFFuWUMySnRNWng1Sm1DaTFoSnlVK00zMnMxU3M1NEZpMkwxdEY0WG5Eb29TK3UzVk9pZGR2bWJ3OVRNdDJaUU5jbW01VTBjbEdxcWt1VkVzUFRxMy9WZVRsdWQ5T1ZHc3JON242cVlGcmRTeVkwYmNsNVJPcEtlYzVnYnNzQmVCaVJpWVBWRWEwT25vMDhZWmpvSTlIU2NHaHBxdXlVbGx2cU1YQVRKNHMvNWJ3VnRiTFZmR2hhOEJFWTB4OXplcFRzNUtQTHVSYVJOWTFIY3RSaVpldGhJUENtY3ZXNm16VVhPM0orZEFuV3V4akp1RzZsc1RUaWxPNmVlRklmTE5Manc5UWJjR1JuV0JWbHllQXh5OWh4Q1paVnhKb2hBQUFJaUNMRkd2QmZoclcwdEJqdWFyWFVBOUlNWnFjSGNFTmF1bHdVZDM4RmdQbFlZNWF6UTM2UDAxbDJGOTNvN0FBaDZESWc0bFdrcmxDNGJ0Um9zOVBORzNjazNHdGhIdndSbFBOQTcvdE0yclhsRGdESE02b2UwSDhCb0lmY0VhWlhqK2o5NEw2bkxCcWUrRkc5Q3NEUFVWcjRTTStZMWVLdHo3REs2MWtUMXRiTFFIekI4WGtjOFpMQnZmTyswN3hlKzM0Nk84T0pmc1YxcTVlN2E5MTZZL2tFN21TdVF6SUNCTG1pQTlkNTBuR25NVElFOUdySG9ibTNNUWFhQ1NUZE81WGhhbWhqQUUyaU0yMjZsSU1aazVwWkpoVWVXSmhSaTVFVjVvaEg4bkY5ODI2VDBLOEh6WWVwQXRGOTJZN1lCODNicVZOSG1QcUZsZ3R0TStPY3VmdkJveXRxQWpOcy9KOWFkM0E3UE0wNTF3RS9nTU52dDlyOWN1ZHU3VllrMFRLcTVNWjE2ZDVLQjZDWHBGeDN0TFdvTHRjN1RIcy9TSDhObnJlVDFzcjJ2c09CVFBrSXJMNldOUWR0N2pMUVhtaHlOeWY2Z0R3N25NSFExTlFhTTZucWwrRHBPMm54UGZEZWZ0Z1R6MXNtSnoxOUpkbzNyRjJZcllXR3lDT280MmliaXIrMkg5YzdVVXA0M2ExcnkvMUR5QjErM3FIY0l5SitMWEVSNHNrYjRNbU0yajNPNXRYakVzQ05pT3F3MWpUQkUxNGJiNzBtUkMzdkdicnRqS2xJVkdlUDVCTXRTMjhleUYrNEoyZG9COUU4dkwzRzI0Tjc2SG5sY1paRzJKdDM0STJyM1pjSVZ0a2JFLzgvUi9ua0RtdktHaWQ1OGw2cTI3TVd5cUlMYUo2VkZXMlJWVXV6RjArYk9udjJFVy9uUHkwd1ZkZHkySWcrWXViOWxabld4S3ptbXBlaWlUWEtWUDQ0VW9wYXRwWFdkZW1XRjM4cnRhU3c1VysxbUR1MmNvRGJZZG5McmFFck9teXRRb0xPOTlGc21vQnpFdDZ5ZjJSblpqUTd1QjB6RFRsR1dydFRoNE1kb3FWWFdldUFWbmpKNzlYOU5mTGN2UW8xWEU2cm5SOXRNVnJEYXUrUVBKN3NjTFAwaWRGRkRldmxvSVVQVTZkd3hUekJPLytwNDFoR2lLWEQvM0xxRzVPdVY1eEt2SnJQSjhLZ0RaOUdLVVBPV0IrOENiMUxTUUNnY0lHVm9NZVkwUk1PQUlLcytrVFBaRXlCL25walp1cVBMRXFlQm4zcTVYaU10Skc0RCtIcTZleXNPV1lrblZmM1pjWUVNTERlbndJQUdjc1VQTktYNkljQWNBU1dXdGdqZTBabG4xZG45NlNMN0lSMzgrUVdMcTFBemI0Zno4ZXhlV2tiM0dHTXI3cTlwSXF2eVBTT2JTbGVwc2g0Ty92OXdQckQweHhOb0JVbmIvNHNxYjVXd3JmU2NxTm1zZzkyVmV0QkNnSzhBRHJ5eDVPTEg1S1d2ZnV3cmVlamdVZzRBRkRCWGpXWjZOZUdIbEl3UEV6SE9ZMzZEbnZFOEZTbnl4QTRFY2RENDhOVUFlOUwvZG9tTmtmSXkxSEtqNXF0SGJBZUlaT2xyN1ZUNDNxcDNGdHB3VDlHcERGMUNUZEQrejU5RjA0U2x0V09VZlZ1ai9rRjdYMWs0eG4zN1VjV0Fxd3RnMXBwMWx0UXRzSzIzQUdPeHFsL2VPVVhURUxTSDJ2L1pVR21mQmhldzBuejhYcy9TclYyOEd0N2Y0ZWhLWjVBUzBCckQ2cEhodkF3djZtclhGTDVab2pwdE9pUGw4ZnhZcnpDOHdvYjBrQ2UwZWxSN1QvamRqM3FsZFRuWHRIZldqZW1HWjViWTBxdkFScTZpSm9pSkwrUjhlaU0xNzRCN3NhVXVWZEhmb0lwK0pCM0haaXJBY1Rwc1kyT3lKTGVieFpxdkhwRXJlcTF3cFp1cGR4YW5HVTRVMDZkb2JLaUZzTm5NZExpZXcwZXJWbk9iR25oZGYvRHJ5VW1EV2N3YWtYSndmQUM2MG1wM2hjVHZDZWtpdUhLbHlQS0VVcDc3dFo5V0FZUktheEY5R1dDR1htZVNTcisvYUdsUi9qUU5hdmVweHNONXlHZE1Nalg5MnVaNjdUclZoak5MaHZGMGg4bGZYS2tSd0NBZ05ZUnZVTi84MFZGUnhnNEZNOGFsaFYvV1p5UHNzaHNSTXRXdGE0VUN3OXdDMlkyMEtoUk1HMkRaeUYrN3pxMlI0OEVoVmttQjFEcHRSUkYvVFdPdHVxOFFyM3FNZTU3SDRUMVFGdmg2MGxvRlpjUFV5ZHlWQWVKWXBWajVJV1kwNGxLaDFKYWpuWXdrR0VpREM5QVZLeVlMYmhBWkFKVTlPb2J6bmpNdFM5Z3JYUjBIamdDT2pUQXFXaXZlYlVNcEtqOU42TFh3SFVrUitaNWtNSHVDSDJ5NTcwS3J6OTl6Z0E5OVhLT25LTzlZcUVNNENGY01mNHd4bDBBNDZiTUN3ZWNwOTdLekNZNkttTm0xdUdWOGc1WkMrL0UyN0pUUjl5ZVFhRzNwM2svL2ZKU2IrUERvQS92NGt6VDZKM0d6Ky92cFpkeDZqcmMxV2x2SmQ5STNDRDlBRjRBbmZoU29tdFlYditzT0Y2eDdNbDdad0QvR0psNUh2MGhuWlRueDRMQU9weFpuMWRaL2oyZmRNMEM5ZXBBR29MdzR6OU1GVDdXTmZmbGEzV1NxRm4zcUJmRFpnNStSNVgxTUt5dDNDQ0cxRWtBYm81bkNXMnpRMkZ1aDVPQ3ZGWC9uZDdOYXhuUzJrTElHbkRxY0ZKNEppWndKcHErTWRJT2hYYTlrVmVOWXZ6YVJ4V1QxSmI4SDZmeldWZzMzTUt6QXhDOEZrdVBpUFNWalVpWTBYNWUxMUZmQ0hQUlV4Z1I4UkowclJ0eTl1ck9MRzVhVnN0VTVwMkN6UnJLWHR2WFBEYTBHWldPc0x1Y3VoMGZZZVB2RlNjOFpuZ0RSN2RmK3NlSDhEUjkwakpHd0thS0lrdVgxdmNFclNVTUs4NWJsalJhcXV2UjVxd1VkQWZZY29iMmUyUWVzeXhiVWxyZThOcUtramVOR1JJNUVsK1NyR2NQK3BiVXIrbDUyeUQ5L0NsUFNsMVBUdDFsWGZpTHlhVnRPSk84K2ZNdmpkSG5GOFV6SWx0NTNsR3hpdlNaNjFSWmI1NnFEaEZ0Y3EwOExIR2x1T2VpR1l0NnhRVFIwWkxpbGtTd3dtbEllbWcyd2dDQVFJK0tGNDB6UTkyQzZWdzlCNVdHSFV1ci9sV1BxMmtmMzZKKzc0eG1DSy9BZWhlNUZTL2lybVIxbE13b2k1RU5mMWhrb1FwRFJMdFdqKzEzRnBxOS92RjRLOXNqOTZJUE5MS29VU2tZbkpoNk0wWTdSbTEybmNFWkNuY1k3YVdzRkl3RC9adzFHd09ZU0dwNVNOYmFEMUJTczNGdHVidEI0WWUzRVZ5N25aNXVJQ252QWhmRE9zQU5xTjczU0lxL0l3bUExM0hrRkpSK0ErODJvc0hwTVArRkNmU0tFOFFRZ00xTXZaSStkMk9PbWtEVTZ3YWo2d2gzYUVSSHZDUTc2VTJRMEdPMGpLRVAxOUY2YmJxUmQvRzg2MFZSY29mZjZIM0JwM0RXcStOUFNIdDBNU3J5UmxzcnpTTUd5ZVRJQzRiNDg1WEQ1cVBXcnhGNEhZaHZWZFZQZis3eFNwMG5LZng1RDB1VUNZWE8xWStrNUtHNWkybVZhTzhJTFg3MThjcnVnUlFFR0lRTy9MSDB6a0ZIMHgrS1kweldjM0kwcWFMZDBmd0F0bGgySzJsYnBMT3dQbHlIUlRkblVGbmRHTU9PTzd6bkVjeFdpejVPemJyWkRYL2NoNmtSQWUwMXZYcGY5bStGNmZtQWVXbVVKeEp2SksvRGlXem5zaXh5Qjd0Q0czZ0RuanByYlNIa1RRUGdBSkp4TGNhcDFzbnkxOS92U1htOSs5UUxxTWZFS2QyNWxZZ1YxbXY5R1hrR3lDZVlRYytNMzJoN1VkMHRkNlR4Y2MxL2hwSU9IMFd2YmFyVnQyaFNINFEwTm1UQlR3TDlaRU5MbmF4VWRuZlZXdjRldlJnZUFIMUpKTksrdFNvOG8wcEhkdHE4ak1qOFY4UFNXV2ZlT0gxREpGTGx2V05FY3ViVnM2bnBFb2dMY0hkNnZ5V2JzWTZHRHZoU1ppL0kxMnVSOWZVSXM4djZJdXIrS2VxcWVSdGVDdWNoSzNuVy90cDFOSndIcjN6cTBhZnJPWGFrVE5HOHJIaGFXWkRQY0J3ek5laFBhS25lK21vTmtzbEkyMHBUY2kvLzNvV29jVmdqRjFHLzZsUjdVU0VGRllrNmZIMHFhNW1ubXJRbDdSZW5lODBNWTB1VXlGc1RXdHhJR2E5VS9OTDN2eU5qLzhnZGFBZi9sdjUvODFLYTFucDRiNjdjdjhudHZMS1E1dXF4SzFhU0wxdTZxWlJFSzd4VnR5MzMxalFrTDdhdW1welhBSzhsT2tSN3cxc3ZMVW9kbEE1M0diUHM3YUh3U3FaSmNmZWsyV3BTdVZCTEUyME4zb1JsZ0xNV3ZwWCtJTTNva3BHazExYTJHT0U4Y1Q4T2FURm5XZUxqT0lRWnJXcHB2bEpOd2RSd2tUektkUFB5Z2ZPWm94WTFMSGVCai9zd2RhM3pwRnozVU1lUEduQ3N0TmMwUGVGRzhuZ3NyUTVUUDJnQUFJMEpnK29Uc0pidXZPNEFIMDI5cHU3aHhNN2tuVXNBd0o2ZWVhRTR0a3B6RWdDNGpNaFl5TGg1UTNnb3I2SjM3dm1JWmlDdHJOQitIOGZvV3NGbzNyMWhhR29BTWxmMmFiaVE2SVAzTHNaR0ZwbXZhSHhXbm5jWUxIcmVDcW52UzN1akpYaC9wejZpbnZ2dXpDTGlQL0pTVVk5L25od0hZSXlacmV0TkxUWHlpZFdzTjltOHdsRjdHNVhKOTd2UW52T1plYjZmMFcreGh0NVJ6SDMrVWZlL0xTZkxUemZub21YMUxneXFtUlpoVG1pK3pIa0JBTWFZTlJjTnJVVWJtWVpOQ0swSVJWNThsQXJnUS92b2RQV2pLMTNBREZNRUR5N01qRmx5NUp2STJkL3l3VWtVNjJRZjkySHFINUp4SFhWZnY2NzJmSnhxZll6cy9icGNLb00zcjFlWTFEd1Z4Y3RnZldpRGNGNXM0NW8xOEFOY1RHNTR6REkwM0pteWkxcGpYUGQ5V3pzTmxXR1dScGhaMURORDVCUE13cXRYREhlcStjM1lvMGMrR3U4TlRYZzI4QzYwdnVGcEtsbTlXTHFzSjU1M1lhV3M0QVFpWDR4NEh4UVBja05rS2xySGlkcFNvdkhoWnB4aFJCdk4rMEt5dzAyN3Rxb3Nha3VkV1UyM3F2cmtEQ01KTXV0R0VFaW5ZZG42YytYWG02YUVkMHI1TXZFRTRHYlVmdUd4aFk2V29hZlBzVlIxTURNZXZLWVVTVzVwc0F5OVpXemxHVTE3VmhrY2FlYTI5eTVjZVYrYkU2K2t1azFWWE5sN2s4ZWQrMktwUnA1VlRrcytSV1hlcUJ3SGVDKzlXcnNVci9WVzBDS0VqNlRkQ2p2RHVOS0QxeUp4eE14SSttRFNZMzN4cEZ2SHoxVWVWWnFwR3ZTMG95VnI5NlNGTDdQUDJ6enFvdFZwNlE0RFdCWW1iMTZhb1Y1VDhxUzZ0L0NrUGNxUmFjdUViUkZLazZ2RDVFQ2kwc0crcm5ndHQ2SU0zK3Frb0ZjbVE1ZFZFWFRXbk5ybDFGcHBJNHRkK0Y1SnA3VXNxMnpudFVTQWk1aWwwbGlkcUxWZ1EwZTdEVE8weW9obW5yMEpHWUZ6NWM5SHFmQVJCUHBJMHorSlA1c21YMlZHdG9uVHlzcXpGamxybHZSWUxQUEhqTEVibWh4ZDFWTGZPalArSXppem5YZThvUEJyQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCdzhKRW5wcGEwTnBxeGRqQklSbHFSblF3MElua3VocCt5bDk0ejBCNkc1cGFkY2VDSDZEWnNVbHlBbStEWkJXWWpNb1JkYnJTZG8rcE5Rdk9EMnI5Vkg1NHhvdDVJdGQ2UWRSZFFJcnFkdGlXZlduTHJZN1lFZ2xPWXNRVmU5bnYzNm03V1VCN1poZXVSZUdVRitndFVUSnMrV0cxUXkzRHhEMXNlMVgzV1pxN3dSY3Q0VU1PT2ZFTm83YmtWTGxyVlBKb0xrWlFkN2RxYlZzOXUwMHZBVDByekJvMG9NaTBxdzNpSzNyTXovMW5jcXY5YWxkMXlqODZMSTNtREM2MFBXYWRFMUg0elRSRWo2d21vSC9BbWVrMkJyWDRxOVV2cGhKbW9HdEhUNStpbkZiMUNzNDYvcGlFOTJOTGZrN2UxQUd4ZGUrN0ZNdEJGOFNxRFVwalJaeUNocEttdHMzeEhxOWRrR3MvR08vWlplVXBrN2NMWW1WK2RtblRVcmRTRXl6UTE5NTRwaTJhSDlzNGZ0Qzdqall0Y2hNK2paMGJ2OGZlRXQvTHFNYXEwTks3RmlMY0U0bGtEc0JaMkZ0NDZjWTlRVmJpV0JiUjZHVXA3UVdFM3NDcnVpN2JRYnloUFNaaXQ1dHJQTW1SRW43TlVIaTJ0MnQxUzhoYkR2NnAzTWN4aXVGc3pqVlpjcjM4Y1M2VU4yeUtxQ0pGM2Fjcm1XWWEzNHFhcVNpWDlJeFU2V3Y0U1UySnQ1bTI4WDBKYTI4ejM4YjkvRnQwclVzZlJFV0NHbFBOSzRWYmVsalFHZUNTakhjeWFjM3R0RVhCTGVqUTlyeFpVaDlrMW5WeUZTZnM0SmFVdHdxczlBVHdhNzFSYnNlTkpDbVV1d2tiNmliY29QWGEzcVAvamlTcktDTFRwZUMxSml4QXVCZDJqZVZ1OFpxN2lxWWplU2xJWE5ZeHdRaHhPVEFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZ4OTdZcXEwZTVQM28vbVJqVzR0ckkrTTYvUWplOGs5bXA1Szc5M1M3Vk9KYkFWUTF5M0FRMUIzNWhCMnVhbXBkMlRNMXU0UU55U3krNGUxUzAveWJwZTRKcFljNGJTMFpneDJ5Q3lZVFd2ajRwWmJ2VU4vRlV6Yk5VOXJ3bEsvN3RtOFJycCtITkh0WEFFcXJPbER6MUJtQnE0eTFYYVI3bEUzYVBKT3JPMUJXM0dXSXE0a3dLR0wxaVpyVVZwZHIrVVBCMkp0RWV3NVBNQlNZanhLam5jTHhrZ1lMNU5zS25WMWVLYW8wV3hucUZmVzdXcTc2dCs2ZjNvcXUzYVAyTjIwTkdBcTNyTk1XbGh6dHQ0KzF3Tk5CWjVLVk8yT3VKZHUyanFnRnQ0cWcrWVBYM2pHUUcwODdSMHo2M1FqWWF5OGt5TXR6OWJmVXZqWmpjZ3pOMDJOT0ZMWXFIdjVWeXRDYlNOTjI3OHJ1eE5VTy9TcjBKcEdGU1lWYmxrSkkrWlZYZGNlNm9teHV4L0xMcjg2anhsTnlhUE9ldUpiWFFpWkNmZmtpaGFxemVoNzhQWmc3d0RyalNkWjdyeDVKT002RytIeU1xNDRlRmZVb21sNkJtRHR1VGNHMXI5Slp5R3ZPb2w2WVVFYmFLcHI2UkZvaXhUMXdKanF4SHFNSm1YYW5tZmFvN1NWZWZhMG0xNHJndFhlWitLL3YrZzh5VXBuNXg1STBEclZQbkw2cXB5QlVFNGhyL0pBNEhCV1NjeTJlVDJRdER1OXRQam0zTmFVckZXRzZIUUk0QlZFRnpVOGExdDBsdGNoUGw3UGdsbDVtYmRwMWVyWVV2dHJhclhndERsVmZMR2JMOENqY0U3dnNtWmtxNUlhNlNPV25tV0poTWdNczNaL0RVSFpDZlB3V2s1RzE5RWthMDhyakhTOUJQTjhISkViMGlablZ0cFJrNHBnR3VURTFDK1FTd0FBQUFBQUFKOE44MElBQUFBQTZBRTlFZ0FBQUFBQTROTTVjMmJJTEJRQUFPQXlHSWJoUmRDY0FRQUFZQVlmZDJLcXRJZGM3NWZhb3p1UnRqYk9pWHdkWGw2L2pzZ04xbDk0MTF1OHdaYklGaHhhM1FMY0ZMZU1MTnJ5bjUyZ3NxZDlSd1gyamZEc0xMSVVZVWI4eGNEUkxZSzg2U0NUNEdnOENtUXdMV3VuVVc5L1RRNDNhNi9wait0Q0gzdmpJQ0hOeWR3NzF2VjBKbU51b3AybWJHVkZzeDdBdTVHNVoxdnBNaTRQSTh3UjlnMXJESVFUYUFrd2E2ZSszZ2VWakRTdHJSYVA3citUMDQ5TVViMGJpdlpPdlJxYkk2cGxzWGJVUElWZTRlQnBZNTQydHl5TUd4ZWdpYWRXdTlmRTF1RDBjS2VIMXY0QWIwQXlyV2g0ZDEzVzNFZDB2ZDQ1MStQRnVWY29lbWtkcWJNWWVWbVYzNnJzNk56TVVxUThlcVdXdnpYWHRBWWVieDE2T3BkM3ArdVduNVIyUS9uN2pxYlVZYTdUMENqaVp5Mk5mVkRSM1kzMUhLdDFwYjlPMVhQYmxhRnlWMDhFVzlycFNNVVlrWG03ZkJlZkhCdVYwMTQvZ0hPWU9icDdCTEUwUVR4QzAvQUsyQlZMZW5vR1E2djgzdFdxYU5ucjlEeHAxR1g5enhtdkxvZm4vbXYvaUhMejVaNjF0SmFsbWVhdVN0Y0ZpR29BYStwTDFxQ2xSTGFPd1JUYmczY1VqNDZDUjQ0MjBaSFlVdWJPTE10NHpkUzZYall5YTZyeVJsUHl1bnZDSktFSk5aOUVGYjVIS2x0WWtpRXlWMDBCZnluTkhtbFZobW0xeEdqdkJiZ2wzb21RNXQrWVMyL0NlRG91bmVsd3JNY2Rza1VZYmFWK1YwVExZM2V0MlJEU1lxNXBhSm82d0tQeEttbXBlYm1ab1dpei9kNmk5S1NsV1JaZTMzK2o0K3dLQXE2YnRiMzNqb0dSdEtXNXkrTEl3OU8zb3YzMlkvcVVWVEZhUmVUcWI1M213b21wQUFBQUFBQUFBQUJ6d2JnSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDVDRIVWtBQmppSUNHUy91ZC8vMC8vNXJYNDR2WDN4NTJ0YXRQY05HNlp1ek5Xbldkcjl5cHRsNU5YNE5tR2F5bkN2SzRDRG1UR1ZnWUFOMmUzRzRiUXZyOVBUbjBSM24wM3A5NzJ5TllqR3NnbHVJb1QybHhFeFduRmwzaHQxL0VveHFVL3NnTTZVWnZVcExZVzZiOVdjNGNKakFwa2NPUGRiVzdtenBNMTJtN2hQUFlKalBTbEl4OUM2L0NTaHo3NG5xb2UzZFUxdWtQLzQ4MTNYb09zNThZUk1wZGpiWnpyZVd5ZWR0M0t5enA1UWd2dnlSdmdLWGpISzIvWTNqeThNRDA0a1pGMXdGbkdiOC9SUUZyYUhuY3BiWTBSL1NLaXRGbiszdnRhZzZ5bmZLVHQ5WGMwSTE0ZHRuUXY0MmJQZ1B3ZHVDcFRGYXpPWTVlMHA2MDVuMnVyZnFUNzdYbTh5OUl1VXJocE9aNDd3TDI0aytZY0ZkUWphWHI5eTNBU1h1blN5cXMzN1JuY1dYczdURkl2OXVDbkRNaVJseWJVdEtvZjVvbXBHaU50cTA0anNzSmkxYVhGeU16KzZMelBKMlNuVE12aDcrZVV6VlBUSzh2Q1ppR2U3Q0Y3ZHpWYkoxNjEwOU9UanFDMzF3TEFGNk5EQWh6T1RBM2V1amJUYXhSR3RDMDBNdE5zSlFDUHhKcHk5ZHBFbFNobDhpTXl3Z3Y5MDhCU2tLbEFsYWdseWRPMXZOYU0wcjNFKzlnNnV1K3o4SzVaelJBK2tRZGM1YzJKcVFBQUFCWG9uZ0FBQUFBQUFBQndDQmdkQUFBQUFLYUFXZ1VBQU1Cb0NBQUFBQUFBY0RWbmJRUUNBSEJYMnVlZ3ZzaCtOYkliazNlL3Z2S0Q0TkVCeHRxUW9TZittVHRnTmJHK21GNGMvcDRiWVpUM2tZUHVBQS9BczFHRDJ2UVZqOWFHb1hjbktkZmxlTlU5NUhzSFNZQW5ZaW1RQjhpRDNpU2xZcDJ4QzllbHpOemhERDRPeHg3aWFxVHMyWDY0UnBpTXRRN1dXSnpYTk9lSmpNaU0yMHkybjRWM1gvczZ6c3lxanN3VHdFblBnUVJMd0s5RTY1K2hMZm1YL2NUbzVvMGdNb2ZUYnVjb3UyVlBYcmNjMjNyYTdlSU1pNUM1TFRNZWIrMXZpYW1sRVE3MUF0NUdSSjJPYnNickRkZktzM1QzcEhHcnVaaFVlWGZGYWdqbDM1NEhhK1dYT3QybGNOcFcrRjRkb01ldTFhdGYxR2xHRlRUSnJkYWphKzhrWDYvcks1NTFsdldrMEx6bUZ5WHYwOXZrbmNSZ1pqcWltNlkvS3Q3YVNhbUw0SitOdERWNmRKdGFObTdTR0hrR2Q1ZE44Rkt1SEtXYnZXbUpEM2FTZi9UK3ZCWm9MWHl0Y0NSSFhyMytNNWhWUDNXWUhvdWxOZWpYN2hMUis4bk55eDkzcnhMeDliTWNtTlRpMS82V0VyUVkvcDcyc2h0cG5Xa2tSNXFlc0QzK1BmZFpjOTVBRzFYSlhYT3lWT2s2Umw0OTcrdDREdXh0SFF5OFZMcXJ0VHk0MGUyS3REVEpJYVZSKzF0U3UyVkxNbFIyRTQrVThrakFldm9rcGVsMUIzZ2tYcHVENVE2bllNbTFrVFM5bXJpYjdQZmEyRllhZ2xtYnFRQThpdDdwWUNzdHA4MXZ0dndvb1Q5V1JCZU93Q1JnSVhESHN4NlBoZmZ4UlpZMHl1dkhNRjJKR01oYkkzRmlLZ0FBQUFBQUFBQUFBQUFBQUFCY0JPOEdBQUFBQU1CelFac0ZBTkJBUWdJQUFBQUFBTHlmMzJhSU03K29QWURJbDgzZVRXbDZ2dDdXZHFYeXBoSFpJMUg3d3ZzMmozSmtvemM0RHM5V1p3QVBJKzkrTE4xYld6M3hwTlNWbmgwS2QzWG4zY0c5ZCt1UjFvRGRTaHRnaEo2ZGthTGI5ZVQrNUZyaWFvSllleTdhYyt2Wk9oWStscTVGMEpFdDdxUWRseGM3aXpOMjFmczRvaklra2lZTUVkRlo0Y1lrNDdwblcvV1o1Q3JQQitvSlBUdFI5dEtqTGtlWmx2YUlFYmlPRnpIRXd1T0luc3hRLzQ0UVhVZXdOaXhuTElTM0VCWFR2YnMweitRVWxjRTc4SG9YTTJmU1c3WTFqcWZDb2pZMzYxb3lubVZIV0luSWx0L2EvZllNUUwxNGJmbUw0ZTdOSnhkWktDZFpyZTZwanFzZ25aNVY1cHNGM1M4VmNldndwYnZudEMycC9MdmdBL3BuVHZ0NFVwT29UL2txeTdXN1RlVStYV1ZLaFZQa3Zpek9rRThBdDhBNzJKbXJza0o0emQvSzB6S0FhSGxZQTYyV1R4M1dNeGplZ2NnZzZKM2hlUWYzeUlEc3JUdHZYaTJLdkZKalVNajE0TzRkZ0dva3BhMjg5dUN0YzAxUnROS1crcTJHTjl3TXp1dFRNMVRVWFpyT3h4UTlLVlU4ZVY0SUl4NEFiT2l5TmMyVFZCWDlhdFVybzFNUWp5cmZPMi8xTHJGTDRTS2pqZWUreS9BdFpxcXNBSWNUR1o0dGRhb1ZIcVl3U3o1TGNid2FmSjIyRmE0cG9LVkNPTnFOMTR3RjhDbjB6bFNrZEpibEdQMzY0NGdLWkFSWU41YmxhR1llUjJPdHhUOGFhNjNLRW1SWlNTY0FKNlplQ0RJT0FBRGdDd1pGQUFBQUFBQUFBQUFBQUFBQUFBQUF1QTI4eUFCeitkUVdSVThDQUFBQUFBQzRrSU1uWmZxSnFRL2JXc2p6MWJKM1I1RWpkaVJvYlVDU0czbGJYNWxIZHFlNk5TT2ZuVnRieVlBUDZoQWVUR2dmMGc5cTY5NDlhcHVpTjhtWDJRZ1gydUxMdXRieVFtN0JLTzd0NVRySVB1OVdjMjRsNGRtOUo3SWY4S05CRnNBQTFrYWtmOE5jMk1aQ09nNzQ3QmpXOXA3V3R0T0w0Zzl1TEh0SGRzUlozYlF4RUhYeEJrUWVqcldOdWpjUGJRZS9selVJNi9aNnpiZzlwdURSOHpvc3Z4QzlOc1VTYnlWR2xYZTRGTytqOFc1QWYrU2pwbW5CbTVIc0dKRTRKZDZ4c09la2drdlZpT2dBM0tvWUthMmV3VjdETWxwNWhXcFBYajBQdzNzNlNlU0J0d3p1cmJ4UzBEMkNWYVpJSjVIU0xOUEo3V0RhU1ordEUwRFZJcVJ0dUZ6ZFIvcHk4OXBDczZjZXFuWXNuc0thOXY2cVNVRjV2dDhuZXRWZVFuOU5pNUtCa0VaWnBqcWNDa29IUUpDV2RqTnJGaEl4aW1qaHJZRW1COFBYZmoxdlhYa2w5cWpDNG1HbThGc0hEKzlDZDZRTW12WWFUVE5nL001S0diU2pJOTJQeTNxK0k4L2QyM1k4ZVVUTDBkdHV0YjdWU25PMGo3VHl2QjVOYjlST2g2OTFIa20vclBYSk92NjNsNUwyTHU0aWgxdjljbDNPb3V0SnVteVJ0WXAzU3ROQ2t5QXpScTJzNU9XUU5xNDhHMm93d0R0b2RSb2EvaTJ4NUhkck9UUXRNUTNRU2p0RjdIU0tHbUhKNis4OERaVVE0TlpZNnJYQXFrZldPdHdNN1grVGorRXY1V21sOVRHb0FxdHlqOGhLWkZ5VGpxN2tzbVpZL2g2MDhLV2FsWllQZWNRNWVGM2puYXdXNlhGaTZnMUFmZ0VBQUFBQUFBQUFBQUFBQUFBQUFNUmdyUjBBQU80Qkl4SUEzQnVrRkFBQUFBQUFBQnlCZm1McSttbnlTMmVrclMrc0k3dEpqVkx2UXpoalA3TmJFL2hxK2krZUNubk16VitFZDVzTWdBZmdGUTM1UTl1NWR4ZWNjdmVSZXFnUDc4U0lUSUVuWTIzNWRrQVdVZjg2YkRMOHZlazhFbmFtZ2dEV2Z2SE52blJCSjNIck9BdE1JMDl5aDI1NmJERTlPK2pCUVdoNjFNdytORXU1R2RrRy9rS08yS20raFhlSDV0NzBUMkY0Z3V1TUJ4Q0VKZ1Z2WkhSTks1TEhrZVBUVEx1Tks3T2VDck1xTzZyckhMM3U1cDU4TDIydXNQM01hRHhYNmgrOUN1U0FRcWs5N3ZvRTBWMjg0UDFLcDF6MXB2VVRjUW1UaXgrcDVhL0Z0K3E2a2VqZlA5L0hjeTF6aGVRUjYvY3o0Z0hjbW1qbmt6cndGZVVZdFRhYzhRSlByOEowdFpBWnJkdFpDdGhJM281Mm1nMWxMNVVEVnhra2NwYUtnYVZveEJKYjl2ZnRVV0xQR2d3amZjNmJ0dWMrcjhmUzhmS0VKdFR0MytHWHM5d2RabzRJRm5mSWE2WUV2SDhyQmdqZzdSelcyaHlkNGpUTzBOeUc0eWVIdXlKTXRSTyt5MmpMUXBPRGgrTHRSSTRHdnJFVkNqcWV0NDhjc2FieGNmMnpWOUdNVEFjL2xCazYvS3g1UU05eVdTc01qM3NTWDVYNnV4bm9RYldkT3NORVg5Q1M0bWp1ZFJocm5pQ2xxVjAva2pNdEhCQm5SRW9EM0FSVlRxZksvWVBhZGN2R1VMNjMwRmhlYWlmc2lSUk9IT0JpYmpnbTF2MDFRcVM3M3BiV2pQQVZOd2hIb1kxeGFsOFMydEczSG5GUUc2UHBYZ3hXcHRNWkZkdmFrRUJmZWpHOTh3bXBzU1hqK3NITWVMM1BhNCs4cGZvVm1lQ2VlUVBNaHk5blJ0L3c1aEZkeTZacEFQeWp0dzk1MHBtbFJnejNXNDlocDg3TW91ZUd6NXovWEtsSXZFSG5tMUZQUnc2Q3dvZWlyZWFkSnJTOSt1UFU5SlZwTHZ6L09tbjNPVmluYnR2UzRyaGY3ZGxZeHQrdmw5eHltWVp4UDd2MU1hdGNzOTRTc3RMQUhnT3ZSaHFJRnVFNjJyRjYzMHp5cEdXbFBmSTZyYVVVYU83ZSt2RUtVUTh6TmNvcjhUN1B4dWoyUGVDMDBybmJxbVcwTEZMYjZXMlhrVDRTVmZpOTdoSHVPeEJIMStSbXJPR1oweWdqajAzckVCSmI0K1Zsamw0OG01RnB3OUVTMGhwQlowaCtnRWR3NVBBSlE4eDhORk5scXFGR2JHd3FBV0Vhc2pFQVBJMkFVaUcraDVZbjJVQ1hZMmIxOEVYcTlBT1RJNVkwWmhKNmZ4UjBHZzlhL2pEMWdiVmNDOWFsdU5ZbW85R0dQOUpSTlBOclZzSnB6K3l4QXdjajNmMUJPNEVIRVpiZmRmcysyanA2TWpub2x5SnBhQU5zcFA1bTF6WHlDWTVpZEMzeFFGYXgxYVBMdnFMTHRKUjZnQUp0L3JRWityL2FrTmczR2d2R003RGV2Mk9JRzBRU2xqWFp1SWJER2EzeWtURVJCb2oycmRsNTN6R3RtOUZ6YTlwajFjWlR6ZjlTc3RNdDRqOFRCTlJwV0hyVzdEelc2eDRURTgwQzNveGtTanhLTEd0bVN5bk1LSS9xdDk0UHk0NmVsSG9WalZiOGtieGIxMDlnUnBrbnBLRStSaVZ0NldQVjdZK09Nbmp6Y29ielpicDNhcTNycTlHTkFMa1plUkVMMFYybnVTT01OUStzNDJsdnhOV2tqandBSGtWTFdvdzArSjZPckxsSEIwdkxVcUNsRWJuZlVZRTlRNWowR0JuTzVHaEZxcWpEM0ptWDJnU3ptcFhpc0kyYklnT1NsYmIxbkh2YWJlL0hwcEZGalprV3V2c093RWRzRWp0eUFxb24va3BLUWt2S3hWTXV1OWpTbHFSblBwMVJpZEZqRzR1U2xUeXRub09hQ2EvQnErSnAvblNHdytoOU5MUGlXSWxKNDFMdExzVlR2V2xUOEdhRWFXLysrbHNyRnBKOWJ0WUdKTE5tZlIvVFhXZlowWkZydzh4NkZCSkhXWHlnUVllUzg3dVoyRXM2bWZRZWU2UnhlWGNWME53OWFTOGRjVnRwNW9ENzRmVFk3NUp5ZmFzYmV3aWVSYjgvR0F1ZDFESGNBVXYrbWdHTHNTMXA2eXBhbjNsQUgvQ09RNjBodm1jc0MwYzhZdkFENkdGR3B5blR5bTF2TFdrdjFrdWRyKzlhNWZPU25rbTNBSU0za2hTM1hFOE1oVGpaclhBbzRaekJzR3NkQkpYNkdEeTJscFo5WXhIQ3cwRklzdE1hZHoxOXNYN0EzbmNhRjJjWm91RnVobGUzNnpXWk5ZYkViaTZ2YXFsTlNXME13ZkU2SW5xV1YzeDVwb2wxdUY0ekxFMFRub2gzN0lpT1R6UHk5UFFwYnhsdTBUOTdCbXFQd2h3UmxyM0tRa1RSR0tsczc4Sm9yNEoxRjBHdFBkZW9IdTFrb3k4V2RkbFRwWWZTS1ZSQ3AydWw0bzlRRDdzMGwzblVIekJzZndUdnc1M3BNbmZDWU5uVVprNUtBRXg2TlpGWlJJd3JMYXo3c0FZTnIwSEhxMGg0WmtaZXZBcklqRHdqYjM5NUZDd3Biczl6N3MzTGs1N2d2bnZzTS9LMHdqdWYyZmRSay9sbjBFdFcyaEdrdm5URXdKUTYvVWJUbHJoNEFQWTI3eGxacFhaejF2enJqd3JXTUxYZXRXdUtTNk8zQ1RyZDdDZmdmWmVnVjJLMHBITnJTbFl5VzJYVlFNMkVXeEhwQ05ZYUI3eUNxRjF5SmRvVVJqUWM2d003WkNzOEF1OVV4REh0clRjZ3FlTjUrNHcxMjQwTUVhVjdLNitQd2FyazFuTmUveUxjcGhPcDB0bHQ5dVBWcUFzcTRMY3IxSU9laWlZWDBySTM4YzY2clpZc2tzeXhudlZCUy81WjVlbU5ld2l0eGFzWmhXTHlOUmNHVjNnRG5yVTByMEIrRUpHaTMyNnNBSGc2SjNZZXEvOHlqQU0wcUNlR0VnY05rdHJyRFFEd0Q4OVU5QWlUQWppbzdUb2VlZ3hZc3gvb2lCRU5Oc3g4N0FCSGNKYXRQNXBueit2VUFHOWh4akxEekhXemt0TVd3cy91M0QwVjduMUpZK1JlemxBa3ZJMmp0eXgzRWRRbkcvVTNKcFFYRGxhUjlmMzEvczJ4LzhCNnlyc2Z2anhublJncitudGxSK3Q3S0Y3K2d0TzVrMEE3Y29BOTZ1MG9MUSt2KzB6S2tXcTJFUGt3b2JTNzNSUGVYdlNlZ3JwK09aZys2SG04bmNsTnE2WHJqT3BKMlpnWDFCK3NpbkdXYWszREVwSGVyeFl1NUVrU0Vza0JBSGZqQ0x1a05tUkkzemxQNDhiakZNQVJpUDJ4bUlvZWJXbWdxem00cTAzL3c1bjFqdGRSajVPK05SZjV3OVFaTGVCQ3RBbHdNcTY5TC9ublJoakpyVFNGbHRkUzNONFA5bS9QcklXbDFrT0FOcEZCbHdFYWJrWXRFNU1Scm1hM1MzWCsraDJSUncrU1AxSlJ1NGQyYldBYTBjaXNBaURyNFNwNkZDOWpiWGIyMmxIMlovMStQRW82ZkR4U3M2aDNzdHMwb1N5SC8rczFvWTFGeDJPYXQwSkxHR29yTERObHhzY0w0RDV5UjVncy9LNXRMQzNvUXhPeEt2MU1BOWFIVzRjalZWMkt2aG1QUk90VFUvcWFWMkdPS05aMUJTQU1YczJvR0NyYmNXNkUwV3d0QUxCSEc0ZGFmYXpsUDRQVCt1MlpZMDdrcG82WWxIclQxQlNTT3l2dE04c1dUV3ZXM0hVd2pkWjZkamxtcHVyNXpyQ2xXQ2RjbFdXcHk5Y0thSTM1OWR5emRoZVRydTUzWjRwUStxbDJRbGZ0bm5jL2JOUm5FR2tYWndqTldlOFFBSHdzTGVObzJhbXN0NlU4K1pSWUhiZW5RL2NJZ0YvTG1CRHhXRlhxYTYwdXN4S3VaekNVaEhkdTVMa0k0YVgwR3NieVhNWGRMS1I0dFBubEo5N2ZZSG43Vi9LWHZ1cHJwZm5qVUpXbEhvaEhMQVE3TFVmd2IxMW53NzNNUTB0REtsUEVQWUpXM3MvQ3EzZGFhR2w4cjJrVVlrSnI5a2UraHFPaFNaU1dHdW5OeTJwaFZtLzE5aWpMSGVCU3pselRxUE9pSTl5Q294NUQxR3cza3BaWFBnUGNDcXRCV3dwS1kxcVFpaDh0azNlZHBYYmRvbmZwUEJuK3I4VWpIT0VRV3ZPS3RJeVpvM3Zhc1pYZjYvdUV0d0s4cHFWV3VsOFArUGN1SUpyQ05OWk9sSlRyT2x5THg4dkhrVkYxUmp3QWVEeERCdGo4RlY5YkYzTWxzbHlPZHhsTGU1bUNJUjQrSG0zMVJQUDMrcDJJcGsrV29DNEIySWg5S1RLd0R2SWc5ZU1aYUpQcVpGekRvNmhmcS9OQUh3b3dhOEp3UnFXejJqbUZudmUvVHh3cUFXNkxOUjZObUo0QTRCOUg5aGx6ek11YlAzczB3MnhrNGUvSzliRWpCdk5SNWZ6T1FuSm0yWHBmSmowelR5ZkprOWVaNVIrbzIxRTkrTnMvV0liSXlWNjlIMGtNZjF3eG8ySkdtRFZIQmJnbFJ3NHd2UU51NU0zTjJTLy9ITkhaTFdYdGlYaFdDS01nYkdXT3FPczc0WGxMOGJOcGZXQWFDZDhLVTdld2I0bDQwSnJrcC9UMHQvZGVBSGcyczBWOFQzcnVEL2lQVk5VQlhvUjNCazVYT2hIdkIxbld4MTBRWnNhcjE5N0h0OEpqdXhjL0g2WkczMFM2R1QwZjZVUnYwL3RCVUNzUDd3NVEzblJiWmJxTktTbFNxTWdISXRCR2s3NWVkNEFiRVI2V0JGbVN2LzdXcDZTOUFXODNEZzN4a2dJdXVWdWFYczhZTUhOdEZNRER4RFpsMmVabU5OdVBtRkJGS2tvTGk2ejRTQ0w5dy9WUmF1azFxVTNkY3M3MkJ0YksxQVN4dFQxZ0JCNWFGM1dWOTlwWXNuSHRUUXNLanJRSnRoNEtRdEJGVDEvUjBxanhmcHpxblE1cWFidXdNb204R0Y5blB0c1dockM1RGRJWVVHTTlydG50dSt4TE5CWDRKRWJiZWFuS3J4eTFwS0dPZWJNN3E2VzhTdUdQWXBiZU5VT3dSUVh6MjRqZTN3bjFFYkZucHZKSGxzTkkxejFvcXAwV0xwcXVHRS9Jck5sdHZ5cWtQaWwxQ3JQblM5MUdzeFBpMVJ3NVJ3VVk1a2pCUFBObEdlbHpwOUYwNnJSR2xaMlpHdVNac3pEdnFEZGJpeTNUc0xCRzl6cHNXYmE4VFVJdGd4SWc5eGgyMXBjNWxEYVVuRzhFSmkzUG5ycTM2aTVTeDYyNFVqdnVTU2ZLYkVYalBIcE9oYTlQUlBXZWtLcmxWWjkyV3FkZHM4dDdkVjhxL1hwMUxLOEhhZXErRHI5WlJlbWQ3L2VNSExONjB1UkhBUkFUdTk3T1FVTjlETm95cWVUZnU2YlJETHdzelUwU2NoVStlek5mOW1uV1FRRnVpeVpUUFdFWHVaOTg2NC9MUEx5aTN1cTJINHYyZktVRlhSQ0p6cWg3WnVCSHBxbU50eC9iWnl5OVVzTWhJMy92QXRLNURtVmpWS2pjbDhVL29jNk9jRE03ZEppUk53SUFBRVlac2FvK2dONWJPR1dJMXdZNmdDdnhLbFNUMHA3NS9vMDJNUUtBQ3ppZ0U5S3ZCMEhuK0JoR2JDTWZpV1ZBVE1LMXBIaG80VnA1ZXQwdFB6Z0Y3eU9ncjFVdzczMDFNeDR2NGczZ0IyOS9hcWtaMzZ6dnlQZSsrNTErOHBxT3BtK1ZOemF5cUR2S3JEVzdnMnhwSWYrbkU3Mi91OWJIZzU1VDN2M29pS3Y1WjEvNHJ0TkxaOWR4OU0yaFNCd3JMMnR1R3BHVkFLL21pRmRYWjRWdnZhN1hlZ3VxOVhaVWhKYWhpZ242UEZ4YStSajFJL3NlQzlhdjlVNG93ejd6NWZ5MmRHWGV5dzN5N2lkMzJLRWpINDVHM0NOcGJmeVRQL3hQd09yYStkaVFsT05RZndBd1Ntdm82dEdXTFhQZFpscWZmOGFycHBiVk94NEJ2SmxHcHhHbkx1bTRMb0l1Y2dDZVNrVVIvTXNkbGpRWWZwN0I3MW9vUHBYNm5idmFmZlhMaHI4bkxVL2pidVVsdmVzbnhaZjhlajlTMXNwMENLMGJndk93dHZLS05HaUFFMmsxeVc1UlVyVDdYTHBWQnVoODgvNFFrZmxhM0drUlBDK1lwMEFjajM4MEhJREdTR2R5SmgwdGdqWThyM29qemI2Z2R5Y1hlRFVqUnBEaHFjb0JNdVZBTWZVT3ZBWkNLWTZtcDhCMHZIYUxIaFdSc2ZFQUpFT1ZaR2ozQ3FnZUE1WmxMSHN4STdjYm5YWko0WktSOW96SDRlNjNWcHZ6dE1tc1pEcnpoaEJDbHlMWi9HZWFJcnhqVmxMS1lvR3VCMitpOVlsQ2xON3h5T3ozaFc2VG9vWWJyNyswSUZpL2F6NmJHY0trVjVHQWNXWTl2NW5QN0t0TTRtNy95M2E4VmFMK2pNZU50S0o0ODR3eVloWTRVczAwODliV3Nucm5ZTnJFSUhJenZaVjVocXowVEh3QWhqbXFBUi9KN0JtL1JsNXNMYy9DWTZoYUJ2UHc0UDFzb0VjZ2UrZ1JhQkZqU3VuWG11a3E5N0ViL0xQaXZnaVBNbTMrN0w3YVU0K3JsSlR3S3Y0MjRxTGpmYjZldEtTNDBidzl6R2pmRHg0Y0hWMUxPaW5WbGZSRVhWWXNTK3NGZ0FNZVNYU3ViVjFyYVhsNlROUk9aeTMxdGNKb2FYdEhrakl2UzdvQVRFTWJocU1kbGNiNkdGcmE4bWlhMzhOT1lSTWQxVHB5N1ZDN0wvYWFEY0R0YURWV2JUcVV0bjhsOGIwczhWY3FXbUdpY1YvYjkwYW4yRE5NRVI5S1Q5VmJGZ2JOSEszbDFXTnhjYTlwTEIrQ2Q4TFgwY2QrbXlHc21lUE5xUHQvV3M1WjA0aGlsV25pTTU0U040VEgydkNnTmdVQTU5SWxJaXpOSUR2Y1hpNlhFTHNBOTBiVFlaZUYvZ3R3T0RQZkIvRjc5U1lKOEZFY1lSdUJwVDEvbWpWUDZva1hqVU5ENk9ZS095U1BDNDdrS25OemJ6dW5QOEFuY01wYWZkNzhhYitoOFZXZ1p2OXJMZFpGN000ZXZ4bk1TQitCZEIxM2ZINHowM3RxMjhvK3ZlSktYZGQ5U3BpblVMTW1BcjJ5TWpuQ2VBY1Vxd3k4UUFiVDhDdzZQNEhSTW5zNnNPV3Z2VVlvZlRLVWwvM2JYekNQRzlkcjc1ZUY4SDRjWWl4NkVxclh2d2QxWTVFc2g2T3B5MXdwclhna0FIQVVSOHdtZGlhQ1VwMWE1bVdRVS90YlBtUW5QSXFCUnR0clNsc1cra21Za2NxV3JsYzBVOFFhaHdjMTVSV2dNOTVUNllISE93Zjd3OVEvUEtDMjYxMktrdUJYWHEvaFNxTG0wQmJlTU5XbUNUc2llWlp4TGpkOWV6NU9MYkVFL2VVMzlBS1NjazNkd2cySjdtQ1hyUVE4UnVubE9SdzZMR2NsTTZ1Q3BEcEh2c0RkbU54NUpDT0Ixb1dzY0ZwYzV4clZ1K205WVhTZGo4SjZkU1VMdi84MnJYeGNFN0dtUXpUTkFKWndsZEIyTHRTdVlUckp1RjZKR0JvWkc1MVlsYThaMEVjcVVjc2pHWEdPZkhBUDBBVmFpMDdlS2Rqb1FwY252dmZ4VHExcTczdXRyUlh2ckZ6REt6bTd5M3Y2VXMrdXJRQlBJMkxubUpWWnBDOTk5ODlrK0pjT1BSdzZLQ3A1alNqR3M5YndJdFI1SWhRdnc2T3FSK05FMysrWjhkaWphWFRKamh1aGZaY3ovY09KeUlRaCtrQTlEVWpiSkdDV2ZJWVA1SW9lZmVkRkRXczF5MnZRV1pSMEl2NlIrL3kxNkFhdFJjanZpTTZ2MVZsOTdaMEJScFE2cjRIRHlyTlY1NTQzNW5KSDlDOFA3U3U3WE56UFRsOU1SdHpxT25sWGlxeTZYeHJ1VVl2ZHpMWm90Y0VqMi84RGNENmlXcDlxNlZMTlppdUVrOUxTOGtqVmoreHRXa2FRaUdTTnR1YVd1eVlwdERROGFWcDVMVXFlbG9TTTRsVmhBYWJRTytRekpEd0tTMXMrbXNnVWU2ZnhDdVBXYkxrTGNDbXRCcDIzbDFJVWJaWVl5ZExTYlNKNjA2dUlySDBzUzd3aUpPRlk1aGtSbmpDTkVTdEhuVVlkRDNWcFByKy9PNDFXNjlUMk5Gb3lzYmZEbkxMWTMwdXJiYTMwM0NBQWdNWExOUVlVSWdBbkl6T1NHL01SNmxGMDVReGc1YXZkYkhabXJPY2s1ZldCYlUxTCtvU3NBVjVCcXc5Wkx6SEFGOWE3VmpOWFB1OW93SHBBdzdqeTlkaklmUExXYWpYMjY0K2tweDBmVllabGVlM1VFK0IwV2t1VnJldWRSNUZJMXQ0S3lmK3U4K0lrVjJsa3hmOE1jcWRmSk53UjkzTmxuUUU0ZVZLenpIZnNwNUh3dWRNOU9jTURmSE5GSStuTjg4b0czWk8zRktmMUZtYzBYZXNEd1UvbEttdlNTWGwvVC9pdmVNNjB1VWVUNDBHOCtwVDJmYlUzdnZSeGF2NmFrN3F4UkNPY3poM3Nrd0FBUFhUSkxXc2NZcHlDRDhOclhzZU1OWkZaYXgvZXVMemNCeERtMzRtcHJaWGVoODJnV2tLOGQyZW8zby9uSlR5TDZxMDhaNVRsVkJrWmJUc3pLeHRrcUZ1NE9aSnVsNDNyNzkyWWxnRlFJTGRZNnk1WEdCUVlJeUNDSkV4T0lMcXIzTWMzNTlaejBuYUI5TW9mWk1YSGs3Ly8rZmQzcy9DYi8zMjgrcGVEUDA2TitOTnNGYXdGRG84Zmd2ZDBMR083Wjh5MFB2QmVGaDVwRnhIaDB5c2p2Zk9KR1hrOUhFM2xLZjBsUm0yRHR5Znk0VThPWHNNck9Oc2M0UkZibUpiZ0U3SEdyK2k3QXVLU1pQVVM4RTdWRjNicUZ3T3VpVGN6dXpFOWN4b0VFd2pNYXZhelBtRTZtbVJjcjh4OEQrQjczbHZKcDBPblE5YUNXalN0SXljY2tRcndsdVZKOGh3TzVzNkQzNWxsazJZck03RXNkajN1TGNFVnNTaTJtR2trN2pWR2VNcGdsVy8wUGlKdjFxWEtXWXNiTEl2M21FcnB1UENxYUdyV3U2OEpXKzFIc3poN05Ra3ZsaUYyT2RBZjNCeFFsV0t6THVha28rODhsZmJsSy9WOWpaYlVrYTQxZDZuYlMyRmFJMG1kMWdqME9qaU1xQnBoZFJZYTY2dVJtc1h3STY4UzBPeXhPLyt2c2MyaFhRTGNEOCtVdEw1TzI2aWF2NWJWNHNqSzhyZUdCb1lFQjVJQ1dlanFWRm8vclRFZ01sWWNPY2Y1K0w1aHJTc0VGalYrTFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURuNjdRczNjQW1rUWIxSHFqOVR6MG44YnMyOWYrMkM0SjY2MjI4bkkzbnJEakdSd283YjJlRHhmcXBkNHd3SGNnYXA5NThwZDNTWGZrK1lEc0hZVHRQeEZEMnViOE9qV09oNTZqMDRBOENDMWFXMTdtODYyTlhNWHpmK3FhMnUvM01kMmgyNkI1VWdMUHBKZHQ2NTJvMnZ0bUtzNkhxUVhSdzUzR0JsZVg4WE1iY21RR2Fkajdiem8zUUY3amR1eTZ6eDZiSnpCa1RxNzlRRE5rd21NNnpVTjZRRi8wSVBWZG9aY0hPNVJqdGpwZmloTnk5aUp2UW9FUE9ZTWpaNHBpQ2Flb3VLV1pneDNSK3BidmJ0cVI5YXNQR244dmE0Y05CdndkMWxiRTBQUDRDc211bHlITldZQ0dMVG1VNlYvNUhDQVdmUTI1ekw4TDhGdEZpMVRjOHV0UGltMWhWVnVjNzFycHY0OGU4Mm1OUStzM2JUd1dwbzlMMWx3WEFzME9YS0FQVXBDdVNTU0VLL2xiN2xMOGIxNVdKcGxxMnk5SGRaNnJrY1lJM3JQcldubDZTMi9ONTRudmR3TzZyMlB2Q3g2UWwvdHVBN3pSK0dYOVBaVWxTa3BiU2g2YkZFZHZ3c3JqNW1MSFY0THZQVWlTQ3ZNaFdqTk90STlLeEc1VXdHUzBqU1ZxdHNWUlptVGZxZWRGMVdIVy8yMUxyYUxWcTkvRnQya2RHL1JLOW1zUjdFVS9wYkVHK1ZJTmRFN2FrbGhBVTVqUkkyQVd4RjVWSmJtM3BvTkpDT2Nsb2VxQXRidTZ6aFVqSWxaeUZ6UUxwR2xjRDhzcGFEMnF4cjBwcitrZmRReWVwMlZSNHg3Wi85bCtKWS9MRCtWcWdsTkJOWXdPZWptYmJlUlIrTHRBNjk5M0pyd1dCbVp4T1Z0SHB5WUNnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXVmazVNdmNtMlB0SDl5YnhmTVk5OCtXL3RZMWVIay95akh4dDdpZXgrY0FuU2pxTlNXMk5MaHV2aEdjQk5VSGRJeXZ2ZGxyNnBOOXg4ZVh1TzdHMjVGR0cxWFJYVlNCNGl1N0RWaFVEdXdGbDR0b3VibEh6dm5zVFdUcHZhSnEyMzcwYmFGbDlhdURWTXovYUF5SlNQUk5rSGU2TUwxTHNPbTB4cVMzV3p0b1pJS3cxWXFKQ0g0OTFrTGJMNzlxS0UvVGlTY1oycnY5NHROOHY0MXJhZFNjbkxRMVJ4K2hCbUhBcWdoWnVsUithWm1WcUQ0Y2hXc2ZBNklydHJqNGlua2tpenBobkNVMGtPTjBzY2UwNU1FU2tDWldjbTNoTlV2K08wRk1pV3N0a1RYc3B6TnEweHN0N3BHMkRSVlhqTlgwc2pDM0Zxb2swdjJvVWk0NitsVDJ2M1VKWmh0Q3VkMmhWblpPYVZYOWJjczRVbFovOC85dDVzU1ZKY1c2Q0U2cno5L3o5NEh2cit4akZMOWMybzhFaGN2a2NOakd1WlZXVUFHbkRZMnBOQVpNdDU5YVJqcTFQUEVvNHNFWUdEUVZ4aHhIcU9SRFp4MDlQbjZoejM2citPUlo2cThqVHd5Tis3T0cxN3lRYkpzZEtJS2tQdkhrVDZiSTFDTTAvZ2xXQ2ZhMVUxSXJkU3ZjMytyNjYyZ1VIdDhKZXFUbFZ1VFNhWFVqcGZ1MTlaMlJ4aGFLTG5FTDN2SnlYakNBYmJLTTcyUi9VU2EwK05SZGYzUHkzeHJtOXIzZWFIN3k3MHVSMEMwdjVXQzllaXJidzJORFJOTXRJeWV1Zmk1VHNpK2NoV0RRR2dvaVc1dmJtNkxDUE1GTGhzYjVmaFphbGVaWVE2bjlIcUxYZ3l0Ym83VW9jQjVwRFZqVmE0cXd5cUl0WGRsUE5PSWVOUFJURmMwMmNqM2M5bHMwOHFDOTFZZG1oNzJUMlhab1QvN2JWeE96RVk0UmNHeS9MRlZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUk4VXZjZStDeVBkbjF1bnJXcjh1dTJtU3RHZmpuNzkrTGpiWGlRZTlpTmFmQ1drMmc1aFkvK0VSd1BlRkcvS2lTOGkzYXEyRWpicVZFKzVIV1czVXZqV2VBbzh2MVdBYlhXL0lMNEdKSS9tWmtCVTJwRFc5eGRxOS9xNDlEMkhPWlVQUUpMRUtzdGxrcFdGb3NPL1VGMVVZSWl3WXdZcFZYL0k3ZGlLNGExNnI2ZS9JNmw2UjJOS1Q5dlVpQmcvUzNSSFQxU01hZlNNc3E4ajBySTB0WXQ3KzdyaFdVZWgvMzhQeEhDK1R0TmxpbTN4T2hSYW5icTVZc3VjZmRnRHVqalMxdFRCU3JBY0duS2N0blkrcDRkUVp5S2NiSlNUL0VtMWhjbHI1Z2JpL0ZFRkdLOEVpaTRodGRSYnhsRWZrZSsxdWM4OG5XaTdpWnRacnlYTmpiRXYyeDJXUjRYYVlsQ01rS29kV25OQWd5U1l2c0lBTDRJRHI1MmxvbVVpL3I3VWxsNitQUkdiTzZibWFnOUNxUmxzSGVldHdySjBXdDBubGExM1FSMnBENnFNdEY2anZuWGFKUCtWWHRTRjlZcmR2Nk02bFRKTmxhUHN1SnAxaitWcFBPNldOL3h2dlFaTXFUTmVrK0w4RzJ0WEs5YU43UVNlbHhNRnZiZHZhN2Q3SnM3cVlrMWxZajllRjZ6bk8yZUVqbjRPeXJUeU9pVVRMdGFlV3pybW0yZklZTGpDUzRHaGszWXJ1ZEJlSGRGUzFkcWQxV0Q4dkxpUGIxZ1hNeTZvZnJFKzVGcjlnQ3VFUjl1NTQybmJaSHVLN1pLRmpqY1dPdUowK0pnaHFHZGlrOUZ5ZmFqdlpNUWFUdFNGdXd3YmhBZkRGMUFPZ2JBSUI1L09oWXJEd0FuQng4UWdDQWs0S0NCZ0FBQUFBQUFBQUFBQUM0T0NUN0FhNEdveFlBQUFBQUFPRCsvQklYcm50eDRwZUFNaStoYTZ1WlpsYyswaGFXc2I2VVdxOHNVdStYem5GWlR2NytsYllZWW1UL3BYN294ZEdFRCtCcXJNSXFHUStWNitocUg1SExNMm9GbmJjR3RjNUxzanhBQkc4Vm94MVlsWDJaUlU1SHJyaHpxdUVVWFhMSVcyM0tpbFVBQklxelV2QklIeUlTMnF6R051SzgrS3U0UnJjamZjRHU5SzVzbDhuMzNKTE1TdWZac2RHeUdxU1Y0SXFjZzdaRTRjM0g2SWlmRzdtVTIrMGVNWWplUHZPTGRGS2oxakxOa1JPRHg1SDVub2kzaU8xaXRHVWh4WFZMc2krQXkxSTJkcVg2QWt4NmJMM3ExMHZ3djNLK20vMnZMOGZVY2R1NmJTT3d2ZjBkS2xGRDZobGVnSjJ4L010TUNMRnRhMFJvSFUwRjl1UStlOE9IeUxsb1piVHlvTkFqVkZubnppc1hpVVcwK01ack01cS9rdHFKSkQzZ2drUW5OVVpva215bXVYVVExZjFaVHBHV1BQS0lEb2lSVm1BRVZoSnRaTitaK3EyVzExSlFxMU0rMDdiRWFneVY0cHlUNHMzVXdZeDVUcTN5cDkzblZUbStLUFd0TWVUMTBjdEZEZE5NWjh6ekZiVDlxM0lvb1o3cnVOYUxkNlhob2VYTVBPbDFUczBkZ1ZLZlVodVd4dXpSSkh0UGFlREd3YVh3Qm85VURpRS9qS3duSHExdmxWMkRuWG5uOENGQ201eXlaZ3VpWGhQQWNGb0d5d3N0N0EvT2FmUWdqZHVNZitWRkdkS3hXMUNNYmN0aDFKeGE2Q0thRW83T2FheUJ2bHJuVFc2REZqQzFZZ1JmZkRFVjRNNWdCQUhnN0tDbjRJWWcxaFBoNGdJQUFBQUFBQUFBQUFBQUFBQWNCSk4xQUpEbkNNMkJ0Z0lBQUlEcEhPaHc0T3NBd0puNDlmVi9hZEd0azczdUcxMFB6RnJOeUh1aFhTdTNMZDlDNUZ5aWZaL3F0cXlOeC80UVdCUXZWQTcrSmJxQ3c3SndUZUcwU0dLODNYNURVL3BWWStMcWdTZTBjUjRaVzFkajJyck1ramtlbVpPS0dtUUFpeDVmWTVCTnRJWlFYV2JtYXArbklydlVVRVJYYUw0TlBBTE5wZjA0YnRsK3JYSW5MU2JQSy84WXNzNk50dzJuSnJvaUl5SHJOOGJxY20vYmk3QWRUU3ExWEd3dmtaVlpLbmR4eXQ2VTNqQW9lcHU5Tml5M0tueWJXM3k2S0NnRDJCQ0pqK3F3SWRxV3B4b3pZMHJhdnl5SU1WeVBINWxkOVlQMUYxUmZmNFJzUXpWd2Y4YmJ1cng5S2ZYaks2MU92T2QrT1hYYnQwYzJWZ0hZbWEwb090TWpLcDVZOTRRTHZkUERYdDJlNFMyMTk2cS8zWmJLZUgxRy9ZakxxWlFqRXRKUjU4NUR1c2hXYkcwRlNsTDViZHVSR0gxZFlnNG1YQnh0VW1OVTVLQlpnVXc3clgxNjI5WWdpZzZlN0xrc1NydVJzbHJiTGRiUDI1OU4zR1h3TEpMR2lGbU5xRndIa29aYUlQSUtGRDZDampvZ1dOK3JxNGE0S01jdFkxSFRPcW5oVFp6VzQ5b3FtMFViR3pjMVRDTWNyV2pTcUZUL2JxbjJmWW56a2o4dDdjUEJrUmhBcWhxUk5QVmNFbVhxa1pTTlhiS2F4RG9YYlgrMGp4WkxCekNNYUZ6VTZ0cDUrMkVxZTgxcFpEd2Q3V0JST3BYeXNiVnJ0eXJ0YjNQREFKZkJDdnVGWWtzOW4xSmhpYjgyWHFQUjNnaTMrSlpFbkx0V2h4bStHT0c3WjMxMjZ6eThQaU9wWGF2ODZja0dYVnI5d01Ybmk2a0Fkd1JqQ0FCWEE3MEZBQUFBQUFBQUFCMlFXZ0FBQUFBQUFJQm5jV1FrVEJRT0FBQUFBQUFBQUFEL2x5WDZ6Ly8rdDZpTHFDMS85Ly82bitVVXRMN3hmT1FiL3oxcngxMEtiOUU0bGwwWVQybzVHNEJySXE3eHFjaTZ1U3IraGNtc2JCVnFhRXZ2TW9qZXFobm9KZGlibG9XQkIzUjFwcllPSmJ0a253VytEUWlvb2xTdHlQaXpleU5EUDR0ckR6NEg3YmdFWXYxTjY5Sm1MT2wzR21iY2dzZTdrNUhrMGVxVW53R0thd2lSOUUzMlVtdHVWN1M4V1VoWmdiOW81YTJDeUJBTTRBZ1ZPV1BjQXB5Tjh2Ty81VzBGK3pyTzJoNjNHMXRVWjA0Y0s4NGdxbk85YTJWbnlvejRnSmdEVG9vM0hDMjdGUTIxclRhdHRqUERKVHZFdEhQSWNNWXBEVlROaGlNY0t1OUJqV1dKQ1Y5MlVHbGs3QzJjbkY2Qkh2bVp2N3FkWHUxbm5ac2x1Q01zMHA0Y29hR3RlK0hKbEhhK0l4UHQwWE5ZZ20xbXlxK2ZWY1FncHZoTmZaWHI5U0kyZmFwamFVa2V0OHBrMjR6V3I5dXd6cVczejRrY09WeXJQbjlpMTBVK3ZxMzdOYUlhNG1CdmZ2VHQ0Slo2bm5ReCtsN21zYWZMTjlvYVIwYnhFaXlMcXdmVGFIa3VKNXRnUjRCdlFWUkhaajBDODVsZFJkYTgvQlVpQjd2VHFqc05RVlo5T1dGZXBwWG9lUFVlMDZyTFNjY2VRL1ErUTVxc0hacVJRWnBsQzI5UFFFZnl4VlFBQURnMStIQUFBQUFBQUFEd0JJaC9BY2JBV0FJSW9rd2VNb1lBcnMrZTR4aWRBUUFBQUx1QjR3RndXUmkrQUFCUWcyMkFXNEFnQXdCODhldEhJVzdmWWozaEs3Mlp4VnpxY3RMYWNKbVZrWHBYQ1lpZWM3VE1hYWgvOEFoNXlWd3NzQVVkNEtSRUZ3NHB3b29qbnBqZjZVdXBKYmp2RDJ1d1hFaFBSNDJlVjkrcWt6WEVBQmFhUDNJUzI2aTVOcmRiUWNkZEhxOHFwNVVwUXBzQVc3UUhwNjBWR0JmL1dJYnN5cmlTV0QvQ0ZGckxXOVpFVjNGRkw1eWFzRS9xOExqYkhBMlE2cko3SVNYVnJPUHdSaWFHaTE1SzdaYUUvY3VNekNsdEY2K2d0WTk0RUFLMHhFdTlJVW5wYUR2YkY4QlplSXVqV2o0RllwUVQweldidG90aC9MVDRydXdSSDBSakZvQ2Q2Um1hMlZCN05jcjNEa04zamtmWXR3YkxYMmxLQTFXeW9mZGl0T3JubHR4VExWeVpHTjc2c2tMTDNCMmNnSWlXM0piMUprZVdwVzFBUkNkV1BHdmdXUm9yK3gwVjBNaVRWaG9aVFN3TnR1ZzF0bjduTENLS0ozdTh0ZDRmc3JNYVhxYktLeDlvdTJ6TExjdm5sMDg5dVE3ZXYyM0FvZmFodGQyam9MVnI3SjFEcEwzdDluWmZ0TjBURzU0UnczTFFBNlNsUHU3VlhkOVA0ZXR3ZWY5M1daVHRWNzFYM0J4OWVIWFQxdGVYVXoyeEdNeE1MZXIxRmJVNkxlNWhYZGM3RjRCcHRBaHV4S3ovNGNTbTRPNzBSQW5aUGhhbEw4MnJXS3NHcEdkeGZ1eE5kV3hWM0NmdmErRUEwL0Ywb0NEUEg2Njg0cnVwb2MzU1R6VDZpMFl3akxsdldzTXhNTWxtZHJKekdwbTJzK1VSQVlOdkhjZ1hVd0VBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFvdkRXR2dBOG5GOGZlN2FyUVIyNGJFL3J1bTdaY2pPUWJFdkxvalNuSS9MS3Q3YWkxaFZ1M0ZYNGM0MWFyaTNBQ2ZrUTU3SlpmUElrOW1nbTllL2Y3cysySSs2STZ1dkk4Wlo3MEd2TUFUUU9sSzN0dUkwc29scVMyN2VoWlZraWRBTUkvSmcwYlZXNTEvWUpZOWNlTTN3TFhrcXlaZnlqRHc1SGNpZTkyOWthOWo4bVA5K2FVNGs0SEh2QytPd21xaG96N2FYS1pQUnoxVURaWTlsV2VEU1dYMVdDKzJlRmk1bjhEV0lPaDZINUd4RS9wQ3I2VTM2QVFKZVBQNXp5Wnh4RURHdzRLZDUzdGJhMHhtd3o4Rlk4WDZyalZobnRPRk1hRDZIMVJvK1luS3ZyV1FKZGt1Y3lrajM2ZUNRWmdabXRSVVk0YlZITkxOV3hzTTR0ODEyWFNGa3JtZFp6Zlo1a0JZN3lKSkp0Tit2cnFxTG1hS2dQclBSTWRraWYyN0hrdEVWeGUzTHZlVllQTkJhamhuZWluVG8rN2hablRiUTBsYmgrYndaVXE5YkYxZGdqRHVvZHZRQ0hnK0Nla2hsZTZPajVsSit2bkM1eDNtd2hzZ2RuWjFTb0hUdzhjMGc4S2JMdHhzc2RSajgvQzkyTTh1VkhSdGlQdmQzRlAvWkxIRHhuZStoTlFKdFgzNk92N09lcjYrRFRDa1l2cmZpbEVYZ0JXYm9VZGM3VHloVnkzZUdrMUNMNkk4NnZ4R3RSY3YxQ0l6OXRGYWVURTFMLy9uci9sdWFmNHpuSUVhS2QzOHFnd2FuUkJrbDAvbnRabXVWVEdyZXRybzRXbjFvNlFEdCtDcUlSVjhSaEJyZ29hN0RNbzhSZEM2WVo4NWVoRGowMTl4STYwTVpGeHVHSVBzM2Q2clRzNEdmZGxjanRiVzF6MjVhRm1JZGNZL1cxOCtkMncyeFdaWjhYTHkzTEhMbnNUYTBBZEROcXRyUEJBTDN5dE5tWFJUUDEvcFMxeW5sdGhmcGlyZ3B1ekJvOGZyVWgwSm9UWlVvRDNtZ0p5clFIT3JKQzR0WExKRnRhZlFBRU84RE1wSXJVMXF5YmttMjdWVnN1d1hxUk5xSjRnMFNidlpQSzlKekxHUjdRR1gwT2Q1M1ZxQjhtVVlyVnllK3ZPdGFraHZhQVpTdWF0OU03WnJSWmFLbXZlbjl2M3plaHgxR1UvQWpKRDVIcWFjZXk1YW9oOFBNeWFsM3NGVXN2KzNPRktZM29wZmFtZGdCT1FmU0JKTGdFTGZxcDFhTWI2dmxzN2RIR2hmK3hSK3U0dmdDbTAvcjhoaE9xakhoRVpIWEtNYllNckllanJoWVdueHh2N3IwbkhsaVV0cEg5UmhJMzQ5ZFBRVWtUSFRDSXNsMjJuR0x2ejRxOFFPRFYxYll2aXplaEFtTjRqVXZMOCtDYXcwWDRFT2ZOQTBnbE9MOVVuT05YWS9ocGU5N2JDTFNJNVNBL0FoNUFqKzNybE1sYWIvWFE0eitlQXUxQzRCUENKTTRnUXBra1hYYUlYSktXckNXeHkrV1lJY2QxTHVWMllwQWRHNlh4V0lZOUx2SkR4ck9XRTJ4NVRITlVmaks2M3l4Ym5PUFZEdFEzSElFMU9UdXkzZFl5QUVNWUpkamI5aUxVayswTlRkVGxVMkZDbVh2ODMwSUx3Q1dSeHBUMGdNWnIvNTF5RWJQT215bU5oekVqS0lzYXUyeHcxcE5qZTRGZ04xQTZqNC9zYTQ4Mlc3dzFyUTFwZjhReVJZbldYWlcrTTIxRUdKR0pPZXM1V05mcmlrb2trY0I2YzZ5RTMvKzFxcnBVSVN0Ym1sYzNZeXg2ZUM4NHd3OHpobHh2bTk0ODJ5b2NVdFN6MWxUVXhaa3B2V2VZMHVoSk5SaTNCZUFZUnNaRk05d3NTTkdpbjQ2WWNpNVZBdXV0N3JjN3NxNStYNGdhbkpLUzNLNFBCeDQ2R0pXMktzSGpXalQ0bURFb3ZaZHp4WEQ0WXB3aDB3SU9pWnZ4NjYzU2lSUFZtb0xNdHRGYnYvVWNicEh6WDRObDBBWnpZVUlKYnNTSE9HOWVUdDBHbjU2SXQ2N2NmeWFxV0x4dldMYzhGZTFGR3RweHIwMzBFOHpnUU5sYWc4ZEw4UGdsZy9kdDhFMEdFQ2J6TVdZVW1hdDlnQkh4WXl1UklYSXJFemxDRjZ4Q20zQW9MYmRVdTQwdGJ1UXRtWkZUd1E1ZmlsbTZ2MVdGaW8rZktURzRHbk5iQTVwNEVCcUlwRFBxK1VBdmZaSHRHN0dGdzRnSXRrZnZjLzg3RFFEM0M2blZIMWZPK1FLTTRxVWFpclBmeTBYVWRZOWlSQ2hUWHcrbU5CNUtOQm54Mm5mVURZNzBQU3ZmVHU3Z0JKeForS0pXNDRXbWVXdExGTEZNVWp2Uy9zaTFXNTA2ZXc2RTZEbnMrZlJhdEh6THJFWjJaalRTOXVReEl5WEF4S2V3eTk5eWEvUWFldmU1Wll4RXlRU1NHSWN2SkRWbWxSc3Bsa0V4VHo4TDlmMmNWZGxzLy93N1FmUmFwelNPc0lwUmJiVTQ1UUF1elpHREVMclo0L2ExZXBsdisrcmNyMkp2VnR3Uk9Cc2pCbGx2U0Rvck45VFE5WXlJNWJSSW9WUUpsZ01USzE3SVpIdnFPak55L2RsNEFUNzU5YllWY0FhZVNDM0VQVzFjbXNpRklHZ0JBQWp4Y25yV2FsdmlFcXIxRVJFSW5JYVREZ3B4enJJNlZwVGpBSTlIeTNCWjVaZEZ0VDB6elZJbVByeTBiWStDL1FjRjc4WFUyNkQ5c095elo1SEFRT3Q3Smpncmw2RUV5NmhqY0xYckFkeUYyOW9qdUQ1MXN0RENFK1FTcUR1WWozeUgwVS8wZ1ZwZVNBVzRIbDRjbUhsd0pOcVh0cDB0ajI5d1VUTEp0OUd4ZGtZSW8yVTlYd0RiZUZHeUdtbzBVcklwcXBHMXB6T3RaTDdYbDBia3FjOWVpQWpmbVRtVGNtTEs5NXQ3QUZFL29sZE5XMnJZb1NVdUxobi9LRkVzbW4vV1lOUUJBUFJ4WkRqbzJZWlZLN3dHOXB1TkFleklTY0lqS2VLZWNWcGV1OW1YK2k1Tk5oZUluZ3JUR1pwMDE4OU12VUkvdjlRakErK0M1MDhzd3ZFWnlpd2poRkw1MzlYeHgyTTlWQm0xU0ROditKMForUW8vd0EyNHFuaXZ6bmEybmRSMThCNk1iNWtqOVo3a2VGUzBBdE5vOFRjR2QrbnQzMjdmU3VTbEg1eDk2UVpBNE9OcjZRRzUrY2oxQ0RJNVd2eDZ4clgxbU01bHlhem9ONklNbko3c014eTNzSlhXODNMWkpGUzlyK2ZDZUhaYU8yL0dva3ZXNTlzZWwrWXBSdHhtRmNWdi9rcjVWcFhYckEvbnZYRmVGbG4ra0RHb3NFVElxNk50dDQ1VEM4UVhkbVB3NUZPTDMvV0t5WXEwZjFseVg4OXVSV256bHJrV0FBZk5uNHpZeXBGcHVvZ1BPOUszTFV2Yk9mVEFBeW9Qb3RXNWl3NnEzdGc3SW93STYwMkllamRTdWF3Z2ovU2tySm15ekRtdTFiK1J5V2V2clpKb2V4YWV3enpqM0x5MnJNakF5OTYrOXZWNkFKbjczSmlZK3RsZEJ4S1Ywdnh6dkJqWkJPbXR2cUtjNCtxY2swanQxVVh1Z2NUYVdNODdyNTQyYnM0ZUU0VmFQS3pGNUhYZGdlcHVEZXkzdEVtTmxpT1BuRVBHcmVyVlZwbTBSOVRTR1JvbmZDNk1TamdNellXQlU2UHBwOW01bGJkMk55NmE2RXF0ZG4xRURRNmhkV0FrbjgvNDhlMFcvVFMyNDFnYU1sYVVaeDJYOHMwYWRjUnl1M0VaOVo4SCs5bFBKSE9wdDR6T1lsbHdpNytKQmpIQ0JkTmZURlVxdFBBU3Byc3BwTnNJWU5aaWxFRmxNdVVBNEpuY1ZKZDR5Y1BzendtWHY2dEJobnR6NHZHZGlUbHY0ZklRWk1Nay9pVGN0aStuTmpGUk5yVndxVGpiMFdNQVQrVjJ0ckUxRzMva2MzSFJZOURNalBETG0yVDZ3WWovTWpZc0JIRW0zQUJVSkJ4S3JVZWplalg0Wk9OTWV6UmpnR2dQMmpJVzRjbGNJUzNYa3l1TlRqM1Bkam5STXc5aDJpUmNvUHpvdnJYakl3WkxhNTRERXZSb25WR3pVOWwySWkvSzlTYjdJNUNJZ0luczRuaXRUbWRIeWpkalM2VkZMZ2JaL3ZRelFabStsTGNWaWxQdEtXQng0RmEwQ2pTRDRIS00wdUZkT2o4U2lpQmJBTzlzMTh1UmQrL09yUjg1NzAxbUszNDBmTEtyL1JIYTROWU1JS0FJNUJkVEp5UlpzdTg4ZXVXRGl3cDhsTEhTT1Y1NnRFY29vNm1rM1lQM1RJYzlGeGx5YUVaclMvUmFjei9nSkxUNFhzM2lHOUZYQnlINXFLdHhmRmtTUHlkeWtiTkxEM3B0V3dhNU9HVUJUa2JFL05iVUswUFYvUFA5Nys5TitXamJwMFJiQ212RUQ4S1BmRFQxVjNrK1ZvY3JRdm1Ec0ZhVDI1WjVuRGlQeU9oY1hrbGVIMCt1RjJHL3h1cHMzNFpXdWIxcWpvVnhLbUtGU2Rtd3FQY1NyOVdHMkU0MHNlb3RzZXJ0eXh5SFI2TDVWUzEyS0RwMmJtdVA0THBzSjZaV1lWdkNFM2poZU92OGVyYSt4ZHVpUkFCZ0lxWGpwYlJjSkUwWGRmRWt2TnluVkQ2eW5ZMHBNNnF4cnBPWjBwRGFSRzNkaU9nTnpaUmJsckZDTXNwWnRRWkxYVzUwMzQ5aHBQWVlJVXk5R2l0NkRoSGh5cDVMUFlQbUlWbUZWa3NWclJPNXoxRW5mWEhLUldpdHEza05tUVJRTnZvZUtkZk9lWmFxblBZem8xMWJsVXBMbzFxYjBTY2tJMk92aFlneDZQbTlOMkNXelovbGFIcHROL1o5eEpSR2FUeTJKV1BodkdPUlN4dHRFK0F3cEtEWU12bHdHbWFZbzk1eldMVkNRbDU2clJJOTVmdmYrdGtmenh2eHlnRU1KZXJjZUJNcnlnRFd3ZzdMUTYrYnl2bzRWczVVRzJlUEhXOHpmZmFISWtYNUk5T3dWdGFnVjQ0Zlk0YzZnckJmTFpVZ2oyZHpEc01hMFMwakNOa0JBQWZYd0k5dzVrNnNpeVRIeWpxK0xCZFRyU004T0lBTUp3c0FIekVFWHRlY3NRNGoyTXJTdDJ5dFh2bGxPWlg4bGVBK2dDdENublVnZStaWVp0NDBCT0l3b3BlZVd3Umd3eGlCNmZUR0xKSGtZUFM1NVE0K3d2NzZXZStXTmhtQUFJOWh4SEF2Zy9kSEgyeU1Ib01MTWpxb21pRWdvL0x1MVFPLzRuN29aS1QyNkhsVkpsT21wWDcwZDdZSWwvZDRyS2JCbWFRYXowT3VKMktqd0poeXlhallzL2dSSTUrN1NvaEc2OC8zTlA4WllJUUF3TkdjSVVmaHBhMWZPejg4ZU1XbFI3ZkNVN0dtZlBaSzR4QUJCQ0E1UEp5UzNQYjJSOHNoNi92d2E1bElWRGxLNVN5bHV3VEtlLzFJK3pOdFJjdGY0aUhPVVpNYkpiRWZiSGdKR0c3SWo4NThyWGkwR3FKZUxXTDViOFg3aUgxMkxjdnc3MjU1c21KSjFvbGtndEZQTUpJZEhhN1YyWlpXaHFxUHYvNTkxZjI5eFBxODNMRHhsdU5xQWQxeGYrckFUeGcwNm1xSTMzKzhIbVRXRXRrekhuUW1PVkZoQmRDdiszckdsK2tneEtyc2k5eldHVG1WUzlQczFDL3hIRXZ2c29CV1h5RFNta09NME51bVduK3pRL3JpZUJFck9XMm1Ud0xnSFMyMVlLVWN2SFNFOTBDYkIrSUxwMEo3Q2tFclY1WDVHUy9WZ0NtVlRkRGlwN2RRVGVtajNqL0RKdGJuQTNCbkltbDNyVTUwVyt2THNxSFdneHdqeHViSUtRMkEzZkFHejZJY2Y1WHhCSHc3d1NEVnord3ZpYmJyT3JkTmloNlJDR250YzQ4b0pXSU5KS1FFbGRkSDloeTJmWGt6ZU5vclRTTWl3c2cxaUxRWlBlZG8rNUd5MnUrSy9NNFJub1IxVG92VGZ2MjMxTGZUUnVoMmZvL1BuOG1udFJKdjUvY1dKMUFTNjBuWHpCcFRYdllrY3creWhpUjYvS0prOCswWjV6V2E0OS91OTlyY2xvdW9URSswNnQxMURtR0pZM1dWdWNTUmZyTDFzNWFncnRjaS9kNm9qRm9yS1RhNzZXaUVJNG5FSjMvdzlCVENlU2w2bzZLVU9kTHN6NnJYM2ZheEtOc0F1OUFiVXE3VlljZmhDTGh1emFjVWlVeTJkY3Z5UUZYdktjZldjQXFHNFF5MVZCVGMydmZqTVM3MjFCZFRvN3pHOFZFM3JPNzdzWUhjeUlqYTJ3OEFJS0VwNUp1aDJieUgvSHlBR0xWZklnVitPdytTU096SnVBVXdxQU0vS1JDTUdzTURCaHZqR3lESDdYSXJsaE52YmZmT0dJeWdOQjZEVXpEeUZrMi8zVWNtZU9GV0hDRktxRU00akcweVFYdm12dkY1N0QvUFNLK0JjblhiYjEwV3ZlMVpNQjRCL25LVVRWd0QrMGIxdFJmb0ZwaE9HVlFtVWk2YWl4ZzVhWEdiUk04UjJ1Q0tHc2g3UlNaVHB6N2Ura0RTM1JNT1QwbXFYT2gzM3U1MmtMVDdvUFhaZzRnNnl6NVVrTFg5MmJMRzNHc2QvM3N2Q2tWUFlWYjhjRlpKbm5sZVBJY0NBSHN4U3Rlc014b0Z1REF0dzRCcDl3dmd2UjNKRFJ4T3kyT2tqS1g5K1BmRjFFbHZ3V1JXN1ZtZDdlekNLOWxjUVZtRy92UTAyZlBlaFpiWHlyZGxjQ2o3c1phcTRCckRSZm41b3RsU2lYRDlBRllKaVBncGxhZE4vVE8xL1pHZjlQUHpNNy9mcy9tZTdxL3Jlb1laWUNRNzI3N2E3RVpPUWZOcEx6MDBwQXRSSDF1ZDR3QXZoRUZTVDNoK1BRaTl2dStxcTU5SnRHN3JxbXUybm16TnJiRkMwR2pkVytJNThSRnU0UlRBVEJYb2ljYnFWVFQ4c0ordjR1MGhmOGc0QklpdTBpdUp0U1R5a3RocGJmK2oxRUYwWVJndHhpTHljdXF5TkFtcTFGejBsS3o5VGROR0wzc2sxR1VNd3QzUTdKQzJiUTE3NjlXZ290U0pVSUo5U3VvcDZyc0dYRldYeUpSR2NlcEo1NExlZ1dIMEdFZXByWWhBZTJ3SExJWjJCMW92OHA0YXlkUE1uaUI3dEFqdUd0eTJIR1d0Zjh0NlpzclhkYjFISFRQYmtUYXk1eUJkczBpNUVkbmdUQnRTM2NqdjB1cHIxYXA2a1dCaysrWFV4ZGp2UHFnUmZRcXkvbnU3N1VWbFM3SWNORFBqVW5waVBjdVBhSFhFRzdDMGRvL1Z5VnJOcUt2bW5ZczBEK3lOMWlocnNNeklQZ0Zjb3VZcG12aUFYZGtyREZ3REp6SHFQRm9qRllCZEtNSGpsZUN1cTE4dEsrdGUxTnZqWnFMYW9SZHBUcVBIVGtUbHVXVXNTVzE0UEgxcy9Hb09QaE84aEdhUGk1M3BKMm9INnUzTTcyaWQvRHNGeGRuTzFJVTU3QlZCQUV6Z1RYeGI5YzBGNVYreWlRLzYrUUI1RVBUajJkT1poL3NqR2NIcUlhbjF0Zjlnb3ZGZkNlNERlRHFuSGhmU2dCZjBVMWNPcmVWcGlSSFBzOEZ0OENhTGl1R3Z0WW9LSWdaSG80azFvUW1jZ3A0WmVFbTR0N2EvMSsrb3V5dkNhVGEyV1pMNzYvTm9yUXR3UmE1bXJ5eTdhNlZ6WHR0MW5jVTRuajJ2a2ZYUU9kQk5ORFp2RWJZWmdpdWRMdzcxWUdaRjNTTTFsaWRjUFU5QldXMnZnWFlpTDdCNmxnajY0SHFHV0VkZUkrOWhMKzdIcWREVTFVaGIzMW91VWlkcGJscXRUMlJLQXdBQTltRnYvU3ZtaGNyZll5blBwaWZ2RG5BeHZMR3E1VitQSEI2M0hwcU5MeGlINjhPaDhZSm1qOGlJak9QWHoxL1NuVzE4NlUwYWQ5a2JwazFnYWFlelBSNmFBRGVPZVgyTllPQXpCZk9KTGgybDFVWFI2b3hJWG5HTjRjSjhpVy90TVIrdG9IZkFDaGlLVWI1RUd2UWFiUTNlTlJ1Z0haZjZCc2h3NEhpUHpObGt4VHN5cmE3MWRRbzg1NVd4RGhHcWg2ekxabnV0WC82cXVJa0xjQzFhSDdDSFM3TTZ4NHF6dld6MmFWK2tPeld2akdPbHI3NkladjJqc3dkRjJaYkthc2VsY3BsenFkdGdESWNaa2M2WjBsbTE3K05McWRuN2pFekFDYkRTRVpFY1NsM210OUFPd0s1SWZzWUx5USt4SEM0RjZlTSsybVR2dG14cDBQdXYrblhkRmhlbjhlY0NuSkpWMlk0KzJ4S2hkdkc4T1hTcFhyMWZhK09mNWRPMlNtcnF6S0JUSHNLUk43cW43MVlqNkpYVERLM2toOVJ0UnZlZmxtaFNaUS8yMUphOWZXV0VLbklPV25JdGkzUS9MVUhXaUE2cWFQbHRuZDRCcTlXUkp2bzFvbTFMaWNtSUoxR1UvVnFiMHJaMVB0dTJNNzliYTdZK0IrRmMxTlZ6aENTYnhQcnhSOTJRVWNsN09pU0tkUDBnUk9hMlpkcHNlWGFtMVk4UTZ2M2toTDA2eTJmZFNCY2pwalNrOGxtaWw3bytiMjIvVjg3YUY5R2dGcTBhTktPVkFZWVJIVHdJM3lYeGRHQkdyMFZEVUt1TlRKOEFoNUIxSkJLKzN0dmNqZENNbDM5ZWpicFdQYXZPWThlajU4dEw1YUdMckcvclhYTE5IdlhZS2Zqa1Z5cjNjM0hxbE9lUlArOVVsN1lrdDN2YWhqWnFqWWYyZ3lzUzFRZVdncjZRVHJFY29XTHNCNER6MFdKMld5WUxBRzdQeThaWFFkbWFuYVhjR2NZcHdJT1Fra1phWnJMZWpqN0VFc201ZUgxSzVRRUVFQTJBdnpDSkNtbXlzNURSaDdLOFBtby9KTktuZHc2Wk5nYmhUVDFHY3FQWU1ZRHpjNlZ4aWs1NUNGZDlBR1NHRVpUZVZMRDhqT2diRVpkeG9NODA2dmMrbDVhbm9VYmRZRXZZTWs2cVZLNXVtMml1SCs4NmNvM2g1clNxeXQ0eWsrdTVpMDRsVmVqSUtRMU5zNE9NZHF1d2lBRFFTMVJQWjQvWFdGUHV6WlNxUFpRZzNKeTlNZ3BIdjFkMWFwaThPb3pvcGRjeVR0NzdHOGg5QTRaQi83Vk1ZSWFkTDRPT1c4TGtuWGZMN3pyNU05YjJTWG1URGxvZFJtaWNuZ2RidHZzQVRrakxGTk4yUWNseVUvbU9CTnRwVlNycGgvcFkzWGp2OVoyWmRBZlFrSnkzRGpuVGhrN0VQQmZqRkc0bitveGxHTWxhRFdQRnR5M1ZjYzh2eUQ3U01vSWordHdWVFVrU0R6NkNGbGZ2MHZaUW05bXZuZmRVVUxPcG16bVBsajZ0OWw1dHdSUzhTenZpRnF4cjIvRWl4WDJXRXd1d0ExYjZJdHRHVFhTOG9Sb2hSQ1NCTjdJdjYrWFVaVm1pUzErLzRxYVo3NlcyakNFcDdQTnlvOXV5QUZjbWF2dGF3d2FycmhlYVJQdmN1cFhENWpRUzRMckNyY2pPY1dTZDNFVW9IL0V6R0dRSDQ2MTIxdXFCalVncTlaUVpMVnoxMDE0UldqM0xZdXp6TExIV3AxWk9PNjd0NjBFNnQ0Z24wWE51RVRtZXBZZ0M5OS85dE9TcmlmSlo3NjBQcGZ6MkFaaWZjOUU4cTNXSmVWNGV2ZldQYXZ0bVJHeDhTMkNkTVExV0h5MHExZWxpeEpUR0NMenBUVy8valBNdndmM1N1VVJpc2N4K2dHYTBRUkpOZUNDVXR5YnE2VzNOajJZMDFvU3NJRjV3T0Y3WTE5djhwajF2YkVUOGlpM2VJekxTZHRZRTNJNVdXd2hoUnM4YnZ0a2RaZi9hMkllVllibTlTQ2dYNlo4RkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDREFsQyttdnZBV1pZcVU4K3EzdkpXOGZSdlpXbUVvc2o1ZDNmWjJYM0hxakZqOE1rMTlrcXRScHVXMWJXMlJRUGdYYjdGRWJ6VXlTNmdBVHNMSFNpdXZ4U0JYdWR4V3B0TmZTWjJtTE9jUlVhbmFhalZOUHplNzlJYTNUT0FJc0JFZ0VSSDh3YXRNZVdJZVdkRk5XeFhLRzcrblVGK2VyMmY5Y0FBSlI2YmVWbkpiNUJpc0dIWE1jc3NZTXVQNHRrTWh1dlJ1Y2VxaUt5NUZKUHh2V1hudWNuZzVrNGo4MTJVWFo3KzJmRjVaL0RIbE9UT1ptOENZRFRGckhCU2pVdjMxOFBxRERPb0hHeVMwaE9VRlkydTRKcDR2MTVPS0tNNysyWDRrM0lUSUpFL1V4bXNCaGRYdm1qdGU1MWMxbStIbFhLV2ZIYWI4cmZmMlIvbjd6eVA4U0lBS2JWaG4wL1hXcXR0ZVdlOGNzblBzbVhJamNxTGVYTHZYRjhCd1JnaFoxaG5OSHJlZS9ZajZHZDUydEw1VjU5TE0wRFl0Z3FCNWJkc2IwbklEUEFHd25yQ1MyckhhOG9oOHYwWHJZMUcyVzh0bnlqUmxneFRxMzlzVE5WdmxNOS81OE1aQU5JQmFsTDZzcEtqWDl5cHZGa1BCYllPbk9zQ0s0Q2JtaEtCczFmcVprUzJKRUpHeFZUa09LcDZxc3V4blQvdldmSVBYaGpKVTFGTXNtNktyUFhyckxoYXRUWVhJWmRKK2ZoVHZjbVR3TEo5Mys2WGpMZG9WWUNpdDVnZGh2VFJSWFZoN0U1S3BxOHYrSXgxY0ZqV1gvWlBycnV5VDZjb0FIRVdISTdFTktkUm43cGU0dUdmR3IzZnNzVU9zVm16Yi9kQ0ZGY0o0OWJibEk3Rkh0QzF2ZTFHMnQyVzFjbmNYR2I2WUNnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWhwbjR4MVh1clYxb2xRNnZidWxCVTlHM2tuamVRSTR0S2Jmc3BTOThLQkYxa1Z1VXV5djRJMDM3QXhkRUVlUFlDZHdCN1VxK2VwNnpVN3lyb0VRdVNIa2pMeXQ4MVlkdG5MVlRxbllDbTI0dFR2dlc0ZHd5Z3huSVlKM1FSMmE4ZGEzR3pEaVdycUFBOExKOTJyUTV2dGtzUjNPUEtmNUNhN0NHekd0V3B4dTBlUkgrd1ZRNWJmM2xHTDlLdEhadU90NlJkWFU2cjIzTHlMUTZHNTV0UDhvWEF4d3Qvc3ZVeUJZc2pTNkhWNHRmdmRySnlTYjRLSnBGTlJienF0QnozMHJHSTlVM1JiTDVXN2xWVyszcEppNVBUb2tPREUwY2ZQMC83TUZDVmoxVlhtMWUybTA2NXNrOWFmNVpaa3NvdkMrTVZ6azhrMXpCUzdxM1Z4RWVrNTZQeitMWEszUDRiV1VVODB2OWluSXRYSG1BWUk0VnNWbnlmR2Z5YW92SnlLRnA1YlR1aUhLY3krbUpuMnJLMFo3WXQ3encwemJ3bzVZS09wN20vOXVwVzUzZ1U2enBGeml2Q2pBRzRSK0l1bXJTUGxwZktqZklrdFBLWmh3Mmlub1RTWm1qaWFkMlVGZHJYdnFTcUJWdWhJQ3d5b3l5Vml5YTdvM2pqZWZzdnBKR0dVdGFFYk90b3R6L1Nmb3NxMkd3WDdkeldjVk1hVWUwVkhUMUxSN21NMUh1V3o5TjQyaWd1UWowdkJ0UGFYcHh5QUI5RUV2RmJzc0pvbFlYaGpKNVhpU0NKaEhUTFA5eW1SZWJEclRKY09tVVQ0SHdZUW1wRjJHYTRFT3hLOGpQZ205cmhrdjVlQXZ1bDlrQWtHamUwaEZiWnpGbnJuRVkyZFhvWkdpYXBUdlhGVk1ZZkFBQUFBQUFBQUFBQUFBQmtZWDRCQUFEZ1g3Q0pBQUFBUjRBRnZpWGFpa0FBQUFKb0NnQUFBQUFBZUNMcmYvNzN2NkdYM24vOXo5S050RUxRZHR1cnN5MjM1NXY2eVRYWHpvbTFoSkxIcFg3b1JmQldDcXJMQWR5QThsQjUxbGFWNnJvYzBjVXdMY01iSldvRHNCVmdJZmtoM2hLTk84aFNpem0yaGxKa29iOVRESkdJenZEb1ZtUndDNEt5Skk0TklTYVpLVkplN05tekJyVzJmVHNZODdkbWhnazR0Y2lNak1talBubUxrcGp0dzBPYVhwMi9qWXVsWjlveWNmTzY2bTF2bTliczhGTmpkRGlHckxobHhsaFdWZDRpMXcrZlJPMXd2YjgrbGdrY05Ib0UyRHVYWU96VUs4L2U0cmVST293cGVCSlpGOStxRThrMXJNNTJhOStMY2R6N2dzYXk5SDFoSS9JN0FXRER6UG5CcUQ4RkNXWW1lS0lPcGRaMnBLeFZ0eWZ6UG9wTUgxY1g2RkVEdWo3ZUUzMGY2ZmxuNVRqcVdRWGEwNzZJdWlxeXBTWHUzdjlRK3ZhVXZzY2U0eERTZU1ONTVueUNKZmJiUGpOekhZMmlGUjNGVWUwZUtSdWxSN3YxYXN6SWRkRnVJNjRiRENNcVpKcDdBYWNrbWxPYTRlR3QzZ0dsczQvNTBPV3ovSXJjd1ZueGRLV1hjRlYyai9SOVd2TFBqeDF5clE4VVdtMDhsRXpvc2l4dDJRelB4dlh5dU1nOG9DeE85Y1ZVQUFBQUFBQzRDQVRLTUJoRUNnQUFIZy9HRUFBQUFBQUFBQUFBNE9HUUpBUzRPb3hpdUFVSU1nQUFBQUFFK2JYc3lQWkYyZTFMNGR2dHVteW16UllpYi9SblhtUS9MWmtnb2Y2QmwvN2hKeVd6bEJmQVJYa3QramhpUmFLdnI3bThOYjVjQm1tUmxOb0dSdXFZQmR3S3k5elBrMlRLd1ROWmpYMEh5czRvSDY4TUtyTWJQVXNHTFlHNjhCenFsUWtWMjc5S1FaY1NBSzZiZGthaXVTTVJrNmtOR1cvN3NqQytIMEZ0K3lJMlVSdStVcm5UMEpwc3NwSkZWdGxNbnlOOUlTMlBBOFBKTGdqOXNUL3cwWVRvaHhVaU1iY1hld0xNWm5ZcTRsVTJZb2U4Y2NzWXVSRFdKRTVOSkdjVzZVZHF5ek1LRVlGdTlDTzBqL09vNXhha3h3WEtIZ2U0SXBreDBxcCtJaXFrT0hWNjZrbmJ4U2lyMVl1R0pwbmZDUUFiSXM2czVSKzFUR3A0aXVDMHlhRXowS3JSOXNqVVpXNnNWeWRpTGFSeTN2WVdTWURYUkY4amhkT3p2R2RvdThWcmw1NmNxNzJCWXJUUjRnVkZmMjlHVHFQbDZ0L2xCVmxHVXhhcmRWMmkxN0IxekkyVSsyaWZEOEZ5WmlOaWJaWEpxa3BybUM1SzI5cTJKMm9aMWFMbE5ZSk5SZDBPN1RMMDRGbmhSZGh2N2V2cGUxSDZYaExIdmR2SXFJWVBTbkE3cWpNUXNsUFFxcCtpZW50YnRpNnZtYW0xbXU4c3l2WlArZGQrWkFxdVFJdkJOZlJtQ2ZoWkdwbElUWXVTcE8xSDRJV0xPRnBwcEVzVXlVQVZaYjlVcjljbjE0all4QlkvL3ZRRUxpaGZUQVVBZ0V1QWJ3WUFBUEFNc1BrQUFBQUFBQUFBQU8yUVd3RUFBTmlUcDFsZVBBMEFBQUFBQUlBblFqUUlBQnE3ZkRIVmVrRy9kLzB1N2FYeTdPSk0wcHZSMlVWZGVoaloxalJPZlhJWGhXc0tONko4L1BHOTZheGlGR3I3d21NbHN4Q2hXNmZuT21oTGluaExqUURNd2xzbEw3Tk1VMmZYM2ltOTlta3I2VmgrWEt1dnVpdldaeENzT3VnSnFQZ1FKV05RckJzWktwdjlYdHVqeEM1aUVyMCtMeEhEMVdTVldPUTRYSkxWMlI5MUR6TXIxazNEU2pwNXlTWnZDYnVJVFpUcWJkdldISThJMldVQ1lUb2Y4cTNjWHpFKzNwU3B2NUM2R2t1NmwwMDVxZTFvdkx5S0p3Z3dEc3ZOcU10b05xSjN0VzZwblQxeSt6QUk2OFo1ZGJUY1FsM09heVB6RVJ0dlFxbEZ1RmFuejJxL09wYnFWZVMxY2tLWlJTbnI3UWU0TTlFY1llUjRkQXhGUXBXV3V0dmowYmwzcjUwZWVuNG5BR3lRakgxclBzS2IxTkNPRzNIdFI3MW92cVlsbDZLUzFTb3pJNFpzUXJZbkdlVDFrWDFTSytHc2lnNTJwQStyVG11aVR0dmZjMzhqRTJtUmNwbTJlK1hSKzN5TDVjVkV6MkhFNysxTmdyWmMrK3p2K3U2ai9oSnEvWEJNdmYvbm1ESWJYVGIzWVBYMFZqWnd6dFRwN2ZNaGpIVEtOWFVielVXODJvZ000NXFvV2RLMmE5dS9mcDdTSWxTSmRCMzVLZEc2MnMvNDdSeVB0TDBJZFVkNEVKSGZWdC8yYUM0MEVnOHk0aUZFaTF1S2NGME9MMHoweW0vcjFIOXJkWXBqTEx3UUZPQVVSSE1xMWE0UmZvU0dOYlMwS1NyUDM3ZzlVWWRxNW8yN09kbDA1T0xzcjl1eTVIcGJMa0kwU24raTY4TVhVd0VBQUo0T1VUa0F0SUR1QUFBQUFCZ0wvaFVBQUFEQTVjR2xBd0FBQUlBeDRGa0NYQlZHTHdBQUFBQUFQSWxkdnBpNkpiSm1ubFF1dTdCSzlHMWs2N2kzUU1ISUY5dW52U1R2WFFqcDFXemUyTitQeUlLRUFDZm5ZOUhIOVgxL3ZkM3o1ZFFyWUswS282MW00NjV5azEzYXptdERXdjVqZXpLTGNSeWdCV241Rjg4aG15aDcybXFYa1NHazdidjB4RUptT2F2V2xWYmhuamlyK1VvMmY5M0lVRWFNUm9sY3k3anRqVkVQcGY3QkxYRkd4dCtBeStFdDdOZHl1MDh0S3BFZkdMVjEwUlhNdFhxWnBTaFhvejRNUTdyazdzcUxtU1NqNG5OSk1YVVJaTEE0WFhqbEVCbVlSVVNWZW5JNk9oVVI4Zk1ZRXpzU3RiK2F6dFI4Mm0xYlhoOVpaOGV5eXhvWkd5MzlodSsvSXpHTE5yYlVVNmdPRktkTmIxcEphaVB5ODZPWEV1QnNTT3BKS2hNSkk2eTJJL3UxZmRiKytyZzN6ZERTaGtaUCtCTFZTd0NQb2lVWFVROG15OCtxeXkvRzhjVXB2eGoxczhwa0NGRk40bW11RVltWkdSazVxZTJvWUVqN0xWYWpQZTI0MVdmTE9WbkpNMnRTOHZleUh5UHZxMGJXU3JaNEVhUFB1K2ZCaGlqUkFGR3J0eTI2S3JyeUZWd3BFMk5HaysvSndMcStWMWtpazVDV3hsa2tBb1JoYUdMZEVtVFg1YUpsbDZYUFJHaHpHZzFFTldWa1NrZXI4NnJuV1YvdDNLeSt0RzFQNjdSWUJtMmF5SEwxNm5wYnRITmsxTU0wRUs1VDB1SWRlc2VqeHo3TVRKSDMvNVN2bmo5YVY3Mzkxb2dFWUJoUll5ODRLQjgyZXBYL2ZsV3ZuOE5mMTl5cFJkekoxbFRRN2NoZWlJRis4OU5wbVVkWnFtTzE3eDY5blRQblR5NkpvVFQ0WWlvQUFBQUFBQURBa3lEUkJRQndidERUY0FNUVl3QUFBQUFBQUlEWkVIMVBoMHNNQUFtT1ZCbW9Ld0FBQUFBQU9JcjFQLy83MzlEaU83LytaMGxqclJEMGNTSkwyeXBBbVRyTDRxOWFaTlZwN2ZNVVpCWUxiSG1kSFByZzJzSU55WHdSOVd1aHlhSnZYNW1zYlV2OTdKblh5Rm9hQjJBR0UyUXJ1Z0pONzlyVTVvcHV5d25JTHVmRE9BZVA3T0NTTjBYU3RyQ1JUQng0YXhqdnR5ZTdzSFdyN2JOV285NU56Q0w1alpyV1phbWpDaTNiZHJZUEdFcEdqdXVQSTN3YzBQb283MFdieEtNNnFlanF2d0I3MFNOekVidWtyZjR2bFJ0MVhyQWhNOEdTZFVUcXNpMXpHcG0rTlBhdzlRSnZQNnN4TjVvOXBjZ2xIZ0d1RFZ5Rm5yQWdxaExyNHhrMTVmVTVpck9GUndDUW9EY1gwVkkzNDNobkhRNHYvM3dhUmovdE5FSnI5bnAzdlJmZnNvcXZiZS9ycFd1aXpTdlJtcEhOdERtNi9BeG1CR2s5ZU43Y0MrYzh0TThUV1EvRGZHeFhYYTMxZ1NWNWJsY2VMeWRseGhBNllrNGpxNDR5ZVJ6cGVPRHdqRXM2azE3dDFES3FtK2NWbERaYnI5TmRyREpNSkNvWUNOUHR5ZWJRUWcwdWk2a010eTdaaDlzbE5BV3dPeTNKNEtwdVZuNTdVMFlOcnQ3OXlmcndrTVlMV1VhRVIzdmVucnVMd3FtK21NcTRBd0FBQUFBQWVEYkVoVHZDeFFZQUFBQUFPQ1c0NmdBQUFBQUFBQytJa0FBQUFBQ2dIN3hLQUFDQU9meGFCbEE2eTdRWStsRXJKTDNlZW82c0YzamtXbkhkYkYvdnp2N0FTLy93azhHMWhCdndzVERqYTMrSGZOZDFyL0MxVkcrRjh4RnR1bDk3bUVseHRnRThvaXRwN3BEeGlhNlFreEg3cmY5WXUxbUhKN0d5MTNiSGV3RTNwZnBpMjRzajR6eVBTSGgwZVRTRmhFMS9OQ1c1WFIvTGpPdXBvaWFkVE12QWJqbkptVzF2MFphZGhGMXBUWlc5WWxwMVJkN052OW5ibkltWEVTR1l6ZWpWUkNOMktkb25ZYzRFcElzZlVXU1ptNUgxWVdma3IvYXk5VXBUYTcyanNSMXB2elVQTnRObVlJL2dySXlVemV5WWFobUR2ZU4yeHB4R0ZQUUF3RTRjTWRneWZmYWUzMm1kL0Y2Tm5EMCtvbzlzL1padnNmUm00T3NiTGozZDFjc1JRblZrRU5OYWZnWjdLbytXUGxxRHNpb3BLQ1h5dklkanRGTTVSUGVkVnZFZXl3eVJQR0pPWTRUWWF3OU5TTWVYNVVPazl0UkdualMzU1B0b2E3c0V6cUhYcW5ySDY5dWxuY3NNcXd3M3hYSXJMZjJFY04yS0ZwMmg2dVdBSWl4U1dXUUt6b1FueHdGbm9OVGxxbEJFcWRaRWl4L3hDSG92S25ySkpTcDd2WDNzOGN6QkUyNzNrQmRUTmFKZm1vN3NueG1JZXI3dW5oTnpVNGsrN1hhYkh3d0FSMUxuMm11SDl3b3ZuNDVBVXFsUmRUeTBVNi96UFEwdjNKOGUrUm5vaDh4eWFiWlQ2ZDdMcWFkd3F3aGk0U2dNMjNLR0dNeXp4NWNPaXlTRnROMXZRVHdJQXBwSUhZSjFNcDc4YXNkbnlyM1g1NkljZjVWaExCNUNXQ1NDQmQ5ZVNsMkZKcllUU0VsV1pjZFRZbTQ0RHU4NXMyWHhWVjFQS29Jd1oyZXNCemk4U1I3dnhrdDl0VHozL3FxYktTLzFiZFdaRUx4RUx1MG8xK1YxYWFOaFFZOWR3Z3pCRmFubHQ4Vk85WTRCN1J6MkhJOGo1alI2YkR3QURNTHlYU0pKMFJldENtaElnUHMwTXBxN3ZzalpHMXN6d3ZKSWZiYWNreFZ0cnNFK1JsdmtuanJSdGtaYys5SDNieG5ZWHJidm1kZitBRS9GZWxGMVc2YWM1ZjdETkNUMXZTelhtTlBRam0vVTlKY1lMOHJ4d0xuMnhqOWF2ZEdYNmRWWGJUMUh4blBSYzlodVIvcUtsaE51cjlvV3dCdlIzSzgzWUMzaGd6UlJ6M3ltdVZtakJSbzZFOTBvU1VuS213RG53aks4VnJpY2JMN0ZYeUhpK0VhN2lEWFl1alN0MFhydm5NYm9XM0dyMjJvTi9DcDFOUFhGMUcyZjJjQnZwTktLOUxFMjFEODlyU2YrZUl2UkFkY09RRVY3UWZXSnBGVkZ5MU5tMldQb0x4aEoxcXUzdGp1WUlkYmVkSGhSeXAwSzlBQzAwbUdQTXJteFdhNUNOUDZUeWwrT0hvV0VMcmdGSTgzclJGUGR4Z3o1bnZtanZEN1hSQjBZanVUTHJWNkZMY0hNK0haQ2RQb0xvOGdQN0VRazdJc2VIK0gvRWVZTVJGS0d0ZjF0Y2FnMUhib0d5bWI3eXA1TFR4K2RRbWJabjk0dXkrQzZNK3NCbkpFV2w3MTNETXlNNWJMSEkyV3h2d0FuNW93UDZHVHJQKzZKeHg3TlBGTHJSL3FPUm5FaklzZkkwMXoxT1pYcTMyelVPVEpnMkt2K3FEWWtNaE8vSTVpZDlOM2h0MlFUZ092MnJiN1diTXFaWlFoK0dLVyt6ekNuSWN6VmxHaWJpaGp2TVpjVlRmRkhueVdlOGN4eGFTalRtdS9SNm1sVGNSbUwybXFGNGVHRUp1c2d5NTdSZ3RWMlpBNjJ5UlAzbEJzeUJWZEJDbXUxN1VaNm1pVmErTWJ6YlNOcER2U1NpT2MvN2pHbk1mcTVoWHBZWCs2MmwvaXhvUyttcnNsakxRcXE5YVZ5RCsxWmkwd2JwOEk2YVMxbjJMTU1Bc1N1MHg1THl3Qk1SbjJKWktDMTdGNE1jZ2QyY1E3T3FEUFFWeEJsRFI0dmpjYzdUcVhWNWJIOFRldDVXb0NuRUluVnZPZlo5M2dwVmV0YjQ3S21MeHIzd2EySjJqeHQ0bDBidjRmVHVxenIyZnVDWFpIc2tiZG9nbnFicXdKU085RTRkNjNhR2hFTzRxUENMR2JMbG1hZmxzQisxSE1qbnJOdUhlOGhZbS8zdXRFSEtNM1dTNW1aNDQ2VUcxMFg0T3pzcWNaYTJsc210YmxNYUJzQUxraFVjZlU2RWlXeFA5SWVCTEdlWnZYS1c3UUVCTjRzblZmZW95ZElhUkdxSzFuOUl3S2xNMFlRR1M5b2xUZExjRlk1OG1WVXJZNjJuYWExdmhWMHczVDJudE1ZTlVTemZYWCt6cGthcGpYdjN0TDJIbytDaldoTHVyMmpVNEp3QTJZOCs0V1FYWWJzN2UySklpS2QxWE94Yjlzb01EZ3pWc2dTOUtlTy9HQVVRNnNCTGxxSU0yUVllbS9WeS93OHdSenQ4c1hVSThuRzB2V052eVNSSEZya3dsejJBZ0RBcnRTWk02OTRDUlM5b1A1QlpRSTRhRm4xYVBrVFlMbFA2QUM0SlY0azNERnB1UGVZNmVtVDhRMVhaVVFpNnpWMnJGVENybVBFTzVsdHVaRjk5aHp2YlIrbU1kSWVGZXZBbWh1UFdaR0wvQWJFREdZU3NSV3RSQ2RtRHJkUGQ2SytvZHJ4TGJNZDdiMGRrUnNJejhqTHhGZ0NPT1pCZ1pGOUpxZHdBT0FwWko0Y0h0bEh4cmZ6OGo0b05vUHNqV3RKZ05YV1NucFN0Z2ZwUmtzV3N1WHhQazJJamhDdUl6d05PSTRqWnNpaWFFKzh3eTVjY1U0am8yNEhNVE1OaE1UL2kyZVZ1RTR3RFlUcmtyVHFaZWs5alNFaUlMa3laM2EvQUFhU2ZUUVhKdEQ3L0JJMzdZY3orT2pFQ1htR3ZKanFyZUt6S01kYjJ0WnkwVjVBWkMwZUlKVzMycDd4TzRlUnlSRnBGMEs3b1JBbmVnMjUxbkFEV296djdEem9HY2pZcFhTanJTc3VTTnRaMEZmUVFzYnhHb2czblJ4ZG1WSnI4N1REUVZOQXJjNDQ0LzdaMUc4WjFNZjBUWk9YYU8wcFhvOFg1eU11T2h6R3FteTM1RUZYWTN2M2wxSmYvMm9UU2EwSnFwbXgrVWk3RE1QNUVxR3k4UWUvNzVlYWY2eVBCOThLM1lydFc5OUtlWUF6WXFXZFBidlRZNGN5YzNVSGhaNzNJekt2OENMalJOUzAxSTNPYVhnM1hEcHV0WDJRNEhodVJNLzBRMnZLME11MU1NYmdDdFJ5bTZsVFU0ZmFJOGRDWkl5UEhITTljKzFleUFVQUY4VExzYlFvUGkrUW1PcFlSQjNKUFJqaHZJN3EyeXUzQ09XbEYwR2xUSXJuelVhdFIxSDYzUExQOTcrL0YzdFNZd1Rlb1BES2EyVkczT2ZSRHlwWjFqN2Faa1RlUndkajNwT0dGdVc5NzJJZDMyNi9OcXR0OGJORjFlOTYxYW5McW0xVmZkZUp5NUNNV2tHM1JRbVdnMjZ1TUtkaHFmcmc4QjJsK1NJYVJhcTM3WHVtVkVkL1gvUzhJNy9YMFZhaDgvQmNOdzgweFVNb3pyWmt2clF5ZFgyRTZOYW9IcUNqdUt3UDFHL2RvamRScStaM0VTM1lqWXlMWG0vWGlXY056ZWl2ZHBjUkg4SHpxN3dzeHUzeDd1K2lITmV3L091SEU3M1U5YkhpYkM5S3V4a2k0ZE9Nc08xVWZGL2NxVjlNUGRQNGVBbVRkVDZ0YWNMTENjdnRmaEFBSEVLcjBydzRVY2U4eFNFSHVCV3RqdGVKOEJKUzBVa05nTnR3WW9HM3htdjlHRXJMb3dnQThKZGR4azd0UjR6S0RoNFJ3MlF5bzNBSVg1T1RPd2kyTnpjUEFERXNFd0U3b1RuWVVybVJmV2FPdDg2QlBDVFE3M0ZISHBvU0JqZ0ZtYkJvOUh4NFNXNERBSmkwK21wZHl1Wk1Yc3dvNTNWRTMxNjUxVGkyUGE2OW5DclIrb1JtNUttdkszUG4zN2JsS2I5VDRXZW9IQkY4M24wTTNaUWo1elFpb25LQ1FLQTFOdkV1N1o0dnJnS0FBSVB1Rk14UTh5VllRSDJQcnpndklqbXlnMmpCS1RuQVRTY3lHTUJvWDUwYm9yTG5uSVpXem5vQk5YUHI3bnliaDc2WUtyMmtFM21nZndtVTExNEFHbkVqSC9WU1FYWjJFZ0JBNFVkZnIvTCtSVHQrYzRXcjJhc1VhbVM5NUR2M3ZLazFlUHd4aGhLR3NIM3I2MEEvby9ZclcxOG90MzdHS2YzSXFBTWVPWEhHL3JNSmp0OFBuNkRvNWJKbXFCZEpIYWtyTHk0M0VIbnJoN1g0RVhBSnRJZVRJMlJ2KzI0dnBiNytiVjJ5enJzUUxmTCtxT1RSODNpOW5GcWNlQ2dyQXRhcXZSOWxuVDVITDdnSmtHVXJnMUxJa1puNGFVMUZXQ1ppVzVkeGtNQ0xIN1h5dFlOdGxlMGxZdk5IM3ZTZGhDZ2p2eU5US3dlbWFRQU9SMU41V2c1UnEvOHFJNFhhM2lzNFVadG45YjNkYnNsbkFnQTBNVXFwdFBoMnA4eGJqamlwbVQvTWMycTlHeG81cHpYWnA5ZEhSTWc4S3gwVlZHM21NSHNPVnVLOTVmNWFiYlZNNm5uUmRhYXQxdklsc0M5VGQwdjI5MFd5YU42RWlpSWpyVW5BYlhudHk2bGVRNnV5MzZyVERCN21OSzR3cDJHZFE2L1pPUUdSbUN4cVBXZW1xNHF5N1oxVHBwOGwySGFVckpXR201SVJWb1RsbG93eVN5Lzk5SS9nZnZGU0tweU9sakRKTWZJL1k2bHlPTFpoeHVJMHZ5eHovUWl0VDloZ1BRc0ZoNkJsaUVaa1VGcXpXVmNiUTFPL21IbzJXbE5abDBXS2lDWHY3cllYWUdkZTF4YmpBSGVqMS9tNXFZNDU1YzlDQndGTW9aNWlycmNCYmtlcllDZnJ6VFJaMWlNdGo0c0w0Zlk4TWhUTkR1VElNMGV0ZmNKOUdQMmd6dkk5R1pwWTZHRjFqbWYyQTF3WmFUejBQcmI2MkxHaXpaNUZiV01tQUo1MWtTMzlQTExQbllXbngreEViNnZVcDljbUFKd1Q3VG1Waklwa25BUEFGRWE4Y3plcjNsUkdQVkk5aTZ6ejdqMEN0eGpsdHhIY2lPU0tsOTFmbFRyYS9tMGJkM25rajRjQzJqamd1bjE5MG90N0JRRTh0WHpFbklhbVFqWHF5YXFBU1RpVGlmZmlwNHoxdVRKWUdCaU9KMVMxemtBQWI4dm82UVh4eTZuU1EzM0lGTnlNNkZoQzlDL0ExbDlHWDRuc0dTOHdmOUxQa0JkVHRVQ3NHR1ZhOXkrQnZxVDlMY0lTamF0UFRmVGxWQmpEcW15M0N2b3RoQkF1alpSNWV5Mjg2Q3dHK1ZQbFp2SWJuYmJLTEJib3F1V0lvVjJNZlptMnM4Y0JzdXhnMnp5em01azdrZXEvVkdGcUhPOEJUNkhCQ0JMeUVYMkVReUx6Zkh1RXlGekdxTDR1Ui9SSDMvTGkxSnI2dnZRK28zQ3AwRFBpWUk5a3R0RW43dDhkODNZcWcrbm5vd2RTSXdKdnQ3VW9mU25udG1iYWJqZ09FRVZMUlVobHNsYTJKTXRZNDliejlSZ1REcEg4ZGF2dDB4eVVscHVTUFllTDNIanZaM2w1U0c5K1ROdk9uQk5qQ0s2R1pRdThYTDdWUnFTZmx2STlxakJxRTZOekdsblFDd0FYSitwZlJaV0c1RFRNeXFFMFY5NUxjMlc5dk41eVBlZGkxZHYyN2MwQ2xFVi9FOG03Y1ZrTFhSYlo2cFZsVG5UYVdtZlV6RWRaNUFnNThudEhabyswZ003enBGYW5mZzh6N2wvMGVPVmgxZy9GYkwrZytyWnluZEQrbjdMU2wxTmIrZm55Nms4SEN6eU0zam1ObmdSME5DRXhRU3hiZithTHFKYXJ5NWNsSGxObUwrMTJlN3V2TEhrdkl0TzNwTW0xL1JIUVFoQjIweENXMDVIMTlIcjZpTGFoNWI5K3R1czVqYWo4QWN5Z0ovU1Myb280QVlvVGt6bVZyRHU1bzh0M1A5QlhJYTQrcDZIRkZxMFpzN055dVMrbWVrSGZ0bHl2MDNPVThFMERoWFU5dUdkd05KSkg2V1d0SGlxejBXU2VWUmZnRnBUazlvbVJwaFpMZFd4UnRnRXVTM2JXN2lSNGsyaFdHYmd6TDRFbXFCckJ0REZVRXNlT1NQQ01Odm80RWFkQjh2R3lsTVQrekdPTHEzUGNxdzh3azZQZHhhd2FaVXg4MDNzaHJCeGh0czg5a21ZWHV2RXp4NVEwbjVhOWJZd2h1Qm9YVFd1RXFGOUppVDc4N08wZjhSQWhBRnlRMFk1MFR5QThFaldvM3ZOa1JsM2NVZWNjc1k0WnE2QmQ1TzErcTg5SU5sODZwMGdiVCtEcTNvNlgrYm9yMnU4ZWthSDB1bnpxTmI4NFI4NXB0RHp2VVl1WnQzMENOQ3ZqUFNJbmxabUZwVGxHbndPYUFnQWs5cGgvbWFaVEl5OTdXU0VId01WQnZFK09sRUxoWnJrd3AzRnVocjZZcXIzRjIzUFR2VGE4ZEdoTDM2MHJjSnhhdUQwSEMrYlNJeVJvVFRnYUo3dm12WmU2WFF3U05ralg0d2o5akljR0k3SGs2QUJaODFhQmpKNVNkQ285Y253cTJTVjBHUGVnRVJUa2pJMnZtNXd0ZnBhNEh6cE9SK0U1WUxDQmkvTUhiVXpzL1JoY003MUxNbm8vUUhJS1RtMzBvWVg2OWk3VmRoRUtmM3dwdFc2Z2lKc20wY2RCdC81bmZReGdCbldjWkZuUVh0OXVqL0NRZElmQ0dpeFRFdnRuY2JPYkY3RkQzc09QM25ibUhEeHdkZURLZUsrMXVITWF3WG90NTFTeUE3ZXV0Nm43ZTdONTFIaEZWd0JBRjluOGpvZjJUTXliRG4ycTVtcTFabFpXTWZKeTZnaTB2cmFzd2YydDdVU1lFWVVXcDY5V1hsN0VQMDQvRVZvZmdzcG0wNkpsZTl1SjZnakhveXhTbjBxZEgvOXdsWjIrVjRGU0pTdzE2aTdYWldtUEhrZU5Zd2dURmZjUmN4cGVYOWtoVTRMYk8rRjFsYjNFOWM5cG9lVlNXM1cwOUoxVXIwV3pSWWxxak42OEZ0d0VTMit0Z1RwV09iZ1VVWjI2YWp0S29NN1d2ZnEvZjh0YUhRZVlqV2I4ZXRxcUNZYTltZWNZc243RVk5VjAxbmRmcXZJelVpamdrdlhwUjl5YWVtemR6aC8rL2lHWCsySnFsQm02ZTFUNUtaVEVzVk9jTUFCY0JpMDVXSXp5WUNKZUloeEx1QUo3T2xnbkl6cFBnZ3FFV3hBVjVJc0lQT0VRUUo0cHlhOVJmb1QxbkZtcHl2ZjhnR3gySFU3UFMwUm1oRjRaY2JpWm1RWFloWmFIdm00L2hyeDhYZlpKTU9tWXRyMEhLTUVtdE52YStxZzRBUHpMTEI4eWhlSE1IamxlMFJVQTBFV3JrNjg5dmFXOS9QSVdVRHhOYzJXdG1CWU10RDRzME5OMzNZYjNDczRJcG1SRlQ4d3B2QndBMk5LVFBNN09hZlNheE14Y1RkMm45L0xaR3R3V3Ftck5aelY4OW9YUXVpN2FGYUNDZ1FFVjZYQ3dxckNPYkJ6Z0FUd3QydDJGM2djLzFxb01OMGRscEZyUDNyYmUyL0trMjVwNk1iVmwxWjRzMG1wRDB2RVJ0RHpROHFxMzVYUStqSldQeGVFYVR5U3ZyaVZLQUU3T2RzVWc3VXN4OWRmU25pTGVRNTJGTlhrOG1vejEyaXdMK2dqR1V3ZE1KOFliT3RvcW1JY2krUjJSdVhxQUtKWnZXOHhOczNqUDVGMEV6dzJQOUhYcU9FL0xkbVRHOXkzaVFWS2xFdEt3SFNYUHU5cSt5RWxIL2VZWnN0NDdoc2dIbklJM1YzVnpMN1FQcGhUSHorb0p5WlFtM2ZxSUVzd2kraDZqVkRhcUludkhTT2s0ZmlzeVFXclVrRXMzcDllQjNsTmhYVUE1Yms5eGF6ZG1ubkxtdGw0b25RTmdFa2xyZUhQUlhyc1MzdGdxOVE1NTArNW45ZnZLcEE2ZGJyQzdBUENPTjVHeUtNZDcrb3F5OVl1dGwxTXZUNnRtbHdLSFNFWjlCSkcrUGFHS0hwUEs3V210anJDTXJRT3d4L3ZQQm42OUNkVTZnbHFNN1V5N2RUMnRyMFVvdTYxV1AwVFQ4YURHUjlYZzc5SVNtRlAwbm5aOTRKVE1jdHJYWUpsTWppbUxrUk96WGtvZGhmVnpMRGZFMDZBUnplT053aU90a2FldEYyYy9QSUJzQWlicXdzSnV0SGhmMmZtamFLZjFNOHZiemtxd3FkcVZROFJnR2lQQ291MjIxUGI2ZnJpbHkxRit4T1BHVkV0b0xvWGxobzhMTmlQbU5Gb3pMRXVpemJydHU5M3VmeFlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0FDcEw2WkcxeDVyWFJYRHFwTnRNMUplT3UrOTM0UnVScnZvRXRMQ2JvZWUvTTNRbGpxWDRMckR4VmlGbGFjK3hMdjhITnB1cW0yVm00K0Q1cDluTFdVZU5iU1p6a2NaWEhnV0oxaWl4VnBZMDF0eDBsdTEwaXEzQ245YjV6SU55ZStRamkwTDR4akdVUHhkR2ROUmo1VVo2NisvK3RuK0t3MFpyZTRwOGZSdlJDSGRRaWRjZmEyd09XdWVSVXpEeUQ2NkcxbXF4dFpFcDFhZGpOeGJOblBXR01JdVQrTVZZNjZPd0V0K1k5MUdXTmlEOTNOR0xqRjdxZ0N0WlB5cXFCeG1VeEhlNHVnei9jcERpZGdsejM1RzJvN3MxL280bTROOUlnSEllSHhIckQ2TjNZRGJzcDJuV08wcHUrSzBZYTB1NzRVTFdmK3ZaZDQ3bStQTW1vYklPWlZvZ2F1SDhRRHdseEYrWkkzbjFIczZKS01jbzg5dlROVmJ2VE5KM3ROTVdnUmxSWEhaSHh3dEgwbm9lVE1OUFRlajlUci8wMWwvUzAvbUppb3JMWjdFaUhQcEhmaDFHMUVQSzNvZW1mTFNBM1VXMWZIaXliRkVVYzZoYnFNdXIvUmRQNGpqSlVsRDU2V05SNXk3MDJHSjNBaFZadlZoaWExM0x0cVE4N1lEak5hTTlYTWlsbFdWNnZ6aGQ3RFBqS1Z2dmIzYTZMYXNkYll2VHp2RFEvQmN2KzAraE9NeXRPZ2VTeWNVN2NDbTRvK0xVeFg3TFZSZWxjN1c3ODRLTWdkWEpPaEhGZWY0Q0ozYjRrZEk5VzlIUmpuVzZScHBQL3dRamU1Yk1paWFmeTA5RzdIZHp2QTB2NWd2cGdJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQWlOUVhVMTlvaXhObFZ1MnA4ZFlRaTY0b0czbUQyRnRyYlZzdWN3NjdvQzB6VUJOWnd0NjdLUkJEV3NqUFcrYUI2dzVuSmFESVZiWHpXa1g4dFZwUjNmVEY1ZDVUdDVwYWpxNnkxM1F5bWNaSEw2d0tZREZSanRaRXQ2M21ON01LNU9vY0gwNTB2R2ZyQUNUa3BPVXI2SHVObFNsMjkweTBMUGtGSjZKM3piT3krZityeFhYemQxMnlIU3VsTUl6b2x5b2laVWFlcEdmMDRYU3N3WThGZk8zNytFTnVJL3p4ZzllbUZnY3ZuMFR6a2g2SUk4ekc4cXVpS3RGYk9YZXB0cldWU0tYMmJqMEdyQi9leXNpbHpGRkFKak5XdWRYR2lGYXVwdldiUGRaeEFKSDNZR1dmTG8wK28xT3AybzRpR0xDaVZ2NHA4djZINDZ0cTliWExGeG4vNnBkMHFyNjlPWTJmYWkzM2RhZjdEd0FuSlpxazhqNnBNZElmMWZyYVZWOTVKNTc5dGtneHlrWm5yS01YTTJzTVZxY05xNDgxMktkMlBIT3VQZGtZciszZndYSmVQeTE5UjlwcnJic3VkbGJBODhCR0JxZGEzejF0OTBaR1h2MW9PMUlianFjWS9sS3FKa3VyMFRlY2xwSEJ1dmVnckRXOEkwRlhDYlExWXNnNDlHaitGN1VXOUVhSzVuNUU4alhhZVdRdFhQVFNSbjZ2VmRicUE0M3lNRnBOYWlTV1FLaDJKNk92b3FpMzBabHpyWjlSRHZYbHhKNGZjODFLY1lCcHpIZ1J5NXQwVlhhWFFKbHNsOUU1cnRzaDNWZHNXNHBvU0JLVjQ0d2QwN0pVbVZzVUhiWjN1ZTE4TVJVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFqUjlNVlY3eXpqN0JTdnJiZVRNb2t2YjQxSi82OUsyQ3RESTFUMkc0YTNnMlBJcU43UWhDWmttNkZ4cnVBaHZZcjB1bjErV1dZMVZpaW81cjc5RWM4VXZwbG9yM0dWWGZ2dEErc3pIS214YmpVWk9BajBFTThuSW9MUS8yb2JUZFhaRnloRjlMTld4WmRscG1HVVd4Szdyb0FkQUlpcm9tMFAxeW9OSGl0WnR4ZHJ6QlNLckVrZFdFNzBjM29XNU8vTHZIcEZiS2M3eEtZendJNWJBY2FtTTlZUFhKUmJ2YTJCMzV4TmNtbENLUVV2MXh5dnU5ZUxWank0RzJrSk41QUQyUnJPeW1jVmN0M1VrMVJtcEo1MUxaa3hjZWd4NTlpZ3lxUkc5YUZhNU5YaE9FQ0xqd1hvMm9TVTh5RUlxRVVKb2dxbmx2RWYwRmZEMTNzclg1N01zL1Y4L2tINWZmY3hyUWltbm5VdEVEYTlPVzE0NFZCOG9tak53SkJGbG1HMHIyczdJdmdHZWdqVlhVUUxsb3c4SFdRNkxsOTl4Y2dwejhUUzBSbytINWwza3pFWFAzdUFsMEthMUhhbGZGanRvV2pabHBiYWpmVWU5K2doUjY3OG81YzVLaTV4YTE5MGI2RXV5amtjdHg5SGdXanNIelh0YmpTRlQ3WHc1a0Q5TkZubS81dlNLL2NObGFiR0IyVFk5bFdpcExZa1cyNStOU1RidGZlWDhqYUtSUytoMXN3YktTSDJsWXpTQjFyeE5qMmJVemtIYjN1Nlh6dUZRTnd5T1EzTng2bVBiNDU0UXdXNjBSQk9TcnBEYWkrcW5uejZFQ3F2UytKdE5FSlJuV2UyK0FIYWpEQ3F6cFFvWGVxS25WcjhqNjlKZEZzL0o4K3FPZE5RZWlpWG5tdjhjZFN0NjNJL0lOTmFkT09VWFV6SHFjQ3NRYUFESWdNNEFnQXpvREFBQVVNQkVBQURBa1dDSEFNYkFXQUlBQUFBQWlNQ2JDZ0FBQUVlQjlRVUFBQUFBZURaTlgweDk0UzFJWXEwd0ZIMERPTHBLVVNiRnVDMTd1emVPUjZ5TTFiTTAxSk40ekZJTzhBaGVpeWYrL0U4djk2TkRuUlZWeXNjZjk2QjdCWXZJTW5GV1dhbGVTZllITUlvOWwxSUtkbTAxblYyY2FIWDZiMW1KY2hpV0xtbFpmUW1lUTJRbFNrWEExMkNjMEJ0T1JGYVNYWlR0bmpEb0ZMaU9sYkp0dFhWcXNnOExqUWk2c24yZUQrbjdCSi9ydU11Lzh4Q3hpQTdndW55MDNVaWYycGlLSkt5eVNTVHM3bndjV2FydFZhbU9iVmZTTGNINys4OTNtNyszc2ZPU3U5M2VTb3dBZTdHSFh6WENEMnpsVW1QS2Mwc2lSbDhxNjdVbDlmM3VTTWlNeUZQZEVPdFNXdnVsZHJ5MnBEcmI4bDQ1cld6azlzUE4wUVRYSzZkaENWbzJGSXQrTXViN254SW9YMzlrcXQ3dmRsWE5qWWdEZUkzMVhad3ZOVWltNEdkSFhhZytwaGo3RHgwelNwbFlkYkwzM2JKMTJUNWJ6eUhicjBYdk9RRGNoUkU1SCsxNC9ZVWNLNzhUYVhQb2VQM00zTVhyWmNwSCt2Yk9vVWQ1ZWhjeGVsT3NldHEzTDZTeWkxRTJhTGcvK2k2Ti9Wcm5FdDEvQk5ac3pleitGcUh2dXN5TXNSUk1Gb3JsclQ0RnVmNDV0RzZjUUVIbU5DZjFvK25WT2Y3YXYybHZQWk84Z1lpV3o3Rm9GZU5JZTNYNWFBelJHZzlZdzNlVi84NjZFWjYxc3NwNmRhS1dMcElhOVBxSzFNMlNuZFB3YnJOMlRoSFhUdG9QRjhZU29ySzBDeG5zUm90NWtmUnZST2RHVE9CUHZtMHhUTStLQ01GTnFIV2xZbUIvZHBmM3c5NXovOXN1ZWs3UjYrTldhQTVtNjBXMFF2R0hLN0tzcnkvdGkyYnB2RGdoRWg1NTAvcDEyNTdvblAzMm4vS0xxUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBejNzS2w5Y25BQUFBQUFDZ2dqQUJBRTZJL2NWVTVlM3FXWXNkWmNpdU5KUnBvMmJFQ2tMVDBWNm50bDc5OW82RFRHUVJ4RXNJRFR5YVdsNjNxM08vVmhCYWw4OEZFcmNyQjIzS2JiZXZMUGFSVmRaYVY2UW9XbUZwOVpyb2tsQWo2RjNlQnA1RnhBWmFkU1lnckJzYktydFU5WHI2M1pXZUg4aFlmeVlEZ3JPZkp1cFYxSlJ5VmhzUk1yR2N0TkxVOXJoVTU1UjQ5eWt6amk5bDJ6M1BhVVpXNGNnTXJiWittbFl1ZDY3dllySW15dnFMVHJzaTVTMEJKM1cyT1B2cll5VllSNnEvT09ka1VmdnNWcmxvbTlCRzhOcldxMzF1VndPVlZzemRWdnI2UUVIZDBQTDVwVlNORVdJUUdaY0FQZlNxenBIbjhMdmF6dmlYaHhOSklrbGxyZU9SQytCTmpOVG41QzBuUHZJaVAxUmhhZm82NjI1RXZob1JkYk04VzlMczg4RytqQXFMTWtsdmoxNTlsNkg2L2ZXWFJsZGhUa003djVlUFYvdUpSZW5yNHh5S2NGcmJzb2w3OVBHbDFNcG4vZW5ubFlOWjM3c3B5M3U5cGJ4Zm15SzA0U21IankvSExvdStJL3VRUUxhOHBxQzBldEx4N0hha3pjV3BNOUpSQW9BMkJ5dGpnM3JtWUZQalBwdFVxanNaWlZnakUzcVpvQ1RUbjdVLzRxVktkU1BlckplQWZIM0Q0ZmRpNHhtUkZ1TmhDWEtFVElUUXk2cnNpeGpzN0t4UVpJYXAxZUJtSFE1cjNIcFJWdFR4MkZidC9IM3F6eXZWOWxLZFYrVklTdWUwYW82a2R4SXdqSjdobkRVL1ViWmlvYzNoU01PNk9HMXR0NzIrcFRiWFdOV005Vm1TWlRWckZkVW9xN0ovWkovZU9iUVEwYktSdnFNZUJOd1FLY2VTY2JNd1E0Y3p3dnVNNmhEUDYxeGYvNnR6WmtYT3E3Mk9XeUJpY0NxY1VPUkh2Q3Y1THNKK3pXWEx1bVpaWCtmMmVPa05VWEVaMjlvK2NDTlVyMTQyY3lIVnNXNk5GaTU1S2MvTDNlN3ZIOGdYVXdFQUFNN0lucDRGVGl2Y0NNUVpBQUNlRHJZUW9JLzE0dzhBQUFBQXVEcTRkZ0FBQUFDandMTUNBRGdqYUdlNEZRZzBEQWFSQW5pSE1RRUFvMW4vODcvL0RiM3MrK3QvL3Y0ZGZVdlhXd2lwQmUrdCttaDVyWTBSNTloRjlGWG55RkpEcC9oQk42WkZ3RnRlc1FmWWcrZ3FVOFczQVZjbWNobWlkc2k5SGhFZEVtMFUzUUo3b3cyV0djNmYwM1hHQldwMXMrcjl1N0xETllXYjQ2M0NGU2tYTHlJMlB5TU9YQlA3THoxMEdQTmdVTUpPZktTdGhvSnJZTC9WaHZmaGdwRkxxOVo5ZUhVWWUrZWlXdHkvZm5IMFk3VlBaWHZncVh6UXVxSmlaa2dobGpBTHpaL1NqdGRsWitiOFovVFZUWXY1elM0VjNLTk00SEJHM2c0dnZ4R3ByNVZIZEM1QU5KR2wxV3VwTzdKdkRTOE9DTGI1OWpQWFlCNGd1RXgydmFyOFJ4bGgvK3ZMQzNWYkh0cks5ZUk1VkgzWGZkYlg0VzhuaTB6a21rZWRWcS9OdWs3UHd3VlorOXM3RHBhQjU1QTlweEhqR2VBT2pQQ2I2N1pxdkxaM0hZTXRDYTFzMnlNU2RKS1JhRkdlMlFCSXF0ZnF0TXk4c2Q3c3hhcnNQNElSZzJwVU12ZHNVVXJVdWNtMm1YRHltaFdUY1c3clRObUh5ekpTM0QxZlBoaWJwUktYTzRwMTlqa1ZxNTFsOGEyeWRDemJkdmE0VmljenB5RWRrNDVIMmdENDRoUytPdlFTMVpVdFVaRW5DaDl1bG5EOHJhOHFid2N3alpHRzJRbDNJOFVpMFgxckpBOFZYSnlodE15TFJqTmplL3F3VnhVTHZwZ0tBQUFBQUxlRG1BMEFBQUFBQUFBQXJnNzVEUUFBQUFBQWdJZkIydzhBY0RIUVdnQndGZEJYY0NzT0ZHakdFZ0RVL01vVTl0NzR0ZDR5M3RhTkxyUXF0ZFd5S0lEVzF6S3hyMmF5cTArZGJiRzRKN0VWa0tpQWE2L1JBNXlOOHZiUEczVU92TnhJanJWaHZTeStqWmg2R1RLckFBS01KTExLWEFuV0hYZ3FML1BxZGIwbXR5TjlEeWZqWUd2K0JvQkZORWhMTkZWWDF4Z2hwaVBzOGFtSEMyUDV3b3hZOHl3NUNEOVloYjlpWXRXOFFySm5yNnhPb2tyRWlxbWxmaU8zSWpQV3NMZm5RTGl2cnJ0VTNhL2VXRFV6eWx1NjBsSjhoSHN3bTFyV05OMGZVZU9qNWRPUy84UEhRbFFwU09WbTVvSTlCeG1tMGV4UEpkcjN4cUcyLzRqeCt4aGFYZmlXOENINmVST3JudWRnWklYSy9leUFVczlxYTBDYkgzNWczVVRWVjZuT29mWW52UkRrbzUwbDRYdldmYS9pN3IvYjI3N0szMzEvdHRYZnJaekxXcDkzVnNuVU1oWEpPZFZ0UkIwUDZ6eGFpZlpSbFAyWlByVGZtLzBOYTZDUExDMzZDT0JvTWpvam04K0pCdWZSK3BtNnFVWkhFVW5JU2R1U0FwY3VWaWFxODV5QmlDUGg3Yzh5d3RsYm5EWWlEdE1vUE1OckdYT3ByWWpSbjBGMllFZG5sS1JqOWZGb3Yxbm5YWEt3NmliVzkrT2E0MWpYVzZzK1JqN1FVNnB6Z1hPUkhTb2EwVGloUHRhVGpLaUhrQ2ZucjJPWnhQMEFzYTFHcGRuZHE3eUZkN3NpNFgwckxhTGlXWk9vVmRGK2kzZTc0VUZZdWtVcko1VkZjQzVCMUdOZGxHMHRRcEYwU0hGa3BDZ25OMW9IQTN3dzBqQnIyNi9kMWFBckRZS2RQZDNIcXVlSWN4UU5JU0ZGSnR2aGxjdTJwYlVSeVJ4RmJlR2hHQmVFTDZZQ3pBYmpBQUFBQUFBQUFEdEJDQW9BQUFBQUFBQzdRUkFLQUFBQTAzbXF3NEdqQlFBQUR3ZFRDQUFBQUhBSlVsOU1mYUd1MnBxbzIzbzh5K3NONHhiL2RQUzV3TVVwRFdXaVMyUUJIRWxTSHUvMGhkUXRXMXNSc1IxTmw2Rk0zZy9RaStmVTdTaDcwdXFLOVFLWnJXM09LdCtGZE8zUkFiQVhwZXZ3SVZ4K0dEQ09iMEJMdG1IY1dtYWw2dHN6R1d1dzc1Qm8xajg3dW1UeGlGVWV2ZU1qeHhiajlEaWsreXJJMXM4Qy9jc2NSdmlmTFNCNnNCZVJEdzlFOXMvbys1VFBtdlFraTBZc3h4b0ZKVEtOcU9jMzh6YjZQbCtzUE95TTVpLzNMaE91NVpLc0pIZXZVRVFVZGV0Z3FiOVFvUGg2VFdHRk0zZ3liV2JuUjd5K3ZkM1NseHJVVS9EeU85bjRTdHYzMnI4bXkyZHA3YnRWYUViSTliYTgxMlpQSHlQT2hZZDc0YTVFZEYzR1RubEJ5elo1SUpXL0RkN25QYXl2ZzBhOTJJenk5TDR6c2FlSHZJZlhmWWJmMnpyTDJtSzBvdnRIdFRQQ1lVNTVsTXNReDZQVWYzaWYvSG9WUzl3VHZwQjZMVWJGZTlIOXIyT1p1TUJxSjdQZjYzdVN5TTY2eFBYeFZTay9RcVBPb0ZkemVsNEVHdWlCdENaSDRSTDBtb2hJL1hDSTVpbWk2bmlMaHd0d1JmYTB2N2UyOVNNbkRGRThJYnp3WWNSK2paNUhDQzQxdjJ1Y1hOT0xxVkcwSUdsazI2UExSdHJCajRVUHJIdzZ3SmxCYnI4b20zKzM4NGhidk1TZmV5bTErYUlSOXdBREJiT0l5SllteHhOc296Uy8zOUtGTjc2dG56MzhaMm1kTVo1aEpwNGduOGkzamRwanI0MVREYWxJRmh3ZGNCR095ZndWMFh1Vnl2bWt4MVRkdFdTLzFtRGozUTUyQXZ6bDZ5RHB5TEo0NHY1V1hHcXFsWXlmbUdtekpQZjM5Z213WmFSTVBTNnRFWjFSc3A2bXN2YVBDSGhoS2dGenBCS1Y4NzFzQVNMV1NPdkxveTExdFhyZURMYVc1TzUxWUNKdFdLSEs3RW5qYktKZzBldXN5a3V5V1ViLzFIVk4vc3pYUTNOYXpGWFQ4bVRnYktVbzlkbmF0L2R5V2FSdnI2d1g1MXB0Wi90b3BiYyt3SkdNQ3Z5dC9GVnJBbm9JTTVObDJUYXlGOXRTWUtNdnN1ZGdqYmhPVVVZNGU5cDViSTJEMW5mVUNkTHVRUXN6bmJxOWFIR0dQRWNpZWowOGg5bHo2aHNZK1ZJcEw2aGVrOGk4OExLMG01K01iejVhaGRSOTk4UUxDYklocU5YT2xvd1d5dll4YTA1RGF0djdYWmx6UXV1QXlPeTRHUTVsNkJ4V1VHR1BDalVCcGpESzhkZzA5LzdIT3lPbktyM3h2SlByZGwxUVJxZGlkTmJuRDk0dHZ0cTQ2SG94ZFU5NTkxSTZrVUNuOTN3UEhkOHRuYU9ROW9OckRWZWhWcWFDNTNqWEw2SmF2QzVEeTlSVlNSOUlsb21BRG9MUnRNNUx0N1RSU1U4QTdBVzkyV09wVGlPSlVzWTJaTkFDcGdiajlzY1hPQ3F3blpGc090MVFzcDRwSWRNMmdWNnBpaXJ1bnI1eWdyQXVmNzUvV2dMbFBrV3RlMUtsZHB3bGUzWEc1QXMyOWZvWUNiNlJ0N2VlYUxHT2oraGpSbmtBajVGcWU1YktueXIzVWRNZUthZlp4T2dQczJhZEdQeUhNU01tZWJYYmNpeHl2SVhIaXBoM2cxdHpZaEdYUG51amU1N0N5ajRYMy9vOGZZYm83MTl6MWVLRk9zcTNORG1qajJTYkpXdVBXaGlkbU5Yb3NiZmU4Y0M4MlZ2WkdVWkMrMTJSOTdDaXZvMkUxaWJBV1JtbFc0MGNRMVBmMXBzYUtXWkdTR1hRL3BZK3ZISTlrK3JSVEU3TGk0aUwwL1lvcEhPc2Y1Y2xaSkVKeFpHT3lSbXVXUzhqTXlHdGNsL2Z2OHoxY3JMOXBlcWpkZ3EzTDVlV1RkOWRlZ3RINHRTMHFvZ1duMzFQZGZUcVV6cUh5U0laK1JrUmQyUEVwWStFRDcyTURybTlrS3d1RTlrUER5UHE0aUVrbDJTb3FSRG1sTVdvQVptQk16UGFmM28xYTRRSm83ck8ralFNd1EyTjh5a3dEKytXdEVUMTJyWlg3NnkzL1orbGdYVjUvMEhlOXBGNGMxT1haVlgreTdZQmZhekdmcTR2WElXTkRtblJsWnE0OTZpbkk0ZytLOVQxdTdTS3ExSU9ZRzh5c25jaUdjMmM4dHB4dkM0N25UVzVIMkFBbWZocHRMbHFpZDB1YXpLeDlUdXhaMFlnMHRlNDdNa2FyUGUzaC9lK3VrUlE4MTFiRGJKVjEvT2JJL3ZYeEg0NEo2dStlMzM3bzQrVzVHOVAxNGdnSE0wNHE5VGY5Nm54bmhDTFBBMkYzYmtNSStLaDdPMzJ2RWVyN1paemVMUW9IaEVlV0xUcWhsNEhwRWNJUnVvenB5MVZ2dGRsMkllYTZyWlNiVy9LallnQ1IxemFkY1pralZiUFUxQmVlOWx6c0xaSDlWV0NmYzdTSWRLNWFucHJSUEtzcDAyQXN6QkNwMlRicnZlUGVLT2tpVUhHY0FpekZMUFhWazNHQWVzeEV0RStSckl1OXJudjRlUzFPaEZuWUtheThQcUlPbEk5S0gyclBrQjUvL2ZqaGRadEd3T2RiNWpQckZzVkRXcVd4djJXV3RiNmJqbUhBVVEwcFhkcUkwOVBjK24zREZsbUVQMWRoREFQeEJ0RVozSS9JRTJMeXMvd3BrdUNqYjljb2RIbkFuQUlqZ0FYNFVYdW5icWUwdWRwUVlrTXdRc2ZSa2JpSStUM0tiZTk2NHVwZTVCOUF6aDc3RFJrWDJFZThhT0l6c2J3NTU1eExlSEtJTDlmUko0anJNc0IzSWFaQ3g5M29xMkdOTU5aYjExNWNpajFEOGJQQUkxby9IQWgrWkhFUFJzbUFienprcW85SkdqUHZueW1uc25leXlKYTI2MzdBUVFzTzZUUkkySThSQUZQNHZMeVhSdldVWjhKWU9DZkRpOEUzOXZUMjlNdVBZSnp1ZXpqMlNPSGRJTHI5K2NCbVRNOUczOG1rNEFPZ0JUa25lRU9IREczRlUxWVQ3ZFZaeHJBSTU3cWFpblhrOGtaOFpKaVdmcVU2Wkd6SVhWZmxwTjNad2Q2RHc2OGZtclg2K1pmN3UrdG1HVWF5cUF5SXhMd1JXaFRxcVB0MTg0clNLOGxHeFgzMWFPNDV1cXVQcUVLREFNemR3bG02Y3cxMG1sV1B2WjAyUUVtY1liM3JmWjhIdmgwak1wTFBad1cyNUVOUmJMbFhtWDN5dXFjY2J6WUw2WXFSblNrVEdkU2l0WjJjZmJYZFNNUEYrdzJkcVBCZWJZT2pNVVNqUHJCSk80UG5KVUdYYkorSzgyb0lWK3JzWEtGNFNBNUhHR2ovVjM1OWJ0TE5uR3FuUURBa2RRMmIzZm42TDFMYTM2aEtIV1c1YVJEYVhYMmIzK3dOcU9Bam9BQjFHUEhHa3VhQ3BnaGlwblZxS3o5cHhvbW1YaVA4UjFFa2xpTjFsUk15NnhDYTEreWsxN1U0KzgxNWZGYnZuM2ExV2toZG5ibC9kVDhDbExaTThnNWswVHphQmt5MjNvTmRYKzZIQmg3dGo3d0VMR2RtZzhMc0JjbHVUMnJYNGxUcHI2bEFET3JKRTRRVzBPZTEyMldRdk10Mm0yZDRRSWhPZ1BKaGc4bHVGKzZTWkl3RktNTmIxdHJ0KzVEb3l5KzRGcnZJMGgvMTMxN3YzLzVtejlmdmNHeXZwZDdhem81R09vWFdldVBSR25IUFVyVng3YmVXdjlSWXVjVW1XZW8reEpQS0xJL29seWliVWJ2aVZjdU1wYTBPblg1RnZ1YnZZYlI5cnc0V1VJelNGcmIzbjZ0ajIyOXpQbEpaUG9HT0FzakhhMURaRDhhcEhnL05PSUVSUHZJMW84cXlXTFVyWTluYjRiVmwvZTcvdG5zc3hTMzEzY2RmTzZONVZ4WTEzNjA4ZXloWlRaTGs2R3NJOUhpVUhsVTUxQ0NzdlhqVUg3LzkrRjRMcHVtVjJYL0VnU2pmMnF5ZVN5cC90TFpodGJtb3JTZG5WK3FWZWJPcWxTNnhETzFuL1R6dEo4WlRYOVkyczRMRjZMaFEwdFk1S1VZbG1CZjNuNjRHSm9RV3ZxS20zOWFaa3kzcksyZEtSV2o2VnFBUzFEbjNhVThkRFRrVUlwN2R0ZzRIYWoxVk5TWmc4T0paSFd5R2E5SUtMWlR5SlBDLzJMcWdEUHVqWE1sWnFaOFpnYUlJak11RUFEQWxrZ2c3dFdkVmY1Z1JwMHVhaHh1eFo3WjgwNWVibFJrdXB0NERPQXYxdGc1TTZlTDVlQmcwT3cyNjVBeFVkNmJiQitJREZDUU9OZ2dTVjIzcE9rdTVENEQ3RTZQNmRpVnlBeG85b2VnSEM3THlDbWJFV1p1cE9nZ2hwUFJoR2VtcnhNVnNqM21JaDgyMzVuSlMwYVBSeTdmclMveEZaTlZkeUg3OEJQQVhjbSs5ZkJDZTdkdCtsaWFOZFBkY3VMU0QrOXhEcUpXVWVwclpCU2ErVjBqbktHZWF6OWE0SzQ2azNSbEpqalUyaTFzZlpzTnJrT3ZLQjJSak1nR1NscHlmNFFaQ25DbTFGK3Z0ajVTMjF0cWlqd1d3SDJaTVJkYmdwVlY3M21XV3cxd0pkYTNmMkF2UENYSERUazlaRkM4RjFOWGMvT0h5QnZ2cllGQzlPYXN3V09uRFZheVVsaGZiSmlIbFUvMkVoL2NIemc1TXg1eXVKTFkxOU5Ja1hQL0dON1ZqdTBDbEIrZFNRWlNtc3VTam9tZEF3eW1SY1ltWllNMS8xSTdCYTMra3FpMzY5Q0srQkNNZGJCWWc4ZEx2b25NK0p2TnBZTjF6Y1piR1hKc2ZSQlBlcU5sckhJOWZTeUJ1bjdmdXAzYS9yVUsyMy9xcnZQRXlQSmxSeGhnYXh4RUg1UmxUTzFQajhKMjdtTlJpbGw1eU8zK3hXNWVUQTRmNmljQ0RNWWJJM3VrSWs2bGptYzVtSkdnTlpOTHZzU2t4cjJwcHdBOFcyR3gxeTNFOVZGb2NlRzFod0NpTDRCRzBKd1o3d1pLaXR2VEwxcWZpOUNXVkQ0alhGcGNVUDRlRm5iLy9ZTHFLNzgrVUpDMXRxU1BSOFViL1c2ajJ0YktkZThQbFBuNmtxcDBYTHQvbmx4SDdOSU1SeUo3NzZPT2Z3VFAvbnJqVmhzem1YT1VESkEwenFQcGpJaVBvbTB2U2x2UnZnRjZHZW5jUkhOS1ZuM3RYQ3pkSVNVZFVvMWJkUVlhUzdPZkxaR0UzYXZjcXJTaHRaVzlEa1hwYTVUQWJQdFlsTDZrTWxsbk1GdHZFYzRwUzhaSnZGSUN0dVVjUmprU0dhZW9OdkoxR2E4dEowcjl1RFZsMDhUNldkWDA3WlMrc1BsUW82bGZUeTMzcUpDb1R6cEJYclBXSm1veFdqV3BaQkU5Zmd2bjBLdkpNeUdtZDZ6VnNoT3FQQXh2Y0ozQlBYa2d2VHB5NXUyenpKWFVaelJOa3FrRGNEcFc4VStUNG14bmFJMm9Id3NYU01UTGFrU21PcnkySXZhcGRReEZqNS85OXZ0ZlRPMGdFK3lNNkt2bDJPblFJalNjNVBNd09xY05jQ0JQRitQdDc0ODZ5ODFURStnTU9DTWpaSEt5WExmNms5YVFPL1ZRM05PQmhtdmh6ZVRVNVM3S1ZRTnJPQXN2N1Q5VFl2Ym9JOHZrYzZxYjdqV3d6UTYxVXRaNytFK3JCNWRpaG5ScjhXQkUzRnRBN09DcTlGaVlicm1QK3NBOWRVZllpbEZQYlhuNzRKYjBwQXlqcnMvak9WTmU5b3poQlB6UVluYk9OTzdRQVJjRWZRQmdNek1vejdidFBaQ2tQVU1TR3VNelhxWWJWVDd5MkowVlZLMkI4cU1tSzBjOHlGUC83c3dOOVI1WmpMNjQrRG9XRVo3b0M0dUxVMjRQZzZUSjFOTU1JUStOd0EwWW1jY2ErUmFEaEpUc0g2QjJSbG5oRWVuSEoyZ1U3MFV5Z0E5cTF3WmgyWlZlSFRsYnI3M3BsRkhQTjJ6YUJyZ0tua3VIUEo4TUw3WHc4QnVXeVZxMVBySVdNUVY3WkZmT1RPekYxR0pmS0NzVkthWFN6aDRRUlZLcjhDRFc0TEdpL0Exd0JndzVYcVg1bE8vdEVtank2dUkrYklHK3lOSkpyODQwNDlqcThRRDBFdldHZHh6NDI2NWE1elptbk80d1g5YWFmMmFzUTAySHdFY2VlZkJVd0Y1RHY2WDlVL29qa2w4MU9LRjlMZlpPWFVZbGVsUWYvYU9wZkcrdjM4ZXR4NzcweWRmb0YxTGZXM2ZIVU5uODIyc0VadzFZNmR4STdKd1BTN0FkTEJzVzJaOVpIZkZWYmpYS2EyMjFjb1ZjS1Z3YkwxMFJuVVRKTWxTdVh3TXpVMzRrRE5USEVabkFIREcydG5XS3N5MmRnOVZlcE54bHlGNTBTVjlZZVZtcDd1cWNpN1hmY3lSVzV4eXN0cVY2RmlYWnAvZFFneFdrQkFYT2E5THFTaU9xcGw5ZlNIMTkrTW43S210ZHZ1NDA4bFhYWGwxaG5rT05ObGF5OHc2UmQ0aTgvZEhqSS9BdVpvL1RrdzBNb21QSzJ4ZWhWVGRJaWZlTW45WENYdjBBakNTclc3WXh5M0JadjVwM3QxV2Uyd3NqbFZ1V01RcTg3aXZxN0VUSU9GMVN2ZXg5aTF5N2JibWV2clp0dFNycmJKL1c0RGtDejVOc2tVT3ZudVZBUy9jMTRsQkVLVy8vcU5kZU94Nkp2ZUErdElqZTZDR2x5VnpXTk94c1FrZE5wNzJJcGlKNit2RGFyK3RtY21mZTc1R09lMjFvZlZwdFN2dmg0bmlDYUFrZnduQTRyZFA3Vm5yU3EvTXEyS0puM3hzeStnQTRHay9BSzZOb3BUbGI1Ym9ueW4rTXpRNHJybTkyOW1kQng1cytISkhsc01hbFYrN0lzVFAxaTZrdFpGSnJNOC9oTktCSUFHQWtYaVpHS25OVDZxbXBjSUFKY0dWNkk3Y1RESWlqZzA1MEFwd0doUEVMTHNNVmVIbGFkMDBienZ0OWVxdCtuOW5IWkZUcTU4aDZHREZnbzA0N3p2MTVPVUFkYUhQUExmbkhHU0tFV01JZG1ENjBXNTZzaXRxR0pWRHVERFlRZGtWN0tLWUhLU1dUZFcyaTU0SElCVm1kN1FoSGhqcDNEck5Pd3ArWFFWZnZXWDJ2amVSKzZSeDJ2OC9JMXI4Y2NRMGlrMWE5MVBlWGV3MGdrM2xoSnFvM3RYS3VzM2VrZDlmUzk2aEVYZVJSMVV5ZFZ1b2JOL3QrUklWcWhySFl3eWljeVJEdFlYaGZuQ1FwK3NacWJnS2treEhXT2dSSHp6Tko1ekJSNWtmOVRPdVNhbldzZW1lRkVCUjI0KzZQTFZ5TTFpbWNTRnZTOFRWUzhGWCt1NXlWRjF6RkRZQUw4UzI3MlhmOEIzVHA4b2doMVpvU09USkZCRjlFWHNQWm03TzRPTEVYVTlkeGFiWnQ0S1E1Rm4vKy9hZmFseVh5VnYwcHlRYnpLSmo5MENMNGVqLzNCSzZBbzJ1c2hOV29mT0dSYkgvRGRycWhQcjZsVnJ1cUdvNHNWVkhyQ2kyckdQVmcwRHNRd1JKc2pSMzlEVzBZakhDV3ZZUjlDZTZmZ3FWVThDdWdCYytXQ0VUTlVOM0ZIdUo1K1dTVEZnQS9McDZiZFNjenhxMDR4MXY2bER6SlBHdFZmeXNleGFpbFlmdnlEZWY2SmIrYlZyY3pNQzB5UEZQK3laWHNUM1JveFFUN285bTZxdGYwZG50UnVwVGlRWUM3WUkyZGVudFVLbUxxbU9wcGNNWUE5MkkwWXJoYjRZbFF6K1AxdmFLU3pXZWMwa1d5bk5hYWFMSW9NKzZqYlhvSks4bTN5UXBIajc2S3RCbjB2OHoydktkVDZyNk5VRzFWMnZxNXBOcnhTcEFsLzA2ckUvNUNxckJQcWxOKy9wY2Z6OUV2b0w2Vnl3N2VFUW1kNUgwMTYwWGE3eUdpZUpkRlAxY3RMMnUxRlNXaVF4YWpUT2IrWjNSSk1lcFk5N2xWWDQzUWN3UnZjR1lpOGtreXdzQXpKcTh5bmlHeUZHYjBDVFRyeVlpbzFmY3lWWXV6M3p0bWxWdVZjNGpXbTBsOXJ5SjlqcDVZOGE2NU5FbWJkU1NzUG5vZENXWDd4M0VVNnF0ZHJ1Wm0rSlRnV21TREY2bitzc1RpQXEvdjN1R2M2V3U3ZjFhZlNTSnpHbDVkaTludVJ0UzZaQzUxYTU1TnMzeEZPUTQzb1RVWDRSMkRVNUh4c2lLODZjYWd3dm81aDFWdXJ3NFhJcWtsZ09sazhwRmVEbmdkNzFka1ZQYmxhZkUvMHhNT0N5VHhNa2t6cHpTaUl0RmkrODRnQ3FmNlltcHYvTHRYbTdzUWxUallINVE0WEJIdDRaaUh5dlBMTmtUbjNLWDlZVFU4TytNSEVNVnlpbHF6dkNjbE9yNXY5clBoem1TQ21wc0pNT01SeGpMU0tUdXZnN2RWR2U0WUNqOC9zL0dnZS8zYm1RTWJwUUVCckhnUUFEN3h4b3MwcGs2aGptZWNCSFlHR2lqQmZabTJzcE9pcHhUZEl3MHlUc0Fsc2I1ZU9xMVA1M2pMNllUVE96aXMrM0hFdFQ3ei9SVWVRRHNjeGdLY0Vja3hLOGIyWlI5YzJvTXlvRXpyQzM4dm9tODN0TnhJejR2WDZseE4rYlg4enIxcHZhNTNNMFNOTDZYQzllbE5SbmhsUnI2WDNWTXYrOURYQVdPZzUxVDJzRUlBQUdlbUo2ejZDTmxlNjN4WUZhUUN4b3VzcFBUZ3NwQy9HTTlJWHhhR00zcE9GUnNRZlRHMWpKZHpiK1djN0dTZkZVUmRXa2NHSFJvWWlKVmp0c3BwK3dET2hMUkUyRWEyNjdubXNnaEQ0clhnNHNYbFBmTlNhcVFkczI1eHRyM3lVZU1JNEhGaXI5Zno3WXBSVnFwbk9mbW5HRklqNXRuaFdRd2F2NUt0dDQ0dlM5Nk03Y21wd3FYU2NBd2JQeERWZTYzK2JTVnFpU0p0ck45YjcrZHFmVG5WYTdkVXRmNk9iN21QTnBHckFvZWpYaUlvaWYwd0grK2xaaXRoSjdVbDNFZHRWR3RkUkVSaERSeWZKVktuZTNrUGJrdDJiRmlwaUV5dS9yWXZwWTRBMysvMFdQRlNiVHV5dDVQYkw1RDFKNk5PUWJSUEt3RDJ6cTAwOU5IU2x0WnVwbDZtN1JHeGExRXViWkdiOHJiZm1rNytadlhycTBZZlVWYmxQcS9mYS9rczFlOWRndk1xYitjMldtRjRQbnVrYm5UL2tVclBTMmhGSm9kNnoxdWFpL1A2MVBiVmJkWmxOWDNWY2wrektaU29URm5ISThFWndFeDZIMUI2NWNpOGJhbU54ZGwvQ0MwSzNIT3dwR01qenlYaXhYZFpmV2U3dFQzUHVOYkNrL2tOVVlGdXVTNHpqTHgwMzZSc1JHdWYyUXpIdGx3ME1CaHhYYnkyRk0rNWFQVmZtNnZjalZEVTU3dnk2N05oMkduWXNsVmI5ZjRvVWZIWDZtYmpsazZpMm5sbU9LLzFNYXZ0RWVjK01yU0pocVNvcTV1aDNkaG83TmxsQytHTVpCNGgwTXpWVDRVLy81Uy9aVGU3bTNRK3dHblFjdVZTdUpBTml4UWlQcERVaFRhZUh3WEtaQ3FXakkzTUlFWDZ0ZXA1ODJoMU9hdXRQVGpWRjFNdHNqZDVVanc1ajUwRFl3QjRDTkZjZldZdTQrSjZ5UW91TTVkaDJ4N0FaYm01QUpOa2hsdlJLZEJtY3ZWQWVzOExPL3gwWHQ2YjVkM042UE44U0ZkQm0yaHBhanl6Znlia1RxNUxVdUczeEdaVzE2ODI2MzFlblJrZ3JqQ1RrV1BuY3Vkd2hzRjFwSEtCMHhDWkZCelZCeVRaTTJ6WXRzME4rK0dPT2JxUzNBWm9nZ1Ezd0R4Nko0WWo0elA3MU5taGpIaXBicnM5TS9zdnZiVHBXZUtXUndUcjN4SFpsdnFLUGs2b3ZkbDhOR2VkWmJvYkU2NHh0dzZPWk5TY1R0UWt0TlRWeW5ucWVtbHZPa3FtbmpmVWpaOXhHbEJYTUEzTjNVTGdUazFXZDZaZVRzM2FKMGVKcnNnU1hKanlyUStsQ1B1bnpJTEszQjB0MVZERGpXbGkxdFRkVVdQbExLNU42c1hVT3Q3S0hCOTFBM3N1V084NWVMKy9HZTJDYWNjaXh5R1BGNEZiMXpyemRDUEFFVFNzSGhlTnM2NGs4cEVwblBES0U4NEtNc1V6aWt2Z09Qb0U5aUs3NU1vRWJpL3VCSWZRUThRUERReWk3WkF1Z1Nxeng2Vmxsek1yUFoyR1NCd1J2ZmlRSU92VmplNm52WTIvWHk4dDMvL2F0YmFpSXoxdUpZK2w5YTNNWjV2VktJc01ObXRXeDZ1N0dQVjZZbkxZRCt1Wk9hbWN0MDlydStRZkZZdzBIeEhmb3V4ZmxyaExoN2pDTENTM1lyc3Q3WS82VXlQRFB1M2N0TDY3bVRIb3lNMDhBa3RPTTNVdFZxV3ZsdWtHVFN3dklhNDlGOXRyYzYzKzlmcHFPWmVNRXlDZFYrVG1lRGN5YytObkMwTmpMa0pxb3FISnR6clo4cGsrVFB0VmxIYWk5KzlJOWppWEkzL3ZHWlZoajZLT09sSlJIUkhSSGIxNmVwU2VCemlTdGZQNEVETEtJMnNWUjJNcHB4RldmMUhhMkc1SFBHZXR2a2VkVmZLMkYrTmNzdmRUY2pCN3lWNTc2OXhiejBuS2VvOW14UFhTREduTGZhM2JxT3RGenplWVVQOTVjR1d4VDY4STU2RDZFZXY3L3RHaUNkZGpkbENXYVZQYVAxSnRTU2JONkxxdU9ndkpHbzJtR0gxYTViejJ2SlNOVkNZcWNpWFJKMXdZTHo2MmJqakNjRnFDbm81YVYxVDk2eUkrNjdzNnVaT2Z3MFdwQjNCbWtuTWFYMzdFUnZZbFc1cU43bHZTa3R1eU0zMm9TekRMdVhzWVZsalFrNjdYL00yVzJ6WkMxczhnS3Y4c0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQcitZcXJ3U0hIbUxWbHVoWXNUNlp0b3FHTkdWZGtlY1EzTjliNEd6eU1XZHNXSVV2S010VjZVdGVHZVZCVGdMbnJMc1VJNVhWRWRkcTFDVWFwK2lNMExYeGRNWjJhWGJzQTNRU2xZR0orTDVlcTk5bXRxU3lta2NNbVQyWEJZVHJvc2x5TjV5U3dxUmo3ZEU2UTFKNnA5anJhUm11UzZucFdWNVZxaklTcWNuVmRkZ1ZjNzc3NWRVUDBkZjJkVFI2Mi9ydkpmNVdkV3pYczVUV3laTzJ6ZkNaN0RhSU1ZK0Q5R1lKUHBGa1NKWC95cFNiREVvZGxObVY5bkZrNk1palhxSHZlaFJpOW5VUW5Tc2FVUld2SGNIWDA4ZUpEdWdlejUyQXBmRHlqVkkyeExSc2VGTko1UmduY3NUR2MvUmlVQnZld24yVlpaeEU0Y2hwUmRzcTZlOGxFc1lFYXQyNWlLMlZiS3EvV2twdGZyMzllWmlRQ0J6TWFOanlCUFVubkVZMVhIMXVYak9uRFVZVy9YczRwUzNBajJBcytHTm9SN0ZIUFZaVml0NW9sVnFwY1hpUkIwcTcrSmxySDNVNllvR201bXNrdFJlWkZaalNmWlJsK2xKdUk1U3RtdWdyeXlSbWR4ZXo5RXJIeW5ibWx5d3lrZU5zaWVIanFGK1RRTFVYem45T0pWVjc3TEZqN0NPd3pYSm1vaW9lcFBLUk9QLzF6NUwvVVpWaWFYYTYrMmdqUGRhNVN6V0tiYkdsRnJLUVRvV1ZSMWVPNUh6YU5YUzJWQW1Vd2RPUk1hRjRBYWZGaTg5OGtMU2ZXcWQ4cmRPaVRTNnhQWnJINTR2OFNZQTlxY09FemFENlMyRUNBanRDSjlIbTlJZ3RGREkrcndna3NrazFjZTlNR0lrMGJEcExQREZWQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJOFN1MENrajU5ODFhYnlVZGI5RkxiZHNyWi9XaE1XTk51VU9Jck40Q2MyaDVqWno3QWtmaHJScFhsOXV5VnF2M0tLekJjbWRHc3krZXpmZ3E0eTA5c1FUMmV3YklXMVlPSFFPamlPcU1IVTlocWJhdFZXa1dwYzZyalBielRrRm0rWnBMT2Ewd2hNaWkwNFBqZzBnNEtKVnRJUnN2YW1WUEIrUDBRRVlZcnRGR01UNnFpdExYMzl6TCt0RmlUZFpVZlBpMldvR2FsbVdMd3llempHMFg1cUF0VGVrTm1hQkNYNlcrN0NwaDBiRkVyUjVEVVhFN3BaOEp0OGFTWnkrL2tVMUZlTWZOdmt1eTgraXFyaG1uVmFxenJkZXkzUFoySHdQLzBuaTVpRXdkalRWWVptdFdzOXdxWlJpOVlIOW9jZDJ6am9UWFY3YWZ2VG14TUVSVi9xS1VxOXRwR1VQYWl0WVI4Nk8xNWRuaG1xd2ZpZGs1bU5ZYjFhcExYbVV6eWZGc09jODNzd1paMWloSzdRT2NsZXc4c05aR25UdkpCR05lWG03cUdNb0VVTmtUNmYzV1JEUXFmVzFibVo3ZWpNN0lXUTN2dW1US3RUck0zdjNOL042UlNJTnBXWHl2YlVabUx6c0FXOGVTSjljdDU3UytGOWVLYkI4Q0trNmJQYmxnL0lEckk0bHoxbSt0WlNnNm5FdWdyV2lmeVNHMHB4eTNXS2RzcWxNcjE1TUs5VklzM2psNWFzcnF6L01pdExyYTcwVlYzUVR2UmkvT2ZqZ1YxdTNVQ0tkV0hHVlJGcmx6eTJXSzZsK0FhUVFIU3pGOG9uck85K3ZkZ1NVZkhZbnRCdlk5ZXR4a0hiQ293L1Zndk5EQ3l5UnR5eTFPdVhXeFpkbzdubzBIempaKytHSXFBQUNFd1VjQkFBQUFBQUI0S0FTRUFKZUY0UXNBQUFBQUFBQUFBQUFBQUFBQUFBQndESGQrYnVPWHVPcWw4RHJ1dXNSWG1JbTgwZDZ5d2s5dmUvV2FhcTJFMzByMlZsUVpzWGhlNzQ4QlZnMkFhK0t0SXZkYS9QQzczRnF2MmlPMVZUZXhMdStMSTk1QTMzZ0xORVpYWkhrNzRPbmpsbFgyV3NvQWFHU1dSZGxSeHJ5MVhUT242SzNHNUswVDNJem42MG1kUnRxeTlzRzlpSzdNT0VBKzlvalJyUGFsSWFERmxTTml0bDNCVGcra2RmMWFyYnpWWnZZY05ESkxQOGZhS04vbFYrSDRuNitvMWl1MWZhaU10eDJyM0pNWEIwZDkxQmE1MTlwbUxCMUgxQjV0Ly9Wa1NOczJkditJbEJhajJrMnFXR2ExTmYwV1BRZnZtd2lJTzBTeFZxeVA1dXdqYlVyMVB1UTBvak84VGoyMEFORnlGTDFCMWFNOHJIMXdLYnpjb0ZXdU4zNXFpWGZjOFhna0dlV1JIZnZlL21pNXBUcUh5QVhVK21weFJHWVorOHk1bkVob1dtNWJ0bng5eWIzVnA3WHR6RGxwZHRnckR6ZW54MmhJK3JYSHh4a2gwRmtkR2tuSVIzT2gwWlNLRjZ2VzVhMHk4RXhHS0dqTGo0Z2tJMzdLVndMdGphRXBXQU80OTJMMU9IM1JRWjdONkVRajVJd1g0ZDJrMzhFMk5iU0gvYVF5WGh2UjQ2dHpIcEg5TFhoT3VrZDlMbG1Qc1N4eDJZa20xaTJpeHMyNXR1NnBsTTJ4OWJPdTliTXpRd2w3ZTExYWhyRm0rN3p5SS9yVThKS29ua3FKRHRsSTJTUWpVeEZSUzJGZGh0NndZRkcybzJUQ0lrOU4xZHVXaUdoOW9kNU9oRGF1Vy9XWHRBMjc0K2xBellPcng3T29wci8vK0htMmVuRk93am9wejg1VVZSQXBtRTVVOXdueS9QUE9RRFdJUHQ1RFNKTHhhVHgzOG5aaktPcGdSZE1SS0prbXRGVDF5SGEzYlh1cFFtL01STTNSeEZCRlJQOWlLb0lKQUhCT1JsbzlBSUNiZ1FzTEFBQUFBQUFBQUNNaDF3QndYUmkvQUlOZ01BRUF3R041cUJIRTlnTUFBQUFBQUFCTTRZNGg5L3FmLy8zdit5dE95Z3RQLzgvL3E3KzErOUdvY0R6eVFyZjBWcTYxYnBsRjV1MzYzY2hja0ZQK2dJZmdMZHUwUGFZZEI5aWI2TXB1aWp6ZjRXdW9HYXdWa3o2MnE5VmVTdVNhYm85Ym5hK0prOUhhQUloaTJiTWRaU3E3eW1DMlhZbHBQN01ZblVSWEpXSThnNFVsWXgxTlpabXRLazQ3REtMamx0aHRJRkVyY1VUZjQ5WVJLMDZmdmtqWjV4SlNIVVVSWlBYbkY3bHNNYzZsWlFrMzJCY3JOb2tNaFcyNWFKemtOQ2VkeW5hL1ZxZTFMNjlQcTd6WEprQVBHYXRVNDlYUjVOZmIvN3ZhRng2L3MvSWIyZnhzZHVBeTBHOUZ4TFZmazl1TDBkYXIvTExrN2N1aDAwWVpsemVxVkJibCtLdE1ORmVhNlRQallHaWdBNGJRYzhsWDU4c0ZJMjVOMUlVZElRNkkxTVBvdWVGWmZiV3QxOXBudHU5V2h6UGJac1NQOU93VlFDOHpuTHB0dVczYlViOXFFY28xandYdEpLUk9XdHB1VVNxdHlpTXphU2ZWc2NwWjlUd25WcXJqRVUzVUxVb2YyaE4zMGZyYnVsRm1US1MwRHFhWlJPOXI1djVIb2xHSmtqeHV5R25ZLzFENmpNYVBrYkp3UG1iNm1kRzJNK2VnbVFhdHJVeU9JYXJ5RzhuK3pKR3Vld3VldG9wNkYxRXJIVG1IS0Y2T0VDNU9aUHg2TWFoVkRnNGhHaFkxUlJOVjQzVStVbjF1T05BM0lnU25JK0lMcmUrSDZzTjFVOUd1RnI5TGMvK2phQTJ4VVRwaG9yNnNSc1IzSDNVN3NobUdvL2huQVFBQWdQT0Jnd2dBQUFBQUFBQUFBSEFhU05mdEFCY1pBQUJlWUJNQUFPQ3hZQVFCNEJxY1FWdWhNV0VZQ0JNQUFBQkFNNzgrOWdSZTM0MnVHTHZkanE0a3ZRYktTMzFLYloyR0VRdlpuZktIWFJ4dDlaTElOYmNHQWZjS2prQlR3RXUxWDlyOVd1Rm5YUjd6NVZUcDhtd3YzZGQyZFMwK3JvMjNBa2wwaVpnZW5RT1FRVnBXNkFEWmlxNlM2QkZ4cnlJTFBEVmhkZTQ1czFGSEdwNUp4SFpVc2hJZFF6MGkxaXVXM2lwTmdiV2FqeGthTXk4cUtJeWU3V2xaVmR3TEZIdjZrc3BLMjdZenZ6M0RiUWhhaEc3SzF0bC9LeFFVNEkveTliRTFVTGZ4dUFReDkxaWt4TjBxYkZ0NDRpejF0ZXhqanpMbEVTczRHOEcwemsvWllwU054a3NhSDVheWJQYXQ3K1cyZWFaVW8vWCtKWEI4cGxKb0tRK25KQ0pxcS9DM1pSb1hvNjI2RFdsYlF1c2pvd3VHRUhISFBmZTV4UUJyL2tmMG9udjdyV09hZjRrT0dFSkdMRDdjeW1JZmY3WGZFbmFzMWI4dHFmNjZyRmNPa1hvWVY3M2h0VjZPbHJmYXNjcEZpQnBKRDgzNGEvc0JYbGcraEhZOEt2UFJuTXJJTWFVMnJtMjNzQ3AvUjM5Z2l3ZmQ2amxyZldWbU5Wb0RYQTJyVFkvV1NZMFdaZWhsSXhhamp5amVBUFRLMWVVejhxTEo3c2prZ2hlTmVtMW01elM4cDJRaUJHZjZ2VXRxMFNyK01JOVJkbWROdEswRlpSRVQ0Y2xRZEFoNWRVZW9VcU9KVVdXenFSYXBuS2NSbzIwdmllTzF0WTNXalZvSTY3YWpobTZBNWFOSDNGTTROVkVUa0xxOVZlRzFudGNPTkJiVmdTM21CMkFveGRuZTdQdVIwMkFZc0RqRmF0ZE9LNXVKdUc4N2hxSk96dU11ekR5aW1ZVm9lYWxjTkd0VDEyMTFXUWFFS0NuMEw2WWlrQUFBQUFBQWVmQ2pBUUFBQUFBQUFHNERZZjRPSEhtUnVjSFQ0UklEUUJjb0VRQ0FrL0lVQlkwaEFnQUFBQUFBQUFDdytQeGlxdkZLcmZkeWRhS3BON3cxdXFTK1MrSjRldldMMGF5Si9kNFBqU3dGQkRMWkZiRnFXcFpoQXBpSnNjcmdhNVdldGRwZnIyVGl0cmNzbC95U2FtVDkxTzIydE1MS1d3R3BjVytGUHVta0lxdk5BTFRTc3JUS0FUTG9MZVlUeFJ5M28vR3ViZVRhOXk0VENmZW1ZNWxQTHpiYmM3aTNMTHJWc2tMcU5MS2RlYkViSEVqUGVtTlI1Njh1RzVmODlidHNxWVRtNy83UEd0dSsxODMvdit6ZzFsbmZMbFc0YnV0V1RkVTdTdlU3alZqai9iaHdQYUpqUWxzT1ZPdDdGNk4vVXpMNWptanlMNXUzc21MUlJ1cFQvRjN0dDM1Q05GZm8vQnhNQU95T0pIUFdFQitaaWlpYmsvZ2FRMlg1eUJkOTVaQkNqU2pibnU0QlNCSXhWNjB4U2N0S3VJdHdIdFk1RkdXQWQ5c2Z6YVV0SFoxRWZZaFhtYU45dmt6Z0NpNFJrY3JTTXlWbmlaaFVYMHYxZS9XMGJZQXV1cDIxaWVjd0lwbS8zWmM1NStoQXRaeGpxMTJBUGNnbUkycXNNZVFacjI0eXdacDJNbEdMR2puNWJkbXkrRXJCTzc0a2owczNvL1VtMUw5N1ptQThNcU0xc3Eyc1VXaWR6TkcyWCtmZzFaUEtleklTdlo4dDNtdTJuTkYrUGFSVUZIbk5EakV0Z0pDMjRUejBEUGVzdXMwTWxXMWJFZHVZM1IvbDVMSWJqWCs5K3RzMmFxS1hzdTc3SDZXZTE2NUZ5KytxKzZ1UHQycGJPQm1TZ1BhWVlUZ1Z0V2Z1ZW5qVm94TGFveFNXbmRLZXJhN255M0I1NERBeWhsUVpORDlqNUNYWFRoaWdkZDN5U05ETUNQbFVlTEhZTEI4V1BvaUdLRDF6V0Y3NXJMKzlPT1gzNHA4RkFBREFBVjhGQUFBQUFBQUFBT0Jha004QmdNdUI0Z0lBQUFBQUFEZ09ZaklBQUFBQUFBQUFTTEwrNTMvL0s3ODBXKzM5Zi83ZitNSkIwYmR4SXl2cGVHMzBMTVowT05JRnVPMnIvQ2ZCdXVhdGdneHdGRVhmdFZhcitieUlpTFc3Q09JRjBleU50ZktLdFArclRuWkpGbStabDhVNEhta0Q0SVcwT08rRjhGWjcwWDVlWm54M1kxMWphYnV1QTNDQVBPelJaWGJkNTh2Q2VENHhtZXlDRnZobCtwRDYrandIL1l1bzBTRDBzNTFWTlRoQkVWVjkxZXoxcU5vWWFRT3hvZk9KREptNlhGMis4ZjVFd2g2djY1cmZ5dkVlRWZMY2FjUVU5cVlscFJETjViZjB2VzJyUkFwS0ZhT2RBRXdrRStacmRYdFNnN3VUZDJuMXVpMlRldG1MSENXYTlGNEM1V0FJSXk5eDZ4aHFFYlZvdE5oaWx3RWVSY1RYNjdVQlh2b2kwbWREQ2dSZ0twN1JpM3hhUkt0emVTS1ptaGFsTWlJNGpUclVVVm9tSTJmUXE2Zzc4czNEQWdXcDNTM1pSRVpMd05ScWtDSVB0MmwxVnFldEVVWXljWCt4dnlEaEpTNFg1L2dJUDNMRVE4blI0WHNDZW5MRlIxb2pqVkZUa3kzdVZWMjNwc2NDd282TU1vbXdPeTE2eTlzZjdWT1NCM2VlYkRVM0FZNGpFeDRwZytmblBRV2hlTXZwak16aDN4N3QvcUZrd21UOXlWYS9lU1N0SWNwZTZGOU1SVERoamlEWEFBQUFNQXY4REFBQUFBQUFBQUFBQUFBQUFBQ0FtN0huUkRDVHpnQUFIbWhLbUFiQ0JRQUFBSkRtMTl0VzQycENyWXNRdmQ0S3J0ZVB5L2gxTTlaSVN5TzlaYTc5a093UGhIR1U1UEZUQ0JlQWdiVkVTRW50VHBlNUErcWwwNjZkdDlSWnRxUFhzWWhOUUI5QkJNbXh1Z0JKTmZaeFRQTW5oeU10WmJQVncvZ1JjQklRdlFsd1VROGdzNVJiZGxYekxONWFhTnR0MnhDWEFjTDAwY1lmNTNWZDllM3QvdVYxbnUyOWkvVkgyMERHM0g1b2VTdUwwblY0U04wOVJLVHpNZ0NraVZxYlNCM3ZlUE5ZSzRFeVVSaEVzRE10SXBldDB6dm1wbEM3Z042UzAxYWVRMnU3NVh5MDdWWkllZzlqVk5Rd2tqMXZuVGVPZSt3eXdLUFlReTluUC9WVTI4SVJENmp3ekFlTXBuZk91ZVpSTXRxcVZIcVZVV1Iyc2xZYW1oSXBSdDI2ejYzVHZnN3VzKzVEYW51MmNNM3lyRVptTGtlMjFkcVhkMStsT1l6WHY5YkU5K0Q3Sy8yYzZQT1Z5NEs5ZlJvOXRuQlVIOWx5V3RtVHlhNm5TVFFpR3FKWGN4eVppOGk2VjlKeEx4U0JrMUlHN2NkTzdVNXZ5c0ZMa2FjYVhqZTdBclpBaWg0UUlUaU03RUFRd2doaFNFdy9IUzFhZXR4WXlqb3FyMzBvblIreVVYN1cvbGlYdnZWV1JIMzNvL2o3WXFwamlkZjNUYmRLRk1uUWJpOTJUNXJNT2o0VjZZZFkrN2NRcWN4SHk3MmRVcGdBSEJ6NVhLcy9YcytqUjNYcFhhbU52eGtndGhMVkhSa1BBMzBFSGc4TkhDUjNhN3UvZThob0VjTnJtekVKVVZvWE9SalFwV3I3QnZZUkxUdnpYT0JwWktTbjEwaXU2VEpydGYxNnFmUnp2eHlrcnRYMjUwdXByMy9MdnkranZwejkvL3QzL2IvdFlwM2lSNFo0bGZkL2RyWTgxdUc0RXdmWUk2M3JxOXNBZFVoVjI5ZzYySk9vZitYR1M2OGNrbWNpSW1RSEJZTUlMa3hMTG1MWHVNanJ6RE51UjQ1SGNxT254NHIzczdkdjV1MzJ6SXpsTGhNTkFSak1OSUs5L3FSMmpIUUhYQlZ0N0t5U2dHc05lR1Y2eW0vcmFPY3owL0ZzZmRKTWE4dWFLRndDeDdORW5QYVpDa3hyMCtyVHUrWXQ5RVpLTGZmZEcwUFJCOHlpNVd0bWVOQ3JVVGE2UDFndWVzbGZJb1FkaGxaVHNTZmVPVmlxNG9Sa05NV1NLR05aaG0yWktGR1BScXRYbE8xb0d4SExIclVFY0ZHNGtaZkNlbTZ3eGFQN2FGZXJVUHMwYjVXVXRnRE9qQk9DZlQyV3BGVGIvanZpMlFuUC9wN0JUWnhLTmh6MmxBeXhWNWlSV2FsdE8xWVlITTAwUkRKOVIvTHZpNm1CbDJhMlA3N25RbnZwSzIyN3BaL2Q4VFRwUzVvaUZ3RG0wSEx0dVRkd1JvSnlXWlR5VHhacjA5NWtuYmxNUnlQS29vL0E0MFF5VXJzOEk0TkNMOEF0UnJrbXBqUUtqNkllQURVajdVK0EyVjJWeExGVERDbFBZY0dPWkNWaXhFTkJJeDVPYXFNNE0reEZPdDg2TS9Wam45N2JLdHFYVTk4YSt2TlBOSjFySlRTeU1NaDJ4N3JrQnl2aWpBbU0ycEE5ZjlJWnpnR2dwbmxNZmUrb3pjY1FlYzQyd2lDQ1RtYUkwTXowWFdsMXMyeDNVaThYUGRaU2JpYm9obE9qNWV0YVUyclo5THIxQUpwVXZoWEVFTUNneVFnT0tqY2k2VWlPRUs2Q21mSXJ3ZkxPSUZIbHZ5ZVRrejNlV2xZcVA5TDZTNTVHSkhjYVBRY3ArYnZkdnlUNmJNV2J6Tm9yeVhqRWs0Tzk5ekZyUEZyNnl1NGZpZlA3ZW9iMUxIR0djM0tIWEVSVVhaK01WZzJpV1NIcCtJamJOc3FMR0JHaWpENFhWTjNGT0lNZUFwZFpPa0Y3OW5vVkMyMjIxODl0VC8raUcrQzBiSVN6MVkrWUVabmRudEgyWjJZSzRXYU12UFRSRE5LSU1YU0cyL3ZMUE5Qa213T3RMMXZYRjEyYnZNejBHVG5sVE1yVWJhanVOSHZDTFgxQWp1eTE1NXJEV1RGazBoTnp4UG92cWcxUUxwSjY3YUpMVmRTVWVOOEFJVHlmYmtlNTBudytpYXpZV3dHdWx2c2Z3czdYRUI3SUlCblR4aFFtUmlHanNHQkhNamNqOCtCR2JTMmtNcG4yYzZ5OWJXM2s5ZDh2b2haQmQyeCsxL2JsMUxXMTcrODJ5cmJ0U2FDbzlpZHpyWVAzcDBWS3ZPYzJXa2RwdGgyckRjUVNadE1pcjU3NzJKTTMvNnEvNnVXM0grcE9uUlRBU1JpVmkranQ4MnZJdlBsNGc0ZVE5VU9qU2lSN1F1b1BYY1pUOTRYaDdxWWphbkRiYkwwdFh2MDZyTGY4eW1oZkFIQUNSdHFoU0oyV1NRMEFqZDQzTTd3a3YxWW5Nb0UyaEwwQ3Y4eUE5cDQwbTNXK1VyNjU5UnpXNEw3TWNhK2NsWTN3cnFuWDF4bWQ4bWl3MGpKb29nK050SGlyMm4ySzN0Y0JqTGl0RWRVUkdWSndiM3BrVFFvSWUyVjJXZVkrRHp5QldWWmEwb3lqZnZhYUxCUDFES0psclRaSU1UMkE2STNXOHBCd0szN214WHJ0VUZHMnErTExncDZCazdQR0RwZnEzMUVxY3FiL2NSc3kvaWtYejhSTHgyWDF0UlZHalBhak02bnRtZnhhZHVSbFo3T0J3clpjN3dNMXZYVkNSTzVvajNRQ3dITkJGNlFvamNkR2xIK3JpRU1IczRsTTR1eUk1UE9OYmx0aStzOGs4d3dqYVEyTU9ydUJDc2IxdzdqYWFQaDNCUCtJYUdWZ2Y4VDM3WTh0cTl4a2luVy9NY0pZaEVabStvYUlKVHlSb3MyMldHVitEaXdBbHlBYko0M0lSUlJ0MzhiSDIyMEliUi8wSGQzcGtVRW9BZkFqcWZPUTlUTmZHVEJqQUE5bTVxUUdQSTllZzlMcWVHYWMxdlNEOWVHQ0F6alYwMS9CdmtkUDlraHR0anlJbHIxdmQ1OHdPWk9pejl5VEI0RWRoaDRWVkp6dDN2WmUrMXBVL282eVBWT0w5MXFua1EvZzcyV3RlSlFBNE5xa2M0TWpCenpLQXdEMnhGc2o2VldHbUV0bDVPTVBtVFdaZWpqYkxiVmZUQzNtcGxyY1c2aFBhdThXY2g3OUVablZtVmFoRG94RnU4WmNjemdiaHU3NDBiL0JoUmpYWWhjVHFseDZTSVIvUStSTlZtMlpGNnZUd0VPZFpsc0FGcDRmY1pCY1JjVmNHMXJSdHFmOHZHSjB1Z2JMQTFoc2JVampPUFZpTDhzTXphWStwK2k0UG13b2FRL2h0Q2dvRUpBaWYwMkN2ZU9Sck1PMm5GWFc2Nk9OSXRTdnY1UmFOa2ZlOTJpejNOdkdYcU9sL0xSZHRrMTl0SzN3c2R6bnFoeGZqUE5wemVTUTZUeWNURjVLcWpQaEZMUmpGajByRm1idERxWUE5aUxqamxqcGlFd3E0dWQ0YlJycWVzcHhnRE1TMGR2WjZRRFZYbzF3VVh2ZHF1ekphOGNpU2ticjJ3cEN0MlVzUDJTRXdVVkhUU1U2RDJ6Wm9SYmZ6V05WemlGYUwrc1hJbVlBRGowRFcxTWlVYnhBMENvWG5kUm9UVmNCWkJsaHFGb05seXJQWmVrWGRtOFFhUU4waExlUXpUdDd5aUl6MlJPOW9WcWJtV3MvVWhGbjczZFBuOUg5UFVRandXeS8wWGIvNEUwMlJ3MlN0OThqMG1kZHRHUDhqN0tYMk4xN2tWVlhVdm1JK3MxTVZTN0s4WXpLUHdHalltMUp1M25XYWNUd3JLMXRmVHNpK2ZPVy9kcTVST2EwM1B6N0FxY2s0d1p1eTQzSUNjTnd0TERmTlJYQithK21XN2krL2FQcW82VTZqcmpBSWRSek9aNEJkZVE3Z2pjK3ZUSHh1TEhTZXJGYlVnc1BKZW9TYUhXeldaOWV2R3pFbnJkN3loZFRveGRxRmNxMmpwUEw0TjE5cnp3QVBKYzZzeVBoNkl3L3dkTVRmSXBUcUU0Y09OZ0xhNjd1QVVTYytTR2RBSXdrWXROUFNIWitycVZ0dUNOUzVMOVhuL3Z6NzR1aVkvcitmR2QwZlQ4V3VhU05jWVBPRWZjVGhzR3QrK0gyK1VlNEhWM0RWMHZBVnhOWHFzbGdBQUNNWlU5YmpPMkhoNUVWK1JZVGgxa0V1QW5IcFk0QTRtUmtkR3NFcDg4LzlEYmFrckFjOGVKZDVuakx1ZlJtbTd3YnVDYmFpdlp0UGRwTE1QRWN1TTl3SUNQc1ZGYlZlOXNqK296V256ajhabDVhN1dYVks5RjZ6bWhNU0lOYnRTdk5ubnF2MGx6Zm0xcnJ0cTExU1pBTnVERFJkL3NSODRHMCtyTFlvekE5SnFFMUN6V0x2Vy8zTDdQM2pjWllsN2dDMGZaSlJGOUtIYldTenQ0MzlBMXJDWTdXTjlnaGozZU51UmR3WnI1MVI2MlB0UytsU3ZwYWRmcFcrV0hEdXc2Rk4vdGo2V05wOVR1cndlM3hZdXdIR0lubVYreU05WDZzOXlLYk51VHF0akw3bS9GT0ZpRExxdXpya0tsSVRKWXB0emU3eDJhUldFeFRRSnJ6OUZpZDBKSWhYNTF0cjd5M1g3dWhXKy9YTzRmaUhKZjdmTzk1ZmZ1M2ZrRTFZdXVrRWg5ZlhOMGF6ODBLaEI5aVh0eW1sNC9sUDFmcnVpaFczUjNRVVpscGtTMTRReE95N2JhbjR3YWR3aUowdmQzMjZyU2NWbFJ6ZUNZQmx3LzJKS1A1TEgrdmFHMitja2gvL2cycTE4akswT3VtVThZTW5JRm9QR1NWejlxQUh4c1hkSEhVRDlKSDhKU0Y1V0NXSmU2R2VXMUYyNGlXNmZWTFVFRFQrWmlIVUk1YmRiU3lVVkdMMWhQQ3BBOGVIODREak1hS1BTTjFld1pqdEM4cEh0WlNSMXJkR2s4NUFtUVpaYUMyUnZDVUNZN3N3RjJNOHQ0UDFQcUtabyswWXlNelZsNGR5VW1Yc01wNWt4L2VPZXhGQ2U2ZjRjMWxyNjNuN1ViS1pUM2dtcXg4VyswcTh0MFZ3RTdHdThSd1RrWUZpTkcrOXBiZEErWHdMQ1kvRW90bjI2dmJzRFJvVktTazhDQnpEdEx4Nk85RGJSMk1OMWlpQTZubFJuTFRwNlBkM21qVWtPckk0QzAvdWI3dktPdDdFOWxVQk1Cd3ZIbWx3VTFxUk1lQ1Z3NDdXN0VHOTBIYVZyVDYzdEVzejlKNEx0Rk0wc3l4OHV2bkxIWVN0cnFyckQvMzRqSmpJeG9OblRHWkF3RG53ZFBUSTNUSWpmVlEySGZHOFlJcjBQS2czMDdzbGZUR2JZTFRFWDM0NmdBN3MwZW8xeExhbkdZY1kvdHZ3czZKalUyZmYzdGVsVkx4YzRwK2tXNzl2MW1NOHFmdzVpWFMrZ3VxcFRVWDhWRXZjRzB4ekpBZ09sSXR2ekw3c0lDVldDVTlCM2NsWXhFL3hrRmdJUEFWVmJnem1xMUM3QUhPUWNTZmJQVWpBZUNHMUVxRFhDQ2NrUmtHcWpWNVVxTTV4azFqcWZYcHNKWXlveTZBZHl4Q1MzM3AvREpSaXZmeTVCNVlHYmtuSVJtaW83eFM3ekhWSStaWjRER01FdnNqSnFGSHFQRm8rWWJoZDZZNE4vb2lwM1ljQUtDVlVYUEtMUjFwTDhUKy9FRkNFczVLMXZWZm5XMDRGNWs4ejhNWmJpc210WEVGL3YxaXF2ZW02UGUreUVveUZtK3JRU3lPUVZicVhncnRCK0pvbkFOTmNMay9jRFpxNVdrVWVSRmRuMUdxZXdjK2Z2L21SLzU1ZnQvNmV0U0htczdPa2VHNHdjUHBUUzcvTnNxVlpiTE95b3hqZkRxNEVLTkVkUTBlei9SM3lGRHluc253ZnNqangvNlJ6bzZscUxPUEpvL0ltcTZiLzB0SFYvTk1kRkg3ZDgrNjZ1ZjA5WEpxM2VCYnNxWHFSZTBzSU5CZkR2UjJld21PZzZ5RGpDUGRURFFoMTZLb2wxemR1cGpVZGJUNzZPbXV3ZnBHU04xOExqMlhGSjVKUFNaRzVNSkhwU08wTDZYVzVzaDhLWlU0Q1E1Q2MrMHphYjA2WC9veGJhYlpVODlJekhCeFJnMzhudkdhOFMvUURaZWxSOFNpTHVxTXRyUGcwd0UwMGpQSDNwdDM2M1dZNnp5SFZGNnp0NTd0MS9wL2xTbUJPZ0Ivc0F4VTY0cGVhYU9uVkRDVExOcGdjOW84aEphTVQzYmdacDhHdFc1c1ZKSFYvQTcyM2NMTSs2a3A2Skhuc0ZYMkVlT3dCUGZYMlZEcjVWUnZ6R2g5UnVkRTZyNHQxdmVxSTg2bC9ybXR5V0Z0Rys1TnF5MjBqbWNuSHJLcUpWTCtRUG50blNZNnlucHIydG9ySDkwdjRhbXZiRmlBMmpvWXkyUm5CY05xbnh0OUNscjFWVFQxdnhqN1YyWEhSOXZJQ3V5TkpOQlIzVmcvVzcvR3V0cVQydzhwTHg3S0tDNzBqOG5NVEVUMjBrZlBaWHZzTlU2UGNFMStMVHV5MVZOSEJDbEhCVVp2bk9Ja0FPQXk5RXpxS3MzZDJhZHc4NGJiQjhKS1d4dk5ISm1oQTdnZzNyTWkwenNuQUlNWllBYys0SklBNkpSdmc3U0t4emE4L016VmJDemM2MGREZzJNU09KQURmWnc5dXA0cHFpTWVZZ0I0TVh3c1NNK21TdmtQUjJDOXI2Q0c1SjFCQVJkRlN0dU5GdWRMREE5eUlYQkNyTWx6emVTMTlnRUFzQ3ZZWGZDSVBHMG0wZnJTYXJhQ211enhPam5TOGtiNzlpNStaUFl5KzlMZ1hxL1pqSUxKMUJ4Y0x3Q1RudmZLczhkSG1JS2VzaVBxZGREVEpURTNBRnlGVWZxcWRXa1MzRDY0RlJ0NWJsMnZneUV4Z0pHVG1OYXpCUkFHSC9lVFg5R1ZnVVpkUE9VbCtsUjlhZHRiZWVid215Lzk4TXdLU1Vqdk9MeGxpYmpXY0VZVW5URWpOK2QwZVVuRUZZYXllcmhHbXl1eUROS2RMaW9jUjhaZUhTUnpscS9udmtDdWxNdXVMTlAwcyt2RmF3R2lSSU9VZ1pUanVuWTVoVnR0S2FKNmFTaXJMcHlNbmt6WVhNa3NtM2JyVjBtTDRpRCsvdDcvS3YveFJib2ZRYTNiZTIrcExFdjgwdnhjQnMxcC9lN3o1N041UzRKYU01RzVuSTZYREt2MzkvZzR5WHJTaUJ2MXZNY2FQRDVpdEVjWG5nU0lrbGJYeXZaclg5bmtJdDdrc1JpTGM2MU9YeThUZ0lERGhSZ3hQL1EycGw0N0ZtRmJNUXJ1MTRYWFFKL0J2ajZ3WER1cm5GVEhPNTVwTTFNR1RrM0U3V3lkQm0xbFl3TEZDQ1E2N3EyeXA4aHZBRHlOVWNvalk3ZGFIUW10bk9xOEwzSGJEckNsMWJtMXludnozMTdia2lGdVpuUW1wNldkN0RtVWhyNHlOekxyMVZqMXQ5dWp2SnF0QUl6TUNkZlh0RFVnR29HbDFLWGppMUl1VWtjakd4aHE5VWVpM0c5THhDTEJoTlIwWFI2bkhLSm82bmxQV1RyRGNGVzZ5THEya1RhejVVZmVna2dldlpVU1BONzZUQlNjaEl6Nzl3ZHZMaFpPUmRSakQ4K0xHVXJHK3dLcWw1N3dVZ3dBM1dUaS9Vb0EzYm1zRHJSeE9rbzkzNDZzczZNcGx6cXRNU1MvQTZOcG1idUtaaTltTU9XTHFaN0JmTWx4U3lvdEdrUk1qU0cxay9CK2FEMkFNMzBCd0gySlppcWlrZElENkVrb2lXVm5XbHdjTmppU0MrdU1ub2ZaVUpXd0c5R1ptNGZBMklQek1uOVEvbm01OU0rTHBPdmt2a3JsV3hiSjEvd3htaDNuMGp5Z2NYeGhIdEhRZWFZOXd0YkJVWWlwaGV6enI5L2xYeE9IVVkzTkM2cndKUDQ4UEZJYWMza3RFM3MvTGx1ZEFKa0YrV1VZeEJsUzNpMVRybGtZTGdBd2hQcFpFVklua0tWN0lqeFFydVVGbW1IeVBOTGladHM2YXhacDlIbU5iazhLTEZvaUl0QjU2SFZFZktDbVJYMGQ4akN4MDFkMFVzTjdGcm1ENkV1V0k5dHNiUTlWQUFDakNJZEhBeFRhbnpiVytxVVlhM3U3ZjFsUWZuQWVoSEN2S1B2ZmppK0x1NnpQVXBXREJucWRPdTNkTm03S0Q3UFU4c2oyem5yTDNsOU1yZDkwZDlBVWlGWldtMXNmR2FSa3pta1gxQWRFbmZLbitRRTNBZ2NPems2OUFvWEU5M0YzaFJ4SGwzZzVMNlBxSmRDR2VmbjQ0L3VCczZwdTJUWVNkZVFpUzFDZ2YyQVdzeHlyQVZqcmQyeVBMOEp4eTMvVSt0SGE4c3FJRlNLTkEwUVk2T05ua3psN2NNb1FabnRTWjdoSTBJam5SSWxlWE1YcWJFZFRvTDVGV29QN2kxTmVyZmVhRWZtS0cxNXZUV3kyM3lwN2p1ZXFiSzUvMjB5RHM3czcyWmhsUnlKaFVrdDdGcVRVNEFwNGxpMlNXbmh0L0xTMU1RbFdYMFZyUERoNDNvcDUrU3VBeWRUeVhZdHhqM2lxdWNMTmNiR1A2cVRxY3VaUUcrVkdyY0V5UFU4YlluQWZRU1NkUFRyVTlzeVVkQnh6QkhCRDlueEhURk1pM3FSR1QzbnJJVlR0T0R5UE0vaGJhK0FrVGlXdjBRZXhYc3k0dU80VEhFNzV5STNQekp4cTlVZWgvZDZlYTF1Yy9hMkRJNUx6MTR5RU5aTzlCSTVMZldZZjArNmQwOUE4NlJaV3U2c0lXVHNiUEFXNE9ORWhaU1pzbGx6QTJKTXJIUldNM2pUSDBqcThYNVFscHJtbDdTd1JEOEU3Ris4Y2JucWJuME5VR0xGUHB5Q3FubnVqQS9WNXJmSWRTbTBWUkxXdHpTOW9jeDRBaDFDSFExYVMzbW5HSzU1VnA1N3JwbTNmRnMrbnRlcEV5b0lyWTVHNm83QWVoN1hxdEdRaVd2aG5BUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJOEd2cElQTjJlZjJtN1NyODNiS0FWblQvVUtLcm9MUzB5ZEk0KytFdE9hS1ZBeGhOWkptQnJYd0srcUpldFBUMXBZd1o2dW9NaEJjcERxeGdWNnF4NzE2YnFMNldkQW42QkZxSXlzMUo1U3U3Um12RXg1TVd1MXlNNCs2bHlTeVJwQzBoc3oyK0xJejNPeU1KbjdlazBBUjV3SFg5eGh1LytQWTN3MXNuTXZJOUgyOGwrcGlRbEUwNTdjdW5yekt2NDU4clpyNDc3WFc1dFM3M3RYTTFsaktMck9OYmxmbFprck84YjF2MmJOV2J5NUV4d0dDaUplWU8wSUV0WWRMMm1PZGlMVXMrSjlpeWFxRFhKa0FHSzNaeEt3WFU4bHVCcGVxakJHUy9PbGpuVXNTK0dSeHdFa1o1RTdXN3RlM2c1NURpTmkzMThVVStTWFBZUkg5QWRFNGpXdDg2cGhsdHh2OGppSDZzWmpIS2VYbUxiQ1QyVzJrUEFCNUdOUDllQXVXM1pTTDJyY2Z1V3BNYUtEYW95ZmhiVWZtMTZtLzcvSnVRbE12MThER0dvZ1A2VmRZYVZGR2xzSzBmcVpmRnlnQkVzMlpldlVnT1hHdmJVMlNaWkhEZHhqOUdHNk5vYlR0ekRiVTZHdEdKUXFsT1hjN3puTFUrSTBaUGFtZFIrclBLWm8xaHNMdWUrdGpSZStDcDZSS29VL3QyczFSR1dYUS9NcU5lclQ0dUx0ZmVKWXhPNjB2dDFkYlNFZ05yZnpRWEVTM1RVajhhTHNEQnRMZ1JjQmdSZFZ1cjhlMi9xbnRSelEyNEdKUFQ5ZnhDUWFiZ1RGZytkc0JRYWZZMkU0SFA4aU51TzlRaXZxc0hldWdOVDE0enZxRjBlNDd3K2F3aFBmSWMrR0lxQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlUNDk0dXAza3BCNi9zYnVpMHJ4MnpyMWZTc0twTjVpNzZiekt2ODlTdk5TMVcyTHIvTEQ3Z3gyclhPdk9tZkZXaUFXVmpLc256dWV2L0RidUlwMUY4eUVQV3p0MnlhdDl5RnB6dlFKVENLaUFOMXNMelZRMHh6ZDViRkh6cnVLbVNMUDl5YUwwZEx4ZXlpekhCOTFrU1pnZkxRc29yWWJMS0x1MDQ1NTh3eWE5NnlhWXpmRStLdEJQN2FGMWxQTEdKaEl1ZnlyeU81dnUzYm5zR25JQlhGMnEzZnkyQytWc1dzeTVXSUUvRDFCZFdOYy92Nm9xcDIrdlZ5bnJYajNMSkU0Y2VCNkZxRVQ0OWFIQ0ppSHIza094SmRoVnFpOVppSFZUZWJPc3EwRFJDeFRzMnBpRTJGb3VXS0ZHcVQ0RlZBenVHTU5LZjB5MmY1ZFgxdmNMdGllYkVTSE1GejZ6YUNVdU4xUFUrWnRCaERCditqbUhtN1Bkc1dwU1YweDRjRHVDSFpBV3pGMWxJWmFiL21lSGdCc0hSc0ZGNCtBTzZGbFdqdmxhMU00dWJ0aENUSE9sQk43RHhDMU1HTlpucXMrcGw2cTdPOXJiTW05MnZ0V1hoSncweDdhM0RmVXZXWnBlZjNIb0UzV0tLVFZ0cnZqaVNCdmRuMWVyOUhKRmlkbU5QM3hMWStGV3pnTTJoUktTOFRFRTJPZWtPcE5aK1RtWEJvT2RlazdGdFdaaFJSNjFzVDFWb3Q3dldvWEVTR1ZxdXRiY05GeU1TRnNEdmVJMzFoWFpGUUh0czV1NitwaCsxakdDWGVkOVJGQXBoQ0pYZ2Z0cjRsTnpibVZOS1IyR09JaG9WWEM4RVBJRHRsMnpyWFpmWGRNcmNsUFZaV2xuM3RDbDlNQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlBUS8zNHhWWG83dWxvbXdsbzF3bHRaUjNxNWV0dEZabVVlYjBIS3pKdkFhVmJuWk5aQTV6T1gzWGtpMHF2ZFM3V3ZMdWN0ZTlMNkNqdEFLNVljcjhMZkFkblUxaTNNNk13cnN5bzdpcUNIZno0eTlTSzZwSXEzWDJzRDNRS3RTTEp6c0V4RkZ0RHhGa2I2N2RRZk9yUkdLTUhvOG1sd1A3UXhhSlVkYUhDOVVPUU1hTEhhcmxqWC9vaWxVUjlKWm5tMTFyVytWbWZiR3JCWml5V1hLKzZlc3RuNkxDRzJYSDFCOWUvcWc1djlaWE5nRWJhRnpiL2xObis4TGMwcEZ0eWUyUEx4T1Q2eEkrOStlMTRCbUd6MVd1dlFtWWkzeWw3MGxEUkpXd045UlJCU25sM2xBQ3dzZGV4YW5mVzkzS2R0K042dnJacS9YWkZaNmV6bnE1QUx3TG1SdkV0MVRGUjFQK3pTV3RYZi9GMS9lTDRrbFg5eE82KzJVNDA3eDNzR01rWU9GbjhNMVp3dEZhNzE1VVdVaUQvQXc0Z0dnTnY5MjNyUkIxVWlEN3Q0NStYMXJXM0RQZG5UWUhteVZUWUgxeVdYcjlyRkFtY3pWSmtCWE5mUnlvL0lodFhIWG9vcU91aGJsWUtWclpDZTltdHR5eXJudGJtM0IrZGxDYjNmcWQwemFmQlk1MkJ0UjVIdTU2UytNc01nT25jWEhhN1l4T2VRVGVKN2Nqa3lmeFAxTDdYajBmMEI5dENhVVJlMTNtOE5hODl0M25Pb1IyOW5WcHVYUUJtNEFLWGh1SmR3UXhDR2tkV0JZVFV0ekRPWS9aZlBPWXFzemp4S0I4SURzQVMvVkllQytxczA2TFBhM3RhUnR6ZFdIcTlDSTNHVnBXaFFNaXJhRU9uMXM3V01Td1RwVm1heUVWTDVSU21mUWY5aTZsdXJlNFFvQUJOQlNRSUFBQUFBQU1CdUVJVENKQkF0QUdnQTFRRUFBQUFBQUFBQVl6Z3l5M0JFMzJSVkFBQUFBS0FkM3NBQjZJT0lER0FzczhiVUwvRTEzcExyUHJQZ1VISHFyYzUyNUlYdXBhTk1xR0owY2IzWE1ldTFZdWhEVzRHeDU1cEg3aXZBU0N3VlcreXkwYlU5dmYxWHgxdTVZYnM2VWYzMUE3R1N0QlJGNjNJWG1oRUVpR0xacFJQSmxMYUFUcVM4dEIzMUFiMWpiMkRiSWNPSWxhQUd5SnEzb3RjWnhEb1RIazAvQ1cwLzQzNEhXZ2JOcUpYZDY3NnR0Y0U4VDFuYmZ1L2pieXRsMC9JcWx2NjdFdWIzWHo5ZlJpM2ZtKy9iZGNXM3ZSOWZMMTNGT244TjhudWZmNWNvWEd4VzczcTBvRmw3VDlQVjlTTmxMNENYRk5QeUhSRU8xSDJac0VueUd6UGhsemVLcFhMUlM0TFpnRmxFWFphUHNSQmNmYmx1NUUvNXVzNE5OQ2c4amNCcXZrVXhJRVhlTFg0NXRXNS9YZVF4Vjd0Sldoc2ZwelRUdUdSOWhTMVNMaFJEK0JnODBiRldWTjRldCtxT0l0SlhOaThKQVBCRjlBRVVMN1cwQkk5TDdiY0dDdG5VQ3R5UFh0L05rMWNybmJjOWxzcGpWWjFPa2Q5b0xqZzZzS1cyNjdaZXg2SktKVHFBNjR0cTlURmFDYXpLK1VUNGJiU1I2Yjhsc3hjVmJLbk9vdlNwelJkWThtQ1ZXNVJ6c1BwdWxhSEZPWjRhd0E1MWtKNUFFKzlzVGh5ZXc2eEFNRHVwa1drak84UThkWFV3bnBhMjNJanRkcVkvcVgzcFdBdGFpaXg2T3pQdS83WWVuQXh2bkVkTnYzYmM2eHNPSWF1V3JmSWZqM1BVNVpVNWplTE1mWXowMkFEZWlQcEkyN0tOb2NjYWFGcnJ5clBMV3IzYkUzVkV0bVdzQjNYZzQ1SjZrWGg5ckJqYnk1THpZYlcrV29hdDF2WkkvbGtBQUFEZ0had3NBQUFBZ0J1eHYzT0hPd2tBQUFBQWx3Vm5GZ0FBQUFBQUFQYUdXQlFBQU00QTlnZ0E0SlNnbmdIT3pmcWYvKysveFYzbDQvK08vL3FmL2tVZk5idzNnMS83bHlXLzRFaGRKbldPMGJmQnM4dmZ3SHk0QjNBbVdwZmdxQllKZld1aVVwWlBFM2wxQllxTVBuWnNuN1I2a1FrMkFFWnpRZjhpc2dyTXlMYUhOY0w0Qll0TWNCSTlQckRMU0R5VTdYTjE5cDk2cUdoK0YrUDdJWGpyaW1YV0hjdjFVSVFqVVRIMHZwejZkMy9WUlFtY3FmbzVzRzFEbS9MaVNKZldkQXYwVFZvNGhuZXBUNjYvTk1tSjV1dWtWUVk5aVJ2Vko4QXNpdUhNZldqWm9oeFBDR28yZjhFWWdMT3lsZVBWY1NNOE9WWlhrQlVxMW1Qb2F6dmEwU0szcC9YMVdYaGhVTUtwOEZaKzlxWkpMVFJ4SjR3SGdOUFJhcDlISkUramVlZWFraWdMOTZUWHI4eklyNWQydGNxbE85dldtZWtkakJqQVdsdTlnekg2RFE2dDdQWjQzZVlhclA5a3ZHc2RWY3lSY25QbU5PWVF6ZENlQkd6aU13azhELzNGaUFrR2IxSmpVZHIyMUxOV3I2WFBpVVN0OUJHdTdKa3QzSWdaV1RneDJnMkdTOUlVd1NSZHU5NlFER0FYS2tQMU14OVdsM044bWxWdjB1eGFJaHA1UFE0dXhDSDBwcFY3NjBYOTZsbnVDVjlNQlFBQTBNQTVBeGdDUXdrQUFNNEJGZ2tBQUFBQUFPQW9pTWdBNERLZ3NBQUE0SWNqalFJR0NRQUFBQUFBVGdRaENzRGxtVFdNZjMzOVgzMDE5L1c1dmpYMTFaNmVWV3pLb1AzWk1pYlJwU2lzNVd0Z1gxb1hXY3pXQVlpUVdmSXJTRW5XdmF0NDExOFNxYjlJOExFaVMrWUxJdG1MaGU2QURKRWxSeTQwY0xXZlV4Wjl2VlNyRGExODJyMXFXWXdXNElVbGZONmkwNDB5RmVteTdtS1UrRzdiM2ZaVmorbGw4WWZTRlBYbGRiN003QnpHazVXbWtYMzByYVAzVjhTS0xHWkYrTE5xcXY1QzZ0LzlpOWhia1Q2VnFwVDkyOWYzcDc5S2R2QUkyMmtEVENZNmhLUTB0L3VrN1pvVDZieElibENxSTlrK1NXb2pDNXZYWmFYTGczbUFrV2h4VUwwS3NpbURSdG53ZVVpMlJ5QWJldUpXd1RDQzdvajJsZFFpYkhnNVFHMTFaaWxYS09ZQXF4V2ZVMThsenNTTHN3Y1lBeGtVb2lMUjR1TkpYL2NvU3p5VnNpcjc2L0xTT2FWREZ3QjRKcEtpZW1FcExJOFJEclduOURSYUhzWWhmWE50b25NV2tYYXMraGtmTmpxcHNWWU5oT0tGN0E5czhTUjY2Y3M3eC92d2tvalJkcmFNdUE3Um5QL2lsSHNkc3p6UjNvbWl6Q3kwZGg1UkdZdGVENmx0clEzUDRHVDZiSlhIRXhnUjd4UUlESjVEZFBoNng2T1RHbExmMFVtTlZTaTNMUHJ3TFlsek9ZQnN2Ti9qRmtmT1pVUTcwVDRrcTVUdEsyTFpzaFllQnVBbGx6U3oyNkpUNm5MYzZNUHcxSzhuRW0rM3NYNU00N3ZNMS82cW50U0g1OW0xZVA4QW8vaVI5OWRqUzlHUWU1VVBiNHVvZlRubEZydkwrNCtYakIzcXZRZzN2NWl0UGwxTEg2Tm9jVGUwWXlQT2pTK21BZ0FBQU1BVVNJQUE5TUVZQW9BKzBDSUFBQUFBUThDdEF1aUNJUVFBbHdHRkJRQUFBQUFBRG9RTk40Y2JESVBoUlZLNEpRZzBBRlQ4RXZlK3ZkS3U0NzFsMjZKek1ndi9ERVZhaWtKYmhDeXl6SSsyUWhLMGtmWE10RGY5VDc2U0ZOeWM2T29nZFpueVdXUlY5bWU3dnBMWVc2dU4xVjlVcUwrYVVCOHIwa0tpR2lNdkZyWUFKTHhWMUU0OFlMV1Z2RnJXay9YS2EvdE1zaXZUWFZFNXdqNUVCZFlienc1U09PRXRNbDd2NzhYNzhvaDJURG8rbEl5eWdBdmdyVTBYWFI5U0t1dnQ5ODZwN2xGejB0ZElNOThEdXZ6OCtWWGsyMW10ZlZYZGh3MGtKOWJ2aWg4RHMybzB2TDI4LzRiVTlaeTlCbUhrL3ArWXlPV29qWUNXWTVxc0F6TTJvQlh2RHZhc29JMkpnRm1FWTVtdG1sN2Y5ZnVIenRmeUdrSmJGcUtsWEdVVDRUWE5HSUl2YW1QUVlvYUQ1WW94WnVyOXhRdU1GRGNrOHVYVHVrejBhNm1xTHhlSkQyZmxEQm5Jb09EWk1DOU51U2pIdlRhOVliQXNwTzBBWUFmMkNoNHo3VVluV0tJS1hEdHVsWUZyRVpVdnozaDd4dCtVclkxMWI1blVXQmI3SEZlbHJ4QlJwM3owZ05CeXlWYVp5TUN0OTYxS2ZlOTN0K1pyUzZDL1FBNWJMT2YxbDZsbjFWK01Oa3VnamlmWTlVVGhvbXg3Zll3c042cmV6bTFIeGRiYjdwblNnR3VSSGI0ajBPWm9ldnV4WkRHU2w5dlo1L1BpL2F6RnMrTCtxUFdwNi82ajdNK2czZTVlTXM5bFNHV3NjdEJCU1I2UENJWTEzMnVOWlc3d2REenYyTkpMaTNKTWVnYmt6NzdmNWUrMjFhYlczb284d0FtSXpuK05rTmRlUCtJeHF0U2JVTm1XaTF4VXlTRjV5TVhNK25xUytQZGtycVMyTTMyMzlMTnRhd1QvN05JTHdGbEFyZ0VBQUFEZ1l1RENBZ0RBQnhnSGdNdkJzQVVZQXc5Z0FGd1hoaThBUUFDVUpRREFTVUZCQXdBQUFBQUFBQUJJeUY5TWZWdUtmVTVpWmR2eWR0V2MwU3ZMaEJseEVwbGxNV0E4MmRWcUFNNkNvenVrbGNWSzZkUE9WeHdPMmdwckV1WWx6YTVjTmZKaW9ZZWdCZVFtanVlNjRpdEFsT2pTZE5uNlFTS2h5VjdpbWdtVHBwNFRxMEkrak9nTmJ4RUl1KzFTU2ZKbmFla2JxdVc5OEZleDlhT052enZrY3lpaHozRjU2d1E3eGJVbE5oZnIzRFFES3kyVnR3Y3Z6WFJ5aGVDSmNldnRqdGJ0NUtpdVc5Snp1SEJ3V2picXlsTy9kWUVldVhiN0F2Q3d6R3l0cUd1WFlWbjhEK1BNeUxVNWJzR2g0NkRINWdNTUp1ckI5L2lDcy94SWhoSUFQQkpQcWE3Qi9SZEpwY0FFUmlWWFJOKyt2RzluSnhJMCtSWEx6ZklrWmdRbnZmV2tKK2xHMGZ2dERrMjVST3VmaFpaek8vSjNaaFBOV25DZXlmRWZhRFRLNE8xVk9ZWk5mQTR6aHVuc0FOZVNZNmxNYlRwMmx1K3N1OUV5YmVaWnBabGFPbnU3UnJSN29CYUdXWWdQQUZmSFlYYzhOK0tNU0tvZW5RR0hvUXlhNHZneXJVOTZqWGdzK0xGakpXcUh5Q0dHR1psWjBNcjFQRzdXUzh1WStlVVgwYVhMZTQ1QU95NDl0eEJOcVdscGsrTFVDZDJBR1hrOUdJTW4xVnIwNlFuR3NuRFBZWDlXNTFpSjdhNTFhSDNzanV6cTY3VHFDSFFMWkxtNUUrODlqNnB0cDAyNzVHQXV6a2tBU0xUNGxSTTRrOWp1K1Z3NVBJMm9FZlNzeGg3ODIyZWRsL3Q1a2ZYRFdTL0x1cTdpb1ovNmE5VzIrOGFFcHFCR2tNbmdhT1gyZmpuMW9seEFlYmJrNTBaU205MlI4YTRseFFCUlVob29xYTU2eDFaTEtoU2ZEdDZ3WXVzWFc2SFoyd1VJOG5PS2xZQy8vQy8xMFZzcEwvdDZ1VHc2U0dZYnlWbHR3KzJaNWNIUDhxK3dXd0N3RzFvUTZpbWFsb2Rsb2tvenErenE4dFk4Q2NBSU5Ca2JrYjZVNUxrKzFzeElUMEw3d1pGNjFqbTBQRWxYdDkxTDVrWjZmVVlDUytuWTNieTlJeDhuM2ZhVnlmR2ZOT0RQOHZvWnN3SWltTXRvdFQycUxhbnRHWk1hVVJtdFRjY0QwTFNaNWthTXpILzBpbEMwSFZ6Nkd4STF3OXpvUnhCOUYyWmQ5YnJiOHJnMk1JV293ZDBKNUx3VEs5UzI3QkFYL1kwWjRqODdWTmt5YzlnR1hrelZwU25pSEM4RHlsamxoL2R4eC96V1V4a2hvQUF6S2NGOTMyaTUwdGN4cC9xdHFEL2tWS3FIeTRaY2lCbFBnY0t6OFNLamk4dE9TZTdYampkZm9wZVNKQkNDLzUrOU04dVNIYmZSTUhtZHAvYS9RUGREYmNNK3A5ak96RkFFQldIa29QSC8zRjAzeFFHa09JQWdwS0I2MFY2ZW1EaFB6elI4dlhYWlJXMjFiQURCSUVZK3FwdUo5S0tPZCtIMTNaOXF1Z3ZqMHZxZHFmL0xYY1daUk5zeHRNSXRzSktTWkNzVm9HZk1YY0FJdU1xVVloalJ1eDVLc0t5V09tQVpBVDBVNFlkdHJJYjBxRTZ1REdmOHlOY0VNUzl1VHUvNk0zS3ZYWHhGL1NRVnpBMXhUU2hDVVVWUHR5UlJiNi9WcEprQkppeW9pRXh2eTU0Nnd6cmkzY2xnR2dBQWh0UHFTdkVhNzFiWUNPTytESkNweVFDQVEvcTFoSGNSank3cVE4YmtTRXRpbExLZ2VDZXM1blRvZVduQzg1YnFDSW9qYm5TWlJ5TDEwYnhuR2x1aWpxb2JMUVJSdllRMThEd2NvYlpubGpYTHh6VFNXYndEWi9KRkhGRm1SSTVuKzBERHdBbXhUTGVVMElrblpjU2JGcEs5c1FuT3NUcTBXSk1BaEpua3BPOTlNeWlTOTdFbS93aFhCQXdObGhsMjZKSFA4RVoycy9IRDFGZ1IyaTlxbzVYdGNaTjFvOTJJbHY2UXlvSU4ybzhKVWtKL2d1TVlvTFh6YTN4amVQN2lucTVNd3ArdkhUQVpUL1VWQkhBZkloNEFqS2tmbXByQnEyZlJ4c0RDKytQVVFXTkpVeEY3RDllV3V1eFNSNnNRek91YkVYVWgxaU8yei9XZVNmcGlEYXFWVHVBTnpNM3c1RDdWOVJQOEc2NS9PWlVvb28yK0VpYkRwa3hyUmt0aHhZam5aQS9ZQ0xtSTkvZFVXbXcrYWYwNUVHL3ZTdGRlMm1mdG1DWGdoRTBQTHNReWJrc2Q4UHAzc3pRSWZ1ZTNtbllPUkZybXlUUWd1QnZSdlRhOURpaFljU3ZHbTA5K3VjWWNXODBoWTFIWXJIMllmT0RrUk9hTnNFeUZwbk92NjJTRWJRY0FBSWZRb3NDa2w3NnlJNTFISGpZTWdPTDFzeWNqWFIzUGpkZVdoWHdqWjZaVjBQUEFRYkoyVW9wWlFiMCsxSTAzUWlFNzYyRGQxNTdLWks4eXRRZUNpYWxQYTdyRXBCdnpUTVB2aUs3TFRrelpFWmtuUXFwcXkzcU1UY2d6OEQ3VWFKazZyWFdJeEd2VDgyRGJyMVVqam1qcVZ2TjVKcjIrRkNrZlRQdVRFTlVkbk9tR2pqd05yZnBMbFdrb01Hc1hZT21Ra2RZa0FNTWhBMWdhenlQR2Erc3pqVWZQRmM5NmhMM1JWS3h4UzhPbC9EM3V0eGxkN1BoaTZoZ3VNVDVidFF3bUh3REF3d2hkOFZCOUk2bm5ZbHh2cUF3cXplQUVZRGlhRnpFOGtPOE41aUNZanViZDh5NDRWdmpGOEx4YjBoTVB3RHlXQlhVSGQyRjVsZU1veXB3enhSdE83NDE1dEJCNXoyVUllend4YSsxVFBHSVpoZmRCLzZ3eW8yVmpxdzMyNWx0Zi8yZ2M3V2x4U2U5M2FLV0RzZFpDVXdpNkluQVBuenVMQUUvbndHVTFzZzU1SHpCN2JzYzdkK0RHQWFBUCtCZ0FBR0Fpa2tzRkxoT3dNR01obnJhNE85N2kvcVpwZkVkK0t0TzZJK2oxY0hsMitwNTRxOHdzeU9LOERWQW00MEJiVHFmMTEyemcvb3hRNDczT29WYTE3ZmxScWhTK3g2UFVGS01NU3ROVDFoVlZBTlRXeWJIMlpEQ3JUc2tNVmFrZGtzbGVreC93UlN0enhQTjlBTHljY1d4Q0RWZHdQaGJ1QlI0MDJqQjZUZmV6bWhMdUg2WjZGaTNKVFZZYTVlMEs1MXVqZUU5TWt2SmkxVDhXYjcraG44QmVjR014RzlkQzFqc1BXL2JSeCt1UElxekM5Q3NLcStqbGhWQVNtUk1KQjJBMFdiaTJ4bHpFM3RnSmg1bzZCMVFKbkxBdHdZbnc3QWQyck1iQzdLcEllelV0ZmhlaWV5N002d2xjeGFQa2NjZHc2WXNhdjN3cE5hK3V5MHRIeUt0ZllhLzRNODIyWDBpdGZzSDBHNUZXdjJ3cXRKN1VxT1UyRHBMaDNETnB2R05EU2llMVMxMjM2Q05pN3pnNDhNbDdkcVE3a1M2akk2d09yK2w5LzRJcjB4c2VrWnNteVFiUG9sYXAwdGlYSGhpTGZncXFwcTA2T01Jd3JoK0d0Y1JGVFNWUEhndHBMeTZsWTlLOC9YUkwwdWlnN2xtZ2hMVGkzTUtFQXhkQ3N1VjZ0dHgwYm1qVHo1SmpwYkhBR2dnQU9KUVdCZVMxNVhwc21hZ2JCNG9VY0hqOFdtRlpqWU9PTXphYTl6Q2VHNU9lbU15MlBGWnZSeVNmSlVYNVU4bmkwa3ZlUC9ZTmpkVEd6RGJxZVlrdkdXbWpYdEZJbmFReFpaVmRuUEhTOVVobXlnNmlkVlUyMG1jbEx3QTlqRm9pdkdPeU5PVFprWkZtaENUelNDeGZpMmRsOExveW9hWk9SQW5FWWIyNUhKWlYyV0oxMHFWaDh4b0h3U09iZXhSVDBxa3NOWEIzcEsyS3RJMXNHSnlqbm1sZ1BqamgzQUF6dC9VWHBNVVQ0ZlhxUk1adFNicWRIZDJTZUQwTkdrTyttTnJpNGpuMUdQWDZuVWI0c2dBQTk4T3JoYldkaTlkNmVnQWovSFdYWDVmQXRZazhaN0x5QXdCdXlhaG5VNlBnTnE0QWdCZmFXbDY0K1N6UHB1TDJQVWl6MHFFOWJtVkhRRFBkRmM4dzdWa3JZVTZEYVJEL1QrYmlkaWllbG8weEQ3cTQ2WEk3WWw1Z2JnR3d4ZnRUQ1ErWXB3QUFBTUNKbWJMSUZ2VXl0TkZ0ZnFqUitxTkVMVzl2MlZLWkhvdkxlbzJRaGk5eDBWY2RQZm00OUNtUUo2ZU9qZ1VxMGxpNlNWdGoySUN6TU9LaGhxYXVOZlY4TXFJcmdJWG50cU8vNmQxVGJVQk5BWEJlZWwvN2p1UXBYdE0rcURCZ1JZT3JnL0c3QXlOdDFBZlM4M05Dcjh4SVB1bHR3dVhmUGJjSDdoK21jaSs2OUp6MkVJMlAwbExIS2NMMzd0RzdFejBHcEJqeEthRi93UDQ0ajBmZ05oL1JZZXNzNnZUVFFMSmo2TWxCV1R2K1FXS3ZaMGJRTmMrRXMwSTNSMkFKYVI4NmRzemI1dHBPQzVmeWd1ZHlnczB4TjF5OTYvRmVxb0hidUxhYytEU01salVlUEJEUHl4UytCVGVyWWdxWnlJdngvaHY0Wi9rU2FscmI5UEtwbDU3WlZCbThTdG1yWDBjVlRTWXQwek96b3dxVXl2UXlRMUZQVlA1ZUc2NjFPWGJBWTBaeGFVZVhiZUZkZDBhZUNnZ0F4MGFmbDdVL3d2Tmx4OUd1Q0cycnlhVUhOeUtxSE9sNkZOay9XMm16RVc2WU9xci9VckNqUkovaFI2d2I3ZFhjcGptMDY0WUpQSkhJOUtWeFZBVllKcTEwVGZQc01kd3h0UUFBanlMNm9xcjFib1RIQVhCQ3Z3WFlnWmtHZE8vaTdYM1JvYVRYeHFFWUdTeWhVaVd5b3hJMFBDVjdva1ltWGRUaStrY0lMK1JmQzNyL1JRaFBhYXkxWmxtdDFyV25EN3h0YXNsT1FqeVh2bVg4U2JLNGNPbWF4dFYxT1lFUGYrVFFxVzlMbXA1YVYxaitEZkJjb21wNHhFT04rcm9rWnUxTE1ka253T3VMV01JS2s2YW1SVzF3VDBtOVRXbXRQaDVLa3U4M0tlRTlWZ1E0RUhUY2JZaVlLKy9YT0p3eXpiVkF5TXRaZEJoaVlEamVyYllRWEl4MGlhU3JUUjVwZkxmcy9nREJxeXpRbUdFOFUyWlVjM284QTBWSmI4bU5yQ2xEdnBocVVTdURveHJaSkZKNFJEZ200YkdNSEZRQVJKRzBjb3RmRy94Z0xYU25iRGFQOXdyY0YyNGRtbUZ2N016TTVkV1VhejFBd253RExZeDRlaERnS2lacTZZd0hZSDkybkYzdmRlZTE4TlJQRnRiL2pJWFZWOHdpMkZ3NEZ0TW5jdFM2Tk5zc0xzNHc4RUNpcXM3amRkOTVjSGxmeUlGR0IxZmkwT2REU2g2c0hRQnNpYXd4bzljanpFa0FBQmdBTmdxQU10S0F0dEo1OXRoY1BsZWFtVTgxU21kNGE5MnlJWFAwaEpZZXd0THIxbzRGNXdFUDF3RUljOFJEalJsNXVQdzdxSUlSdCtmVldsZDR2NURlQzdReEFPZGgxTE9DMERNUG1OUGdobmkzOWRLd3gwK0FKcUs1R21nODZDWTZqcTBmbTU0Vjl3OVQ2V0U3TkU2N2x1Ukk4ZHoxTG9yRmVxUEhxc1N1bFgwSTFwRUdORTVUanBiZkYvMEhlb2tldGVFZG0waysvV1BFbzVXckRQbnkvazg2dCtlSUEzcmwyWGgzU0JkYmh5UzlsRkpzT1c2NjdlaVJYNWlEUUlQYS85cjFRT2d3cHVFU3R4ek9IZ2NINWpGdzB6cHhlVzlFRWVPNUxEbVZVbEp4ZWszc0w2Z3VGT2J2dkNuYmQ5dFczUmJOMUxMajhMckNacnJNcEEyRHRaRVlXRlF5cW5CU1g0Um0yOUYwS1kxNzEyRUVWcDNnN2dFcjZybm9WQW5TdktqSDFoSGp5L3NDemt5dEMwNkV0Ujhlc1JSNnpBZ3RIMUhJS3l2aXRSQjVueDhWSVlER1oyRVIyR1hPWXVFQmc0bTR4cU8rQmN0ZUtnRVpYQnFzUndBQVlPQjRWcnpDZXVEQ3labmdHZ0hnaDlIUFVianhQZTJGeVpGUEw2TVBOYUxIZkJRajNsUFdTRit2Rkw5OHBmVVBrZG5TU2RxVHRKUmk5ek9LRmdXc3llcDVRRFpDb1o5b1VaalJYZlh3ODZ5Sk01c2FYSmNaRHhpOER6VnVUbXZUYWl2ZmpPNnF5L1ZBNitEeHoxaW1qc2NIWThrRmcyazFGelhUQmx3U3p6T056Yk9RbW82MWdKbzZHRnBnR3RhV3pIdXRpTGZXOWpvdFYwUVMwZ0VHeS9CWXdyT1M3NEhNdEROSHlKYldBaTRkVjViMWlwdW4rNGQ4TVRYeTJsOVVBZXc2aGlXSGY4UWZDT2FpclQ0QVhBM29qQkQxSmcxTkJ5Nkg5Ynp3d1hUZlB1d0NJTkhpN0NqRzlXQXNCK1ZqUUVPQU15TTVOc1MzcnYwRHVqU1AreXlVUFpMbzVoc0xjak1uOW5PTVZNOTBLdTJwK2owUC9jR0Q2Qmw4Qnd3WXJ3bXJ6UzJNYzNBMVdxWXBYQzRBbkEvcEZYdk1Td0FBbUFEZW9RQkgwcnNKYmZsaGR1VDNrNkhDcmZBZW1UM3NaVUhSTnpLODNnZ1AwUmZ3Wm5CR1pRa0wrVEN3Ym9JenM0ZGFPSUhxNlRFaG51d0xoUHE2R2VqUVc4QnVVVjRCRzExWFpCbXRaUU53ZGVoejdobmpHcTZ6Qms3eDQ3NXJVb0x4M3ZSbjk2aTRmNWpxTWRxbFg5QXVGWkY4ZzVFTlFXN0k0NklFQ3ZHZVdBSDY0ZHE2SHRrajN5NUVQNEplc3ZPYWpEV3FmcmhyU3gwOVpmaktYNVdpQ1YvL2xtQStKdS9qR2huTVE3TEtMamkyaWpNc0VyK2dUYmtmbmRqeXNCbnpHSndFYnZoS2gvUWVnZlQ0ZTVkTkxlWXBVSkhPNmVwWkZCWUo1UldhMmV0TmlhVjZnbEFmWjFua01tUVhFYm12dDlGS0MyWFMvRmFHbEJscEQrc010RUlxNHRtVmVNT3QvdXpST2xaZEdzdUlORzNMUHVJZzNlZTVyZFlUS0QyM3I2MDdMVTJ5eTNvRjdrRndzRVI4Q2o4ZnNDN3l0VldscUFyaFhoZHRuVVBnb2tpREpwTi92ZmxheWs0K1dYUXVyS3lPMm9kWHFtcS81bEJwZmRzTWt3SGNDSTkxSGJYY0N5T2p2bTQxYVMwYjBFcFRwL1BJQkFDQVU5SmpaN1ZzRURUbDMrS2JHT211QVdBME9ab2crSEtCbWtaTFY0SXllOHJ5NW8rbXE1VkdFZEpJM29nYTZjdXBFYndid1I1SExQV0JKME8yVkxZazM0TlV0dlZjd2J2aHZ6a3RhMlRySXcyc2hmZW1SMjMzbGpteURsSG44QTdqdXVXMlJ2dTRXOHhyYngyc2xjQzdVbmllbDNuVlZOU3lBUTJNOUtkTDhUUWQxcU5UVXovVFNOVXJKYnVVS1lSanlJQnVySzJLZEYzbnIrT3puQ1RKU1ZoUkxjODBTdXA3Mit6MjlMb2lIc1lvMDUyVDBlSnBHTlZsbWllaUpIMitEUGxpcW9WV2dXZ2pEQjNuMGhzN2xzTEVaRHNlYTJRRGNDUTlGajMweXc5MGl2ZE8rUUtkQVk1azlJQytPRDN2alA3RWpmWkFnK2NCejV1cWhyZ3BoaWtIcnNjeWtzZE45TGUwK2hkR2trOUJraEZkQkRmcDh3a241SU5lYnJtaE1ody9VMkpFSHI1NzVJeHcvSUtiNGQyTGpYd0JlN0locFZVSll4ODBjUUlmUmM4eWkzRVB3SWZBMW1RSzF2WW9xbTR3dndFQWw2ZlZ6cHBobXgzdEFBQ0FJN0xZaDUrMXRucVhScWJ0ZlNJYXNlNTZkMVFlNVdDOVlPZjF6TFU0VzU2QXBLalJUc05Ca3dLSlVROHNJbVcxK0tGN0g2QWNRR3NUanZCdnRLNTBad1RxQzRCelVzeUFUc0hCeVE5ckVnQWR1TWVTYnZjZS9hRHB4RXgrRGVRV0dEOU1qZjBlWEhxSEp5cDl4aStIeGNLMVNkUnlWQTZZUzkwSGRiL1UxeTJ5QU5nVE12YTRZYjFLeTR4UmFkOXhoMkZOUDBMRnF1dThUcnNWc2lTc3JsdWZFVUZIZ0I3b0FPWUc5SVhncHNNaGV4RHYyZy92eXJNNVlmOXJ5OUplYzhtamhrN2xXNUFxQWx2K2hNVDhCMzVaclVqbmgyV1N5dXU1eUo5YXZYK2NXajVHNnlLNk1sRHoyNWpOTDBtVzE4UWE4QzE0SjB2a1NMSGUvdlgxalY0UGY3L3BaUWVnOW9mVnRDUDAxdzRLV1dxUjN1ci9ROUpyb3ozcUU0ek9uTlBZc09BWUhIc3hyNWJ6ZkRtMTFWMVpGRGxTZW14M0hnaW5QSzFuR05LMUpEZVJNaVFscXVWVHhLMy8rTWg1enhscE1nQUEzdERwekUxcmFmcDZkd1hGR1U3bGFvOWNhVHlWVFdVQkFNQXRhSDEvd1pMVG9peWx6YmUyb05UaE05dzM0SHcwMnZwRFpGcWJic2YrZmo1MGdFY2FLbXIxV0phVnA0eFJlSzA5cmk1ZVoyb0VTMWFMaFNrOXRldDFCdGZ5ckhSZVMva0k1WHBrMlFhdFU2UEgzM0hpNWdBTXJROERyQWNNU1luWDBudnpjREo2bHFHTEVsMEJXODF2YnFWcjllMUg0ejE1dlVQSThoazlZTWljRTIwZ28xTXV3Y3k1MUdOT1NENWM2UnFBTUNmU1VkRjNRclQxL0ZHcXQ5Y1Y0Y256Y0xobTZ0MkNlTU85TXZmYS91N3l4ZFFGNmlPc0dXVjNkWTM5RXJ3RzUrRWhtMjF3VVp4amsvTWgxUzltUFlYbFBmL1YrLzBramJzOWFpTUpnTDJCWFRFWHJQMmdsNGVPbjJYcWVKL0JBdUJIRzEyenk0eWtKN2hmcXFQM1Z0MnZjTnVsekc2Tkl4YkRJNDNySThiWXM5aGpSSTF3L0h0OWlLVkJCcmdoMXE5ak9DNnlkOE00QnBlbFlUbW5XVEQrQVRnWG5LVis4V1VXQUFEdXpVd0hBTnczMTJiR3VBZzkyQThtMmJ4Y1llVHJHcGZlbjhXTS9IbEthNGRZTit6NUVhWDBJMVJZYjIwY29SaWhqRU9ncWU1THJ5cU54a1hTOXp6VThNcWs0Ymt4Zm1kR3J6YlJwczdLOVN6MmZPb0xsUWRBakQzbTVsc05ld3FEbVFkdWhEYms5MXAvYjAyTEFzTzJQMFRQTzFBamZ4UTZHOC9TNC94aGF1NkkzYWFkY1ZwRXQ4elNJWFRrVDUxQk8reXYraXFrSGVhd1FRUkFQOTdURHFJLzhyOGFtZHp3cGwzMmVGNERRQTh0djVHNTJMcTBMTHZSYWpiZkxyZkdTMnMvMW56QW9kbUdPOW51a3FuS3phV1p3L1ZTVHBXTDZzam5NbnAwWldlYWVoYjVMR3I1NjZYNUZjK3hMdVA3aTZpbE5zd1pvL1UzMlBjQ1VINFp3YVZJOThKb2tmcnJyZS9yYlYxbHBFbG0vbEpYa1dYbGtjcVUwdGRwdkdNc0cyVVB4TG9kNjdhdHA5ODdJeTJKcmE2eTFyS2c1c0VRc25KZERiS3NxZHZVcGtGbXZ1TTlVejQ0bUloUzlHNGd2UHZqeU9EcWRBU3NUQlVsQy9WL2xtU3ZFZEp0WUZzQnJvVFhyS1RoTSt2aVFWaG1BUUFBdEJBMVdyenZSZFJwTGNQSnFvdm1ENW5nZmdFWG9OV2hrNDNyQmMvYmV1NnhGOWtSUkcvTTYvc2NRVlIycEc1Y3h4Um5PazhkUnU3S1NqQThJblBrYnJLVzRYbW00WkhEWGRPMFBXTndqM0U4R0c0ZGk2NmprVFVQWEovSUp2dk1EelZvSGF6N090RTQ3dEdzSTIrRCtpTzU2Nmc4RGM5UW9pdUdGMGxkUVgwZFJLdCtRQWRlaXVhbHdMazNmeWRqRkpPa0t6Qmt3SENzUmR2d0tXMnlhN1pMYWx0L1c1OXBBQWNQYnpDUHpTclpjbDdaTTdCZUZZaVlHOWFjL0pNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCd3dId3hWZjc1dWZkMEdzODVZZEdUYzN0T3hsRUZjZ1ZFUC8vZ09iRWMrUEFNSGlzUERmZm1CMkFTMFpOb0R0R0pKMGI3aWdMOXFzbHlJdEFTWHM1NlVoMjRMejBINXJiSW1Nd2VWWEV2L2RrSUx3NWhtUHVnUnJQL281dVZZSkZhVlNZVXU1RjN1Z09zdU1yTk9PQWFkT0xaZVBXT0xxa01pOGlHUHIvK3V6NlNyMnpxOElyZWZNV1VVcGpUL0p6SFdwTDczWmFodE1mcTJNdTh6ZEo5aEtwMXhsc081cEhrOU1RbnBRN0IrNi9iL3YzVjJVYTgrdXVFK2t3N3VhLzNOT2FJNjh3NllMTTFIb0FmdE1Fb3FBcnhvd2lNNzZIWDVXQ3RoSkVUT01FRmtFd0Zyd21oNVpHSTdKY3RoVXZURlNGN1dXZnpWTmthNjFJNmFmM3hyRXNBbkFWTEZYaDJUZGFwekpwYTRjSTk2NUxIdXNmY0F3QUFBNi92UURKMklqSmIzWGlXeXlXeU9JQjc0WFBMdHZuSWNvcHRKTUt1VWMzYTRhd3krbENTWGxNWm5ySzlEY0hWcmZjTmxKYUpHOW5oY2ZsbVdvYmV6WFpFVm5RQWU4WVVIVHZKa0dVOVpVeEdPb3NTS05PU2NlQUMwT0k4aXc1ZmNDOGlxbUgyUXczclpldFdaNXBXbGhUUHBUa1F5Ujg0Y3BYbG1pWTdaSHA4SmxvK2JTWG92VCtQZFFMVnRnUFI5UWVkY2pwNm4ya3NNbFF6eFNoazh6cERwVHpLK3RVWEFPWWhMVzVXdk1QV3NaNWhSSGZhbm56U2JsL0tlenNzeFZTbnF6bkJ0dThJSXZia0tObGV1NVBtOFR3ZjdQVkVjT0NMcVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd0FYenhWVDVkNjNSTThXMHczdTB3M2NpaDRPRWYxa3NWU29wNFNPUDFnRTZQWDFCRDVVRDRDakllTTFDT0VVN29VQkxlM2Z5K3o5YjZCZFNYVUJYZ0wySW5paHpzZkU0K25TWHpjRkkxbW1tbkVCcWFJSm5FVDJTMGlOckVKNlRLRk9WWm1UeFBTY21IUUxtNzRuWjR5elZHY2VwNlRLWHI1Uyt2NHk2cEY5T2wxUUc1U3ZuYSs3VVIxU21kOHkzK0VKeXlPZUtrYU1zMzR1aE5URzhpNmFXZGtUYmU4dXlhQmxiMWhHTGhweXMxUDE5NUtnZ3l5cjZ4R2d0M2J0dDZta095emNZL1Q0QmVBZ1JueStOWDNSK0ViSUo2amxMTW90ZVpJL1cxdVpXNzd3RkU3Q1dJMnZaOHV4dkk0T2tKWjJuekgyenU5WXZUMTRLNWc0NEd5M1BZS1U0NlRvYlpZM2NvWGxQZkFZQUFPQ2d4UmRCalozV1QwdU1UZytlUTQ4eFFNZDhuVmZiSUNjaDMxQ3ZVblR6UmErOURnMzZwcDJVUnF0RE11SkxRQWF0L3g5eUxUSEM2b3UyZWFSTXErMnRzcmk4ZGJvSTFnTlBLOTRyWjBrejR4bkJ5ZWg5Wk9GdFN2QThaajNVaVBnSXBiSzk4ZEtqeXgwb0hXa3NmMTZMOXJhMDZDZ3J3dk91aUhYZHUvS0RpWGpOcXhHbUVaak9EQXQyZVQxQmV2OTVFMTZOcVorNFhBMmg4bzVhcGNWY0I5TUpibmZvR0dYakJOR3RqME1qendXRHQzTjlvdHYvQSszRnEyRFphdExTMzdyNzEvSzB4bHRlTEswdStHSXFBQUFBQUFDNEQ5ajRBQUFBQUFBTUJlWVZBR1BCbkFJQUFBQUFBQUFBQUFDNEN2RGtBQUFBT0E5WWxRQUFBQUFBd0JtcHZwaktIZCtrLzdhMUdLa2lCOXQ1OGY3QzNSUlFWOEE2VkU0Q3A1WE1wN3ZERTA2V0FmdGhuUXBSK0dTSnUvNCswYWJveFhCNVc4OXB2QUwxNlQ0TDRpa1JudU5Sb0JmQURCNWtSMmpMcTNXQ1gwcU9VNHl5SUV6RE0vZkJmYkdPNjdIU0QwUXlDVHluWG83R09sR3Bya01oMTFUR3RIcGlyb0ttYzdicWRGeGEvb2k5elJkUXBhTW5TZjczRjFWTE5Wdks1NmpKbktyNDBuby9IcGFqTTVrd3RUMmlpMlRrL045c3lCaDUvN1c4V2lhbnlRS2lOc09uYXVmQ0pVaVgwbG1lcGRGajE3V1VtVWpaVXJ5VjExTVBMQ2NQSjNMcXZLQXlzcUFUU21DQ2xNSVhsUUxWVy9JNWk1eHVUNElPckJObGFUckx0UEVNZ041alVCZVpXbnJub0l2b1phdElDVzlhejU0TTh3aWNoWWhQb1JYSmVwYlVscVcra2hCZWpEcG9hV0RiQVFDQWc0aTd4N3Zaamg2YlQ4TTVPWmJEZVpUTENGeWJ5QXRtMzc2N0h6OXNsWGMxeG9pd29XTXRhcDFJbm9Eb1EwK2FKMkpwdGU3TzZySTR5N0hGVXBQdXZ3N25sRWJQVGpIU0hsNVBqVGVkbFo3bWJWSE1YcXVleGoxSStWcER5Qk9ma3IzMmdlZml0Yk1TazY3T0x5MFpkVm9wM2x1V2hMVThXWFhaR1VtYlJVMVp5eTFMVjhDZVp1aFpOYVZyNzZvRGRYVUFMWDUxelR6aXJzRjB2RDdPbG5qcDJXTzk1VmtIZlA1OSszYUZNWUVoQW9aakRYUkpYM20zTW5WZVE3U0VaYkpIbjNFOENzbjQ0ZUtUSS83QldOdUM0c3hYNStmU1JacThkYXNpNWRmQUYxUEJNNERTQXpjQ3d4a0FBQUFBdHdSR0RnQ2dDeWdSQUFBQUQrV0lKUkRMTGdDWEI5TVlBQUFBRmdNQVFCOTdLaEVvTERBWkRERUFBQUFBQUFBQUFBOWcxdlkzLzkvZi95bWU0djcxVi94WHRwNURFS1gwdzJrNStBM0g5STdIZTdwU0RvWURjQWFDNDdIblRNUTdVWi8ra3huZFVONy9rZE9WNkNsdzBCMmdsY2l4ZVJJM0hJT2VrMXlzcFQ4c1BCSGhtdUVKbnNFSis5eDcyT0dlVlQra21RN2RDUGJRY3M0VWlPRnRZKzhDdkVRYkJpWlhRaEVNenNJZloxbzhBL2ZuNVA0ZklYYTZWVExyZmxzY0hKTHNhTHlISHU5Um5jOWpTVGhsYjQ0V3BjbUVNU09HcDBzVEdWR3RadFdNL2E1MXlpVXQyKysrRzNIR05kYUthVVNYQ2cxaWdHM0drdUZyNkhGTHpqeDVFZ3ltOXlHSUptdkdvUEhLYnFuREpFWld3U3ZMTTMvaFNnQkgwYU1xb3JTdVpSNkx2WTZEbXc0QUFFNE1wNmhydk8vSWVBMHNMdDZTZFFNOG5vYm9xekUwUGpuS1NNR3lENlhIR0pJTWp0eTRTVnNsNjdWdW9wOFdpVXltYU5sVVJyUnNEZXUrenNvbzY3VmxyR2xLc2tlTFJORVVOQTIvT1NQZlZYeElrejJPdlI5cTdPa29hRmwrVGpUT1p6UmQ1NVBKOXhlalJ0UkpOSFVTWDdZbjNpc1Q3RUJVSnlRalBUaVU3dDJEWnlQb2ZlOHE4OGt4Wk1DcHlQNW96eTZwdFFvdE83TExFN1gxckFkRlVDcXFmV1c5bDVWUyszUHZDTkZYQ3lqYTNNQVhVd0VBQUFBQXdQM0FSZ2NBQUFBQXMzaVluUUd6Q29BeFlDNEJBQUFBQUFBQUFBQUFBQnQ0a1FBQUFLekJ5Z0FBQUFBQUFNN01GLzl6WnY2bnk5R0RPVElqa2NzNzgxQ2ZOeTJIdUVrM3ZFdUZiMHJ1akY5QUg0QXJZSjNrWVJ6QUtZbTh6ZkIvM2NqN29GRUJMcjVzL29pWHV5NUFpQU9Ba28xcnlZNG93dDhuWTlUcGdkd0pRdTZQdDdTY29GT01hd0MrNlIzWUhVVktlRTVDc3RLTllIZjc0akp6Rkk5M2Zva3FacyttT2h2eFZuNmp6TXg1SS9MUG44dVhUbk9XRnZWWCttVkJlcVZiZlRqejUvL3pyOGlpM0c4UndtbUNZdDAzSjlUU0V0Nko1aTJiVzkwbG92MmFHK1E0eCtPN3Vhek5tYU1PTjdJdk5IOGRwZisyWlF1ekJQV3NSd1B3SmMwRWE4VjBScHdBTFd4S012MURpQit4M2VqVnlqZFNRZWZIdXhUU3Z6bWxLbldnSjV5TEc3bmtEOFI3WUh1dmZBN3ZNeXRQSFREUHdGRlloMG9YSTUrVkxwb21XbGFyVHdGckhBQUFISVMxd2JFMlFsRWJsNHN2dk1oUmFPdVVkNHNaWFpkcFdzRTc2U0xxVVczaEZONk15SmpoNHJSbnI1bEViRHE0a0hSU2ZxNHlVZXRGckp3UXo2V1IwcldXN2EyRHR0Rk56dkFsLy9MZGpIK005QkZHV0pUZXZGYWJSYlFHYmR1Y1pLMmhhUkh2anRpeTVyTlF4d2NTZFVCejhka1JEcTVMN3hJZ2hVdlR0a2U5ZVZXQkZ1OWRBZzVncGk5Q1d3RTkwN3JudVlLa1FyeERKbEwyaWJ2M212VE0yNGdad2FWSDU1Mktscm4vRGQycTBIQzMvY0ZkeDZJQmFNZnlHVFdJaW9ZVlo3ZzFOMjg5VDd6R3pvSjNQWG9JMmhqeW12L1JzaVI1a2FhWFBBeGVPNU9McDJud3hWUUFBTGdZMkJnQUFBQUF6d0pyUHdBQUFBQUFBQ2NIUmpzQUFBQUFBQUFBQUFDR0FtY0RBQUFBQUFBQUFBQUErcG50WWZoS2dTS3Rnelk4bGUwOUJkQktiLzZpMkhOS2xaWUh4TkZPNW9pZWZqanlaQ2dBOXFLRWdsdEVYUlBuZ2xEZS82bXk1aXJPVXdaMFBKak42S05PZHNKN2VsNVVubGFHbFBaOUhUbWlFSUFhN3pFK1V0NGR4MVFabEtZRnJqbWF5L0pPOENWTlNaaTd6Ung1ekZpMHpOd1k1NG1YMGpuejVlLy9XNmN0NU11b05QNmZzaDIwaGZ6eC9mWFYxUmRWTTVPMnZxREhXb2IwbG5XYU9rMG5ZWTJweUdTbHpoVnJvMStuamNqV3psMExPZ3UwVDdSYlRYY0JPeVRZR2k0K3Q3MldicCtTMXpoZmpiclVGT002TGhING1iQStTVHBSS25LRVlTWEk3QmxiWGxYaDFaamdCSGhPby9ZdWRkR2pTS1Uwa3QyZDBxNXJWY3NLWCtlem1rbkQyOFJXZWdET1FIUzhhcXV3OS9GbmxPSU00eXgzVHo0QUFBQTdFdjBLQW8ybnhwejNBVkhlVnNIMFVxM2RkMmI2RWU4eGVXVlQ2RFpCODJaSlhxMW9tUjRzVDlvaGVNZmFpTHpXamF1K2lGRldpN2VIaTFXaGhqSVNVNGFVWHBpd1lTS2pMdXB3ald5bUkvazFtWllNcTJ4TkcxaFl6akd1REE3T2tmRlFva09PRW5WOEFERERRYVg1QnJtbHhGSWROSjFVeGtsVWlVZmJSdkpwYVN5YnRYWFYxc3FPMnFZOS9saW9xa0dNbU5mV3dKYXV3VzVFNTF5RTkvd24vZnZlRDBkMGZoMWRxdWk4alFkZ0tONEZXSGhOSnlLK2RjMzNxdHJiNDNrVzdaWHhNTHl2czR5VW1ZTHhXaG1qUEJGY1BMNllDZ0FBQUFBQUFBQUFBSEE3anZBQ1BzVHorRkFIS3g1T0FRREF5WUJpQmdBQUFBQUFQWnpBbm55S1NRdlRIUUFBQUFBQUFBREEzbUF2Q2dBQVlDK3FMNlp1ZjBkZVhtSDU5ZC9vMldwcEk5RlA5TmZDVFNkUVNNZmIwUGlaeDF3OEFhN3pyU09FckxaSFg0Q3pZQjBIN3NnaW52NmFiRFYxYVlwNnllTCtVcXBINkswYUUreEdaRXdWSWZ4RVJNNXViWlc5NURkbFJBckIzQVUxSXdadzU1aXlUTnRJVlVhcERLdE9ROHF5anVhc0MrVXFOSFF1Ujg5MTJ1NS80ekwyNUFydVlxNU5wVFRSMlVMQ1Y1OG4vZnhScXZDY053bDBGdEd2UDdZMWttZHlJVi9mTE1VcXhEaE5YVHF5Y2gwcFhDZEJ0aGNySDUzUUpkbm45MG9iZldzYzBQQWxUcnNuMG9iaWthS1p6YmFwUnBHTE9ET2pUazVlOHF4dHVieUoxMlJhR3RZeXI3bDBGK2lDQUI3ZGVRUmVIZUxWc2JYZXp2cHRlNDllSEdCWUZUTmdLODZSekV5aldTR2UvTUJnMWhMWUlpdWFic1MrK0FTRHgyc0p6cXpxSG1VQU1Jc1JjMFd6MEJzZWFZZzdOQzVkWGJiMkpRN01Ud0FBT0JqdlJ0N0tMeXdLclB0T2tKRnpMTjVUUmJybWpkNXhGMmRaWERyTFF5YVZ0Y2ZYRUk3azdiWmJBaVJESXRMeFltRkwrdnpKdDRyb0VXNzRma1BNR3JsYW5heUhPZDQ2UmVvZWJSdmorVUU0LzRpeXZFclRFOTdhNzE3LytnaVpGMlhyN0I0bnQ2Ym5jUm00QjNUSmlLcUl5RnBHeTJ5MTRiZ2w0b1RqVkhweWFqMUdhTEVmazVBbmFzdTFQTktRbnNUMjRsMzV3Y213ekJGMDNuUjZMSHAzR2E5QzZPc01XWHFWNUR0T0dodDFsb3doQW5iRStYSUlONmZvMnBlVWEwbUdwMnFKcWRLb1hmQmxzQnJOZThNUFg0ZG1yZzB0WG85b3Q3WG0xK1RoaTZrQUFIQXhzRkVBQUFBQUFBQUFBTEFYMklNQ0FBQUFBTndIMkhZQUFBREFjV0FkQmdBQUFBQUFBQUFBQUFBQTNJM3FpNm5MYjhyNUx4LzBNdk9rQ0RldGxUaEY1VzlPNUhBNEFNNEVkMXhXeDdodFBVZnhVaFJYRUo5MVpBTkF2NEFJUGVQbHdtTXRXdlZhSldLS2djTzU2Q0NjVlczUDZaN0RDNnVQS2FOYlRiUHczbU8xclB6OC92ZTRWNE9PUEVZc1dyYVVucTRDV3R0YnNwMlE0L056L3YxcTZ1b3JDaThEc24rOFI0Nk1Ddy80SFJneHhxSm5BcmFlVUM4cGtTV09hVnRweUJYanZyWDRvbzNqRmp4OU1Mck1maXgzamZlckhwOXIvMWg4aGowcHJVZFhSZWpmbjYra2xyVDZFb2s0YjNrUm0vaElkYXJMVVZyd1NCbkF3YXlQeXJUR1A0eFJ6WlZUZTlPaVM4QVZHRFZYU2lET3N1MWFLSVBDQVFBQW5JUmVBNno2cWt1OURmVGtMWGtsb2hscHF6bkNteVY1a3kwWCtJZ3RTc1NPbHZKZXl2c1FlS2p4YnZ1d0FWTFc4VGxhSVUrNkdaYVdONS8wVFEyUDNIcEVTeVA4TENOcVR3dHpWRm1jNzd1MWpDT3MvSXY2TW1jL2hBMDgwZ0EzNTRoK25xazZyQ1ZoUjFwOUtkNlZ6d3MzclNjODB1Z2VTbEE1QUl4aGo3bEUzNHQrZnpsMXVVNEcyUTZXOU5YRkxUeHdKcHdMV2VzempSRm1kWXROY0tiZDd5Nk1WSG8zYnJ3emVTTDI5RHNXcFE1ZjI2RDZxcTJhMHFKMUtDMmF5YjJpZ3pEV084ckZHUTdBR2ZBcVBUS09UNmtyOXlhbnNUODJCV0Eya1luYjh3YmxRWXhZaHFYYkRpL2xXb1poaFlCYllIbjRzM0U5c1FwSDdxc2paZStpcnFZL2ROVUdncmVINEdidFIzdmFucEovSTJpc1NFcFg1ZnB0dHc1RDgvT2IxNnpJeXU4a24raUcrMy9mYnMvTUhiVzc4RHcyamM0VnIrS2w2YmduM1hVNGZUcFRKeGY2TFZ0OWtKUTZ6R1plbWRKSUhLbU80eU93L3o1M1dPSjM0b3pyVDIrZG1QNmw4ODliUkhiR0Y3dEd5NzlIdGJpbVNVZHBjWkRhTzlpekJMYktkUG9LcDVSeGNYcjNLamR2SGdBT0IzTUxBQUFlUU5TZ3FqWmR1WGMvbDMzWnZZemNEMllqTExMLzg1YlYwQVhtYzcvTFUvbGxWLzNiL0tZMTEySjU3V05jRlJLeGhrWnRBR2Q2OUJZay82d1dUMlZHZmNFam1PRmRzUWFUZFUzemNYR1M5b2d5WTJiZlJsdk1vZk9SQm5nZ2x1cXc4bnJlZjU3aDQxenljMHZDUmVsNUhTa0s3ZTZXRlhER3FnbDJwTlZzWEpETUN5elRwNlQ3bVlid21vTlpxRDhZZ09Qb0dKVFJWd3RhNTJFUlpCMzVqc0hodERhcTVqcTRFVFB0dEtqbm9VVldJdUV0TExLK1VnY3pLamFOWmJXM05tVndCT3hEZFBDZ1Q4QVpjWTdMRWt6L0dMRHpBVmRHZW9MTDJSc25RREtCdk5Vc3pqRE5uQ29SNFMwVjBzTEJ0WkhtVk1zRG0waTZBTjdIMEhzU21lZWxOWUZseSs5eTQ1NDdqU3JtbHUxN0s2TWFTVnFZSW5tc2RCRTMzK1RGOEgwOFpHYWl5dWZIcWV0ZmpPb2lYL2VaR1hrOGVWTWRleElVcWZBVWpFaStwOHpKWDRlUXh0TGVydkRnVFplVlBFVlBMaFl0ak9mQ0NiTzhwTlk0UDkvY21hSGQydGU4cUY2MnJkbVlScDJzcDBLY3FTNmpZTzVIK2xTT1pkc1BhcG96Yk5VOGRSaGxHUUFGeXk4OVEwbTJ4bzhvWXlDVzlUR3lLck9zWkFDQUR1WU1BQUNBRFNOc1dtTWpSRjFyYjlOY2NOOTRQY0hTczZyUnRxeVdOeXRsejN5dU1OcHJ4YVZ2OVpnTnBRaDdiY3ZYSU1wYi9NNlJURjU2NWJTMGFxKy8xcG90a2Rta2pmQlJvMlpQYTdZWTExRlptdWJTOG1uWGxPaU12WnUvY2dMZWx5aWtjRFF4aUtpTzZKUWZyUkk5UnNDRjhENkI5ZWFwNDYybWFlbWFQVmM0Y0NKR0RUcXdLNzN6ZGZQbFZDRmQzdnpSWHhjTUtUQ2Rqa0htZlNzT2ErYUpPTU1MR2p0d3BDZWlKKytNNS9wZFAweU5RRjBuRVZmSzBFb3NhTDR5cktyN004UGJEc0JNT3NabWk0bzVSR2ZPSXV0Um52dDhud3kwQkhpZmxVQ25nRllpejJOT2FrZEVIaXRaeTNCeGxDSE5aMUUyN0MvQUlmMG1DUHI4QWZRcUJhcHR6dTdwR0YyM3lQMUd5ODZEMG5qeUdYTElqNXlXSDVGdWY1ejZFL3E2ek8rc3IxeWt5SnhJZ2xkTmNuMnhlVkdPZHpKWUc5d1IvYjdudUs1WGQ3cnFwK1MvMytnTE1nNXZrdmdsMUx3VjRZNlg3cGZXYmVSY08wNVA3YmZuek80NnJLOUg2dkV6clExWFdhZThDUGZ3L256SldtL3ZiZE9Oc2k0V0lpOGZTekxBeGJDVTVZMTkydHpEcXVnSzJQcHE3U0xqaHMwS0hzNlZWSWJYa25WWTdnQUFBSzdDcUlWcXgyMnY1TFdLMkxKZUwxY3l3dXU4M3JJamNPdHVYUVl0YTZSSFJmT1lEZW51aHJIM2VTazdwOWluaGE1Q3F3K2ZqdVFXR1RValBSeWVtV2s5YmJaa1JtZTBCMHRHdEYwaS9uYWF4NnFUVlJkdHhscGFFcXpRaGtWMEdBUHdUY1FSelRGcUtkU1dnaDFzdXhaNk5QMHNQMFpQTS9YV3FYY29BUURhNlo2Ly9Hc3JiOW5yUHhnWTA5MjdEd2JnREl4YWwvTU9aZHlXVVE2c205RmlYMFhIbXJSREh6a25SbmhRNkgwTitXRnFhVWh6NkVSdThSb0RBSjRIOXlRRnpzRnJnVDREb3ltTmNTZGd4RlR3Mm54ZXZ3Y0FKc3Z1eGZzc211UGhndzV6RG00a25Zc2JTdVRIaUN1VklTMUlqY09oMUFLTDlkTzZ2VGhqV1VlTXFZNHl1L2NMMTV4RDBtMzNhTXdSbWxiM0hXWXp2Ui9Kd0RpQ005VmxNS3NPRXU3VE0raDY0MCtLOUdvaE9BSHdKYkVjYlZYRG9nZmdXRHl2dUovcU9UQUFBSUJIb3YzMlorOTE2ZTQvNlJyeDZFYWlsSTUyR3ZXalZMcHBaMi80Q0d0bmxCUEZhdUVXYXk4M2xyVW4yUEN2dWJGZjh1eWd5WjlMNjlKeDFMc1JYaFZ4SWxYU2MvdWptZzYrZndEQU55UDJSUnpzajFLdHpSa1VFd0JoTUYwcW9xNkltemRlaTM1dlBXZkcrbkhvR2RSN3Zkd1lQMHpWcTJ2ZDdDbXhlZ2JzZzNlbXRPWUhvQmQ2d2hlOTFxRHZXWmF0U0NXNVdoMmE1M1pUZ0RqVE5oOVNhWG03cGZqS1dvVjc4Z05RYzdFZnBWcVBCbHRQWjRtb1NsWkFZb1FCY0tNM09JNWN2N3VXdDVZamtacUpicG16TTAxSmZTOWR6RUpxM0Y0NWtUeXQ2WW9qallWMDM0YkZuRDAvQ3kydkJTbXJrcmY1MWlHZmt5akxLdmV2Nkx4K0l2RCtPaXU5RnU3bjNXMHRrNHRiZ1drNGQwM3plQ2E0ZDdIMldoeFN2Q2Fmem1ORGh0alI3dzc5NUM5YUJvMHo2WkpmU2tDWFJMZEpYRHBPWG91ZHVTNlRHM3VaeUJqUnRsRVp2WHBhWS9aWTZkSFgzcDZsMFhJL2J2QU9PaXB1b0IxaXJjYXRyZ2lwNVV1Z0xtQUNWZ2N2WWRwN3VORnhleE9rMjQ1WUZRQThEYzZpcmErVGNtM3RYV2JNTFc4ZFdtVkRId0FBd0RubzJTWFNoWWpkUjNuZkFWbGNaTlJkWXhUTmlhdDNucHduZUEvYk5Pb3BpbnJjV3VydTlXWllOajJIOWVoR2xyRk93Wlc5MlpJcFgwSjFqZWRXSTZldVNHNjFacVFlSE9tTjZCM2gzaEd5cE8xcEIzcGRuT1ZxZVNLeW8zVzNkcmcwM0tvYmw2WVZyMWFKeU9qRnEzVWVoR2RJZ0hQaWY2alJKaU9hTGpmV3hYTFllWllmYmR3V1o3cWRhVjM2SlZtak5IZTBUSzl2cU5lS0NEeUJCWHNnemRlOUJ5STRGZG5hUURKNmVObkNlSWNRNWoxb3hySmxwUGdHQjlXb3R4M3FPRS9hVytOOWtVSEtoL1ZwZHpnVHdUdHV2VzdibHFId3g1LzBJbkJXc2tkeFlVVzlGbEJpNEVpS0k3NysvMDV4ZDBGcWpwejVmMVBTRjBDb0FiQUxHR3dtYUI2d081eXRmNUdCT0tPYUxiZC8vdWFhK2FPZnUyLzhubktmRmF2OWZ0Ymp2ZktxUE4vdk8vSHZQT1ZYdUdLOGV2Y04zZXpaMzBlT3JhZVd2VCtldTdXRzc0emxHYVo1S3dlc0RWa29rejdVYURWa0xqSVF1RmF3L0J3WTV5Y0NIUUVBR0VnVy9yMHE5L1JGQUFBQXVDcDd2Z0oweEhvbS9VamdpRmVmeHNodXNDU1VYeTJINmhRdE92dnFvSmNoRlVyRHRjcjFqanlyRHRLTGR1SWJIbWxjSGU3K1RNUGJkM2hwRVlEVE1VSXQ5enA3UnppTFJ6N01LY2IxaVRpVHYvMEtQbitzUWdCY2dGWnpHaE1jbkpFRGZsZHg5clg0VUt3WEdNQmhlTHZnQ0ZYUGxWbDlNWlg3OVdhc210YUJESWRRcW4vcjIvTDR6akNaNXJHMHJYVjhEMDJ2aFVuOUNzQXNHblVHbHkwNm5DODExTFhLTWo5R1hhNlhqMUlWSmw3VUlja0lYK0ptUHRjQjkwWWJXeGNtZWxCakl1bExzcTNHVFJuRkVPb0JhLy96OEF5NkhlZXB0UndWSTg4WlhtSUpaVEszaDlLQ0hDRlBrS25sTFVaOG5hYW5iRTVlTFRNSHk5TFNSZXZwM1l4bG9SekptbzJVU2E5OTkxQ1dsNEZLK3YxNjZVL1dUT0tObVVrTnpVM1ZQTTZEbkZidFFMK1UrdjdzZzFTSUJHMGZLMjFKZHR0cStiMHNaU1dqTEtsZml4RHZMSHYxbFZvNTJZcDNrVktmakpyZis3SjhJVFcvNnArRis1RFhxL3F2dkVwRGU5bWl2d1dMS3R0WEY2OCtvMm0wdFdEMEduQVVyV3RnUjN0c3ZpTE5pR0Zsa3d4Wmo1WUdSMUh1VDFwdExNMHB6eVVaNzBoTFJsMkFRS1JScGJ5YXlyQjhSOUlnYWVWRUhkOHlYalVaZGJyVzlhV2xXVENYd0ZGb2M4aTcva2pqdDJVOUdvVldadFIrQkFBQWNHN2VMcFFsSVBQaDJXTU1Wb3RFWWRKd2h4ZXJkU0xiUmFsSUR5M3JiR1M5MHp4b05GenpzRW1QUkNTUDRHZzdJdXBwOFNCdHE3eWU1VHF0dForWDduaVRQZ3ZwYTNlbTl1VlV0VUc5RGc2cHQ1ZTBKVkNHM1RKcmlxT01hRjA4dE01WUd0NWpJVnUrTTZ0c1NWNXhwTEhrRlVlK2x2UTlNMWhpbEp5VDR4bHEyQ0E5bTliKzE2WnJkSHBaNDlTN0xDWG1PcWM1S3VUaWpHd0diN2RaSzMxa2hZVGFta2hydzBaTUNDcy81dWxseUdUdnZZRmJFN0tjZENWVFR3NUFPOWFDSXprNnVEUnBuYlozdkdwRmFtdWY1cys1NVJ5eVhCRkxHaTBlTkNQWmNEUSs2aDNvS2ROS241ajhYK3ZrTGJ1WXRVQ3VBcWN6V2psbDF2dUdBd0RnWHRTS3k5SUowQm5kc1B1bC9ObGdvWW5CYWJBMlJEZkhZM3hLMWlUbU1RaGoyZWdlendBQUp2Mzc0UFl5UjdCMzNUM3NVQi9yM1l5M2d6S240bXpyemN0MlBWMDB6RjQ0WS84dTRQSGtGZG1PcVBFNnNHVjVMcXU2TEdSWDNoalMvUjZ4RnB5QkFmZHRQWDJaMmJUR3dQaXNBZU1MMTZUeW8xaFAxeElQWHR4dCtwN29YbzdTbUtQZExwaEw0Q2oyVUU4ZStWWWFheW1YMGtmakFBQUFBSW1XdGZLSk8vaHZ6dTRwaklUUGhDOHphcWtvNmJWRDgxU1hhYVFPWlZCNFM3clpIb3VvQlhva1IvakFaNVJwYVk4bmFsUUFKak53MlRIVHRJWjdITnhTbUhlcGVKaDZPZk50UisxSXJBdzM0YW1QUHkrTzlJTlVUY2Q4NTZHdjE3MnYwZi9nVERUb0pPbjEwVmxEKzlGVHB0ZmVoTDVwcHRVVGN5Yjc4N3NPWDl1Z2VZV1ZRSGhYUVJwRktMd2srUjI0dmYxTWR5SFNsaVBhR3YwRVJ1TlJVRVVPNG41bytSUHZHS3QzSE01Wm1PZjFqMC9aTDZjeWVUNlpsNFRrR20vSWdDTTQ0dG5VSUtTcDFFSzNOUm1wQk9iei9mRnNJS0xIOXd6RU9vMW9qK1VvZDhhL0tTMlpta3NMRk83ZDRQWDhQQ1FiTWoyeXRYUmFtZDZ5dFB3bDhhTXVLc3RURm5jdHlZajBxOVhHbm9sZS9RVDEyL0grTWl5WEwwZ1drbmVKcCtIMHVNaDN1cFVScjIxc1M3Sm51TldtdEg4alpVZ2FLT3BCOUVEckl0MUhZMW1ySVdUTmRaclhzRzZLV2xneUtwUE9oci9GbDUvcDFlTS92Ly9yR2IzdGVQb3diNjVpOWJGV1p2cDM2Z2lYQ0k3VncyUW1RNmJvMlNEeGxwd1VxSFpPYWhFTjFGOFI1bGVPSlIzTkorZXA4MXF1aURvTkNCSVo5cTNUVkxxbVpwbTJKNGt1K1I3bUtlSXdVZXRaU2xlTWRKeWMrQm9Bd1BuZ1hwYndFUEV4U0x1RlJQNjFMRnlKSHI4SEFBQ0ErVVE5b3hHOUhmYktsblg0cXN6YTdWWWx5SUlyaVg0WnRUQTNhdTIzNm5KcFhocVZtR1F0YmRzcU0rSzFDK3pHMVh6UnVtank1SDNEdXNPOWJkclM1c3ZZaW00UGN6UURWeW5KcVdDWExseEhyTFJvZXU4bzVlSTg4UnAvWHYvK2srWVJuWVdhejk5eURyVHVqRk9nVEpyT0c4NmxxOU42Wm5BcjFrdytHVE0zTmxLVGU5S24xSzd3d2JueHFLT0lyQmxqVnl0anRnb1pRTlMyR2FFR3ZLdHNWR1pSeWhqMVRJUExBM1d6STlJOHRqbzAwbW5vMENuTU5DSGVaZEQ5Y0ZYbXlrSXY2L0NOVDVqWnMwakxrS1ZyQURDSjJMMExEcHVtK0pLOXhhVzBuZ3RjT1AyN1RzT1ZmMnRhR3hmc2pqWkdXMStac1BKcDlqV04rNU02cUYwWFdyeVdidGpZcElYUWE4NS9JM2xmSlJrQUFORER3M1hLOXlab2RmdU9WUkFxR096R2lQbjU4QUZyMlh3QW1FUUdqL1JHNVFNSG9MVU5jc1B0bDNaalpxR0gzdGdCM094K2pRR2RyYndOWmZ6WXJLVmExMHB5SFN3ajg3U3hOMUprTmtUUGFOdHNoTis3UDg5MmQ3QXJMd1NucjR2eS83MnlUNEwxc01xNkJpY0Z5dWNRME96ZzdweDlEWkNXMjJnNEFBQ0FZN0JlZ3BlOEdpUFdwM0xnZ21BV2ZVSjN6cDdlck9NWk96aFVyNTFWVksreGt3M1prVEpOUEQwYWRiSzBWdVlzbzJ1MG9vRWxDd0E0aUdFUDl0TWMxY2o1K0Jjc3cvSWtSSnZVazM3V0k0MGpmQ3RXZVhpR2NWRmcydXpPSHZOWGUwK2x6RkpNQU94TndLNlFYa1h3RXAwQ2oxb1RaN3NXd0hBczAvMG92bnpKOU4vUm52NEgwSnlISFJQakhFUi9ibzErQTJjZ3QwV1BHTDZYbUFwMFh0ZVYxcGVUVmQ1NkErWCtjaW9BbzduNURzTXlUcTJUc0xRcG1RMVpPTzBUckNqVnY5YkptM1g0U2ZET2pkTmp0YW1sSklZVWJtbWMxak5GWjZRL3d5RE16ckNGNGt3bjVka0xmNW5mWHpUOS9wcnBKOGV2MG5pSHZBM0o5TGxPZFZCNXkvbTVzcjYwR1lHV0hUWm12V2YyYVhXMHpybWs2VkpEbWExenJLei9mVmV4a2xmL1hTclgydEsyaGRUUi9NeUIxQjZlTTk1YTUzeVAvdkx4dWF2WGVDWmxmZUx0T3ZoZFpyNzd5dVN2bGhsbHI3TlNYWTdRMHljeVVFeEd6bU5GdENZaW9yNU0rUHRacnhEOE9KUTBwS2NLMGUyTWY0NkJacncycTliQnJVOG5wY0YxSXp4YnM2S2s5Y3BzcFdVZUE3QVgzbDF1VkpWUTl6c0FBSURyRXZVZ2VCN0J0dTZVTi9aVTRlV1VWMXptREMvdkJvaFU2djFsbUNSVXFzcG5lZFdvYks4WExySkw5bnJyckRYZjluL0lMR1cyM2wrUC9lemRGNGR0ZFNZQnZVL3ZmZER4OFA0cWJ6SUtyU2VXOXV4S21vQ2NUQmV0M29QSXlMWFNlendjRVZwbVY1MVBiZVFHckpucmRTSkVmZjVjV1RTUHBibEhlckpHTTdLUGRxQzFPU0srenlKYzEra3NPU20xVHlGd0xORWxRRXRmOTMxTGZFdVpOSTEwL1JDR1A5S28wbXVhbmxNZE0xWUNxMXVoaGlZUU5TT3NaeHJvbkVQcHRlRGZjNHpzV1NSVyszQ3BFcTlyU1VlMDZnTUEzQTZNaUMxTHhtK3JhVE55TitTOXpkdXdseXNDdkdteDVUUmF6QUhMcnRUU1VadlYrY05VWDBHbmhiYnk3VFhEU1doVlVBRHNpV2J3dFBpUWdVMmxrNzF1ZXdBT0E1NDFGVzJweC93R0p0d0RmZW1hNWdOdXJ0bGNUMU82ZTk2dk5ybDZaQTR1eTNxNnBxV2xkVEFXcXFsTC9XNFQ4Q0diNzU4Zm80NGV2MkpoYWZ4Y09SK2VrV081MUR6NWU4SFNmeUZHUEJWcTduQiszbjcvR1BYN3g2bDU1L21zYVJDNFRNR1Y2Um0va1hjdlI1V0J1UWFlakdYUlJ2eDZBQUFBOXFObjUzS2tKNE45S1piaDdkNFpVbWpDODd2SlNFMDhjMS83TGxNb29NdHJaenF5akFUMHg2aGRoVVoyU05HeXZMSmFYc3R0K2JuTmtyZUZQYjBvWi9EWVFLbGRFcXhIUUtKVlpVYmpQUEZTZXMvWXBUOXk0dUp6WnhtRG1hSE5SM1hCREFzQUFIQTh3NTVwQkFUUnRHeGV6c1E5VUQrRGh4T3dtL0dNNGtKQXB6UVRmYTd0bVJlYWFUNzZiVkg2dXZmWEoyaTdnNUMrdExCT05YYnlEL3ZSSzNlMGcrVkR3bHRCNDVHTzdlSDZSd1A5QXZhbVk4elJOYlpGbFBUaTd5V21ncURJTXprbVliWHEwSWVRaFJjRndLazVzUjFoNlNVcDNITTd3MjU3aG1FSnpvdmtETk91VDhnWjk5WEQ5bE9yekdReDk5cnc4WUtTL3Nwc0pGd3JvODdyR1l4ZVBQZlJXOWFJVVpjTjJUUmRUOXRiWlJubmJXMk9nOHlyOEZLNHplYkxqL0h6SmRWdHVMWGdaRHJPeVJ0MWhjNExGVzkvalZnRTZlYmJhTnR3MzNCcHJIQXF5MmdIMTVESzY5dXN3MytLTk83L0hheHBTNjIrTSthNTU0bitPdDd5MTVYTlgxbXRYZldONFZWYTNxWG1HMlBackV0ZFlsN1ZRRjdOTEd2V3lrL2pXdnB6RkpIN0hiVXVSZTdYMGlGTGNCYUtMSHphd3RRaHB6NzF0eTVFQ1BXMTRhaHEwTG5Eb1kxU2tIem1pbmRZUzhPNHA5R2x2Q09XOUF1dzUvaVZ0TFkzSCtZV09BcnJVYVEzYlM5NzdVVFNBRGtBQUFEYWQzL2tFU3diVnpQU0k3cVM2MXdJcEMvQWJIYWl4RTNIRjdyT25GOXlKZGVSVkpibDFZbzhMNU5rYWZrODZUaThXeFByL2lKbDFONEtib3NXdlEvT050TDIweW5aZTIwNmhtaWxzdmN6UkZJaG5yMW8zbk5YWXBYbDJXUkh5MnF0aTVSSGU0YmoxVkJTMlMyN1NacXZWVXRJSTl5YnRxV01pRC9hUzBSclBKUzZpWXB5bmFwd21vKzdUc0kxdUJjOVM0YWtRcmwwbmpLc2RGUXRjODd3UFpmQUlDMjJuVGU4am8vVVJhTjB4bnZyUWRXV2xBN3NqR1hVMDNUZ0ZFaldwRGVmeHdLa2oxeWxMUXA5TmNJeVJ5aXdBSUdJZDNBWElVd2Q0SWxkbUx3bWo0VzJPL2FhU2VERmlXMitxeEZ0U2k1OVBVYzhKcnNtS3pGNXRYb3MvRWtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE0eVAvMzkzOWRQNjc5MTErZnYwZitzSG5VTDloTnVPTWdhRGdZZzNTQ1FSMFhPZDREZ0psRXhxQndwT3pvOHd5WE5KNnBkR2FXVTNub2dhT3JkaUduOTd5RGhmQnRRbHBvQW1BTTFucEYwMTBNNjBTcmxrT05SSnN1ZXR3V2VEWWVtMzNuZWNnVlBXSlk5KzZEV2srbUs5MEpacUMxc3FXSVBUS3A3RE1oamFZZU9ia2hmaVNSRFdGVXRHNUJGOS9LOUlwZUh3dFptbzRJem05UnZpK3BlaFhZek1XeVpRNTVGVEpONHoyWm5XNFl5SFdOdUZId0dtMno1bGlrTE04cTRtdHordVhVRVpyU1N4bXlFclhtalk2OUdUcXdaY1BnUFY4NzJvTjc5Z0VqNG1Tc3YvK2JYYXVTRlM3bFQwYjZFemZUZVJtbkltM1pQZlFhODdXY2xHNDNXS3c1MGVLTHlNNTBBSndGcndWUXArMWRuN3hFM081VzNRQUFBTXpGczlPczhkaFpyYyt2UTE1YnhUYW5YM1dwWlVoc1hFWFdad0c0YXlwTEVkV0taYk9PTHF2RjN2Q0dTN1RVM1R1MjRqbTNzWmFYUnNxN1NhZjZKOGs0NWo1WHhBb2ZZZTFaRytLb1J5T0tOc3A2WlBYV1MyS2toVzFwVHdscnArdVp5WFc4Vm9lb1U2VUg3LzNmaEI0RjNxdWdIOUxFUUtERmllYVY2VEdHdkk4MDZ2QUw0OUhDUFQ2VkpJUjd0SFR2aWliVllZbUxyRDVnQWozcmpKVWZIWGc0WHQzQjVVdkJ2SnV0U2VabEppSzcxZElGb05ucDROQlhsbzlGeUJaQ3l3dVZXaEhkaW1wNUg4Nm9OV0hQWm8yc1IvaGlLZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjUEdsUjY5L1Y5dDdibHRSU3BoT1hWbnBSbExhc1VJM2hoc1kxdEdaYUhkd0ZGbTR0bzcycjlKR1R4N29PVVR2a2xQbFZla3N0QzJyTWpROVhjdVUwZ1BRaTFjM2FNZktuWkJpWExmS3FjTTJOaDl0dXg2REV0d2Y3NXphY2J4a1IxaExkVWJOUCs5SlNHSjU5TGk4cnIyUjkyalZ4TVJiZHhDMXVEeEh5TFphY2RFanZ5TG5uTGJDYlhnekV6K1Q0b2h6MXNQNmN1WXJ2QlJ1MDFrWDlmcU9aS2xqdlFONzNjOThWUW9UVnVlbGVBMkpsdk40dWRQVkkzV3cybVdnUjZjUVkzNnpZVWpyNjFLbEU4YkNKNDNYYUJNcng0UjVOV3dXNnRCcVdHb2x2c1lseVdQM3BqMFhjeVdmcGkwckdiUk0vVXhWK2xYWGJabGJtVko2R1dsT2VlRnE0ZFZmWHYwK2NoMW9YTWNZUGJhWmYxR1oxRUZTcEhSMUlrT1dXMmZLODBEY294ZzFvTEtrK0JPWXF2ZWhEQXF2NDFwTzQvVXlxcE1QSEN4ZTdTYmxxL042cllpZTUwbFduaEhkQ2tBUDJrcm5WV1ZXdWozR3VWUkd5dzRGQUFCQU81YXRGdlY4Y3Z1a0tDRXZoN09RdDB6QkJmaE81MTJZWHU3dFV0M296eGRqdURLRmE2c0lEYVZhYW55TGJWNmNNcVQ3dGJaSkVhK0k1Y2V4MmtXTzRUeFJVbzZ0Ujh0VHRyaHRMTnV5djcrTSt1T1Byc1lXaTlsb1VkK2daMlI1UjZ5M056aHRFaGtWSHY1VThrYkp0RVo2TXNJOXRGcnRYTGprS1pWa1c0ejBPN2FXZFZOR0Rwbm80d1lBYWtac3pxM0ZVbkt3SnlIZHhZbXNwcjJycldWUHR4QjlwdUdSNFkySG1ocklLT2MzTndDNGdWZVVQR0E0dmZ2RWQzcVNnZDE3Q1h1VmFGa0F1SWx1ajZ4dGt5SmlGRjU1bk5xTW12YVhwZFd1aktSNTZQb1QxYmNSL2EyOWR6V2lMQ3Z2ZHo1OE1SVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFMajRvcitOTGN6dlhPbjVad3VSczlTbW42Z3c0MEF6MElmbnA5Wm9lM0EwMmdrY3pLa1BxK2ppRjlWYUxlbjYxRWp0d3B6V0V6NzBnc3FHRGdHamlZNnBFNC9CbHJOc0l5ZmhTUWZqRkM0aGgzWDhNcmdYa1g3V3hzd3VHd3ViSTZzUVBUUGJrbFdvUkpjZzBxR3UrZXM5U3JYb1pUVnBzS2pGWVpVcDFhR2wvTmE2U2ZtMWMxMUh0ME15NURzV0ErdkxxRVVvUXpFQzZ5OUlmcDlnTDU0YTlwS3hwTS8wSzZ6MHhFbXV6SjlQTG9pcm9ZUG9XUExJa3E2OW5oM3Z5ZTFVVnVBb1BPazRUM2JESUZnY3krY3V4R0s5eDQ1NzA3ZmtsZG82Ry9rc09iL2psci85OWJqZXhyN0crL3Q2YTkyVjFYVXRWWmR0dFVOUjBsbWp0MTB2UjFiTm5QUzFxclgva3FNTzB0bUYwVFhRcWxQV2t4Vk5KbW16emRlS2wyVFdmWlUwYmgxZGgydGFxR3hTeE5yUUhxTjh6YlRXdURXZTRad2F3NzNsY3RkV2VDSmwzcnpEdkUxTHUxT3pOcjFsV2RhSUZMYmtqYVFIWURiY2lsbUhlZFlDUyszMHFpVnRCUnhSQnVZZkFBREU4T3dHclcyYng1Ymp2QmZhWHNYWUJZcHlPZXF2czlUYlJNbVZWcHhiVURHZlVqL3ZmY3hjejd4YkVIbzljbDIyWkpYZ3RaV2Z3N01QK0UxWHhQaGZuOWpheS9RN2ZndEpaNVFsK0tNemljOUY5cEdXMTMreWNmZlNWNHZlcnRHOCtOeldOZEc4ZEg2clRocE5udDRZc1ZHdjh5V2xUbDZma1ZXbll1U1Q3dE56L3hMV2JQSE02R2haV1pEZDJtZmNTaFR0NzlieDhTQ2NybHNScTVzOU1zQjE4QzZhWEJycmNZTVZycWxuR3E1ZDB6cWRGRS9UVXFTVm80NzN5QjZ4TW5obHQzU0YxSzNnQUN3VEp5SWpKM1RtU1lqcUg3cTN6cFlKV3o3L2JLeEl1aDJTOXR4R0VRQ1llSndVM0hhd2lpL0NvUFB1ZHJXaXZWelkxSWtoMlg0alhCRlFIaXU4bmdqUEZLSmgyVWh2K1oydGNNM1d4UmRUQVFBQUFBQUFBQUFBQUVBSDhDTHVEVm9jQUFEQWtXQWRBZ0FBQUFDNEQ3RHRBQUFBQUFBQUFCVHNFd0FBQUlCZnNDWUNZUE8xVEpWUy9jUjU5WVdSOS84K1lkYUpmZFpwTGkyL05oZlJmbDBOOWtVN0NRbUFzMktjekxBS0x2R1RvMm9adDFWVHhnMXQyaUhiMmNXUFQwbENBV2poWmlleWpEalZKREsxaWxaNExjaHplaWQzRGU1Rk5xNFhJbU5tcDdWQU81Mm81ZXpsMXJLOWFzcTBQN1JUeFlUVHg4eFNDajJkMll0bnNhZHByZU8zUEdWNWp5V1d5bXc5ZHkyQ3BabWptajVTWmhMSzFrWTJNMmhLbGNjOE5ZM2tKVWMwYnV6SVVtZGZueDVmNnFNZlNXR3JVK2FGVHkxOHZweTZ6Yitta0NNa1BXMXY5WnRIZTR6VUxONHlwZlAvdUhTZUtnaGwwWTR1VlJzdlgwaGRFb3FmMHZCZWU1Q09BNlJIalVZWExndTdyWXNvTzI4a3JHVm1ra3RLdjg2VG1id1MyeEhWTW1aejV6VXRPNXErTlErWFRwTHBsVi9MQ0s0ejlPaGNWWHhacDl0TUlXczlFdkp2MERZS3dmdEw2elhpVjhKbk0xS1lzdVVTOHFaMmNpcDdYMFh6MEx2dDFlU253M3ZqVWxvdHZDVmRWdXJra1hHN0Rvcmg2VTRhTHNtSTdtRm8vcVRJQnVBc0dJOFhWclNxUUs4cVRZNjZXT3RSMUxvR0FBQmcwNkl6OVYxL1RDOWJ0bHpyL2tlbEtMdGhzamh4SDZRVVBtYXBHcHFaUzgrVThYWXhDZTdJV2g2VHpJeTNQQXNqN0djdW43WFg3TjN2V2tSc0lrOWVtY0plMGZzM3ZCZU0zM254Q2YrRzVJMVBwVmhWMmRhSmpPZFAvQkt4L0NQNHFaVXJHYThWcDQwNmFVTWZMWnVUeTExSHlyRXNhcy9NSENXVEVobkoxb2l0MDJuWDBYQ3ZuMUlLMDRpbWZ4Q1dqOHg3RGE1RmRHSDJMdFRKU01kaHFUbFBYa2x0V1E2UUM0emZGaHZJdEROSXVKVmZTMnN4dzhhVG5tbEU3dy9xYXdCZWswN0xLMTJEMDJEcEVIWVBXVzBwVmhaZWtlV3Y4cWRZM2VwOG1PTmdDTm9Bc2dZb0dZUTlPN1pzWER1cmNCK3N4YjVsKzl6cVlyZzUzbUZ1d1RVNTE5UTl6Ujd4UkpoZlRNMFlBUUFBQUFBQW9BV1lrUUJjRjh4ZmNFc3dzTUZvTUtZQUFFRGtTQlVKOWJ3YmFHb0FBQUFBZ090eUJsc3VQOHlnaFAwOEQ3UXRBQUFBQU1BY1lHY0JBQUFBQUFDTC9IOS8vOWYxbzlwLy9SVTdPZVZIK090ZjYyQ09xRnhUYUxTUTVrcUFINnpqQTd4NUFaaEI2MEdPRFVWSXRKdytkU2tLZjdrNXRFazYzWmFoZmdpSkw2ZUM0VVJ0aUdpZWc1Q1dYeTdjZXp2aDI1NVJDZkFzVGpRdVBNT1p4cytxdmphRnpNT3AzQWtqTmZFYStaN3p4cVR3MWpJOFo0K2U4ZEdKOTR6UmtlVklnOElLand5cVRLSUxDWllNUkg1V2ZVck9yMnRsSUVzR3BmUlpCbklxL3ZhcmZ5MlR4dU9NYUpVZHBlZWN3RHJPVTFlaFg3MGJCSzN0NlpkVHhicjFPQ09zYzBPam04dnN2STZ4K2dJd21SUDBrTG5DNUpiSlNwbWYvOUwwMWwzdVE2TitFdVhVNlZxZEM5SDBNOG9vNjNubktZck9NL0dUTmpQV1llL2NXY3VqYzBMVEVCS2VrYVB4V1BkenhMemd1ODhmVHRQY3RsR1BJN0lQOHNxS3JBbm9WbkIxV25hL2RYaEsrL2dXTEk2eDVRQUE0Rmw0ZHFxUm5SWW5hOFEreUd1eWUvWlRrb3ptaFlmSlI3ZTlSOU95MjIvaFRIYTAxeU82VURyVGVmSllRNng3TEM1NVZ5NFk0cTk3UlpSWEdabjZTTjlGbDVWSXRoRHhXczRad3hxNVBXVkduaHYxMHRLaHMzejZYa2RIQ3hGTkhDM2JXb21BeWVqSG9wd2NjRDBHckRmdTZ6cWNLN1Bsc1dCMC9GNkUzdFhJMjYzU1N0aFRabUprV21WNlpNK3dNc0FFMENtWFJsVFBKRUpWL1hrcmt6N3ExUXJmNkJMaDhUQUEzWXhjQkFYUkxWV1EwdEIwbGkvc3RrU05ISEFxV2szM2lJOXRDVE8vbUFvQUFBQWNDb3dWQUxvNHhSVENQQVkzQXNONUptaGRNSXNqeHhiRzlYNDhxNjB6eHRaRTBMWUFBQUFBbUF1c0RRQUFBRTlqeGsvT3dIbUJyUU1BQUE2Z0xBRUFKd2RxQ29Ecmd2a0x3Qmd3bHdEd28zNHh0VDZKN1Y5L2pabGF2U2ZMaUl3VTJuTXEwUlBvK1FnQzJoU2NEV0U4cno2cWxKd25RT1Z0M3FUa3UvMTAwSTVIU0orNEVta0k2R2N3aTV1UHFjaWhoeVB5c1VLeWNRMmVRYVQvcDIwYzJobDVjbmRydWVHcDVEM2l5NU4rR0JPT1BuT2R5NlNGenl4VHlwZVU5RmM2WDAyNGIrMHJwVFJOVm96eE5HaFk1clhoU1UrdS81dzBPZUtvWUxFU2lpd3R2a1hMU0dlZWVUV1pWbGJ3dmplbi81ZDFlQ0x4N1BHZDB2MkloWFdHMDNoUFh1KzhiWnZmMmhlQ1AxOU0vYVRtdytObFNUK0E5YTVEbm5YTFA2S3NVcVA5VHVOYTFvaFdmUjJwZzNXZlZEVFJ2K1oxWFlaWDMyVCswbVdRekYzYldqU2sxWS9tN1hYVTVmRkVobDV3K1FGOXRPbHBXY1lpaHd2M2dPNEhaOE5yQ3kxcFdzZTlKYnVtWldmaXpkc3pmd0VBQVBCNDl5N1JQSFZleWF6VzVFVS9ndEJqdXRNdHFyZ3o4emdYcER5MFRzNXQvQkw5ajFFRml1UVNqWGlZTEVic3NLMG0xRHdSMWhpU3lscmE4azhncnlTTG84ZEwrNVpMdjE2cXZNanc2MWYrK0RtcHYvbjlwVlNwVk5WWjV2RlhlWHhJRXQ0UnZjU1ZwSThLcnl5ckRPbWFTNTlTZkJTMTVKdFZGNnRNRHE4VFpZUTI2ZWxQd09KZGdHbWFrWTgwd0g1RUhRRXR0azVVNXNoOGd4OXBIRUdMTGV0ZEVaSWd1NmNaZW9jVURhZTB5QVlueDJOT2d0dkJQUVplNGJRak5xL3YxR1VrQURxd0Zrc2xUKzh6alZtK2lGdWlHVU1wK2JlbWtteGdZcG5rUGR1RldiN0ViL0RGVkFBQUFBQUFBQUFBQUR5QXAzbTQ0TkVENEhwZzN1NEZXaG9BQUFBQUFBRHdkTTZ3TDhvN1ZnTDd3SHVEL2dYendPZ0NnOEdRQWdBMEFOVUJBQUFBQUFET1RQNzMzLzhwbVQxOTdKY2w5RjkvYldQM09CSFlaTVJKUWRNcWQzTU82WEFBbkZpNndha3oyRU1meU1reWtzZ2V0WFFhUE1mZEJBOW1MTkFONEN6MEhDUjdBVHlIMWxqeFlkWFpjbXdnZUNZbkhpdWVNNW4zVWhtUkV6YzllZHdaTmpjdVdUZlc0dyt0TmVVOXFFOW01Tml0ck1pUjRyV3llaG5SRHBFeUtMM0hMbnNHVFpWSE0vNHlOUkI5QnVYcWE0Ny9rN0UrdVg1ZGw1LzRWVlVLa1Voa1pzbG8xZXBtalcrSjZNcWNBbVY2TlZWRW0xaGFrWW9vSkpxMGJmWnNFS0p0RzlYUVhQcFIrc2k3R2ZXVnQyMEYveEdGL29NTGRkK2dYVE5PdXNVTUhUaWpUTzlhYVBYL0VtZlZ3ZCsvSWtXUllTN2gwYlhlbzBzODk2M0pYbDkvdmp5UzJWeHBVL0s0dFQ5eTE1Y20ycjFjT0kyM1ZPS2VIRm4yQmZCYU1xVXg3NUxmbTgreUFBRFlDOXVla2xWaTY2NmhwUTZVVVRzVUFBQjRNdEhkYjBTWGVuY29YaStQWnlkSzh5UWxiNTN1SHlGZkJPK3pkZ3ZQTHUrbkxKcXZyT05INHJVSklySXM3MVZrNTkyeTI0L1lFWlk5UW1WelpTWWhYa3JIeWZiV0lRTDFRK2ZhNTFrK1hvZk4xNFVFRittU2dXMlBWV0xQekgyWFpzUmJTRDBmR1dVdDNHSEhGM0Y4ak9nZjdqbzV3NWU0MGYwSXBvSXV1aGRkQzFMMWQ4VHdzQXpMVmtNeXN2alQ4SWRnYWUwOXlyVFNSbnhHNEVDc2p2VnM3bUFDM0lydStldDliQ3pJd2xBQ1UzRnVoNlBtUm8rcTlKcFBqNWtQSG9NRHl1RXdva3UrMTArbmVSYk1MNlppUEFBQXdCYm9SZ0FBQ0FDbENjRDF3THpkRVRUMmJJNXBZZlFybUV2R0dMczU2RjhBd0RXQXRnS2dEOHdoQUFBQVR5VWZ1UWhpQVhhRHBnSUFBQUFBQUFBQUFBQUFBRmg4ZmJzU3R6OVUxbjhmVzR4cmpsT2ZiWGIxZzlmMkluSnNEOW9VM0FCcEdFc2Y5TG5sc0YrT001Q091dUVvd2lYMEFqZ0RKUmgrWWJoRGc3elQxOVZNVkRkWVFnSDRwalRHVFVZYnp0NFQ1bWFnbFcwZGF1ckNuT3dqNzF6VFNEbVFqNFpIem5PcWU1b3pjcXc2ZUUrZHJ1T1NzMjdSc2oxNWVzdU1vUFNuOUFtRW4yeUZTRmxmMjdYTkx4SGIwOXVYM3YwOXhWNld0UG5xWlBHT3VXMloyN1FXUWNNNmxEWmFoNTZ4NGR3d2JLcG8xYkZsYmtYSGJ4SEM5aWhieXNmM2hUYmlaRmw4YURFa1pQSCtQUnZEaU00c1Joa3BXSVluWGp2VFZidHVyUXRGMGlHUnRxWEJyL0RzMGIrbEtqSnZaYmhwOFFhUG1pTzZuTFg5OU51MlpSUGo3ZDg0clhkNUtydzNFZkVaUmNQMzRCYWQxWStreGRaelNjODd1bXd0TFFCbm84ZWF4QndDQUlCek1HOTMwRjZIR1o2bVhwTTg2Z1dRMHY3NjYrUjRUYlpVQjlXN1RCcTNDSzVBNjRleW5uU2VOdWI2T1F2WGFuMlMvVXpENDNXM3lyYkcxTXp0b01lVFpJVVA1WCtEWU5XMmhTOTk4NFZVa3NyczMzcThwc0trajFpYVZpMDhMU3FONEpIY3dWcU5PRk04ZVNPcmdyZS9xWGJ3YUF0d0dueVBFY0JWYUZWN0xZOVhXZzNMRVl3d0lHK0ExUVV6bWlIU3phMzdnUlliRm5UaU5hQjcwNERMRUoyLzFwUDExckl4LzhFVU91MklGajlIblo2K1dhQ1Y4Vmk4amJta2hiTFlGVXRQZXoxRVNZbW5ZVi9KcFB5OGtPWng5aDNDakVIcWJXSHdvZGJBVW54S2FGT3dIOW00cHVGRUE5Y1BwU1Q5SnczcjI2MmRyVGNVbWZlV0R1SFMxN0toWTRBSDdabk9UY2RPNysySkc3TjYxeFhScndCNGlLNEpuWng5T0U5cmppNmgwUi9mZURZSzBiS2pGaGpYMDBlK1JMRm4yVlpaMXNpM3doMHU1OVdQbjJnZUJmcW1WMUhLcVg2QXRlM3RrUjR1N3NXTktOYWp1cDRKNmpXVXJmbXB4WFAzemJSeDN2emhKSkxlKzRwWHREM28vYlJzVmxxUngrdTJkelBKV2RUMG5wSy9jOGsxNko5TG56cFIzZUZaa1h1UjlKWFc3NzNXUVRiaXRQdjJqbSt0aUk5dTNQQWQvaFBQWmt4OTlPZ3hXb2NpeEdZMVoxSFgvcElXbi9keXRZNzMxWXd5dy8xeEtEbVl4dU0waytLakNndnNnalJlVzYwSUtkelN0aGdXNEV4NExZT0lSUk5WaVQxdWQ4d3BBQUJZMDZPM1I5QzZHejdTZk9aMlZ4NW03UHF6RkNnWW5LczE4Wlc1REdyRTRnaHZ2Vy9KTytEeFdramhVVzhHWit0WWRhalRhYktzK0tVTXI1Y3l3c1lPZXcyTW9nd01zVzFmUGhqdlBtZ1poRm53OXl5U2Z1OC8yc29qa081a0ZDMmFiS1NsWE9leGZJWVJvck5TMHg2OVdrT2JnZEkxT0J6NHpJQ0U1b2M5aTBFWmZXUjNNMXFiZEtSOVRMSGtsa0JlcUNFQTVqQlNIZFBId3VJK2F0a1BwelpHN0hQQnc3RzJMTm9nSzNHUlhpeGZpQlYrZTd6R1FZc2pDM1NqYlJjb3M4YnUxMmYrU2t2UXI4T3JQR2trd0lxT1V6cmpBZGdieWZsUnh4bkJuZ2RNajJabVEzZzdBNEFhYTlOeUEwWlBCVkhlMHBiWkdRNmVTOHVnM0VtbmV4NnBsN1R2NWl6TkxNc2xLUG9hU2ZSQmVuTG1UNEU2V09ucVY2V2k5eGVOVDZRc0Q1SlIwL09ZaUVzN1FqRjc2OFpsTGNuODdBQ2J6ZXZGZXBWUnhhN3YrbXdMMDRpWjdkMk50STdGYU5xc1JIZU1IZGU4N0puWFdqcFBYbTJWNkgxeHlNYmZhNzZVdVhvVnJremE4Y3F2NTNGNk91b3V0ZHB1cExIYTB3NUdIVGJScEN6cE15MWNlSW04VnFCaGpldmVjYy9KR3BtejVWV1FiOGJQeHhFclFEZWp1MnVFZWo5Rnd6eUwwaGpYRTk5U0pvWUdPQnVTQ3UyMURMVHJIcUt5TWVjQUFFL2o2RjNpSGw2Y1dVVHJFR25ycnJWUmVzNWZ2NXhyYk1scnNpS0hUVUNDYTA5eDcvYkowdzZqeGpNbnQ4WjdYNk84Z2EzN0JXcTdXV05MKzBHcStieUk1TFg3cTVCL2Z2L0k3eCtzNXZUN3BsNnVjcERySDcvN1ZuS21aUVR3amFFVzdXbjFSa1RHU0VaYjQ0Rm5HbW1VM3c3Y2lxZ3hFSEduZzJ0akxrUU44clJyYjF4RTlzM0haV3RYU05PWWkyOWxqMVZYV3VtaGprN09yQTBFT0FSdU8xUHYzVGJwTE5OYzJlOWk2SUF1SW5hSDQ5V0tVWGpONmFndjRqWkU5eXBSMlZBcVhjenNIaTgvWDB5dFg5YU11c3E4Y0l2YjdweWlFaGNtQjlONGZHam9EM0FST0lPajFYVittK0cvcHhFdzhrMGY4R3g2Zng5dzRyRTNjdGwxbmZZejhpbnpSamdBKzJJNUV6SkoxMm9EUk5FZVBBd3Q4MmVmeEwxR01uTUIzc3VRME83SG91Zis2ZWJUMm94YW1yZUYxdGVlQnZmTk1yYllINmV1Nzd1OXhiY3AzNzIrbkhMUEowdCtiM3UwLytzOHJUUDNMSXVqZC93NnhOUi9tRy95U1c1ZnpSUHROVkMwdG0yOTMrZzhicDlyY3UxOVkyYjdsY2kxaE9JYWN6bjExMDNxRjA2Q3RpSW5SVTRrYmc4TXZheEdCM1VDKy9ReEc5bGIxMHByenN5M0lXWnFTdXN1OTd6N1hmQU9BNCtaTWRLQXZtUmpYbzhaczNXa2xRWEFFOEZjQVFDQXVlemhNVHZTbEkyV0hmWFBSZHFsZDhlWnJjUkNaVmVlaU5IUHNLcjlVSFpVVGRzK2pXSkdHWFVmY0UwZDJSYW16blFwOGQ3M091OHMrMmwxbi84YlRLVzBibTRYYVV3Wi81TlovemoxVTNaNS8vc1QvdmE3cHc0ZjBqcmo5aXV0QTN6Q1EzQTl1VmJDZTUwUnJYazFKTStzcHc1ZVRiMW5INEV3clF1dTEwRzV4NElENWlHTmp6MzYxWHBVMS9PNGxJWS9GT24ydGVtOXg1N0ZTK1NKSzlnWno5ckNwY0dhY1FoZFBnWkdINHV2d3BUMnNxdzNLZ0FRYWRtU2NSdjlEaHVvOXcyaDRwQVJYZE12UTlUbXEvT2xocng3MnJvWFlROVB4SXltL2tvNzBkMHdrbktLdER5c1h3Q2VTOUJIdTZ5cm1Wd0RHOHZvQXVBUXFORWFOV0lmcGdDOHp6TUEySUJCMG8xbGYxalg0TXhRQy9OR1JCOUNUaHk0bXhidWJ2SWord3hldC8xNXhnNXc1c2p5dDlvVnh2YU1Pa3BqSzVOb3B1em9rTXpWUzRxTDhOME1pU3ZNb1hqL3R0elJyVzAxT005dVJjdmFVRHJqRnpCMEFJaWh2WGFPdVFRQUFHQVczdGQxZW5iU1h2dHl4dU85NXVkaWVaMVdlaFNaTzhvb0RYR1NmZC82YnFERkl6MllUVDlLL2Nub1RKUFhaVkdudDJyOHRkYnRWMmplakZ3NnN1djBBSUJUZ0EzaHZlanB5OTV4b0JsYzNsOXlhT205WlQyQWg5OCttQUUxMjd4ckF3YmhJWFNwK2lKYjZDTnBlVzRFUUJNN1BHdkdlTjZCQm5mSEQ5akxiQmpWSE5wYU1jTVcvZm9JTDFVbDhpdU1KL0piVUM3djFMSFRVem13aHJiaHlMWkYvNEFMSUsxOWtuS1c4bnZUWHdidkU4YWVnd1BvWWdHZEFYcWdKNnJRNjVxYjJoRzl0eU0yU3hXdyt2Z1MzdGdHQ3hlYVU5S2o5SHJ0ZDU1djBWMkhydmY3TjI4RXZRS1dvK0FMYzZmdUFyeGJVU3VkcDFWYnp4MnprSHFhSzJQR3dMWE9TL1BHVysyaFdhMnRiWmYxcW0wdkZGSGNlTFNsdkgwVmRIeVRmT1dWdHJ6KzkvT2VUcmJhOWxQS05yNmVsZHI0OWU0WXBMSG1lY29iZllMVStqU1l1OTlvSFpia1ZOZVVXSHl5d2oxc2xDT0o1OXBlY3RGNTI4NWJsemhGbVNYcmRIejRPczRPL1pXUVg3SDh1TFcxa2xmUHJVdmwwMlJuZkEvZWpZSkhIOU8wVkZlUVBNYlhwVU8zWjM0aFZTakRmVzNKcFBjWjBWODhjZzNxRVo5SlNiUnMzdmY5dVV0cEx0MEVyNXJ5NUxPV3doRStJNnRlWUJpUjJhckZ0M1J2MExvQTREQWl5M0RyQ21qdEptaDZLeXc2RjZONUFBRGdiclI0RUxUMFdscWF2bGNQYy9tanNuclhnTnFMMW8zVklJYTdybllkdm9PTnZjckc3WmhKdUhGenkvMFhjcTBVdVNsN1V4Y2hiUkh5Y21WeitiVnJMWDNFTTFDbmw2NnQ4QmFabXZlV2oxbDd2UlpmTXZ0RlZNRzR5NjhEd2l3ZDhvbW5nNnRzYXZQajM2aStqTHE0ZVVvaWhRaGxldlhZZWl4dFc2MnVXV2JxNkNNYmNkb0k4STZPR2M2STNyeGFhM05JTTF1VFlmbElQVExCN3ZRdTBKNUhHbEdGRGU2RlYyMXBDMWFyaXU5UnR4ZkEwdXpSZlFUWDFMMitwR1NFOTJEYldmdzEyQW51VWFxMlFiVE1DSEJhNk40emhEVmhDL3NuZTQyaEFsaDZCZzU5MXB5RXZNdXJFMWt2eWhQbkRmZk9OOHdMQThuNEFVUGhmSG16eS9oYVIwVjJGRzJFYjZ4M0l3NEFlQ2FUTmtuTnh2d0RRTHVBVXhKOXp2TFFnZHlzTWl1bENCMEFXQzQwTU02d3h0TVhWb1pTQ3ZIR0hMbWp0MXA3Wk4yZTZybVEydmpnOWhnMXNCdmtGQ3hVUWViN2g4N0ZFZmQ3cmphbUwwcEduZXl0VHZrUFI2N0VlL2hFSjhnV241Q2NhV3pSdHQyam43TlJOcDVxTklQbUF4WGFiRzU5WlJoK1Z3QmllUHg1ZU1RS0FBRFBJUElvekd2V3R6NDN5b29zR20vVnhiUTNYd0t5a1NkeUQ3MDJibDBtNStzZjdmbXV5Mmk1ejVIMXVkYVdVZS9SN3grRDVyYXNnYUtYdDJoSi9QdjNxbndONXV5YnRMZUVQejJiU2VsWmxhWDkvRWFMQi9OQW05OEsrT21laldjeGlEcm9vbkUwL2tIanNiWHByZC9YY09GMHFtUHFnNkZnTUYwZVV4OFpDaW5UWDdkalRJQzlzQmEwd01iWFduY3hyQnNZNzNSWUl6a1AwVmxUMlBPNTMxY2hUcVQ2UithMW8ydTBjeXNzTHh2WFVSbDd0dkxWa1l5UFVWNTVBUFpnNElLbEhCRGpDcjhza3FWR2JqUUw0VjFsUWErQUZtN3FCTjNqdGtKeXJWT0t3TE93VHRNNytUaWh3OW03NXMrb0F4Zk8xV0VUdnRrM3ZRSytQWTdjTWU5ZE4rVjl3V0JWb2JRdVhMb2pDYXNscE9zSTN0YU8zRGNOeitUZnFBelAvZVdrcnhyZXpnOTRvMStud3ZQaHRRd21QcVgzNmUvMDY2YnZVK0hmVlhIVVhSamY3Nit1bWdvcTB0WTB6N1pVWFhZeDhuTjVSNlhURkRRM0I4aThyZnQxNmJjY25IOXFmMFlORFd2ZWVwNndXOHJSODRxbmxxK3VrKzFkTGN3OC9veGp2Z1Q2Nmx4bVpYMWlsL0JTeWQ2NjBBb3AyNW96ZkR2NFlwY1VWS2FldTYxdkxIMnM1ZVhrU0hYbTVGaVdCeTNDME9PcnIxRkw4N2UrNW1SSjYybVBkWlNGdXZqV1UrcW56a0o4TGF1UTZ5UmVGemFmUE5Ma09tY20xZW1KZG50RUhWdGxndDF4YXBwVldndHJ4YXpUYVhMcjFWQjZGZ25BMFVoMkZ6ZStKWXNtQ1RMcXRCNnNPYVhKODg1YkFBQjRDdG91MGZMZWVEMklYQnJOTHRMd3JCMGV6MGR0ZjNuSndXdGFaaUpsYzNXaEw4VnVYSUtKTDJBbGsyNlZOMytzaGEyMjBuVStrcjRvQnJXMHZuTGhuTzNic3paTGJhbWxUeWx1ZDFqMGpDMnBMTmwzVk15OFZJYnRVZHFtYUoybjNuUWJEMUxBcDVxWnYzNWxGalc5OUhQYjdiYi85YlhXcW1jL2JmVG5sWWN2UzVrcVpxbDhHbzlXczdCOHZkb00xdXBXeTI2eDdsdXRjKytJbDlJWEpRN3NodGVRc0thQXRTa0Y5MFZ6K1Z0cUx6blRXbVZTT1Y0RDBSdC9FaXh0M1dyVDVXQWF6dDd5cjdzKzJSRmFWMGd3QVcwVGV0TjUrWFFpZTlEZWNqUThUM3NCRUpIc1lPbDZzNGxPTEpGMTJmdE1zbld0dnkyOTltUVM4cGNFWldJUTlVU01YQ3V5bzR5dlpEaWVaaEcrSWNsakdLa29OTUlZTVBFQkFBclliSUJUMHZ2MDhJU01tR00zYkJad0ZqeTduSlBBK1RYb3l5RjdWMTk2WVlValhyZHNsSHIzRmZ3TTl6bWpiT3VlQnBhcGZZbXZOSmJkTWNDbCtTcjkxakUrWjdBQmRwR2Ywa2I3MytmbkpiQVpaZWYzZjg4NzBtODh0cVJHcCtHU1Q1VEx4d0lkdGdmWVF3RWdZODJQSEVnTEFMRDlCVG1RRndBQXdIMlJ0cFpXdXBaeUVsT1c1b1dlZ2JyRzVYVTZUeDBpYTJiMGNjZ0lYei9uRTlXZWFVUnRnT2pyV1p4dnlXcHJTNmFlYTExMlA0T3NwSzRIU21YOTU4dmZ1cHdGeWJ0Zld3dVRmOEQ2NmJkU1hiZTBzdFhET3o3VEFPRE8wS2trTFE3Z1B2UWFFbTBMOERwdnRJeWVNazlBcTIzbmxldWR0bDFtQnJnMzBQZVBZNWd1S0hZMGhoWTRGUjJ2bjAwczhubTBOckxrTklLUjQ2WTB4bW5wUnBycVh4Lzd2LzVlQ0tiUm81RTJoMXdhYjNnMjRnRVlqVk9OU1FxMUVGRXpodTRscGdWdENCcW1rZGZaM2lJOVJ6QXMxOUFaQUd4b3NkS3M2ZHRzK2UyaExNRzFPZUZpNTlsTVplRjZ6OXV3WGhyYTFNbTA0Wms3OXFSaGhVdTFzRnJWczdoemoyQzBlQXZPbUxIeVdxLzFaaU05VFZQZnQ3ZmUzbEdYbVRLa05ONXdUMTFKV2U4dnBaYnFXc24rL2hUQjhrOTVCY2RXcEZMOXUvVlh4WjU2eWwrQnJQT094cHk0RE5FRjErcG5yd3d5eGxaVGk1UlJJdVBXdXU1OXl1MnRneWFyRmFrTTNhR3kxbHI1L1c5UjhsaGZBaTRPL1JlOVcxcm05aXV1a1RXaVp0MENjaHdYbjR6MFM1NWlwS0hwdFhCcjNSSW9yLys4WHpRc24rc2xQcmZxYVVjZFRGWGl2YStXUHJES29pWFE4V3pMNG56YlJaSHQxU0NTenp5aVVYZERHdjdjdFh6RE10SGxDQnhPeE5xZ2VXcGE4bnVIR0lZVU9CUGVuV3RMM3FnVkVaMGI5ZjRJQUFDQW42aTlGUFZFakt5RE4zNVpFNG96SFZlWEtFMHluVGUrV1VNWEYyTlpweWxjcHNSc3hia3kxbTVMZDEzMmdKWkpmYUpjMmpxOUZCOUJzek80TXJrNld1TlJJN01oeFpSaDdVbEtJTWJpTTdaZVBnZmlLMTE4NEtVSVd1VGRlQ1hWUDA1ZHAvMU5HUFZmU0h1d092M1d3emQ2NXliZlEyYlRjSGxIMWVIbGozdUhGVWVlVk9YbHdpV0tJMHhhV2FJek5wSXY2bThGd3hpNWdFaGRqdTRFTlpJS0hlSGlCMTFvTmgwbDZ1S1g4cFhrNzFxdkpRQVZkREE5UmphWERoMTRDZGo5YjlIVEp5NEo2ZTk2WDZ6dEFTbThiUThlUmUrV2pRNml5WU1xdW41R2Q4ZTNtUWV0eG9DRXg3SDFVQ1J2Z0xWTUgrV2ZwT1YrSlNlUlY3WjJCWnNmQUlDR2M5TkVEV2pMN1R5Q2lORitHRXRETkZUVVdoZ0JHQVlHMXc4OWVndE5DSnFoYTRUMERCVjB3YzN2YXpYdDA3d0hEN3RmejQ5SnZRUFlHTmpmTCt2UWwyU2tsOXhhWHQ0R1oyT1BYZG1aT09aKzEzTW9yOEtsOU91VWV2clVtRzR1M3JhZW9jOWZaZGRWb0E3M09yeG14c3RLZ0VVYTUxSzZTNENIT1dBU25oODZwTVo0QUVBN21GOEFBSEFjSTUvL1duc1RhOXRvL2JSTDI0SktMMEpKWlNWRFpuYmtEZnNpbU1idTlRbWErVjlsSHJIV2xtQWFycDlwT3F0ZmkxRldGcTY1Y2REenpvQThyM3pTdlB2OExrb2hEVkxrZEd5NEo5RElhOTZndC9VN1hoSUpjZ2FQNkxuWW8xNVNxOE41Qk1DdGlScGdtaUhoTFNOcTNEMlkyU3RUcTN4MEVRRG5acU4yZTE4Y0ZSd0JYaDJ5M3k0Q0FEK1dxVE83N0Z2TWg2Z3RtSjB5b0N3MlJNM3BpS3hlUE9QNWk4L29kVm56cVliZWlPVXRIK0hGQkd1eWNGMk1QSlpYR29BemtWZi8vQmpsVkowc3c3cDMrR3BUNkJKVHc5TEQ5UEoxVTlJaG45enB0ZEFSWUJyY3lUbWFrWHVoc1VodnEvNVhTeHRoMHl4Y29lQzVjRCttdUFEUnc1bk93c2RtY1hnRVZUeXZBMGtiZ3NTWEtaSWI0b3BSaGxRWEdxOVpYdDZIN3RHZm8yaDFreXhMNzRpMDJxdmxGYUxvWmp2cjJjUzYxYUtYdDdhS2tNT2VlVFJOcnV0VkdaamZKOCtYK2l1dTR0and6bll1djNkTVdXVkVOSTQyaG5wMkhOb1lLN3FLa0o1d3NJYS9WSVpXTDgvNHRWNTF5ODUwZFpsUy8wYjcxYm1oWXNvcXJMenZ2ektKYVhPbkwvbCtsL0s4Q1k4UnpjTzFPYjIyZEx3VnIrRmRBNlZ3NzFxb1dPMXZ2ZldhWTdrT3Aza3QyYlY4SWFob2VhV00zckhsYVE5cFBrc3lzaENiMWR5L0k3aTgwMnF6dDdqcmNuRm1tQkhlS1I5VkRkclFzNFlRVUlsWXJsb1loMGRXRkhRM09CdVdkVW5UZWxZOGJ6Z24zMXNYQUFDNEs5YnV2d2Z2Ymtqek1QU2F3ZEwxUCtUYUk5TUtuMkYzU1o2VUpJVzNMb0xldkJGamx6VDZ1MGphd1hsZHJhSzRPZDR1MFVSa3BqVzlhenEzbGVOMzJQMTlYa2daOURxbDdUajRKL1dWdFVqbC9GYTVjU1J2ZFFmdmkvaVVRWktVc2s1YjB2dUxxRXR1K29YVWlDMjRybGZoNjFUS3htZGk2VVNhbm82K1VvV1o4M2NqYzduT2JEb082Z2xjM3dWWFNwUVc1VkdVdkZ5NkZySXozcXFMTk5NOXNzSHU5QTRwYlZqVVlkcUVCZmVrYlNtVWtRd0p4ZVlCdjFqYU9nbnhKWTJmcnB5SzBOSjYxbm9wSHV4SXo4YkIydWlDdzRqNkltaGNjY2grYjJrRTg5SmpabGhnS0QyY2xnRXM1WFg2YlJKLzZkcnhTZjZMcEJkbDdybnJkRFBXOTlQUnNzZUJzdmhobG8vUVUyWUxWbjIrMXNYUTRSK2JEbFAzR1Y3UEdRRGcyWXp5SHdNMzBTWXRqN0Mwd0NtSWpMT0g2UUx2N1VKRkFoWDZ0Z0hvWXIvbGtkdjNhZUY3bEgwR1p0LzM4dStOSjB2T0gwT3Y5WUY2RCtYeno5d1Jkdk4rbExqdGJkTVJRK2VyZEgwUDh1dGx2dldQVXZVYzdXQWp5UExXbldsdUU3bm03NGpDdVRsMWxQSVkxNWh3SlFHd1JsSlhvOTk5QStDS2pGcE5hMWw0UEFvQUFDQksxUFBMN2R5czYrU01sK3JpeVR1Q1hqZGxpYWJKYlRKYWlieG9xZVh2OWZpa0FYSTB1YTJwZysreEdqbUxIS1hSK3RraWIyUFd2cVVnbi9HeEhpbldVNlN0bEpSc2ExVy9vWHQ2WDcrQlR4VHN4RE1lYVlDUmVJMGNqeUVCVnJUYkg3d01UR013SFF5eVU5Q2pVdDM3ZGZJRFZJL2NYT1hEV0FGM3dyM2xUdjNjM2l5UEtyRDJueXJlamw2LzVZaXlSemIvMTlxSXphVEF2cUpPODdMT2tlOUEzWW5vY1FJQTdFM0htT1JPZDhsRWQwaXE1RFM2cm9jZWo0YnpCQkkyVDUwWU9nVzA4akREdERqRFBJUlBYR0dWSmJrR3orSkcrdnZJMjZoLzMydXF0UGNYQ044QktVNE9oaStNK0ZrRzlTNXc0ZHkxOTlXbWFINVAyVkZhN2l2NnluRTI1RWw1aWlJckdXVW1PejA5L244VHp0OHZQVzIrRlBmS3RKSVpta3ZiU2hKNVZscXVMV2VVWmRYQk96ZThqMEdaRjZ6ZXcrMzFrcE0wcEdnRzFaRHdJTzIrcUNIQ3liYmFoZlpmVnRKSzExSzROYmY0OFBwckQ4c1BSdTErKzZTWFpDMHBrbGliYk5TaHZwYnpGMWViU3h2Qm9selhXRHBUdXRaa1dMVHF5b0NzOXd1RXIvbVZtZmc2Ky91cDRWdHBKbGV4S3Izcms1YlgwbGMrcEhHZTJmN09iTDJLSUpOcWp0eXhpdFJ5ZHNXNi9UcE5GdElWNDVvanA3NGI5cXB2S3c2WWVDMkRKYTIxQWtYc3JhZ0ZBTUFac2Nadk51TDJVbTlldGR5cnZnRUE0R2hHZS9PKzhlK2syL0pIMW9MbCtvK1JON0pqcys0bmFyTjU3cy9qR1NsS0hUWjFDbXlIMzJ2ZElMZmR1MHpseGlYWHFMZElaMVhDUkd6M25qcEV5NGlrYi9WZ1I3MDZIbzlTWFVhTGpaZHpGc0xYMGtzcUc0L1pKM2J0ejNoL2xiVktyOVZwNjYzNy9MWEk5bzNMSW9SdmZZYlpNWnBxTDJVZmxvTkQ4aEhUTkNYNWR3SmFHVVZKVjVneXFReWFOanFpcFhpUExEQ2Mzb1hXY3VoSTErajJjeE5kY0NNTDh4NkdoS1MrZXN1K0dDT2JuRjU3TkhxMERsUkZVTHNqc3BwbzZaSWp2N1VDQWtKUHg5TThrbXgwd3VIMDZKUjZiMUVDQ3VHenYvaGNyN0lYSWpzQjRDVHlVTkpyNndUUjFKcmxkN1B5V1RzM2JtZDVDelViZGI3UU5DMFBuY0VQdlhabnp4VFR5djZhTkgvRkFnOFJqdFVQZ1BzeGFTSEt0ZWduNlk3VmpmdndOZzlVTUpnT1o5Z1dJKzFEd1h3RXc2alhqSmtiaWhzak5TR2E4cHVaM2diYTZpUExhcFUzc2c3V2hCd3dZVXZEZlI1Z09KYmhrd21lc1BOeGh2bDdIMHJuZFR0VUgrOWhXR1NoRG50QW50WmxXZ2RtSExyM05reCsxMjNOR1B2N3phZlBYYmV2N2RaRG80aU13NUNHTVpZdXNBT2xNeDZBTzBCWG9Cazd6cnFzbHJpV2RBQUFBTm9adVE1NHQ0WGFTMjVTZlZycldaeHBQSS91cFBqaUZid0Q0YlV6c00yWDlxUXppTjVIY1laSlkwM3p1SGp2TzdPNTV2RDlJOHJ1ZmlqT2thNU8yRUo4UnN1LzFxeUtlallLazl0NnZrQ3Y5M3k2TldyeUg2QkUyQjNEVWN6Y3JZRFRnbTQvTnlNYzBYdXA0Um55V243VWNFSkcrR1NpTXE0OHBhV25nMUJURGFEaGJrbVB5bTErVjhaU0xoaG40TVNNTmxQMmVIUHg4dlRZcFJHbkp0alF0VVlZNFQxTi83VUlxRTlibzlaK1RubmxUcUo3Z1YwWU1jQTByeWVJdjRXbC9aUWZnSm5VdnUzWWt3clhXTFVPQlBLR1MvR0g2RkFQMGpNTXFjTEM5YWI5UmhnWkFIaFlkTUxOeHc4M0pUMjN6VTFyVGFZYmo1MEE3Z1czRGtjWHp3T0piS0ptcVJTcENZdVdPSy8rVVU5bTN3K3ZrZEFpMDF1V1ZLYWtMWk55WFFiRVI5dkNtanhXblMyWjJtdENQWFV6OGdxZkIvamMxZnIrcEM4dGJyN0U2UDA2NEtxMGtiUyt1clhuaEpYNjF4bitybkxWMXU4c1ZUL1V3K0F0b3ZEWFEvRzJhWXQrNG1SckZsZXZYc3BLVFdKdDUvdGFhUkxUK0w3V2F1bkFULzY2VHA4YWFIV1JYbW9iTllZaXF6N3RIMm1zUlowUlZFdzE1N0psVUZrRUhIVG01MXNrNzIvbi9hcDUrRFVob2puckVlek53MHVReHJWK1BVUGJ1WVJiVThmYStMV2FSa1ZKa3h4NXRETEFOTHl6dVU0YmtWdGpXUjJhakp3d0xNQjhOSXZPcXhxTEluZlV5aTVkMDNETUdRREEzZUQwdEpYV3EzTWp6MGxHNk5kZUdWNTdTc3RmMjFmTGRSMVB3MGVzTDF5Wm5xMU5xRXlTK0dlNzZ6QXNzM083YnBWYmYwRkdKS3RWc2JJMXdmV3ZscTdQbzdSRkcxTlNXcC84MzFZc3F5dVpZdHpCcDI1clg0U2N3MGF5SzhPZXcxVWphcGJoeDdkVXVPakVsWkZKdU44SDg4bXBhOCs4NmJuSURNOUc2YjlPajJ4cWNNOGRGV2ZaRnBiemhQUGI5YzRLYTVSNXRFaVBwZ0c3MEtxTVBNWU91RGVqbkJIYUl5S3Z5clRVbExaSVhtQzhSbFk0anl4dkUrczJFSC9OZGErMzN0N3VpOWwyZkJqVVZBY2oxbzF2MEFtN00zb1BMc1ZIMkF5TGF2OXI2U1lNSWFEaUdmQzkyNks4RG00aHVtT3p4ai9tQmFIRnJnUmhqbWphUHdrQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSCtmLysvdS9xeDdEU1Z4Yis5ZGYyOTlvalQzMUo2MHBzQzRua0FYT0lIdU9JUGdHakdYQktRdVNNeE9oSk10RUR2azZGcEhkYjlESE51NXlZQTUwQVJtTWRCbHJIU2ZFWG92WDJ1R25zUG85VmEyUHRLR1R3REM3VzN4NlZjVFRxY3R4ZFllK2libW1iT2sza0ZPcFI1MzlGejlwczBaN2UrN1h5SlNhOXAzNlJkRFM5eDZpejhqcjd5bVBjc1o4cWtNdnlmeVZ5TGFkdmVuaVA2NVhhdVBmc1NpcXpGMCs5NjNCS1VTL1hJckpnYUVUbktTMHNPdjRqTXIzWFZLYW1LN3c2VVpNbGxaREp2TWpWZnoxM28vYzdOK2RvbWIvWHRmUlArRnFXUk04dTNEdWVrek8rVHFQVklTbHBTQmxlMVRsU2RkQmpQdW1jMjN5MlpjVGEzcUlqTGJ4MmhITmRJcm1Xbkw0Wmw0VlU2enBrTVY2V01SMVBGVnJNQ0hBWjJxeW5NZkpiVm13dVA0WWVPQXJONnFDTXNrS0tValpsNXR6b05rY0FBT0RHekxacHREMkxkMWMwd2hNUjJjWnFaWGwyaGRhNjArck44bnFNcHF4NW1aU2hkQ3gxb2IwcG4vaVUrdXlNMlhpOU9seDhkT3hZWGpvSlQzcnVDNmw4dU93TGZuZHZydktXS3VlclE0dnFsNm1ra3EraUZzYTNXcWV4NG45TExKKzZwZTM5dnZNcC9qM3Z2SldRNnBBM0VxSTk3YUZuMW5pMVJyU01uaDEwcTVZY1NYVGxBZE94cGxDTGdRSHV5UmtOaVpzVG5YS2VhV3lWRWExTGFpaFR5dGU2Mm9LRGtFd2RkTW9sOFZxdW0zeGtBb3VQbHZQcW45VytWM3BWQklEaDVGaTAxN2VTVS92dXIzYzNlRHVpVGtLd0s4MXJSVER0ZHhuNFlpb0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIRHg5ZjNyVlA0WHJldXowYmlUVVE0NVNPZkkwM3Z1UU9TSWlwNGpLTkZQWUE4aXh6b1Y5dko5elluaVRxemlpb2llR0h0S0JzeHY2WVN2Y3FtR0FKZENQcXoyTWJSKzZjVFVVNTU1aTduOFBHN1M1MmRlbGxvT2hYSjlGRzBsWGJKeWtoREdwYytPUEZvNGplczV0bGZxU2EwczdYdzBMZDRhUFpJeDJtQzBxbWs5K2JqOGxsVzdEQ1pCVmlieDJValB4cFhxdi9WSmpPU0UrdVZVK1hYTjBqOWw2NDNJNGNYZkdtT1dkUy9sbGRyVVkxZ2ZzSU40OXlNTlg2cGdIV0ZYdG9aKzhiWmQ2MXpTNHJWNXJjVjdaR1lqVHpUZVN2ODdyc3ZyZjF5YThwTHh1YnNpU2xybksyLzVPdmFLVkp4engvb3lBNVhxaTVjR2JzU0lsZlN6Tlk1Skdia0k0aFhkdnlraUN3dTVjZ3p0NmpxTFJjbEUxL1lSZXNsYXk1Y1MrSEZhelA2bmNYV09MTlNjcjVOY0IvcVhQVmVHb3kwMzFySVVrUWt1ZzcycThOZVNuQkZEeDJ0VlllaUJNK0cxVUhzc2QybkZrc3F3Wkh2S2xwWUV6RDhBd0puUnZBSytuYWh1Tm52UmRoNWMrUEx2SHlPOTEwdEwwM0xoVWwyV05QSnVLZFoyZGJpbkwyalpyVnNWcVE0ZWZyYmFaZHlhcC9uaFMrMWlZRHBXdW4vclM2bE1VWFk5bmVsYjdRelBtUExPbllnbm9xU1BKOGRiSnc3SlAvWFAydy93U2NubHJ1dXpUbEo1NmFqZmRTT0szeG10dno1VTErVGxJeXhNRytmOFRzR3gxT1hqYjZjK3hHMisyaGZDK1I3enB1ZHA2blc2SXNSTDRVa3NLMEtQOVc3Tm9GYk5IQm1wVXJyby9VaXpNaVc3VHRMdVJFb1BodEhqVlBFcVlxdTd3YjN3R0FiZmVGUmtuZFp5Um5DeUhqTFdMSzNzeVd2dER5eTRMaWhKOTBkcHNvb2puMmUxQVFleWRLUzNRN0EyWEFKMnE4SDBNWDIxWjdObEtTUWRLWURkK3BDSWtyZlJBRFJoTFR6WkZheUtwM205VllqeW1QbFFsR3ZKU1VpeERJbUhLNWRXVDBUOXQ5ZUViK1U3UDc2WUNnQUFBQUFBQUFCQTRHazcrNmZjTDl6Qis0RzJCZ0JFZ000QUFBQUFBQUFBQUFBQUFHdndvdzRBQUFBQXROSnJSK0RKRlFBQUFBQUFzTWovL3Z1L2I3dFRNeUQvOWRmQmpxN0lBV1lTbzM3Q2ZnZTRnOC9RTnVBcWNHTzE5VFF1UFZnVjFaTDNNalMwaytlaldRQU1RYk1KV281M095bWVBeTAxMWFlbGN5LzlJK3d2Y0gyOGcrNWtlT1pRcXRKWVpzUWV0MTA4a2Mzek1hSXNyVUtzbzNSYk4ydWNUQ3U5OTJnczYvNjllYms2UlBORlpGQlozaEU5QU90WVJQbzF3Q0ljdlVqei9VYThRdGIzWmR1VFJjalBFWjI1M3VQWGVzWjNDVjdUT2xDWkxmY25sQmtTbFlORy8waERRcnB2cnc3eDFNVlRSb3RPS2NxVlZKUDExeEdrK0ZLbGtpUkpNbXBaUmJudmJOUkJxMmN0eDdaU0kvM2IxdlpqeXBiaWwyU1NEaVZaSW5QSi9KU0s5ejY1OUpaZTR1UnlaZmZQTWQvWGRldGMyanlJM2orUC9RWFZDVWhEelZ0dGJUaFByVGc0RzU2aEZKVVR0VUxxZkZRV0FHZkhta085SzE5Unl0ekRpZ1lBZ0NQd1crSnlYdTlPYlEvZFI4dXlkcXlSTmNHNzg0cVVaUkhkQmJlc2daSDQzanJzUWw3OTh3UG5FbDI1U2hOemY0V1gxK0xWR0xYMnp4aGJ4WG10eWFqdjBMUDlqYzRaenp5UWZXaytNdlh6Yk56dFpaczI4ZjRQcjQ5d20yNEpYK2NyUXV6MlNxWnN5cVJTaTFJREdoclZGcGIyOEkyeU50OGhwVzJFeDBhMlZhWVVUMlh6clE4T3h1dW10WVludXZkKzlCcFNQUXV5RjR3MWxrZ1RSMWNmYTZYbzZkYmVvWUhoY0RKNnpRaDA2S0ZZVnVNcW9aS0F2cCtUNjN5SkwwVGExd0l3bkVHRHk3dUw4c2hJUkZZMDM2TnAzVklEbHBrbWV6SGlOUk1CWDB4OUtwaklBQUFBQUFBQXVJSDVERUF2bUVYZ1RqeDFQR01lZ3p1QjhRd0FBT0I0c0JvQkFBQUFBQURnNFF5Vzg1NTF3RTRCQUFBQUFBQUFBQUFBMXlILzMrdUxxZktwOHI5aC8vcHJCNmVIZG96Q2pGTjVuc2lJazVJQU9Cc040OXFqVXR3bnl6RHB2WGtPdzNrODdVb3RHeWNoYlU0VUlTZnFxQmluOHdDd3duTzBXL1F3MHhQUVkrcEU5WlgzZ0RQWVh3L25Jbk1uU25SdWpianRxQjFSdU16MGxQVHUrZWs5dzY1RkcwV1B1UEpzQkwxbFduV0k5SVoxQnBSRnl5U0tIajNaTWtJenliNGNmMGlQUXpUdVYveENxdHlmbnkvT3JlT2xrK1hIYmsydDQ5ZXNOaDR4dHFJNDUxVGQ1dDdiZWFlUDlMUG4xSFJQRzBldytpMDU2a1RUUk1xT2xPRXRVeDczOGhkU015TWhDV25yRktYNjcxcStuait4ZFNzazF4SytsaEhSeTRta29lazhZMjVicDNhTDJsTzJVSVkwdDBKZkZ5WmxiUlo5S2ZsU0ZvM3dicEM0UE5HMnR0SjVKUEZ6UXg2MzI3K1crdVRFelNFK0haV3dyZ05ONTl5TXJ2U3lWMmNJSWx1SE01VkR3MmtjdUQzU2tOS0dtbVhodEdybGxtRU53R3hheDJmcmVQYk1MY3dSQU1EVnNld01LeCtYZCthdTBFdFVkc1NUMHJwRDQyUkZzZTZyWnp0aDNiZVZyempDTGR0MUk1dFVxZ2d1VWlrOXpkZkNwcXpHN2VOS1pwbzdEcmkwTmJ3WGI3M2ZOOTJWUW0zMHVaVFZkTmJlSkczQzVjN2dmUTZMYTl6aFkzdDEvSktXWHRPMDMrRWxDY01qcit0TFplU2dUNksrciswWFlhWFJwZnN0dVZLNGxCR3ZYS3JxK0J2T2p5MmY1c3JCOENnOUs1TFVFb25JaklaemNlQldXRVBIWXVDNkJDWXlTazNWOGxLblRLK01oNHl0cUYzVmFuLzE0bHZoUDNoWEg2OE5EM1ptdEhrQmRzT2pVNks2Wk5PdFFvUTFmejA2QkVNSW1EZ0hzUGhxQkNPdVRoY1plOTVIN1pUSWM5RmJ6d1hMaUtCcFlCeWNpc2pjb2QySUw2WUNBQUFBQUFBQUFCREFqaC9jQ1l6bitSelJ4dWpYZTNOay8ySnNnUnVBWVF3QUFBQUFBQUFBQU96Q3pDMzR5TjhlZ1NzQnh3NEFBQUFBQUFBQUhBVjJaQUQ0eWYvKyt6K0ZmdldBKzlINXYvNUs0NGtjbnlEaE9lQ3NUZ3R2M1JyUE1YTUFuSlhJVVN2a3NtVzQzMHFGdE9oSzQrVFlUUkdGWkJOT21BV2dHYzlobnpjZ29yYzBQVFZreWNmOGZSYldCdUhpSExsdEVMZEJMY2RzbWVkdG1RSlMrM21YRkc4ZGVzcm1aSGpxc29TMWJEYTk5NXNDWlZsSGYzbnJHYmxQNDB4Q09xYXNyLzJ4OGR1eTlWYWdKNXF2cjVOWTQyMDYvVXVUTGVkQ2V2QTZNcXl6WVMwWkxjYU84NzdmamFyME4vc2xYTy80NWdxVDB2ZmMxMGpON1QzZjA5S1JlcjhYUnh1dWF4Sy9QenBuT0ZuUzNGbjdDdVd5dDdLM3BldlhFVWJNbWRieFMwVVNHZEtuVnJyd3pxVWVHeUFxbzNWTlhHSUxFN29Pb1d2Q3RnYSsrRnFtUFpmMDllaHovWkdTTnBJbkVWazZScHM2MFhUZ1ZGaXJsRGUvQnd3bGNEVWlsa0NMQmVQWkpSUWh2WllIQUFET1NxOTFyTzhpN0xSMStxZ04wNk56bHpML0lkZUpxWXZYVzVkU2JNZG03UTVibUxFdTBmdnY5WXg2NnRqYnZ5M1Vyb0hhTGZEaldrczJQYnQ1S2Y0SVdyMFpWamlYUmtyWDZrSHkxZUhqYXlqdmRPVWR0dkVoNUtJSnE4Uys4cFZLMXV1THFUUzdXRy9wNjZ1Wi9ySFdKajZ2em9jU3NHWnBlMWpQQU5ZUzF6UFpxd09UVUtNOFpWZmFzeU9PcnB6Um5iNjN6SjQ2Z2NQeEtrMTA4M09JTHNSUy9JZzZlTlZUeEFpNjBQaHRlZW9TM1I5SWFmK1FhMjlUdCtEdDdzU2tzL1lGWUNMUkRaTnRhSUVkNmQzdkx0MUZYeEhaZENjendhWDlMY3dOc0J2T0JmYWRqS1RUZGtuZXVSVTFkYlEwandmS1kzZXM1NkRKaU5mRzl4OXZvZUNtb0tNQkFBQUFBQUFBNEVDd0tadlBVOXY0YWZlTnVUUVB0QzI0RHhuakdRQUFBQUFBQUFBQUFCTVkrWnVlTXdQUENnQUFBQURBRFlCUkJ3QUFBSUNCZkdrdjQyVHk5M0FubXZjNEZCcm5DZTlOKzJROFA5VUhZQStzVXhBNFBXRWNxWm4xNkhkWU1hcHpLK2dOQi9WdE1ZNm1MRVorQUVTaWgzNTZKdklGYURsUHRjN3JPV21uY0JtMUJKSU94cnkrTnBFNVZxZTlTTDlidDJmTnBTWE5pTnNWVHhZcTlhblphWDFjMXlwQ1F6b0t6RHJQS0xJWjg1YnRWZEJjbk5RalVhM1kwN05Sejd0V3BuWXVtcWF0VzFlQmJPUjVsYWwxeGFZN2hXUGpFbzNYaXM1c3VvOG92b3hjWHFlbTEzT2lMcnFTdEQ1SnRhZmZQV05Ja3MzSmJNbnZtUWM1MllaM2RaRzV1bkY1bGZvVzJvYlI4ZTNaaFduaHE4b2tIZS9aaEZSZW5ZK3JsNmRPL1Bsd1JVeWYyUFM4VElzc2hQTDYyYlAwYjJWbGRvNXR2MTRwamQvSTNQSzJ1UlhQOVlsai9LNm1uTkJhMWhkUzFhOU9hL3JJMG1NYWtUYTJ5cERLekVaK25ieTVxa2VWcE92NXV2aSt0cjNNd3l4SXBEWEtxM2lhZml1K2lzbFpLajZ4RWpaajZGMEpuaEVxc2pWOXk1QUNoK0VldjQ1MFZDdFpXa3FpUnpzQjBBSWR0MXk0bGRkckwybVduSVpsZlhybEFBREFtZkR1WEZyMHNmYzZLZUhhVGxPcms3VUxXazZDLzhmSTUvSDZTR210UEVldUhhMWJsZWg2eWVYTmpqSUY5NlFiZFh2L1R2UmJZS2xkQmxYbHBieHYyWW1VWVUyaWlqUFlDM1J1UmZjZ25qR1VsZnhhSFV3WHVCSFBsMVdZc0RwdFlUTlRYOFNTN2cvenBkUjMxbzFmbHRRM0M0TkZ1dEhNMXlFWno0czRuMHRPMmVnenZtNzExMld0TW41VEYxRm1Gdnl3dVVxeHZ1N1orVnBFZHhCSlNlK1ZaZlVmTjh1NFBBR2xBODZIWjFoTGVUekRVVXNIemtsMElaNkJWN2JIdUsvdHFvdGgyYkRGa2NlU0xUWE5QeVNlUzJmWlZ4S1dQU1dsQXlkaFdTTjBNM09kUGlYYndBYW5ScHEzMHVOdGFVeVVSUGE5aVF3QnhxUzE5QlVBelJoMlJCRVd3Y2pPeTJzdVcyalBrUzQ5Tjd4YlY1b24waEJRSWl3UjMvZmFaOVZ2YjJwbGlsOU1CUUFBQUFBQUFBQUFBTGdQZTNxcW51b1ZnemZ3M3FCLzUvTzBOdDcvZnZFU0JBQUFBQUFBQUFBQUFFQS84QlFDQUFBQUFOd0FHSFVBQUFBQUdNQ1hkdklLZDJiV1ZDSUdqblF5QTQ1YThlTTVoZ2VBSTRuOHpGN2dmVUpMOHNPcGxjdE9EMm1lQzRjaXJqNzJrWUpOTHB5Z1EwL0pLZEExd0l0MzR2WWNJM2RpV2c2VTRmSzVaRnVaYnRyR2p5Yzd3NHZ3dDViM0JPTkR1bzFJRmFmZFJyM2VMdXR2dFY2V0xzK3Y5eWlwRnBsV1dUM25mTGFlTzJiZHJ5YkRxL3lzKzRzYytjV1Z6WjNIWnBWbEdjcEt0SVI0SEtLSHpCZFpuZkt1cTVMWGllYXZCZWx6RXFNOVhncGJsNTZ4NTRHemxHdDU5SWpSMXJHa25ac25WSXUvK09RVHYrcVkrUFJzbUhTR3JyZU5XelN5dFRzcFNqNnRUdEt4cnBwc3IwNWN5OHFiTXBiWVVzV3N2dzVBdnhTUURiMVZERjFhQW5QRGtpVkxrZlJUby81U3c2VjAzakdsUmRHak01MGJXODlHdUpaZm5QT2JMNHprYTlYYmtUcTA2RXhSNjc5cVFyK0tJZldqZDZ3dU11dnJ0bGFxUzFubjVvNEJac2liUHo3aXZDb3pZbVpKU3lCNEJDTzczbXVKdDFyc0dLWmdOaTI2M3F0QzI5YVJENXJsWTZsOHpZb0NBSUFqOFhyWXJEeWNEUi9adlZ0d05vcTNicFljVDM1cERRaDZmMVJhMnNYeXNQVDJyOThURWIvdkpwY255U2R0OHlQUHRkMTJSSTdGcTY2SXJOZUJ1MTdKVGtJZGpIZ09iOXJZYmoreHJ6TkU2K0RkbTBTMjNqUjg3Zk9UL1J1ZnE5ZTFNTWI0T2ZYNzFLaitRaXFuSXo5ajVqZWs1SS92cFM1NzJ5N3lUUDVJb0g1TFV2YjdPZ3N5TTV1K0RsdlhLYTBrRmtjWjJUM0t0TW5ZcW9FdE5MazV4VVo4blM4UzM3dWJBYWRDVTFSZVJlc3RBNXlUcUNQRHUvaGJpdHBTWjVvczZUb1paZDRNajJ2ZjZ0NW84M0JOWFp4bFcvc0ZpVmE3aWxzSm9ZNEdFdFVGU2JnR2gySjFJMDJ6bVZPa3Y0dVVrTmxQcStSdFZnd2Q4SVBIMmVCZGtPamdNdlNYcDJpcHlGWXpXcHRLdDVvVDBvTGRZa2g0N1VYd0E5ZGNIbHVyaGphMXQydTR1QVY4TVJVQUFBQUFBQUFBQURpTVozaFJudXNyZXNxZHd4c0l3SFU1ZnY3bXAra1FxRXdBQURnbFVNOEFBSEF1b0pjQkFFRG1hVG9TYXdJQUFBQndIRmlIQVFBQW5BSXNTQUNjbXEvZmY3NS9yN3FkcmEyLzlHNkNWbUhVa1hkZ2kzR3FCUUNIdy8yOGZ2QTRqUnltY0lzcFVueHBsc01wNnNORStCWENKMjkxQ1YwRFdubm82U2NqYnJ0NEUyRFRCaWlqam53NkFPL0ppNGRTTGJBYjAzeFloYVZqcVhKcTMyeU5TaitEbGpwNE42RXo3ayt5c0x5YnRjaFJsWVh2ZHZIWXd5VTRjdC9iKzJtekl3dGJkS3dIZXZ2TGFUaUg4L1RrTTBUbVVBUkoxbU1NeEh0NG0zOTIzcGJ6ZUh1eDJwU1A5L3d3cjZ6K3N2VlhHWGhmcFhtY3Q2YXRGZGZBT1dZTjIwM1RCdHRRVkdEVi9SUnUxeTFWUmkwc21MNnVpNWVSYzJOZGcwL3ZqaTlEYXBsaXBsd1lxQk8vK3p1M3lLdkVhdGZlT0FBSTF1bW1YaTExdkVZQlFHZTBwZDVpUFd2K2RzM2lhVjNwQVFCZ050Sk91MVUzU3ZHZXNxUDVLZHpIRjNvNTRoazBMZFBqQWFaNVcrTkg1WmtwcDBWbXhCMndjUVVvN3Rhc3VZU3pudjhOdC9VTVhrdk10RGZPVUlmZU1pUWJMcTlTU05ZZHFRUHh6MHZ6ZCsybUlvUG9kYjNwNy9lblUrc1N0TXJRd3JqM0IzMyt4eExVcFBtVks0SzNMbmxUdC9WZnRUOVdXcGVzOVdwYjkraEswdXFEcXZPMmF1cXNYSVBUMDZzc2FmZlRNSEIrWmhsN3BVR0dWNWJYUU1GWWRIZWJ0NmtpanhWRzIyS1Jzcitac1VjREN0RU9IK0VRQU5QbzNlKzZ1M083SlhrSFkvNENsdEtReG51ZFkyS2xOQkZmV2crMzNubjEySkhmT0h4bVlFM1BtTzAxQVRpK2FySGJTY1dMNkhGdHNGQ1BuV1J4Y25sQURHN1Y5L3FzaG5jOEFBWURWbnZ2V21TOU1ueFpHdWJ0Nm5sRGtkc21rNGRqOUxxakNnRG8zTndta09aTWRDNTFOUXNtN3JQeDlQdGV1L0dia04yQlNqcXp2U1BLVVgyMUlkbFltc3FEVklkUkE4dHIzV2t1bjZnM3ZVVlRqL0tjT09Tc1hsaDUvMmNnTDQ5ellXcjFEbCsvOExHOEtKSmZkVnRlbVBtMCtMcE5hYjQxWHNVVU5TUzA5S09VWVdUc0VDLy9rbzBkQW5XRTB3SGdyZ3AxNU5TWmFScUxFY2JkSHNaTDIrUGRiTnlmOW9QVS9QUDZWRkhLOGVxdnJkeTFwTUxHY1dWdjgzcHA2V2R2dnpyVGNjTldpeStlTW1rVnZPdHZWUW1pTzdjVjZsa3JXbCtHOHpvSDIrZnZWcEp2YkczV2tLU3REYlk4alk5c0MyRnd2ZlgwYTQzVUMxdUw4akJxR1FLM3dGcnBvN09icnZBdHF4RUFSelBTMnVpdGcyWTF0OVpoaEJVTkFBQjdJT201czlnUjBaMzFLUDNic2s1RlBVZ3RIclRlZGNram02YXoybFNLN3luVFNtOTZJb1RuNGhaZFp4ZGxQcWh0djd0bXBCMWhlZVpieHJYM2lZWTI3bFBTeXZDa1dFdXYvWFpyZmRadjNlVlZVVVRPTW9nNG44T202R3lVU0h3cTVlT3JYNGtoOS8wSmFkY21aOUQvMy9mOTI0L0w5Ym9mMS8zYnFwRzFkRllyV0xNcG1vL21wMDdRa3M3Uk0yQTRyUzVpY0U1YUYzOU9UbXFVRlRXd0l2SnVTSTlOMzFwV2E5N280NG1VWk52ZEc2N0pCZ1B4ZGpBYS94S01XZ3BxZVltVG1ZMTRaVXNDd042OC9UVExkZEt2RTdubWZBNnoxbkRzdkpMdTZBRWlsb2VoeDJkY3gzTjRaSC9aR1hLVDRCRExIWHJlZEFCOVVKOVNqZFhtNkJPd041cE9jSTVIYVpOcnBic05IcDkwWTF0YUNhQXl3SEJ1T3FpOG01OFdtYzFnQWorVFNMOWZlSXdjVWZXdUR4TEtVbWNJVFgyYk1XK2RQSFgyV25IUi9CSERzbFVqOTVRUlJXcnpxZzVGang3Sjl3OUw2YlBJdlB5eENpK2JmQzc1YXFXOU43U25GaGpWdnpUTU1SK2tGNWVTRkY3MDVHTGVMSVJIS0FQU3pDeGJTNnZkZjJHdmNxQ0VJcmExaGYrK3RsODErSDBoNjFQbTlzV3psUGdYMDZ5U1lta20zTytxdTZvblpKd003Zk1tYkxqM3RVdnFCRjFrK3NlU0gydCtjblhlVTBmU2tuL0x6cUcrWDQ5UTdkR1Iva052WHVySGhoUHFKSjNNbGFwOFMvK3U5SEtXaW94eFhIZUJFMUtDMTFhNEZkZVNEb0JaT0haRlp0N2VzaVcwUjNLOVlPNEJBTTZHcEpjaSsrRGVkQzFFdlJ3ajZ0SjYzeVBXdFNNOUxGYWJlbjlLSlYxNzhtemlHMis0REJnSVhUWTczV28ybGgzMXVrZGtqMHl2cFJsamJ4WGxLbTEraXZueDh1U1hMMjBkbjFMTEU0M0ZMNUplUXVSbkdyVS9QYThqaUZCU0o4ZWpHOTRmK2FsRElTMGdqMlMrTUkvdHZpNWozaHF3OUJ2anJVdnJnL3hTMnZidmlCVnNXNnFldDNYR092eVRiSjRaR2dJY0FqZXRhYmlXRDBQaFhJeFNpajF5OWxRUk4xUkh4Um5XS3V1YmxpWWJ0Zi9wa1lQVlp5SjdiaHpRa2RNWmJSOFhJOElzTC9PV0xZWUIySlBOYnNxaHY3em1NSmhFeEtHRHZja1Bsb2VoVndZWEgybnlyN1dZNVVXZEpXVEgzc3ZHTlJqSHA0UDVhd0NPSmd0aEE4Y29WRXlGbzIwbFB5VXI3cFdnUUtlQUl4bXNNODZFdFd5SG5pczRIa0N1TXNObUFCZEEybGFjYmRqT1YxTTlkKzdOMjFKR1ZQRkU1V3JhTVpPMFd2cUliQ2xQRWNKcHZiaHdHdDlTbDV6VUwyclNLbHBHSEQxZWpxdzQ5UFR3SXJ5bzh4dW1QeWFqTDNWRXZvNFgrK0dSWElmMnZOWnJVaW5GUFdZMFgwbk45UnhxclBjYUVyMTZhcVorOHlKTnJpVk9xOE5Xa3N3YzNTbk5sZTJQVXlNamJsUWJlOFo1eTVpcXhzNzd4NmxLZW1uT2hHL1RXb2NpWTBsYVM3enhXcDE2KzgzYkIvVlZNWE53K2JqeHdhOEJ0Yy83VTc5QzhtMUQ1WkxVQjdTYmFtWW1neksrUjNURldWUWtPQVVqdTdWMWFBRndKTnJPckpEcmxHd0xiay9MRlFBQXJzS2VacVIvYjdwT3IrMks2SFcwakNNWTZXRVpWWWVaWmV5S2NXT2NtNkQrZUtXVXB5Z3lvM1VZNFNLTWN2YnRvdGZlNm4yaXdUVjkvU1hWU0IyV3dVUVBiZnpJTHRYWFM2dXZlb3JwNjBLWWdjclhZcDFlMVlwMUs5UHdKSGhjYWw4TUxZSHo2OVQ1MTE4ejViQjFJZStEMG1TdDg2OTlTYjVhK0d2M3VZN3VHR3dmR2MrMjMvenB3VzNRM05BQVJJaW9DTGVEWFVoM1UzWFU2MnVLNUkyazM5T1BaZGxaWUFkR056WTY4bFRzTVovcng2QzAyekVNd0JCYTdRaERYQ0ZoUFRzeTU4NTd0L1gxVW1nUDhXclFlTTFZVFJ5MUp6VytQc1VkcFA2OVJWTmZEUURnK21CZUh3ZWplNm1ocFdYbDBtRGRCNmZpeGdQU01wM29ZOEZkQ3djQXVMbjN1bmtsWlRIU0ZYdmtmUWZLdmtEM1dOdUVvdHpFUGVlV2NMOEh1M1BBTjBjMnZsdzI5bVpPcERmTzJBUWpDNXVSL216cytlcEN2T3hpWEZ2cDliSkhwZ01BQUhBSFlKc0JBTUIrY0QvL2FiVytwWjhZalpCMUIrNjZ2cG43UStNWnUwZG1kOXNOOUFsR2Z4ZHlGcmdYbnEzMFBmRUw2MmV3OWNGdTIzaXpMTS9CZ1V3L2YvOVl0UWhmUnYxY2xuZDlmT0s5cjlIdStUemxlTjlKSGxvSDZYNjVILzdPSWl2aDJMVThCcmdsd1VoR0d4TFVtTC9KYzlBWkdqWXE4d2JOQ000T0J0a3AyZU5IcVFCY0RXMzNPMXFWV2J2QVI0TXQ2RzZVWUxpVXp2bkRWRy9TQ1pUcVg4eXlPWGgrUlU3RE1kbkJsVEI4cEQycWhZcSs1QTh4dFhsZDJEL2YxeG02QUp5Rm02OVBMWHJLYWdyM1FUSXRUMktoRzhCSmlHeDZqaVpMTDZwMG5mZ2svMlJ2SGU4UktMV21kb0t6UlJIeVcwZGNaS05zcTA0dGk0YVZSNUxOM1lQbHdvcVdrUnJLVm1hRjlnVlZrY2dZcXJJVStUcHZUb1Azam1jdVRzc3pZdEdLMUtGbFlmWGtVOHA2Vnlzbjk4dE1LNlN4WlNrb2JUelhhYlJyaVJuemVFUytISXhmeTdhL0dQeWJwbXl1eTBZR0xhc1kvZGR1VHRPSkhNMHpwaGF5TE85MVVVUVVjcHZSSHhZVzhtKzJzNGhWczlaak5YUHk2ZXZrbEVWbEZpR2RkdCtTSHRhL2F5MlA1NGlla3RjQWJYWjg1aW1mZWx0YzNpYVRscUYzVVhsOVRmT05YTHIyeWdlbW9aaFR3N1N5bFU1REhPWUpnSDN4cnBSTFdtNzNOTXV5MWVyZ0pYSi9BQURRaTJabFM5Zld6aVFKTWpWYnB3N1h5dklROVVaNDgzajFjODlhWUhrRXZUYWhWVVlKbEpsSWZFOVpwOFRwcGx0OWtMTFhrSkMyaVpsTjlwdmQyZm05L2VleGxVYjNhOFErKy9qT2xyenI2N0g4M21sOXY5S1BVME5TaFMrbi9zcFB5NDJ1K1BQNlRPOC9XMkd2akdWMW5aVVp2UzAxNWdPTlBzbVJ2SnJydU16bXRaRHVzcno5UG56NjM3anRXRnBqdDZXL2htdVo2MnR0TmZTV1RkTkZWdWJpbEFrdVFXdzYrK09MSXcwNEh5Mk9PL09aaGpPZjEwRlpwNCtvc0J0ajJWbVJidTN4WmJXV09hSThNQm5KU1RyQzFBRkQ0T2FjUnpkNHJFcFZRRHlLbFEwckVqUmpiVkVrZTZQRGhvanV0S1JyTG8rM2pOdmpOVzY4NFdDRDFjUmMrcFQ4ZmgydHpLOW80VU5aQ3RjR0M0d1ZBSjVIWk41RFIwd0RUUXQyUjM1YUJJSkVuNEdEaDRFQk1KMmVqZHA4OXR3QldwdTlwN0J6RzZ3ZTF2MitvUElPdC9KMXhLOUdWakh5Qm9kZ2ZNVE9iUE5EdlNnQ0krOVhtcmQ3anVNOWRjY3o5VlJ4M25mOVFsYi9xTit4cmIxUHpldnI0c3pidzNUVmNlUjR2c1pjZ2hrTXJzN1JWc2hnRXcrQTI0TVg5QUFBZCtBcU8yYnJaelFMMG5ZdytxUFVPbDJMN3pkYWhsU21sQzVDMU1ickdST3RQekk3STJYQ05uakcvZmJLSFBrakIyLzYyRndxNnZVSVBsMWRuT2tTbXpwckdZMHl2OGRiSnRMWjJraGZUczMwT3ZLbTV4NCtuMDhaZSs1N3oranBQeGEwQ0FpQ1I4RFhvbVY2dDZxRVZtTjNnUzZvRHg1cjBNb0FBTThQM1hwa3NlbGVDZC9xMS9xTnoxSGJDQUFDRkNNT3cvVmtTRTVRWUhMa3M4bWZMNlpTVzc2c3JuNGRYTlBjRHhnd2M2ZzdTKzdnZFZyMEJkaWJBOGFjOUpDUWUyZ29UWlZMNGpuSnppSENlL0pCVURRQWJRT201VWlvQitCcURxTDhOazA1NCswR2NINHVwc0FITEczN1V5UWovWFg1SFYrRStJOFFFayt2clNQQjZOK1IxVjJxaTBaZGZ1eVZFdjI2QmU1VmtCRjFHdkVqdmw3RCtQMW1TZnFwMTQvWGJGSHlPZkZIOXd0amhaNnFUdVBmMmZNbStyZEZmLyszamlxazVMejZsL29nNnBSOHVJYTNMYVU1Sk5XRjV0VTIzVnErT28zM3ZyUjJNTzUzMDArZXVhVzVYUlU5dGtsanRhbVd6bW9iNzg3TzA2L2EzQ2lCTXBmUVFrTHpLbHhqMjBJZnY5eDZiclhxR081KzBxcU1iYzdsT3dCVy9WdmJXaHJYOVRpUTVrNkxqaUE2Y2dsN1Z5VWlpMEUwckdraXpXcVAxcUV1dExXTk9WbjF2eDZkVUpLOFNkUHlKVU4ydEorNXRpMUNpd3N5SlYzNXJsSmVYM055Q21sN2F1Tkp0OU15ck1IdDhGZ2gzaFdoWjBoNUxSd0Fqa1piTWFSVlZsb0pMYnh6cW5mT3Rjb0FBSUNSUkhmOXlabWUwNzlSdlNycDR6OUNlQzBuQzdLMGZKNnlhWHdFYWVkV3g2Y1VXeHNzbVo3OG5qSjc3VTFweHhvcE96blRhMlZ5NlRpWm9TK2xNbmxYcm9mV3djUnN1WSt3M1MyUEF4ZWVrbjgrWitISzQyUGJldS84L2prdVA2YzdhcnpwSWl5eVBySkw1U09NRWg5c2k2OS9YWnN0aGMycGxjQzE3cm9Nem5QR2xWa01pUjduQys4NVNtbnJTOG9rN3ljZGoyZVhRdE1rcDZ6ZWRCcStHUWxPaERhOXZkMG9EUjBwSE1QaFh2UVljNlBMMUJRK3h0MXA4WmlzcVRHTnRiS05XUGtlaTJ4QThlbTgxM3Zxa29laFdaWE5NdXY5YlFPRjBkUDVkYjNzZlRlUFZGT1ZEZ0FOZXp2SGh3ZFk3N245S3E0STRkbTQ1dkkrZmk1QUdSeUd0K2s5NlpaeC9XVW4zYW5IdlFzYkRKYytlaTBSQUdaeWdySDV1Q255dXVISVF6aHJQd29WQTVyZ0JxSFhBeFhKYzNOSzhOb0tCdzhEQStFRUxNcHd6MTMzRVdYTzVJaDdPVkg3V1Y2elZjS0paZCtTSS90WktqdHZMNGYxd1ozMEF2REF2MmoxSVBNZ2VxUEREZXU3S0ZHZjdwQitDRDJMNGZ1aVVqMUpaYWxmVml4TU9BQTZaOUVJMkNLQ3EzSFViakFsL29XRjZIcURPUWNBT0FNejdaQ29uajdDZW03UjM2M3BJa1FmbnkzMDlLZTNIWHJ1ZDFSYlI4Wktiei8yZkNtMWQyeVV4cmhabEozQ00wbmxHZGY2VHd6OStONk5LT1JhU3VmTHIrVXB3MmUwaGVmNUVlMnA4cnJTZmtLU1hXVXNQOGFkQnorYXFGZG5iQTNtU2g4TC9GaVg0T3pEQ0p5ZnN6b2p0QVgxSm1OK1JOUDc3Q2o4Q0Fic3lCVk1uSXNTZVUzVy83d3p4ZkhvWjI0amhURUJUc3BNdFFWMXlLQTVGbHNjZkdqZ1pscGZrZEthL0t1b1BaclpLOHR3RGFNSkdGWUllT1B0U0xROU9BcnZRWCtCSk5FSG5iY1o5dEtOTUw3K0xHVExSQmRJSitYMG5xQUR3SjJOeElqOTNMcjhXdVpVb1FIZXpPRCt6RGhXN1FDc3pjOGh0MVBJNGxsRDIvaWRsUHdZcUhBWnVldGl4R3RFV3kwTFpVdnBTbHJYcjZUMnpZZG5NMU1NZVZJZHZHVnkwREk5UmhqTkgwR3hkdDlqcTd5cVJYKzhHRndFTmsyZTliU2x2dVIvZUZTWXY5Wmlzbm90NTQ3MHF5Vk5HbHVldkpJTTc3Z296R1VoU1FYcmZWTmtqL1liclZtbHVVVExpVmhESlJqdmRZaDRkTWM2N3llVWwrbjdNa054aHVyM2xZMDJwSE9xVlBlMS9sRnFFY3VRdzYxMXg2TXJyVEZpekttZ211TTN3RklhYXo0N2RJbG9aMFhiV0VwWDF5V3F0NUtSM3JJenVETDVlbHB6SWdzdk5CWmxibm0rYnZHclVsOHlYLzFkM2piYmtwQTRPQW9UWHF6MnIvSjRtanVpK3NBam9DdTlOVFNrSWZRUGlZL203d0hER2h5QlprVjRMUHVvZkEzQllnL250eXdBQUFDSXdPM3lLSkxuVEV0Znk5WjJoNUplbG1SS09IWmVhbmd5eWg2dGE2bE1ieGtqMW9JWjk3UElUVW12RzNmZlNValh3NDhMMUVnenRCMTZEUW5oMmJ1VVBPVFhTQitabWxjbjZqcXh2TzFlT1Mxdy9kdGFwaldITWh2Rys3aHB1RFRHM1A0TjZxTWdjV3g0NHNuQ2l4dVJ1YmIxZFhMeGR1dnpiVjZJL3pJelpaWk52QmVwemFYVWFkV1A5SnJpOVpGWjF6VE1tbDFKU1p1RjlONlZ0amhrZ1ZNVFZiNWU5N1BIOE1CUXVSODlSbDFFWmgxT3NSNXJ4SmVHeStMZFIzaW1hNDNXaEpiZEhOMmJlRlluNzMxNVZsZmd4Rm9Mb2h1RXpNU0J3NUhVZDNUZXZ2TVZKcTlndXRNdFNWUlBBZkNtMTQ1dzZDU3ZIOUphMDRxUUYrT2ZnVnY4NjhiQ1doSW00bmVObVBBUkhGOU1sU3ZRTlVFZXRFRUFBQmlVUVdrNnEvQjBsUlJ4VHZUa0IwRGt4b05vc2FObjZobkxPUWhBQ0F5bW9VU2FFMDIvRnpPMDVnRVdaU0ZsZTd3SjBSZVpOdGRNV1lwTXJhVXRmeURtQStIMkc1WWpkbVgzM0FsYUQ0VTlENVRuTTBFUFMwOEVOa1huYlI1TFpqUE1HUHVSQ2V0OUZOYlhNK2p6MEhWZUFLN0JMTXQxTnBoajRNN3NzYy9ISEFJQXpDVDZJNzZSTytjc2xOR0Q5VTR0RGZmSWFDM2JrOGE3TitscG45bnJpUGZsT3l1TkZoN2hUdXVtKzE2VXlUVGEzV0g1a21ZLy8rVEtiS0d0WGFSUVh5MjJYMVJ0cUgzaGZ5RHI5YTl2ZE9KeVlOZjdyZkdQcFBxM3JCOFgydmhlS0hYNUt2Tjl0OC96MG5FL05aZzlrd0VBbDZIRnVJMm05eHJ2VWg3NmpQckc2c3RyVDBlQjVnZmdHYlQ2SWpnNW1mbjdIYkFBcFFJdUJqY0haZ3hqckxrTXJTOFNBaEd0U1oydmVMTHlJbDN3NVJFeDNBRlR2dzBrK1R2QU9HWjVaUUVZamZjRUM1cW5iTFdYOXhDZk9sM2hSVjhMcVNGb1BMa3VIcG5MbjJVdHVqRHAySGdBTkRRci95YUR5SHV5anBYZm9STHRRamo3SzZWNVhrMXdMbTQydDZ4TjBCRzMrWGxXbitVNkZPR2llTGR6bHZVajFrcVFvNlVkcVNUcWVoY21QRnBtTWRKcldJWlNpM2ZEKzJwTHRMNmU5aW1DTjJzeDN2THJyWkxtMTFWSW10ZjRydDVVeVd5Nnp3c214YlRPK2Z4cFV3TDFia3ZqK0doRjU1MlB3cHRqeTVzL21VdFh4T3krc3JKeG5ZUjhXaGxSSFNHTVl4ZlNmWGwyZm9uSnkrME1xV3V1T0d1MHpoOTcyWXlXeWYxZHA1UHVtNy8rekVVcG5SWXV6V2NwcjZWanVUUldPcTlza2w3ODlJalJOL1VHZUZPbExNaUlqT3RGVDQzcDMyMStEMVpaTkYxeWxxM3JhYys4Mk42bHJLOUswajA2bjVjM3FiNGxZNFIrU1ZYcVp6cW11UFYxK1R6TlpoeEo0MUVLaVBRbnVBdmNpSWxZODRuSjM0TFh5b3BhdGdDTVJodURkTFcxZGduUjhkemk3OVBtbHBRSEFBQkc0YkVwTFB1alZWOWxJVXlUTTFJbjVzNXlQTHZjWG5xOVdUUFhraDdabysvTHMvWjdaU1pCVnFUTWQ1NmNOai9xS3oyR3M3QVZMVkxaZGI3Z2xySjM3TlRldFZGbDVjMVZjZVhqeXJEOVdSNloyY2dmRytsdFR6USsvbUx1QzZxaUQ4eFpXdUhjSm5uSkova3R0ejFGVS9EaEpkVmZORjE3MG42di9yekNyVGJhemxQZUQ4V05nM3JOSzZ1MFcyL1crbjRLVzdZOCtYUmZtUjR1eWN4R2ZETENvMm5BNldsZGNEM0R0bzV2VjZYZ1NQd0t1azMyckhFaE9TSlRXai9XZ0JyN3dlcG03b25RZGkzMEVlM3lsbjNmZG8xZmcyN2ZFVzd3MU9HSmhITng0TFJreDFwUTZ3ZE83WXFQUlczUkFPZ1U0OXBwNDJ4OEtvSytZc2MzazRWRDh5WGRlZzRjc1UvQUd2T0R0K21YY1MxNUlqd3lzaEgzbmY4cmxxMER6b3FsMXluWkNnVDRtTG5oQTJBMmtiR0xjZDVHd0NrakpmVXNaQUN3YU0rdWtpUDhvZFRORnZYam9Da2ZEaFQyN3ZTODJqQ1B3T0ovNlRMUFVQYkI3TFd1bG5VYmM5djc4VHl0WHg4OGpvRkMrNWdvbXpFVm43SDk4OXNhMXdPMVNCSEt6SjQ4WHRsbkJPdHZMK083RjQ1YUVJTStQaG5KQ0xjclJqTUFPclBjTUpoN0FJQ3JNOEsra2Q1OTdTbC81QXZWdlpUSjhUMzB5TzZ0VitRVklxOE5HMjFMenoyMDVBbWxVeWJSU2dhem9kaGo3QXkvWCtVcWxuZnhpZlZSaHJSU0xZOWNLd2VvYmNvT0t5NTlaa2pSOGhkVEkzNE9TM1B2NTBmNmJzY2NLRzlmYjg3ZG5nOENBRTZIMTBocVNUUGEyS1BRZDh2M2VTaDlLYno3Skc1Rm1MMUtZQlY2R0RNZmJvQnBiTTduWGNJVC9XTWR2eGFTQURnMVJYcFZacUsrZW93NjNNTWhpWFdGNVlqbi9scVhySDZZU2gwd1pmVlhSNDlLRzROMTRYMERjN01TUGdTdGR6MDdqZnBmQUM2TWROS0VkZ0tGbHA5TGN5bWtHK2FPNEJEMGIzMktLL2FMWUJqVUpxakhYblF0djhEYXo5MGVqWXZNclhycTFtR21qR0pVZ2lDZXVneWI0VGxjMklsL3Ftb1hlYWIvcnJPTWxoRGJYckp5SkxnSjMvcWlnUGM2TWVHU3dURzZwNG9TTnJ0c0Q2MTFrTnE0Nk5Fc1N4NzZSaEwxSW5PYmRVWmE5WFU0K3ZQVTM3dGx2bC8zT2lhUnhtVHZBc1hHalhLZFdQbXQ0eUU4cTc1MExSVDFUcHREMmZuRTNqWnUwUjFTVzFucHJUcEViclIxNXhmNWhhSStqNHVSZit0enMvUVdoelUvQzFzV3JYZmVlTnpyT24xaytPb1k3WDhxZzVzN1Vsc2IvYWNlNTFyV2YyNmFjdGtBQjlmSzBKZFRsL3V5MnN5cWd6V090ZnRvWFk4aTg1SDI3K2VhanJIZjFQeGNrYitRR3FrTFU2MzB1eDc5TG9HTDA0UElwRjlTM2NodzZKQk5OYU4ybFdjdWdidkE5WHBXMHUzTmhiZUg0T1pJdTJSdHBiT3NrT2hPVGFxVFYwWVJ3cU95QUFDZ0ZXM0hFdlVrZVBTV1p3ZXAxU0VaZFpEQzY5MkU1czNSOUxJbDI4b255ZGJhYmNTYU1OcVdpKzVndGJ3MHY3ZE5QVzA1eTRibDNBRHZzaVREUTdnV1hRb2ExWFpWZmJ4QXJ3azkvY2pKbWoyT3ZWQi9scmZzN1k2YzkxbnNoZjExVnIrY1gxNittTmVnMDM0RVczK1YxWkllQ1M5Q3ZHZmRpZXJiTE5iaDkzL3JKMWk1a2xFWTJldlM2WDNJelVUVDF6STlxMkdkT3d2cExaL1MrazYzc2pnTm5KeDE4ZllhbUlabkF4eDFCWHVIcGpXMHdEWFJIbWxJYVZQeUxmQmUxV0hKNEl6Nm00eTlXYllyQitjYm0xMTJyM3lvbWgzd3JoRWVBN3ZWM0FBc0VmVk04eVFoWGROZWxKR2RsSExFZDA4QmlOSnJSMURibFhrWUs4MnA2UE9pWWhTSitlQ2d4VTU4SUh1TUtZK1hnTmJqVHdJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1CQi92ZmYveW1abk1mRi9ZcjJYMytsT05vUkRYc2U4d0o0MFA3Z0xBUVBCTlQwMVlqVGUyK2hucXhUaW95amRDSUhvSGxFQXlEaUdWdzNHRlRhQVdDdHR4VTloYnBvUWpDaHIwL0xLWE5hLzE5b01ReWFFVlBySU01dkpzRlBFNWVXanZPV0xxVjdsNjVjMStFcDJjb2hvaXpNcy9uSWRXdlB0UnpyV3B6WHZXWDFIQjNMR0d1YnJKa1pmSWs1UmwvSi81TzF1TktWMHRwSFAwTFUyTkxVSjl6NGx0SW1SOTJpSzI3TklHTm1kVHVDMFQ0VnJwOGl1ekl0YjB0ZHpyNUEwVlAvdlVjMExuZFhtQlRXVnhMNGsvdjlYNlRjeXFKMW9iNURXMmZTZEVsSXJ5U1hwck9FZEJUck85NmhFM00yWkkrWTE5WjZaSlVWWFhlbFJteHAzRFo5dkM0cGI4YldieHIvWFBuTjhFb3Y5dG02dnlQcjFlWUxJcHUxTWEvKzBjZVdaWjFhYmQ5S3BIL0IyZEJVNFVqWkFGeWRQY2F6dE5KSkZvNEU1aDRBNENoRzd5STRHVjdaRVF1MVo4ZGxsUjFsZEYxbU1IT0hPdksrTGR2VzYyR0llR085OFRPZzI4TzMyN1pzMDNFMHVTSWF0Mzh0SHZCZTJYMVBOTExnUS9NK0FmRDZJbVRwbVFudjB6WGJPbVhpejZpL1pyb0twMzRMOG5raWVwOS9KTCtIMm5vZjFEWGlKVE5uLzJDVSs4MzM1Vmp2K1BUMHUrMDU4ejNUeUkwK05ENXRxM2FNS29USVNnMXVSVlRKWTNnQVN0VEk4OHFrUUUySjlEeXBqVGFsZDRVN3duNEVPNkk1Q215RENsd01yZXU4cnlIVjZRRUlNZGhXN1Zram8ydWV4MzhsN1Fadmk5VUFkVGlIZDFzTTN2aDlaZXRyVFo0RXZwZ0tBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmM1SC8vL1YvWGI4aWJ2cGk2NFAxcDk4aWY0ejROejYvSEFUZ0wxb2tGSE01eGJSMTZjTnVwRVQwRnd0QVpubk1hVnhGU0pnQXN0TU0vYjRwMW9wdjM5czE1Nm1sYjJGbjNadFJnT3hsUk0yTG1zS2FuU2IvTEVndHJPZU1xZXFTVDFmRmErcWdoTWFKMXZlY3llZVJFMG5ObDk5NlA1Nnd6S2ExVEliK2poUlBRVXhLcW9Cek5MMzBoMVJsT1Q2ci9WR0Y3a25zeDdtL2JVcEdGS3JvUnRyU0lwK3plSTRDOThVc3lwYXpvVVpUaHVraDVXdWJRQ0FQRW1sdkpLR05VSGVxUzZHbjQ2L0J0dnBiK3lxeFVlbUsvOVNXQjlxOUMxRVRyMzNJZUpNMUx5N2FNWEpxTmtXM05IZU9MRTlzNlNYWHd0RmZyMm1mVnBTZHZXN3IxR3ZENXErMUxxVHp2L0VLL3FsOUlKVTM5K1VKcVdrZElHY1d1NG1lbUhBN0FMMVNyMGZDUlpWQjZWaVVBOW1hUHVTSlppZitRYTAvWmtyVnM1Y2U4QkFCUVpsaVRsdjd5cEkzcUs2KzFIUEcwQkQwcm9iS3NzbWw0Y3RUTnV3dU8xbVhQdFRFYVQ5UHU2WWxvS2JNSDlndXBEWXU5NWZwZEtNeWsydk4rNjZKai9icHVnSjZ4SmVrU1NjWUlPMHYrV3F2K2RjOXMxTTQxaCtnWFZBWC9SODY4ejZUKzRtb05IYmRqa0RTVVRUWjhTSkpQaVlZdnNYK0U5SFVlR2kvWFlia3U1RHFSdi9oUlZ6WmxXNnNFWDBvTVRxWTN2cmRzTUkzK1J4cCtROEtqVEtYaEM2N0RpRVV5V2taMHNhYzhlTXkxUGswYTJXUTlReWE2TDdMcWl0VnFBTmI4N05rWW9tTzY4RFp0eUtva2UwNnpEb3F0VU1jVnFUSlZHSDNVanVFQjNMVHFKZjVTOUtuMFZFa0t0K2J4STAwYTY4YXQ5UWpzaHRUa1hQZmhpNmtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUJGL3ZmZi82blBMbmovbC80cXUrdUxxUXN6amtrRXYzaCtSZy9BMFZqamNlTHBXN2VZQ3A3VElTaWVvd3FxdEpFUHlMUWNaQWJBQnE5dDRFMTdNcVJwNnpubHhudTdKUkxoTFF3VCtucEVqazY2ZUwrMkhNQTNyc1FjVzQ1SndPZlV1Y2l4NlZhOWVsYmsxck1udlVvamV1WlhpK0pxS1Z2Q2V3d2tyWU5YdG5ZbUlRbC9INGVmSEhMVGVneUpUVW1QS216cng4OHBpcGxOSHZueTNiWWsrZVR5SlFXZlU4TzdNUjR4bGdadndxVitwUDI5L2lQMWZUbFZneHVRMnJ5TjFtT2tKbzl1bUx6NmFCdSsxUkRyY2V3OTBWOGprL1ZuWFhJS3hFaXlpeEh2a2Q2aUk2TVc4cEtVSEtsS3cxczQ1S3ZEZGQ0V1BSVTlUcnhIRjdhd1hmc2lYeFNSNTRxK1B0TXZoM3dpMGxhZTlBWGNkeEZlUnhZcGhJM3p3dDhYZUNZOU05R3lZSHQ5RVFEc2lYZmN0cmhEb2haOHoyNUJZdVRxQ3dDNEZ5T2VJNHpZTld3dCs3YTZwRUMrcUU3ZlkwYzJFODBUa1ZKYlAzdTlyeEdaZTlIcVlZaDZJbXJaNFRISHVHV2pqSktoUHBjUXR0QXo1OHk1UEJHODdHZzRKOTN5cWFYMyszZHJ2N3JVS2V6ekkxSHlweU5Ma1RXMC9MVmRSeGtrYzMzM2hhbExTZitreElaLzhrZHAwUVhyc29zWjd2L1NMZlh4MGhSRnpNbkgwN1NXQnZkZ2VRSm9tVDMwOUN3NEhjSmFBWUJJMVBEeVB0THdxcThSS3ZPaWpObzNKQ1o5RHBacGxlSHA5bEd5d1VsQkI1MGU3NzVJNjhyTjZ5dlp0U1Y5Zy9rTVJMd2JmQnBQVVJZazFxY1NxSXBVdGNqYWg3RlBpRGJJUTVXSXgvYnJ0Yk9rZUVxZC9vOGxIQUFBQU1DaUFNQllNS1VBQUlBRDJoSE00bWtlS015bFo0QitCdmNoN3pxZU1YY0FBQUNzd2NvQUFBQTIwSlVBQUFEQW5tRGxCUUFBY0I2d0tnRUFJa0JuQUFEQU0yRy9tRnBmTFpGTlgweHQvVWwzNU9lNWdNYzY4QXh0RFBZa2V0U284MWhYN2tOQnhYbDlHNnpqYXBJdnZ1WFVoQkdudUFMd3hQVm8xQzFIVHpNcHZVTEFPYkZzUG0rZUc3Q1hEZkFqNTdYNExTZEcwOU9sdCtFejNXN1JjNHEwZk5aWlNaNWpTcm4wUFdXTk9jdmNSL1E4d0paenBhUjh4cm1BMGhkVTFTYk1iWWFhK1FWQy9yVHhkWXJ0S2VPeGcrenNNc1poTmFwbmM4TEpZdUkzS3NFYWN5UmpxRG1ZRFZSY0NNbGIwenIrVy9LT0hBZWpkQVhYdG12b0YxS2wrR2paNVpYNzl5cFZWMlBodjlJNnE3UlBxZHVOUDFObWROcHFtMWRMVjBwZjFIUmJIaTFyWWV1NG56c2kxdmpXNFhWdjVpcThiQk5KVGJjcDZUZmluMUxrWlAvck4rN3JIL2tubkJhYzBoZ0hoN2MvanpnYmVJWk1NQUpyRkdoRU5VWFA2anQ2TlFiQWkzZmM3YkVDU3JLdFJ4cFMraVYrbE1VT0FBQUxYbThkbDU3emFoUkgzbDRyVTdLaXZXbVRJMytQTFRTQ1hwbk83WkxabnlQS25rbHZ2NThOMGVWZ05LcjhsVXRaTnZkVm1wWDQ0TjQ3d3F6OWdtY2UyMDhaeHZtWlBWL1dMR0pNMnNUMjFPM2pYaGI4SDBTMjlDeHJrWlR6eStOWTZyQlBLc3ZHWFpYbEhHUWVmZVd4cDlQcSt1VXpldGRsbmE2OC9wK1Q2LzF5YWhIQ3FWVHBhNjB4VGUyZG9LWnpWRW52MWJ3RGxBVTRINjNHWGNRRkNvN0hNdVlpanpSR1l6MCtvZlNveW91aVBYVklLZDVOMFgxRVMxa2piTGhrMU1HNkQ2aWdIZkIwdEpRVzdFYnZYaTA3SW4vS0lIdFREZnFZbGo2S3gzQUJidXhOMmhwbFFZMk91Nmg1RlpGNU8xb1gvUVVzL2lwSG1PNUpLWlA1WW1wWkpZV1N2eW5vV0FBQUFBQUFBQUFBWUJKbjJIUmo0ejhQdEMyWURjYllOUExtRHdBdUMwWXhBQUFBQUFBQUFBRGdZNDhYTlFFQUFBQUFBQUFBQUFDZVNQNzMzLzk5K1Y3MFk0dWF2cGdxTWVJWUZNQ2pIb05ZaFhQcEFSaU5kZkptNS9HMDJtbmkxbUVZUnh6ME5aVG9LUS9GRHM1VkcwTTFnT0cwbkZ4MytZbjZvZVVySnQ1RGZheER4d29uVkNvVVhBL05oTC9KbkpFT1dJMmV5R2luNXh1enJBN3RlWDA5am53eDlaMldIdTBXUG5PeTVVNUhuTU9sS1dSUFN4OHgrQ0lqd2JNeDBvaHE1aVNrYTJFNUhwQWNGNmdaYmRKUi9ORXZxRzYrSHNmZnYzd0t2UC9JNUNKSzBlTnJHVW1zbGJVQkhyUTVhV0dxcmRNN1hxMFQzS1Y4VWw0dXY2Y0JSamsydkR0RUxhK2ViaXVaSDcvYXVMWk81cmNvcEl4UHVDMHpYdllJM2EvMDcrcG8xU1RydTdwczExRHc2a0x2ZUxXdXFjeUlmdG9EUzU5NTdReWU0bkJHL0h6RmRCVzNySGxKejl2US9VdW16ekR3MmxsbklqcTJ3QmxwMFNDanl2QXdhdlVGb0pWV24vNE1zN3BsTG1tN2ZPMGFBQUFXWmxwMmUrcWRwYXcvNU5xYjc1c2VMd2FYMzZPSExWdG9sTWZQNjRtSWxEblM5b3R5Wk5sbkorcUtlTGNsY1FsclgweVZHdlA5SlZVcUs1MlhxTGN1T2RLM2xER2F5QmRTUDkyWmhmRFh0ZHQzVWw3QldjK1hTdlhmWFAyMzFHSmVNcWd2c1U3L3VjKzhrckFscDQ5ZmtsWTc2cStNN2h0a0tldjdvczhKZjJVVzU3VlVSb1RJNnFhbEE4Q2daYk90YllEQjlUbWpJeU5xU044RWI5TkxhMkVpNFZ4Y3BDNGNlK3lUdVBSMTJWQTlFL0Fhemxialk0MDRCZEdudnQ2bC84ZW1GL2E5bXkraVlzS0NvM0RvczdjUFJjanUzWE5hMVhqMDAvNWUreEtMZnpOZUZ4SU5UODc0YjVndnBvSkhnUWtKQUFBQUFBQUFFTUdHQVl6bXlER0Y4WHhQMEs4QTlISDhIRHFrQmxBZEFBQUFBQUFBQUFEMkFudFFBQzVMeGdRR0FBQUFBQUFBZ0VkejlOa2NBRnlCcjgrZk96aFNyT01UZ0kxMW5EcVgxaHNPd0dpazR5Qzg0N2lzLzQ2Y0J1RWQvdDZUSjA0M2JkeW5YNjZ2NmNtcXVmRFoyU0pKUTBDVmdCRGMvRzQ1SHZ0aVJFNjNrVlFoamZmSUZNdkh4TDBQMnFMb1BjYm14TlRqdnRlTWlKK2x2T1Ribm9Bc3BYMkh2dGZiVEs2OXh6UnhkMjUxc0hVK2thYzhLc2M2NDhzeVJGcks4dWFQOTZ4TTlINWFObGplalpyUW4wV293NmJiSGYxZWdtMVdCTmxsWGRmbEhQUkNqWGNHdWw1Wlg1S1VUaG5uS3lyaHZXOXIzR3N5cGRYOWxWWThVazhyZzhxdmkvTHNWbHJHcTBXcjhXYmRwNmJ2U3FBY1Q1MDhpK04ycFBMd3NxUlQ4aitwdlAydHAxdVBna3h5UmxhLzVZc0VmTDlsVTE3ckhCUENTL1YzRnNZMzk2a1F0WXdLU1JldWpyL1UxbUdMMXJiaTZoN1JTNXJjVWZPSXl1WHliL1gxenhpcjJ2M25peHJzOHNnN0tKWXYxQmNhc1FqSjIvd2I4WG1wUTJHTDhpT05PUzJkdGtaRVpOTDRTTDdXOFF4R1krMzc2YldsTlR4RDJiTG85N0lpQVBEZzFWWTlZelE2ZDdqOGRieG13VUxyQWdCYTBTekdYbGR3ejY2aVZVOUhQRGZlKzBoR09zOTlTdDZkR1RZUDlZQktaZGRwUFBJOHRwMTM3WXN5d2x0cjdXcEcxSHZVL2JmTW5RWE5GYkdTU2JhN0pOZ29KQlJzUDNXb1hUUHBQSHNCYVo1YWU2cG8vMm4rYURxZnZUSktxQlg1TzMzZmovQThZUE1zU25nMlZSVEh5TGZzN2ZqZy9WWmNXM2oxMTFvKy8zUkIvK29vSjRlcldSMnpyb1huZVVNMjR1MDZGQ2FYZFY5UjM0OTF2MFZKYStHdEE3ZzBubzF1UkE2NEQ1SnhLYVhwWDREOTVWcmhGeWU2UDVCbzFlSXRlN1NJNnBCczlCWTdRc3ZQV3pBZ2hOV28wWTRIdStLemltVmIzbm9LK2gyL2ZDbVZiajJXMTFvMlc1U3N5d1lQcHRlQkU5MUdXWEVPMFY0VkNYTzZRbXBFUytGUXZLOXBnRGNSSDcwSGJvM0JGMU1CQUFENHdVSU53QkF3bFFBQWdBUGE4UWs4cjVjeHJzRWRPSEljSDFIMjArNFhBSEJWb0RFQUFBQUFzQmV3T3dBQUFHekI2Z0FBQUFBQUFBRGd3VzRCQUFDZXhkY3VSMVMwSEVVSmRMU2YwMmNsUFFCSDREMHVvdmpFU05kYVVaR1RLSUxWT2dicFJyeHR6UVU3YmxSZE1lakJtd0RVWUZ5SWRCOE9XS293N3pHOTRQcEVUcUs4TUlldTE0SjluY24xVDFKeWVqZ045MWt4dEZCdm5MWDRaMmU2SlUxSi90YU50bnBMTDQwYTBOcWtTYzQ0cjZYcGtWZHRmRXVWeG10UWJZNHVyTktiWDA5MWJycnA4ZmpLQ2Q5WnpMdytkZHc2RlY2S2o1MG1YOWZCazQvZUh3MzNsRkhKcUw3STkrNkxMTWgrS3c4cWxvNkRxaTdGYzY2bHQrNVNmaTdjZzJmc2FiS2x2bGpDUnB3TjNKUGZWd2M2WG91aFUzS1Z6dmMxMWJMS1Y1ZGg5UUJISWUyZTMySGJ1VTV6YnV0V2gzdkhFcmNPTFZIQ0hDbWoxaVZPWnZTOFpldCtKY2RkVWRKYVpYblRTMkUwTDZmUnFmN2g3KzhUbTEvWGhha0JVNGRTTmpMRUljVGs0ZUxyN0c4UlAxOUtYUUo2OUJ0WENvZkhockRHaUhjc3pqd0cxRnNIMElzMnc2TGFxTFhzcE5RQmdKbHc0OTJyZFZxdGp2OW43MDJ6SlZlUnRGMDRHVi9OZjRENUo2ZFJkNjNrVnV6dGNrZUd0VFJxWE8rVEswOXMwUmlJeGpCTWN1Uk5VOHVVOGxuTGxxZHN6RGNBZ0lUSEpwQjA0QW9iWWxTMlIxL1BXZ095a1g2RTJmYVhOODZUZmtSMjczMnRXTWVpTWozOU82dWVTKzUzWUhMdDhrcVRpbkZURmlxVFB0TkkrL0FWOTIzTlkwMW5lSGZqcThiOUw1SlBaWXZOUW93ZjZ1bjcrT3VZdEVYMkIyMWZWcVZwcFBDUHpEYnNKMHZXN24xZmE4bCs1c2p2TzJ6OWxFM2QyUHlKbEYzRS9Ib2Q5dm5idjdueFdVait2VSsxclJ0ZmVtSktrVldFNkR4Ny9YZHJQOCtNeWN4MVVxN0JWNklQcVJZdEhZYk1kMExzQ2hIdmdweUQ2YVg4WDh3c0c5MjdINkxUZUtTSlBYV3dUTm1vN0dTRVF6Vk5SSnEzbG9PWE02VEFJWXp2Uy9ZMGxpdlpjMjRSM3ZrcTdmOHdUQjdJeUdDTjVNLzdQMmVzVHpUL2FKckhZaWtkRDFBZVlhTDJvcllkeEJkVEFRQUFBQUFBQUFDQXd6blRHd0pQekhlRC92MXUwTDlnTms4YlUxaC9BUUFBQUFBQUFBQThBR3hCQVFBQUFBQUFBQUFBQUFBQUIvQkhQMEx2QlBCVDhCaEhIUDhJd0NnRFkvRnYxaFhhNkxiVFkvSkpjMzlQcXZGKzRkUktoeStsZ29hSGpRbE9YM0ZXVnZSa0VmTWtxTG9Rek1OblVRKzZMeDRIWjkzTzd4ZTJ5dnZrNkorNmRLK0YzalBkSWxwajlHeHdPbmpPZWt2RnF4VlhsYkg2dmgzOXRPdDJyMkdteFkzZGJ5Rnk2TW5mUHNxdXhIUG04UkdsTXZQdFBhV3F0cGErK2lpS0dkbm9lKzg3cWxzaVdIcW5KLytzL3B4M0p1aDRqZlluMy90eUZMVVY1L1RlckhPWUErZEJ2cGVoWW4vcFl6azk5ekZhaGhYZUsyOW1IUWJiZ1pnYm01MmxGbUdaVDZXWXlmWmw5S3o1M3ZOOEpWWjZ0TFN6d0V2Q21lRDNvbWVrU2FPN2R4WWZvbUlCcUtCdURNODRsdUpYcnRaWHNHQUJBTStDVytNMTc5MVIzby8xZTlFNTZVWXMrSlZ0aVRWaERWL1RycjNHVFdDQW0xOW5EVCtjN0dmMENjZ3hGQ1dtR0RsbmE4WHR1NWUvcTBIT2EvZjNSZkRMbFdvMXlGeDZaN1hhTDR6U05vdmZYL1JwV1ZicXBaSFZzcXh4d1lkWis2QzU2NWhrV1dTaE5wN1ZILzZtUjJJOXdvb01KWEFQWmkvS280ODBNTWFtTXJZSzgzSTg0VmJjU0psV0hneVp4VmlEQ3Axd0dFZnRxVnpQdEF5SFRjUjJCeUNFTXZhS29JOW1yWTBSSHE4YUxVTWlPOE5CbUpscnhaL2ZmdzdzRmVxcDBWNDRTK200bGZFdVJMK1hDOENWc0JZRzRaMUU3RVZlYU5hTzlqNWlsWmRMeHIwekQ4QXdJMlBwaGphQXBxOE9NWFcwSjJGYmZBM20rdjNoQnAwMHFHNXNWMnRMbjJGR1RHSDNvOVIwRk42ZHROWFJXc3QwR2hLbW5FZ3JXWXBMeThlVjJUTVNabHVZQTZNeFMwYWI5YWFRSWJNMjdqTFQ3NlV1OHhXL3dDQnNYNjVZT25PZGNyMUtrMHRuT0RiTWw0T0VzcHMrc09ieEdZOFNWdlZaNml6RE81Wm1McEsrUEpuY1YrU2x0UHp6d2xraCtULy9acVBOdHZqaURQK05rK29vellrazFDSFlwdnNiZTRuSXZDNmljNnRZYytnZHNmK3phUE5ad3RzT003SEdiVFRmL0xKemM3Mi8ybzBwVW0zNkltVnhyejk4M2VvaHhQUDc4dWJ2MG1mMXAxZW45S1NacFkrS293enAydUtJOGYxTXBKNkphaGJ1QWIwbDJ3b0g0QXpxVmRqVzR6NTVteXdwVG9vZmtlM0oyMk45QUFDZUI5VVZ5WEh0dFNONjlWaEVUOCswTTBiMTlzb3ladTI0VnF3Tkt6MHNLK3pJNkk0OExhaURselBzYU5GVldLZEpodWV3MTdYUXdlZzQ5dHB5dERUZlhNcXYvL0wrTmcvOVR6UTJmMXhQcVZ2NlYvMTcvYzVDK0NaUDljbmtPdDl2WGJZYTdiTnBQaUtaZmYvbHhwdXB0UmYxZFVyZXlabkRQVGQvaldtRmQxdXlaZldWa1ptL3RGUnlXcy9xRDhBTGJvTWZNU1RCOGNTV2pER1pJMlZ5U2hKakxJejFaRTlMWThtYzRTdXJ3MnZHbmhxMVlNaDAwUFBvaWw3RHpKakNMRjlFUkVZa2ZmOSthVjhHdmNaUUFXK2lkb1ExZ0t0Qjl2TjZpbEtrZEMyTlcwdU9WcVhIakhmTEdCamJhZ01IM3FhT2RNbWZ0SkxpQ0xNbVBQZ2wwaDVvTzNBVnZQTmJTTGV0TzlMZVpFWlZib05YZDVMb2JDWFFnd0RvcDNlM2VWTTRmZVYxZUhreDAydHRqZ24rWFhnZGVWTDZteUE1d1lOTFlrZXBmR091VTJzZWE2Zkg3VkE2NDBabGUvUDAxc0cwY2pwa3pVby8wcTZHQXU5cThpSmZieSt3VEJqWVdlbUw2TnA0TE5LWTlMN2NRNTk0VWxsWktWSm9pUktaSjBlMlp1K1RwdG55Ui9LT08xV0tFZCttNzcrdlZWOWVpT2ZUWE8yZCtuaUdHaS9lT2NRVVdsNy9pdlBYWFluSjZYcnlXdmM3Z2pBUHRxOXBaeUgxNjQvUE1zUDl5TG9JbVpOYUpzM2djVHZ6c2xiWUVOTGFFUEZvamM3UEhtWk1TRERDaURWeXBvWUFZQ2JhTTRBVjlNNmQzblN6OHdJQTdzMUtyNVlsdTFmM2NMdW4wZmVEUm15WjNuUXo4NjdRNDdOa25yRURIV0cyZDNZbFo1UmR6QURGN2ovU3dOcktUR1BFUEtGeWF2NzNLN0hhOWZnY1pGbnp0SDlwRGx2Yi91WDlYTklQVGd0MTVLaUZwcGVqWnorb0doY2JrU2l1RmRzamo5eTJpOVRQZGNramp6UzRrazZZS2l5LzkyWDV3RXFUWnkwVGZNSGdYc3cySkR5dVVuQWVLNXlIS3h5VzB0amEvaTFDT3VtWFRnOWw1SWtHbFRHNkg5VHl6dDZqMFRvZjdZY0VMN1I1RE55TXpMbGVtVkk4dStmcXJLQ1ZEVU1GdkNtVHdqZXFnY3h1dFlrSTN0ZlFaR0hqSXp4bW5lcnRUeWlGdzRtTSs3VS9URjNCRE12Mkc0aG9zUkhQSEFBenlFWjRpV1dOREdmdlNSU1huaUl6S21jY3VRSFZBWmJBUGF2UXdtK09kVnZSRTBaR0t0SE1YMHptNzBIYThkS25zalJ0SFo2RStBc2hxWXpFaE0rN0RhNHhTWm5HQkpVZGJaYnhUc3VNdE1BUm5EbDR2TmFjbGo0bjIxMDBVb2VaSEZUVzM4SDYvdFZRWm10QVF6SjVDU0liWTNBL3V2ZTUyMmVCK1hYOUNlR2xYV0VzMGpETkt6WnBublo5elRZNmxrWmNwZGJDYzZXNTAxZlg0cENZbW5Ic0xYc2MrVXVvdWZxdlZqZGVxbjd0elMrVU9XT0toT2NHTlpoRzFnWUxhVDN5c0dMT1dQYzNkM3p1bHBuZGEzOE8rZUkwamV0QzdvZXh2T0hjNW16emFFaGphK0phOEdhMlBIQkZQQ1BIcTdXT1hJMEI2TVhhMWMwYXg5NlhDTFo0amxWMUF3Q0FLeExkYVVmeWFiYk9YVHdSRVdidk9HdTVLWDN2T25TRjNjL2QydmpuS3gvTWxsUThZT3FkMGJoZXdKcTIvWjF0NTNxUmVUOWRadjZxcWROVGY4WnZ2M3I4R3kvL3UrZExxQktTb1p4OXo4M2lKWmJVZmltMWpxMnFRSHlkN3pvSWVkdDAvS2dyUWxyYUo3OXByV2NjcVluaDBuT05MSzhWMGk1a0pSNnZCTGc5bGlMMmJJQXRJNmZPczhKVkN1WWg5YS9GVVl1c3B1d2Y3SlR4VEZPTzZCT05WVTI4NnNrY2hiT2FnTUdNaHVJZXhZSkRXYWtpczhjRzRQcS95TW0xYXdDNnlVYWN0dFcyZ3h0eE5FOFBNSnNyTENjd0VLbWJhTVZhd0kzVHNSK21IdW56b0dVQ0FLNkR0UXBhWHVRZ013M21weTNnRWJVTmRRdENhSU9yR05kVytpOG42aUNNeUFRUDQ0dm0xam5QRDdaUy9aYkJ1anBlNFFrS2R2QitKbHFVUjNiN1lGbmw5Y0tJQkgySXRjK3JYMnVsSGo4Mkw3QmpxSC9oQlNaem54Mmh0akxNbUdQZEtzSGFaTDdqbWJabUN4VzgvSnJzUzNJbmI4UDhldVlMNkt6TXZsWnhYT25ZbFlIWkhPeCtCZUNXaks2KzJoNUc4dHN0dGJNQUFJOGo3cDFjUTlUdWtIU21sVytFM3YzeFdheXExN2V2TVZlNHY3dTFNZllGZTY1MDM1OGZOR2IybWt2N3ZpNWF6ekw1ZXo5WDlGZFc0WU9qK0d2dytlR214OGVwdlZocFZWTjZwckZ5M1pXZm8raXJ2dlZEWmdBdVFaNFVEcTVCQ2NaZDVYRXRuQzQ3SXZzTzc0OVQwY1RBeFJXY0dhQmhwWS9rNXhVV05VRnlDbnI5aS9FREFQQUFuZUhtaUZmSnFZdy9iVlFXSDdBT0FXdDFEcEZqYnJZZFEzSEtBcUFIYVZlYWtuMVNRZEZGMWttVElJTExvNFZ6K1M0M0JTSVZFdG95bXk4RjgvbGNSYjd5bHNzMUhMZ2tNOGJKRGRZcmJSa2V4YXZ2L0FrQXVBZVNLV3VyaEpFZGFEQ1BaV2RiNmRoRW1meHJ0Y0NzMTI1cE9NY0VRMEk4Rms4cUt3WHJrbzIwSHV1UHl2UnNxTGgrNnJsUGovVnFzRHNXWDRyM3lOcTNBOWZpOGhkT2YrOC9ON25UVGlhOWxyLzZxT1cxNHFOdFdKeGhuR3lhcmV5VHhSVmFLOHVOMURmZW5STUhONjVMUUthM1RoNUhoeWN0RjgrUFpKMTltZEk0TGNZNGxvZUJaOXh6TmRtWHJsOXprbWc2YSt4SDlWaDJwSlhxbFlKbFNYSWk0ejBxeXpPQm8zSFVCcERTZW5XUzFiOWNIcDJQcjRHK1JOa2syTmVrMG1GL2Y3U3FqbmNocWxueDM4NEprb2k5cGhGRmtwcjR5a1Q2bTc3S29hMlYyalg0SmpUTmFPV3AveTRPR1JIekFvQXo4VmdaWEZvT2oyVTN5NHFJSU50dUFJQ25rb05wSXJweWx2NHE1TjlhTmswVDNaSDNNRk9YU20xcmxTWHRHbnJ1RzJzRENESGJGZUZncHVkZlM5ZUxOVS9sZkg3L0c1ZTNNTTZHWEYydm05ZWVWaTNWRjFKMWpmVkpsM2J4M1BzZnJZc25kN1ZmYXNYUVAzWlJmUC9tOTNNR3o3NVlvL1hadnRxQXhFbStYM3J0R1Z0Y21WdnUzL2pVeE8rdjB5NWRyaVR6K1FwSlA5SmlIK25nQzdIVkM0ODJISEpISG5CdE5FZUw1T0tPTGhmZWZMVE0xWWJIQlptOW42aWJ0SlpkRXYrNFJhcFRTdHc2MVpibENZdGdQUVhtZklaUVIwNTZPc2ZqZ08weDVvRWJyMThqSW8vTFIzV0ZTOGgyeVR6ZXJhOGxIeFFYQjhBUDNsZER0TUhsTE1JYjd2VWhndVEzT01CeUJxYkltejk3Y1FjTWZjd3VBSjRENW5zZkU1N2F1RGZUcjdJaUt3QzZGZXp3dkJrMjYwMkloNE5tQUQ5c2N3cWJzRVBwZWNiaDQ4emQ5Wm1ENktDOTU1MlkvUVJwSlA1RU1DckFMOWRiNkZacUxldnJ3L3UwTjJLa3NzdHY5RnZYSVRwM3pyaFBmdjcrL0JpMWZGNlViRi9xMUNYKzVxRVJKZEczSkhXSlI5aGQyU2dUZ0Q3b1MwRWFHSEhnTHB5dElTV0w4OGl0R1RnQStOREFsM0NWWWV4NXh6UVNmeGJXZTJwV09Pd3hjQm9Ickd0SGpGLzNld3lFYk1qa2YrSlhwK2lsRU50MS82Ty8xUHhnMFpZWHc3YWM1VE1OU2QxSyt4UElmWGgrL3lONlVNZzRiUG96Mk1FZVQwcTB4YUkvakRsam5ZWEhDTndTN0srZXh4VU4zNGVQd3hWTnp2MDRsVjREc0F5c0sxT1pQVit0M3hhSHV1OEtSamg0Tmw0YllzYnZNb0FmeXdIZy9mVXZHR2JHR3ZKbmYwblBBRE42SzlxWnBTa0tlRmt4Y2REKzRLSndweFhSdUpSOFJ1Nm8wL28wZXVkODNYajE5WGFaNVR3L2F0blRRTkFkZ0NNYmNTVndmUU80NmxMOTVMMmxMRnlIbThUVHBwS093THkrRjk2akNHK0F0SmFQM2NJa3c3bHMvM3hlTXZqOXdsZXFGa3pocktBU3FVTU94a3ZXVFRieWVldFNBakt0dWtYS2twQVVscmR1UlpCVmxMVEZrT1daYkxRc3hhcGw5ZlYyVEdEeGhYTmwweStudnErdCs5dkxhVnM4azF3bHBhRFYzWlpvOWEvVzl0YnI1TjcrdE1yaTBoVzdLblZFTHArczliKzFRZjRUSHVsM3J5RVZtWis5UlBxTmk2L0RwZnA2eDVwM1VmVHJzYzlzTHEvcjdYVzNrdllsN3VPVEVNNmZ3QzhieW56dnQ3SSsrYVJjMGt5aVB4UjA5b0U0N2d1SmQvWUpOODdwUnRiY3VIckd1OXpXdkN4cmZOTndDZS9hb2FHdFM0WGt0M1NFdGE0YWRYcEh2OFppdGM1azBtL05OZEY5eGVoWCtqV1BYeDFjejZNa3FnajZKWW9XcTgyWnN0MzVQdHFEbDVFR1pJOXlSQm5QcGxkVGNGamJmRW0yZDhRQmNBWlVRMnJwVXVxZk80bmtyLy9sNGlOMThkUXRXZ2FZaE5UUkFGd0FhMDEzdVJwSS9PanUyS0lza05uRGlBZUpYcy9XejBlMFM2UU1yOGVJeStjdEF4d0UzZmJYWVNuRlhJT2RXODh6eGtWa3g1MFN2K1MzMS9zN2lkeFA1SkN0TFVkZFZoYmpQL0ovVXhlejdOOER3SkpjOHM1UGs1Sy9COHZuT2RndU5QM1VvTWUra3A0RlpFZWVUejUrUjV2ZC9hanRuSDI5MnZxQzZmVW1qZmE3MXE4dCsvM1JYb2JjbGxMN1NIaFdRMnVGQlYrTnBqS0trTllDUStpN0dkMjBTSEsweDFUV292OHdvazhkK0xWK255WUoxNG5KcTExSGJUb3VyellVUE9uQUFLT08yYjNaOVFubndGcXhISythbGZKcDF1STcvTlh2MHZ3YzNKcUNKekxUanBEMnNsbTlGTVY1cTlJNzl4NkZaQXlBYVZqTDc2anN2M0wrcEtQQVlBSGdPK2xaRERyMVFRNkdneGJwV1JYYUVBeWo3UkpMOEJyc0NEY1BKdlQzMHZQRzVFM2dOdVJYdUwzUDQrUlA0My92UGhqSzR4U3NweWplY0UvYWFRTTNaajNtcVZVNTAzTHRMSHRHZGQ5Rm42bUI2c2VSMkVHY3djemVMMHdmaG1XdmVHcGt2eHNIWER4empzcHpKQzhjT3RDSDRGaG0ybFZRcWVESlNCYXR4OTdxbVlPWWJ5Y3hlL3VFWlI5OEFaeDdXWEkzWjBPT1ZjNU10T2s4VXRic2VsNXRUWUNkK0VWY1lBMWFNYjVIZFVsRVQzM2NWOFhNSzhzYW14MUZESkYvdUNqOUxITi91QmVqeWQySHB6SzEraXViT2UzOFUrUnJRSkp4T2ZkUmg3NGllWHRpMzhKN2laeGR2MkthL2UzWFBQU1RuQ09CN3g4QTBFbVpGQjk1RjZaSDVoY3kwNDhsclFDaks4TVpLd3RXc3d1QURyZ1VLNnhNY1o3QnFRQ3VqbU9Sd0RBK2dSWE9YN0JqZFZQK25WWi8rR0ltdlZWR3hZQjVlTG9FN1E2T3d2dUxVZS9UZ3lKSDBlaG9FYmZBZUk3QVlwM1lJVHg5MlI0Zy9OaGEyQkNDSHJ6SGszMFpuTzd4M21xdmVmVE9GOUFGRGRJUENNRDFLZFcvVjNnMk9ZbnNqSnQ3dTc0OVRoRnJrNnJUcG1tdXlObEMzbzZVSnF6WENvcVVrWnd5dlB0RnFlN1UyQ2tkc2t1d1RDMnZkWDlTZnU5eGF6VHRhOVZRdCtJekZsYnJQcTF3UGhYM21veDhXdnh2Lzlyek9iSkFlZTlyRktNL2R3MlFmL3ZNbktiR25IRGROcDB6MFNldjF0eng0SjJYdlM5QVJYWjVIajNqS1hNOGRWdUQzNUFjYUZ0clpZaXVIUHlNM1ZqVlpnRkRzN21oWWhSUDR1blhoSnN2cXpaL0NOY2FNOWRiYjduUnZ2Q3VQelhXZmZuYUxCdU9CTzRycUw5ZjlTZ09HZm4xWDZrdTdWaHIxNk9vUmVuVktYVTZMazZxUTFMQ3JmdE1TdnFJRG8vUXE5ZkJSbmJHOTJxbG5ueXhGUkNBK2ZSWWRpTXlwZmhlN1J6aGk5dzM5MlhXMGtYOWNnQU1vajFma1BSUTFGS2w4VVVKOTFxd1VTSjYzYXJERVZNditraDJwWTQvMG5iRGVuVkJ1QUhnY2Uwa1J4cmZkdC92cGc4dzI4NlNtQ0czTktHVzcrR0lQVHBYVnZxNWxwOVprZHpFQjFPa0RQVEhxWTJQN2JWNmNMYlI4TzF6ZzFRZlBWSVZpcGcrdjFxeU5MR1NiNG42Vi8vN3V2Nm5pVy9iZEg5SVlObjVqV25adks4cGtmcFQrWmtOVDB4TjlsSTRDOFM3VXdLM3hHdGdsTTU4RWFReUFQaUw1Y2lCOFJwR204YTFkVUZYWFNrOFNsVHRlUE5wNmJ3eW9YNFc0SDM5Nkl5TlAxQVJkWVVRWVZ2cWdVSUJrUEF1SXRJQTFoeXhtandtYnphSzhwalIybzRMSms2RnRRZUI3bGlPNVJya3V1YlBGRGQvTVpJZTZZY0RBTndYb3FVZXU5QnVONTZGY0FlbUxjYkloMUVEWEZoclBwY1doT2gydU1HKytsNHM3N0NXRG5Tei9jNnNabDRUUDJYQ2pqNmlPSU9ENmp2NmRPVlN5RzBtUGJ6NkNqWWxjY2g3R25lY1MwZnd2VzJ5Ny9IUG9xKy9jc1hMdVF3am0xQ3Z6aHkrWWJqN3I0ajhMT2wzVEoyenpraDZ1WDRjZFpUdXh2cnc3Y3g2NlFjakJWeWRxNC9SbmpVR1ZnWGhqRzNOckRLUFhOb0JZSmc1akRtMHJWVjI1RTlPdVpHMEszU29Kdk5xL3FzalhZZFlyNENMQ2V2Z3l0OHpSY05qK1F1NXNxU3RuRlhGRmJ5bUJsTFpyL0JwcDZESFh6Q003bnVsNFN5OVdML1NCS1JtcG43bzJ2elNZT1NDUThGUUF4YldqMFI2Tmlkd2p2NWcvYVpqd3F1cXR3UnE2UUR3NlBWV2lQdWs0c3ZUTmFjTVBRMkxGU3duc1BqTjJuc0NCK2FQWUY3L29vR1hFZkYyYldQOXorL2xBVzlTb3VQN3NDYU85NGNLR3UyYlhRQWNnMlBzYmNQWmVqaVFCWkczSGQ2V1doNTdlcUxLNEg2SUEwQ1luakgwNWV0UjFCWTJUNkVTOHJqbUwrYjRmYkRlbG5sZ1g0N2ZzbjlqOHJzbUZxWnc3N0ZNTTNiQnZWWlFNc0lqWlZqaG11WGxmVWxqNUR5eE9sekRtalI1WVZuVmZlNDhzOXUxVUMvcGE0RFN0YWN1bWRZaENUTHk2NzlsZHdlZjhQUU81MHJmY3BYRXZVcVNxOWhaU1AxcnpZR0JPbVJodDVKSm1iUnR1MndlUzUrMHJielA1NTFMSXd1UFZHWjJwdWRlKzVISzlzN1haSlRObFVWREMxdUR1ZVAzVTE3ZGVwOWE3bDlJa3I3Q21wMzNGWnVEbHN4WGZDYjl6bGF4dDgxbXRuVTkzanc2d3lwYldzZTZKdm9DV1Y3ZDU1dVB6ZkpUelkrbUJHRnRvdUhiZFRzdVBmcnBNMU1LdXlKNWRWODJyamw1SmVrMmdSYVhIUGs4ZlpjZDRTUE1rZ01vWHN1ZFh4UFdZNjM0QU13aTh2QytsOWxqT1dMQmdvb3pGTnJzTXJFc2dnbFlWcWduamRlaTVlSTl1M3JPb3ZZK2c0MTZUS1V5SS9Uc2xqUVBnK1pabWExS1ZxOFpaN1F0bUVRSnBKbGx2SHMyS1RNbmcxS0ZWQlY1Ylh5Tkwvbmhzc01Ya1psOFV0cWZVT2VYVStWOHhhekQzN1NmWkh6Nk9pYTZWdnltNGI0a0trdXB2YVoxZUNiaDNIQ20vRGVWcWc2L0tmLytsMzRabGUrdDFFajJqT3QySkdRMmJTRi9TZTJpVDFWNzNIRXl3WmZnMVEyempBREo0RXBLT0liZVBaRU03Tm1MT2JjNWtmZ1NZOWF6aDB0Sk4rRzRjRTJXTnp5S3p3Ync3Y204ZTA2b2tnbFljNGpyRk5vQjBrWTRNa0RCRURQM1dsSjN2dU5mRTFtY3B4MzlqS0VCWEZpUDFoVWJvaG5YMjRJa0xDanlYazB1bnF1T3BoS1RrdStSZklsdGR3VXMrN0tYdnpML3BMUEF3QURnKzZnZEFONzBEcnliYkRBSHFHZHdHaGg4TzNxYUEwMzRoV2lMSURwOE9aL0h5NnNhZTZWc2NGbEd1cjN4V0VVTjhCVHprTEhaUzhxT011dmJIQ3h5Z0NOMkNxODczVzQ0cnl3ejc4dVU2bkpiT3Niell0N2RtbzdCODU0R1RlY0piOU41N3lwem1TV2hmTmJITG5QWEc4OHJPZk51aDhienJWbjltZ2k0QXR3NmRNUjh3dzRGSE1GVnROWG9JNDFIbXpwLzhUVGVXWTBFbHd2NEFtYnFTbysraTA2WkdUcHgxVFNOeVBWdWMyZlU5VWkxTlBPM0pBQzhPY0NJdTgvWUc2dHBNV1A5amYzKzRlaGJxSjZYL3Y2MGNJZFc3bjc4azkvUElzUWZwVTU0WWRlVEp6dlQxV2sxbjZ2a1pkLytuYUZMTS9uclBzREhCSUpneUR5WEk1MGxtbEtYMHQwWTc0OVVvdktrOVhTR0gxb3dDVTVaQ2UrNCtnSndkY0xxZGZURkJnQm00VmdVMkdHcHZES3phbzNCMmdWV3N2SXQ2RCsrb2ljUGNTd29mbzQ0eGdYOUFXWlF2M1crWUp4S0p5SlozR0o0YTk1dUt4MU4vMHBEMzRmM2ZGVHIvVHdCT2dGbzROM1hNTkhUYmN3VDM3eFAzOWpNNEpad1R6Ni9yRTk3MXZqVjdOZEs2VkcxWmF6My9rakNheHhJYWFOWWxwYW9rWXh3YjFuRlVRWW5wMDQzVWllS0pjdFQxem9OWjNnbEphK0RuVkVYZlNRbDNSOU5WVWlxL0E2M2Z3VDBlOS90M2EvYzRGcjNGUjBUMGp5by84NzdmN1VzbnZCUSt3aGpxM3ZzZSthUU1hN2Rzclg3c3hxTjZveTU3TFZUZnYxTFkvYngybHpoNG91Z1Erci81aXAxSWlINzhPUU03MG1iOVN5amVrd3RldHVjTmhGSnJwQVc3aG5Qa3F3UlBkWGJOdndZK2RDekhqUHpkdGVmZWx2S0grNStqZmZ5V2htSU02SitzZkgzaXhyK3VmU0ozLy8xK1pKM2ZiL2xMY3YzSlJHdnJveXVWNTZ5dlRLOG0rK2l4SUdySVZnUUt0eTJuN1BFdkZaRXI2VUF3Q2lTdHBvNUZxUGpXNXRUdlRKcDNxK2ZhMXJqYmZFYlp5eFRXQnJCUmJBcy9CcHJwMnpaRWNWUkQ2N01rZWs2MDc2WTdlMEE0S3ZndG9Pamt5SzZrUWlLUG1yTzFyNkQzZGM5WC85R1BDaXQ3Q3o2TFBUNG1DL2lFK3V4VWo5NXVMSzFkMElzZGw5RXJhdnc0NjlMVlVSZGk4UmNGMGZvSjA2dmF0bjlsYnQ5Z3BuMUR2N0c1S291ZTE5VFNwOTJ6dVlLbk5rNjA3L2FxN291VkJKZmx6WUhkNVhJblBCT1poalNvRUtiV3RiNkljR3RhVnc0dUJlekgybFFDbk50alJtTUtaYXQ2WW9SN21saUNlM0puQmQ1ZGRYVGEyR2VvU1dsQXluV01GYUhZYU4vR2FSbG1jWjc1a29KWG1kTU50Q0xaVjlRaXA1VzIrNUc1NGhuLzJ2dEI3M2hYd3QwdzJGWVhnNHBQVE5WSm44eDFiTkpoQkVCd0hjaTdWYTNPREFPMThZRXE4bTFqMnBCUFlNcFlDQ1pTTk5RbXI5bzBnZXplK0NiOXQ3ZkwyTzd2V3pFQStCbjVESEpBalFQYmM4QXY4U0VhTnY0T3ZQMEtSdVFsZHJSbWtQZnFabmw5V2pGL2U1TGtwYjZFVlZ4YThRZnB3NEpUZC9kaXNHMXp6TEFlbXJ3ZjMyV0p6OUJsSjhQWFhrZE9wSUZIUWt1U2ZSaHZoU09rUUxPUXRKV1o2N09xeDlwUEdKZDhyd0E2bjFyc0tmUk9jTlpTcGVGZkZaZUFDN0FpSzZNdm9RcnhWdFRyS2N1dldsRzB2Zm1BZUFTM0d6cmQ2VExPL3JEdjBoWnhVaGRqRktLa2xPK3NtVHI4YlpMemZNS2JHRmtCVHlWOUpTemp0ck1aanR3ODhyVGFHWGRybjNuNEZaNDF5TzRMWjlIbVJSdXhkRjBHR01OSTN1dmI5NHZlZDlId3BBQzM4WXM5NnhucnZ6ZEJtUlBZZEkxSmlBNGdXYmJDL3ZpZkhwMWcxZWhBWkZlZi92Zkp2L1RMaE1kNHJTZmR0TlNwYUxPZlBwOFJlakV5RVo0blEvdENNN0NZNW4rcFFqWFFqcE9WUlJEcEZjdFhRSnRIbWRIV2c0Uzd2cW9GblFIV01Yb0duL0JDUjE3WU5uKzNiVjM4Y3pkTEJRSTdnYzNXTDdjWHBiZUQ3VE00U09hNUgwUWRObVhicDg2cmRVdXVpSHl2Q2d3SXgwWFo3VjJKSDNkaHB4aElobEJoZnliakhTZXNxaU1VU05Ka0ZPRWk5MzhKdmRSZW95ODFNWVZhd3grWkg1YTZ6VytTVi93WDNtTXZmTHpHZVhlR1d4dEdManlwQlZXMGg3V1dNdUt1TUd4d1F0MWh0UEZJYW9OUGZQVzJ6ODBmVzhiZSs2Qnptc3ZmaDJZRTFlV1hHWnVmaGhYZHVGRmJldlN4SEJhTVpPWlkxbVNjaDI0dHBiYU1qaStzOUhmbkw2eTlOUm5BZDdMMnZWSkhTN1VUUXpqNW81M1hFdHlQUllMcllNa3EyZmRqZWlSMUs0L2dteWFMR2U1MytoWFViY3ZoeFNocjR0TEg5WFgydjF5NDlCakE5RDhWbDJTa1MrQ05IZG9QQWNkZDcxbGdLUHh6RlJMVXdCd1IzSXd2SGNIRjdFdXZYUE51MkpJOFY5SFpFbFp0Znp3aHJPY1Rvb0hZQ0hlWGJLV0p3a3lWdUNkUWpQck1tdDM3L1ZFekNpNzU3NW5sWFZrSGNCRjBZd1Fia05oRGFLbzIwUGF0SEIwYmtVOTNpdHJQRWZuaWllOS9lVlVuKzg3QzM3NWVGbmpNM283WEt4MTJTaTcxcnc5UDhoQ0RyMWVXdXRrSlR3aWs3YXgzZUp5N0NldjVPdlYwNmZHVDF1WHQ0L2phOVRtOVgrMTFadCt5eE9aNE9DVzlMbzZQWStQcER6ZW9ZUWhkdzgwUlgya1laMUlmbTYvLzlBeDFXUFNXYkptMTZGT1k2V2phU3dUVjBvdnlhdlRRQTA1OFE2ZVNNZGE4ZWljYnFMcXVjNlg2cnhWZ01lbnRmTWhNYThJMURKcE9Mb2J1Q25CY0c2eElIb21TMmtkb3Vwd2JkNXhVNkVZOFYvSnFJS3lLQWtLeFNEdWE5SDVtKzZmQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0lQODcvLzhML043NC9ZM3J2LzZueFRIT3NxczU1Zk9UeU42dkF2YUZKeUZOdDg5cDZrWklxM1RFVzg1RlhwMFpINEZsemE1bEtWT04vUFFJZ0IrOE16dkx4aFVrZFBVS05ZODlaNXk0ejZzRm53blgyNVg5NXlNUE91VzY2OTM1WnlaK0dUV0tYNWVWVEhTYXZHOWQzNkVsUlE1YzVLR1c3Sm0xdHRoY0tsbE80M2MzVzFuUG53WG41TCtoVk10SDZsR2Nkelh1MHJlVWMyZkNCNVo4bjlQZWsvSmI3VjZ6MVNON0J5U1F5YVR6L09WUi9NcnRWRjY2aHkxVm1ic3FMd2J2NUY1N1RVb3Jmdmg2eEFiUWZ4Y2tPdWd3NWVsZnhVaGlTVmJkZHVuKzlSaHhrcXM2RUFMOTl3aFpWaEhySWJ2YTJUY2UrYVNWMTk1eTRnUXZUOHVmMnEvaHRxNWZHbGxVTm92QUg5aWZMS08xc3RlMjY0a24reG9tZDQ2Z1JWWXZSYWR4U1BhS3JycWVyUVdBRFB4YUVhTGtaVlJ5dWUxYksxd3NCQnU4QnhSMXV3eXBVVmpKV2VVK1ZDc3B2YllCclBXWVk5VnllMVV1SFFTMW4xNm1IVy9zejBSMFR4U3ZsVTdGUEF3ZWx5bFVSazlFMXBUSWdNY1kyZlp2aGYvSHN6amIrdWpsczNKdGI1ZUt2a00yeSttbGwzY0o1Z3BNLy96Q2k1TjNsZUN4UEZwNGYxZlByTXJLMDhudUh6OGZmTnBwV0g4cVNjWFQ5dFc5czltNXE4V3oxU3k3QWg1TFl3WXQ1dmZQS3VwQUhqVDYrb0czNFc5ck1aa2VUY2ptdko4K0pqejdJZnN0VEMyZ2lTaHpFenk5ZzRMVHFhODZvSkxnNDVhamtjSDlNajBQRWZLVW9Dd2JZZytZUWRBSkdKL0NJUHJKMWdJUHdxTWM0RmV2eFp3TTdKMjRJdXBBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREFSZjczZi82L3N2L0JOMy9Pd0wvK0o0OGQrVzBkb1FKNGVvNHlCK0JJNG9mcXRlbUtML21XNWV1R3UvTkcyVk5mQkgwTWxRQ1dZUjB6RmowU2FjYm5FVTVneGdGL2xrd2FMbWJZTW1IaWZ4Y1A2VSt2R1JINWlrbTREdVNMcWR6SjBOTE1sTC9jTlhvVXA2ZGxyS09mdkVkL1dmSTgrVWUwb3Zlc3pUSVlQb05Kc25kREs2ZlFaK2E2UGsybkx4THQ2TFJPRWVmYm9XOEVXYWVIenpZOFV2TFBIYU1zN1F1cTc2cVFZL05DWDNYMDBuc1U4SXJ6TUxsNHJnNHJIQjFlWThpeldkMS9yVFQ2OVZML3VJNzBpYTlPM2krbVNtVTA0NXJiWUZJOVJMOStNUFdyd1pUbzJMQWNsVDNyMWNpYUo4bWtjbGF0K1lxVDRaMXNMNU4yWjI3U3ZWSjM5SHM3anZmajExcVhmRjlRelIzaE5aMXpTZTNQWkpSaHBkZnlSL09Db3hqVkhETzBHSmRma2czQVREU0xmWVdGNnNHekFraHBNWGNJMWpJMGMwblVsS2sydUR4MUtFYThsTDRuejZ6bEdpYkFKYkc2MmFOVHRPSGJzNFA1cnhET2xSR1ZIZldFenZKRWFMSlc3TnhtRXZWZVlMMEIwNGxPMkM5YlkrWTgwZmcweWd5Zm9jKy9ZVXZmNS8yOWxoOG45UHNpZmwzaGZrT0VmZ0ZKVFZ2OUhVdlB0MjJiamlkbVJoTGYyZXZxbjFmNGY0bGZTL3VTcnVYamJmTzgrbFVjd1RRZkY5ckdlOUxrYjFVS0lFYnNrVWJmZmhCRDdOcU11dFVISDJtSTZiU3l2MlJNUmZlRG8yVnArRlloV1c1MFh4dE43eTBENm1ZeUhqMWc2UkNzQmRPeGJUejkybFZHVHMyck1sSTZyZzVOdWdTQXdBcW5tclVKelcyeXhHVHBXUU5udmNYd21Ea2o5U3VVaGdtM05adHQwbTloamkrbW9zY0FBQUFBQUFBQUFLem1xWHRQN0xtL0VuVHJDVHl0MFRISXdQM0pwNDVqekNFQUFBQUFBSEF2WU1FQ0FBQUFBQUFBQUhnUzJBY0RBQUI0ODVCRkFXc2Z1Q3QvL3Y1bmY0NlhndmZuMXR4UFliMUhLQng1dk11VjhCNy9NSEkwQlFBemlCeWI1NVFsSFdEZ0dlYldnUldYeEhOVUJYTXpkWHU4UlJCWjcwdEJkMFFPckFPQXhYc3Noa1lKaHQ4Y2EyNlp6ZUZaK3pGNUgwQjl2Rmorb2o1dkRZdWdHY0dFeExibitiVm8vajNoK1hQS3MyV0U2NmN2TTZVUU9Wd2NqWmUwaDFWbVpIQllHN282VFNRL1IvUityR01STGUwWk9XL01pNVZYUEg1Y3VYMW5mYVF2RkxyeTgyZXR5elozMzdqK25OWHRiK1A0VngxSERBOTZ4elErR2VGMW01TzR1bC8rL2swWDhXTFZUY0t6NGVyWG1uNTY5WkdVZnFhalk2dWJWNWNVdG1RdVJ5L3lWdy8wc2FacnEvS1dWVjcvNDhyb3Byei9rejVmU2kzK3pmaFBka0UvaWNlZmFuZHNqVG52V05IU2UrYWZKMzNQdUxWa0ZtY1owdjBKOThzdEFrM1JaUmN2enFCWHVrejZONVBQWUdoNnZnZzZ3VHVhaTh2RHdaV2g2UXkrVG1QOUxPWHpya3VlZFNzYlpWcXRXb0xwUEdtZmpYY1dXL0VlUzl5aVJ6WUFNNUEwUmpiU0ZXZmFPbjdFbXBSa1MyVjRaSS91UEMrSnA1R3Q1Y1RiZ1pHeWU1ZWphSmtyNkZsK1U1WG5Ta3N4VElRM1BjT1lodGRwdWZEbzBPbXhCU3pyMHF2alJuVGhiRStFSnZ0SXZYMUUyd0dnTXVxS3FPTm8vSUhycW1ZM1J2WlJzZzBvKy9Qa3IzTHVmZVAwUzZoU3ZsTDUvZXIwbk13b3BVZ2QrL0xtWnlsZG5YWmZxMDlTdmNOei9tY251L2x5S3ZmVlZmYnhwenpJQ2kxVHpFbnowWDRxVFI3WjNOclgwREpwQzVzdmsvTDNkYUpqNHZQMFJTb3JzK0Z5WGVqOXlXMmNoZkFsRXh2Y2h4SklROTIwcVFyMzVnZlhZZFNPa0RZcFBZOXdKSm1XSStlbVk4cHFqdXhNTjdNczZicFhMcFZKOThjZUdkNTlya2N0UVEwWldQTThJa082QnNQTTBBbG1HVVV2dHhrcXhwcFJzcENQeVFLK0ZNc3BhTmtSa1lFdk9XSkpQQjJYRy84STRwSXozSU4wdTdlZkIxSS9TM2p0VFNpSWhsNnpPcEZyVDFQL3c1dFpBQUJ3UDdDZUFBQUFBT0M3dUlKMUF3c0xBSEIxbnFhbm9KZVBBMjM5bmFCZkFRRGd5a0JMQXdDQURON29BQUFBQUFBQXR3TWJmUUJBQjFBZEFBQUFBQUQzNG85K1JwYkJRTmFkako3VGJyNk5xQ1dOSjAvZ0xISWdqWE9jWmlHOWZFTGxKLzRycGtLa3ZmNHY3ZmFWMU4zOWwzZjA3MlZRbGVPSUFoRG00UVBHZXlxSUZHYmxZZU43am84RDkwRTY0b3M3ZWZpcitqYXpJWDIzS0JncHdoZmJTbW5QQnQ2WFBjUG9pWnpKS09YTmp2eVNEQzY5UjFONWV5Qml4TkNqY2FrTUtxZW5UWHZySU9GdFk2VWRtdU04Yzh4UW04TG5mbjJqZW44L2JXM0xMdDNlanZ6RWpaemtIc05yelFhUFNXdW1JTmUvcEQ5cDM1cjk3UjFqNWlMQnBJMDZHV3E1Vko0MjlyWDdLNVBDdGJLayt5MUcvQmJhanZQaTFJbjBLNlhXVncvcW5GdE1HNXBEZGJPL3h1b2tiLy9aS2F6RTNuc3gycWRJRzN2UFdGbTFPNVhXSFMyZDFXKzlUbEJKdmtaVXYzbDBSblk1RUQ3TDEydXNrYlRXdGNabnJTQXkzdkhiOVg3ZGtlcTREeW11bEhHa00wbWxkRksra2JJMFBaMlovSkd5WnFWN0xqNk43OWNvWFA3c0tGZktDOEJaZU1kaHIvVTRZN3lQV3RlYUZTRW1QRXF0U21XTzFDWGlEckcyL2Q0TzVOSnJIYVRkMytoU3pkV2hqdVBLdHVwZ2xXVlJISFdZU2QzMkR6WVJwR0U4NjdFL043eTRuWnRIZG5UWVIreUwzdnZtWkcveUl2WVJWeGVOMHBGSHE4dW9IQUNXMGp0UXRVM01yTUV1S1ErSFV1bWR4MzZ6UTlhQ3VZbmZRa1kwazVZekMyVnlOY3hWdmpvZDhTbStnbmszVHIzUzVCK2ZVSnV1R2dqMFU2alphT1VtSFJPVnVIdVFrZnkwdVFxcFplMkg4NmVWWmY4dVZ5Wi9UZXZkMW9VYk1YdURpcTcxVXYxcHJFUTdXbWxiNzh2MjhXQUQ4TWxvZzgyNzc1UEN2Y1lxaHQ0OWlDZ21LWDFPS1hsOEM1SnNyN0swbDlkYjBMdC9vbWtqVFc1TnowalpzOURLdE5ySUd3NWVSRG8yTTM5eit3bzArblFzVmVoUng1WWNxanNhTlN3NHpScVoyVmMyZUFDamRvUXc1c1QwWExqZ3FQUjgwWmVEUzI5VlExcFh2d2FyOGFKT1lDZ0xOOUVwRmtuM1R3SUFBSEF2c0lBQ0FBQUE0Q3VCa1FPK2tJeHhEUUM0T0NmcXFmeTR0UjlyQWdBQUFBQUFHQWRXSlFBQUFQRGRZSzBIQUFBQXdGY0RZd2NBY0JlZ3J3QndrLy85bi85MS9iRDFYLy9qbUZuMFo5cEhIbmZ5TFVTUFZrVWJnN1B4bkJ6bDFBM1c0V3JlMDVzc1daY2hjaUtIc3dHc3d6OEE2Q1o2Z3N5WDREM0FrWVo3NVdxODUrOUQyLzZ4YU1lS2hZVlk5cnMzM1RyMjV3SExweVAveGc4T2V6S1pXQk1tSitIa1p3dXZscUR4V3hyUG5WcEtJQWZEejJLV1ZUZHl2cWNYYjV0djBVd1pzNytRMmh4bHpyU0RVcVp1dXU5UDhGWXEwYVNqcDRuYkxUN2ovTGhGTk4wc2pBTzJLdDdqZXFWOEsrOXZoaUVoM1Irbng3aXlaczVycWV3NlhKYjFxUkZmMTFnTnBMbmp1NS9DeUpwZHAvWnJDWVVyWEdoS29sT29IdEkvc1RDWm9GNTJqejFQbVQ3ZE9EYVBvK05aY2g1cU1oTHB6K29QYVIzN3lWTE1FbVpENzhxL1RyWHJFcGRpekI3SlF2b1NTRFBvUkZObGdDUGdldHVybGJ5andFT3ZwUXZBYkR6dUsrL3VkelU5MnZyVWVXWXBqU1BMOUhSMHF0SjR0Z2xjUHE0czc1SllBdUZleGEybDBSak56OG5xTVVPOFkraU1zZmFsek5RWjlWUWEwVjlaa0hFSFQ0Um5selN5RzR5Mnd5WFdCZ0JtMGJNbTlqN1NrUGlTOWNmeVJlUXBmZzNaZDdqbDQyTmVmaDNpNi82NGdtUmZ2NjhPU3VwTS9aUzBSRStaVWsxOGJkcXVHZnd6RHM0UHUvZEw5YThXMGxkZGVkbjZ4TXhNUGZlcCtEN2l2cnFiaFhqdllYSXdIOEViWFQzMUc2L2dubGoyaGNkWTN5c29QcjVuby9EbGpPeFZvdE00K3FTakIydUY3TGxmcUpjVGlRNmlhRHBnY29TZmhzcVZ1ZzNudTROaGV2d1pXcjR0amhuQTN2Vm9KdDdidXczUkxmV3NNc0doNEl1cEFBQUFBQUFBZ0Z1QS9TSUE0RDQ4VFdPZGViOVlIZGFETmo2T0U5djZjVThBTWE0QkFBQUFBQUFBQUFBQWdCZjRrZ0FBQUlDandlb0xBQUFBQUhBUC9uQy9xUTZmUmxhRWEvNm9NLzBhOEZodE5ITGNEUUFSNlB5dHg1NzM1SWxYK1BzREt5UTVweUkwMFo3ekdpODlOYlEyVFNST3k4ZmthVVNRdHFmaW9VS0FDVjNqWnh4SGRtRzhEcTZSMjVXYXJIaFBDY1RFdlRiMGEySTBYQnRsM1gzckhibkh1M0JiRlpMZjRSRXpvckRTcEVKSnV2MC9QOUg3Rk5XKzZQLzZyUlJ0QWZZaUtVOHRyVGM4QzlkUlE4SnpYek9PTjIxN2tzZVNGZWtIcnI0ZXBXb1pWblJzTVlhVzlBVkI2YXVtMXBjSHBjV2h6cWQ4dFRDSFFyY1pzWmZIbld6ZXB2bkk4SjJ1N2hrN25uZ3ViUlNtVGFXaWMvVkhTVm9DSms0U2FoRjFxbmpuclFldlk4TEtQMkpBMHAxZ244NzhsRmlZRkh5YjFxZkUxL25vVjBrLzRVbXRnMVgzNHFoVEVpWFFsVTNTUmU4TWluaXFDK21jRU9hTUM4LzQ1ZlN5dEJteDRyVXlwYmtselIxYXB5U2tHOUZYMGx5Unl2YXNxMEp3M3Zjai9VTHErNHNhUk5mTis5b0hwenZwWFBEcmpDSzJtUmR2bjFoNUlyYU9WVWJ2dllCVlpFZWNwU0VvUlVpanpaeUkxZ1ZnSlI3TlNYZUQ5SG9WZEc1cEpsRFU1V211U3RMRTF0SU9ibVhlTXF5eUkzV2o2YlJHNWRKclpVb21qV2VKNUFaVDZpaFRLdHVibnF1bkZPNWQ0clV5UGYzVk02bG1taHVqNDFtU04xTm1zQWhyNTZKZFI4dldiQWhyVjJBTktVMEhKcVhjeUZUcTFwa01zendSVzFwTmhWajAxTi9MNnJVUWZBa3JCNkZVQmwwVHJYd2paUjdLL01hMGZDTWV6NG1VOXFNakNnblByT2RNS3EyUTV3c2ZkMTd0TGVXMXQveElJeFBadTJ5ZjhQYzF5VWZMZEt6NVVrdkp6elFTdVM2S3JMMUdiazJhL2RqWnl2enYrenE1NmtSclZLZXRjL1B3UG03cks2ZnlsMVN0RkhXcVRHU0NSNkNwVE1tQlpSbXRrbXdNcW52aDNTaFkrMzhPenhMdEhac1BJbUxaME82ejhsb3VFOHRmWGdMaHRFeXBEcU9Xbk1Qc2dIcWllUFM3MXJGUnY1NFdEdHhFMWJNMkg1cnVxdnA3MTcxT1c2Q1FQNFJIMHFSUTloSThEWStlMFZBbUFEVnhwZlduWnd4Sy9rbks3RFh2ZEhwdndLdkFvQkM2NlcwNmJoei9JeGVDSGdJQTNJUEhhaXVvYVFBQUFBL2wzQ1VRQy9CM2MyVC9ZaXdCY0ZmZ016dVNNOXNhL1h3Y2FHc0FBSGc2V0FrQUFBQUFBQUFBQUFBQUFQZ3U0UE1ES2hnZ0FBQUF3TmVRLy8yZi82MStzQ29mVmZHdi82a3NnSy83R2ZZRlFSdURxOUp6ZkpFZ3dqcXd3RHA5MkhOcUJKZlBrbjBZbm5sT1RwN01TYzlqdFdYWFIyd0EwSGpZZXFYZGJsQVZpcks3Q2dmM0liem9LVWQvM1JCNnhuRDl4ZFM0Rk1PU2FFNW56aVM2T2dQNDU4dW9VbHZUZEVxWlRCNitybHVZMTNyUmpocU5ubTBueWJTdU9TSmxTbWpuWTBabDlaVGhrQzkydDJKWTBlUER0UytrYW9aWmRvNXI4N2hBdVgrdEZwQlA5SmJDcFpMMFV2VGFMRmo4bXR1WmFTaVBXZ1V6eWhKM0JFYTR4K0NJM3Q5S0hlSkRIbG4yT0U1SzN2M3ArajVadWoyWnEzVEZYYlpkbUxOdHU1bysycjlTL0VqWm5uRzdpa2ladlo0TVRvNVNwcnFFNit2VFo4aTh4alBSaWUwNDk5eC9mdjlYWDMyaTgzR0duckxzcUdURXI5U0Z5WkdlRzFPZXZGWTZvS0cxZUhSR0g3Y1NBckNlNkk3VUs0ZExQenJYTnBtaFZkbXJRaTIxSEZIalViWHRYUkkwRjRPVjM5cFdiSEhlUnRka1JobFpsbnZNU2UwK09heXRGMDNubGRlVE50cldFWFBqeGt6UkZWVzZXbWFQOTg1THovQWRKV3BGUjFUR0xFL2hqT2tNQUtpSVRxbzZiWFROdituVzFlMnY2L1pGUk1yZ1pYNUtsdnc5KzdTY0gwZDhucmIvNTVQejg0blVYVm1iek5ZM3lvVkhUVDFheGxiMlhncHY0bVRSOUtscmxvVitMRUlkSkcvd0oxOTVoMUQvVzlzL2ZIaDg3V3Q5MnhUdjExZ0JNSW51d1REa3JzRXNRM2xrc3pLNlljQlkrbUhHZnZHSUptN1hYVG0rVGpQaTV1R0dHRmlNcFZ2UUNjdm8xUVdTSmV1WnA1S1E1bFVvbXA0OHprNUNIUUFROFd6SjZyU093UlYxYjBTS3RIajhlTzk5bHFXbEFWMW80L3FmQkFBQVh3TFdEZ0FBQUFBczV4U0Q0NHhDWVZrZEIvcjNPMEViUDRGelg4akJHQU9UeUJoTEFBQUFyZ05XSlFEQTFZR2VBZ0FBQUFBQUFBQUExb0s5OTVlRERnWUFBQUMramovNzMxd2J2NzB1eGpXSUV6OEVENEJ6NFk1cDZCeW5NMDRBbHE2OStaWmdIWWNScVh6NU5QbnVWS2hpbnhMRmlvTk9BUkowa05YaEtkbkh2VHhzYkJWbjJMRFF2OEEyK0E0Sy9TT1RjQWx1RlJpdHhIVThmUDNEZWVBZW1FTGxyNlZ1MTRWSnh3azdvbTI5aG9SaFlMalRSaXlPbmg3dHFmOFZ5NkNpR2RuYzExRXQ0MncwL2pkUlhZa1VwWkFUeWlNUy9DMjhZbXdGS1VlTXVkbGtvdzZhY1dkeFJudmN5OGdwelduNHNmb1hoMHh2Mlo0Y1BWSERzcnZTalpSOXhoaUtsRG1ydmlVVXZJL3pyVU5GQ2cvZlEvdmxCNWtyNnAxWk5nUzFwMmJZakxuNjkzdjNDMWRuVnN2WDhnRDRGbHpMMGdSWnZReXZ5cExLdE5ReWplZWV0MWhsOWJnaXVESzkrU0xoa1R4WDJDYU1EQVRwbUhNdGZrYVoydGl4K3RYN2FSRnYvbHFHRkwrUzJRdXhRSSsxTmVLOTY3MnRLOWdSTXg0ZnpicVBNOG9FNEtzWm1TaVNVclNlUGRNOEY5K3ErdjExVVo5K1R4bVN2S3pHVWo3bVJ1WGZLWFZNKytraTA3UXR3dXFYcTJkeGJXd0lxNTAwYzdyMStVcm1WNXVPcTBNV1UreWx5Mjl1WnJITUpKVFprcG1yMHBRQmJ4QllTcy9lRXB6UEdjYTVsVGM2bGlTN0k1SHdMK2N1VTgzcklwUG90U0Y2WEdWWU53ZUE3cjhkeFJrV0VWSUMrdGh5d3dMQUVsa1VORHNpMjhtaVlxMDR3T0MxOVZKMWpZM3VFclN4KytmM0gvcjBLanV5S3NsbmZuc1k4QVM3Q0lDcFNQTllVaVViWlIvOCtPRWJhQWp1ZlFaMXpTU3kwZVpBeFRXb0FNZWhjOHRUR095c0wrVWJKMlptUTN6YkIyZDdtRi8vYWlkVjNqM2cxZEo2Wi8vS3ZqdENBNjJ1djZmdTNwTStwUFFUMmljYmJSMHBNbE9QVmVIanJSOUpldE9weHZrV3VyMkdzSDlSb2l4OVFtZkpIdWszVFp2VVNQM3BiVnR2WFpTeWh1S2piNStmd2F6K1RBRTVmSmxaMU9QNytKSm05THRFcnY3ckxhdlh1SHVWa28zNXE0MXo3c2YwUFhYb3J2OFJjM0FtTTV5amkrckxGalhhdnp6NXBVTmIwZjZ5N0ZhSTZMVlJPMklFN3h1MTBUS3pNOHliRjR6QzlXYmtoUmNwdmFVSlBmRXBIYU1CQWZqTHpKM1kwU3U0YTFXZXNmeEk4ZGxJTjlvUW5PKzNkMG00dW5MeEtrZVBIQTZ2N0ZsYklLNXNxUis1ZUV2bUNOSWJhVWViR3dlVkdaM1dubDBCSjBQclJpK1dQaDU1ekhBSGEzS21tb0k5QlI3QnlvRWVjWlZ3K1JKSmI3NGNjWTNaS3ZraGkvajBhWDlUWllJaE1kTzM4azc1Zno0ZjdwQlgyNTIrMVVscWgvSVJrSFB6UkdQLzFDTHRyb3JnQTI3RDI1eHRYQkxLbm1OR3A2WkdIK25iczhuV2hOdnV4NWJtU2ZkSlc1amMwaFM3dytvUGx0TnIxUGFVQWE2SnRrRTRhdm05emxMLzljeHliMUI1STBNb2FyS09QS0VEbmZRNEc5RG9wM0dvdjhOWldOeW1CY0JKNzRDZjRhaWR3T1BIdTlSLzNuVUhpRmhObTRSNG1yYU8vM080eFk0TmdvNjNmZENPNEd5NFhacDFEZllVWDVMV0FiMjNlZGg4YUhzUVlSdFUxbnV6MnZXWDQzbmcwOXNrVTVzU2MvOCszTDZ2NXUrNlN6RGNsUGRhREhQdXFhZDJmejNLa2x2TnQzK3RPNXpkTWg2T0dLQ3JOajRyNmw2RXkwQlpYdVBza0s5MjZvdDZFZE50b2Z0WFFmcld3TlhqbXFuVno0c3RqcXlIR3RLOTg5K2JKcUwvSXZkOXBPTmlsZzZ3eHZONmoyUjdTcjR2VnlqWjIzTlk5dGVKaEVka2RqTWlZTlk4dk5KODlxVHRyRy9wS2FxNGtrVXBqakZHclN6TDBjMUw4Qko5d2oxekhiSmtTbmFpUlRIS3dCT1dGZENYVUhWcjZoaG1XQkVBWEpYWjQxZmJzMHhlbFQrWnZjc09wODU3bHdaSnR1YjdQYlJoRE83c2l1ak4weXVQVy9vOUQ0NnlJVTl6aFhudWI4UU0wZW9namQ5QnM4ZHoyNk9zdEZ3ajhqemhrVFJIZUs5V3B6dGFGZ0NYNVFCMytuQTZ6M1BzQzgzWUV0d3hyamdvcnhpKzBDN3ZTK0h2NnhQY3UzcDlPcmlJL2J5UEtNSXptNUt0KzI1TDVtcFNpVXg4RGZwTjk3YTB6dzkzQzN1ZmNnbWxveFlsYmI3d3p3OWlBVERwTldwN3l2QytIUTJPNVF3ZndleXlacnZwdjVqUjdwNnRNbVkvMllsWmFoZ2EwK0ZzZTh6RHd6aWlxUnYvbG5PQ3VyNmcraG83dXBVTUFLSFhocUFieEk1Qk4yUE9QZDRzdm9JZCtqQkc3S28veVVYZS9TTktFN0toOHhXaWJRckFsZkErakZheXJ5N3FGRFVVWGZtRlNtbzJ6V0RUQTlCaXZYMkJBZmREejZscTNXVmx1U3h3WTZ5T1hUcm5abTFOKzNmZDF2dHZmUVR2YTl2YWJBK3FrMVNiOHZPajFyM3pLL1BDbXJ5UnAyWlVlMFMxeVJVVjlhSGFVaWxMS3RPcXc0R2J0UHp5bWtwbDBPUEd1MzVvWGRPNGdkOWgxaGNqOVY3TmFjMlhKajFhSXlkNXJKRTh0ZG9LVHgxclhDY2wzaVBERTArSmpHTXJuZmZSWDQrK21uM2Z4MERIOWV4eDNuUFhuNWVGaWhqL0c5dFJ6MmxmMEtSM05xSlRKVm5XZXR2REVicmZPNGVzTnFRVVBwbHJldTdYbWRXemtWcVJzUlZudEhiMUl1Q1YyVFBtdkd2Q0tGSXJjdmZwWmRUTytFN291RTNKdndKNjZiRm9lMlFBY0hXT1hPbUg1WHFXNTJ6RWU5SnhaV2xydnZTeXhPd0c2RE5tejFOU0s4cjJLR2JhTnluWlprZVV5QUxsTlM4NUxCTm5sUmtSbVNzVGlVNUxLYjVuMkUxNnhPaU8zOUtzMHJXalpVYW5VaVRkbVdvSmdHWE1talJPVjBRWDBiSzhhWWE0OWpNTnl5L1pmblYxTmxWZG1pK25rcnJzWFUzeUk0MWRNK1I5VVptdkEvMGhaZTk2bTVXY1dsdnpWY3V2LzFvRDJqYWdhRC8rOTVVdko5OUREZnFGVlNsMXFkSjZmUTBBZERQRFdBWG5NV3EwUzR6YUVWRmZSRjJtNUZNNWVNOTVSWHFiZG1VZFpwYmhmVUxua1FPY1dJOUJ3V1dZNFpjM24xZ0doVGJKaWI2RzJnWmhlZ2YybHFjYWRDdlhwem84SlpqSmI5QWd5NURNNHg0WnpoK21Ca3RDcHdOd1h6Ui9LZWIyR2dRck9UTlI2QUlBcnNYSUpyY014b012NVJZZDMrdWlQVkxpQi9zbkRaL1NpNUYzckJad2lkMkdFVzlyYjFuZStJdnFpUE9yNWRRaVE5TVE4L2lYbFJyN1dmUzBZdGgrMVBiM1lERW42SXdicWlsb2xCbXNmRlVEL0lYeno4M0M4OXNoVDFvQUhzdHJZaFRsWlFEdGdiNjZEczJ3b3lUMWJFM3drVDJwUjNuTVVHZ3JqTm5WbkcxNEhPRU1IcFhCalh2dlF5b3BYWGFVb2JGeUliNDV4Umx1RFF1WFRuVEs2dTNlU0xxWjB4ajJGUURnUTJSM2RqeldJWFE5WDg3VXBHbHl5dnVIcFBLUE45djBqb1JNRlZidGk4dnVwNWswTGlwcno2anAwd0lqQ0FCd0lyM3Zpa3Y1enZCSGVOTkQzWGF2czdQM2lUT0FHK0VFME9pMzVoQzM1R2doOEJHQ1VSYU1uelBXT0dDQVRuRmorVE84MVBuKytJb0tTb1lYM3crZEFEZ3BDbHlWNkpOQkp1dUlFOWI3NEhTVmM3b0w2UWE1aGhBcW1xczIxZTZGbml4RFQ2QXMwQmxnTmc5Wmo2VDN3T2hoT0RVelh1QUlWUWJjQTJrdENQZGp6MHZuczdZUm5Jejl3TndlZmt1bk0zOXl0ZW40dWROenY2L1VyMFd3T2JtWk9aNzVjOEp6MmRlbVJLMFlTMXR3SFMvSnRtUks2YVY4SHFRZk5xeDQ1VXNxaTZhanpLaFRNYUlNMlNPR1YvTkZ3dWlLMGRlZjlYK2xMeXJhTTB5YjkxU1c5V1hKYUQ5R05pUENIQktQWmhkMEJOdXYwdmoxdmwxampXdDZYWVMwSmZVLzVwTmtSL3JFcW9OWDFndzl4Y1hMNjlGbk50aGx4cjg2cXQ5UEZuTzFjMUtlUTlMR2NZdDI2aU9YdmhLS2E3NytMb3p6cGd5djQ2c3VQRHFIUnNka0Q1cHN1dlpiOTZQWkVkVzE5c21KUmlSWmQrbzhwVFJqNEZNU3YxWkl4TVl4emV2dEdVbXZTZWxXRUJtM1dVa1hLY3VUM2l0ekZwb045NTE0NzlLYXhUT3dyR2dBenNLanRUS1RYcE1SM1FVblo3cDZoZlpabDhGNXpBa3RpWi9BWmJTd0pMc2FQQTFneVV5S0RFOWU3L2FpVG51RTZTWnhoam5aZ3pUR3RQUmFHaW0rVlArSyt3TW0zV3hPWHV3ODY2NWsyWHZUYjJsSDlGdFBOMmRuSFNKMTg1WWRsZDA3ak5OQW1RRGNrc2o2OEplZWRYaWxIUkhtakJrZE0zYWlQcGJmUE42N2ltbFJ1N3ZiUlYwdXdmSjdSQWRqMm4rTnRiSXJmdXZBK1Z5MkJGSU5lVi94SnF0VVlha3BJKzNLcUZQdDBZenVKTlJyMytaRnFQYy9RaHVYblNSK1BlZXVDeXVqcmxOaGZJTzhqSlBOTS9CTldJTU1SdHUxbWVYWDBQSjdsOTFlNXhFVW1wdG85L1lNaDdqMUlKZFZrdjZFenBJRk9wQTZjTk1Wa2lHQlJyOGwzVDRrTW1HYlZ3ODhlZmNpTUlUQUw5YW1SVnNNc2pOZFo1VjZ3UGdlcERZRXdBOHhEMUpMY2FUMWZ6RzFPT0xRZ1FEY0Y4OURDU3NOSEVMVHFkZEc2MTJTU0RnQUpwanYwNUI4cGtNQ1lYTmRIMjJUeTRXNzJWYURwd3lDL3ZzVjE4YXdPRXk0T0RjZW85NWRlR0xTZVFiWHlldm4zRjZSNy9lODI0eDBvSk8vL1pxaEIrN0J0ZnRKTmczYXVYVFlIS3AvdERqK1RsVmZ1a000YzExNmh0MzJkeHpuenZ2MERyMXhqdWdIYXJzdVdKY3V3ZFAySlBNWkdSWHdBUUx3NFloSEdsMXpxM2VpenB6SXMyVDF5SW5tbVdrTTlPWmRjWjhyRlhPMHpjcmc5VVlleUh2a1F0WHBmKzErb2U1Z1ZnenoyY1BaTXl4bWJ5MUhYbllHQU55WjY4L280Z2hwVTBUdXk3OVMwUytyK2c3djg2YUl2Rkd1U0dKY0RyK1BYdHI3SERXQnZIR3ByWklweDIrR1hNZlMyQTZaNi9YeEFRQWV5T2plMUJPL2F1TWcvV29TS2xBazJ0MVh3THQrQXdEMmxFbHAySHl2akprS3ltMjZ6SVJUTU1mQmREcTJhUEY5b0ErTTc0clpEdXdIMHR1RTJabm5iN28vdnF3dkUwMHl5S1Vhb0pOL29hMmVtT3NWVDFVQTZDRWJjVkVmZUJJUEtCUi9xOU5UOU9YZWVmMUw1QVpUbTJmN0tGTzlTZjU1YjFpVEpYZ0JNdEUxVUNXZ200ZXQ4ZFpCT2h4RitIdTd6bG9HcnV3UjV5czRoK1g5RTkxMnJ0eW03bWVKOUxEeWs0cWZUY1ZWaGhNeWFUNWZUcVVGVmdGbDlCZkUxdUkvc3crODIwRHBLVXJFb2hveGFycmRrRUo0RHFiWDBtUWxMakY3dHUyRkNxbDlyTEJVL2ZoTGlXZkxzQ3FuMTJXL0ZkMHM2aUpJbVBFMFVDK2pmd09jSFhXUWZnUlVoT1JDVzNKOTRPcjdtcDQ1NDAwWG5Wdld2STdJbTNrZmtYUi84WTZ0L1ZYN1plQitZN1p2am5Cd2RkREhHUDN5NU84MWsvNDFydDhsNUU4T3ZwelU2aWR6M3g5ZDIwYldFRzkvYVhwK2k5ZnFyWTJ0WHJKRGR0N3JsNmJhaFEvL0pHaUxrdEpVTWd0YkUycWI4WE5IbXdlbEdaVWYrN0JVb2ZzMHZDUWVhOHhwZmRoclIzakdsbFdXTktsRzlIRlM1SEZsenJSRlY4cThOcDRXalZvTWxKVVdCQUNyV2ZHU3Rqa25NcCtPSmlsR2ZSaVJ6WHYxa28rd2FFSk51MG9nTytNOXNvM3Q3eFNzTW1hMXd4bktidVp5NTcwZkxWM25NN3BwVy9RNkQ4M1gyOCtjM0lQSVFoaTNlNkRoaVlsUFZieWxPemdpT3lWT3RoWHVrYm1hV1pidlVkeXR2Z0IwWVcxaVBHNHNyK3dreUk3SWNhOFhNMmR3M3lKSHZ6ZzVvdzV5VGJKUWRuL3AxbDMvdWhTNUZQK3RKS1NRRzU3NnVuS2RybkRDb240ZEtaV2M3dE1PM1BHQ243YW1zalEvZE9zejI3ZDJhMGNVdGl5YVBvTFV2OWFQVWs4dzJjQmRrUXhyYVoyUnJzRzlXV2xRZTN3UlVwd0dwK3dmUnUvMlB0SnMzako2L2ZDZUozVFk1MDFHbTNPOUpwdGsrbUd0K0NyTStWc1N6cEVIUHF6RlljUHpLb24wcU4zUVF6M21oN2VhVXI3SFRZK1Y5dVZEaUhwV3ZQeVY4MGN1UnNneEV2OVVlcTExQU01QVc2MTZOdXZBaEd0eXpxYXByOUVWWUJyVXFZYkJNaFZ1dmw3eGhSQXdFYW5EVjFuMFg4TFo1dkx4WldPRHNPZGliaExyb1doUDE1MjBsMTQ1MGpDQ0plQVZ2eU1yVG9KZithQlQvQUZFTnVMZjE4cVRkVXp1U1NodFhKUDlTV2R4cGhXeTluYlB2ak1yZm5iZEpHOVJGcTdCbWF4OE9BaTFEZTdHa25td3ZiL08yVUtLS3RUOGRwa0UwUE9zeWhLanpnaVg0czlXQk40M0NYdnJPZlArb2dyNWpMS1BmRVkzNHcwWks5NEtkNzdVWTVZOVVibGN3VS9wZVdTelVnMnQ1b2cydm5QN0FBQUlYZHZiRllzNGg2elJ5bUYxNE9LdGh4cDIzYVNqemQ3eFpidldaUlhMa1VtanNwWjNsSFlnUFZuWHczTUVBTGcxcXhRNGxHSTNsalZ5SkZqZkFOQlphUU4zdTRDSmovOE5Kak9ZalhlUndJYnBtbmlWalBSOEJmMDUvVEZUelIvMzdLcjlTZlFoRWJDaEowSFY0ZlcvYUZOd0Z0WVlwTCtVTEV4ZUxYK1NoNzluMk45cWFsZ1Awb1huQUQ5clhpRk5LL2p5cFVjSm9ROTZWYktnZWg1S3FmN1Y1blZLOGlEeHBuc3d6UnlqdWtGcVE3VGwvZURta0xYNDNkSUc1RzQwdjJMSzY0bysyTjJIUzQrenU1cEJlREtkbTEvbjdCdDlmMkowRVdwaEtiL2l2SlprbEJTL2E2L1M2QmxjVmkvTUxFTXlsSklRN3UwTHJVd3FpekhTaWlKcmFMNUtNcTB5cVhFWGI0ZnRTNHZqTDhKc2M2Y0lKZFdoM2hudDlmaDQ1bFl4aGdISjI3eTlQakxHYU5vb283b2tPZEpaK1VmSFIwUjJORnhLSyt0cmFaYTM2MUZoNCthK09KYkVNdnVoOTdFUHIwdmx3NW13OTVkVEJkNzZTc2h2eVZmaE5pT2FFODBLMTlhWXFKNlM4TXdkVGE5VTk1ZTV1cVZmQjhFK3dldlMwbHRjV1ZYZXNvVzI0LytUS3paZXRmUjAxY2pOWDlGKzBQcFg2bk5MeDlkcHVYaHBiSG5zRmN2NUcxMS90TFVtQjlMV3NudlhyKytHYWlVdWJsU1RTUEpIWk14ZndRRHdFZFhPSGxrVzVyaXYxSGRqeWxReW9sWkxTcDF6N1FqVGZaWmk0dVRXOU5SQlU2WXBUZXg0Z1o0dG5YV2ZXcnJvdHZoSUJXNlZHZDBHbDRDTTJmZGJtMm1TaWRhQnRDT3hxbUd4ZlVQdW45ZS9rbVc0M1U3UHNPMUIycEZwNld0NlZScnNGZ0F1ek14dFl2U1Joa2ZHTHVJd2E4NlFTVXNvUW1yTG4rY3ZrL3AzcEhSamZybzZuSE1oa3Z2UHY2dGNNZnhXMm5zdFRSbnU4VWo3WXZOSzFlM0FyNzcxYzgxOW0vSUROWXMxK0kzNUx5T1h5cFA3anZjL3ljOWFKYitlVFJacklOVWZnRTZrL2QvcS9RSTRCbTVEMFNzbktiSjZscnplZlQ2WWh2YWtqa3Ribk9tNGVHM0ZCNU1aOFZQU05TRUoxN3hKQkNZeXN1eEdmVWRXdUpaUWVpYUhJUUYyMEFHdDJRRGNBbEtTclhleXIraG92SVpYWlg0OTNrYVc0SjRqQUJhUG5TWHhKM254V0h4QUI2c2l1QlBTYWxiSFNkZWdpOXFXNFh4d3E3b0MzZmRncE1GV1l3MFFES0FHYXJ1eVRRUWI0UHV3M2hieWJIcHZ3M2FqNHdQNWlMMWVFVXI5aEZ2dXNsbTF3TVMvTEdldWRkUEtQbTZNbmF1MmpQdGNNcDNQbkw5UDB4M1IrejFDZjE4RHQ2ayswaHlQdFB1Zk00Wlc0L25xTURmRHgzcmdxZm9aZHVWWlJNWnJkUHMzUXhOQm00R3ZScGhVOUNYMndyMDA4RktiaGNncWpEeFBIVXBISHZFNnltem52OGVQMVVNNUtWd2oyaGVlTW5wbGVPdHlwbUtQbEQyNy82ejRMekdEUEJaZGRBak1uTGJlYmhydER1eklBQURqSEtrdE5SblNqeHE1M0dPZWtQcXZzcUFNZlJIUDVoZFE3WFBVN0ovVGxrK3l1dWd3bzJaaisvNU9idExaKzM2NThsSk01KzFPQno5S0JRQjAwN3NNclZpK3BIaDZmV1dGZkREWW80RXVIanBmbm94SDdmWU1pYi83aVo5OEdFL2d3a1I5cDFDUkYyRGU2ODZQeFdNai91R1RaeVVNREpHZDhiRHd3ZEZ3SytIMjcrTHBuNDBxM0k3Z2pXVG00bWNOTFB1OHRDdDJHdm9WUVQvOHRIdlJCZ0FPNzZFSldiZ3V6dkNiRTMyWmRKdXZoY21RTTU4bms4SUtKdTU5VU5kTTZkSGtTbWFYS1QyR2JkUFFVM2d6eVZjWW1hV1JIU1FMK2JnSnVJdXNhN2Q5SGM5cXUwTCtIWGtqOVZNNm55YXFVTDJhU3NxcjNiK2w3Q04xdFo3NldPbXRlSzR1ZFQxSmVHRmtaZU50WndwM3RMZjA1Y0VtdlBmK3VIUkZ5UDJabjl6ckh2NFQyaU5qeWtvcmpUSFBXSElZMThXSS94RWpMYmphR0xJSzljeHpUVjV4aEZHZDRkVkhWdHV1TU9LODR5RFMxcElNUHIvYzB2SDc5SDlKTlZmLzNaZnFLZU9UdW0yWFhYejVoS3VmR0tqam15b3BiZC9NSld1c1dXdW5sSWViTzVxRGdrczNnclFoOHVybm5vMFJrM2EzaHREa2hRK1gxcXQ2UERnM0ZibDJSdnhramVYYnZzek5yeW1GbU12N2Z2K2RXL3RjUEQwNnNnNlA1dWZDUGZwSzB0UEpLVnU2NW1ScTkrdkJtdzVzZUhyWHYxTDQ4bVJuT2dDT3BuYzhjdm1pVmtTaktZa3B0SXZYSmxGSi9hcXd4L1RoWkhnYXhOc1FQVmpMVUVTR2xxOEV5cGJ5Y0hXejluK2pSTnJENmsrdlNaQ2M2Ymt5UitzZ2xTRVJXZlM4WnBmRnlMeDFpSmJnbXRyS0k4bnhsT2VWRVVrM1ExWE1rTVhKaG8wRHdBVVpXWWU4azVvK0dOMHlTclpCcURLZTlDbk4wMEFsOWE0V3RXK0Y1czFOdUM3alV4dWp6UGRYVGY4YnJBTmRpTzFkY2V1V3pELy9kOTFYN1RLcmlzNmtiZmQrcUdUV1NVckQ5VjdkRGpUOVBpVzVielp0RzdMM2xTV3hwV3VwaFpSTis2K0lkZVRoN2pzTGQyQnRneGFaYWVBT1VCVm83Zk1rRlJrZFRQekVCVmZuS0Y5RXBHeUtycEMvaW1oVFJwOW9SUEM2RHF3Vlh4dFNNVXVHendlU3IvR3NBV1dsUjZPZlJ0UWxTdkdvMEt3NG03aDhQNCs5WHdYU3JTZUd5c09KMmhGNS95ZjluUWJMOXV5SlBvc0tETDU2dlBwMnFQcjFiY2U5dHdGV2xRM0NXSFpWSGU3L1lpb0E0TGtjdkFnOFlFL2ZqZGVWRHFNYnVQRTZCYng2NEN5ajhTSnNobFltMTNYRWFCT0RDeExaTU4yeW8rbkkvajUrdStYTW5lOFJlUHZ3N3Yzc3VFOVdVWlA0bE1hYTRpTEtmc2FvdnJYYUFsL0t2ZlJVWkNqdTFWUDdndGJ1YXNUKzhEVGhWOHloTSsyWEU4ditPVXIyT3ZPRVcyWjczeG5SdWFKdVdMa2daYUVzZUlLT1F1cmRPbnlHU1FpVEJ0d045VVJ6UmsydDBGcEYydE41MVBJcnZrVGZmT3RGMjVOYVJONmU4OHB3dGs4b2J0YitlTWI5UnN1WW9iQ2ovZW1kRk5JY1M0N3dJeGNpNzl1aVo4dXNaUnlncHlRQ2FzcGs1dlJZTlkwMTl4d0E0RXR3S2RFaUI3dVY4QXpEWXBTK0JWZjdnV1lKeW5CLzRiSklsNjF2UWZxNTVqNDlKKzMxWThraTdaeHRpdUJVYWlST3NBR0Vvc1I0SzcvRnA2WDNxK0dhTlRFMG1RQzRGekFrcjhGcVg0U1dadFptUmNyN0FQVTV1a3A0dStESXBzVEtCNENQV2Mrd1ZqejNiZWJ4YTgybnZpVE1kVERDRlR3Smo2TzNFVWMzNVZBV2JucjlHMy81NDh1ZTk3bXNYNWNySnhrQWd2WUVob3NIWUJYZTN5a01qRWs2ckh2ZVliZ1Vrb05ibXI5ZTNjaUV2MCtEWFBGaUFYZ3UxSm1tUFJkNjJKanltandjL3lUQlQ1a0ZPWkl1U1FPVkFNZVR3eEVMb1lOR1dvQWlkWlBjU0ptSnIxUHVINGFYSk5WeGdOSnpQMUlOTm1WWXlMV1VPN0ZTeGx3WHRBNTF1SlJIQzYvdmRQVE5QV2xzRlNPZEppczU2eFFwUTduUDJoQjlEOTlOUVpmRWx5MFVyZDVEcVdTWE5yeVJtWVhvY1NOdiszSGJaejd1SlJWelk5OC9UOXNmMXZXNEwrcDhnYkgxTTVXcWRNVjduNUd5a3BFbTJvYWU4ZTZkeDlhOFBzTVowU1BiTWMrWUVIbmwyOWVCaHRkenBaVTlad3p4WHlEWWw3S2xzZVpRem9Lc3BtaHJUYUZ4Mmpya1haODhZOHBhYjN2bUl5ZUR5eCtkU3hhUk1xbzI0emI2eGVwUEdzNlVJK204M1hySFpZdU0xenBjc2dYM3NyWXYxSmYzTlUxbGw2bVAzN2JVMkhqMnB0UGl1VGxRbUR5U0xPbGFiK3Myamlzem9nc0F0L3B5dlZTTXZOeTF0L3dlclFmQVVXampuRjNWbWIyWXBPbWFNaktmTGp1V2hQZDJyeFpxbVFGMThtMnJ0bklDZTVXRTFXQlJQUG05UzRXa0RHY29zb2hTdGNyMG1oRWpaWGpwWFJ5ODZVYjY5Nno3cS9PbHp2d09SS3VxMGxPV2Z2SHVpbnFxUHpyRVp0b2QwYUVVdFgycUpRRzJEd0IzUXRwcWU1V2poR1pZZXJmV2JtTWd1diszS3RHakxTMGlkZUhpYXhsK0g4UEhYMU9uYTlObWF0U1hOb2NNNC9zcTVMSUk4VCtMQjE5S3IvbXhsL0h4eDVaZDBUNnBPYkFxZm56QVcrenZYOVlvVFcvZkdTK3ZtSk9KNW0zN3VSMGhXeXZRY1VEVDZiaW1NYmduM24xMlZBM0w2bXFmdHpqVGduUHBWZFRlOFJVcHc3TWYvc0t4cEUwMTc1TUxTL1pNZWwwS3RVcVFaR1lsYnlRZkdBQ05lUm9qZGpPM0V5bkozcUhzQkhCcG1VbzE1a0xtczRDSDQvVTFVRFJucUtIMExkK3h0c1lVb1VpdnJNZmpzZUdrZURUbWpxamJ6dlBZN0o4RUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQWd6OThNSE42MXQ4amliMEhlL1Vjb3dCK1FkdUJLeU9OVDNKa2czeHlYeHozU1NwbkVEMFNTcmdSNmJESE9xc1hXaFJVQ3ZqQkdtVGFVV0VQdzN2Q0dUZXQ2Nllza1lsc0hUMWkyVjNnZUt6K0xaN01SeHpCTTNxbW9YU2prYnJ6cC9aK1ltbThkcXdsU2JOOU1tWDdXaHo5d3RjclBCZSt2dTM4TFVvcTY3Z2xiL3lJQWo1aThrZVBFWXNjS3lhbHNheTl5VW93di83emQ3eThSVXRHV3FueVZIKzh3eDN6K1owMkovVVRPeVY2WDN4N2VKYWY4ajZGdXpBU29pWHFsT0VqYjBrYjErMVp4eGNtaitmelNkM3gwUlBwclhqdkdheGMyWm1rTTlwUTVBZ2QwMFBzdk1EYy9FWG5TTm5GY2w5bWJMOVNLcFd5MzNVVklSVXRvNmoxMzMvaE9PMHIzd1pSL1pVTnc1TDk1SmMxaHFncy92N3Q5Q042M0R1WGptQ1dNN1JlWTRSNVhZUTJsejdkWm56U3JSNnA4eTFSZlI0a0pqYitkV0lxeDNNbW8yVnZlUFd2TWJmTXZKRVc5K3B0S1o4bjcvd1I4STBVWjVoR2RNWDNsQ1c1ZFFBNGkyWmNNeXFtdk1McGVHWEhiaFg0M3ZhVHFHSXNpVHR4d2xMdzNxSkZsNEFSdUFrN1locHByZ2JyV2xxMFo5U3ZGNnN2ckhSV1hCMGZOUUZtdEVPdkdWMkhjM0ZjSGFQM0dhRjM0YkhHbUdadUJjdHNicC9vakcwYjFiZ01Nei9sQzlFZGRSbFNtVmFkYURpcEJrczI4bGx4UGQ1SnlacTI3aU15aFk1VU13Q0FBTm9FOWs3Y2FEcEdMNnZYcXJCb2ZNOHV6Y29qTldKRU8zcTEvNVppbjY5OUJpZm4vUHlWM3hLS1dWYlJOd0lWK2Ywc2p5Um5iWng5NlQ5WG1XYXFoWk0vbW1jN2Zvcmd2L3A4U1pZZkI5UUhMRjN2ODFHSm1heTNwY214eGRRaHhiQkF1SEdRV1huYW1wNlZFbG84OWd4NEtCSERtRXVYQnRPQlBxeEZRZG93UkRZR0VyTTNETjQ5NkpjUzJadFpMaVFwLzRybTZ4MUNJeVp0MUhVRUZDd2R3YVVIUy9HcVo4M3RHRTJmcmNLMVZ3cXlJQXNBalJrMmhGT0cxemNjamVOa1d4NkdyNThmUFFzNGxBYUxkOHhFdkZmNFlpb0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIQWhmREdWK2YwMGQvTE43Qk5wQUFEbll4M1BXNWprNU1CQmVsSzVkVUtERlg0YnBOTmJFcmxXYnBBNzNaMjJzZXYwQWRJSDRPRms1M1hQRVdGZmhuVjZaeUgvMXV3T1djbHl1dmQ4Sm9XWjh4WHorVG9NbmFJVHpYekc4VDM5WlJieUZ6MUJ0OTFPMExLRTg5TzRDVWFFWnVITHFjVThibzM3TGxkTytwbHZ2WDB4MG9mZU14bTk0Wkd5cENORFYxaHZpeXpDM1JncXIySnkybjA1OVIwdkdMTldNNmpsbDdhTXdnbXhDaFBFMTZLWkN0SHpzMmtlVzZwOEd2Y25iRWFmeWZOMFh4bEhXY1dZdDlrclM5QkxJU3hMSXJJejRzYUk1MXpLbGN5YXQ1NnhWWVJ3bXRNN1p6Z1pYSC9FK3ovK3hlQkdRSXZXSEQvWFJwbGQ0ejJtajVoQ2hUTHErR0xVUjVKVmd1bTJ0Q045WTgzZmxUS00rVngwWFZCLzEwRzN5ZXh3clpRMkg2K3Y1QzlOakxEMXIxZG1ienBONzVrVE5TQkxDN2M0UXY5L0I1YVdrc0k4UFJidGhjaEtLRjBETUF2dlRpWFJkSXJmcXlSRkNEZDV5SlpzQzgrRzZtUjlic0tXb2s3TCt1WXROUjZCbXJLalp0Vk1CV0NaWTZVajcraTI2UXRjRVR1aUpvRTI2ZWhZc3NxVXl2QzJ1UWRyMFNzRDhaNjIwTkpUblVLdWF6ZlFPMnZXUmRPTFl0eS9VQlhWNHhEZGlWcXl6ZnRKOHBDS0RoRllvZ0I4QVRQV3hPaDJWMXEzcFBoZEdtTlIxTmFTTUxOOVM1RzB2Q0haK21PaWhrZGJyclZHTk5lN3ZraU1iUzBaK2EzOVRwTi9aQlZXMUhaZGFId2pLcE5yZjE5OHZueTZYZStsUzE5S3JTWHM4N1hrUkw5OXlsOFZJZjRUbWttNkZrLy9jdWt6azArVGE2R1ZDYjZjNlA0QUErUmNSaVozTDlIOUxnM1B3WFNlY3I1MEhJNWFOaFNQMVpFbjFTWFNmUmFTYWFyVkZUangydjB6QnlKdzRYVlA5c2lpTXMwTXdiVmZ0NnZCbzRuNklyZzRhYU5EdHJQWk9VNVhqRW5KRi94MVJKOXBTR0R6S2VKVnY1NnBneSttQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRi9uZi8vbGY1Z2VzN2MvRi8vVS85YkhCQ1hpUWZsMnRuZVJYbk5jQXJFSWFud05qTDNxSzcyMnhqcERoVG1vM3FBK1dMUFRVeVBvMDV1UURxZ1Q4b0IxbldvZW45TGpCWXAzZTVHMk93dGdBNzZiMjZncllBTmZIMHllalI4VU9ZUjBONUkzWDB2Z2tsKzd6bWNoUlU3V01MQ1dWVG9yZUoyeS81aG94Z3M2WW1MMkR5VHFEMHJNb2FMTHE4Q1RFSjBObU5QMUFHWjVtNExKYmFYckpuSkdYa3Z5MXozMTR6MUx4K1VMZFBrZXA0dXVRdnR2VzVzN0FHSHQvMW9oRWwwZ1pNem1xTEsySHpiUHFTZnFvSWNMSjlHS05URXVuakpTNVNTaENxcnlMMTlhRTN6bWpyUVU4dzE5TVRmdDZjZk5XbkJ0bFVGZWE2V3JaM2pHV2pIUWVwTEpXcmtPOWF4L0pOMk5LalZCOThpa3lOdjF6UlYrbnRyejhkK3A5ODVhclhWc0tqV3RyRWV2dkdXTk8xeFh4c21aaWJVS2ZpVDZxN1h5ZXZDTXJIUUJuNFI3UGlpcjUwY0xNOW9mTkw4aElsWXozOW9uazViWlYwcGRSMlRvMEZ3eWVpV3k1Rkt6OFYyQ21tV1V0ZFQxS3M3Y3RvNHA0cFhsOUJwNXRZSjEyeG4xRXQ2WUIzcmNoUElQTGdta3VwZDlWaTdodHdtYVNZVjVGbXZ3TTFlSDFqRVozaVNObEF3QnVSSzh5eU1haUVIR0ZIcm83bTJuc1dGcmY2OStROEdqc0xFcmVwWHIxVnlFTHFmaW93L1JETTJVYU5udXpMK2hBZW03eXVWKyt6ZHN2cE9icXY3VlBqVXF1NzdhVlhSaFo5cGl5RFJYK0x0cGFlVTBldzlSeGpkNm9lUVZ1UXRTWTgrNVJQR3NMQnRWM01HdS9IMW1lczNHZFNGN2c0c3ptOHFvTXp4Q3poaFp3Z01hK0ROR2RpM2QzTVZLSDdQQ2R3WTRFTGp6S1g4dnIySnJUUFdobXhOVHhkYnBaSmc0Ti8zcEdITkpRSG9lQkw2WUNBTUJkd2VJSUFBQUFBUEFGSEcvVVplYXZNMG9IcTBBYmZ6Zm9Yd0RHd0J3Q0FJQXJBdTBNQUFBQUFBQUF1RGJZdFFBQUFBQUFBQURBSThGMkVBQVQ0WXVwTGV3WFU2V2ZYejhWNjlmVWFDZHdKenduUURuanJRTUtiajgxdktkc2JjSGtock53Q2hkN09uT0NLZ0VIOGRDQjFxMmZ0UG1iUC84VUxqMjRMNjVQYkZ5WitjZkxTYWN5bGQ2eWFSdExiYzRYOGdxT3pHenZ1VlE5SjF6WDRWd1pXUW1QMUdXbGhhWFZ2MGZHeUptVTNuS0VOcFlNTFpwT1Nydkw1MGlmamJKbDRWc21WenJyUzNTUnIrVEpzMVF1YXhydndzbjkwL0N5c0E0cTNpTnplK1NtRk5HbXh6RHJhT3RFd3RlWC9hbkJmdHpxWDJqVTlER1h2czFWaHhSNWdXb3l2cjhvU2VMYUw2Y1dVcld6NThSUEpjaTFaMTBhblR0WkNJOGN0K3ROVDVLS3c5elJGODFubDV6eDBtZmhQZ25hOEVvVzN3UDdyNWptU1RwZUt1c1RQMnBEeUtYTTFjY1N4WmtuT2hZOWVNdm04a1RMZWlZZTdjV2xyL053Y1p6TXMxZDRjR05PbU5hbHNVLzJWV2t6SkJ0RGRZb21qckJOaU1DZHdGNTY2anh6QXZlNkdtZ2FhNmtvRHRrOWRabTFERXRsSmFiTVdUSm1LbVJ1dTZpVkhVMG41ZEhLNU5KNDVIcnI0REZQVnJTdHdNZ3dmc2RKYnB4SmVyZDNHbk5WV2RtMHE2WTFBT0RMbWZWSXcyTnZtRGJPRWRweUZ1TytpTS9kRnFPa3pmK2pwYWxMOWl6MnI5QzNEVitjNmVTNEpqNDNmN3hyeU5kdDd3c3ViUHE1L1pySlg1SS8yait3T2FUNzVkTngvUjJkcGxKOFNqMDE4cVVGZ01WNjNBRE93ZG9YZWpkbFBYNlBYalh1MmJNK1pFeEZtOUI2R3BpRWVLM01xSHZETWgrVEVCL0J1aDl2SFVBSDFpQ3pCaDBJWXpYdERCZWg5RWk5ZlMrQ1o4UjZCZzhoYW5kc1lkR0Zpc001amlORTkxeGZweG85ZG1FMFBaVEZjdkRGVkFBQUFBQ0FvNEdSQzBBZithbVQ1Mm4zRFNVSkFMZzYwRk5nTVFmYVBCbmpHUUFBQUFBQUFBQUFBRE01dzlVQTl3WUFBQUFBQUFBQUFBQUFBS2Z3NS9jZngwKyt1ZWg1aDRaOUJ4Rkg1OHBqVFFIb1FUdEUwQnFYUlEvdVBVSG9ObmpuZnZFbEwxVmFycXgzZTVWZGNPS3l6VHdKQ2p3QTcvRkczclEzSkhJb2J4TlFUYmpkS2ErU0tZVUplbi9xcjFhZDJuKzlaL0N0ZUVvdm43NjdMMW1QM3krYVFqMjNoVER6cHc3VEU1emJ3OWE0ZEZ4YmNrZGxqUjdIRkRsV0s0cGlSTGpTYVhtOFpXaDdTeTB2RjkvMm5INnRVVWpUazJPM0c1R0d6S1ZmS0p3M0xvbzVydXR3THIwbEw0THpHTGxNcnBzcE5QUG8yK2lSbTl3NHJkUEliZXNmeC9SYWswbmpwWENyTGhSTk4wcEk4OWpLcjgzam9vYmtWNWxGU0MrdENmbzQvcXduaFFuL1NNMUt5WHM1ZFpudjY4emxLR3pUdi9PKzlWWW1YYjFmRTV2d2tLNzBJbzNUVFA1TndyVm5UZkNXYmNHbHQrYUFJQ01YL3ZvZFhPUWkzMVBFV1c5eG5TSDlYZGpZVjNWaVdsdEtMWDlsbUk3dk9qUWI4ams3S3lYYkZraEt2SlIzWHd1L2JDbXZjejFUOGVwaktWOWRsaVZqbmwzeEpMaVJRc05wbklTMUsvQlkwUURzaUpwMEU5UkFvMzBzdGF6RXFlTzYzcVl4WVhWRU14OGRXN1R0WStMbWNpeVUyZFdta21zaENXVklqSmcrS2NtS2JhUXNUNTdzU0NPbDk4amY4bWhLMUdOR2FPR2FiV2RoTFJ6RnVPYXc3cXQzN3M4MEdid21uY2Njcys3WElBZkcrNCtPMklJaWM1TG9uK3h6Wjdxd2R0b3pobkVoMThtUUtkVkJ5c2NCR3dlQUx5WTZ1YjBLTFRIcEduZFVqMGJ5d2xYTVdzQzAvSjV5Sk4vSmxtN3p4K3o5TTFhZFN0aFlPTllYUVczMXpZYi8zRjU1aDNQcHFmL080d3VXeUliL3F1elMxV1VWb1pUU1NHbzladnY2YituK1MvcmJRbnNXeTYvOTBsaXpUVGJQYU04T09lQUw2VldWUGZ0Q0d0K3Zoa0FVYVMyMzFuUkpUay9aeVNqTHNqZTRQR0NIcGNPOWxvRmxSWXgwUThUbE1NdXRnMkhUZ1c1ZW9kRXZRTFBOSXVGV25sMjY3WmtBOGVsbndkSDEzOWZsUDZTZnZUb0VQSmlaZHNSZnNpUGZOcjQ3QnVPcVJ4cGZnN2MvcldlUzJIeUc2WGtHc0RXMTQ0dXBVTjNMUU5NQ0FFYUFEZ0VBQUFCT0FBdndPczVzMjZmMUs4YnhNemlqbjU5UzVoWEtCdUFiZUpyT0FBQUFBQUFBQUFBQUFBRDNBcjRrQUliQUZBSUFBRURCMmdBQUFDSlFrZUN1NUgvLzUvOGp2d1htajZMNDEvOWpocm5uR0FUQS95UzR2cGJTQXJBQzZRUW83eEYyeFM5YUV0V2pPbTUxY0lHem91LzJZazV5ZkovNlNOSzg4MEZYZ0JsZ0hJbTR6NnlWNWlramdNNXJjR0ZHVCtMOEdtd2psbjc5amN2NVNhMDBuV2N5aVpPTWxzM1hpY2EzTlp4eFhPdUlkZE5yN1VoRzNZeUI3RDFLZE1YR2NQQStQRTJibVFCSmdmL0lETnhmby9Sblc3UDZPVlRjT005Q2VCSWtTZlA2MHpNSDlMZlU1cUUrbWJVNzRkSkYrN1YzcmtUeXpkSlhuakpIOVJaRm42aGxkNXI4dnV5WjJzZzdWK29jdjJVT3pnbHBhV1BWVWliRGY2UUZQR3RnWk95TmpvbWVkVG9aZGRCMXBoMHU1V1dDRzNWRzVEUzJEVGtlMWtPakEvVzIxM3VYdCtsc0c4ODZvNVBXWVQ5L3k1QXUxWWoySjVlV2syZU5LYXZNbnJVaU9jdUlqRnRMOXJQcHRaNTd0Tk9NOVFwOEdWNDFZK1gzK3ZndE9VbzYrclcvSXRSZEhPZUZUMXNDengwOHkyeXEwbmkyRFdLNkh2T2FhN3NaWnZNTUpTSXRIVE8yS0o1bEthSTBhUjVQbWFOSUNqc0pkVnBScGhWdXlaclJ2MVlaaVpGcitWNjhkZWcxMjVTa1loTTduczBsSmsraEJTUlpMMFhyeEphWnhvYTl1eXhKUHllYkZlb0tBSEF4Wms1b3FvQjcxdCtvdlp5Y1pYU2hMWTdKVVJsSnB0ZVliOHVNKy9BUDlFVXdZK25YMTluV3RRazNpczZHWVZXNlZ0NjlESG9sK2RUYTNIemRDcHZHcm1FcnFRN0phdDZJOTZvdGk5NnZYRTR2UzZZcE9KL2V2VnZFcVlaQmMxMm0yaEZwenJJVXRUdG0yQ0UzWVhUUEdkM3ZSdkNXMWV0UzBjRDZkQ0JvNU1PWTRYNGNMVE5yZnZaWEJxODdFa01IcVBRKzAzQ0lwTkRuYUVrcHNoZU1kd2RvcEM1RzdDdkhGMU1CQUFBQUFNQVVZT3dDTUllTXlRUldnYkVGQUFBdFY5Q04wTS9mRGZvWEFBQ2VEbFlDQU1CZGdMNENBQUFBQUFDZ0F4alNBQUFBQUFBQUFQQzE1SC8vNTM4OVp3V25mLzFQbXZNVDdTY3hjam9QQUVjVCtXbTc4OGlHeU9GU3Q4WTZWYXZvMlRqd1pVV3dCRzFkZWlpU25pcmVETTZUR0xXUDV2VjhpQStjeE1DYTJBcXh6cEduNFZ6Y2JQcks4cHlnR3o1bFRmcFNLbHZ3dnBUaVBLMDMxcUhXSFlYdjBNR3NvMk5uRXBYdFBXS1VDKzhza3hVaEdGYWV6MkRzWkJjK3ZveU1nOUdONHI3TVlwWmx5LzNjRFoxREU4WlVWQVdta1VYU2NiU2lHbS9KWGpuSE5ucjBsSmEzVHJkU2Y2M2tjLzh6VEZ2K1VNUWNIUGY3OWFlTmZjV1RyMEEwcCtpemF1clRyMldxc1RneS9xa015NW5RVTVha0c2MnlQSGhIaTNORG40WDA5SmhYN1ROTWl4d0FmYjJxajJlcERINHVjWE1yMmxlZVVxVjRyaFpSUnNhZXRlN201TU82WDdBYWF6WHVHZFYzV1hYQlJlalpMblF1OWRKMjZpZE9PT0c1dUlTa3hoZm0ycUlaOTFHWS9IVmRRMlZaUkNad2RQbUptbFhGeUhjV284dXVKamVsdmphdENZeXRLVzNyZFRGSjhVbEp4NW5MSTJQT3ExdTBPbWpwSXJLZCtrdHJXaXV0eTVLcmRBUTdkSnltbVZzOU8yN0kzYzBkNXFQSE85Y3puQUVBd01XSW5jVmRIMWFaMVRJaUdybU81NGd1RG5LakRqL1JZR3oyTnRIdUgxbHVvYklqejB1NFFrY01yQzJYN1Z2THpGK1UrZzZrTDZuYVgyZmxwVzZwT0VtWmthYlI0NTJEUnd5NDhPNVpFa25uU1F1K2kwbVBmSFpwYXBiYUhkY2thbTE0VjhzWnplVzFzbnJkSE42MFdqNFF3R3U2d2lpNEZCNGQ0ZkhiU1kvYTM5M3U5WWtLeVFCdzBXdEhrT3NaMzFmeG1DRkpTZk80Y1I5WjdLRVVYRmlQS3BNUVg0TXZwZ0lBQUFBQUhBMk1YZkJGWURpdjVHbXQrOVRSZE9aOVl3YUQ3d0dqR1FCd2ZhQ3BBQURBQXBvU0FBQUFBQUFBQUk1ajVDZlVBQUFBQUFBQUFBRFdnT2RsNEc3ODhTWDdQemRFd2ZBZW9nVERBVGlid3Y3NURyQk9aOUJFZm8wMktjWjFMUG9OdEMxWVJuM0NDOVlmbGluTlVwMmtuaDNLRWw5S3ZTQ3VCYXVrbU1idTdlaXNsTlZiQit0WXVUeFF4cGFya091a2xNR1V0WDJXb0o1RVFsV0tzdzU2MlJZbGVQMnRSTyt6VEVoamZCckRjeXdtKzNtYzVFZFMxRk1VdUxWUnpFWnNwQTd0dk14cTZrWGpXaTkwbjJhb2plMDdISk85Z29WelpscjZZNkc5S0kzTDNyc29iRmhzN2JQbVNoUHZzak5lU2N2cXNaYXJmMmVObldpNEorME1tVFdPKy8yeFE1aWl4SDRyKzNTMW5HU0VMZXJubmw3dHhhZTladXVuR1RwemRmNU5oc2VMWnRubzJpQnN0V1Zzd1gwV1hqTnloUlZ4N1ZVWG5JcDI3REhuejR0K1lzWklJbG9FV1Y3YXNxU21wRUlZR1NuNXdyMlR4N1BzV3VGVFdHVldlVTJrYjZQblBzdmkrQmwxR01tL1NuWkV4M2pyTU5FRTFFUmxaenBQL0UrYUlzdk9qTERHc2hOTXUwYUhSblJuSlVlbHc4VHJiVFBZTmdDQVE0bThvQksxbTAyQlY1QXg4anlRaGxPWm1xOXd2L3FWM1Y5MWVIbmwxRDliVWp6dkhncnI2NnNBSmR2TWxhbFBWaXhYU1RSUFZtN1FibU1ML3Bsei9ublNWQmlwZGpuRm1ZTXYrU1BqbVI0cW9DTHRmNjIxUURQZXU5Y0c4RGc0WjVsMC9ZVjQ5NGZSSnREV0RPOFRqZDZ5VnVVQmczZ05DWEFwWnZqZHVQUloyd01Fd0RBQzB3bjRJa2JNelZsejYzRW1yK2VHc2VrY0lxS1hYejlNalR5dVNjbjZKREVBNElZSVBtbk5sMi9wNmNmb2NVa25Cck9IOG13dkJVSHZnaWpORzJaS3VwUytmb3hGOVZqSlFnTHVKWkdVbXQvVjdiS1NsMUZnVDkwSi9tR3NqeTZ0bitiV3dWdU92d3dwcHgrbUxQcWpWQkp0MTJiR1pLSktNN29SdXNMR2lTdlR1LytUNm51bERTRXAyMU9WMFNuVEtIQytLc2NTSzF5YlVuTnVRekE0dExjU3RFSXorYU1VdTZ5M3dEVjNhSmU5eFd0bGpjUnpaYThjK01sUkIrOXE0T3NET2s1WFRxM3RaWjdpbWgwZjJsZUhGSm1INmdodlgzQlAwNzJ5VjYyenMrU21aTThKb3l5WDNhR0kzMlM4dzNLSy9RcG1mTDBkYjlGOW1aOXh2Y1hxczRDTDJWNTJrOG80bGw3YnpndW5VNkwzYTZXWHRPWElBQWFybWFTbHdMZkFtWFJSRTdZbnZscVdkbG9xdDlYUkVJdG1Jc0pMb1ZGb0p1cDdwdXp1dGw1QlQ1bXJ6S3dSUnJjTHdqZys3YjdPS1B1S2k4TkJkWkoyeFd6QVRIZE4vdnpUNk15QVFGY2RQRzM1ZXQ1ZzJSQ3ZwRjN4V2xYT3ROd0JBQS9IdmIyOWd3YnI4ZmVNN3UrOTl5LzVDdWttWmR6M2tGOGJqL0RCZkxTS2ZhVlh3ajRodnByNGpOcE0vaXFDRWR0dUIwdnkvdkMwN3dlcVdaVmwzZDNJVE9KS2pubmpBV0NnVTR1Rzk2c3A4QzNNZE9uM3lydzUwVzEvMU9xd3B1dlZMRHVvRklFUlo0TWtTN29HMDVGMktKU2g3aVdGekpqSEdCcGdPUmhrOTBOU0x0Z1hoT25SMCtTTHFjNnN4YmdHT2hqWTRFb1k4emU2dVF5SS9ub0tNYUxGZE9UYW95THdoVVd3SEl5eEg4UlhmNW41YmFVMXc5SG0xMmJYUDl2cW1MK2szeVRYVW5XZlJrN2JQV1ZSV1J4RmNTMW52dlI1ZFNCMUdlN2drZnl6QmxkeGhubnpmZ0dsK1NPWWYyVzc5QzBPMFpQQVo0NXludUtMOW5xMDFUN3pQTmFLcEk4UUxYdDJ2SzJuMTdMV21LRjNON0kzdGVEbVVDRXZKdFV2QzNsZStuRi9TWFhKVFVXRVJpdXdjZzZ0WFBzOGNZU1JxVFhsVm5yWGhGL21hSVpDcm9vU205UzBLZFZ6NTJ6OXRkVWhpcmRqOHdRWlVucXJoejJ2Y29DL2pLN0NLOHYycGdFM3c5cDZKeWJlbXNZalc3dkNhK01pMVlWbTd4aWtzN1pTUzMxcUpSaCtWZGFhNm4yTWpOZXJNYkpKdVlLcnlKSzdjanZSQ2RmVWpZcGNVUmRoMjFaS3pNcWlla3VzcW1OTXJmWTBhR2xnbndBQVRzT2pnTlJUQSs2dXdZNTZWcVU5K2VZM0oyMHFuMmVxakd3T3BLenV4YmswR2VPMTBjZGFVZEo1bnVmc3ZUcytQM1AvbDFScldXTmIwQktVR2ZFUStrWVdlQlNhLytJSzdtZHdEUzY0djcwYnE5MGUxblNWL0FIZ1lvdzRHMmk4OTFlU05DOTBmamZXSEl2WWFsYUM3dmxML0xIMFd4Zm9mckFFNTRERnVuUUMxaXNVbXArOWVUQ2FvRVRTSEh2cnoxaDJFQ1liNGVnR2NFRTA5L003Z1dQc1BsWnZiNytsRVRaUFBwZitLK3YyR3lqb0NyQ0toNjlIdmJmUHBhZGZnY0Q4dlJIV2NiQnNvcWpRYVB3TXNuQmRBbmw2eTBxK3NvcXlJOHkrdW1UeWwrUzcxTy9OYWR4TWdYc0xtWHVTSnQrSnY1eWVmSnlNR2ZUZUovY2o1VlNOajZzcDJXai9hbkpxUnNmRHFsRis1Tnc1R3EydHJmc2VIWjlXMlNQTTBqR1JNdnp4MmJpbWVUOTNzVTlwdlp4ai9kaHUyNlBWTHdOSnN0cXZyellKL095ZXFLd2NZNXdzU25HV2FZVkw4aUxNbENYSXprUjJQdUsrb3VqejkzZmM3dlZUKzdWU2Iwbkd1QTdJcUVONkphVlhiZmpyTFN5aU0yYzZiR2ZwNVdUVXBTVGZxeHBhT25BVVVZMUowM3lyZGZWWXVHbVpoWFEwZmE4clFobEVxcmxSYmNYTkhZdFFONC9QN0JPUmZPcDdZRks0emF1d1lITGRzeXdkYlViUU90WjE4Q3kzdldYMTVKOUY3MzFleFlYa0pkcS9scXpFcEQvaHZya2lmMVJrc0M2emhyUEh5dW9xaTl5UHBEUDdkOXJkVmVuS1Axb0hBTUFOMlJUejZPUi9HNkl6WDBTWjdVTmI0WXZvclV0L3JxSVlwbnRma3VXTCtPVE54SmRXaUl2dEtnZXgvOTdmMmZCalJ6THBWdU94Y1NpV3Vla1pPUURzc05TMVozTE1ja2VEZWZUc3lYczNKZGlNaEptOS8vTjBMODByWFV0bGdDOWh0R01qamhvd25Xa3VRbmxMMHNUUkg2VnUvNkw3SDhiSXdtT0p6bGZhcy81aTNXWVNyaCtOOUVCaCt6ZnE3QWNtZnhJNERneFljQ2JTS2pSVDloTVphTS9TRVllTk5RZ1ROWmd3eUxyd2JMTFJ0R0F1MjZpYnViQmZZSWVsdnAzNmkzY3VGZVA2SEdnYjEyOFhyNjdobCsyZ0p6aVMzR1ZjR08zSGNXQTJaODZoSTh1R3QrMHZJN1pkc1RMQU5nZkxPRzcrOWd6TmRjTlpzcSsrSFdwSGNvK2RvTk5YRVIzUEkzNCtMQVZmaXZmWFRLTXY0M2pUdnVyU0hMS1dBa1RMZElTdmZIbDkra3NGSzUzOXF4UUJmZWcrV29mUis0ektuVUZ2SDJRbGJwUVo4bWIwcDVYMlNndlV3WFZ4N1JmTEp5MmZ3QWlyVERsSlh4WDZSNWJGOVhMbDZRc0F1REtUWnIvMzg5VExqTmFvTE8raWVlUkRqYWl4azRVWTZtT3dWME54L1NwV1BTYThnR09KcU5KZGNhMlNXa0V6U2V2NEszaUNudXF0QXdjd3FDYkF5ZlFzVTlNZjFnV2c0ODFTMERjZm02djNmeVB5djZTSndTcndPR3c1UGE3dmFZVkllamQvb3RIOVlEYXoxa1NNeXhPSUtDdzRyNmZ6K21HcW8yVnJ2NUxrM1FDLzBBZEhXcndXQnNBUlJPWXo0MTh1SGFKdU1keWxHOU51bUR4RENEMXc5cWFwWHNZcFdqb0EvbEsvV05ScjVhNThOblpCdkxmSmZRWGlSMFVlc2hNSGwyRDZDMmc5VzlJY2xDV0YxeE85VFZOL0dZditBQzZUdndvamtiditDSy9mZUJYZWhOM1ZKWWtUTGJzdEVhNDI5a1AwZlI3cGpqeDNydlZEU2VNdWUyL1puQnlyRGFQak5MS0llQ2VTMWVaY05iS3VvS2xoWmIzMUhIb3J1cmMvNlgwVk1YWDk0OVFpOW1zeHk1aXo1QmRuMlVMeWR6YWhqZWtDYkg1Qk1uSTNubm5kdThPSnRxcG4vbG95K1RHVXhMcDU3ck9YRXJ6ZTE3MkVaTlBZb2w1clAreHV2eXhKeDFSaFpWaGZsSXg5ZVpLWkE0V0w5K3JuampJYkxHMWhyUjIwVFpNUTNyTXUwL0NrbEoyWU5NejRMK1NQTE5UQlZkMTZRMi9yWlZzdmNmbGljMEtPcC9Od1A5NC8xM3lkaXJCaWZkSks0eUF4NFNOalFVclhVd2FYWHNyUGplZGl5RWhHZUZMQ0kybTFjRzhkN28zVjYxRXR0K1h4ekdyd2NEanp6SnBtczdaZWdweFMxYVhla3ZjVTRSbm4yeEk0T2lla2JRRzdqZUNlYVhqTUVScmZxelJtNHRteTFHSGEvVmd5UjlESzl0UnBSbDI4NW1RdnhWR0dKejRsMjZ5SXlCeWxaenhFRjBHakRHMFlTeXF4S1lLVVVZejBUZjJzY1Zya3FaU29IakxHdCtaaWFyWi9SK05wZkFKc0h3REFEMUVsVUJ4eDF1ZWpEeUZxNU13c3k3cm04cWZrOTBXa0t0N3JTOGhDaVpZUjBHUWdmNVNmcjYyS2EyUFJaQVQ1dWQxQ3FsVi9RVlh6YjZVbUh4ZmJtZ0tGaWZ2MFMzbjVrRW9sVTY0RGIyaElkYUgxY2swOUlkd0RKOE96SFpBNGRMcUQ0NG00aUNVRFh4cHNHRHpYWTVVdmdwUHBYSlpVaDFldE5MV2w4a3RaN1lyZ0tNYmZQUzZIV2ZkaERTWFFRZFJrNVVCSFRNV2FTMG1KYjlJTHdzeEhJOG96amZLUzkzNm1rY0FqS1lQeGRScTZTRGdYSEhGYjJ6RW92ZXVVdDRpQnF0eUxtYzgwSGtxMENiWDAvaSttYWhzOEFNRDlpYXhvRlYrcm43Y2JHMWlWWnpockxka0F1Qmw1SUFPNlFOTjlBVkluUnIwc3Q0TStUUDU5RUhxRnJ6SjY3QTY3U3g3NHRPQTBidExXeGJpMjByL0R6N3Rmenh5ZDRaTTduVkprRHpUNElvNmJTL3NmZHZPdlY5WGgzRHJVUFhkNk1zTEE3QVJyLzJyS0xkdDRSbjJ0KzhhNHV5TmFyNVpnT0xnWlVWWG04UmxJOGFNdnMwM2F3K3hzblNNRzh1UXk2TXZxeGZIZWVKbTEvenVEaUJJNlUyRkZ5eGlwVTVrVWZnWTlHNHZlKy9MZTk4dzl5bUFmMEQyWXRpZUxsaEY1S1lmcVNLcTJtM2VVUEhySkVaOWRsVnBNeHdOZzJFUUFnSFZjUWNOY3ljRHFNU1E0cVpZaDZYOGcyc1ptcTNDeFRQZlhWcTB1OGV6Tm5DSjdLZTY0SE1ycmlkL1NaT1VhQUFCT1ljWFN1ZElYNFRVQklwdk5HN0hTRmNHbGtaN1ZBZ0NPdzIvRCtvVkZWZWJQcTBGSkFVWXR1QURldFJERGRTRXdFb2FaWlViL0hlZkdEMU43ZmtiOFFEVE5vYlcrRmcvQWJKd3JXODlDNkQyRnFCanBMMGYwU0luT0c4emtvdWZqVzFBcElJei9PZElqc0packs1MHFGRjZ5N3lCaTUwMHJJQm1GU2lQVXU0RDU2MUQvNEkyclFmdEZ1a3l1SmNHdmREOUhtcFUyN2lkczc2WEs3eng4MmI0RnVSalg3MG80ODJkRExoY2ZMZE5hN1NYTHk4TldadlJOUlk4RlVnYkxxdk5WOHBvbkVpVGVJNTZPc1RmbEU3OExGdHAyOTNtTEdZOWcybkdkeWYxelgxd3N5bU9oSW9TUEVlbi91bzBHS2RLWWtzcDJDNjdrV1hnWGQ2OGxFZGs1UmVlcFZKYVVqaXR6dGVFNGNwK2JoUDJja09ZUU54dEtGYnAvTVdlYmIrMDFYZlU4ZFhNdjlTcHpkTXphT2tRdGFHMys5cXl2M25LWWVTd05lMDJNT05VVXZWZGtmYzFmNjJ2OEoxV2tQZmEwYzBSZk9YS1Y4eFBqdFcyOC9lZlJUM1lOK1RwdzhacHN6ZkZqOVpzWHI1eWVlUjdkYTB4UldKZkZNd0s5WVJUdk82OWVXVWRvZGZDQ053YldrVThvTThsVjJaZzU1cmlsMExRaTl0dDkrdkdpb2JLNU5HVkVwYTZjb0RQTGlHNWRldHZreUxic3lYZDBIVWRrUnBiK0l4WUx6b3lhc2JXdnhOSGlraEZHNTYrNG94N3NQNnFtZDlkVWgwd1lLOW53UCsvS3JOY09rbS9xRVBwdXN4QUFjRFpEOXNkTEtVcXVnOTdIWjN4aDZWcUdoS1haWjVhMTBlTnIydWZjbnUwVjlkZWxuZlUzbXpydmsyWGJ0N1QvY21vUGNtNi9iTjZEOGJuNjFKWExKYlYwWWV2a3EwRmlhelEyeXFWcERCN0c3TWNPNEI1YzFSY2h5WmFXeGhWTC9vVlpmYnVjcS9TZktxNytsOHViT3VJMHZPckhNamNuV0R6M3dXdXlhbVloZDAzemcwdVM2ejhHRllWaDNzT09CSHU4NDYzbjlhUXNaOTBsSTRPd0JId1Iwbmoycmp2MCtySHpnV3U0STEwcEQ0TTJuZitMcWNEUGhBVVZnTU1vY3JEMEFGaUtBendSZGRDck9xQnlIbzcyUkVDelRER1J1K0dhSFBQd2kraDlDL2tRempjMGo2bEJGa3FURmRkM3pVRnNLRXdDemh0VFJtLzhPOTMxRjlVMUl3ckd4SHJReG4reGZZVHoyc2g2cGt6RFdZaCtLdTZNMzg2VnhyTmtaMHprSVY5NDlyZWUzNlpieDh6K3ZwTit4anB5Sk5aRDhDTjhoS0FUemVrZDdReHJJRmg1djhUWlpKNW9ybWJXcjVlY2Q5TXRLTTFubHN5VisrV2V0RWEvVGkrdkowKzBqajNteFN4ZlJEUnRMN1A2YlNhOS9UbVFwekFCdXgrcnp0Skw1Q1duK3NlbzNqS2FQYWowZGxLQ3ZRRUF1RE5IYXJBampaWWF6dER3R2hMV2J0Umo1RmgxOGRWays2c1U3ZGZDaS93c2RCOFJLR0syaWVkUE85OWZPYkpGN1MwTDNpZ3duVVZxQWx5TUsva2lydkJJNDZJYzVZcjR0aVpmYVBFQWNDa2F2NVF6ZlJheU5YT0dQai9KUWpvQUpBYVVNWHlwTjBEcXBKMHpQNEZKVUhQNXorZFB6cEt1VlA1ODM4ZDN3elZwZlkyMkJCZGw5K0d5TFl5bXFmNGVlYTRyR1pPM3diZ0J6OG5zTmVYOW43Mk1BbjBCUnRBbUxEd2VwajZpTDVaazRTVU9kWjVpRHQrWHFRdVY5MUdjeDd1OUdaWlVwdlpRVjVNWDU5TTArektrOERibmxyQW8wcVU4TkRhVE1pMDhIU3UxTVlYdVdBVWwwVVYwQUhwZk9PREM2QXNBVWwxbXdMa1JJM1djaVdURWJkSFJwMS96bEVZZWVIRWtWMjJxYTVUTXBFcEtEazgvY1RLcXVTUjVqZWxDSzEyeldPUFhpK1hxcnVPbE5GTGRvbVZHWk5TeWlxTU1hVzNROU5acVk4YmVJY28vR00wazNYNU44SzRSbmhtWG1iSzFPV1NXemR6dTN5OEhGSS91K2Rrb2NoRjJXODdIc3FUcDNMSG1rclUrMTdLTE14MFhWMTI3dm5pOUpUZjBrdlkxK1BEOStkYmY5bzQrWTg5ckg4bGZXTERXSDN1dTVTclZHSkx1amF4UFZodGJjOGU3Rm1oMjVLamR5TlhSbTlkYnArL0VvNlY2aWM1dUt4eWNSSzhaWkJrU1h1cmxyWGZKNktsdjJpOVorVlgyakhGcHlpRDNXV2dtY2wvU01qejFDNm5XaExYU1diS1BVaGE5S3YwSXBjaWw1OHJzM1dhTmxOa3I2K3c2emE1RGN0U2wzU0RGZEZEaGl4SlBsV2RFaUVVWU91RWZHaStaVjg2dFdTMHIybzFOWFY5cndMWVViR200cjdNT2V5STRmUXNBQUVjeXNzM2ZMUnhGQ0s4Q3NyVUFwUUNyakozU1VWWms4ZWJxRXJseGJ2R1hycmlhRkxZR3YySC9WTmZ5UGZ6NlR1VTBtUmdTWmJmQTFxWHZjdTNrZmE1NFE4SHlQMyt1YlhLVnI4NmJFdjJpYWlIeC9MWFVKMXl2Y1NPcnNGZS9PZjc3dXZxSFRhc2p0YjQxWnJxbXAxTCtERmxnSWoxK0RVNk5GaVllSFgwL1BQMXY1VTFCR1o0eU1aWlVacm94Nk5PVjdWK3JqS2hMdE1lcThxNWpudUh5bUNGVkJ1TXBWa2Rqc1YrT1YyVkdYTitoK1dzOTAwZ0FCT0dVdThjWHNXWExKRnBZTEViT01lZE1YeTc4OFNidzZETU5FRVliaS80dnB2WllrRTluRzhBWXVPQU02Tmp6cmo1a3JtUDQ5ak5EYlVMMWdpNDByNGoraEFFWU5NMkhkZjY3dWZUOHNGdzZSM0xzSkpBMjNqRUptTGhmUTVtVVppVDlMdVAxeHBaVUs1Z0FYdTZzTTNycWZmMzcvYmhhMXRUVDgweExTOWZFZXdXbTVQODkvRmRPWVBwYVZNOGozU3R6UlAyUG03L3RmRGhEZHp6ZHBvUGorU3BRN1ZYalhpdkFmR1k4aVoyOWo2QjFvdE80SGtUUndkUHpWbkJ2L0V4SVdmUXJxMlh3V2NYMlk2N3Q0Yi9yeDZsZTI2M1gxQjZKNytFTSszTFYzSm5KRVE5dlpyZkRxcnljSEcxeGsrSm5qVFZTaDY3RFd3ZDBxTG1QcTZJems2NjNLM2IzV2FwL0ZGMGovckRXZUJubmZRbHpFZ0R3RlRDYWwxUFFsekoyam5pbzRUVnFvOGc3My9KYVVGYVl5ZTkweG0xdFgwVE5ha2xaRFJvd0kxejU1YlE1dktXTXhrZm90bWtHOG03NUFSakNlc3dBcnNVUmUvTm9QdW1odXZYRGxRZXl5bzFCWFEyWXhzQUVPbjg1TTNZd1F6czA5Qys0R0ZGWE9JYnZRcUtOREVOakd0eitYL2hoS3JjRW9PVWJQSm9sRytIU1F5TUFSb2dvVGVFQkpYdG9aRGF1ZVZIbVNRMjNvRGpDakhrc2RrVU9sQUVBaC9iMHdmUGoxQytGcWlzdXpseCtpVTVrUCtCbXRDZDllZWI5Z1N2TTcrdXl4QzViWVV0YmJ4MzFsZG1leml2UEp1bEhRZjRUZ2JuR1pwNGcxeTlraVFzd1JYc2Jxd2hsNXlwZVkvU2xBQTV2MlZ5K3VveG8rM0JodmRaYjhFMDRNY3doOHgwc0dWNktvcTZQSkl1ODNiams2NTFXVzJjaEhmK1NSLzExUFBwOExGZGwxbk5KL2pxZVZZZW04RlFWd2FkdGhpZU5ONjVWb21PSmh2Zkk3cDIzbHR4YXZpY2RsOFp5UnRCOGRWbWNMT3NSWVVyOStvdUhIVkxLMk9kbHhOcDRYMlkyOGhjaWFhK2Z2RitxM0U3eUw1R3ZkazVmcDNZMUNzcXg5RmRFRjBhdmkxRW5rbzR6d3FWaktndU4zMlJzR3dLUzdwMVBtWXZlcFVHc2pNUm1kOFgxRWYycVF3bmFFWFFHeVY5TzdWa1Q5YkxidnlXWkpZWFhOSFBOaU5oSzBweXc3dE9ETkYrak1yMXRmeTltYVZTTlhwZEw3OG9KRG1UbWxPSmtVM1ZTNTQwTWpBV0RxV2NsLzBtZmVUbGVBYlYyekphZlBmdkRhZGp3bDFNamRLLzlWZjVJdWhuTHI1ZWVmS1B0MFVQVXRLWDVpaEJuYlkra2ZLbWpQcjFtOWF5MnB2Y3p1UGhSLy9vYmJ2em1UOXA2M2xwNnlodWZuT0UxOWUxeTZyeXhIc2w5MDNBYVZwUjIyTlZobG5tZDVheEZ1YmFLQWdBQUZVazVXaTRKVGpGSjIvMGs1T1hXTVpiZWhidk9XNXpobm5odGtlL1IwRjVEVTVQSnlkVnk3ZXZTK2tSemt1cEZ2NVFxZnhrMWtUSzIrRGJ1ODJkaDExczJ2U3ZlMHlaYWY1UXFWUHF4cXVVcnpTUjBQM2xLRmNJOXorVzhmdEp6WDY1a3JpbEw4bm54TktScHJKazY0TUpFcHc2bnpxek85dzRLREtKNWVEY0dJeHNJNythRVlpMi95Y2hYa205Ly9FVllUVjJucStteGRMU3l1V1c2WjZoeFUxMVRLZFlUSGU5MUhRWU1QSTFwNVFXSDBiY3JjT3lLbUFUdnJZQmdhTm9IMUFDUWRIdVNwcUVZU2o5UEhIelN1dXFkWjQ4M2JUMXJoMlZvQUJicDhVTGQxUDR2cGdJQTdvTzJNN1E4aFZJNmJ4b2dJdTZac0xDQkkzamdmTjFVNGRuVEM2cnp3bGlld2xNNXJ4S2Z1WE9OeFNuNnlEY20rUWtMOEpuM09hRnM2MG16bUU4cHUzZlFmSkVDOXo1STZoSjZ5V2wxMTduZTI2RGZvZHVPR0ZLRnJIalUvMmhrM2xWTy9GcU5KYVk4YlVONDVQMWlzejJiWWw2M2JlNmJDdWluY1M2OUVOOEt5ZnlNdUZ1OVpZQUpyTmpIano3ZDliNkgzUHZtQnBXemdLN203S2lMcUxVRVdkSVAyclFmZkpWVmJldnQ1eEdpWTNGVzNsWDV6bENXSys2dmQyd2MwZGF6ZElLbVcyZnJuWkcyN2l5cVIyMXorV1pRT25SSm1kMEhXeGw1ZjltVW1mWHNBQURneCtzMFN5ZHVjVWMwMjJ4allFVG15T1pHK2psRjNUSHRUdGxkMDVKRUdSeWZBeHl5TE5NSWIyNHo0a3BaTmg3MVg5UjVmQkhhdTlPYTNTTWZQanhtdXNJekJaYUF3WFVQVnZzaVBIbFgreDVHbE9UTm1OMmRVanEvbGRFUG5wNEFNSi9acnM1Qy9tam1xN0ZWd2Z3R0pnc1hnb2VZQnRmRzJpQnZhVllZR2c5RGE3WS9kcEtLNE10MVg0OVhRZEZGc0NTMElWaFA3d0lxelBPVlBvRkx3eGl4WWhxeXNHVVNYNmljMHNwd245Z09RSVFIanlucjhabjFNc3I3Sk5Ya0tFdWF2OFc0QnVBSHorNW9sY3gyVUdieHdlNWVwdnVncU9KeE05ZGh2d1p6cVlVSk9lZ1h1ZHBUZXdzSnJ6VkFkSUkyZHhhTTM5ZVVOUWJVeDhTY2JFK1pvMDlnclA2THZFVW83ZXl0TnBXdVU2QnNLM3lyeXFiOHJiWWRhWE92VEduT0ZUYjNscVlrZm9UdjAxbjlaMndNc3BJbENZdWlkSHRUc0ZaOXFSSkp1TGJtWWgxbWpXc3V2WGJONWZGaTFUc3lqcjE0WmZMaDNGZCthWTVQTGw3blc4aGZjZndOcFdtNUwwL3V2cUJhamVHUHZUaXpEU1hjSzYrUTNyTXV6WnFZbnJYQktuUFMrSlJVd2svUjFOQWdhd0Q5QmN6SHVFbjk5WkIwaGtjbnRQR0YyRG9mYWJ5TlYzWldFcldUUnRaZEtZOTFIMTU1K290NlBqMDlPcjRqNHpvSlpYdHQ4NGd1emVSZmlkSDRlMkZwVENtZFIxTmE2YjB5WjJnNUlOQTduRWM2STlxaEpjbEx3bXlFOXFpWHM4eXByMlF2ZmRJSHJ5d3FjMnFaOWpuVXo2NzF2N1JWbVZsR25hWW5ma1FoSFRXTzYvSlM0cGZiR2JMT0lsS1gyZmVyYlpNblQ5RHNOVWZJMWlzaXU1QzgwYVlOSVN6NjNOZWFVL0xwSmUrUDY2Vm5GNUlkSWs0ZFN5SDNLR3l2NlFzQWVDWVI1VjZjNFc2Wk1aK0xMZXNxdXpuTDN4eFI0TkxPdHc3L0xBbzUvZk1Lb2I3VUxhV25UZjlKSHJMeHlmWDg5cFdaa2o3NTMvdWVuSXBrS0pkWDJwL2J0cVI3dlJHL1pYNWlDeHRlWHhkUlptYnpiVjlHM2Z2OWVEOWkya25pK285UHAzbmpwRHhiR21sMFJtMDRtQnNQZ2pOOFMvSU5PazVPTnRLQjlZejRPYzVjaGpGbVFrUmRadlhXMDcrcSt1dGgxV1hXc0tybFlZdE0wUHhRMnJYMzhab25MVkN4NXUwUjZqZDduMmtFd0Z3RXUwVW1zcG1oOFU0L3V6WkdzMUdGck9STFNWYVpqeG5mMFlVN1ltZzhITjN6b3VlSmZUSDFMR01lQUxBT3k2Qi9PdHZxSDFpQW9uc2ltZzQvVGdWVHdWaDYwekdkUmVnSjRiQlJidzdXUWtKdXJ0WTNDVDlEcGNmZkd0NzNGUHJCakFmM3dQSzcweGszZlo0ZjVaRUdZQUpsSUUyQkhRRlVxTGF0dmR4ekIwdjVlVlZzaloxeTcyRzlyczFqZFppMUcxMHBFOVJ3RC9DOEtqLzZEQXdzSVBwU29sZW1aRmhiK1hyaVp0SXpvQmNPNUpFbSs0azNIdXFmNGx1Myt2bElkYTB0ZVN1Y0prZTNkODhMSTk5RzcvMzI5djlNTTRyVFIzVjBhYTFuZDlFVDZxajVTdGdsb1BCeGxoN1M0cjA2ckFodFdaby81UFJsdStadUhHWW1BT0FyR2JWRVYzSkUyY1pDL0lhdXdMSnY1WmpuaDYreVNsSmY3QzNlMjJNV3VtSlZZY0dON212eEtXUjR2eVNFMXorK2ZkSlNEdy9hUTBHSDM0T1JoM04vT2RybEwyMFl2Yit3ZitpNFBNSmxGbTNpbFVPSGV5cUlkZWdnME5qVHNPYnRFYng5aE5ZekRmUTM2T1ZvT3dMTXhmdE1Jd3ZYVkFaMHladWV4MGhiSFBsaEttYVpDK3RYWjVGVk9UdnlBREFUNTBrTlNVakdaWkg0bXVHdUdiYzBua3Z6aW44Zm5sajA3RDloNU1lcCtMRXFBSFBJd2pWOVVPVlNsZlhEcjVLd2xuOEQya0kxYkNaYnJ0RG83c1pqY1BhdTFDMzFnOUg2Uk4xUFNabVZXS3hQcXRCU0NodGFsYzJWUXJHMlJ5TTdTVkdMR09tTHN6NmNNcUV5cENjWk5MMVVIb2QzZ0Z0R3p3THJMeHYzazBrWlJaQXhaRWoxYkxtak12a25VKzJYSlBmaGt1Uzk3MFI2V1dSL1dqYU5GZS9QTllXcS9pbUZ5U3dZeEVVcXpETzJldnVwSjE4V3lwYkNMZGtqWTRuV3lTc3JNaitqOVpzelozdzEyK2FJUGpla2NMNFZPdXRQaE5FVC9MYzEwYXFyVG5ROFI4cXcxaE5yL2JIUTVxMjBEbm04eVV4Nld0WDY4MFJtRXhZOVBIcjBLbHVoVkYxYnVpWWx1Vjh6U1ZVUzl5VjU2UXVwMGhkVk9laDYxTnFBVVR1aXBQRXg1UzJMQzVmNkpHcHZSZXBzelNsdlBtL2NDTjY2M1FPdmRhM0ZlNjFsaXhXakhSd0VIUkNyb1NxVGh2Y09vbGY5ZDM3bnROZktQU0pyNkZJNXc4ZmQrMVZXWFdqMWQ4OXlIR1ZrN0dUaE9ySmw0ZUpyVml4MVZuNXZHV2NvejZjbzdNaDlSaGZEZ2Y1dHpIbEp6Q3Vpc2ZDSXppajBHWjFjOVB1YTAxZGIrT0hqb25wbXdlbkJLY09WMDRrejlSWUFBRVR3R0gvdVJ4ckM4d05heGhTOTVYMDJZeGxpVzVwSWVMUk9JM2s5OVc5VDY2bjJPNUsvZnRYZnJ2bVU5WHRkZGo5T0RhK0J1M3kxdCt0VFB2V1p2VnM4QzhJYVgxemFTZitFWnpaOHY5enU2MExMeUUzTjR6Nmx6LzN4ejRma3R0elhxY2Z1NEdZQ2Q3Y1NYczhhdDRXR2FmS2xXT3JWU2cvT1k2WGJQUmt5b3Z0Z0ttK21zL2pCMUUwNHN2WGs1RzR5YTZTMW9RaHBJbVZ4WmRON3dqcEVHSFZFY3gyTlJmOTBPSlZaaDR2THRyTDllMjBCK05lT3lpYytrZjBCS3lkaGVBQ0dXYzgwU0xqbmxSSnBmeFFGNDFvaEs5ZnNRNEVFQnZrbkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRPRDF4VlI2RGhVRFRucnhIYmVWcWpURnVKYnlBdENMTnVab0dqb0doYkdvblNJU0hiNjNHTzZlMHk1b2N1RWd6ZWFnVGVINkxVdHBWSHd0RllDNU5GUEtPbGxWT0VpWGhtOHlNR1V2Q2wwRFBUYWRKODdGeWlOMTZNajFuaG03ejc4L0FmZ3pra3VWSnIvajBpNVBrUXlNTE5TdGVBeHJXZ2YrZE9FMnAzRXNGWXMwYy9YVGllM3oxang0ait0MEhyc2xvclcxSmJPM2JLNC9wVE8vcXJKMkJoYWphSC9DQXllYWh3MHBJdk1RcGE2M3RmZDA3VVNrVU9uYzFUU2tLYlJMUTl1VzZvUVJwRTMzdTNBbWZSM3VIZmRTMkZGSVI3aDU3OE1hMkI2OXB1bk1sUHg2cmV4Q3BmWEk4eVhHWXBTWlNicDJOR2hIcTZiZEY4Qi9UdXl2MHdxM0xYMDFQUGFsVkttL2FieDNEWml4UHZXV3BZM0IzamxGWlc2WDFGaG41TmNiY3ZVTEhMMTZ5bk9mbnZrbUk2OEJuN21rZlNHVnMrbmFNdHEwZFl4dmZkSnNnSlRzc1JheFE2U3lrcEUzRy9GVzNUVDVVcjJsT25qMStFcU9LT000ZWpRZ3pTZFpzTnAxU3JJbUJBWmNZMHBJSnA5M0dHdkxxemVQTlUwdGRlWXB3d3BQUXAxSXZ0MVdLNmZkeDhUcHFlUGFsMDgxdEhUYzltMjNHOHg4ZnNtL3ZzUm56cHVzYlh3UzRtbmFHWFdjWWNKNTAwV1hJWTlKSjdWRGRMbnV3YnQxc2ZyZEkvT09lUFNUdFFoR3kvS0dKMXVsbDk3eEhuQXBXYmllK3puU3ExK1hMcnQvYkhyYVJUSm02TjhBQUhBRWtvTFc3STVtYlJlVWZaWUVDUGxGUTJKbnhaSnJpWWd2WW9ZL2dndjMrQ0xvZlZFWlBvcTdialMrVHZIeVA1V2dMTU4yTFd6aUxZOFVTLzNNRmxaZmJDMWNpUDh0VjdrS3lkSEswRXBPUWcyMmttSmtOZFF5bjdtNmVMY2MvamJuODRPYjRWVVZudjJGcFNyQmVWanIrQlltOVdkazJhM3pwQlFydTFaTW5uRmpLVEt3dzJNSmVadE85QnVrK2RpV0RKaUdOWS9SNk11SjJHR2VwWmtOcHo0MXptYm4rankvMUxWRGFXQ29mRGtqenpRc21UUlAwTmNyZlRtVk0zR2s2a2ZUSlNIZlk5RGNPQkpRRWlxZXNiYzFNYjZZQ2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWE9SLy8rZC9tZDhBdHo4Ti90Zi93OCtCUlZZY3JRTEFDSjRUd01qSkl0YlgvempSWDhuSWFRbEZGOVY3eW55S0Z3MitqZWpwTFQybnZEd005d0dMcE8zVlU5UXpQNjh0RlFKT0pIS0UwR0VkeVowbFUxOUw2WHJMNFBMcnNybXpncHV2WXpVR3hwYmMwK2p5L1JUbXIvYkxYTkw5OUp3ZFpaMnRPR01sOWc2dTZDTGdiZXNTdUxicXRtS1NDQXE0Nlc2U2poVjFocUtXaEc5bllZOUtwK00vdmE3SHNiN0tPcld3ZDZHT2Z2eE4yRkc0Tlo5bmxOVzdjenBnRGgyeWlJMlY5Wm5Xdkp5MWQvQWE3N3ZQMUtSM2ZWeXp0VGtkY1QrSGNuSE9LYkYrZDdjb0krdVJNMTQwYVl3MWM3ZlVTV3RETm5TUk5kNDlPc2ZYcitKdEp2K1k4bndkdFpaSkY5clBsMWVURU43V3hUMTNsbzV2ajYxVFF3Mk1Fa3pucVlPV1Rpc3pDWFh3bEduSitpNk9jcFY0WnBJbjdTUHdUcTJaWlVqeEhGRVR6cnZsOHFiVHlwRHdEaXJGdk82MVhMdW8xSkxIeTlGa0YrN0REUGNJRndzZHpEdnFKdWd0ZXhVejZ6UXlONjdJblV6MTJmMm95T20xcWppOU5kckU0aElodVMwWnVLMkc1eG1mZUNwKzhlVlI5VmplL2VQWGVYbi9aK2wxR1FJQXdCbFFmMDF6bmZwc2Vob3U0ZEtGbHJFVDhURmtwZkFSdjFWeWxwbVlNcTFkdDdqeXZrTDkvaXczcjhYelhZT2VGM0c0NmlyTjR2ZlBaUzY3a0o1UG00UzhuN1pNYXI3QzNFandkaHU4MitBZXZOUFFPN042eWdBM1JaNEV2blRnV3JpZFJvbFhZRDErdW9nZE1lSWMvdEl4T0tLWHZiSlg0dTMrMFRLQXdxZy9GZ3d6MHlVZTFRRmFlczR2cCtsditud0F3K09oOUR6R2x4WUR3OTRRbjBsbFh0UUtmRHZ5R3pKamsxbkxncy9ieEx1dDR2TDhZeWNCQUFBQUFBQUFnQ3VCdmNweG9LM1hnYmI5YnRDL0FNemxoRG1WTVkrUDQ4aTJScjhDQUFBQUFBQUFBQUJmQzdiOUFBQUFBQUNnQTVpUkFBQUFSTEJJQUdEeWh3K3VmeSs5K2h5UUcySWRBS2VsUjVPQ0kzQXNnTTJwQ1BSVThTbzRjZ0Q3N1lkM2RxYXBiNVRjOUx0dHljbk85RU5mTTc2Z0NuWHlFS3lEVTVNUUw4bkN3SGxERDFRUlQ2MGhwOXU4azVGRGVMblR4dEhjRnlheVlUeXNJN054VGNQcmxUcXFMS1N6a3J4bjBTcHBQOGNTSjF0R25ZbmVUMkZLM05kVC9sS1gxQjVjdVZxODUweTNrYkswdEZvNnFjd2loRnYzeWVGTk8zcSs1V1lzY2RHU29aVUVjY1FBWXpNTHdlYlg4U3dpL2J2bDRCZm13cWFydzR0YWRzeEU0TWRHTWNyb3dySkR5c294RjluVmVQTjU1cWxIaDNqMXVGV1h4S1NUWkhnWHdSR2RNV0hNQkhQYkorN1R0U1B0MDJldVZ6M3p1RTJuZlVsU2s4YmZzWDQvOWxpSjlFWGtXRWl0N0RuOXI4cWd4Nk8rTjkzYXVwS0lHVlVaK3NXdnYvdld5SWgrNFhMUnNTUnA5WGJNMGZFbmYwRjFiM3RsWVJ4N05FZ3hkZUluWlIrZU1XYlpSVkdaMnZpMmRINHZVcDIxMVQ2cTY3OExxU2U4bXBRU1c0ZjR2RE0xNGxmUU96UWpIWnVjOFhXYWVvMUlRcG5jRkpPdWl5S0x5dFRxNUYyK1UvS1ZTZk1rZlF1dmJyRzBkSnpiSW4zOFo3WFBMSlA3eklPVHBrUW43bXp6NnhzbnU3UzByTnlhWFIycUU4N0VxeXNPWEpoTXkrVVYwSmp1ampxRmI1ZHVGOUwrZWllYmJBdWFiaTV0ZWttV0ZzNngrMUlxMFltRnF5TnR1eVRVU1ptM2hWdjdrcENQY3pzODA5d0VBQXd6c0JCWmlqWHFyckgwR04wUGJNYnNZYjRJeWJjUzNUQkVvVGVla24wZlBZMHFvZDlYKzd4Kzc4K2k2UW8xQ3BKL0hPV2NFK2ZYTGVRditSa2xYN2N0ajBkMkVwL2g3R05sOXQ1RmJRUjVsM1p1WkhMaHZscnQ1WHBuVERMU1JkT0FpK0laWE56QTlzakN3TGcya3FLaGNkYXlHMUZNcSt5SUx4MXJYbGRvRnRKN1pLL0FPNVNpUXdncVpnQ1B2NVZMRDZZellxbFQrOUtTMVhRekNUQzdPWk82WkRZSmVESU8zNmk2ZUFWc2lDYXA5YXl4QTBzMVd1dndiWW5ZY24vUjJyNk85K3dmSGtydnZ2NXZ2bjlpV1FBQVFPY3hHZ09xRVFBQXdDWEFndlRkb0grUDU0dzJmMWcvUDI1WVkweUJid0JqNnB2SjZGL3doV0JVQXdBQUFBQUFBQUFBWUE3d01od0ZXaG9BQUFBQUFBQUFBTGduK2QvLytWLyszTSt5WGYvKzg2Ly9oKzIvKzRSa2plQ3Y2QUVZd2pveHJFNFRQeHp3TzlEdVB4dlhpZVFsTXVuQml3VnpINndtZWxURnc4YWtkdkJNY2VwQ3owRTY0TUlFMTd3MWhhNHVSeXNyVnBmQy9MWGwvVlVoampLYk5vODF1cjdzOHFjUHkzY2ZHUURTT1luSktTTmlhSG5LMGs2bjlySmkweUpwUTQ5aDVZVVlVdGtZdjU0eDVxNksxR2FkaHJTQ1ZJS1Zqa2Urd2RCb0ZsV0drSU5WQ2RrNTc2TnpTa3JUYzI2WDFiOFJadFZoSnBIajRJN2xNOFN5RVArcGs2UUovLzVWSnM0OUx1TG5WSHl2YmttZisybnpyTkREWjdCaTduQmxNR3ZJaUlvd3k5aUNKWnNtZWlieU8yTnlseTNHNzIyZVRNSS9KUlZHVWlaektUWm42RHp0L1lLd2xMb3RxUTczcnJPV25jVnJqN2xJWmZUVVNWeUFnMlY3OHF4cWorT3hacFNXaHNiUDdJR3JhdkxEbVQza2VyYS8zam93eTA4M1BldVQ1WDkyYmszb1Z3RnBIbTFaVzJxRmFQZEhmT3BzZG5KL3J2aWp6Q3ByTFBiSVdMMU51SnFTbWpsblJ1bXlMMEdFcmgyM29Tc3krZU8vUkJjV0laMnFFN01kejhsNGg5TXlDZlRMcUZ5NFZhZndNMGpMZkU1TXZIZjkvQjd6RWdCd055eUYvVTVIL2xBTjUrUlljRHpHZTY5eXRCUnhaRGRxMVNtaTlIdlNhMlZ6ZUh4bktWa1dSYWI5dmVXU1BwditMcm5zcTh2Y2J1TUR6clNHdG85TTh0UDlodGZYUEthZDhmWWxaamJmbHRmajFZcU9ZaTJ2dDNlcHJHaTRKaFBjRUU5SGUvT0M4emh5Mys4dEsxS25xSktVbG1QUW9EWE55SG8wUW0rM2FrKzJacTJ6ajhYcnp3Q0g0bkQ1TitFcE9SN2hCSXc4emFibGdCc0xtRGp0RDlFdm05WExvYUlsVlRqTEUzRmJlbTA2WU9MMUlQME5kM3d4RlFBQUFBQUFBSEJ0anQ4eDRldGFSM0pHVzZOL0FRRDNBT3ZSVTNoYVArTit2eHZvTFFEQXRZR1dBZ0FBQUFBQXR3TkdMQUFBQUFBQUFBQThFbXdId1RlQjhRenV5cC85NWZZYjFuLytiMVQzSERYejVVUi9UYzJsUTdPQ0ZYZytMTUdsN1N6aXEvQWN1YlRONTJLa0l6SmhISUREaVJ5MzljVDFpR21YSXFVaGJWa1VVZUFHUkk4Q2l0aDhibUZIa0x2aTZZbTU5S3RhbWx6NUszZnZCSytBM21OTDIzTjdDNG1qOVo0elA0dWpibHg0SWY5NkJwTjFwcUtWM3FxTE54K1gxbnVHWFVTbUVDUjJ1MUJHWkV4eHA2WG4xMy9Lakw0WkgzWFdPTTVtbS9mb21xMU15bmJDdDdDUjhMUjl1RW5LWUx3M3pWKzg1OGYxRU0zcm5jOWFlbW1lUnN1YVFlL1pmVVc4a3JaaVJjaWJWTW0rbWZKVFpsWFY3ZFQ3bnkrblNzWmhIWmE5dGRHSTlsZDBYSTg0dUVicjVsbm5oQjYzaHBCbnluQXlkN2ZYdTg0bUk3d3VyQWpoa296eVRyV1BMVVNLUGNMdEw1bG1vVXhmdnhkMkJuTmxTTzNBUytYVEZTYmVxeE1sMmJRTW1zNHp5S1MwMGpWTjcxM1ROVzNadHkrNEUvVHV0WmtwV2VaVzd4Y21UTXBueFFPQ1owcGxKVjlFdG5TdElhbXBPcDZUTmJJdHRQQXVPOEtTdWJ1bVd5TzZMYXA4MjlLWC9IWkZDblZqVDRvdTdKK045czcwRDI0N3QvdURLU3Z4ZVpjeG81d2pGWWcxZnMrZ3AreDZrTStzKzFXVitlejdQSkVlYTBzejFUMldVS01iQloyWm1ES3pFUy9tTS9TVUZpOTkvSStHaGR5dVB4bWM2VHdtbzlYb1V2cElIZ0FBOEdBcHcwYlpVMFZObFNzbjQ2V1k2VUlpclJLTmp2VDZaRGdzbytmYmZCSDgvV2FoTGR0MTkvWHNvd2dlQU03Z3FJV3d0dksrLzB2V3gxQnhiQWlMWUpUTGR0RSt4bXRQSmFia05zL2NoZm1mcGlRWjc2ajJqbHJMaGN6bGpabzA0QVFpbldUdG02ekJCZGJCcXowOW5XZjUxSlNJQmJlMFNXWDAxRjlMOTJCb1V4L1JaSmE3bWZyNG8wUEljblZUcXduRFFrRTJuK1IwME9XWG96akRwV3Z0SjB5Y3lmNFRubnhnbUlBM2czWkVxZVVJNG5mcHFuQnYwYk1lUFdyN29hL0FzeUNERU5yNHJhbmovN0hGQVFCdUJ4UXBBQUFBQUw0UzdGR09CMjBPQUlnQW5mR2RvRjhCQVBjQTJncUF1V0JPQVFBQUFBQUFBTUFHZGtpclFNc0NBQUM0RWxpWEFBQUFBQURpNUgvLzUzOWRQMkg3MS8rRHVSVTZnUU9BSzZBZEN4SThOc0Z6UU5SWFUzYi8vTkNjNUU1T2dmZGVjN0tsTWdCZ0dUbHE4b0VVOFVJNUhMSGp3Rnh3SXk3Ulg5ckNITFhEWjUwbnlOZWgvYUxxSit4elRVVUppNkZSNHY0NnY2NzNaWEgxK2tpZ1VpUHhIcXhqbGlKbHRIZTh6eXRkSnlPY3hrZnFNQlB1L2pnRGk2UnJtbFFmUTNvVkRBVk40MGZLQ3VJMXphVXZxMW9qY1M4ajJzc09vOVVsNDZpeDVVbGY0ODE3eEliL1RLZkNrV1h6K296N0l1UG95SEhuWmRUdno3cXowd21mOFAxODJOL1A1NjdrK3pvT1Q3K090cksxWGlVbFBQdXVxVkZlZjdhSUs2cXBJcVBQZDBlcDl0ei96RG1qSGNOdGp5SFpIdHZiYkp3TnQ2VXJUSGhOOUV1ck1hd3g2TFdCYUp6Y3BuSGRuNHc2MFBoSVhaSkRWaVFmaUk3Q1hpdWlKOStaSzhLYnlEQ201SUNjMGJLekkxektXNmU3a2xrVm1mYmNra2pUT01xMHRJL2EzV1FaWnVOVENtK1g2UGJQODNYQXFOK2RaZFRrQWMvbVVvcjhIbmdzdHpxZVRTKzRqdHdJMndlSjBOcWVZL3JQK25McXpMTHFmTHV5dEhFODZscEpnbXlZcmdDQXEySXVVQkdsT2RzWG9jbmtGS3NXUDdJcDBlcDBOTEdGS3IvNnI1U09OczkxaVo3ODNzM2FQaVRpTTI2ZmgrNy9rcDdOeWpVcmJCbmFTTnF1LzB1dVo0N3VLRjdYZ2pXRE5IcGNIK0JDUkYyNzREeThqNCtTa0k1ajlTTU5yU3lNc1dtY01ZMTdoNFkxTExnMGp5ZnFpNmp6MWFDeGw5UHp4a0gwNmE5YXZ0T0F6RUsvd3dRQVAwajJCbVZrRytnWTJEbmJvajJQQjZOK2R5N1AxeU1wb3FoZCtYQWkrdnFmQkFBQUFBRHdJR0EvQWdEQTFUbjdCUWV3QnJRdCtDWXdubzhEYmIyYWZJazJSajhEY0Z0RzNpSUZBQUFBQUFBQUFBQmN3SGNFQUFBQUFQQjF3TVFEQUlBR3FFWndWL0RGMUJycitOYm9RV2Q0S1FPc3BQY1lqeElLZmhmeHVPRXNuSUpnZldTcnp0dDBrZWZrZGdCNjZEaDU1VWtVTFZBOWtqMko4eGxOZXdNOFJ3ZWRRblFCN3puWHRUamplVGxXaVlWTEtiYXROTWs4c3lwWDRrc1ZTdXRMVHdTT25oRkYwL2FlNjh2Sm5sbjI2Q1pseHVjUVVrY1pETm9nZTRjSERTZlBKM09jcCtpdFJsTlA5Z3p4elNHK3QzTUtuZkJOMno1MFpHRTZ0WTJmeWV4enhqMFR0WTkybGRxWE9hT2t0b3g5V2RwY29GOUtqWDhKNTFYRzEyMzhUcHpZb3BMczBWZmE4WWZGU0M4SzdjU2F0N3pOMDZieWpXdE9UcDIzcVBuMjg3UHZpOEJhMjNPTTZyS2V1bGtyY2pMU1JZaVdRY081T0xBUjZaRmJhK3VlNFJEWnNuaTJvQkhqTmdYS3RqaFNkWGpOck9qOWMzbTk2UTFDVFVsc25kNHY4K21GMkg1MWJ1czJROXVDQzRJTy9VcmtQWmd2M3hTY1k0dHVKK2d6Z010anJWZkZHZTR0S3luNXZXWXl6RllBd0N4bUdhdlplQ0NzNXRVaVNrQVhlcXplcUIvTHd1dUxzTXJ1WjRrcE9HR3QrL1VKMDNEYjExYmNUM2RHSHJCNFpjY2wxK0VhYmNubGRaM1pkUCtRNnhsWXBvNUV6LzJDbTJKTkhSb083Z0hYcnhIL25CVnVsWjJZZkwxK1NZeTlCcXQ3cmFhZTBhUzlWbFdkUHlXL1JRY2NqRHhYOEE0aU1JM1JPZVF0UXl1MDJTWm1Jejk0Smg1YndMdGhNclo1MU9WQW44SE5KTHJUL0ZxOEN6RFdqS1hnaTZrQUFBQUFBQUNBRHJBYkF3Q0Fhd0w5REZhQnNRVUF1QWZRVmdDTWdUa0VBQUFBQUFBQUFHZUNYUmtBQUFBQUFBQmVZRDBEQU1ENS9FbGd6OGpxdFByWUJ3QW8xa20xVXRvZ2p4amF5azMrUGExaWF6N3RoQmZwY003Uy9BSEFKRENtNGhUbmRmWmxCeGVtVnRoTE9xNmtZOXdhV1NtTGhsc0RtbThJN1F1amhaUVJiMHA5MG4xTzFOMm55RXlhMzNTWkRlZXU5eEs5Uk8rd0RNYjN5TXFkK2FKeEVRd2ppRmJaTXoranA1N1Q5RnorbzZhdGdUV3J0V3NwaGJGOHZkSjQyOVF5YXZ0RmdKV3NuTTlyT3ZRemJ2ZmplRTBaMjdVOXZwdjFaZmJTY0ZzdWNHT05Db3pXeVdNM1dZWE9wQml4dnJJOTZmNm15Y3dxVVp4MXlNRjhrclJZK0FpakV6ZTRVZXhpdEl5ZXVxeTRqL094ZGtWZmpjZXdITzF1cm94WjAzbWtzODVRSGRINHFQMTh3dFRNQjVWcExkbk5kaTdwMStEbW9FTy9HcWw3SXllM2N6SmRudEd5TDR0TG53THBMOHNaZTlRajV1MUpheUVBNEdhVVNRcHBSSTc0TlkzWnZvZ3RqTDZwTXZPbE5ycHhsTW9ZS1h0ZnhsVk53Y0ord2taK082aTRmVWt6bUNmcnFQWS9jc3V1dVQrMFBEQTd2cEJlbDcvMHVVTndUWHI5ZDcyYjBVaTRWMTQyMGp4b0RFWlgweXMyalRVY1BQNE1RQmg4cldXSzJRd3V4YTQ3cGEyTDB1OXZIeURHeExNcEEybUNPcVUwZjZ6anFudnN3eW5PTUk4TTZJcHU4TVBVbXVoN1A1ak40RXdXdlhHbC9kUkJkcnQrS2ZsamxGSWJscWI3U2VOc25CeE1Ed0NZQlBNOHFYZzlSS1VyR3B5TjlCQmh1TU5LOVc5MEo5S3pjNGw2cHEwYjFWYjdXdWJuUHZQN1owTkpMNHQ2Y2FoM3AwZ1BjR21KMjNXcFNvcitRSGJtREkzS2lxUS95c0xTNmtUcjRIMkZ6OGxQaDVJeWNvNFpRMTdGYlRVOVY1ZmVzbHlGOG1WRlo2MlgzN2xqalNsbmFaYXFrUEt3emJDMWFVUllGR3VESk4xM1QrdXZtcmRTbzg4WUlTdXNsdlg2YTE0Si9QM245d3RSWit2aFVabHBRUFpSNjVBSG9TN0RtK2hlaGVaTk94dHB2TzVEbytOWCtuR3Fyd2JlT1RUWmhwZ20wenZPdmYyZUEyVngxM1VaMXZxVW5PSFBKTEl6ODdaME1jSnAzdE0xYU8rUWlPU3p6Q3d0dlJhL3NsRm5iOGtpNW1VdjJrRDJidk1MbjV4YlNxMlhNTXdpbmN1enBoRm5vZGIxU3FZT2VEYkJlWHczUnFzdjVaZlcrdGFIcUFpbG1YcnFKN2l4TEZjb0RhZjVvcTZ4NGwzWGZvUUg0clcxZm9VcG40UXlQRVlkQUFCd2JENS96UUFPeTZzcHUzOTJ3YUxlZWtWa3I0OUJmYWhCMGxveW90ZWNMRy80T0piSjduK2NsSGYvdUJmTzNVYnBKMlBsUTlPUFZiU1gzU3pHUzRmeDV1b3ZydXhQbWIxK3ZqaFpDRmt4S21hWmNKYXBBN01EZ0MvSCsxajRTbzgwYnFLZ3ZFM3J6VGRTQjIrNkdXVkdaVnZEQU92UVl0QzRwMlBhK0s5L1ErNnJUTktUZm01ZVN3S2dGMjRBTzU3aHJkbDd4V1N1WFB2QU0raTE5ZjdDL3pEMTUvT0FEMTZaVjI0OEFGaUJaY1dsMVBqS3JSbGVuR0ZmVGZrMExYVlU3cTZERFlNZnBBSTMzZ2tMM25BUEdEd3FVaExrOVF1Q2k3RzhZN2pWd1l2WDBNeEcyY2xJTjBvaFY5V2s4T3dUUEYrdlZFcmNIdFBXZHh2LzBkQ3NnVERTejdQVGpsQTY0bWJXTFQ0bTFQd2pSRC9YWXdzMDQ2elhPK2FPMXVEcTFmdEF6aUg2RTM3RU9POWR0WHZxdHVwK1ZzN0ZGWFV1YXVpTUZXcldiQ3hMMi9hOHNxNDdOb0s4elNwSlAwVTMzV1pBajVBREthN1FuaDlVOTcvSVZVTGhXK3djUnVVTTdRd1RYeGZON1Y2QzExWlpFaXNzaVh1ejBoS3diTGxMRUYyQVBjTlp5dVBsVFBVN2MwdDJoYVY5ME1UbnpQSElEMHJaK0tMbm85cDM1WndwM1pFQUhFaXZybms0ZTk4Z0gwK2gyNGllNTZGTm1qSW5mQ2tqWnVhazlTZEV2VGdjc1ZnQUFMNmJqbWRTSVhtbkUxWEl2YjRJSyswYVgwVHYzcU1WRU4wWXk3SitmRjdaazA0dlV2T2RGV0V4OUxlczlIQ0h4dnZib3dqU2lsSENUTHpkM2Z0S3AyVmYwclRnQVdBdmRtMzZIMnJFd3EyNEdXWFRlR2xadmJqeTZkMCtuc0VWdHVhWnVhN1hJYXcxSGN6eVJZQXBySElwc2U0cjJuL2tHa3M2bUVicEM3ZjJoNjVYYnRNYW9Qb0lNMThoK1RKR2JMMzJoNm52endQK2RiTDhFeEQxUUNJdmJRQ3dtcWh5SEJpL1Q5UEQ0dWw1Mndrc3dzUHR0eDloTzRrRnVnSkV3SGdKd3oxaTg5cVAxanpONUEvTTV3dmpmVU5wbU5YYk5jMGJGZzNYNDkxZjIzb3ZndVgvNWt6ZUJia2h4NU54Wi8zU3J6MytmcTNWVTlLSWNlNzErcy9jQUhndEttK1owcThKeTBEWlVaeDE3YkZabzBWMUdXQnJObmphaGoxM2w3blBwOG1wNTFUZm5VWHFPR3RzUmNaemIxM08yTkJmMllsd1JqKzNVdXUvQ2p1ZWZVNHcreFVjLy8zbTJoQXNJM1BwU0dhdlZ6V2pNa25kcEtldnFrMG42UGhHZGZTc0JiMUllb3ZpcjR2VWk1RXZwZmJiVVh6cC9ySXQvZXVac1RQSXhuVXgwczFjZDdqMEk1UVR5cndIb3hyUU15SjdXM0taSlJDcFpHOGw2TFF0QVprcmg1NVgzYzZjMXRFdEdtV0ZtaXYrNkRXV25GTDQ5bWZoazRTNjVNaWwvVWlXS1FjQXptT202cmZVY1VST1N2WnpBdnAxNmVoWFRYL0tLSHE4VjVaV3Rsc256dEF4czAxMmJoLzRERk1WQUhBV29wTmxnWUdadmI2SUpLUTcweGZoOGZmMGxubkUvY1ZSUzZqV3FWOGZXeEpUVTUrWjdrT3JTLzBVOGltRFMrOWZLbDAyVCtMZnJhRFhYdGVDcDI2emUzUEV4RGxzWHd6T3dlc0NMa1krY0R3amp5cmxCeXA4T09YTVJ4cWFiUEREa2MweVl3dGR3NjJudkNVQURnT05maXJleDBrNzFjaE5tc0FrZXZKMytnQkQ1TUhaNEtKdzVOaXpQQkdQSmcvR1A1eklOUGp6U2JwNVUvWXYycUd0QVhnV21QYzYxS2F0a1pRdUhKcmdjRERvV040bVRvZVNRNVBlQ08xSkdoYTRNYmEyWGJCcmZvdXV3bzZiZHhnWTA5RWU1STI4QU84SjN5VzRSdCt1Zk1EOVVXK3c0c0UzMFRlZXViM2FqRm54YzI1YkpRaDI0U2lrZjVjcXlYTEJKMDByYjdnZmI0MzhOZmZlNTEzWHJpdXN1L1dMbmQvYzF2T1pNZDU3WjNGWFBtNmpwTm5YMXN0MmthSFFhNHQ3bmFZeldLMVNSOVEyYmZNVmRTMTJkSGoyejN6ckN2aEFXd0ZnNml2clBXQk5YVWVtMk93UDdsbnlSYkt3bkZZM1dtWVlOVjZpQzRybUc5eXVlOS9DbmJuaEJ3Q0FNNHgwazhnbXBQZUJTKzRzTytxTEdHRkEwUWVxOXJ1K1pubGhmYTFUWlpkQmtLTmNXM2p1ZHViSTR1eXFtZHZmYU40cGZ2d0U4d0NBMnhQYXZCblhWamhsMXFheWg1SDkwWTBZYVVacmkzbkhiU0wzamhRNENEVDZxVVFmTDJVdWtMdEd2d0l2QjQ0WHVERXZndlpnWVl0SEo0bEV6T2svckZXYnQ5UDAvL3NLZldoclIxOGM4S1lENEFpRXA3U1pQbFRkUi85Y2w2UVA1NjhjNHBhYXEyNWErbEpxTWZMaXk2a0FySUdxT3ZWeFdkN25FZWRsM3YzemljZjh2UWVTRi9KVVZtNDFKYVBWdTdobEpuVnJTSlEya2ZLMmxyQTZGcmx1bjY4NmxtQ1hTZmR0R2ZNamZXRU5Nc3NWWGxMOHhRTHJ2cnhQWDdpNDNzZk5oaFhVTXhkSHErSnBZN0dNbWNwaVg0ZzAya3AzbVpxVlRtOVFHcCtDTWRzTXBhSm01K3N3U21ROFV6NjZKRllHSjhkS0p3MG1LZS9NTWRiTGpMb1ZWWFlPM21jSmhGcEtvcjA3WjUyTTd2NzlmV014UjRNaUlvaFhHZmIyWjZTMmxsM1JzdzR6ZXFVa3U2aDNQTTJ2YkxiREcvQWpuSUQxRGRxaktwT0crWHg1d1paUWY2V2hOSTFjcXZ4N21iSlVZMDFwNHF6MWFqYldHc2lsNzRuZjJ0SmoyM25iSVRQNXZIQk9RSHA5YjZ5N2kvUzZ4T2p1WUk3K0o5VDJXVmF1ZStpNVlkUHA4dnEzVnpWcUhYc20zaVZ3dEl5b3lacyt5eHc5aDJGYktqbnQ5TlkrV1ZnNithSjIrZXF5aGFySmtVby9OMThxSkdVREFNNWhoVlhCdVNKcTYwckw0NDAvVW5mMG5vZkQ2ZFQzTTBnbFQ1SE03NXJaRGNCMTBLeTEzK3A4QUFBWXBkZVlkZWszWXRSS0JyVWNJTWhNU21WbWJjNnlNMHpLVzVReUJ4WW1hekUwNzIvLzdPUDk5VkxQcDhoM1lxcU4xZDlOVm1IU2l5OFI2QjY3WGRGaVhEYnk1VjFvdTB5Mzl5VDFXaHN2U1UxQ25lSUx1ZGNVaUhpZlMzSjVveHZaNEFaRTdFN0o3U3BQRm5BSHJLVXZJaWVsMkNNTm1uZWtEQzBQdDZUY1lIejIzSzVIWnU4Mk13WHppcjdUem5SY2VzazhoUHB4WWhrRE5aWXRqa1kvRFhFNUZyWm9XUklpUGRPb0RFRnJYbUlZQVBmMnpYcGdKb1ZidW1nQ1ZwRmFucS9HNHk3STVKb0xCeUpjRTI5aGZ6NmFtbk95SkRSeUJMUVh1QnJTcGhWTXhkdTA2QUlRZ3B1L0s3dzVYMFR0dU9sZGtnL1lFNENWV0IzLzFYTm41bWlsczJrK2hYU1cvT0J6SlREZUQ4ZlRzYU1kNy9rMDlnUFcwYVhiQUV3ZGNDT0tFTkJ6YUpDVjlsNnE1Y0lUZWIwWkFnaGNVL2MzL1ZNWGlTc01XTG9USHRrWlA1T1JIcHpXKzl5TGMxeTMxbW05TXFVeXZISldENlY1aXNnbmYxV2VYam5Sc21hMDEySzFWUnlCbkgybERYTWMrQWpBdVJ4dFZVaVdEUGZ1Q1BjdXlaSDA2cWZtcGJ2cUJUcHBQeXNXZGNTTmo2NC8rRlVJQU9CMEhBNitXaWU1dHZ2RER6WElkVGJTZUp4bjNnY3hvd3A0a1Q5RVhld0NkZDdXenVpelkrMFhrdUpteGNnYnJJSkhrTGVYdlduYWtaWEY5T3QrcmpvUHVKZS9qT0QwQjBCa1pFOXp0TC95Sm1OK2hhNkYvZ1lxM2pVQjY4YWxFTld2WThLL3V4ektBZHdVYm45MHRIbjdHSlVZMVJQYTd6U1NFZjVRTkMvV256YUk1UHIyaloza1pkR0luTGdCd05rNFh6SjZqTjYwRmc2T1lLUFF3eFI3dnJRSUp5bjR3VGwveFh5cE0vL055TTR3N1NzUTVxR200UHBFYk5mZXVUV0VkekdwSytkZG5iTng3WHZqcDdBL0ZLMitybFdKS2RKbkFKcEZNQ21VM1YvMGEyQy9hMkZwaE9SM1NtbWJVNXpYbkF5OW5pM1p5Tk5qV1VuOTV4MnduZ0ZPTFEzckNVeDJwaXY3NUo2aW8xQ0Z6WlpWZ21XUExyakhiUXg5TmQxZUdkam1MeC9mREZQdmNHNm5wYU5mWnlsZWo1elJmb3pVdGZmRm54RkdKOUdNdWtsMThJek1zZEhnL2Nwd050UGJjcVN2MEJ5elYvT1c0TlhYV2w3dkhYbmJNdGpUbkY4dUdTS2E2NktuYjRRV0pkeHJSMWlWc3NKL1pYSzNiOVZBa3B3YjI2NndmL00xa1dyQmwxSEVkdUJyMXFNeit2UnpWS2FWUHh0eWFGaGhyaTFiWE9yaEhySnhIY1V6K21iVWU0em8raklqSFgxd1dJY1hwd3lWM3czU1hvaFVpRmE1MUZtWjBXNk5LakNhZHlSK2hGbXlwYmJ1SGhEOVJiMnZ5VGFLelNQWVBxSVdZMlI2OFE3anNPZ0ZiUXpBaytsWjhiZDAvMzM5K3c4amk3dW15MTV0YlhMcjdoWXVwZU5ramFpSWFjdFBUdnU2VkVLYnIxOGJaWTdvNFRCUkl5ZGlTMFR0anZQTlR3REFkQTQwNHF3RmFRdXJkWTJsa0UxWFF2VCtwTldQRTk2cm9HZTJkWFplZXpkSW5IK3VUc2M1YlBOZVl0RlgvL3hLLzV1TzN3VDlUY08yRWwzRWpRV1pmdFZVSG5SY0lid3Nta3RlR3VVVW1hbFRxY3JJb3RTOXpHd3N6UFZvTHFxa2ZkMDhlUEpKTXduY0ZHMUFTZWsxWUZkZWg1V2J0UjdadlJ2QTBTV1FrM0ZEb201b2ozODlHVEtwTDJKa1Mwb3REcXRiUGFzNHZTOTdEWDhZMXFEaFREdWYrUVR1RERHejZTN3BKNG54VEtQWHpnUVBJbXBIUlBTVWtNenlhU2VmS0ppNkhydzJYYS90OXpDNE1VbkgyWi82NHEvVFpYUEEvRGhabm5EODhEYVlNQVBCM2RCbTloYWZuZmtEMlo2RTFCYVdacHl4ZWNRYUI0YkFBSElEWjgrWFVDYUZYNHJyN0hqZVAyNTcyODN6WjB4bS9ycDE5NGs4Mk5LYTFYSEZ1STdrL1hKY3QzdTc0WWpkQ3VDUnZqSXpNdStMc21jR0UvbGF2NXp2cG1iZS9sOTdMYnNrWlZKNkxjTXFBOFQ0MXFjWXgwL2NxN1prQ1Y2N09jS3BhTDNGRThuamZPRHE0a3hGdEdyUFlvVWZRQ21PWVJVZE93UGpWR3lpTXFoWnNGQUJjSHVvaGFIOS9DYTY3cTVjbnNMeWxKZm01QUJieGpKR2paeGl4TUhWQThERHVhQVJOMVUzOVNoUmJWT3g0cWQySGlNLyt2YU0xWUNTUE1ubm9IZ0d5dTRmTWY1OVdZNWJmQXByM1hqZWZOWmtqc1czYVg3cmxNa3pXazhMV2U0QWFiUmk2UWNBaE9uMXQ1MjViK3FWa1pYckd6RHkrZ1ozalRVRG1HQ1FmQ1hOK3g5c0l1WWE0d0ZjRVRJMmozalNqdW1RTHVsdXVqT2U1dnp6U2Z5Ym5QNDQ5UkY0ajFieHhsT1pHTmhnTmc2RHFyeitrK3YzRFJrWjlJWGRrbmhuNGRPR2NmMWdPMWZlVk83UXhFeitLQjYvUFFBUnJHTlJOckRlc0hDbmpyK25jdG1ub2ZOWmF0TkRUeU1IT3IwTzZGdXdyY0N6RnBiZi9QUUxWem0xeHNDN3hQY3B3L2t0WXZmZ2NEdFZlQXVRZmhua2NSaFYxRi8xYXIvNjZHMFA2WEZvTnRKSFpIZzNEblY2N1NHOTF0L2VNN0xpajV5WHd4WFh2VjhpQ3J2blZxWVp0ekVoZkRQUWVSbVR3WStLNmt2SEdwSWQwUXgzeDZKMzZKRHlGdWJ0YU91UlZ5MVBpKzlORzAzZjI5Z2prMlpPSFZxdEZodi9ZbTBDMlh2Y1hONlJSTzluWm92NzZTbXRudndyYXF1MVJLNytLVzJ5eHA4aGRHQmg4djRrNS9TWDl4NnROZC9UdzhWSXR4OHJjcncrVitwNDZjZXBueS9PdHpGcEo5MXIyNnpBc21sNitpQUpNcUsybkZTbVIwNzBoY01paE5ONG1pWlNocGZjR2JjR3pscnVtZDIxUEM2Zjk4Nld6SWFlWmgxVjN6MDMzRzNMRzJWSFpKMngwRWJyR3pVZnBUYm02TGp2V1UxbGFTa082ZVJ5U1g1akFsUnhtN3c2NE1oaEFNQVRpRnJNZjdHOFdCN0xob1pwbnJEVjg3NjNETHJubEY2aU0yV1h2Y3lTSEJrdDRWejhyTWIwTGdxU1lpL3BEUE1TQUFBK2NEclNzMWtzaW96c0tjUkxyYkJMOHZzYXJFV0JJaWxrU1dHUCtyT2o5YU03aFVMKzNhSzNaNXN2YjFkSlRENnVnNzJidDlTVy9YWnpjbjQ4Mm01OFdmU0hvWDYvRkdYdlUveUV5dFpiV3phL055dk9CZHZhUG5NanpmSzZSVDFvRVR6VEhkd1FTeFdpNCsvSkVSdENMNWF5azlKSmFTSkwvUTN4TmxkaTB2VnVPYVUwRVpPdkdOY2VwR2NhNEVWa01OUkVmT2pROGRPWi9VaERXN2F6VUdnUkNucktUNS9BQktLdkNrVGp1UzFvM2tkNVJWdW1yU1FEMHlFZDl5ejk0Znh0NHZjUFU3Y1h2aC96WTFRQTdneW5KQzFIaXJRcVliZkRzalZ4NHd4bFhxS3hIS0VBaElsdXVMRjBkK0ZScFdMVHdtcS9ObCtsZ0tVVmFSNytyMnZOS09zWDYvbDlHejdUUllzSlBKMGVZK2pNYmpoSlI4d1l4WjZsSHpib0txQTdyb3EyUjVPSUhpN2ltYi9ZYWwrUWNvVW5UMzI2WTZUV0h0c096MkpuMGJzMnpHaDE3dlc5NGtnSE5rYjA5SFFkcnpralBNTnN4TkNjMlJCZS83UVVIcm1QTXhmYUZXVmJiK2xlMGJBb3UzL1VoK0pSMjh0OHBBRkRDNEJEMFg0YWNzUjBsSDY0c0xMc1ZiS0w1U3VMNW5Ia1YrTm51bHRIMDhIdEFnQzRNNGZvTC9xTEZZNVJ4VzZ0K2tldnlKMlF2Y28rd3RGWitaV1grNUdRVU5ZVzUyK05lTnVWNFhENW1iUHo5cVp5ZEpuUkgwK0Fpd0tiOFR1Si9zSmlOYlBMc0J4ZFoyKzZEK0tNcm9PNitIS3NOU0VuckJzTG1mMUl3K1V5S3VRYWdLdkRERlp0SDRSeHZaREltckJ5SS94bFVOMzkrbUhxYjJ2alI2a3ZyQmNrUEN2bUYyMEt3RVZaL0dJS2QxRERWeUROYjVxbUtQditUTElUL3orK3BBaUd3TGdaaHZ0Q0toZjNFMC8vSVBOWmY2c3VzWHlaYi9CZVdPOWlYNnBqUElNc2szKzUvSndNNlhxN3lrVFM3Ly80V3BaM25wS0kyTDkvaXM3ejJHTG9TZldwdzFhbmZSMWpXSG5vWU9KY2FsSStUenducDVDeXBUS3RKeFo4di9ObEpsSm1DdVJKZ2h3amZmMExzdks2NXRMUG5MZW1ZcmJhY2g3dHlKcjFva2hwL3J2RG96S1NFRDdGcU8yZE05RjBYSm1Xam95ZzNVZHhwSXZLbmNuTU1xeEp4WTFMYnFpTjFHbGZoMHlNdXJmc2lkUFpOak0rYTZaMnJVbXdTMXZKNmlmdFdwcEVidisxVmhRbHZic2EzanhsVWpqWG43RjFWUDYyYVd2RDFmL1NMNmR5YWRzdjBXLys5MzI5MjdMYXY3WmE4ZUY4YmwvZWFMZ2tlNVlSWWRXRkcrc2wyZmR0bGRrVGoxZnNlamhqWkpuOFRzeTlqeUk2TkR4cWVJVFJaYnlXVWQrZng4eVlXWFpVZGsvWmtUSzVmbGZNZS9ybDBCRy9kRlJiOTFqd1oxZzRBSUE0a2FYRFdrZDdMU0thbjFzS3ZaYlBpRmVnZGxzVktUN1plbmZKYzhNWlpuT2RwM2R0bkluSDVnRUFnSmxrYVNOVnAwbnQ5bDliZ0N6OTdLdFk4bThnYWxiNUlyUTAwa3E3RXNGMzl1clBZcDRFMFhaU3pvTDNsdXpSM21zNm0vQVRJL3ZXNmh5dG40NlR5ZFNXcEtOdGIvbU82RWdxNy85R0R6TE94clVGN1EzTm94cTFOMnVzbHZHYVQvOC9lLytWSlQzT3BPbWlRSjQ0TmYvNVZWOVVENlBySXJILzhIQzZnMGFURUpUdmsydmxGeVNoQ0FLbVFBZjNIT1ZBd1JPUUtLazk1SThIZkM2OFBrbFVKYmI0T1ZIL3lLcXJSLzNlSE0wUzZtWDAwT2daVW85blJGekRlcUNRNmRNaDVySnJpU2NsT1U2bnJVZHdkWG1BaWdjbTNPRFFGRkhFeml3a05semU0emR2czlIbFVxbklTSk1rUEhIMTJ3RWhvRExDcHZueEpDb2hFUTRBR0U2amc5b3phekhydjFqckNvVkpCMENJM2dtSHdhZkNmVVdyRjJzNUMreUlSeEJmOHFGNGhjSUViYjMwNlk2R1FHUTlvWHordWhJM3RheGE1cFkzajNmMWQwUlpGMlQ5d2tDKzQrZ0M0RFJFeFpGMXpKZUFXUXo2OFh3cDFWOFdpSEdtT1h5QU1YOGdtaDhoTFRTM21xTmRQZHE2NmgwSlBPN3BEN2VXT1NLWTBucy9ld1owV2w2Y2lSb1NKeExZbnFaRHZ3QUFKRHlxTXZwRGdWNWI0SlcyVVE3VGZLZVhmMWVJcTdmYVV3QUFvTEtub090WjFLQ3ZwNDUySEN3Tm5KWGpLUE1FdXY5OWdPMDlGT2R0ZXV2b0dWbjdxMTg3bHVRMUZTUTd6UHNESSs5Nk1RRGdRWXlPR1k0VTBEUGZaK2hWdHhmSDZtckw3MC9PNnpPd0h0MnpWbkRBRXhndEdqMmVpem1ISktFQndFRVVZOURPMUExU3VZL1NSOUtQZ0x5aGxvZklrQkcrK0k5VlZCbFN6WW5oQnB0bHlVcDQwd0V3Q2s0cnZJVmp5MDUwUy9ibHVQQkYzd1B1aHBWa3k4R3J5MG1lVFJHUUFTQkMvWUloTjUvck5LQVo3NDlUMGVVWDVUQUZKWGt0TFZqNXZjdDFkVnArUkgrdlpwSTd2NjhIRElteUxmWHZrRGVvczF4QWtuY0dMcVFNcVhIU2EyWXR4cjBWcFdvWmNLV3hidS8xYUxpdk5XMmdIUFoyaTUwbjBwd1JqMmJUMERrQ1pTMHhxdm1XSWk3bk90ODMxN1lFY1U3dHNURG5abVpqbHNIVU9qY2lWc0dSbGtQcnBCbTU4a3F2cnNlMWxLdXZKYm9zUE5hbWF4bHozanlqQWxTZWNrWVpXTVYvK1ROdFBmcGtGcjE5TjI2a0YvS1gvZlZkL1ZwOWZmdDBXMlhsVFBuY29wK2xzcE5RVnpiT1c4Y2VReVJxckVpMnJ0UVdMay9VbU8vMVpZNUZXeWNhV1VkTGVuYzd0QXdlY1Z5Q1pkYlhJMlhSNjlhYnBiM3FhbFplVDluSEdCRTJ3bjF2cEFCeHpiMmEvL05IbFRENkdGc2V6Wm03SElBbklsa1pIa3ZuV0Yrc2pha3FaWkhId1R6bDZBNjBCTFBYam1nSmVmZWtBd0NBS0J1NVJReHBMczJHdDlEMGhwSThYMm1sWlgvU2NmR0lIcWNzT2V2VzJsSmZQNXJJL2ZKcko3OWZYUzNWWjJ4ZXgxejZ2RjczTEdKa3duTDRhYTcxR2c4UGpSWFN0aVNoRFJwem5oODNhcjFtUm1TbWVOcEJ5L1E5a2RoMXJ1d3p6SXpIMGJvTWlJY0ZKTHlCcTFiMXF5MDNYWEJjam9nVjFtVkZZNHhjWFRPN2tydlBrcUlXd0VNcHdmUGVXQVE0RmEzTFJaRTVsSW1SRncxUEFUQXRSa21WZ3lPcHQ2cUlmcFhNM2R2UERla2xBaXZVQXIyaUlyMnQ4bnY4VHdJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1EQnovS0h0T3RXdnZ2dm9ibnRzTHhiWUkzWTFnVUFEOXB1TDhHZEducUc3YTJHdU5DbjVmTS9SUlNVc1gwQkVYSlRXblJLbmFjb1pVRC91Q244NXFYZkxpdmszeVZkQXFkSDJoSnI1azZGWWtFajhtb1QyOXF2aU9hVmJ0RGF2VGVKK2YvMFk1V2UyelZhTGNQYWU4azJhcWlJMUZOb2JkS1Fkb0NXK3BqV2JRMnFua0UzNmhNRFMxbXRlMUpXZGZWdWI4blJ1dVdYcFRQRnd1eXhGNFViUWRzMGhjMWozMzRoeDN4NW0zTlphWTIzejVNMTc1VTZEcUczSFhlOXorUGFMV21HVVpTaVZOYUE5SlM1TU5KK0JBTUF6ZGU5YVFJOExoaGgyWFNjSHJCc29iRjJ4Tm9LODVZZGVZQ1dYY1dsci9HbWE4bmpOU1N5Y1QwWjZlbmZWbHF1TG0vZGx0N3l0TUZqTHg5RGNaNWJ5T2w3Ti84eTEzcnJVaTJCT200b3VROU1IamFkeCsvMTV1M1JqYlBORFcxclZlbTRWV3g1K3FGWDcrZ3V1YThlN3Y2clBHSlVRQ2hUNjhwTm1zYjcxOElFcmZaVDc2TUFBT2hZRmxBU3ptdmlPQnJXc2F3UWo5aTJQUFNJZDFTSFFDUjVwdFpWOU9PTnJHUnVrTXZEeXVnWlFsSXkyUzNsMFJybmE4bGoxUmxOQndBNGdCN254Rk4yUjdsYTdEc0xWbTBSMWt2TUw2TjZoS2hIbUhIdGFvMUZMR200dWt1S2FmNklkdmNLYSsvWWVhK0hmdlN1blA3N2hWU2U3Yld5L2ljdk5XWSszOXRKKzM3ZFZFWmFOL3EwbGZtclRsbkk5VTJiaEwrNUV2V2E3SkJEUlAxS1QvVmZjbjBFZGZzMFAxVXgxZGp6WG5zYVRNS3ptSk9TTFJyQk5ZaXErb2pac2ZlU0JsY1hsNmRGWlI1SXhGcUlsbVdGZXIzaGVBL1cwTEd1RjhjNWlCK0R5UHlsdEJnbG9JdW9DTFZ3aWNSM0paSTVUMTB5REl1SDB5SlRZaTdvZHcwdis3SkZta0RwTlU4ZWdSVGpMc0p4blE1OGlDeXQ0NHVwQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURBeGMvZmIxU3p2SHZYNzlWODQ5K3ZlclltV2JDMlhBRmdGdFkyYTBYSll1eW1MdTFPRFA3Z2RvOW83U1BQL3BQZ1JtaGJqM0JiQkhHYmpYcDNmQVlydUM4MExMdUswNTNGYVZwc2ZuSWhvanNiMW1tNzU0NjBMeGVYWnRUVzdaN2RrS1Y5QUl1UWE5bWRsK3lrdS9JRHZ2V1duTmxTK0RwaWV4Y1dwbDExMjlZbGU0MzFDTmFXU0dlU0JwYWtpdXhUbEZPb3Y0clRvS1RuclNiUVBFVXB1OGVRMnR6dUdFVXF6YnhFanZYYWxoMnNpMXFIbFUrdm82aUhkalpQQm1tN3NidHh4M3Zxa2FIcm5OSWNHRkhIS3pleDhkVEcwSnA1TmNUYWp4NHAraXc2bjU5SE9KNmlZMHZ3dW03anlJNmUzWjlqWmt5TmJuZlZ4N0s5NWJuUFpPVDFYbS9kdHJRd3g5YjllTXF0MDJzT3Y1UTNXcmVuYjdQd3QxV1dWczUxNEt3TXpveWt4NjFQbmF0bnVLV2ozUUNYeG5QZU8xMGp3OERyTG5tbmRYSGtiY1ZUbC9kQmV2czRLdTQ4YVlTNDFhY0p4SmJ4U0lSUmZJWUJxWHRWVDA1ckd5N3BKa0NyNUFRQXhKQXNHbTRlVzFhSFpTVkYxWTlISmJaYU1DNGRMd2djajFyUjZpaUtEN29wbzE3VDRFemNHVVRkQUNzZnhScGNVcjFTM3ZwWURrYU13N0o5QUFCT1pscDFuV1Y3QkRTYnAxUXlRakRPYVlEU2xDVlNUQ2xWNTYyOGxJZ3pJc1ZVam9oRmVEMTZzdllvSkYvV1BybTdNMXV5NUNXQjV1WDRzNjZhMTIzNjFzUDl0VTRycWZvbFhtZkY4N1NvbFZ4Mk12TnFLU1A5MkdwR1NOaHR0bU5JOUp4bFZrUk5BcS9wQXhxaFlrdTducExmbmdUWHdQS1BwT2QvaGlVTkxZQmR0L09HWTlQcjFrcnBScnAvVWFzcCtwaTV2Rkk5RUVPRTFxQVNPSVNvalNlSlplNjYrT2lOTVVITHR1b0VEMlNTSFZHVXNlbGRZcFdha0lKTnNpSUx0NFo3dmlPTmlJZGdyUnZWeC9oaUtnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNKSC96Ly84di9LN1kxdTlFLzdyMTZ2a0Y4SS8vM1dUMzdCcVA5TUY0R3hFZm1iT2pHZlBqa0ZhV29sTFRSM3ZqaFhDZGhHckxxWTd1elBIcnp5UUs4Q0RSeDk1dG5kOElIUlhjU3ZkQ3MvV01HbTdxUzA5RDA3RTdSNUtVTmwvem10bDBaMXk5V085VDhrdXZCOWQ2TjB2a05TbDFwUkpPbXZ2UVd0dnM1R0RKYmdWVnBNeFp6MXZiOTBhM3QyMURUeEMwM3Q3RnQ2ZHFrNGtHMlkwSlZ3bU41WG9lWHA5eEJBRGo4Tzd1NjAzYmJTdVRkbGxiaHVBZ3JYem9KUk80ellQYnFzVU5kdklzdDFNMjQ2VXRvNEIrNzY1elpXelprUlV5ZnIyd0dqYng0TmtWMHJwbHJRUm0yNVVHKzZOOTJtejhqKzQxV3p1TGRPVHp1T3laT1g4RERub2tkTlczZDdwNlhHUHRMeEg2NEVEOVpIWnRRM3hhUnJqOXJhaFJ4Tjg2azdIUDA0QW5vUTFmeVh4bklUekxwOHNpTGVPUFZSakMySFoyR3RXYzNtTzBGTWo0blVSVzZBdVN6b0dBSUFRQTRWbk5rOFllRFN4VkllbTFldnpyVzA0aXVBYW5PUVlmWkxsOVRuT0laSWNwUjYvbDE3Ym5QNWVXR2RiUDFmWmZlZlRlZXlwdE1wWjUxdkhHOWZYNU92YmRITGQwdjJNNkdwUDNaNlpKUUh6NDZKNFJRcTRGMWRaMHNENGV4SDE4MGQybXpmZU1kTWx4ekJ3Z282NkJaNDVReC8xWXFwSGJiR01NUU5hYWJVamxIejFlQ3pDK2JxSTNyYzVnQUk2SzRRMkhmREZWQUJ1REdUbERxQ1RBUUFBUEJ3RWJtYUN6Z1dUd1JBRGc4R1FBZ0FBQUFBQUFBQUFBQUFBQUFEQUZjQ2FCZ0FBQUFwMEF3QUFBQUJBblB6Zi8vZi9sVXozdkNwa2g2aWMwLy92LzM5emM0dmJqbXZQblVRQjhOQ3lUVEhaREhEbWJqMm54cmxkMFdybmllb1BlbDdkb1lVcEM0QU5qbm5McGdYYnpVMlZPU2QrOVlGOENlVmZvNDloR2h5SVIvY0JBcS8wdm1mSnJyYnZTWkxmazZsVWsrYjNYQ2tPZ1NWT2txSzJNSUw5UlM5TGVIcTNKeDZ4ZFgrZDNpclRxcVBudmxyU09kaHNPMGZLam15L0xKR2RkWjlZRm93Y1NaNHlteHBScDRHeUE1MUVOd0kyaDV3Z0NvdGpGMEhLQ0IrdGRkNCtIbytNT1ZYbmV2ZENIbG0yVk9QYk5uUFd5YWV2djdSUTJEeTZmVVhMbVhIL28yd2RyVXlhdjFjSjVoVERvNUNsUE5HNjdvRjA5NVlJYWJHaXBldDFJejUxRktYeXF0RFBpQXBYeXRBckkwZTRKTDNwZXBncGxxMDZ2TmM5NWFlK01pekphRld4eDlEenF2eWtYRStPTWdBQTgya3gyU1U1WTZuQ0pLU1QwdlpZaEczeHlENTVOZlJMMXBXZFVieUNYR3VjcXpHcHJkTkhLaHF2TFNBZFI5RU1TZ0RBYzJnVjRKN1lBMzF4Sjlhd0ZNUHJJWERwOXhTQ3JVNlhvSGpvODJ0K25vdmVyUVBTNUEvaHhZVnZ5MlFsdHI3clNOeU9IMXVTR3A3cEQzclZyOGUrbE5yWk14SjdSMVlVbUJFbngycy9qaGg4b0IvTkR6amFIK3AyRkpucm52RjJReUhqalJYUzlONzFnMnlVcGJtYXlTaGJLMWZLWjkwdnhFNEgzbmtKTG9OM0x2RW4xTk1BMkxRNkVuWCtsRmlGWlkzTDFuQXNSVEp4dFR5UEE0cVpwY1dNWHNZdHZwaTZnRmtHQUFBQUFBQUFNSUhqQU1hQWtRUUFBR2NGRWhvQUFBRDRCUm9SQUFBQUFBQUFBT0FaQVFBQUFBQUFBQURZQjNpZzRLcmsvL04vLy9mOWc5YjZuMnJMelRlMy9XSXEvUW00WnpzdUFHYmoyZGJIK0tWK3p5N0V0MGJiQmtKSnZtVFplemRtY0NNR2J2TDVWS1JOVFhQbTA2MWdKakNiTEN0bGdHTnAyWWx3T2lQM0VvcCtXMFF1NDF0U0psZUxjSjRXdyt6SysvcHlLbWxLWUtMSW0wSG1WZHRpZVBkRG5LR1I5eERRM3YwZHBmdE14dlVCZXlKN2Q1RDFib1hjNG91ZFdGZDZicy9iYlBmdDFSdDNaK2d6TUIrUEpyU0dvVGdmU09IU2wxSS95U01iM2pOVmdFRWdHT0VncjJ3ZmF5UEdlT204RGFpM1FiY1A3VGxqMmE0dDBSU3Y4dmZ1ODFrY1pWbDRBM1hXZFkvMHRCaFJ4bm54V3JoVy9sQVpwTkxQNklqWXJGTGxMY3JRTzRWNjF6UThiY3lPNjFZWlZucnZ0TFhLaXZaNXBLNEQ4TjVXeTF5eFhESXZjWjNoQnpZYkFIT3daRXZQM091TmQxaVIwWjQyU1hWRzhrYno3NEtrQ3hNNUh5bkxteTlxdWt0cFdteWRGb1B4Zm1ZekFHQkRxN1pvS0hwejdCVklkS0U3T1N2bnltdGRGenByTEdMUzgrdDRBU0JYejdWbytmTmFRV1doZjRyalRDWnhPKzQ2WDhLNjd1S0luZVZWdW5YWm5qQ0FSVFNrRW1Ga09JTmkyYWd3S1M2SzExbUJmWGtjRVlld3QrK1BXTkxRMm9DeDFJVVYzNWhSdGtYRU5YLzg0NDkwVnAzZWEyaGdycDJTaUxyOTVHSGVHVmtkYi81Z0Q2ZklDbkJSUnJqR1hEbVdLMGJHc1lhMUROb2FGZER5UGc3SmNVUUhyZkNvYTN3eGxZSkJCQUFBQUFBQWdFMkc0ZndNOEp3QkFBQ0F2WURXZlFwNDBnQUFBQUFBQUFBQUFBRFhZczk0RG1KSEFBQUFBQUFBQUFBQXVBN1ZGMVBmdkxjUFdQYlJldjAvMy9pTHFSeXQyNXRFOHdFZ29lMldRTEcyZURPS3B1ZHZSMW45RTlvNE9PZHQvczk1cmlySUFNQmg3YzZrSFZPZ2IxNkV2cFRxTFpNY2I3N0tLcVFEQnpCeTU4SmRpVzZQcU9XTDVaRjFvTEJqN21aM01hVU5MN2xWekpaa284MWJVUmd4ZnF5OW9iajhVdTJqYU4yVGNhOEJIRFFnMVhKU0VqOXB6U1Q5dTU3c3ByVHVXbnVnRE9CR0pUMVBXVzdmc2szZGVtaWczd0JBTHkyYm1ZYks5VzlRNzViR21DSVRnRnhpMGJ1Ri95cUNiVS9WTVYzZmhzRnhSbnBHbGsxSHp5ZHlQYko5dWxVbkxWdTZIcVhGeUlsdXlWOGNlYU5ZbGdsM2JVeU50UFRvK08weEs5WEN2THR0ZXl1MWhuczBWdVNaU2x3K1Q3cVdPcjAyZW04Yld2TjZ5bzZVTzZNdDNqWUlMdGpNN2ttazdKYTZQTU02V2lZQXdFWVMwL1I2VFdSSncyTmw5VnBmVWR0Z1NaZlNBMlJLTkVTNnBObXpVejIyVGlTb1ZxZXg3QkhLUE5NV0FIQUw4dnBQN2JNOE5JdTU2T3h4bURUQjVCRmdIbWVUdSs0cHgxclZhSVc3cjZoelJ2T1RROWRhMXZyNS9uNHhkUjJQTHFSTXFlcUlZdll0b0gzWGRWTXlLbmV5TGp0aUVyU2FIWElMZEpQQVcwZWtMUzFSeVVUU3dZUzRHRkY3RWR5RGtRNWhxL0RvWGRLNENTTkR3ZEd1NTY1SmRVaEVkRjV5dE9YbWozc09yWUZvc0F2UmNSMzFXRlpwbmZHc2o5bHYxSVZoQWtRR3hVQTVGL1RsZWpKWjZ1T0kyZUZkY2diSkw3QWdKTUxnaTZrQUFBQUFBQUNBZGc3NWNpbzhQbkFmTUpvQkFBQlE4Z0R0TU9JOWkvbkFqZ1FBQUFBQXVEcXdyZ0FBQUlDbkFlMi9IK2hyQUFBQUFBQUFBSGdpOEFiQjFmalpuSkcyQ0xnNk16YU5TODdyQUhoeC9ycCtOWndMZjU3aUhmYTNRZGltNkhOYTZKQmNwZHZzTlAvZUhMSGVTTEhlRkJFQUYvV1lyTWRwZmF6bGVUQ1JMNkpLbTlWdUU3Ny9JVEtDOWpXbStVbXg1czRwNk4wNng1UFB0dzlnRVp2RWJNdVV4RlBmTEd6ZlozSlUyTGFrejY2K1RKMHBLWlZxeDFZSldVbVgwNWh0OVFyNWw2YnZxZE1pb2l5b0FvcldzUlFqUFYrbVNTWFlsR2pYbkVBT2FDTk1vbGRDdU9nVlAxQ0NnRUhiUEM2Nlk3bDFMT1ZQd3E2Qzlia3NuRTlHSFVCQkVsemV6dlRvaGt2aEcvblVBc2lmdjhybU9yV1A2RmZ1czJKSHBaVFVyd25JOHlxbjBxUzVXdTBJendDdzZ0RGFZdVh4bnJmcTh0aDRraUsyRkRTdHd5cW5wSDdMd3NvL3oyS0o2cERrU08vZEFYMVRocU1SV1VvdStVblJLUk9SbFZGWjZtbUw1U2FVNExHbkhLOXJRdnZZYTBpMHVFdTB6dnE0VGhkOUJoNks3N0o3cWN0NS81cU5KNlhwTlEyODdRQUF6Q015NXpTUm40Vy9OYkt6M09Kb2kwU0xuTXFkMThWOHdwcGxySkRrTTRKYWRKNm5iaTJmMTRUWHpyVStXRTg1TFlNVUFEQ1JsdGpDWGhUMno3L2pKZkJJRnFNbHVWUzhRakd5aHVWMWpKSlJSekxxekVxYVVZSlVzaWJvTlE5Q1AwalAwR3BPV2ovdXYrTGVjVGthZ1A0YzVuVXhtKzdLNzZkSDRsaHNOK2l4djFKRkdPWFUyN3hsVXhJdHQyNGYvNXhiWjIyUGV2YjZvdjg2eXF2ejFqTkpTeGM1cnMrQkhiSHNaSy9kNlJXcDRGaThUcG5sTjFoMTFPVjRnOWRSb2NKZGsrcTg4SGhzMVIxMTN0WXdlMHRkcmRlNWRKeFZkV1pMK0xTMG1NODNta05ucDlYckVkTjVZMURNc1RYZlZqWStlQjR0c2ROR1YxVjZUNGsyUmF0YWFvcTFSQW45d21BNWdGeDY0RkszQy9oaUtnQUFBQUFBQUNBT25DOEFBQUFBZ0JzQjR3NEFBQUFBQUFBQUFBQUFBUEFjRUJFRkFBQUFBQUFBQUFENitXSFBsdlV2V01zZGZqYTkzRkFrb29DZmk0T2pNSGJkNG9aemRMZWUydzd2VVR2cGNsbUtmZ3pBQ3MvT3o5WjU3L1diNHQyZGlKdUxKU2dMSGlNanI4NWpIeFNuOVQxN0ptV3oxTDgvR2pxeVNHMG8xZi9yRklXa2FubDR2UTg4c2tXcXR5eXZJUkZSQ21kR0VKcms4cTZjb0J0N05sblVaNUo4SEdMazF0VUF2T0gyNkc4bE5ONkxrVmU2YnVRREhiU3EwTnZndXlFdExHbGJFZjEybEpZajcvYjZWWXU5TkpzWjlxVkhxbWtSUGU5ZXdUVDlLcHF2cEl2Zzh5djJ3dk8wdUY3SVVrR1IzVzJkK3NWdEo4KzBwMGRNdGIybjR4NkdSTTg5RFRYT3h6VGhjOTdaRnBxdVoxM0JTdWQ1bkxjekJ3QTRLWmJLbXpsZm83SkR5emRLWmtUS21TV255a3hkZndZNzRzd0NIcjg2QWVDRVhOMHFMS0hUMyt1Q2NiNVpHS2ZSSk0zdjl6b3QwcHBXNURzdDBmU1dBSmJlZnVxSlk5QmpiMWx5WDNzL2ZGdGFMYkRBTzQzYldLRy9ycGdaTVZaNXR2cVdyWkxDTS9KR0UzaU1ZQWF6SEllb0tBSDNZVy8veHhPd2k2clptK0Y5SkNPc2lKRjQxelpBQnhGREE1MTlLTzVIcGF4cGlDK3F2Sjl2cTkwSmdFbHdjSjB0Nm1GTW5mc1R0ZTBnSEZaNDFtNStOc09wU3ZFYjc3clZENjh3UU1EWnNlTEFaSDV5eXN0NnA0b1cxUnZNT3kxWk9HeTQ0VlpaZU51K0JURzBnWkRUZGdJWFo5NEhrMGZvYzZGdjBlVW5ScHNycDZaM3dOWUxuNWs1cnV1UWxnM3orK3JmOVp5emtuckpKQ20vdGpaNCtHMW52WmhLajF0S2JHK1RGUFdQbHRuU2hsWnJia1RkZzNpNDMrVU4ySlJnK2hxWFRXL0pTbXVvQVdBUWZaMm5lNGdWOWRBRmJMMEJlTi9vOGE2eVB1aGhaT2FHaTVrK0JleWhYUDMvbTYrUU1xbTlwWlUxNWdGRkgvUW9oMCt5WlZQcWYwSFQwei9hZmJkby8rUW9xN2ZPNDQyNGxwN215bWg1K202b2F4WWhFUHQxbFhXVXUyU1ZtWXl5OXh4cVoxTCtKMnBMenpCZWFKV29BSURqOEZvNlhsT2V5N09jLzFkSTErTXVSTU1jdEcwZXVEcGJ5amsxSXdUMGJEdWk1VUY3UTZZQUFLRFNJZUNXRjNnS2R6NmwwSzR5cXgrbnJncExQaUU1U2tEUGpHdGtwaXhwRFpMbXFkc3hDUElDd2l1R0ZuaEo2THYyK2w2TEplVVc5YjQrbGFiZ0JWL2JxcHJqdVVhVXRTMURHMW1SY3JSalR4NHJuVGRDYUowREo4Y2JyeHNaMGdYakdha0NvMEd6cUhDeDh0M2VLZTIvTGRlN0VrcmVsc2NiRFhYUEdFSkFJQkxJS2dueS9LS0lqMDE3blpJSWlhK052cjRNUUZnNWFPV2tkSXJCWlRWRm16cTNKN3J3QU56OHJJWVJZOVRlN3NlcHY4Q3dBRWREdlNJcjNZU3FiNGYzeGdwL1hDSjVHcXNDRHlVU21TakdNVmpSYkovQUJnQkRrUXhMcjdLM3lyYU9zMUp6WVhQMU1VOHdsZUZsenhBU1VVSGQwb1pvbWRKWTg5UmQ3TXN0US9naCtxczBYbHRZNGhvajFGS3hLbW5LRElDUFZxbGxacWpEVlJpbjkrVlJRVjVxbXhVamRiUmpiTnVQKy9wcWRqbW4wZXM5WExYc2FGMGxlRjdDKzVMcVVZNXdtN1hUKzZUb1F0cHlibGdkWjVCYnZXMlljUSt0OGRrWmRiU21uMGxEVzg0ODFFYThkQVVBdUM2akxKbElIWHRacUp3ZE1hdXVReGpSK0RQYUVkYXZwWmR6VnVnWDYwY0FQSnlBZ0hQTHJhRFFOSGRvN2dtbWVUVWI5ME5SN25vUHhUZ1hXYXNiUUtFeHM4N2l4R2hFZmUxend2V2oxS0xVUnRQT29naDFSdnBMVyszMjJHSGVjbHZUY09tOHNTVXB5Z3J6NHFKNEhqQTREM3M1akQxbFUyRWlDWmNlWVhnUit2WHNmbmxuRHkySWxnNUs0elYwK3UxNDdlMnpPa0VUdlAvMXhJN0EvYkZjVVcrZVRrcjFSNTR3QnEwbVV4L3NVZE5BQ25QYzFPN3FKZEl0UDJ3dU1ycnluVVpiYmJSTDkwV05md0J1Z0hmM25zc1BleGlKNEN4d2s2cDFmRDVVTDJXblBhSnVOTXZ0YmdMQU1EeUdaVy9aS1NWejcxaGYzVG5ReG0yTk1lL0x2eW5rc21CcGwvMzNoYThhYjN1ODI1elc1MmFoQ2ZRemViajUzWlR5SG1JSEtLS2ViUzUzeHRPMDZPc2IxbnBVQ0FSUHdFUzBjZDBycFJjVnA3MjdKVzJtRnZWL3JSZEt3R1J1S2FmNFVkaHptN0xkMUtjazVSK244cTFZY3JWZFB3cHJrR1hqMkp0djVIMUxiZkxZcnFOczJsSGx6UENYYkVRdklQUG5OeGtwRVJQZTgzS1JWR1lySTh2MHltWHYxSXEwS2FvVDloUTdCK29yeTZ0TjVQcW9iaGw5dTU0aEF6c01nSEdNMEw1Y2VOMnJJbHJyU3cxMTdDV3ZUaW1uUmdqOVVUY1dmWUI3S2dVcmxHOWRCd0FjekFVdFJldExxWnVGOEJRcHZQcTdwViswZUVacmpLUTEvYXd5dE9KSitUMjdJakpmV24wVnVWbGw1Yy96K2tlLy8yOVo2MEsrYWpnN1NrbWZOTDBteExjRjdYWFZ0Ky8xZjg4SU5TTmdYbHlVb1l1MDRIQ3VzS1RCQ1FsdjNQWG1hQmFMSjMxTFhkRTZSdWhSTUlEWkFTc3dESEZOdzNDZlBwbUo2N0traDcwRnB0QnFSM2lWeWpKK1MycityVjdMNjVXOVh2L2xnSTZZenRMRlAxcWlVclRnMDBYcGphb0FjQmFxY1l4aC9XYVNtRUxmZ2lGb0M5MFdHSVF1V3I3eVhveGpjQURhaTd1RnBEbWNwVkZIMnNubnJOdTdUbE9VL3BzL1B4R1dVdUhtM016dUtzSGpFN0hIU0lvRWtBQjRDcS81SUV3RzdRV1h5SGtBMmptSG5iRy95M25FZlQvVnBydlNQVTl1S3hrQ29xeVhEQ3JybDMzMXVacjZqY21vN1RyRDFwM3h3NDNlZEMxdE9yTlN2cEhCNEoyVm85Y2RaZ3daQU1BOE5GVm5ZWVdTUEM5NjdtL0xYbFJPbmNtT2lKUXp1ck85Z3lvYjE3a3lFVUlHNEFSY3dWTHNkUXdwWHFlMEJVM0FQU3pPTW1ob0ZUSEc4TmVmaFQ1T2FtZ0Z1bnhrN0x2MzlxUDV2VDlPdlNvNWVCNEEwTUZNSDJhMjJYRkVuUmNuR2grQTNBWGd2SmhyZUFLc09WM0dyMkVBc0F1TVAvZ3dUM3hmWUVoTVorazY4WWVwcGR4WVZDOFRPUnFWd1Z2QVlCVFplVDB3MXVpd2x0NnBTdTFWbk51SXMyN1l5SmZKNy9EWnIrN1FsOXlLV2lSRUJmZ2o4dVpGZEdlT213K3laUjdTSFpHV1kyNlhtTTJQVXhWZGp6bDZRVHk3QWc1NXNCRXZ3N3ZFNUgwZEt3ZXZjVFh6UXFKWXV6SlgxN2RwdmUzZnRzWk83elhLdmYxZzlYMFJybWtPZ2xXWFZrZDlYc095NHF5NmVwd1lPbmtxZ1Z1WU9uUGhtK2lCVm5WcUExT243bGt1UU9RWjVaRTYyTUsxb2RVekpBQXdvTk80UHVjZGVqNnR4cGZSbXE5bjJGOVlYSTNCKzJBam5YVHFEaDB4YWdyejE3cUc5VnpLNzdTRnBMTkdQaityNm5MK3Zqd3ZIN2NyalloOUZiVWpyYnFvSnRiS3RHdzFxdzFlZTBvN3R1cnkrZyt0a3RCVDlneGlkVmhQU3N4UUxkcTFzb2s5cFBYeDZ1UW1jN3Fla21oeEU2eXlLT0VIZWxKNm42L3ovbHVxOEhyVGlXbU9GMjk2dUJrQW5BY3JLaFdOckMzbk9Lc3J5citCdEI3eEs5blowclUwSVAyc01pNUZpNXRnbFZVekluYVluZWVrNjFCb0FCeElqMVQxTENSR3kzWUtCekVVSVRpYld2N2xMV3YxZnBickhOcHFoWmFlT05raFptcERiOW5CdUE5ek92L25lVVhlbC96V3FPV3ArcFBwNGxlZHE3amRrcXk4ai9PbXRKVHF1cVBQaXBaVUUvVUE5YXUrbUNnLzhzNWdYN1hZemI4VVJ4cWF0dlVwZ2dZNGtWZURoM0pPb25IS0ZsK0ZFMUNVVmhPQ0s2TWxQbnZUY2FsWld6MSsvMHhkVWdiVjVibS94NG1qbHM3a0hzaVJSZ1RveGhLaG5OMG9aUlpYWUtIckFjVWJVbGlRZERvWm5LcjVrWDMra05mYmpaZ1pvQUlkNVVZYld6OS9GOG9yMExHa3VQTnZVai9BOEFBM1pCbldzSmNDQkRyTUt6SWdXaDZLSnhvd2FuQmdrRFdEcnJzUUk5L0l2Q1QzTWxZeDk0NjAwQnJxOW1ZWk1VOHhPRjVJQ3hkV09nQ080bWpmYzhTaTN1dzZBYWpaeDdMeno4cDdqT2N6UjhBUW1ldkY4M1JmYVNxRjFEdXU2Wm9JdTBiU091ek9PT2xHdHFsMFhwOVo5eG5xY09ZL2V4VGdzUzlDQVFDNjZKRWRyZW9GL3VJT1hNR082RlZjZUpjRWdBUHBtWHd6aE1yT3dpQkg2aDU5djVHb3I1WHV4QjVFa2RzZWZWL1NuWjdXV2YyNUxpSWJ4MzdzZlBOKzdUUXlwRUxMbEY2Q1BkTkl3N3Q3QUV4Z2ovZnRScXRWUzNDbDZycjI2OFFITTBJSFhxMGI4ZGdCMkZJMmZ4aHpCWXNaNEdSWStteFAvd0hUUW9EdW1MU2NBeHUwOGZ5ejdMcTEvRGlWRDVyY2VLc1Z6NVlqU1RnR1lEYkM3Z3FzOC9RZXo2MDd0dEhyVXFEd1ZIQWRFWEhxbCt1Rk9iYnFBeUNLcEcrMGNTWElnS2RBZHlXU3ZwenFLK3lkcitoMVBHSnpqdE5CQkxjbHY4MXk2a0phaWViWDZ2WjZLdGs0eHltbzdEcisyZ3B2dS8vVEpIbzl2NjlIT3I4SWRSYmgrcExxWFJkenZkNzV0NFFHZ3VmVjlVaFpIZ0h0TlR5c2ExeTY2UDFFckRoNmYyWDc1OHMrS2tiYmhIdnlkSWUyM3EzWmVCZUFObi9vR2hiUmdXcGVxVStoNjhBZ3N2TzhwQkVpVWt6TDE4TUZSY3h4U0twUHV0NWF4MmtleHZpRzVPcXZVbGs1eTIxTGRrL01Idkl1V2JUT1FLdWNFZGVzd0t3VTBFbE12cWpUelpYQkhXdDVzbktOdTI0RnJxejZQSG1MY2YwNGFLOXA0VG91M3l1TjgwZXBMdnRKekV3ckRlUkx5WDRFcmh0SWZTNUtKRlk2aXBZNlczWEJUWlI2YjZnd084NWJYUlR0eWg2VFFISlpBQUI5ZU5WVWkzcVN3am1TVHY5WHFLTzFidTE2Y3RiVndxbGNsUlk3d2xObUNSeHorVWUxcGJYT1dmMENBTGc0VHVGQUY2RmRSUlBOVkx4bENjSWw5d2JWSXRkYllpVmNmczF6bDhyMTFoMVoxR2hSUkVVLy93bzJLT1U1eDB4ZXJiMVdaUzkvbDBUT1YzbFRObTJpcXBCRTE0WHROVmkrdEhYNmRRM1dkY3ZOcjBmTUxMd2pyUVR5U3VhR3B4MWNPZlYxbUJzSEVoVWR2Z2tKN3NwSWZ5Zzd6NEVQUGRhR0owOUp0cTZ6eXROMG9iZk9iQncvaGw2em1PdGNhOTBFRE1lS0lYN09HMmExcW40YkZ4ancyRUV6bGhKNDB4S210UEpZSWRDb3gvMG92TEh1cUUzM01EemQ4L01YeUNoL3dZZFM5M1ZPNkZrQWRpWWFtL2JrYldqQ1paUlBnNWdTbGZQN3huTjcwUUQ4RVhGY1MvQVlUQU5kZlFjV3lZM3dRWlFadldhSndxTFVpdmw0TUhTRnVLWm5ZYzVUbDdWS2UxTTB1ek42SG9CTElDaUpVdGFCckZ5bkJRQUUrSnRCejdHT3ozU1hlN2JqR1pHcmoyNGdYVXZIZDZnM1dycXRORjRmYWN4RjgwUnQrZUk4TjV2V09tODBIV2JNN2g1SjJUcjhSNVFOQUxnUGRxelFYMGEwenR1eHg0MzEyaEdqMmhoUml0WWdXOUpFcm52S0JBQ2NuTkdMR2pTUFoxSEQrMWI4Q1BZU1hMMWV5d1VpVnIxeEFPbjJNb2xrS0FHODBhRUk2OXFzOUNWNGJKMzMxSDNXMFlXM0dTNkc5YkR3SU0vSkRMVTZLaDFOVDMwUFVYZWsyd2ZSWnJtYzBhNGVRV3Y1RUNuZ2Jyam5iUW1kL3RJemFSRHZBWk9KcU8xWmVnbCtSOFVvUXdLeXcrVG45My9MajFJWGNyV2RBTDRjcGpBalRnaUFnaFJJaXlxeEVXbE9nMmNMUGc0aElrcGZhbHYva1NBVGdReDB3anpLNmg4NVdjc3FDNTdYamtpV3VXZjNCYVc0VUtaZVBFdGE5RDY5NlR4MVdpbkxxc1J2RFg5bnZsOGJYbzVMbGRkZlM5OTFUMXA2bmtiYW8wby9NZVhSK21hOWJXVTlmNXEyR0dtME9rcmpkYVp1YzNGam9QRDAvRGoxNUZqdnN5MXByQ2VRVWlDNE9tSWhETFlMbUlTbENUa3B2NXl2SlRJckVoaHh0ZnpCMllJUktmeG9xSW5EbVR5OTZqZmFqcHRRSEdkbERjN1Buc0trM0phMHRndWxISy9ZTDF1cXBaQmJabGVyOHNxTzg1SnRUVFd4dFhwZ3RkRzc2c0JOSXF2TTVDeGJ5bHNDYmJEc1JpK1IrOVJybEhUSDU2a3hTa0h6TEQwdDYvcUNhaElxbTRGcG16ZVVsMUtiWE9kMGhLWXpyUE5uUWVwajYzNG5RcnVzdFZwT1VuSnB0aHBrKzNkUDNRQ0FZNUdzQzJtZWFpTFJTaHRWQVExUks1TTkxTkdPS3FHZEdZSjRsQm05blBQbzJkYk9sa3hneHE1a3IwT0JBWEFSQmszWXdwVkxMdEF2YUM3T0t2bktwYXg0RnllMDhOZFZSelpiQ1FUc3lKQ2UxOUxRVnY2YWY1Tk5pMEx4NVBPUXYvOFVKb2EwNlk3bE9kTG5Md3lBWEVmajZzaGRJVW1MMGtJcmhxUkZWMkxNVUlXdExyWmwyeVhtT28wSUppV3RWcWVVTHhwSzBZN0JBVVFHdHpYd3dQNW9ma05LOFFrK3crNlBPcVdXcjVJU3hsNFFMcmFhRTkvVlBmRUtLVDMzNkNVOTlXaDZZZ29TVnVmWDU4RXBjVDN1eHVjSHRRNU1MS1hnVGUrd0Flb1FRMGxiMTVKbXBVVjd2TU9Ta3ZsR1JVdWs0ZmEwdTlLUDUvWEQxRkwxWEIzSUtFV3pkZ0VBdTFIRnBpSG54bEtNYTVDQW9CbE0xdW1VSWh2a0hKd014V082QUpaSHRDdkxLSW91dHM3Z1hCcktjbnJCa1RqRzdCRlJCbTl3NXFIczFnM29iM0FreHZpclg1LzVMQlFXb1lpaVY0RzRvUUUxY1JCOHVBMVF0MmRqcHFFbFRlU2JSTGFZMjZoMVFCMGJvRXNha3E2d2RJakszbDA3VWk3M0JFYWllWHV2NzRWWFdGNVFlTTRjcWxkNXZBQUFQeU5seGlqUjJ0S2VHVGJ3RFZUQ0dGbzdvdVVYSWRhQTdIblFYTm10djVZQkFCek1ySW5hSXJpaVpRcmxaU3R2TnE3WHg5R2YxK0h0bUdiOUlzV25tYTVkeFNNQ1hkNy9sR0k1UjZ0Q2F4Uno2YlJqakZhd094aDA1NkIwbnQvRHhtOXhmS2xPc0k0Qmk2WWp1TWVDTG4wWWVPQ25wRVZNdjk0WlRnQmNDRWJwN0JWMnRQVGR6ZDRvNk1QN0F2UkRuVkxQbVAwcEpObmY0RnErbFByMysraWNNZHhZOXBJSzRIa29RbTNaSmFFWVdXaldiQnhma29iMWdFei9NRjVnL2loY3pIZmdwV1Z5V2JzelBXMzhFVUdsM2I3NTQxVFN0N25xVTI3eG95akZhTmVCaDA1N2NoSElYUS9CMG9vZWFQU1hPNi9WbllRMmFPZTV0MkswbHVWMVNlOVZUKzVMcWV2elNXbXoxQWJxVFN4MWwwMEo2MVNaelUxVExmNElqK1VOUnA5SmhLaFU2TGxQcXd6djIxYkNjV0dPbzlOMXBwQzhnQUQyakRodjg4TzMyOU0vVUdxZ0FVMHoxT2RUVW9ZWVNWREkrY3hVRmpVQllMczFJTDJVYXdVUnJLQXMyUENLdXdZNlNrcHIyVk5GT1JwL3ZnZHJ4aGJqMkNxN0pIdTF3RHBPeG5sNnZTV1BkekpaRHJBbnJWUlhpeDB0Q1lzWTRpaklSZ3NxWFpMSitXRmZSSlhRN0dacmFMVVFWWWFlOGxLYTJFR2dGVHJENkxuRVhFOUt1bFpQMDZyTHV1NjFHekVFQVJnREp6dWtZNXFubGpWZWkyeTBqeVpGUkwxbDk2cFlydTdieUtjWk9uOHZPMEt6dHlndDRWcHJzclNadGdDQXUrSTJuQmRudE1TT3M2ZEM2MmNXdlFLNjlxNzcvUHd0UGVXMFdCTGVvdDh2WUxuWElybFYwU28rbHoxdHlXbjlhUndsM2FvczJoWmRjWDF6UitNOFhCbGU3SEdqaFZLTVhsdlZJRjNuV3VNbFlrWndkV29Sc3lUa0FRZWdQVGp1ZWxMU3Q3NDZBcTdOREllUkcwczA2QjN4ajA3SUNOODdxcGM4ZFVwdHNPcVF0SFFVVFhTTXRzWk9SNnZpalFTYWI5K0oxOE5TdzE1WWtlZ1ZLaGdQd010SWZWKzVqS29MeW1jejBVUmtMUW81Yi84eFUwS1RFWkp1cWEvRkhlVEhzSFR0RDNmaDllSkdxb3ltTzNmZ0RFY0JnRjQwZzdoZzJINW82QWpMMTRETkNRNGhZdXlBRGVLUFU2dHppQUZmaU5KNDdSQVdSVFJqVk0wc2U4M3ZEMVd6T0luc1RtK3pTL2E1dC9QVmZVSzRCemhycGJZRjZFSWRER2R3QmJ4Qk9zWlpHN0dJeHgxYjU4RWJCQjh1Q1I3WmtXZy92Ym96RTMwWHAyN0lTbGF6N0I2aUwwN3NVZGRSNWMwcTg0R2NYZjBHVERsM0hnQkFQL3RGRXRzb0RkZTk5OU1yUzRyejNHVzVpczQvUWxsSWd3enhOZ0JBaU5KNWJKMWZvTDlZcVY4aHRYNFNFUkdtTXpUckx5Y1ZySjIzVzZUSGEvMnlwTU40R3grS2tCdHpKcFhmMDVaWnFqMWFMc3lMbThIOU5oeDI1RE1ZSlJ6TG9EUVhZWVR2UFVvSG5pbitDdEV4RUt4clg0SlJqd2h6Qmx3VmRwMzdnQUg5eURrMDNwa0doSi9hcXNua0xjRy9IZnh2QnZmTEZPdmxTQUJtb2IydFVjT01VUnAyTGtJV2FYZ1h1NHByWU8xSTRMeXhMQVdHYVZtUUV3RE01ejBmSXh0akZFbW9KVEp0Q3dJNk9sN0ZkQ1NjTWVjbEc4Y3Q5Ky9kTXJPbHJ1d28xNjZUZmltVi9najE5M3dwbWlYQldScUZwT2JibXBPK0g5UDNTMTkxbnQvanVzN1dGL3l0UHVyWkg5RnFDMzBKUU8rSEdLM3pVNmtuVi9jWnVYM0o3dXBveXBYWTVUWjZGcVJndDRLQnRFZ3Z5eFhiZk1tdTJPWG4rZzlIZWpBQVM5WmI3NW85L01GNHVpR1RBZjIxSWtwMS9YdWN5UFZZZS9LbW5oZ2pvMGt6REFrcitoV3RtM3RyMElLeko3a3l0ZnhjdXFnTjJHTEVlYU9IV3BsajJMU28vT2tOVVRjczVuMXhsRVd2TjhRZ1JMemRFQjBXUjhsU3J6dkU1VXVkZWEzOE45SXpuaVVyeStPVU9MS2JKSTg3TWVjQkFHUHdSaDh0QzhCRDd4ejIxbDJTSHRFdGpySjcxZEpwNWRXWmRlR1JuZTRaQUhVZGRKQko1d0VBTzlBaVBFWUxqUWFLODFqNlVxcFdIcHVHRTFTdE1aYVUrUHhudzRwSE9kdE4rNVA5VEEwWlU1OWdoSGNoaGp5RFROYmV5dmZjNzNydE9pSm9EU2IrUEYyakxXSi9hWFpVTm1yeDBxODh6VGhPTUo5SHRmZUV2S1Z5VzJjajJBRjVpcXl2YTRQUk81akFmS0xQYjZTdk1tSkpJMUkzK0REQ2NvbVdZZWtLelJYMXhuQ1RzOHpING5sWWtudGd5WDR3SEs5OTFaSXZteWZXcDgvcTVZQVR3ZWw0eitBTHVxSzFDOXI3WTFTdjk4anBJODEva2E2RENuU1F5TThuRmlMMFVtOFk3M1RjN29iQXBiQldnYTMweWd0V0dOWjlGQ1VLaWI0RkxoQUZPQzBlR2RsN0hYUVE3dHpsaVQ1OXNsMUQrOXR4L3UyejVPL3E2dGJPeWNjc2ZYL0IyOVhlS01kRDZIbktNQ1BBSXpIOFlFNGNGU3N2QUNlRldyQkhXVGFZT21BTWlrOW1HVVJPbzhkclYyMStxSkxUNWdlbXByOC9jbUswMnRGN2x6bTY3bEg1SW5raDBGd2M0WWxxU3hxSTVnQndmZWc4bmoydnJaZGtrdVA2SG1ycEVLSWRNU3J0N1BKNjIxSTYwMmpCQ091bGR3QkFKeTBDWUEraE1RcW5oaHE2RE9wVkZsTEVhcVNBczE2QjNVR1lIakhFbERKZi93d3dySTRNTVp6SlZxcTdqNHZEN3FHdThlN2VRNER0ZDA2OGp1QklYK1VvTXdKanNQbFI3R21GN0tWN1FBTjRNTHV3eC9MU1o1NWh3b0dUcy9sOVN0NHZ6aDVaYzMvc1ZPb1ZXSkEvbjY3NFlYK1FTanpsZkxjT1crNXZoZ01DUUFUNjZ3eDZMT1VSZnB4YVU1VHMzUFhiREh1cEw1Y2Y0Wk1iNVhhaXNNcTJOa1gwUEVid0FEQVEycEhtVmoxZlh5ZVlOSW1menh2UktUeWZhejIyR1pISFBZdys0eTBPenc3QlpqdG5XZjIwenozUElQcTJTbkdVUWMrdnkvenNoRXUra0dwOU9kV25GS1g3TnA2cm1GNUxrNHp6clRQVis2WjhTYmFSRnBFYXhabmV1cy9CRW1veGF1Z3FMY2NlUXRJYVlnZkN2YUpCcjQ5NnI4RjkyN0Ezd0dRaTFzWkdXa21xZ2RwMDVMd1VqNHI4Y01pcmphVHJqMFVUU0piS3A5Y2YxcWxHS0lMOFhUN0hmN3FqR0dVdjZZbXR0eUZYLzVmU1dRL0dxMWhhQWxqMGVJYU5ZOVZwUmNXeWtTNEorU3kweVRXeURaYWt0aWF5bE41NWJSSFV0VjFKMHRIeC9EMi9iYUgxbE1TV1pUN2ZVTHRKZW9QRm02L0ZyY2hwam13OTBwNkVMY3VpU2U4V2Iva00zVnNQMzVXSUFBQWNRcXY0cGZOWW05ZmVlYTYxSlNvcldpMVpMdDhzdFhzSU0vWHRpTEt0enBhdTczRmZBQURnSWI4RlZhbVBVOXA4R1ZYYVJXbmpQNWVKY2tqekhLUTB2WFhRdXFRZ291WXBqQmI2aGEraWNOZktObDE5K3ZOODJjTnZoazgrNHEycGhsVm1xMDU2Q3plTjVHT0YzemlpcFlaVEdxdHU2L3ZvQ2FWdzFQR2t1aXM1VzFYenZiWHlhVGxKT1ZlU0hRS0MyVEVCci8zWU1zRHh3TTdKS0dGaUxTK014anVlT05YMDBMRm9QY1pvdDNpc0VKbzJCZHJFNllDV0lRWFJRK0E2ZmNTeUY5Z1ZqMmVpc1ptL0Fka0lld3hzTU54QXR3TFM3RXhtd0tudW9JRlZaY3VhKyszbmd0Y0JCaXJhZFBnbkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRPRG44eGY1YWZScTg1ZVpPNzhjeFl4dHZRQ3dzRDZHSUkxSDV6amQ3bTgzWmxlUDJSdEF1ZEYyTkxPeTBvME02Ykd3SlRMM1ZaNTZjMHR1MDBTSWxadGpUU3BzcGRQTVoyNFoxNzhubURUTEgyVCtaaXJJQ3I4YjU3WG03MVVIbWREdTdSYXlUaUxLUVpxZ3JVL2U4d3g2aEVKbS9wYjNWdjErQ1hVNXZUNi9hUm45bEYzUnRuK003bkM4bk5YdmUvdWxKRzJmcG04dXJVNGI3NTY2a1dQdkZxdFdIeGVtREd1OFJyZmwwbUNzdnZ6NW55eW9wU1pKMTdtcXBOcy9vV0MyZGh2VDhvWE5DTy9RQW1BU212YlIwcjZPQmRXK0djYmt4SWg0Vk9tOC9qaEt3eldIYmY0a0xMbHU1ZFhpT2QreUNudDlzYWYrL1Z6UHEzOXAvbTN0WEczZTYxWTZUb3IwR2hLZS9UNnBZU0dWNVNYU1AxRzczN0lPSWhhSDF5cEp6cnJvZVN0N2RpU2g0MUt2MlJwQ3BicWVpMkIyY3U1T0w5cVE4RXhvZXQ1ajYzbmJIN1VYaTZNc0sxMXJXelQzU0N2VDA4Y1hRSHZNa2lUMCtoTWU2QzdNeTdtNlM3VWg0QjNlSEJkOFhBQ2NEby8xRVEwcFJFV3F4eXFSMG5wa1I2UWRKWkRlWXlIZVNrNjFLb2Vlc2lPS3lyS3JMRHZDR3VpYXZTRXBPc3VzdFJReUFPQk5WS2pVK1ZJYUs0MWJOQkZOUWhhZlAwV1Y3L1hmL0pzdm94YWpTUkdOV3VmaEhHV3ZZTklFR2VjcFNHbGI2ckNzQkkzZXNWR2FMbjJxZm5YNXV3MlpCclBMKy8va2ZnWUdJNHJRZDVsY1gyS0MyOVRiOHpTU3RxMVRPcE9abHRSdGxKOXJyNjFwalN6UGlQS2FFY2xJbDVqMFdmZzdCY3NFSFZqMkl6MjJIZ1llempGNHpZZ0dsYTZtTStMUmZBQTYrZHFVbEhRNWVId3pSdDFlMU1yb21kNHRWb21sYTF0WHh4NkhkMzU3MDROZDhJakNsakplYXhyTE9pQkpSRXoxemZzclVQRmdRMlN0TWlWVFVHZk9QV1FHb0daK1dENkwxQlNJUG9ZU3ZEN1RrTGd3bW9tS0w2WUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVgrYi8vNTMvcE5sN3BzNnRXdGVIYnozOWQ5R2U5MnErYlc3ZGFhZG51QkR3UGJZY2thOHNOenpacnd1a1JPNHVjSHU2R0M1OGtDMzFlQ244ZDB4cTQ4YzVqTUl5aWJRcGIvVm1VK1p5VExwNC9kU1V3bmMyMlBkNDlSajFhYnhUZXVtYTB5VE9DWTNWOWR3SnpUQ1krcDVDbmlDbTN1KzhXNFhxTDBkNjc5YVRIcVBkc1RXbVYwWXQzcjZ0b09ZU1JmdEZEL1NYdjdZWkdGQlFTT0FoSjI0U0dwTFZsbjVUZWQ3b0xoSFVhc1ZTbWxlWldyRy9ZWjRYa2xjMFREVXRhMWpMM0NQS216dXl3dTJncDNQa1JEM3lVSVdIWnhKcm1UY0U2STIzcjlWMDhmWjJWZkZwYlBPVndSWmNxK1ZoZnJCaTdGZjllcjJOOTJnZEg2UFhvRjFORDZadVZKSlBmVzBaVWVIRDV2WFdOcWhPRTJFdmRjbysxWjBsREFrTUhnUDJ4cklpb0xPbXhRcXg4UGp1NnI2NklCV3RGQWsvSm5yNVlxNm0raDQzandUUEFOQk0rR3VkSXdYUUFnQlBRSTFRRlFVYWR6RnluWjg2emlqZnExNCt3M3JOUW50VVdid1JyVHp6T043a3ZMcmhnQlNOZVJaZjNJVmtmcmYvSVFwMW1rQ0Z2VXExVCtpMnJhRGpEbWhuZTZGVTBGTUhsc1d5OEdTT3NaY1haRzRXRWVYQWcxb08xMG9GekVKMXN2WEZWUzlCNTZzQ1lHa2JVNWV5cEl6bnJpdWdFbWdjUUpwam1icVVPaGpGQy9IN0tZZ3hMMXBvbWxXWThWeEJGY3RXaUExbFRJcGxQRWkweUNWVllQbG94amgrQnBhRHJkT0NETnJid3hWUUFBQUFBQUFCQUIwL3p2dUJ0QWdBQWVDaFFnZUFXUEhVZ0Q3enZFYXZIQUFBQUFBQUFBQUFBdUNpSXJkeXJMZ0FBQUFBQUFBQUFBSUErZnI2L1d2MEdOVDZicmQzaEpSTnRoNHVXN1V0U3dzczN3RWRrdTJCcjAwQmFicEV2YTFscE1aNTBwNlJ1dkhBRDBzYVRkQk5ENmN1cHREcE1lL0FoTWwvQkVPaTgzWHk5cExwdXFYZExESU1kMmV4UUtCaHRKUXNaUHdrYzE2d0pLeG1Nbk1MaDlnalNGRk4wSzhZc25OTkdOMytmaFV5ZXplNjhZamtlTXB1TDNsMHh5aXl1T3FXKzU2NTdpRmhCeFhuc0xYT0VCV2FOTVcrK09pKzU3alYrSWtKVjIxN3JJa0xZS3prOCtiT1Z4dHNubHpicXdabHBNWFZmMDV4c0lyOUpRTktFcmp2YjhDckRTSWNwWTJDcERHK2VXMFBzTE9IcWVrd1dJWTMxRmRNLy9pSDU5QlpKYVdpN2FkMnQyM3hHYlNJdGpkZWVqcFRydGFjdDNOSXdiVzFZcnlYaHRTZTk2Vk9TbjAvUW1obTVwYkFRMjl5MHRGSUsvK1NzampScFRVT0tLZEE2UDIzU3VwVGF0TDJ5TDFLWE5ZenJkRnpaUFhZakZPZFF1TWRhSDJ1UHlpdHRQZExaTTVUaWtRaGRDZ01BOXNHS2RMYVdWOC83MXMzRXZYSXJKVmtWZWhsaG9XcnRQWTFjRzlrUTZjWmE3WkFXdXlyYXVWNFRselBSazVHbnpodXBpekxRakFiZ0h2UTRKNk1rc1BFeVdHWUNsYlV6S1o1UDIvUGlGMUdMM2pTdVhiOFgxUUNzcGYwc2dhUnBicXV1Q0xNMWFVUWhKWkxtM2JiNlJTSk5COUpuOEhuczYrZWVQK25vV3EyOXh2eE5zVVFZb3g3aDlwclh4dW1aclRXUmlCck40eDNOSTlTdFprWndiZkg0NzFaWjRFQmFCN1psNDlacDhLREhJd2tMU2svUUxBWEx0T0t3M25GZ09jVEExUEJlZHpCQ1ZGUkU2dkhxbmNmU1k0QkVZd3lZWTlQd1BzYU42R1JjTW5hOXo3R09ac2tLcnl3QkQ2TFhqcERTNWZSOXIrcDlyWDQxbW91N2U4T1czdlBTdFVlTWU4dU9oR0oyb1kwdGZERVZBQUFBQUFDQUljRDdtQS82R0FBQXpneWtOQUJYQkRNWEFBRE9DS1F6QUFBQUFBQUFGd05HdkFOMEVnQUFBQUFBQUFBQUlBR3ZHVnlWL04vLzgvOCtQMXo5M2FHcjNvVzgzalgvNTc4dStodFdiVmRQNlJpQTJWaTdJd1N6YTBVRmk3NEdubm50ek1ydHJBS0FDMmtYREl5bFlSUmxVMXJ0dkZoZUF2MU0zQzluMXdjVTNlNW1TV01kYTJWNDk5dlM2eWpNSHJwTE9yckpjaWE3OUJaenN2UmJEVDJQOGMvMzRFcXlsTHhsL1hqdXE5VWg4UGFaNS9uU3RKNXlyVG9DaktpcXBhdFA2SXRaRzExNVpyWDJkSXVuRENndGNESmFOS0xieDNLS3J4N1JBWlA5alNhWXVQTmFQcURpc1VLaW0vUVdvWTV2T21MN2hXZkpYbmFITmVoNnRpQ045S28xOEZQeTIzaXBvUzJXSCtYMUY2eDhTVW52dFpldCsreEg4di9YL2s5ZS9saXZZYnpXTkZLVmpyUXc2M1VNb1hWWXo2QzF6dDVwN2NsN1JIK2NFR2tHdGVpS1dUWU9hOXNsdm02djFBWUFISTlYODdlV3krR1ZVNjNXaGtkZUphTk95S21LMWpqZFNQZEFVbzR6RkU5cnlEK1J1c2FZeEFBQUY2MkNxcVdldXNyYTZjeHREcVcxNEwyZ2xaMDNmeVJkV0VZRkZGZVd0YW9SSlZMTzZIaVZZbkdZejVXVWJRVWI4anI5RXRNbzJsaGluMjlWcDdQdjI5VnllN3pIRTdYVDhuclRSYWpiNHZHdGUwYWFOMnFYZ3VuQVpGb0RIblVhRFR6b2M5RXVIT094M3hIcXR5ZmRBK2pRK0dJYWo2N2d5aHpsaW5KbEFvT293UUYyb1hVdVNlazg2eWIweTZubXU4Wk1lUUNvdE5vUjNxQTNNMzY5dXFKbmFmYXhZNzlYVUVGb2lPQ0xxUXNZSkFCY0g4eGpBQUFBandWSzhKN2d1UUlBcmdHazFjM0JBMzRJVDN2UUdOZ0FnR3NBYVFVQUFBQUFBQUFBQU14bFQ5OGJmdjVEd0lNRzRISmcyZ0lBQURnVDBFdmdhdnk4OXVYS2Y3dHlMVHR6TFY4cldvNHVCZjBwdU5UOCtpZmdMVHZoQUdDaDdWTFV1SVdPdFdOQnozQnUzZERoY0l3NWJuMWgwZk8xaE5aTkw4SE5pRzVMNWQxRkQyUExSSnAvUlhvbVpmVVBtOFM3KzlMenNBYjZtYlZGWkh0QVN4RjdhYkdUclMwM09TTTFWNm01dHBmVnRlV3JRaC9iUGx2UHN5NnJGWDVzUkw3Y1ZaSXhxY1U2cFRaRXI5TzBubjNYTENPdVphL0cxdWRndE1XMVMyQjFmOFZURlRXc1Vwd1RpaFB2elBaMGtmYTMyZ2E2VTE5RWRBQXdrT0k0VjhqSnN1emdwL2hZZnduV0JVYTBRSjFXMnlWUUsrT1JSRXk4VnZNSXJLRGpVK3BpTGQ3anR5SjZJcmxSaFJLMWVhUzZtclNra3Q1YmhuUy9VbURabWhEY2s3YWVjTlQzaXZZUHJhZWx6cVNVWmQxbmNDUUtPdU9mdlBnNDFmWHlsMkdKMTVVR3M1ZHRncVczMkV3cGhrZkpXWG1zZkszVHMwZFpScWZldzVHOGZrMGRTL1JJWTZzOHI2Um9xVE1uREFjQVp1SjB3WnJtczZieFIxcG4zdlRhdWRabzNlMW9NZFhydk5hQXFQTzFEREx2d1BFcXhjaEF0aHd4ci9rTUFOaVJ2YVIzWWYvOE8yNXN3K1pMbXNMNXpBa3l5ekcwMXNPU2NEMHArYVJZU1hMazFmSkpNUmVPV2MrYktiZFlTcEE4cDAwd29ueXorV3I4bFBkWEV4ZmNvR1V1c2IrOFRWcjlWVWpmV3VtL2xlVFZFWWNuWXVURkcxbmFURUhodWpSek9KWGY2cE42WnhiTWlJdmdIZERXWUt6VEpDRXZtSWQzUW51ZnE1WlhVQTFxK3VSSTc2a3JWZWR2U05UMXRNNFhSeDNGS0VQQ3FpczcyaEMxMElCQXhGeVd6cUhUaCtNTjN5eTB6T1BQL0NYcmhKdjNyREpmaCtXNWVGUThlQmlXN1BBT0xxdGM1WkpuamxqbDBGaSsxYnpid0JrYW1zTHVzUnNmZ05ZZCtHSXFBQUFBQUFBQWx3VWhrUDFCbndNQUFBQUFqQUYyMVh6UXh3QUFBQUNZQzZ3TkFBQUFBQUFBQUFBQUFBQUFBQUNBNS9Meis3Ky8zUUx5NmdNNXIwV2svNXdvVi90TW9MWDZKVy80cGFjRndJdjI2M25yVi9QR21NdnYvMFdtcFhlM3VNc09kK2N1VTNUanlVeitxUHVVZmlFVlgwc0ZMN0p4VEduWmtRME1JYkpESmFCNFh5TWErTHBSK0dITTNKZksydDdJTTRxMFBKNDZkVU9pdHMwM08zMEpXcDUrT2ZWYlJxVHpwWDFxdDZuWU5xUUkydDY0MmhhVWhqRWcxdVBKYTIxejZyV3dXaVNSZDVzdG8yMnUzYmVjYmZvVTNTQk5MeWlBSlhQVFMwdStFaG0rM0RFQWpkRHh2cEZBMHRhVWVYMVlsOFdtWnhKNDVvcTBnMTk5N3RHMDd0VG9LVE1uZExBRHJ3WHhkKzAvdGwwcVloZVAyRkcyL2lKQ1NkcCttTWtveld0bmVRWVgzYy9XeTR3QmFObm8wVUN6SnBta1NXVDFwZGVTMEo1alV0ckVIU2ZqK3ZzK1MzVk9OTjM1QUIzMVVhUnUySXp6S281WDc0Q3N4ZlUyWlpadFdVb1QrckFVbFdmS3RMb21VdjZyYzFOOXhEMW1UbXJQdW5VOUVxR250U1RwVWtaRXh3RUE0a2lXWG1zWlhKbTFwUk9NU3JubG1DV1BOTm1TakxadzVkWEhQWFdjR3M5RGlKcXEzckk5Z3lvSjdVa3Axdmt6WFJFTFNXa0NBSFprRDRrOXFJNGlCRVUzamkyVDVpOWgycmJKOHZPOXpxbDA3Q0VhWTlIaUo2MTk3VlFzMGxkUE4xbEltOW5QTVVuSHE0TDR3TVg3WEtsZlp1SmlLYWFTMCsrYml3bis5YkQ4bkswUllyWE04L1NvamVjMUkvUjRxNStXdEplM0M1OUdxeWlSSGpoc3ZYTmlxVUNham5La0h5SFZaVkdDNlM5QU5GWWdQV1pqUldPVHB5UmJ2M2l0S3ltZlZKY1Yvd0JCV2pzWG5YNHBOckxBRWc3TCtsOTJKZnVBNGZCQVJvVVVvb01wYjVzd1V5eHh6WnRkNXlrWVlVaHc2YUZETmppK21JcmVBZ0FBQUFBQUFKd0IrQ1lBQUFEQVlVQU5UK2VZTHNhRDNRLzBOUURBRHlRR0FBQUFBQUFBQUp3SmVHbG5CazhIc0dCZ0FBQUFBQUFBQU1BdS9LeU9TdjJqNE8vdVhQbUtYcHBuWjVnOWRyRUJ6MlBDdG1wME9JL1luN0JuSTZqZGlleEtSVGM3VEEzVlFUYUFIazQ1aVU2RVF6OWJjMURjeEpUTWU2L2NBeHpXZGk0ZVE0c21wenZHa2pUdXVlUFpwNjUxTzVxV0hXZXRPaXlORzJQOUJYQitQOXZpM3BzdnNxZmZ0azlMOWYrOEtadld5TzNLdTAyMXJzK2F4WjZ4NE1YYVBpOWFqdFNXbHJJajQxRTdUN2VFSTVmbzFKRjJnOWFxTUtxOEt0N1oybnE3bkVRdHNDZkFRV3gxeWpiQlNsSXk0dm9qU3ZLNjBNMEh1NDF4SHRuTTFHejNVd2pzdUxnNmhxeHBobzdKV0pjVzVjaHJQK21QdFF5ekk3ejVhRTl3K2M1Z1NGZzJYMHN3dWRmdXQrcU1UbkJxM0xFV2gzRnMxTFVaZkZsSVc0MUV5ZUVYaWl5QzZicE94T2V4a0Q1cUVvYXpxK3RqS2EyRk5FeTkwL2NJR2I5SG5UZlZXWlpVOG5yNVBmVkgwOEo4QU9CY2FQUFlzdFMwNkJVWE1vcFlHVlk3aTNGZU95ZXBQcTJNYUIyM0lxSm9MTVVVS1p1V3F4M1hnMHZLNjNWSkVwTmVHcmhTZXF2c1pOU3B0YVZYZVFNQUNGRUpMZ2dWMVVIczFCSlMyWnRnNm5KY1hkOThoWk5MYUozejV2WGs4U2dWU1hCN0lyeGV4ZVRWL2tLZmMvZi9xcW9rTTBpd3VTM2h2c1E0eURxQ3g2ZEpyaVo4WTRoOHRoSjR6a2VFSWxyTkNLbE9xbTViSW1hSnljUFZKYVZManV2ZXVzQUJlRzA1UEtSelVSclB6MXpTaUFqSkhuVitZVFFOWDR4OEtkbHhBcHJlZTE0clUzcXMwdlZJbVY3WEVpak1HQVJnQ2oxZG56ZC82QW05cTZLWWN3OG1HaHUxN0FpYXJpNDZ4L3lsWGpUejQvRmpmZzlENG9abzQ5Znh4VlFBQURnNXNBUUJBQUI4ZUpwU2dCSUVBQUFBQUFBZ0R2eUdaOVFOQUFBQUFBQUFBQUNBc1J6aDV5TzJBQUFBQUFBQUFBQUFBSEJXVmw5TS9kdTd2UDc1ZG1IT1g1QTlmMW9Pd0M5MHlyUnVsMGJJVlo1WncvcnkwOFhvNitKTkQ0REZpTzBmbjhoaVhsUXk4bmVqMEJ3d003enptS2tLaExFRzlJamVYUVQwNkNjMXVqeE53WGlVZm04OWRLN0U3NitVRVFiSk55MDN4NlN2Y3NWYTYyMlBkMy9hRVhVUE11WU9wYUd0dlorUnY2aE90SGE1OU9aenBXVjBJZ0JIWXUySXQ0a1lLVHNGbXVPNVk3eDdONjU3SEpacTdER1AwTWtxMW03R1dwNmVGT055elNoMW5sMDhueVBxOWs1WUxkMG9tOVhTQmx5V29HTXZWQ2w5TmI1V04xRWRZSDdrcFBkeGR6V3U4WnFITXd4am9FSjlhbTBvV2N6MGhsdlQ5ZVlCQUd5cFpRWTl2NkJaQnRFbERVcytSZVNYNWFxTWxCTm5MZXRTbkcwUk9tSm1sc1kwTFovS2lacS9XTFFDNEVTMEJqUjNnbXNIS3pzc0xXNVdGRXhmNStrcEk4cW9lSWRVUmw0ZnV2TXA1MVYvbjhSUXZFdlFRdklXdTBxdThyeUt5ckpsdmEyV2ZQRWNxS3VGeDlxVlJ6SXJ0Z1piN2hwY2ZVbkRFd0M0QVRNMWZGMk8xSlVqcC9NZThkazlySzdiWWdYUFdnMEwwTXlJRU5ITHJGYktYa3h1Nzl3QzRFUHZJbDMySjEwVTBuazlNYkFCdWtMazV6dVU2eVVqYmlucFluaWlBdGx4M1NvREFBcWRTdHJpbG5Oc1JWNXNqSEs1WWU0VlN3TnY3UFhwOU5MZUZBQUFnVnRBSWVzdnErVDVtMlpBVmV4MXpHV0sxNUE2dUFsbTV0YjBVYzJydVlaanRQZ3kvdi9taXQ3ZTc1d3A3NnY1WFhOTDNicTJ5K0VIWmFXZk9SdWxTS0prckxYMmwxUm1mVDBGNnZhVzZia3ZMKytJQnkyalZ5QkQyTDdnZ2t4aVFCU0tDcHdJVHZ1VTZzSm11RTRZdHdlNGc4OEQ4bHFBSDFYV2I0REh4bThXbTI0NXRrdlByMVNSNEdmdmNSS09sN1FqN1N2TGx0UGEwc3VlVXNieWJTSUJTTXZ2c2ZwYWFzTEtXV0dUWktvc0dwRGljNUg4djdqTDRMcEQ2K29lRXg0OEZ0RysycGtlKzJwUFhRakFrK0ZXOGV2elNiaWVVbncrWnVGY1VkTHNJYiswRjgwOCtUb2paWkJuUFVRZWdtZXcxV1dOZXNDZTZ6MlR5SE1OQUhBZVd0WkNxRDlzNVJWREtrVk9PMHdqdFFyUE92MC96TG02Yk85eGhGNmhMNjNSY1JiVWtrVllMM05YU1JkL1NBeWxHSFd1bXFiM25YZDFYNzd1Nkk4SldLTjZobTg1YWxSNjgwWGFEbFBoNU9BQlhZOHpMV2w0OFFRQUhqb1dXMjliNnNxSXhwT3NDQ3Y5VEZjVk9PRG04YjZtRGhpQUZoUFVSS1czWEtvaUFQZ3d3eG1wWVFaeWJ4aHlWbE52eGFqUUN2aXdkT25QZDBndXA4NnlGTzZrUnlPVXp1c0FjTlJUWnRJWUdqa3JUelhNdGZma2F2RWtpYXU2cUlFM0pwVUZFUUhBT0Y3VFdacHJub0NnQUZUOUxJS0dWMGh4TFF0eVVsZ2hlajZsOW1VaHFuZ2tla0lUeFpYa28vcXFoZTNmSDU3UzQwVFM5T043Y1A2NVZCcXZ6V0JHVzByd3VLVU1JLzBpTkxNekN6dDF2QUw1WGhUai9Nd2daQWxmQUdBdXhYa3VjajFLajkvN21LblRLcUQyRUd5M1k3Uk5GQy9MMm1TRW43ZlJtZHRyeSt4cDYxMWxwaHNCTERWZmplZHQrZGJuMTlDKytrZW9uMStNWnZjUUtXUnhiVlV1ZitYdDcrd291RHpLMERJZ0kyV0RSM1BFa09EQzdhM2xhR0I5RjRBeGVGZnhSMnRLVGRWWmJZbVU1MjJMVm1lcld2YldEWFppcEFzU3FiTkhLY0xIQmdEOG91M0N2RnhmSFJ2WGFkckk4dWl4cXhwR0cyYSs1T2ZOenduOTJldGl4VjkyZlQ2dzVsdVl2OTZGVkZlMDJJcmpSU3gzRytibThaUXpZdlJiWldnanlsc3V6SWlMUXFkSzM5UUJNN25pa29ZVkFIandXT3UxSWdLdkhyUDVVNUl0bStRODM4TG9vZmg0SkxzYW5KNW1rVTRtTU93djRLWjEwSG1XNUoxQi9iMjgrMGZOQjhSK2g3TjAwYy82bDlWL1I3bnlsT3Z6QUFBblVyUkppKytsdEJWZVJhOGlLY2tjUlZ5TGJCeEhpMW1NVERnVllCYTNtNFR6eUtTdjNKdlFhbjJjTWIvSE1OQUd6SllTdEtnWEJyUGovR2htditZbHNGcDczUDRJbGY0NHRTYUx5dE83Sk9hYlJQT21tcjhOY243dC9JaXk5eFEwVnAzT05rV0dzWGNuNkp2cFBHc3h3YnZZTUtWeUFDYnptYzZWYnhxVnhodjNsZ1Q0WGI5ZWVLZnIxUVNQSTJwdVBTN0NQSStZbGFWL3hYU0dXdDNXS2RtMlkydjEyNTA5ZFk5c2UwT0F6b1gwRnNseXpYUGVneFV0YkNtSGdmdENxdmlWRDVvMzZWVks3MlJXZnQrdi84TitRR2F6cHFIVDhnR2NiK1lrMzI4eDhxVzBzNEhwYkFNNGpJbFRSN3hlcW4rdEYyaWpwa0lXem1ISUFkQlBiM1ExS2pNc1ZkZGo0WGprbkRjQzNHdDFRalVHR0tXZ2FOb1d1NHBMWDllcHRaVXIyNk1VYVYwQWdFNk9YR2RKYytybWZweHFPWi9jOWJxTVVqbTZuUHhabmZjNm5kYjVDSHNJeFpsanhhbHdwUFd5NkpkeVAyWFI1MTA5NTlWNVIzRkwxZWIxclVXMXRiZHlVMTNHYXhzYldrSW45THFWUDRKa1JyUkVDbUZHWEpDb2lLRlRTWE5Xd0R5aS9zTElNbnZyOWdxVHlQbUxNN3BMSll1UHVuMDlqSEo3YTZUMkorTThDR0FGc3RESjNYVFBaOEY5c3Nya3pHaXZMWWZIRHR5ME9FVEpjQnZKZUYybDQ4cFNya1dCS2Z1bU5RNE5ObDMzd3lWNnhjcUVEQUFBSjlLaUZvYzNIZWdHWFF1YXNSeFF6T1Bkb1I5TGdiMTNjcnJueEtKWXMvUDhDR2k1QjFqR00yK3ZnZGE3aDBqY0FVc1BjUTZlOWNKVmRBR3VOODBKbURYVnJLNEc0RkpRdlJSWkJmQ1dINzhFd0dPNWtScnVaRS9EK1FnRGZXS2Qwb3FzK1BaRHRsK01sZXFRam8weTZoOVhheDhVMmUycGpIYU1vT0RBamtUZFBzUUJBSGdPVmlUVS9DMU0yaWVVWkxXcHB6emdKS284U2tOWnZiRUV5NmFsNUVEWjFua0FnSk1qSnBHenppNEhNMnB4RTdLV3B3anB2VzBKWmI0eERURVc2NUc0OVUzKy9ydjZJYk5qNVNoYUY4bkd4YzU2MWEwM1Q4OXlRcXNQbTVVMkFEQ1VrNzNQOFJobW1CR2pITnBvMnlSbjI1UHVKb3h5L3lROFA3ekJOQWJnSkJUWHFRMHJhN3JSYmdaZ0Z0NVllRXVjUFZvdUJhWnNpdHVBMFowbEhzVFA3d3NkbWRuUi9EWEkzcVB0MVAzVTB6aEhYQWVBTGlUaFk2V1hYckFpU2JYalM2TDFsNlZ4aGJ4aWwyTHVnMTZNK1FvYWFOSHBaZjNuWjBQUklsZUJSM1lBUlRtNStZeWE1UXFOT0MrMGhaM1k5Sm94eU15eTZYbU5la3NrdWM3bDY2bkxsMU0veCsvODlJdGMyL00rZ1ZZQ1o5dlRlZkxROWthOVBzdVE4SVlEZXJFa2tuU2Z4blhQcDUrMEg2Y3VmNVM2YkpxZjFIMFR3V3BKa3RiYmxMcTZjSWxnWDRDelVFMkllbmdXT3FBZEN3TkhER2RwS3QxbWlubHZ3SFBEcXdlY0lIOTJvRFRaWERhWi9GVlltOWFxMVJvMDF1eXF5N1BLcU5OcWVNdWg1endEWHpvZm1UeGMzVndhU3pwNmZKZmFtcEI4bG9DZklkclQ5SmdyNHYwQzVXL2Fqek8rNUM1VlRabjQ3ZXYybFRyZDZ6Z3JWZWEzci9QMWQ3aGV6VVkzaUIrdnFRdUprcDNYOTVDeDBicGdmeDZHVnozWC8vYmFXUkVKRVUzdlRZdWhCa0FmOVJ6aTFnbnJOSlo2S281ekVRdGx0TXp3VUZ0SEkrcUVuQXJTNmo1RTY1ajlVRHdEZldaK0FNQUFKZ2dMVWJZdC9uQmRkL3F1NVpudXY3Q0drNk1hS3lueTV3eU9uclhpRW1IR2ZWUnJhbXp4MXBxakZGTVIrcDc3K3VubW5EV09QZkU0N3J5V3g4ZUlkVExPZG8yc2t2YldxZG1OVnFSUU92YmF5dHA1bUJFbklETElMTHRYU284SHZUOWVYeVVaNldqYVh0OUdPN2JxOERqQUQ2UFYzNmRkNmRFVk5HMGtGdUhWQmRrNC8xaWtqdkU4ZUs4eXg5eTZOc1FsVzVBZVB4NDM2TWJyTG1yMnhxS1lxclNjenBERVZNU1VzZDRrZU95YzhIYUlWKy9BVnZ2OVltcXU0bDNyRWIvckx1TUFYQkZKaUVqZWk2YzhCU3N3ZHpzYWJ0anlKUURvQm9QcXRIakVMaDdmQVhnTWNuQXdQcS9vY1hiSTNkQWliSzF2TThOWkRJTTVCSzdLSjloWnYzZTEwN3RlSTh2Q0hBUjNRaDduVDRsNFB6V3lMOTEzdlN5MWc3UXJWVjE1eitldzNGK1c1NEJ4KzJWRzk1eko3NDIyQmNvUkVGcmRRK25ZZXcwQTRPT3JDZmVsVEw3ZXd4NitKSGdUdFNOR2RXaVBpVnNjNTNyYmlWZ3BBQ2ZnU0tlcnMrN1BpM2tSdjE1N1VhbXBFVlhkVWgxMzFKSjUzRzFGZjlnMlVHZWM0Y21NK0YySWxUNEtuVkV6MUhTMFhKZ0tBT3pJeUlYQ2VyS1A4RTIwSDYzQUtRM1Jxa3ZRNVJmbmlNQVljSFBFbk1Kdm5jQnBvZktLT2lkSEJmdkJIMTVESXJxWnlJT2dYZkFqWC9xKzRKSHpCVWM4SGphWVRmMHlyclNGRGlXeVJZRUFzMG5DNnZoMmNEY3NVTkkzSGZYaEFkZ05ERDZlOWQ0WDYwdWtyN3htUnhicWVWN1hLNTI3ZTEza2VpMllWOXRUL1o2MnRnNmFnUlYybE5yQWFWcnZ0cGZGcUVzcmhpZzFJenhxZlRuMW01TnJvMi9tT0o3NjZwejAxZFlZTkxvZjdWUHYyTnBEZW5qNlhESitPSCt0emlha282ZGRBWTN5TFhNMWo4bDFxWTZiTUZ3cWFmM1R1dHNXQUoxSTQxd2I5NXVQQWxnTUhNL1I5ZDdIVFNYTDFOSFMwU0FEQ0hHK0xsdnNRS2x0alRhcVdRNHQweHBzWE4xV1c3ejJsQWZMem1xMTZWdUNncEU2cExTTmRWRTdVdXkrVXYyVFNkN3F1c0xIVjFtT1V3dFduZmxkMXp2RkdXVmFqNEtDbkw0Y0VVblo2LzNPc0gwOFpnUlh0emNmQUdDTlIwZTJSaVdsY29JUktCZVdEUERJQ0U1R0prZStFZHhTM1o3ZFFiWWVlTFQ5SSsrM3pXZ0ZBSWpNRkVnekpEanhRWXRRVjArMW0zVWJ4ZTh0MVI5MFVYMWpTRVRYWXBlR0ZPRll5N3NudmQ2RzV4NmluazIxcnFZbXEySXI0bk1Tc09JMWp1YzkyOGJoWnZmZWRXWWx6UXk4TnJlVkgrYkdnVmdoWUlybU1PRkJ6a2RSa1dwNmIxcE56R2NoblhjTVdXWExvZTdiWXNWR1c4cUxwT21KZDR6VWJWNWQ4RmlkNFZrbWl3SjVmUnBHelNuVnZMYmNKdkFzb3JaQm5iWmxjWTc2KzJUZ2ZWN05GSXFzaTBtT2RCRXdGd2k1OHpxb2Y1Z3FjOHFYTndBNG1zVVR5c0w1SGF2ZW9jclRnbjRBdytIbWRUUS8yQ0xKekFhaUw5amNuNEdkRzZvekJkcFNIVi95Z1IyZ1lVNnUxS1FSVjR4ak1HR3VlaGZKdER5dDZmQ0FWeUJnQTRCQTZicmNuTFlsUFFCWG9BVE9ZdzdzeFpIYWY4ZTZuWU5zNVJYdTdpQjgrNE91YVp4cWphUDNoV1VBbkhEcjNiT0dFT0lCQUZ5ZmtWRXJ6ODlldkdWRThuakttWlhuOUp6NXBxUkE4MW5XNm5vSEg0S0ZBQkJtQ3FROXl4NnNtVFpmVGhYU3NrdXhrV2lSZHI0M3JhZWNNd2pGa1ZZUFUvVHFXS21MKzFGVHZTdmtEa3VLb3psN2ZITGlrd2QzUkJvd2VEbnhXR1l1RkxhK0c5R2F6MXQyZHVTN3FIQWJQWlU4M1lIcEM4QzU2VjAreTlLRmxHQUlnaitPY0FxY2JpRTRHRWxXZUI4U1pNemZEMU9scjExOC9haUx1K2FTUXlpOXhJMVpEcnhZdjh0cExhK3MvbUdUS0QvNUVmT2VCdWxYWmNFZlV0U2JVT1QzZ2ZXeHNPV1BSZVpoMm9NVnEwSGx6R01OSWd5eUwvVnZFNnYrb0Y4eE9lSmwwZXMvcHIzc3RPaitjdFh4cHBPTGtZK2lhVVVyendpdFNSZUN2ZTNQUnB1S1htVkpwcDdNWkVma1FpWlJNU1BrWEJzTGFjUTIxNStvdE81amZkNzNCVlZhWnpTU0wvVjVjWlJoR1hGUmFhSDFyZFVXNmRpWnp6dGQyYW0xYk1kVnR1ZnJ1bTZxMnlLbUtaZnhOVGZ5OXZ5blVNOVFYSklUSFFuQVhrUzBibjZQNjhLZFQvN3hPOUlldTcwSmJwa2RyZkVJajVvQ0w2aXU4SFQ5b0ZEUjhQUjZhbHFhVldxZFhyUFJ0TUhtYll0MnAxSDdxWFh5YUg1RjFLWnRRWHFEbjE2UDJlemhBTjBtYjFGK2hNTDdGckxmS0xOZDB3aGJiL3NUR2NiZ2RuaTh3NktrVGFsdFNZdkxBM3NMZ1BOaHpmL2xHcWZwZSt1azUzcmRpdGE4dlhqcmh2dzZBSzNUclRlR28vNXZpM1BXcXh3OXl4UVhNRlVCdUNlanBQNUFvYUg1Zzh1NlRCWVhiOVo1bDB5Zk1qVkxZaS8yMExRanltNzBsSm9XYllwUlZWa3ZMTlZyZEtvT2tRWlQzbFJYWDJXYllKWjlISmJLOTFMNzFhMTMxUkxXOGRxbVVqNllFRHNRRGFvcy85YUJIZTY0L2hjY1Q0di9JSzMzOTdiQlcvY0l3ZlVRUnNReHZMUzRvSFhhaU1peDZzS3dVQmc5ZjRHYjhGdDNqa25rS1pNVG1kYWMwVlk2d2MySnZrb2c0WFZXT0x0UlNCc05oYlo0cHRKYkRKY2UrNzNHd0I1R3hBTjQvVEQxTDE2eTdkVnlCNnNXRHgzc0FUZFZPRUZsQ2E2bkc4RkJrYlBwNHJ3dWloWk5rckRwd01OcE5UQTBNTWhZbGhkSTgwbjBOQjdUQkhxOElCYkRLeHZLaVd4Z1FTNzkvaGoxOXdlb2VjZ2tzdS9YZWdkb2xMOStMRGR4SENMUkFtL2t6cE1lZktEVDh2T2pDU3Q2eElBdUI5UFJBcVRXSXF5V1Rqcy9Kdmx1WlFGd05jNHgvbWM0MTVRYnhLMm40T2g3YTZYVldqeFQ2M2EyUVVMSnhuOEJkYW5ySW1NQkN1clIwSkc2aDZRY0FZWXRBTmRpZEtRd0tnT09EQ1hkSXo1NVV5SnYzbkxYSjhZaW12Tm8rYk54dk9TQk93UEFEb3lRK2tkb3Q2cU9rTnNiV1NEaXNQejZsbkpiQmZOSmhlU294eSt0d1EwSXJTU20yRGJ5Z0RMNktaM25zMUYyejBpRE9nZmdRbmgrV0RKYTVYdGZYdVhhc3Z4TEJjM05CVTlybDdjK3VwbXVHblFFZUNxZU1NL3EyREZoUFhONkpjWjczU0lBWm5QQzVlM0xUNWNldTIzMHkyb1BsajAvMjhqRzh1THNkLytBZk9ZZW9ncWtSNkVjR1VrQjE2VlUvMW9MVFNWMjNkbzBnY3QyQ1htbTdRQVZuSWQ1ODRkY2RMak1CTEh3U0x3L0dwSG1Nd2FORys2SE83OVlEdWMvU3JySSt3bjM0MFRhZ0g0UzkzVll2c2V2USs4K1BsbjRtMHV2S1JqdFdOSzQyYWpMODBhTlpSd2tvVzNWdVZkVjVkdXZlYkhadlJGcmo4Q1N2S0tpbWpyZkVqTkpMZUdaa1phMTQ4MGZvWGZPU0dNbEhCNFRyaXRsV2ZxcGgwM1p6MUp5MGJ2VnBtU1dObERKcTMrMmRjS3VBRHV4a2J4RlNGTzJZNzNaTEY3R2Y1SFRVd2xwU1V5anF2dE5LYSs1VVJ6WElXOWNTRjNlZy9XNGlwalB0cjlhNTh5WVdVTnR1ZEZ2Y1hEbld1L1llcFV0TzlOWjV6UXMyejFTN3RJUHJYMHUyWjNabiszdEJ5N2pjL0ZkNkRwRGtRZTRrSTd4bDFackd1c20xSG1sbUVQb1l5ZlNFT01VVmtxUXJRK0hreUJhTktJb2VhMDZwR01QMHZDVnlodXBBd0VBWDNxV3RTUFJSaTY5Wk1uTVVHTlNXeldyS3hyemI3R2V3R0JHMjBKYVlGcXFzNmNObzJ3N2E4Qjc3Z3NBME1nRm5MS05ncTZjMDFLZkszNFphQ2F3ckFMdk5hM01VZkVmZlZWeW5UWVo2YVE2dUhOV1BNc0lLbnlhWmkzK3BPLzZiMTEyZmR1ZklqSXBncmNDdCtrMHE0aFhkdCt6Zk4vWlBiOXRXMDZ4VWJHWEdURktIVnZSU1MyVUpPV3Yvd1VBN0lnVkZOdTdEZlNZRTF3UUZpclI3dkYwc1dRWmVKWmVQVHJEQXg2N2duZDVUSW9kU01kZ09oRWJjR05mMWFaM2RXSGxWZ25sQURBRVNWbjB1TnhDa1NPSVJBWWV6UWhENGlFc2N2bUh2Zk5TSnpuT3pnYmdFdFJXamhYUjhwNTNWQW5XZUx2ZTArV1FlZUNGMXppQUk3b2JucTUrOXZ5Tkx1dE01Tk9VM0NhSTJ5cWJnQ1FJWmt4NFErZ3N0N25MWjRiMVBxV21EemdwUGZvSkQ3YWJhSXdCWFE3T3d1dUw5bzUwOU1jL29UcklIeEhicm5XdVlJNFJIaGdJZlNyN2ovMm5ESzZIVGFLVjRLN3VtM3RKUm5JVVduWEdKdC9ITVRMVFdzZldlVDZ4ODd5M1RDZ29jQkE5MHhYREZvQmpxRitJM0dzZXpxakxDbGNWNTdsSVhlQUFqdWo4aUVLTEtydmVRU2paemRMQ052eDFBQVp3UVMzZ0Nzek9jall0RFUzVGpoQlVMVUx5aEpUZ3NYUk91cDduUFBXeUZFNzZlb1kvMkRvYVIwUHYxdk9xSHdBdWpuRFd3RGlPZkdiUnVqSEd3dUNITndEY0UySXU4eGM4QlVBb2dObkEwYmdta2l5eG51WEZ3aGtqV2Jyc1IwOTJnWjdKeG5FUjhram5wVHdBYUdnUnE4QjRrcHdoMFpBeW1zU1ZlVWZLKzM4MGlQaTVWaDhMSFJMNk9nSzRQNGhBNzBwMDNtMiticktjVDJDNzlaY2tEWHVSTkZOMVBwT1ZzbytnVFVLYklxOGxTWXVVM2pJai9lSU5WWHI3V05QMmhUbXVrMVpsVnhQQjhvWEs1b3dINjhlcCtYM1Ztbm5TRFBVWTdkNnl2ZWsxZXBkMXJlZC9Na21sK1VPTFlTWGxVeTVmSFVtQ0pISStDZGZwZVpjWjRYRUFBSmpJNXV1bmkxL2w4STgyWDZaYnlpQmxSMjA5eVEvR3RHQ3dUSnFlRjNFQmkxZEhjSXpxOG4xYzFCbDJWZXRNRmlNOHpISExteHgxV1JHaTl6blNkcVZsV0lGSTRUNDNndnA5bkF0ZkRUMm9GVVpkVmVGYXVyenltTmZINy93eFhkRTNDeEFEQkxPeHZFT2FwampUcGFSTG5raDZybTZyTFhCVkFEaUdMSnlqYzdFb2VlajhqY3hqTTRSa3BKc0ovTVFMTWRJVWpyZ0gzREV0cXhqSFV0NElYSkF3QyttazlBQ0FuWEVJZ09qT2ZWd2dsaEpkS3N2MGo1YUlGYTFNV29OTnFkMmFhS2t6VXJhMVdpUGw0OUtOc2k1b3JHVTV6WlN2amFWWDkxQ2xsdlc2elBOVjFaLzEzbGFzdHRWMTlVVUdhWTFTT3RlVVNkczJlZFJ2SkRxWnlYRVM4dEx6VWwyZ2cyaFFSYnR1UFRocGNJRHowUkk4YXkxN2xGOVJsM1Z6dkYwZjdkb1dWOHNyeDVOeHZxVk9Td2RDeERCRUZleU1lUXBjdEl4ZjZmMlVGMHB3MUhxc1VOOGdUSS85V0tPTTI5YXFwZlJjbGZUYzQ4WitxNjFubGZsZy9ra0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRlSDB4OWU4SHY5K2YvQlp4TzhnVDByTGJaVEhPQTlEQ2dHbVNqZk4wZHpXTlUyL21JdDJFczdIc05EYzJtQ3hHT253bEFiaXh0cnpDRGtwclduWjFFYjVlOGc4NS85eGRpcXhPMWM2TjZqVkJNeFZsbSsvU3V1OWMxdXQwRFRMdmxtaWVjdXE2dVFsdmJhOW1hZnZFNXY4Yjk3eGcrWDVscUx4enJuZmYvWHlWcUZqUDMyTklmMXJFbHJEdGtVS3V2OXN5VkVpTzNsb3lzcGR1TVk2dDg5YTErcnFoWURhUFYwa2YyVGJyUWY2U3RVdHg3KzE3N0UyWUVXQTJ5empjK0VYTEg0d2RSbmVlTElZWXN0SlpYNm9yem5PZ3dsSlBJOHArK0VPd05ydjBJRmtiMHQrMnhlWi9LRGxGSDJIclhwczlObzlVaHRNV1lzdml5dW5CczRWeTFCNk0zcmZIQjBuNmNaWUVzS0FrTnZXazc2RGk4bFJOcEw3Sk53bnhVUVRGcEliOHM2UkwxdjNoL2tKcVpIM0JPZzhlamFTV1BSSkR5bXRKUXV0WVFvOUV4TXFFeVFEQUhDVDdNRHZ5V1BOeU9mK1BrYzVqODBaaktWYkUxTEtMUzVJdElNaWhBL0dhdHQ2eVdzeHM3ZGl5M2J3SzFXT2kwL09GYVlObHZnTUFBbmpYZUtSOGlnQ1FuRTlSUm1SeS9mMkg2WE5iNVpFMnVUd0x5K093b0FLTUUyeVdKZEdDVjJDM0NrNnFIRnBpVGtYSVE1NXpjYlpWZk01TTJhWW5KMWxZNnh3bGNhdTFmRm15NnN0aStYVjYrdmUzRGZKeEV1cVVzTlN5UkE2azhab2pXbHFyN0d5Yzd4MzlqNlE0cjN1RExoN3dnSzZKMXdlcDAzUHBXdjJmSkpSRHJ4Y2ozNFZaSGdIblBuRjRMU0F1VHhicXQraUpSVmhEekN2eklXSUN0Q3JZRnRrUFFrUzZuQzVKYmkrUWNza2E0eWY1WW5KbjRYcGRSdUxUQUxEQ1d0U1QwcjFQYWE5VGU4V1JWQVRYbEtoUGRYdWloZ1NjTVJOOE1SVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFMajQrZHNCSURPLzdzM01YeWZFczJORlpNc3FBQ3c4dXhGUmpGL1JXeitpajJ6QU5HTGpydW0wYkJsVTVjMWN2c0kvbW8xb0VPclN2cDVnN2I0RUxvdzBuNjJkeUlDZndGYm4yZGlHaU03UDUyNVMxV09aamJicU1uOVlsRFRoM1Z5VGtpNjZGNTEzcXpQdE9yUGRsbHBIRW80alZhNDEwZS9YaGVvOWJBdVpISjlyN3NuaHYwL3ZocUpTMmNWc3g4d1pyWTBUYjcxSFNoeGhrR3ltZ1dMVUpKbzI2YnMvV1ZQbDVsaFM2RjhoM1dha3dZWUFKMExha04rVWtHOC9qUFdYM3VKYkV5ZGM0YU90a3R2QnFlVW9JK1QzUTJXWXRJRXV2UjdwSHMxNjVLeGE2ZkcxUE5iYWt1d0tZSm5wTkx1eUYyK2Jvdmw2NnZhVVRlK2Y5cEhYTnlISFhKRmMrOVJnR1hXeXFaMXBPTzExc0czMUJaQnRwY1VNeUNYUzh1MnN5SnMvSk5ZSkxGdHM4N0ZXckMrQXdVUWtJNmNQcERJaXRKb1JtZ2daVVFjQTRJczEvMms2bW9ZTDlWanpkYVQxUkdXR1p2dEc2NHJISTNWR3VFbVBwN1VUcFFITVhaZk1TNnNObmhDd0ZlSzNzSllUa3RDbTRrZ0xBQWdpVFdpdm9ISUlnbUpvVk1HdkhhTndpcEkvYjlQa3FDVWhSYjQ4K1VjSnNzV1M4VmdTU1dsUEs4NTRrenU4NVZpait5VE52blBtK21EME9SYzI3cUlwcWtMK0tzYnp0NktQTFNveG92THI2OFdSTjFyM1NEdlNhMFlrSXgwSUlNbm55SU9WYkZnOG9QUFJJaXpjTXQvQXFXTE02N1J0Tng1bjBXa3ByYmJRNjF3OXZhNVpxOGp3cFBQR1ZFQ0ZOVy9wQS9mT1B6Q2RudGhnNFpZNWxVV05Jcmh3bStYVEJFQVFhekF4NDdJSTV4T1RSYXRLdWc0Y1dLRUlxNU1oTERiZ2k2a0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNREZUNmwrY3YzM3c5L3Z6MzJYcnpGOXIxNkF5RTZiQUl5Z1pmdWJ3cCtXaXVZMmI3clZVUGJzRXVFdFJ0aUEwTnBKU051d0VHTGpob3pjc2M3YWZ1dmgxSE1yQ3p1M2JiNU9JdlNoWjZPUlVSdlhuWU05dGxieGJ2UGlMWTQ4Y0hZWHFzaTJmL1Z4SXVlNWE4bVJ4M00rZDF6M3RGc3BVampPWkx1dXZIeDV5RFhpcmJZVVYyNTlkMXVwUFpHNm9yTzM5Zm5wZDdLZkZQSFdaY3laeldmZnl6cWJOa3hUOE5xMjhwWk1wOEp5SDdrMC81SmQ5TFF5VFltWDE2SVRYMWNGdy9nZFN3RzFUbmVIekExNXVTYTBJRzBhZUJicHZSdmFsdTQ5WlFFWFhvdVZFZzBSU1k4M3NsdXo5bmlYMk82NlpBM3ZIYlRZV1JUdkZwUVJtMC9hQ2xjaXV0KzJCKzFMRStWUGFHWlAyY0wxMWUweGZhaGRML1g1dEJYK3hiRGROMlV6cCtuSS9meVQxMVZJL3MvRzMvblc4czJhR2QxVHJXbms1WHI1SExNcHBkc0dZQWUwbWMvcGhtallmRW4zcjFLSGg2eWN3OVFCWUN4U0xNTHJIMFg4cDM5SW5vZ1ZKcFU5UXlaUXF5cDZYUUx5YXdDV094QlJGdElBYk0wbjJac3R0Q3pnYS9sYTdtM0VmUUJ3T2taYWxDUGlFMEZvVUovV1o0WmVMRjg4TWY2K1VNWXF2YU9PTFBXOUpIZzRZYXRGdENLMGFQS0lON09rNThxWEJEaEhzWk84aXBUNldraEhpdDgwcTRwcjJHVkZsWit0cU9TZXpxdVVrYWlXTjU3cWxSQ3RKa1NkZDVTYTlkNHZqUlRTYTFxWk1Ba0dNa3BGYUErODFWNEVObEZWRUJVbWticWpBcXpWMTRua2ZSaVJ4eHQxNzBaWUVkNTAxTHJDNDI2QUxNV1o2VktWdnY0WERNY3RHaFgzS0ZTZlkxSERXbjhCd0kxWEVYSHYvdVMwR25TY0xxaUxwekY5cVFwUGN5UWVOd2VpencrWTRJdXBBQUFBQUFBQVhKUU16d2VBNjROcERFWWp2VjBNQUFDbjQybEtjRmxWVFRzQ1F3TUFBQUI0SXJBQUFBQUFBRENQSXkwTldEa0FBQUFBdUIrd2NBQUFBQUJ3ZFg2K2YzTGZON3JRVDMyMXJVandNaVlZaVdmanZzWXRnK21NaSt4S0hOMFE2bENzbldlMEd5djJEa0t2ZjUwN3FFQThQQlJOWjNDVHEvNjNLSG5CaDgyWFVwV3R2YVNOUTVmano1ZnBFc21YbUhxcktxNy9hRnJ0TDI0QWUrdmd0dW5SMG5GVnZuY0tMcjEycE9lSmk0MGc1Nno5dDZTeXVIeWNFdU9FaUtUVmhYSSt5UmtGOXVyU1VoM21GUHRTYWpIT2EvZFo3NDY3dmsrdERiRXZ1c3FsYk52alNTL2RsN2N0a2ZIaVRSc2RnelhTV0NFbnJOdDEybG5yUE10OFRyNjJYUkJOUWtsZGFPb3gwc2VhWFlvdmRJRXBOS2hlai8ra2Jjd2VHY3VhRzYxZHAyazFyWFdycVJVeGllQ3pUTU9yNlVlTndheTBJVElreW00UFg0dGNGV2VlcU8zR3pmeld3VzlOSHN1dWx0cTJwS25hSnNyb2FOM0N1ZnorWCsyVGJiNmNhdlNMNTBzcksvL2s3LzlsTmVMSzZwL2xxNlhpeDFxVDNvU0ljaXZFRjVVK0pMTzlMV21XQVJDanh5NXBrWHllZE12Zm1sVE9TWmVpdDdTekFEZ3hQZHFvTnpLV2hQejA3eVVOSnl1c3RuaW84MFpjblpGdGVEeWNjdkFnZFhwVGZESWxzVzExK29nNWJRM2taSlFsbmM5R2VpOHdSOEh0dWJoa3BrNW1hZFd3OUhSV2tsc2E5OU1ZdnF6Y0s1QTRZZHNyckN5bE1OSWJzZkpuOXM5dGNxVithVnpRaGFYTmJaRVR4YUdRUGxQSXEzQzM5LyszMXF6VnRNNjdIUWx4WldjOVBlcXpSdS9LWXhkS2RXbHQ0dXFVcmtld3pJaUxTY1pyRVgxd0xRL2FzbUZCTy9Ya2FYa21sdERRaEVOcEtKUExML2tWNElQMWVDMzV6T2tLeXczc2xmVWo0ampTc1dINVFiVFVTRExDNmtRckhXakdLeHFUc1piSHdiMm5zbmxudVM1Yk9OYkVNb2JFVFluYUVaVFcrR1ZERlVzUi94cEZSczJpUjQvejNrVU55eEI1TVBoaUtnQUFBQUFBQUVONWlyY0JyK29aNERrREFHd2dLWFlFblEwQWFBTENBNEFuQXdrQUFBQUFBQUFBQUwzQXN3SUFBQUFBQUFDQVN3TzNEb0JwNVAvemYvOTM5VHRlOG5HbXo0OTVmLzdyNURNeHN0Tm03eS9kQWFpWk1KWjZkaTY0RkowTjkyeFlJTkd4RVFXNEk5Rkp4K1hCb0hKUkFwdWJXaHVLV0x1alBmZFJhSjNzM1VkTjJWZnVjeWs3bXFCSTZrOVZyZHVQV2NaZW5TYTZmWTIyUGFKRjFHWW1kWE5iZmYybnJ3dHpQbGQvdFgwTnl5ZTR6ak9YempTem8wSy9VMG13UTVLTU5icjc4bWF1MG0zaWtrM1V3TG9RUFJ0ZmJjb0s5SXYwWlVuUGJuOEF6TVQ2bXR6ZnlmU2FFSzNTMkxJMkh1TUhSNUVFRnVURm9SdzVmc2MrK3VpKzA5R3lreU8vWmNzZlFldjJsNXFQNHEwamtqNDc2ODZrbXNWdUhHQ0FjSDVoV2Y3eGw3dnQ2Ync1cjdxZ1pBZGtia2RrLzIxS3p4Y0FIeU1qREsxWUVzWWpyV1pxQ0FDQVRXVFoyNkozdnM2UVl5MHgvMUYxUVc0ZFNNL0RHR1UrN3pHWldoZTF0RHd3VGNHakdHRnBqaEFhVmxwdmVtOFQ5SFZDL3RNL3RBM1dmYlRlcHdldkZ6SlRvTTN3VXZMcW53MkZ4bGdTYVVwRERFWUtnTkN5bXZ0VWlpMnR6N2I1Zy80MmFiNm9wMFFyYXNmbDRmS2xGSy9iTTlKYXpRNllCQmZETzVEQmZ2UTRtN09YTkt4eDBSajZmeElqcmNUWlJCKzNOcVFzelE4ZDRTQnFTS0F6ZDJmRWVzckdiZHI4WWRmRkpBZkF4cEl4U2xydkd0MXNUL29SSnExWG1HajVnUXErbUFvQUFBQUFBSHlFRFhOWTQzdVJIOVBYR0ZNQUFBREFDNmhFTUl3ekRDWU02RHZ5SEI4RkFBQUFBQUFBQUFBQUFBQUFBQUNnRGF5bUFBQUFBT0RxNVAvK24vL2QvTVFnZjc3SzlOMys0YkF2cGthMy9kQ1l0SEVkZUFEY0Rpa3pka1p5VkIvWkVPbDB3MXlhenhUbkxyYXV6UVNab3JUelNha1NQSURJbG94Z0NPWHp2OGE4cVZ2RVhwQXpiWDlYVnYrOGVHMC94YVJ4YnovbXJIT1RWK3NYeTZCc0dVMnRXb0xmRWZmVEFsWUg1cENTTCs0OXZXSmFzRytPN2FtUld3eU5VWFhYK2J4MWROYlZ0Wk5UMEtBYVdmZEpHSGtMMnBkUXBlc0FUS1d3Zjc3WWFFRG50cTBlTGV3bG9oRnU3WnRGYnZoNWh1OXA4VzU4N2JWY0E2WmVrelUxbmxaYkp6WGs2Nmx6RkNQcjlnWU5lMngzdWlWd05weHY0LzQ4WC9YNHJDY3NKZVozaVlXVWtmaTZ4QytMME5SYzMzMkxnTDBGem9Rd25IZXRPM1cwd1RJUHJUb0JBSFB3MkkwUks2SzFEaThqbzNSYUhUUGJDQmoyTUk5clBQNXhqMW5kNm9OTGJVZ05kVVlWTHdDUFpjODFHMitkbzlldzZxVE9CUWJwVTBBbUhrc2lTblJOVm1OaTMyN3kxSGpYRDFOVnBhV0FBbVZuNllUUmwrNHZxdHJQdmRlZTFPaTEzZXB5UEhqVjdZelpvT0UxQlNJekJqUXl5aW5oc0tZaEh1eCtSRjhSb2N3d1A2eUZKTkJNeTF0SVVSZk42NUphWlZodHJJSG9HQWc2OGZRMHplUHNLeE9BTUY0blp1QWdpK3Fsa1R4K3JveUtDVDhRNVl1cDZDVUFYb3lNc08wTVpqRUE0T3hBVGdFQUFBQUFYQi9ZZEFDTUJYUHE3dUFKQXdBQUFBQUFBQUFBQUFEd1pCQWhCQUFBQUFBQTRDTEFlQWZBNU9mM2YvUUxxZHVOMW41UEhEU2pzbkhzL2JWeFNaZitnU0U0QWQ2eFNQOVc4RzZNcFZXMTdJcFFsRFNuSVR2UGM0MW5ibERkT0VyWUZKREt0eHlvRXR3WWJRc3NESVF1WEIvaU03NXFJc25LNTlyNkkrNjhkYnVXemVkcXZpd1BzcEN5aDM5QjFkTm1hK0NON3NPSW9DamZiUFVmUmJMRGx4cktwb2p2OWZ3K3piZER2aDdUZ3ZuOS8rTGFzNjhZZFhQMWFIczlSYmFMdEo2SGR3dXIyc0pxZk01c3VkSjFiL2xDR1NFL2ljeFg2L2FLMUc3dGZzNUpaRGM5TTdQRDNzUlh1OENoWlBiUFA0UnhTM2VScEIvY3ErZkJTcFU1eG5ycmhzQWxYVW5LT0pBY2ZvK0E4cHBSS2ZuTEJpeXRYZWJkSWJrK1Q5MVBWWVV6N1B0NGUvWjhMc0o1TDU0SklKV1poZlJTdXBZb0cxTTNhOXBLWlpPNnBRQVdlLzlGcUN1UnNpUTcwaGgxaGJtZTA4Ym95YlM5aFN0RGdGU3hmSDAxS3pQaHp3VXRWUlhXakJOT0Y2RVJBQXhDczNHa1l3dXZOSTRzYVhEQWhBQmdmMXF0bzhLY2J5bUh3K3V5Y0dWYWtTVHJ1b2RlV1FWWjE4QklINVFPWk11VXk0NXk2dU9JcjIyZHI2OWJaWFBwdFhKZ2lnTGdwRlZxOTBqN0tuQzY4Ui9wM3hWaW9GWHc5OWxsSTZQZFdiQUNSSmtpUmE3cS9CR0JWTmN0ZlJmREs4aHBHazBRajhRUzlpUU5EYWdYU3pGeFJRdGo2YlBXWGgyTGJXS096ZlRiNEpIa2k0N3NlZHFUbmg1UGpuVEZrVThiYlRSZFZ0TFFPdjloeXZBU0hkM1dqUEhlTDFDWUlXcXM4REllMXY1SUU5cEtYeE1ONEhrRVZhUWNycXlIRTlIQ250aEpwSHVqUThyYmhxUmN6MFliSG8xM2ZuclgzQzJEQTRTSmhsSmE1N0VuZ0NrdEMrSXhBNUVlM2YxTDQrRGkvSlRvdXFBbk5DcnhHQkZvZFJvVXNCdmxpNmt6dkM0QUFBQUFnQzBaUmhvQXdNV1J3Z0tDNmduZ0tRTUFBQUI3Y29UbWhiWUhBQUFBQUFBQUFBQUFBRjRRU3dKandZZ0NBQUFBRGdTS0dBQUFBSmpDNjR1cDlkZFN2MFMzZU5tWjRqeWZxMy94VzFzd21zYnRPMGJ1Vm56cVllM2RGYUR6SnJqcFRUZVBMSjNQQU55Y2VoQmhjQXpGK2hycUw5R3Z5ZUVSOVRDbzl6eUM5NVVnSzFWR2xZU3dNMjJJUGJhN2pHYlQ4Ny91V3BrazJSRXg4MzJ0VkU2UlhXWFZPU0xwNWJ4OSs2VDEwdHFXYUxrdFJTeTdjMHZYaldQdXBObXM5akYwSnNLdERlNXdoYStqZ2xOQUJYYzBlL0ZmYzZveXU4N0dhN2Rqc2E4OGp2K1JLaEtvZUI2VlY2dEttL0llUzBzclJ0c1JQVktqOTNxQThDN216cnJGTDZrU1dHZThHRldYYjE2dXJucFVsdmUvWEprTk8wOHRmZ1AxYjRwMjFHdDhRVWFDd1VUY0I4OXUzOUg4WG1CR0FIQS9aczNYU0RUVzY0cEN0dHljR1FyS2NwUzg1ZlRVMlpwUG1rVGNCKzJzZUFCZW5BWGdlTUlMMmw0L1A3V1I2ejlLWTFsVXlGZ0NTUkpnZFZram1CRXpHbFNXTjliaUt0b1pQUG84cGxhbElDdW80cmJpMm9qYWt5MTRJNFVSOVNzeElrN3I3UWQ4bE9laXdPRTVQNlVqeldoQkZXMExCTUNHNkRxYUZIL2RxMnNoSWliUzI3a0RURHlnTTZKTFRUdEtTQUR4Q1hZakdwZk04dkZ5R0EyTjBuUXRhUjRyQXEwT2dUQXgrZUY2OFR1UWMvWC9rK0taV1RTR0JzQUlCb3lsbG5CaDYzdzgxNHVNQVp3ZUlZM0IwdDlzWU9vREV6cld1T01hRENvMzNEdXBzMzY4QTFYdnBWZWJKT0lZU1pPbjBsd2ZnV3hKWnUyTkV1c0owN0piSnk3WFJ1MnRFQ21QSCs3ZDcyemNyK2RIcVRUSHV4Wlg2dlZUektrMDN0dUl0c3lwUTNyT0xXMDZ3dUtZV0tmWURkZTFyRVk4WlduS3NmTTNiNDgvYllHaUFyUHBjUndkZURZZVlmTUo1ejFGUlY1Z09UMjU4UnJZRmUramlDNTY4M1d0N2F6NytqUjczcG0yVENPbHQ5SUUwbGx1QkZmV1p6Q1I4MWxJWDllbC9UaTFUdGZhL3h0anAvYnpGS09uTHVLZHZteGN0Q0pVbWNubGlEV1hFOWRzOGZlMkpCOEFvMmpSRFZJNE11TFZhbmp0TG8vRWpKUUpBSWlqemJWc25KZCtlaENOakhKMWFIQm1pYmROSTdUd2RhTldGNmJQRVlvcnlVaGRWb2cvR296dzV1SGdYQk5wc2dBQURtSlBMZEpRMThiM05zcTBZZ2xxRzdUMTBOa0M3TWlvMktDNnBjMjYxQiswS24wNHZEczRaZmg5cnEycVVocGhYRm1qNm9pUUI1OS8zSnJHMDJnZGRKcHpCbHZ2dkZncWNVOUIxYWdxN2tpdlZvNDgxak4xYlhRdEhhSmxBcERmMDVuaGVabnZyeGpHSFI0emFLWTFJRis1WXF2eFMxeHV6Z1AzTnNISzB4SWF2VFdhTFUrQjBCRDU0VXd0emNhOUpQRHd3V2dtamFtWmMrOFUwNkREWUtjS3RoUWhwbHZVUXdCa1N2QVlOQlA5SVVORVpEempNUjBSL2JEcVhPekpsb1d6MWxlaVBOZWpmVldjMTNMMWIzSGtiYXY2OXdjSzJaVmx6c2hmUDlVN3pxN2lQTmRhMW15ZVV1Y2NyTFVkRjJYMXovcFMwWThCbUFxalBLUVA3TFdNemRhdjNUOStIY2R6NDVBVnB5WHljbFc4N0NLVyszZjlMdXgxSjlSVzkwaWJ5TTh0SE5kY1ZVdUdoRkJIUlBpT05qeUtaRGR2ZjV6Nit4VlRiZ09kc3ZtRFBSUitpRnJEK1dMMWVhNHMvbmdzM3JFR25rQ0xyV090VFVmenRhWWJXU2NBWUI2bDg3d2twN2p6dlhOK2hweWFXUWJZa1o0WC9ibGpLLzF5N2d3bUc4eEdBRTdJbmxxa3NhN0Y5M2E5TkJPdHU4V0xHWkgzVEF3YUE1dGdlRkVTMGROMWJLbDZTMTU4Yk9XYlp2MkhVQS8zbytMMUc5QXpaZ0tud250R2JVc2JOKytiTVdrOE5uQnIzU1BUU2NDOEdFajBZYUR6NzBIUHl3T2pKakJkVjVCZVIzckFtSnNSaTlDNk5ndnBXdXRxeGRKWGQ3RzZEbVdFWVFHNm1HSnZPZ3ZkTEVGbWNuNTllcE1YY3crNHNRUjRwZk1MT2JhS2lsNGZsZWYyU0hhWEJoVHpoaCs2NTlWbEJsdlBROVFDTndCWVNJNWVZRXpOMk1IZ2xIam5xWEhEMUJIOEhFZmo3QUJJYUpQdE5oUHlIRFI5WFN1djgwby9hbmplSTJweGVXY0tUY2NDV1UrNW9XdmU3WWk4Mjl0b1MyYlJQWVNXZ1V6YS9oN2d0TWEvbXZZeVhyZjNHNjM3OHlVa3MrLzUzQkMyR3NzY0MvWVIxL1hSengzZVZOQmFMMkRTTDNxMWRFUHJseVVCYUdhUUQ3WktLb3pqMFZMNzhXWjNSRVhtUUY1d0dlYUdOMGJOMk1oTTlRYk52TGE3aDJ3Yzc0Z1lzQkx1UjJ6NmdYYjA1aE9qdkxleXBDM0xqMU1UOCtQVUlVS2VyR1M4Rk5TQVlydGgrZ004a2huU2JFUlpVdGxXT2ZEUUFUaUdNMm1TRWJMR0t1UHhmaUNRa1JSUmROQW9KcXhaMXd6T3RLUUR3T0hNMUFLdFpUZmt5MjhoVWtnWm02S0trcjlDVzFESWpEVmZ2elNUbyt1bWxLaGZlNVFHUHlJNE9ySE8xeENxeXN0Q1RLVlpLVmhyN2JLU3RIeFRpNktjNzEzbFQ4SDg5SDB6clUwMEV0Wkt3eHNFWnI5NHo0T2R3QU00RHE4TlAydEpZNlN2b3AzajZrSVlXc1I2Qk5LYlhpVlpHbkVNbmlHR3grdEFlOUNqL0hzOGhHRTBlRmh5V2RuaExrMXdEV2JMQm5BRHpCY1FxMzh6bjZkYTluWlZOY0ozOFpvK2o2SFhBUWJwaHg5SVZIeENuQUtnU2wxSTVLa3M5aUluaGJSM2N3RmdPWHJSK2VGNGZxQVROWmFmKytoT0l2VzRJT2d1azJyUCs5OWZTQnd0bGxycjl1ZURmOUZOTVk2MTg1NTNEeUxwTDRCbVQ4NnNFNEJwZUFmMGlQbkxsREZpZkVkRXpTTzBCbndTQUo2TjVBaDc1TUlzMlZHNEU5bElreEwzeGRTUmJiVGU2ZDJmSXl4TkFIejBMR25BTEFFQTlMZ29rREVQWWVhREhGVzJKelpxeFZWYnpUenRKYWJXMzM2TmVPc01nTk53UmlIU2ttL1Vna29rT2lyVjJmc1daVlJRSWFBcEV1bVd3N3RRam11MDJuUTk0YXllTXJWMDNBK1Jva0Q5QWhjWUlQdlFLeFM4MXlONW9tVlpBc3RURjhiYmlsYjlvNzJUakM0K0lWaU91UlFqVFYzem5lUFNPRFRJaEtkRERLdUFvSmtMRDV4SGpuZXYzZVZkZkgxZ0ovNXNUOUdmWlo4MGlDUlpmdEdIRG9DRlp5dWR3VlZwMUVOZmM1Uk9PY3lsRzVUaTR1VjdUZXlic3Y0ek0wVkVtZ2J4Y0hPb2lxdWhrOHJhY2hDRGhjV3ppZXZteDZsR24vWjhhZTZleTJHV3R2Q0cwUWJVV2JTNnZHOUllSldESjQrVnpsb2NqbXlyWnVVbHg3U3ZscTllS3NVc05aYmhiK0hvazY0b1IvNDZQT2V0NTdGZ1BjZG9XenlNbGg2UnNTWGhiSTlMVDVYVTFJU0xveTBvV09kKytYZXhTNG1ZKzNSNWxURi9KL0M2RGJsUHJ3SHdRck5wU2JxUDVCZGtRMHNJSldwVnRJUnRwSGIwV2pTSDRqR05PSitFa1NWUGtObEhReDhUZlh5VzFiS0hGUkdyYTdROTZXa0ZsemFpZVZzaU9sNTcwbE5XRk10ZnFOTnhWUnI5c1BsNktaTm1VNVVnZUlxblRLbmNyVUJhaWEzNnF4NkZ5VWZxek9RcklNdFhWNWNmdDVaVmZrMGoyZjZqZWJ1cWdMYTR0SVlDZzJueFlMMFNwRVV5OXBRREFEZ2U2aDU0cm51amxrazRscTV4cnNvb1dtUW5BR0ZHRDl4bzNRdmV1QTRBajJGR05HVm0yV1JDUjQxdXlUa3RRdHF5MUZHMkN3eVdrdCtjTnhPUTh4NUJOVktRdGE3L3pSeERVcDFXdXVyRmlOZHBzb0JVUEI2Z2wxejl2eTR0OG16dXJaQWk5cS9udW9kNkpFU2VzQmI5QWlkQ1dydUpEamJRVDNTU1JWVEdVWTV2VWVvKzBxZlpBV21adEQ1T2FlNWptVW0wM1dGVDcwbEViZkNGYU9BY2N2elVySllrMzgvT0ZXcHhQRmZwWFFId2NGcGVHaW5NTVpmV0tJcFNoT1BvV0pYTWpjZlIrbnFJVm9aTElOMkR4V2I3U1FBQUhZK3hlbU9IN3hBNmhISHJvOEFqZkFqTGZQVzh1OWpxd0lKaGpQRDFuL200cE5EYzFlczZBaW93N3E3MC8rNFhwczBNR293YmFXcFpENmZsNGVHQk4xRWFycUdyd1JBNG16YktSUWNqNWhCNEFzVTR0czQvajR0SDlOMnJSZ1B0U2U2NjUzeTBUc2YxUFRmczhOZjFvRlVpY0Z1c3RYRDQvUUJjajlFdngydkhucnBIbXhHUVNXQTZSOGRRTU1nQlVEakRqd2tQTE52NnJNL3lJOGJzRVdTdEMwamNhOWVXYnp3cVFIMXovN3M0ejlIcmtXNVpYc0xmc1N1dnB0YTBWNFM0ODRnS0FYQWhvZ0twNTVmaWUyRUY4RzRjMk91MVpHYlVlUVd3b2dHZWpyVCt0N0h0WU95Qm96RjBPTmJ1RHFKM1VVT3kzUjRrYTViYi92bjk4M2RuY2s0d24zcUFTNnRtMG5VQWV0SEdWT2Rrc1g1OHhWVmRoS3BQTWVTbGVSa3g3Snczc3ZrUWc1QVBJZ0Y4aVB5NEIzVEJmUlhPODNFWHpOY1JXSHZsOUFob2IxMzBlbkdlbC9LbktuM2tOU2tQbXVibFBJamthSk13c09tSlQxVkZ5LzFKV29SVzZramJOY2w5ZXo0L1lFWnJwSGxBLy9hVTRVa2ZDSk56dzBrYTN2YW5uOTdwakRwY21aOGhtVVdwRmVuRHdPTUdvSWxlbFZkVy80akpVdHFtNjdFYW90d3k4RHBDbG9EcFJGL09MMFo2cVF6Tmd1eTFvdjJ0NkNuTmsyKzVVK2xPcExLOFQ0SGE3SnJUYVpWcHBmTkt4K0xNbzBIOEJiWVBhUmJxaEpmMW54dkJYYmI1WDZjTGYxd1hrQk5yZjViby9SbUJQTUZkK2pTdk1CZStheDNGVTFQaTI2UVo0QjcyMUpiZ3lsQUpPVXFDU1BtNXVxTTh5enNFWUgrc1NPUVJvUWlQVnZUR0xTRkRnRW5yR3A3WGhQZVdOV0tRamh6dzJUZ0c0SmJNMEJxUldJTUcxWHFLRnZTczRSUWpuZmlqVkM1MndKMzNVbXY5YktTajZWdmh5b2dLWXU5YXN6ZU9wWlVybExXSnFTaEZjSGxwUEtjZUU1dDgrWnV2cnJPazlYbTEzbHlYdExsNkJxSVN3TEtibDVIbVBlK3B3ME5FbW1oMWpEQnh3RUM0QjZLRmIvSEE5cWZIakpDRVFxT0tVT3RwVFlNeDlZSjJ1ZllJUnJsNVZsdFNReHVrZGx2SEkxYzBIb05YVHAvTk1BSXZXRnR1b0R6dVVSM2dabGl2SEdqNXJIU0dRdkxLY2t0M2NOZHAxZExhNUdPSUxtcDR5M3d3ZjE5TVhYWGd0NWNoWEFHb2FGRXlBNnQrcXF5eXd0RGVSd0I1QmxnZWExSE5KMDhRV25oVUo0QjZMcWNDSVRZUTVjUVdsclF5eXRFaUhDRlFBYmcra2dpajd3NVJ4OGtwOW1aSXlCWXpBdUlLUEExUHZBUHpZdUhKMGJKR29tL0NtV24vUm13a3RPSk9WLzZlYnpiZmc5MnVHRzAyeUVvQVBKY1o0eDl6Q29COWtDeWRvNVkwUnBrUmtDSEFwSFd3V2VlUENFWjRYMVpiMHNLOUFZQndoRFhycWJOMEhrdkZsbVJ1S0ZXanlvelpDN29qTFpLYkNML0d4NjdlZjgvTHNNNDZ6Nngrb2lPc1pmWjZ6MHMvZkFJQW5KaGVOUlY1WHlONjNmT2pCL2dITDBiRklyaWw4OVkyNExFQWNCeXo0NHBVOUdLK2cyRndnNHVjMDM1alhWLzNqa3VZRWc3MldLeDQySVA0NFU5Zm9BZWtHWVlvQUJpTjVBd0dzSWFsZFg3WjFZWmU0ODZmZ2tIenNuNFpVL3h4NmlrN0FGd0tLK293UUFZOENlMmwwZnFqSzJYOTN1ZzdBU21MUDcydDA1bnUrbmlGcWVXbVdHa2RaYjhFOC9ZRjRNOC9oY2xEMDRXaXJvbXZ5MnJuQnF2dWlPdG1RY29xM3FpMXRZZmZOMzl4OTVuMURHejhBVnFyN0pZOUNxMngwa052V1JNbER4ZGRlSjEvWHlqUzh6Vm9hdkoxSmF4bnBKa2pTeEFSbm8zTy9YTUhnQUNTbzhTY0QyM1VMbFRUZWoxS3krYUJsNTVqMW8xNjBvRnBXTmJUek1jUzFsTmRIRG5BUnZTeVpXUFQzdXoxTGx2Nnk3Q0xjeEdTT1d4NE01NlJTZkNzYksrL1RodDlUaDM5c20wWC9YcHBmdGY5OFZrTXd5bS9yMzh2TDFGUGo0L205USs5L3A0MzNld3l3TlV3Wmp0cnd4VGh1SmNXM1NHSmxMbDZDQUJBb2V1Q00zK2NtbzNqaUcrbXBkUEs5RWFLQVFqRHVSZmFncnpIUi9jT1ZFbjVTM2phQ0FEbzVFQU5ZNFl1S24vWlNrdnpXSFZ1a2tXMHZVV3Z3UElJUmlsUHROMFJxeVlhUTZENXlQSG4rV2E1U25lWlFwdXljVjFVU09Yei83eWpBdEo4ejZ2NXBLMXJHbHdlYVhabTRUcE5wNlVCQjRDSGNRKzJJcE8vUGtwQUxmNEEvQU1SYjVkbjV6V1BEUFZhSmEwV1JKMDNOWmFGWWFMZ3RidDZIaUE0TFZrSWZtcGVFVVF2ZU5HcjI3bEI1alh3U2Jhb2Z0TFNTRzlTOU9xaDI1R2QxNjJIOEVDYjd2WEQxRysvY0hmdWpvaWNDMmdIMElvenRnZm1zMGdmUEFJd2hYcHdhYXJ1Z2lyd1RHeCtoRG9CUENMS1RyWWI4ekx5OXZ4SUhxSVZYanNpNzNPUG1oTVpXUkFjQTdUOWgxa3JpQThWbHQ3M3lpSkVBakRRVWFBTHoyQ1RiTm9UcVV3cjJHbWRieWtMZ0N2aWRWSEJ4ZkhLNTJKa2xHUi90QzJqMHExczJCd3VRNG9iZk05dlp3WG1DTGdLM21uZkkvdEhMR2tnTkFyQU9kbkR0V3VSSWFQTUNQaDRZQnJGZVU0N0wxMlBwbC9PdGY0d05zTGozeHdEUU9KTUdxYXpMZG42bFl4V1Y2K1dmNXB3R1NDZ0M2TUFXdGNCdTJXODlENW8zbldHbEVIblp4SlowNERLQmVDRzBNbTlwNEN5ZE1UREJjL0lKWTJhMGEvbFFEY0FzQS9GSzU4eEtjRlpPTkZZOVA3MjhwR01zdkVlOHJwN1RmWEZWTzN0eGNrOUVnbTZXSUdXK2xmSVdMMENzOUMyemlsNjhnaWw4ZHBwaUM3VU1idEVzSnM0Y24yYzM2Y3g3NEVIVHVYaHpkOHU2cStoVXVpUFU2VVBSMG9mVU1uclpBK0dFWkxpTlNsdEZvNjlUYWdmVXZYZ0NxM0gwNllXN2FncFlBODlvOGlyeEFxZlBndnB5ZVI1ZldYb2ZZNktwU0sySVRwTFN2UFYvRnFjSEdHaGpIeE5WaXE3T004ZkJhTjRPUG00NlNwRFNIcTJ5c3JKWmNOdXVhWkVwcExEM1ZWRnVyQXVBSG9LSEk1azAxYm5aMFIxb3VhekpLNDhaVFNMclNQeHFpSHVQQVRLNFhqSFo0OE80QjQ1bmM2ajZ6eUdldFp6Tm54aDBxV1UzTFl2bDM2cGE1WTlxSldqbE0wOTZGQ2JhS0NzRXZLbHBQaDlHYzQ0VGVlNCt2dmwwM1ZMMXZlWE4rZVhxOHYxdkNselZYYlJETFNvWDl3SzI3b0VRRVF5YUJKdWhra2d6UWF1VGdEQXNYaGtTS3ZXT1lOZnFKV1RFdVFSY0dBRjlDTHVncmV1VmxlRmE2UGw2STFDcXd1QVc5Q3FnWG8wamxXbmRGMnd4bHMycWFVL1N0MVZjWjVCcUxRS1lDMmRGTGVTOGxodFNFbXVnNlFWZFFKNStlblRoTEl1TG1laGpWWjhwTDR5K2tlcC90akxFYjZvZHhSYlpnV1hscXVMcmttV1pOK3p2d2ZYNlVwRFhtQVFETnV5ZWZBdzlzZXk0YlhueXEyeGV2eUlYajhoQ1hWUmFOc2VUSTlGSjVVVnZhN1ZYVCtpbmxqdnFIalFvMm50ZE1qelU3RVJrVG14UzVwUlc4K2IzeExQNEVGNDMvblpVWVo0bThSZHM4b0VCbmxRbWh2eGt6WnZMNUpBMW9mSnN3SUdNN2dTSlhnZVRBZGREMExRWUJJNEZmRHB2VVFOcUVrOU9tME9XZmNtUlgwdnlvNWZTclhnZWhhaWNpYzh3N29FanowODZBR1BkRDB4TDhCaFJBVDFpUVI2VDFOdXJaY1FEd05KTndGZ2wxa2NNWWtjZFZwSldoMWZhVlZKV29WdEtkTTZ6elRoZGJ0dmYrWXpuaDIyYlVnWHJBbzlVbkI2M2hJQzRGeFlMMG9CQU83TnpIaDdweGtCUUp6ZTJLbDBycldzeUhXYU5pdkhYUHFVRGw4T0F1QTh0R3FhSGcxVkJsOFBUdXc4Y2xWanBsVmdsVDJ6RGExbzcwM3VRR0hhNG5tZlpVQlhIbW16SFZHMzlWSzJkeGFmV2MzQ0JCakkwU0ZJMEViUHV4U3RxbjRQSCtVT0Ftb2dvMklSTTdzTElnU0FjV3pFYUpIVHNiL3JmNmYvWEF0T3pqT3NUQUlBZGdDTEd0MzhyQS9ybDBkMjd0M1dsM0JHYm44Q3dDODdXZy9TdTJSSk9FOWZlVHAwMk5QRzFPZXljTDZsN0xxT2tzS2VwWGRUS3FNWWNFZTBuY3d3RU1KczVwS2pEK2xIV2NyQWZuL09ZMng5QzBFUzNDMHMzbnMyT3IxRjY1VWthOEhsWDAwNVdOc1JGU09kVkdaRHBIaFRWZG1lSnBQQVA0YmJ3cXRaTWFqbE9kUTdzMmJPVEVucjl6Z01NNlZKNmF2Uy9MTFZESzRqV1RtSklSMjdXZDRIRVBRV1hGTXduQloxSkYwM1JFYkVMN0swTDVkZUs5UFMxcGNsY2lNUUhJZWc2UXA2UHJySTNUS09leXp5YStCOUF5VDZoa1VKbE4yTDAxZXB2MkNSdWJ3MEQ1T3VWSDVXZmJ5aXZPdkkzN1F1MjlCcWkxQ24wcFpNWHBEOTFMRFJWNWtrS092OGhTK3ZjR1hRTm55eTZ6TlRucDkwYkduY2Y4WUNHeXVpRUxGdHJOSG50YWZBQmZBWUlPRDg3UGdjdWZuUFJiNTZySitJN2VweFJibXlyUE5XdWdpMzhTbkJtaGtQbG91ZGpDamY2MGdXVXVmS2YraXNHd0F3a2FDd2tHUkNLR2lVZmRlTHBXbXQ2OGxJeitXZEtaanI4MXBkUFpIbHJCeDcydUtzYy9XTXFyeEZNU3czWDA0bDF3dHRRMVFKYUVhdDd1SEtkOTJ1aURpMXpOZmh1NjZWWFZPVXVyWHlVdkw1K2NsSTY0MHBKQ01kbDlaekhSaU1FbkhXQUFEUG9GVjF3cmsxaWNZaTZtdWoyNUNxT3ExSDU3VXFvN29DT0xETVpIVDJaYW1YVFZjbkdhTDJKQUJ1bDlTVFB6aW9zcU5JTDFaekh5ZnlvcUVJQ0FTUkgvbVMxK3dCNEthY1NMS09XSWNhemlJaWRtNVlYYVZIU3ZWZUJ4ZW54U0RBb0xnRmVJeVRjSyt1akZRT1IyakJVMnJlaVR6dGZrK09kNld5UjlCQlNMb1krWW9HQUYxSXZxbjFOc1ZGOElvOUFFWXpNNnpoS2RkS2c3bGdjVkJRcXNaNlYzRTU3d2xrOWNqejBicEFMRS9wYzNxcE15QTNjKzhWekMxd1ovQit6QVU0YUYwRkRPYUE1emhpMWQ1NnVWMDY5bDdUcnUvcHVrTFgzNVE5QnN2c0h4NzBwZ1VBbklUUkV6ZnErRnMvUFd1cFd6SnFSdjk2L21nT3ZJZmlyRnRiQXhpdU05b3R6RFBZY0tQVjdkWGZrclZtTVZ4UUFCbzRRdVhYYVNNdnlENmNscGdEdDZRQldRbkFQWEN2TVJKM0NISUFUSU1PcnNCQXM3eDJNSURXUlExc1hyRGg5Y05VMlhZOVlRL1Jod2lqRzF3UTZUMjJ5R0t2TmZROVpYWnowUHQvSzk4N2srdnZSQ04zendNM1F2TWVvcnRlZ0RVTjhxQ2dUMC9BQ0VHK1RCN3RWek1weVJhNWgrS3NTNm96T2RQVng1eTJsdW91empLWkZud3VMenZNRmlXMVJMUlBpK1BjV2lqbVY4dG1URnByajhJUmRmWXNOODRVVkV5ZG9lcUtYS3h5K1Nsd3M5bFM5UitDb21PUFVRekFDODZXcFlPTU8yWU9JLzRsMVhqV25HckZJNzR1TWFjc2gxOTdDOXg2bm1BNHJkYXc5QmcxYTVKTEw3bW9uam1Kb2ZITDNtK0dGTWZwd2w5ZlBybE92M1loQmJ2cDEwNnNMNmZhRFRQS1lQS1JyNWl1Um5iMWRkYlAvMHQ2ZmVtMHVKejl4cjVlWWZtRDNqWkVKWUhMb2dRUG9DZmFJYWw4eTR5d3pyY0FjK01BSURLdWc2WXFCai9IRnRraDVlMlJUOUc2dGZSY25UTnNXYzNGQWdlenAvUFNNeENzQWI3SGZlVE82d0NBTnlmVUNoK0ZiUG5raXJDaGNZZk5selBUUk9ndkl5MHQ3eWxQUW9vOGU2MmEzbmpFN0hYUTRrdTZPUytNbld3Rm5oTzV6bFVtclg5N3kvYWpyZEZSLzdpM25ock85NWJTZXRYeHY4NzBYSjBXMG1qdmlZTEJqRGlRUFJ3aU1BNjZJRnFmUCtLWjFXcjNvZjVDYXl4aXdYcU1KY21XVGs5ZG80RElhRUNheHhUTEpQZWVCMjZzZUdYUCtvb24vZm9QdVM3SjQ4RVFBQ3FSbDBkT05KaWlxL1czbndlOWl4b1JRK0ttL0pNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCdzhQUDc4OXp2ajdBenMwZlhDWCtpL2NzZVc0NkFaeExaa3FOeFJ5UnJZNVVSdy9tUUtkRzdaVkRMQm9HTk53cVI4VEE4azg3YTNnUGJVTEZvSDIrcFBxRHlQcEZjL2VmWlFPYVp6TFRKU2xwWFllM0JhUjB6WmJ2MzlaVEs1Q2FxZCtKYWVFYVhWSGYycGFQYmIzMnFkQ3JCVDZhUlc3Zm5kK3F5eWoyR3lGWkJYTjZTL0Z2VVJmb3cwbzdaTUhWNmZKek5WbTVrL2xyZDltQTladTIxTFpHRjU2SjFhV2IraGdrQm12RnNkRzZrRVZXOGczcnVTT1l6MXhUTGlyQzB1dFlXaTBQbm5kZmg1OUsxZEFxWWdtV3hlaTFCQ1dsenpHS2tUYWwzV0RpZHNsTnhJazI2Y1h4cm80QTZ3Q1RQSjNuWm51ZU94VG9EMExxalpZaGY0dmljK1A3L2RmdkYrYlZVV2tMYVBONzg4Vlc0Qkd0LzRXOU40KysvZGFuV3NhU2hJclRrQVhjaGF1c2tKVjB4NnJET1cyM1I4c1BjR0l6SFJqOFRsdEZ6eHJyMjdPTURuMkdMblNuSmdIK0RaWHFpc2haVzFIWWtrR01uWnNURDhRNWNhZEJ4WnFTVlY3cHVLWGxQVzF0bDJKN3lHb0RwelBUeloyb0ZLa1NzWTBMeENodXVhaEp6c09SU3RnS1Uwakc5UmlOWEdpTUZWZFJER2xHWHQ5MU9wYkNKNTFUbFp5WWRMWDVKRjdybEhzOVFIek5lRmFnMTEyc2ZlbFI2Y3RaVHIybFlhYlU2V3lKSWRBWngxN1U2WU9OZURFbGtldTFHY0E1R3FSOXZlTm95SzdSMldFTGs0bGd5VkNJU2k1RHFpRm8rTGZUcWlHU2NmelRjSUJpcFZHODY1L2FnQkk4alpTMXNYcWN6MHBVY0t4OEFrWjVGUHZyS1FEcVB5bitjcUxNTUNUaHRKdmhpS2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBY1BHVDNYdFFIVVIwbzNQdnprTUFTRWhqeDlxVktJQzF3OXZsaDY5M3g2L2lMeVlYNFJHUXpTRnBYb2dDb0JMWnNoR3dTQjk1K1oyWHBXZHJJOEF3Y29kWllUdVhYUGprWWpsTFhpNWhKdGRiOTVtajVYa0dVdXVlcXkwSTI2MVpOdXFHNVl0QWhibVMzK2V0OXNidWgzNHBkZjFVQzV0V0pycFhycForN0gzMk1YcjdQSUdJblZtNFRDbHRkbCttWGF6ZHhrNjNlUVFoeWJsMEhlbEtJM240R2dBbVVSVlo1MGxWM3JJK2ZDV1RObkFYcWk1S0ZWeCtUOU04bXFBdXQyVStuV0lPUWhCY0JrME5leTBiNy9XSXl1Znk5SFBHZ1duTjlEMjJNdlkreWFJVVc5N0ppVDlRNTF1dXN3NXpBem5yNVJSaTNOVDV1T3ZHY2YwMTFGeVY5VHEvTVUzekp6M3JaM3pxV1AzRGZLbStyTXI4RmladFVUckM5NlQ1bHJ6U0RPNloyZEUyZ1ROVEF1ZEhTMlB2Y3BtVXR3VE8zeGJ2dExUU3RVenJJMFdDRlRMemhOU2lvYjFlYmlZNk4vTzJZeng0ZlM5MzZDbnhHdGVqSWFXNlUrTjVEelBLQkNlZ2RmQm9DdGhTY2puNUZMaFVaNHV6cDVtYjNERUFsNlkxMmtMVDlrajJGdTFRZ3NmMGZIYWVUMXVYMHl6YXVhaGh0bVc1VnRKV2FQWWF3c3YxZjVYMHM1OXJ3L1ZWTENKQWNVWUZONmMxeTZwcUUxc0hMVjZ6eUdLS3BSalAzN3JPNTlHSlBpM1Btb1kyZXJsOFVkczJNV1cwNGpGdHBQcGdOa3lFeXVkSWVqQVhyMm9mc1RpcHFWSHRXS3ViRTZOMFlrdXE4NFpZcmxmMG1KWlZoRG8wWFNBUnNQRGNXRVBJazg5eU1SK0RaVWhZK2VDYm53SXJIcm01UU5ZZVA1Y3pmOTdybWdFd3hFbXB6ek40eFkrbEd6emVmekxxdUEzUldMQTMvc3gxN2doRDRNTGdpNmtBZ09zRDZ3OEFBRTdPMHdRMUZCTUFBQUFBQUFCKzRDL2NrWHlxWDFnQkFBQUF6NkwzUlhnQUFBQUFBQUFBQUFBQUFBQUFBQUFBUE9ULy9wLy9MWG41cVcvMWkxKzZZUFh6WHlkL3FRTXJiR0EwM3UwRUJoWnA1ZU93ZnNpL0s5NWRJRHFLOVc0KzFsa2xlQW9ZSU5QUk5tWTFQKzZTZEREUGV6QTBVdkZ1R1JiWmJ5MjZwMTFTemtmMmdldXRLd2xwdFBxczlHblR4MjNqV0xJQ290dEJMcW4zbkUyWXdTdGF1c0U3ckIrS2FEODZSTW1tSzR0ZEJ3QzdNSERRV1J2eXRWWVYyU0I2cFBnNnhDLzJ4Z3c4dSthQlV6THowVmpxNk5ueGpobDNHSlFTbS9sS3ZrVEJ1aWpNazZ3TmoweS9oa0hhNC82NkNjbGpPZDFhblZKNm9Velc4NmkrakVxdWZQOHAyMUpHK0QrWnFhT1FlcjRKT0x5Q25MWkJTMmNKZlhCbldpSU1kZHFJSFNYVjJUS3Fid0dtM0JxUENKVHlSTGZkbHNwWjhrUkVwTGV1bHZzN0ErVCtvdTRFUFc5VlV4T1ZDUzB1UzlRblF4Z0xkTk15aU55ZjJBaVVONnNOclNZc0FJQVFYUzlyWGF6cFdhdmpzaHIrUHEyQ0NvVlAvQ0s2VnV1cVRDanZLWUlwci83NXNGbFF5bXkyVGF4b2s0K3JVbmkrOUxyNDNDWE85ZnlpTTZuVlptMU5YK2NaMFZ2ZXR4V2c4aTlHMUxZRDU4WXJOSG9udERSbTRDZVlqSERKNnZNYUk3cllzcVpvT3U5U3MxWW14STlBMUV4R1IzWVRuYThkM3RTbURPdmRzS1RVaFVjUFFrUjAvWklsKzB3QjcxanNqVzdVM0Y0RVNrYUJsajRsNkFZRmZERVZBQUFBQUllUllad0IwQWttRVFBQUFBREFER0JsQVhCbE1JTUJBQUFBQUFBQUFBQUFBQUE3ZzdBa0FBQUFBQUFBNElIOC9QN3Y3K3RJNWZNTDNrdzhwSHdHanltNkkwWFBOZ25nMlJUanVLR29UUDRkdGZsMG5lY1VlSGQ3Y0c3SnNQbndSSEZsYzZjQk55YWlHM0x3UEZoRDVpWDNnUlZwVTFkcG8xZDB1OFdJL1ptRTlOWk9xdXl1cmFPMjVQTW9pK2crcGxaZHRBNlA4S2pUY0FOYlB5Ri9pU0MvcisrNUcvTlp0KzhaOVp4cGVSZVRMbEU5TkhQRDd3c2l6dUs2SDVncDhEcGR5R2xHdDlHaXVQcWh6MEF6a2tyMElHeWJKOWxkbzNZYmoxZ0dFZTNqblV1SHpMZnN2RzZwWVhBYVdxeXBhRHFhUG5LZHpxSDdNdUVPV2VXdWJVMjZLV0I5dmloMVdHM1kxR1VJYXBxdUxzK3NjOG03S1d4OWZpbkhhR01tanY3dmwxSkxpVDJ2YjVOMC8rZDd2YzY1OXNVS0NVaElheHBGN0Fnck1odVZBSkd5TFczbzBhemdhSHFrRlpWQ1JUanZyYk5uU2VPU3ZrdVB2VHdMYTlwR3BuWEVZT1pveVJmTjQ3MGZqNGkwemtmVGNXMXI3ZFBlWjhHVTRZaysxdGNMY3o5V0pEQWwzN3lPMnJBMEx5Zkh1SFQxOVVpZGw1UlBZQjd1U1NNY2M5ZTB1andPb3JjTmRmMlMwcGJxbEV4VUFCNUJqNmFLbGgyMW9GT1Z6eElHRGVmTjVyeUZSaEV5aUYvUXRBd3h5OExRcmkxNS95SEhGaEZEMldzZFdFckRtN2N3ZGE5akVadDRqUmpuWVo1QnFRdEtjdDMwT2VhOFNiTEp6dVhiMUpVL0VSYXJzTm16a1VaOTZycWlNeWt4MXkwNzJST2RzZXF3eXJMS3B1ZGIyOFNsZy9td0k5NEhpSWN5bjE2SDE3cnVjWWl0dW90U2RuU3NQR1JNZVMwNFNmT1ZGQjhTRVRleVRxK1ZSZlBVeDFvYnJWVUhLZDJqOEpxTFhpVVBlVDJNMXJuSEliMkxMSldSblJmd3VJR2JxSjJoREM2dkdlR3RzaldmcHkyM215TXpGalVlRHI2WUNnQUFBQUFBd09WQmVBUUFBQUFBQUFBL3NKOEJBQUFBY0Q5ZzRRQUFBQURnM2h4cDdleFpONnc2QUFBQTRJbkFBZ0FBQUFEQVZjbi8vVC8vdS9uOUxyZHB4TTkvbmR6a2FkbW1DZ0NPSGNhS3RsRnFmVjdkOVNPZGNGaEhkNmR0dVZIbmJpZDFkcXNLOENDMDNjWkFGM1REVGMvWFVOSDF2ZERlakY3WGlqYTJocEoyNEdVVG01VWxveExtbWxWT2RNZmNFU09SN2s3TVkrNGc5SjVFMFM4UHhlcGMzL2YzK3J2dThNN0IwZlFwdGZVNVl4U0V5cnFBVlJDYVV1UitJdHRCUGhCSklrYW1Xcyt1WWdBMEVWV3ptaXJzRUJrUlNlOXBzbFdXdGJQNTZlY2NoTUxsOExpSm82eU9pQVgvUEt6dkhmUnNTU2s5MFdUVXVWd21EcThsVEplMG1xRmhPYy9lTDZuV2FjWDBqVmJMNWl1dHl6OWxVL0x5QlZXbHNGWGViQngvY3kzbkpjb3FMZlZ3a3BHYmF5Tlh0dUxCR2UySytzWFJlc0FaNkpGT285dlF3M0E3cTJVS2VSZE9qc0JxUTR1U24zMC9QV0pzVDZ6MUl5c2RsL1lDakpZVjVNUG1hbDJlWVZ5bmJZM2lXV1VEME1UTWtQQXFhTmhZUnJSc0xWMWk4clJlQitCeDlFWWlSMDU4R2xOWVRwT3l0ZXVtMzArcS9LUk5RaDB6RGF1bHJPaVhVelY2TFpLVzUycjFnMlhFQnRyN2lpR2xiVDRhVzhwR20wcnhwZnRtcUJ2eCtiK3Y1ZTJLSjdMYUwxM2p5dk04Z1dnOE50S0dVYU9VbnUvbDRtN1Q5V2xWUitCWXZCUGFhMGEwVG5STTREQ1JXRVJPTVIwUWJZTjNDSTF5TTJtZGp4OHkwWGw4NXJnMEVQRitPVFVMei9XekZFdlRKd0FhQ1NpQmxadFBpdERDa3RiNDlJbzFMZy9YbGtmaFhUaUJrQkRCRjFNQkFBQUFBTUFOT2NJRGVLclhzZWQ5dzdNREFBQUF3RDdBNmdBQUFBQUFBQUFBQUFBQTRBeGdEUmFjRnp3bEFBQUFBQUFBd0IyQWJ3TjYrUG45SC8xMTlYcG44U1hGU2ZCdUVUSmkwelh3REtSdEFTTGIxemlyc0lxT3pMVFRESEh2Tm5OY1dzOU5GRjBhOWU0Y0JNQktCbUF3TmVQOW1FdE82OTJLdkR0aUFnN3YvamN0UlF2YjZwZUJkWWlVeG11ZWRORzlWYlZ5eWJaYldkaloyUGs1eHU5R3VLV3FJYWY0MTB1M3BXYXh0bVgzMjhYNkwwckpVbHVzYlI2bDlDMjBHQkk5NlNjZ0dUV1Jwb2s3YlpJeGgwakJpOEtjVUVWWjRGbEVSejhBYmlRZlZVcFhJNmh3YVlCNnhtK1BKcXJ6ZTNjMFQ0UGFNcDFXTXdKQzR4SjRIMC9QRHBXdFEyRE1FRHFqQTF5YzUwZnNNKzIwV1Rmek5tRHpXMzZBOUJXTDVYd0ozS2ZIRVYvWm9VSzd5Zm5sQzZqNWZaNStLYlVleDM5ZmhsaW40MHpmVEdaSk5tYk51czdNN0JpYnE1VFdXUEhPV004ZXNoUDljWEJhdkNPSDRvMUUwTFFlS1RaeVNXTjRpTlE3RFR4VHkyc1hqNnlUbGhsNThKTDRrWTR0TERzeU1zaThkVWxsYyttT0Vua1JNZTN0czlabjQ4aExWYiszQ1piTW9HR2hTTk5haG9va0kvaDNEV0wyTVFBdXhOZ29PVTdDY1kxWDZZMFlvTDFsV0tZc3pFOEFHdkVhUHg0c1kyRHp4enFmZUQzeC9qdWJYckFrTmsyTHJOQkgrNlJGdTFzV1JtdGt1VFZmZmMwU3dJYmk0V0l3cStmSDVmT09KVi95U05sRlBPTlRQSkdlMVVzYS85VHJhNXRRV2RMTHNHemJiYnpLVCt2b2xlcVcwdE00SGxEd0RPU29IUm4xNS9HUXpvbmsrTmJYT1R3VFhadkEwWHdQZ2s2dDZCU0t4R0M4YU5QZUdrS1VxTnNiMVJHM3d0dTVyZkliVEtQRmUxaW80NjNjVXFuNEdoMmVLeGlGZHdBelk2N1hqSWhTR3E2SFhjK3JZUzFxak9yOEI0RXZwZ0lBQUFBQUFBQUFBTDhnQUFrQUFBQUFBQUE0QVhCTkFBQUFBQUFBQUNKd0dBQUFBQUFBQUlnRE94b0FBQUNZd3V1THFmem1Ec3NPNXdmajNTbUlYc2V2bElHWEhReE5hNk52dW12UHBlRG1wTFZqakRWUHlmVk15dzhBVVFCV2FOdUtZTEM0a0Q3RTh0bnBQZXZwcEd1UlhicWc2bmVnQ0lJODArdkxTZXM0Slh0bldhZFMyRnlMbktkMVJ0dFNwMG1rZTd6YnFpM0ozN2IyOGhVaVVtaEoyeS8rckw4UTVObW55TjBZTWYveXBkVENLbmZ2ZG5PZTYxdzV3VDY5QXBZdkkrWGg5RlNSOWtIa0Q1K0NOTXMvMTRQVGZIVzY2SFVDTUl3V1dVSFQ1dFUvb3FhTGFNQkk5Und0RnNFTzdubzdrc2xEaVc1M3k1VU5ka095ZEtSMHJYT29hL2ZYTklLN0Q3RDZ5UlRtMkpHdC9qZVI0MEl6TUdTbkJDdkJaN0Z5dXAxNWFSMVNuWVg2SCt2enVmSmh0cVpwbFlhTDV5M3AzSDZCbmJlczhtYUg2TFJtckRjYUVZSHpvMGFWRGZhbWRXbktNd29rdDA5TFA1cG9HOEpJZGxQUDFHb3RneGRROHJYV01pUFh1VGEwaEZLc3RONjZXL0dFQ0Z2cmpQcnpJK3FPdE5GSXU5bWhYd2k3YnZJcDFhMGljMldkWjlVVmduL29vUmpIM3ZOZUdUbE5Cb0hyWTVsd2tmQzA1Q1pFVGJkSW5iUnU2YnlsNDJBMkF1QWtLaXkwL0xhM3VjMmoxUzFGYU9zc21TbVdTL2Y1bjFDMUlUU0tWT1lxRVhOaHBKRkh5L09jbCtxeW5udUxwZUgxOEt4WVM5V1dZZ2o3ajA0SUdvNjB6cHkzZFp1S0pxblhHMGF6aVRWaVJxeHBjTE5ZNnhVTHJjMjk5cXgzTk5PbjZ5MFhPQmdoOHFVMGxzakVnem9QM0xQeVBQZVUraDFkVGMwbW82NkgwUnFMb0dsS29JNW9xTTFibHRWR0tZMEdSRXJhUG1ESnRBTzdzUm5QclFNOHBjK1hVcWw1dlRHZkJZT3lDSk1rSW9iQncvSGFCZzNGU2ZySjBrczlIbmsycnQrT1VZc2E0QU8rbUFvQUdBc0VMUUFBZ0ZOd2hFSjZtaEtFMGdjQUFQQndvQXB2RFI3dlhjR1RCUUFBQUFBQUFBQUFBQUFBQURBUmhLRUJBQUVnTWdBQUFBQndkWDcrL3ZuOTZXNW1mdmg3d3QvOWV6ZEVBeUFLeGs2Y1A5R2hYNCtjZDF6SFl3SXVwQjByWm14WkNGNUVQdkppaVE1UC9tZlRzK1ZLWkhJbzJUOTc4bmdtMWN6dHhuckxhbW1idGVPdHI2aEMwaGRIeHRJNWU3WTdKaFgyL0xaT3JaU1I3Rm5YQ2ZEZTN1aDBENEhiU0pyZFdEd3JlVWx5YVpjeEFJYlRNTGcyR3FLcy9xR24yZnpkZFRyU1I0NmxjNGRCYjdoVmJWM3V4dTlONnh3WjhZandtUGVBMnVpRm44ZWpkelNuZFM2c0RKUEdRc3VCSThkUmR5bWVUd0d3T1ZNN2xsOXpCaXRPR215ZTYzMStJQmpIbnQ3dzdIeWZ6SnkvMUZOZVNuYW9LTXR0VVBPbE5PWXJFZEU2VzlKeGR1UFIwOXV5WlQzNVUycDNBRnJzNkpZNlU3QnVUMzZOck5RVkxMTVk5MnQrZUNkdlRSMnpqcDQrRGxJNnJ3UFF2RE85eCtmMnlxVVJhR1huNUwvUG9wUUJBR0RvTVFLT1dJdGNraG8rTmwzMHlJYVNsNzdBbWZqa0pITmFmOUp2VDJQVzRrZy9mMUQ2anpGSCsxUmJ4REw2bi8xeUtqY2UvYzdLVEpWcHVRWGU4eVB4MnJCN3pJUldVOGhUSnN5SGdjQ3h1UWVjbjgrSlVDNzlpRHJwK2V4TWx4SW1OS0UwcHRrelhEY3kzYU1aTlQ4eHg2YXpzV2s2QmppWE53OStSbWZ5ZXNBRjZKQVZvMlg5cU9XVlJ4TlYxQkFXdno5TVhYckRhOFh1ekJuZUd3RmdNaVBlYzlzZFNYU2s1TCtoeUkxbm54RXFoZG9oT3NBTFRkVnBRU1R3SVF2clYxNDAwYkdwUzhnTEZvNTJmYjFQY0k4bkowM2czalk0OHdlSzcrK1Y4cDh5c3BDL3IvUmpkZWJEWnZqTTI1VWU1RU9NSW5xYnl6bytmVCtqVGx6bmFla2UySnVnR1c5d3loaGtFZnRxRkRQclBPV2NPcUtUd1hRODd1Q3M4Y2lvSS9FNkdBU2R4NjRIYm8wQVMwQ1g3ZkhLTUVueUN1bU1INkF1ZGRFWEU2VmpLZC9xVWhaK2pQcEp3UjU5VldCK0g1ZlZNYVV3Zi9WakdjNHo2L0FDQlhSbUx1MTY3VG0wSktVM29nM1JmQ1BXTkt3MlNQcEd1cy82dk5TbTFqWkliZktVTVJLcnp1Z2s4dDR2bHpZNXk0d1F6TnY2Y2hSbndteU9qZCtZRk9IWWcxbDNpdG5Ubmpia2RISlpDdTdIbm9OT216UVkrQUM4bVdGWnp5clQrY0lMVzdkdzNyM3hVOGU5Wk0yd3NvejNJd3hMV29mWFlJemtsL0syT2dvQlllLzVVYXBhSmFtemFPMnFFM2ljbFdjZ3pZZ3pSWXBtU0RFd0VhODRBdU1aTlZrazFXYzVzeWx3M1dvakZ4Q2daVDFVS0xURUhDekxiVlo0TGtMMHZpQkt3TlB4eGtSYko4dnpyR0lRWmtkOWZNUll2TzM0SDcyb0FXR3hmREYxQVc0cmVDQWxlSDVBVlNNZGtVTW94bkZyT1ViYTNGQTFwTnBEaUVTRXRiZzZrQ0hyRjZOM0Y2THZhUUVQQXg2Q09YZWsxNVc0VU53c1plQXBkNVJpa2xEdVQ2eXF4SklIS0plYUpRL1gxTklVMnFOTzcvbTdrKzFwV3Q3cGxuK3NMcnk4TFErdWh6SElsbkY3bC9qV0lYTXE0aytBMitEeFFVYThzMERyNU5KNDMyY0FIVkJoeVEyQWpaSTNub1oyWGJ1MnF2djloL0xqejJFNDcyZGp3cjdQNTBDWjM2NWVsMmx4WGw5SGVqbTN2ajVEaWRDQkNrVzFKOUVlMzNQMGR1dXRQUTNJU0YzUlRteDVOMXlhVXFQQ0Y1Nzc5UXZGYmRuUlBFcytiNXRhSEY3dkM1VGVmRDJUYVVhWmRYNDZaZ0lxWWF0ZjM4Y2Q4MUM4WGRLR0VWUGRmTXpHZlh2UFI5TUFNSFNndE1ybjZIVXVUYSt1aEprSWJza01UWENrZGduVTdmTGZJMExEU2x1RWM1WUJlWlR3R1dXOGo4N3JnUWxNMWM4ek0yMHBOQys1M3Z3Y2VoeUZhMk81S0tON21pdXI5YnFVM2h0M2hzbXdNeTF4Q3pDR0k4MEk3MFJuVklLS045MkRhSWs1OU1yaDNKaHZCaEVkQU1DZEtkNVlTYU5SaDdrRVRDSktJR0NrajFEOTBhWjVydDltVHJRWUVwNHlIeXcwZnZUTHNHYkJnMmhaY0ovVWhPSTh2MXpidGFrSGl3U3Fqd0ZneWNJeDN1VTdKYTdOTzBIRkFZTjNvNGk0U1JTSmx0YTBQUEdvTnNpQnRIVjZlbzY4akZ4SE5vS2ZFODVpMjViWHQ4ZlBoR3lHU0tQOUJJWWdEV2RwU25rZmt5ZmRuZDI5ekovaTN2bGEvc2laejRxWkFhYVJqZk9CUVdjVmxVaVJlNDVyeTg5Tnd2VkRHT0VubkdsRkVwajBxdHRvUHV2M0N4Z21rL0VxZWQ1RU4reXF6UHNBMnZsWG1jNm5Ia2xmK3libDg3ODQzaStxL2wzODFFTkRMNlBIOWE5ZjArY3ZaZU9Zd2xtUW5CSGZvMFN5Y1cxRUhTQUMxK043OUh6VWpPaXhwellmY0U2ZDg5VWF4cVBMYkUzdm5WSldXYTMzTzFQWlcvNi9kdXlOTVhpUW5HODZtU3c5TzJQU2VjdVUrb2NxdDVFcUlldFZlekhEdDNZVHRtVkZLaWYzRVRHbkFOZ05idDU2MDN2emFHVkZIVWFwSEFBZXlRd3ZjM1FiQm1vOU5xWlFHUndmUDMyVE1iRVh3anRpYUpFczZmcUkrMmZXWkx2TDdDWFloazN5dkw1V1ZuK2tUMTk2ZEVHMjJoSnBheGJPWmhMbDhaVXk0Z2w1dzNYUi9KUVdrNTNXc1FmZXVpelg1S2c0eCtNWWFUZUNNWXg2SmpNRlhIM05xck0xam5VVG9oclE2dks5cG1odlhTMFczUEl2WkgwUUJMQ20wOVBGMUl3ZVBZOHhYNERJS05uZ01kS0ZxaTFhbWlqTm9jZUt3dGExSzVydXdRcjR4MDZ5cHdrR3dJRmNjSmdmSXJjT0VnbmVLaUd0QURnM1Ruc2FISVg0UXNTWm50WWU3VGp5ZmpFekhrY1pkTDRsM1lNTUoyMk5CdllqT0p5YkRNSldjWFlxclFjVkRDYURJWFlRM0p0Wm94OUc4NjlHdk9rRGpmWW05YnlodDJwQ1NkbjhKVmJaK1AyQktpN0tjc2N6Wi9nZWRZRFpuRUgwYUhsM240OUhEbXM0Z3M5Z2o3SEZ2WUJ3UW5FZERTVk5NQ013NWNDNWlNN1RrUU80MVVDV0poWE1RL0E0enFCUmR2SjBzK2NYS252MEIvY0QwWjV5emlDNGRqRFlpcmRPeG9DY1lid0ZtUjNtYWlrcjJpMmV2TDFyR21jYTFUQUpBQkFZSWFCR0NibWU5emNRR240eE9oYlJFaUswZnBzQ0FOQVpzcVpSeUxHVS9wMGdZNktDczhPTVVXc1RobGs4ZXJvVTU3SDFFbW8yNnJoeEo3TS9UUDN1ZlBVOU01U1d1SlgxTU04UWZ3VDNna2FTNkRWaHpHbkRXd3BPdFFTdERwVkwxanpVK3E0QlRHOWdBdWRoR3RSQnM3cmE4eEdYelV1cVpYdWRPUTNDdFBSZ01hN1ZUOGNiYnJPMklQUnVOVVBMOGhpVWhVbnJyYXVrMEdpa2cxNllETnZUVXQxVm5wVnRydDIzOVV6NCs0NkowR2hvOXVFek9odkhubTZ4dXZ5aFhleng5YjFrV3FpVUFJb0puQUZHSm1nYTArdDc5ZzV2cnpqenBxM3o3REwxSXJFbXEvTThxNXllZEdBYVBXdi8wZlFqWEZVTW1RaUtrQ3hKM2lsSk5DZ2l4bHZnQ1pWZytuWEdMOUxYV0gvVGxiUnQvOFlaNGR1UVNYMXJML0I5N2o5bC9mNVF0UmFKZGVydjhYSTJ2NC80NHhGc3YrWmhhYjJSTDlSNmc2WFI4ajExZ0wyeG5yNUhVa2cyVHE4WklWMy9uT2VHRnMzUU9seGJocWpsTTF0MWVldVdwbFJSeXJRTWFTdTg1Y0Y2WU5LeGxUNHA2YzFCUW82alRuZmRwMTZpOXlQbDgrUnQ3YnUxTXRUekdtVis0dTFDWGNVWmgzZmh2Ri9QOEgxTm1RR3lRdnl3R3dCUnZISlg4OTIxZVd4TmlMcE05eVJpeXFCdHN0RHVwNzRPQUxnQXlvVDF2ams5VEJaNEJabUhFVnErR01jTEVXK3NUdDlpdEhyS3ROb2lQS0JYZkNjNUNNWWltcjZRKzJrVStiY2RTNjFxK1ZJYTQzcHhaZmVvM1QyUVJyZno2WC9TYUc0dnpJWUpTSjFyUFZCd0xpUWhFZlVUb2xoMWFqNE1NTkVlNjRJV1FwdWhFN3d4WXE4T1NFcFpHRHB2ckFkNWhOSi9PQ1BuRmpWL2l4RWJ4YndBYnJ5dXBwUmVpd01PR29ndGM4alR6RHJkWStkTVJGQnBuZlFBbSs2blBRVFF3VklscERvNGdwSHZIakZnZVBjRGh3Z013L01tR0RnRXp2ckEzQitOWXVOTkgvOTdQTVU5Yk5oR2pYN1NRV3c1a3dVV3pMNTRoMi9wdkE3V0JFUUhZdEhnbEp4Z0FIS0xjcVBLaTF6YmhRTkNabUErZXo1V3pzZUJmaG1FMUxuY1N6K0Y1SW1VNmNubktWTTY3dUZJTzdGRUx1ZG9kb1hseDZkbkVOQXpmU2RFbU1HYTNwalpaN1pJUXd0RHJwOW8vNDNzYTZ2dXB6emZtZmRIKzIrSHZwejV5SnBOQ085THVDMWxBeEJsUkd5MTFUbHJzZkZIK1FXWVJBQ2NrTjZKcWEzZVJjdU9DamF2dGRIVEprckV1eGx0RWJXV043SU5lWHlzU0l4bnZlL1gzZnc1anNOb2xYY0dWV2laRjFhNGNpYmVpQm5jZndBVTlyTFZQU3F4ZFUwRGJCaXRmcThFaGdjNE0wT1hUVXZpOTJZcHEzOTgrN2RndlFUTWdCcnJEV05zbHVySGNHOUFDK2R3ZUoyMUMvUDZZdXJmYnVJSC9EaVZ3MzVqSG9CMml2QjN6UURwNnQyNXJNZDNuRDRWcVBKclVZYmVYU0NVMzAxbFF4QS9RRTREY0NpV0krYjVRcXFZdC9vYjg3akc2ejU0QkxWaGNHWHVUVVRtc0ZodkhKVVVmNHViS2dHdmR0VHE1cTVyWlhvTXo2cDl4V0ZJWkw3T1R5bEZiMkVtYlNqdi8zaEczN2ZXbDFKZWk1YlovUURwSU5sVlBiY3JQZmFXcVhVQlJPa21pTGRWbCtlZzNvS1NBck9aR1Bld2JMVWVxUzdOd3owdGdWMlFuTTdXK0JWa3lpbXc0aXpXZUl5R081YTFLODJDdDdpcFNoOUhlZjl2NmV3YXNiT0RFYm9tQnpqNHVrT29qc0xuL2VSdkhTM3JmcUcrQ3VlajFNZnJjWjZGa24xdDIvcEg2MnZGZkJYd0x5Vi9uSnpudVd0U09wcSt0VzdwSERnREkwdzNUYjlvVXVOZkpaOGJJZkZLaEh6K2wreTF2RWo0eXRrV3R3RXBwZWZTV2VHcmxIeHQwcTRYVWxlMERBdE5sRmgxWitOWXFzdUR0ODRTYkl0WGpOTnpuclpJYVRYVFFLdGZVeG5FalBpY0x2eDFNZnBZcXVQR01VUkR2WnVQcTNQMWNvVndjeWtMWlNqM0I4Qmh0RHBuMFVDR3BvKzhkU1doanFoY0IrRDJlQ2ZYR2Vwd0dxSjFYTUJhMUtDeEJFc3VXZEFGRmY1Qzh0SHFRZEdvbXBZbVFqU1BKSEN0Y3J6eEFIcU5QdmZFWUQxZ3V1N3JyWHVKdFJ4RDYwaXh5aHloZG1rNjY2blNXTEEyaWkxYUkwcTF5ZTdKQXdZVDhXZkJzV2hpM1JJaXJTcUJ3Z2tKem1jQklsSVhleDhSbDhjNmpqeDJLMnpuSlhKL0dESUMzZ2NBK1QyZGx2bTVLWU11aTc3L1hjNW5veEp4VGxWR1hNYXpCeG90Q2lnNHBrYk1sYnFzbnFXY3h4SHRBSS9qZC9OT2ZmMHc5VzhBTGNQdHVDQURBTlB4V1BjbmxLZzlRYXJoN05pUU9td0tCd3Fvd0JJNkRjWGhrTUhPR01YWGR1T1BIWGgxb2xuM1EraU5FanI0ZmJFNjc5U3ZFSjBUOGF3emErZDY2dlNlQng4ZUtNM0FVWXhZRFdOUTFkTmdHY0JaQU5MTERWWlR2UGtBMkpzUk9vSE9FK3YzQzFaWndJRkhRRWw0MzlLYStUQkdsTDF5RDQyWFZwdUtsMzBWempNZE1adkt1MlF1UmdnOUFtYXlnL3Z2WnE4bGpWdk5JWThpbnNYREY1MTNBVTc4Qmw0UDgrbTBZM2UzS3FGaGhLZkFKV2cxSktQNWVtTEIwYkloRjhIajJVUFRqSzdERzR6ZzBsWjB6WDlhNTF2SmYzUjl6M3B3cjVkeXQ3Vm82VjZ5bnFYbHZObGxjdDhlYWJQTnFMdlZMcmJPMCt0U2wrOHhpdUVlQWRCSkNWd2I1VWUwMUdXbGw2NC9SRUNjT1JaeHBqZ3pBR2RpeUxKbzhaM1BWdVg1ZXpxckdRRm9wTU5vSDZWRE1Kd2JpTDR6Z2s3KysySHFGNzVIZHUwbjYyZlgzbU1BSkNhUG5jSlVGZDBVb1dlZGFncWNjSTA0NXNGMHJuQXN2RFlRd1dzWUFCRnBGM1V0TFh0TnZ0Uzh5OWo5aUZoZTJUaVdzaTBldGRkS2ppeVVGYU1NNlRYaVpMU2xwUGhvc05KSDJsUytXVmJLbnJ6d3Zaa3MvQ3ZaMnZndXJNVVF1WGMrN1pnNXRZY0NocEFHY2N6ZlhSVDJ6OVhzbDNiTGd4a0JkcWRCWUZQcGJQbWVrU28ycWsrcDUvTFFHL1VZcjFIVEJwd09hWHh6Uk9hT2QzM2gxbk5xSnF5TFVrMWNkZjU2bjZRbllrZkxUR256VlpOVmR1SXZGRU9JUkwrZ1doczFueTlyK1B5aTh2RmQxdHJpMjFzbGNWOG9YZGxUSkErcDRqK0pmSDJmVjIwcW03SUxLN0F0N1plRVk2Y2Z2VUdUSGxUamFxOG85a0xyQXFPZ0kydU1UNzB1bTJKRmFXaklZWmplOEN4cVdFT3N4YkNNMXUwVFoveURzN0JFZzNlTlVtdVhWV2R5bGltSkdFNFVSaDBEcTY4NWNWZm45VHhmcTQzSjBiYklCUExVNFNuREtsY1FHdGJqN04xMW56VTdzcHpHQTVVNXE1UFNzWENqRzFPbTRYNGxtUWx1emhFUFhncUFuR0VBOXNvckFNQkV2QUlyWUppV3ZEbkZGNWw5NXlWRi9IRXdWcG1yTXRZZXYwN1VhUGVrNlZVR0xjTFRxdE15bkxWK29JdFAyVXlpVjJVODU5emlwSGlSWWtmakdPR3FqSzY3cDZ6V3VwT2pMZEZaTitLK0hzRWV0cUFrUXNBemFCMWo4QVZNb3V2Z1BYVjQwN2FFN2JUeVd2SUJCY3VRZ0x5ZXh0QjFseXpFUVJmejJGRkpxZElEWUJKWmZ4bGtoR2VoS2l1OWhyVlUxVkxtcGZHNis1QVZHMzRTQUU4bktsRU5Ga2NDOG1Zc2NKeEFGeGhBcDBGYnlzRmpBanJhNk5tWkV6VmxCQVdXeXpnaXE0UmdLaU5ITmZRVG1NWU5qS0ticVVRQXBnTi9xSU9vWFRXaXN5TVBwUXc2MzVwdVpKMUJQTEZROWwzWFlDMng1dTloZ0o5SkM4TGhtTVZaYlozaDAvd3VpeHJXUGN4OG9FOEpyZEQ3bFByMGFXTHB3UHVWZmcvYzB5VEh6eWpreGt3QWR2SkRPZUxCRitQNENpQWVEY0FCN0JsazROSzEvRXd0V3Vhb0g0cGVoWjBjSkc0emhOYjgydlVkZE1LTVVYSEczMmw1ZmZFcnFHR1lDZzZlNHVlRDQ1aGhHb0F3a2pydVZhTlJFUUp4QTU3S1NQRldJQ3ZCMlRsQTJNT2tQWWlIZHJ6Nnc5UkQrc1ByeGQ5aFlRQWNTL1FYN1lFeGxvUG5wYW9QcGFjeDNxM3FuR1VYOTBrQXdDekVEVGVsZENSeXM5cTVuY21IS1QyU3dOdGcyZGdaMTN3d3BlR2F0YytuQmwzd0hMMEFxdDE0WnBwU3RwUGhuYXk4ejJmeVdZRDR5OVFsOGNhSzV6bEhqQm1yWlZKYjZ1dWVjanpjWUdIYnNqT1RjQjI0MlhSdDNsNHZYTUpJb1FDTVpxYkRKNGhPeWIyTjROVVE5WEZQZWFjQk11RTJhTmFqWlQxcFpTVkhPVkphaERWbndkdm0yMHQ3dmk1bm5LZWZFWk8rcE1wOU9mWC9ZKy9kMWlUVmtXeGRLWGQrWGUvL2ZIWFI5UnFyTHFaMloyUzRoeEIyR0tZRDRERCs3cG9aZ0dRU09wak1ERnlvVy8rQ2RXbGs3dGVNYmRuNSs0c3RSWkQzNnl1MTdMdVVSbXFFbnkrbjdzdE11M09SWHkyUDVHOWxXWDZTVjRibk1LQjFJQ3VaOExnQUtnT0tpcnltclpELzYzeXgwNW1MWUZicWdqN3NRSXpBNkhNK3IvR2x6dEJrdHUvU2U5TVNuWjUxSFhxbmV0VHdzTkpaeGc2aXJscWtlMmtmcUh0dFd1ZnRLUk90VXhMcTVNbnd4cHdFT2phYWRGbzh2U2pwSSt5R1lmbnVwdGU4Ym5UQ2txK1lPakpjL1pVNnlpVFBac1dDUEtzc2J4MllpYVdESW5QYnNoRUl1UVZIS28wRGVTMzhTWGhBc2dGOFRpd2F3NlBHYTArYlJ4V3VWL1lNWDl0ek5IcmtWVElrdmEwZUN6RWlFZFJCa2RKNGpDOFczdFB1a2Q3VFpOWWdTOStNa2RQTFNDeENjd096Y0owNHpGNDJVSWRvNWdRZ09KWmlLa0M2MGJKZlJDZDZ6L1VQWmFacnBqMnI2KzFlSkZ5RjV2WFNVVVVFUU13ZzZUd2I5M0F5YXVJcWVkdkhwMTc2cjdMYTg4MnhaRWNSWXFJTkdHOUJHaWhxZHRwYkUxM2tleDNGT3JUeU1PV2gvREQxZ1MxQm5nYzFMY1lLWjlxQlhVTzZvU2R3T24rY1BNKzVhNjBNenZrTGNxbE8wZDUySStTRFlCRHpzdFFhaFY0d1djWVJ5OWFGbGthdTB1U3F0TDlIYVkrUHJrdTkvcEFPdEliN05HZXpPTWZ2ODhpTHBvTmxwMERaR3pKY1JHK1Z6L1VDa2JkOE9KUEpNUXlQdEhZUlhGRUcrWXYzbHZVTW51YkVSdS8zcnVwWmVxbWxhcHYzYlhmTWMvRTNMRXE3dzJiRTRQWGV0T1FCSERrZ29tVkp2LzQ0dyttTXB1Y2tJN2VHQXh3RGNCajRKR1V5VlZ1K2piZ2luSmV6OUpjNTRVM29RVkNiZE1ic1JVYTFSTTl5ZWphOTcwNFRRdEt4aWlsYUIvTEZyRmhFWkUwb1FKNnJRWjFQUHBJQi9kZittTFhkd0ROU0Jla05WYzRwc295T3dUWGRQWHdTbzRhRXQwOFhPMFA2WWVySnIrWE8zTmFFa0pQeGRJMm51NUJObUE3aFZhaDNRMXJGMi9QSVZpUE4zMVpvRkdtUHFHb2hIMFpQQi9NaDZ6SnE1NjdVdWlQdHJReE56OVZwT1g4MXJOYnJ4VlBrWGw2a2w3U2VCUmFEM1pzY3BUbE9paXhKSmxLMytyd3drQTJ5a3hZelliM0l0N2JBWnVXNlBadCt2a1pVakRKL1VzdGxqOUQyNndlU2xXTXBlbTNaVThVNGx0SzNzaCtFcDBsUUdSRXZtT3NTQ1JGWnJuc2N4UFI1TC9KZXd0YXpDczlHZXZLUlpPQmN1OXhHcDJQUEVFR1hlQTYvYjlCRjNuUTI4L2Y1eW1uOU91eHNaU3UvOWpYVDNXZmVsZEVrcGhzY2VVN1p0bDdXZlFqTmdpOWl2bTBwUDJYNTk1S05XdGlCUzIvbVdvWTVpamRqbzJWWURrR1B4VXVpU0MzdTJUQlJFMDlLNDYwTkxtajR4cXNJS21zVzBjYWQyZmhlblVZWW5iNWVlbXRwMEVJc1hpakpYZ3hpNjdHR0ZzZEFuanVWRkRPU29zNkhkNytTZW5icXNmdGFhU3V5eU9tU1psNGtxWkI5T2l0WmFHcmt6VC94L0dsaVhRZ1pKUnAzUmVTbGhPdWpIaE12V3IrUjlZdG1KaUVPdlVvRE5YWUR4azMrVHI4ek1KUTRSV2grdDg5aWEzcWVwS3hjOVZHWlBSSDA2Sk9pRENZWGxQOXVUY2o3Nm9neWxmNlc1S2dWcXBFV0pyUTlyZzh5YWxGV3RrNHJNK291dDNLUU5EUUJCa0NYQmpUT29SMlRlWXpZOEt2TEZKOXBKR3hDRTVoVlRlaUY0RVpBZFQrSGgwQnZCM0NSdkNhVDRqaHFuRGJ0YlVZdEpzcWhRU0FpejBtY1pMMGh3aG1oVUk1M2tKbE81NGZ5S3hGQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUFMdzljWFV2enVidjM3ci96cGVzMS9aRjlhMkFkRk40WlpWa3R5Q0dULzFSM1lqVW9qKzhCM1phT1d3SVkvTzA2TGtRV2cyOEd0M2ZMTW90a2gxNzBieVVLU0J3VUVoWTIwSlZKMzNObDV0enhXaktLOEs5K2lxeUo1SjZMWmJSKzZCcGkyR1hwbzZuZGV6a1ZVd0crWFU2WktTM2h0ZFpYOFp0U1BLVm5aNTI5ZmZZcjUzcHkxbGUxN0dLelJtS0h0ZklhcXYvL2dIOHZINHpJd281dEV0enk1QTVIYTlxVUVqNXd0M1Y4Z1pmb0JTRmswSUVzTGFlRnliMStnUzY0aEJpcm9DcDlUSk1nMDhrK1JlUnVxamlWam9VcDRrNUxmV0NtbGphMlQra20vUTNlVHJlYXdLZVIyK0FsSlpPUzluMjZXenJrbGZUaTN2L3lUMTZ4WmRYM0YxakI3dGZwczY3SmNsZVlhVTcvOXJVN2VwYWhtbG1TWDcycmJwOUhxMHp6VGlEeFRRaFRnSjZiUzIxclJCMUUvM0JucE5ieGxFb21kdDZERU5MSGV3bnY3dGg1NTlSK2o3Y2xPQXFHclEwTXJNOEkrMEdDSXl0TEtkK0NWMERaWFpYdThKMTBUTDBzck15dm42bkhhOU54YWhuZmZxak5EYkRsSmVqNGhzSzMxOUxTdnBnMjFVbWora2VWdXNlalJsbGlTZnQ2b1N2ZDNYY1pFeVp6bDlLNCtRVTBIRDBUMDZJaVZmWDBteENDczljajJ5N2hKeUt6UWZMWkkvcFQ0anp3TTF0S1Q2dFBtLy95NGRob1JaTnlrdVVzc3FlRjQxWFFzU2tJMzJLK0tVb0NoMTJyVXRXRVl4MnJCVXNzWG04UHIxWlhpVjdmVThHb3ZRemxWMXV2amlNcW9aVURkeXhYS3J1WDl0T1NObDB6U1lRRlROc3RIUFI3Tzd2YVhPNnV1SWt0REtSdVJiU3liWllLMWVsdXRsdVlGZU55SklMcHJYL1ZMWjFqMW82YVN5aVFBYjVqUjI0eHAxYVJKZzg3Vm05K3QwTnBPclpSSHl4b3NaV3MvSndEVTlxdk5SMHlZWjZXNVAxTFo3b1hXR1o2czlhQUhtRjFNSklZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdqRTF4ZFRpL096NitrL3pyVitHYXo5Vk52NkNUY2hHam1RSmpLMmd1TlEyNG5BMnl6aFVDSzdkR1huUEhvRHlzWisyZG9sQWhOSm5zWWxKOVdISW0ySW1veGRpTUMyUFVEVlhoUmt1eFBQR0VJdHNjRFdLbDdId3R0T2VWdi9TV205KzBMMjcybXZXenZwU2pMUWdZdmNYN05BTlVYdTdyTDRFdEdyYUQ1VVN2MFZvOUpzLzFpNjY2SUJ0S1daOWlKRWpUek54dEhrZXVmSVQ1TzJkbVNOMFhiV3BtUkFka0w2OEpZcmNOQnBtalFnSWh5Q2tlWU1Lak5haHlsb042YUJMUDFVQ2grTFpYMUVsM1JQdGpTVTBQVUZESC9jSHk5T0ZZbjV2ZVJ0VGR6cW1tSzhxeDJMK2t0cGE2UVVNTThyZlFxa2YxV3JlQWtFbWQvSCsvSC80eC9FcWxDTTY1N01vcVl2T3ovSG1rVytiRDlmUkd0NE10SDBQYUMrTlVHUUlnM3ROYTlYZDJzSEdnYjVUdk5uK3U5azVFWkUzbWNWc2JwZnFsY0pwUGNXdHVhK3pNWFEwL0ZhMlpncWtXV2laV2xsSWthRFp6QW5JWStVeml0VFkwWmRrRGJPZ1h4UzJUM09DSEsrbHFVZG8wdURjcitsdXFaOWtPcmRYVXJjZlpld1BUVHl2YitxL0RwRzU0cld4a2svdi9tQVYzVzlLSFBGSzJJblA1aWVQSmlvN3ZCa0llazF2UnVwUSt1TFdHdGdTZjZhNlJrcVNUa201TGFNcmlDUkNlMHBqNmd4Ry9GaEpTVlNrbHFmOXNXYjFqQ3hkSkZhRDFSNWVyUUdscGZHd2pNZ1J4WUpPWVlpcDVmS3RtUkxlY3YrVCswcnJlcFFpem9PUGNSakVkR1JFMTN5MGJ2c21kVlMraFRNczRxUjNsMDVRc2czM3BKQXppZmlEN3hvbFlhbnFLSkxoSGZOOGljZVRxOSs3dWtTTkp5SDVFSHlXdWtsK1RseHlJUkFUUnMyNURUYzhSNllSR3FJczRuYlp0UUZFNjU3NFJ6eVVIb2RBa09CNzJMK3FVOWtlOTR5WFZDWnR4bi9QWXM0Z3RjSkQ0QmZUQ1dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJUkMvNjRPL3YraVg5aHBmOUZOZGRJZVgrbDlDSWtRMjJWdXdwWm0zWVVwUFVkR2Qya0tDVTRwdmFUQkJQZXcrVENIdERGM3ZYbExFWk9TSkxKeS9aSXYySlRyM2k2b04zdjZ5MnJYUEpRK2tHZG5YMHl1eTJRbTMzVm0xb0h1TUlydTllcklpMndSSyswOUplN3haTWxLQzkxamRmSUlnS1ZTVDRFOTZaNmRjN2FzK3NhOFJhZGFBUFl1eVk1SFVaZjlKVzhRMlRjbXVnOGZOWm5vR2o2MmhoazQzc3FFZHhlWTZKQXpYSWx5bUdVRU80OEI1Ny9taTZ1NlJnRHh0ZzJCbmRYWExtcnBTUk50MlpCa21sMFhTK2RJMTZ4aXhWS08wZGVGNjFORGpObmp1Z2Fxb1FJZTI3UDdBMFdTMzUwTmZTcTM4T05NWGtmTzk3UC9jTkdwdVZnbFpMKzlIc1BSVlU2OE8rKzRzNm5HdWFvYk5Iczg0MXdhVng0eDl4cjJvY1E4N0N6bVJPR2drb3Y3WFcwdFNtMTdRVzY5cC9DZnpwcXcyVE5IS3pQSjVzMHlKQWx6ei9GdFBsaFZhaWk2NFhqclBvRVNlVGJheVVVTTZvaUk4VllBYUp1aDBSd3h0SkkxSFhVOWtiTFZsYTBURHJOTFNVRjlEa1Bxa0RSZHFTa0krOUQreVpZMHhvUTEyOFhyaG10clVtZzRSeG9IWHJlL3pta3luZlVRemkwc1prUmlkMTFZZTFLeEUxNFlNbkE4YkVzcDVLVC9uRUNFQ3lNU1VydGRZRTdFQXNrZU1YdEJBMUdJTlNUdnZsWTFlMjFUaSs5OWZ6YkZuSkVlSUdxOW8yOWZYc3BMZUcwdFdXZDkvdDUvQ2NkYzRieXc1Yko1NzcrTTZFWDVxZ3NjaW9yMDB1dHkrcm5XRkNwTk5aR2tmSGVsYU8xaGtRMDU5M1ROeHlBS2lLcFNkY1EzUWVJV21xTHlKaXlpcStwampRc1VMZVJYaEdGMmZKSGxXSGJ6MUNTa2JkUU85ZWp4NnlMUWRyNEdhZEp4L3czZzJEV0x6b04yYUl3WlVJejl5bmhEWFZjdDIxbEpkOTl6QzZEaTAxcUdvakVHUDlQcWdpc2xiNUI4TXY1aEtDQ0dFRUVJVzhUQkxPei9OczJESWhSQkN5RVBoRWtnSUlZUThDaTc5NUZad1FCTkNDQ0dFa0NHZWFsRFNrQ2FFRUVJSUlZUVFRZ2lSeVAvK3ozKy9mNityNzRUMTUrai8rNStKQVJhOXFIMmF5SVpsaEdnc0hEZkljSmJTU3VsSGRnR1pEckpOUW5SK05qZlNNODI5bmQwSStZS0RZajdPMXBQUlhZcllSU05JZTdqVnh5TWlSelV6c2cxTTZienV5VWJxaUM1VWpjeU9BZHV6ZTZtT3QwK1JmQjJ2QTdKWEh6SHh0b0tLYmwvTEpvZFJ0UmE2SzFVeER3bkJpU3pQMFVWQ1NkZGpFY3hkbi9wVy9oU293L1JWYUlhK0poOURaTHdqMXBaVkJsb1hzcENRVzVUVC9pc1J0YXlteDdUclhyNVdobmZka2lGZFYyWG16VDk3dWRoK3hPMFhWWDlTYjJWdHYyb3FuMjlsLzlTZ0tEWEl3blhQbU5OV3c5N1ZMenRsemNTcTQreXlTSVFSV3lja1hPam1FaEVjM2EwWEhXS3JqRDFrT210NXBldTk5eHZ4MVdmZFp3cVdqNEFZS2xHSElWcStWVlo5SHNIcjF4WEduZGUveVVnZkRZMXFJdEU2Q09GSzJNeG9SR3BOYTliTnVSKzNlOXBLRUhKRlJoNVpSTXJvMWJsMTJSRjl6bmxIQ01DTUNhN0phbzUzbnpZWEZsekVoa09NQU1tQWtLNnJoVVFZTWVJa1dTVlFoaVducHNlUVJJUDhFV2RGcTBMMng4VVVlaHlHZGN4NnBxR042aFh1Z1RWU1htVkd6ZCt3cmE3SVFGd1dtZ1lIRWxGRFVucHlEVkJsMHFPbzJtc2t4QXpyWXpTY0ZRbFA5c2lJMUNFSmNoNDN0RmI3M09TU2FERlM5enNqbW91V09BVElKREtXSkxKV1JOTWgvb0dXVitNMnFoSU5QWGhoQWNJdnBoSkNDQ0dFRVBMNTBNTWhoQkJDQ0NFRTV3ejcrVXliL1NuM1M3K0kzSWdyRE9jajY4RHBTd2doaEJCQ1NCemEwVGVISFV6bXdoRkZDQ0dFRUVJSUlXUUZ2Ly84NSs4UGZYOWN6L2FIdjcwN2NLaEV0dWFZWGpoNUJFZHNNZE5SamJiSWtRMlNsaEVwTExwTGVKR1RXZUt5STRaQnM0Y3lZOWQwRXVPMUkxQ2p3TnFOVktXbUwybnV2cU1rTzhjQlNqdVptcDFXaXpYWmV2ZldqT3puYVoyWHJtbWp5VnV3bW5TUUhTRnZzMVhVTWtaR2NBbGQvK2sxZXhiSlh5R3laUk9GV2V2T2pPWisyQnE0VTFkV29pWWR1dUVWSVJBOXl6RTZ5QXBXWkQxMmk1UFdNNmM3cXdTVkVTbXpleDU2RGRDbW8yTjVTN0p6clNmMmlRNFp4Y3JtMmpLVHFKdGd5Z0x0N1FMazA3Ymo5Y3J3dnNMYVh2OXpYQndmeWl2eSs5L1dMOGp2ZnhHdnZLak5tOS9TaWxqcXR1ejZiRjJTdDdwWm5lc0VKdFVWeXBLRCtzSFJRY2lGNkNxRTdKTUJPK0pySFZLbXU1a3ZLMmtqQzB3MEJORDdVS09uSHE4RkdyMGZkSUcxVkVsYk5scG1xbVJxRkVXMnJUaHh0VFJpWVBUSzBJSy85VFVwRDlLdk04YU9sZWFWYnVSNms2NVU5N1hyWm1XT3E0ODB0UGtOWW4zSWZXZEd2Qys4TWpkNU5HZnorOC9kQjl3cldTWExJc3FBemlRRUFwbS9HYnp1T1hTZDgzVEQ2RnJuQlhwRzFnaENEdWZNQVl0TWNNMFA5SEFXUDJUUnJ4ZlpyejhWUldaK2ZiV3VRMk9RN0s1TCtiTldNU0F2Y2w3Q0RlUTQrVFNIcVZXU2tsek5pSS9Jc0k2VEVEdFNES2kyelBhQkdOcnZhbk1lWTVpaHJsWjBxZE9PRWRsZUdxMk01SnlYMHZ4S2ZackRPNitOUkdrVWU2TVh1UjhTSkJvcVpDZDhCczd5Q3Zjekdrdnkwa2gxZU9nWTh2UTFTZzdJMXRJbFIwYmJmUVdVOFVvdnBVTXRPYy9DZXdSU0o2VGtOejcxOUVjZ1BVcmRuRy9UZi8vN3kraFhxZXM1bDhnYnp6bXhkRXdiejdjdncrWkdVcW9nWGZQd2J1czI0eDgxSktLR3hRUGhGMU1KSVlRUVFzaU5vTXRQQ0NIazJYQWxKSVFRY2kyNE1oRkNBcHlwTXFpdTFzRzJQUjYyT1NHRUVFSUlJWVFRUWdnaFd4Z3pJNFFRUXBidys4L1BkMzkrd1B0M3hVVi9UUTJEL0VKWTIzMFYrZFU0SVMyUlFUdTR6UnE2NHd4U2hVdjh1TjZhYTlyMlBXM2VIdGtwdnBOYlNWUUpqMENhVk5HRnlkdkpncnp4UHRLaXBYOGZ5OG5NTHREVUxMc3BpclVDQmZkd0s5cGtReWNmc2tWZmNjcXdSa0JPc1JHQzdwRGJIdlp1WmZublNtNVN2dXpzbnBIdDNXOXV5azZic3ZTZGtVcVM2L2lUd2l0cmpZS045dStKYUZ0Qm9mNlBwZ3hIYnY5bXl0UGJsT3JkOUZrK1gzOU1MS2MrMzVabUJBa2hiWE9LRGhyUUIvVldoRWhSS3huWkhMQ1cwVFhuTWxpcHBCeVRXNkF0MHhIUUlZT1lCRWpJaEVNUndGSWk2dGRLMit1dDQxdjJzcVQ4VVAzYXdHR1dyK1dNNVk5ZWgyajloTzJ4N1E4azgrclBPSDdKekk2TTBoelhrclpucE53eUdVenZXWnFJREcvQlNXQ1o3ZlZYbWdMa0lUUHhOaTh1UW1JdHorNThsYUFJM1prRFhheCtpVkVKc1pUZVlWMlNQOVhRcVNXbFNVN2FHYzZZVjUvZXFSWHgrMUhiMHpPYzBmUkkydGU1aUl5ZU1xdzhXakRZbTFTU1hHUkpzTzRYSGMrTm1tNU5pZno5bnpZV0lkYkpxZlB1ZHN2V3BObkp0Y3daVHhlZ1l6Ujk2NjhzSkczR2UxSDBrVm9HbHpreVNnbWswWnl2OWpxeXB0WFhld0ljMW5sUHBwUWVQVS9JcGVneDhvNHV1ekVDekdOUGhqY3hKUU1TUkh1K3FUb01VdGxwZjN2N0Uvczg3bld3N0NGNitqT2FCakU4bmZSRk1jNkxVNWVONFNVVTdYNjZQaWxqb0Q4V2daalZYbXVqTTJpR1c0VEs3M1hOcERTakk5dTdMOHVNaUpaQkpoTHRlSFN3a2JWNHRubEs4VmhFblE1Um1sS2VWc2xrbzh5SGo2RVJuYXMxdVpZdVZlbWpaYUN5MEREVnF2bytBcTlUeUhKMjZzdUxZMXF5bXJpc1dsaGJOcWc3TFp1UFBCVFVHZWtjTU5LWVEzMlZiTWhvejF2bEpxQU90NkYzRFlncWh4c3JFMzR4bFJCQ0NDR0VrQ21jNlNrdzVFRUlJWVFRUW9nUGJYWkNTRCtQbThWVVcvZm1hZjE3NFAzbXA4NGQ2Z3hDQ0NHRWtCdEFvNDRRUWdnaGhCQkNDQ0V4ZnR2N2JPVGRtUzU2WWhhenRyUWk1QStSYlFNU2VBd1VrWlNpTGhYRzY5bVZDWldsWFFmRmRHUWxkNlFlaTczamt3UElSOXNvVlR2L3Vqd3dyNk5wbm1jU2FFcFYyclUwS1dtcjgvV1hnWVRMZjBXamU0MXFBcEM4TTdZYmsvWjBhNVdFdFpWaGNMUnRtcmhwUysyclRFNmJ4Y1p6Q2FYNHNUZGV0anhhU3M5TWpmYmZ6V2F5TnlWNnRnam1tclhCMnRqNTYvaVZ6cHEyQ2RNUUd1d1NJcUl0djVidEt1VzF6bnZMTmlCaTF1cHJwVWZuVkU4ZHBzOC9wSUVzODRvSzRhTkF1dGM3ajg0cGJlbS9WUHpuVTlFYVcweGJmdElVNDdxVUhnSFpwcmYxRDdTdmtyVG5yUyt0U3RlWGtMLy91eDNKbXA4Z3o0ZHQ0NWZkMWV6VW9DMHpLNUovU2tqUU9RdHR3UjRNY0lwbzJrSzZMcVhSRmlneWl4SzRwcnA5ellsZHlNVnlUbkpUbnFJcTNzZXBxYU5TdGxqeGxHekhTVXFQWUJtckdtWFMrUjYweGJzMC95YmxPR3FjYTRhSUpzTTZqOUNXZVhTYnpyeGZ4SWp6N3RkemtDSU9WSlduQ09kM3NRakFqTmlJYWVwVXZIVGZTWE9WcDAyajFzSHFrMVpuS0V2WXUrbGh1NnFTYWNHbGo2d0FIWGM5YTVvbk0xV3lMWnVnVGxmbjErcm16V1BPSlhJYnRNbXlrb2pTUUl6Q2pvbmJQcHYwcXRJNkVtcjZObDNyU0JpTC82YXVVaVd5azgrVEUyR0d3dllVY1F0aU1IcG9ocFZTcG1aSXVsMVVHWUZpbk1xTFJTVDEvTXhXOE01SHpFYVBVVGZYREU5V2FXWXN2NTdwN28xK3EzZVIreUdEUkJ1Ym5iRU9aS2xBRlpJMndZdVNYcE5qeFRPOFBObW9tNVR1SWZSWUJHZ29xYmN1bWx3SnRON1U1d0RvUEd4QjV6T1p4azdORFV4ZzdaRnNuZndQL3lodWtBV0h3c1B4UWhHYVloNVEwRjdXMS9WZnpYRlNqaEdaTGRvNmM5djFKbXBJSU9HQ0hNaDNBL2pGVkVJSUlZU1FSL0MwRUJSRGJvUVFRZ2doaEJCQ0NDR0VrSE5nZEpJUVFnZ2hoQkJDQ0NHRUVFSUkrWEFZN0NmRTVUZVU2bXNiZ2NVenFuZUhDa0kwME0zc0pvMngxNFlJeU01b0g0RzNuVnBQM29sUU5Ud1FiOWVSR2c2UWFldzJjK2xvMjFuZHdXNXQ4VmFjSHRzTjNXdEhvOTRYQjltSHA2Y01KRTl2MlUzNjNWWjRRcnNvaytLbkpjdm1lQTBscENMUFplWStnQ2NTM1htU0NtdzUzdnFVaFdPNm9HUVpDd2RSNTRvMlRJOHBmb200Yk04MjZxTm1CTGswbzkyNWNnNCtkcWhwcnN2SVFyMnFveENIV1AxNlJmQThlbjBCUmZqTG9sNGppcFBIdjk2Zjl6aTJkMndQNE9ocXFEa2FrYkpKTitYN1EwVFY4ZTVMZ2RXeDl6WERnZzREb1ZzM20rbmlvWWp1ZEdKZDNrS010SGZpQ0JXenlna3RuZGRXcytwK0xWazk5djhDeEpVQlhmSzFIZjIvUDVUMmRWa0pYYW95bGVNaDBHVm9WSWNnRDE4SldVVTBFRElpTzZyUFVOcEhOcHhMNU9PNWdsODR5OGhCbnJtK0Z2MUJRMEpOYnlhU2p5K3BTNDVVMkxNeEZMWGExcSsrYUM2MjR5RFVUeHN2RkVoM2p3WEZ1MnR2dG11dHNMSjFFSk9CUy81RmlBeXFpQXpTeDVteGlCNlpwSXNWSy8yc1NQOEtPR3dJU2VJempmS1VaeHJrT0dhNm5FRmpmY1VqajFtM2N5L3ZNUFdIZFZhOHh2K2hiTDZZS3IzbWNJajVRZ3VKekVZYVU1R0huSjFLSUErS0hDaDZIbFlsVmxmdXUrd3pxMEF1VGpzNHZFbHppVW4xYkt4Zy9nRnErY1BSN3R4cmtkTDhHOGs3U2hIS1FpZnFqTHFOeWpEeVoweHUvdjQvSkNYZXYyalpzUkhUMWhXdis4T0orQzRqUXpKUGxIVWova3pGK245WXByLy9hOU43K2Rua3BJc1Y4WTN2d1RoRDlFeTFkQ3RHRzRiS2duekQ0UkRFY2wxYWV0MmpObTBQcmVHQmxKa3R2K0tJQUZ0N0hEV2dZbVh0UzR6ZUorcm5hbmt0V2FQSFhwbXJIbTRnMFZFK1dKbEdwWTl5Y3l5bXE1aGlYMVVDNnBjbTBDa2JtZDRaU1ZEL0QwMGZ3WnUyVDJWbU8rVE9Nckx5djRpY2FQK3VIR3RlM2dWbGIrYTFzUHg2ODlWczJscFhKSnVlRlVLcW02a09qbkpTcVIvSWFpTHJYcHQrZEh6T3lCL1J4NFRjams4WTJBUEt3bjJvb1N6Y2toekpBSWt1OGxBY3A4Zkh2aUtJZ1RJYWF6Q09wYllPOXlPSzlVWkhYeUd6WFpzODRYd0w0TzdEekRRTm9tVnFqSVJieVFTaWZqRTVucWo5ZnpRNXhaVExYWmJmSUQyM2licFBLOHF1ODBaa1BiUjdDWG5qenRzcURndkppNlJObkhORUFCMFViYnJBdXhHZVp4WmRPeEEwMlp3RDMwUnNzNW9IUGM0M3Y1aGFqdGlSbmU5T2tLTVkzYjEzYmRZcCtUK2VNaVVKSVQ5d3dQZ296eGxtN0tZdWljNHA5dTV4Sk4zMWlXNS9ndTRwbzdWcTFwTnBSZUVYREhxM2pwbEJyNnltcmNXdFJmc01DYjNKSTUxUjNCS3pVVVlHNjNDZEx4QmRHTFRiME9rYktZdmQ4MFVaVUV0Rk9lOWtJOFJHZW5JVVhtOXRab1ptVm96cnliZDdEaU9WcGJLNEJiTzZjWVlKOENoZU9sTjZJSU1TU2QvdExyUU9ja2VlUTVFTXlRellQdkU2UzNsZW05MVlTNklrS1hZK0lpdDYzUHY2NHN6QXMremg3YU1yMURhOTdQUjExYVNsT1habG9jcS9LSG16bnVUcjY0aVJPaGhscVdtQlBLSDBrSTVNeHlJRkptZHhoYkRXVEVicm9LbXZNNG04clEyTWF5dTJrTnZ6UXRudUI4OFNoalNjcFpVQ1FvdWI1T1kyV3FIdDg0U0lUZGV6L0JLeWlsbHI0QkZsdC9seWM5eW00ZHdpdCtjS0JwUkh0STZ0ZzFBdHdCSERmNmd1aWlVaCtrbmVvdjRKZmZTSDJXMkx5Tk1NS3kxWjc4UElKdDh1dWVVQW8yWEl1V1pRSnAyZmxSZEpiMFZ2WmkzUFhsMHQwMXd6M1drMlRJUjIyUFc1OHZLRStOYWZzcnd1WnNiVGd6OGdzUlR2L014WGc3enI3UDZGc0hFdmlUci9nbzl2WCtrM3NVNmdiRDZaSXp0bU96eUJRWVdHMVdldGtaSHJ0MmN3cEdMS3ZJbGkrWTBreW5uUjNmYU1VQ3U0VG9oRSszc2RheHVCbExySFZpVGJwWWJ4aXVuTmVVcklaNkE4NjZoNW1RRGVDelB0dExkRWgxNkt1UTNJUWpTQzhWWlFFazRYUzg1bzJWWTZDYzFkMHF4dTdUNkIrNCtPdk4wRU1QclBtU3l2bDdQbi9QanpwODNsbXNrZDNWZUhaODVZa2RuTjBOdTB0TE1JdVQ3ZS9OYVd1bzU1N1QyYjFFU3ZVQ1ZSdFhhSU90UE1DTSs4b0k2OUZWdzZMMDRPWHJmbTd5NXZUbE4vSUlvNnlHZkxGSkY4bWJIWklhODcyVHhHZlpFNS9wTzM0UGJldjdab3RJK25lL0I4MlJsbGtKck56TWhONytaOTJ0U2svenJmdnVPcjVOc21TcnR1VlVkV1NlcUhrWEtWUml4bXBvcnhwa3drbkJNdGEwUTJHcGdjcmYvZERRN2svdEExUGRwR0dVeGo5V3UwRGtyL2gyKy9Vakx1ZkFUdWN4Y0JydktVc2l0eVgyYm4vYmU2VXFyTFBxRXRrOFk1T1JWTloxanBVNXF6Qmk1K3BDRStyRVAwS0NGa0lndU1IamUrRVp6b3VjZkErajdPMnZVck1NUGdHTDB2MUhCdXIwY1V0aFAxNzlMNzBiTDdpVDQrUWM4bjRUcFMxa3lUb0s2REZMMkpMTStvZWVISktZcE1tZ2lESUlNSENjZXlFejZicUo4UWtZbm00eGdhSmp2SFIxbzdDNnhJMGhKZFlCbS9PcHlaVFo4YllaMGhZZFcySTBRRkhTZ0JCMkdGMmVHQitpeVBKVHZYRUgvaFpteCttUHIzL3FKdU55RVhRNHFxdEM5NmVQbklxYkFyeUk3VzhPSWd1UnhJNExwMTBwN1ZqYTg3UHRnY3Y4WGN1Y0Jqa2RrdnRFOUVlM1JwSFpOT2VoUVhFdFdhTFpQc29CbEJEaWNhWExyZ29KU2V4Y3lPbVhFdWtxTTUwZ2ZoK080QVZUS1JweXF6TzJLR1BIUU51UGdnV2wzdEF2dUJaL3FLYllTRGo2TWZ3Y0p1Zm84azRVZGZ2WE91bkRrMG56WXRlTDliYmhyODFXNXJhZGNiYlYzaVdickxwSDFMYnNYc0FFWlBuR2RXYk1oNkcwMTd1WTJtS3lHTG1SVThtQkdaN2ZVa2NrZWVJN2lEQXRQZWxsaDRYeGN6NUk0Y3piMWxqY0pua29UY2pPN0FYT29yYTJSSmtCN3dFcE03NkdtNmVPUk96SnlUdXkra2FvWGxuL1JaeU1ENVJhWVJlTUF3SzNSSUZoTHBGR214dnVGenROL3l1enlMNzdRRWlqcHpDeEx5ZVZoeE95MnVoOFpjTzhhZVpwQmNhaGhyTC9aSjl6MWE4WUcydEVSU0xkd2M3Y0ZwellLeDlYVGVUUnBvVXlUb1gzZmo4d0x5M3FvUXZhNHNlcVc1OW5xcnNhQ3lwT3NqQmxudmdsc2ZJNk5Ma2hIa0haRVErdUw5NDlTZit0VmY3OGxMdjVUYXpwYWlYdjFKSTZIMXMrYnhlbTIvQ3M4TFAxRmpyREE4ck50OTRMcTIwd0ROdEh4LzdhUE5rTnFNMjh1djlZZE5UYWJUMnFpV1Q0clNqR1BMUWtDZmVmYXU1RDF6UjF2UlUzTittRWhiZTBzamFuYVFqOEN5YkdldEJka3BhL240dnhzakpyMlp2bEtrVXhxL0VkTDFLVUwwTVpLa29IcXhaZmhld3ZiTXRydHljNzQ0TlluNFIwV1ZNb2JuNzJxVUNUTEk0WUFobGJaM1JaTkErWkZXNjZPb285dXlONVJ3UkJ2T1FkWE9KbDJ2K29ndVlnVTRwOW5OVVpYbnFZY0Nwa1hDVFZtUkxiVlA3OXFWbmJMYjh3alJNSngzSHVsZnFjMFFoMEc3WDYyY25qUmFHZDc5U2lIQ2hLSEZOOTV5R3QxaDlrVVQ0MGpabWQvbDI1ZERROENHWDVTejBieFd1L2VHd3JYMGtUeUVqSUw2RDlZY3NwQU1qMUd5Y2s0TGpwYkVPVVZ1emd4ZldwSjV4QVFXSnU1dURhOE5pYkxQcWprT25oMjZFZFErZS9ieXJGWXFpQUtMT0FwZU9jbVJoWkk3cjlWNHhxeHkyUkkzdWJ0V3piaWFXYk90QU9kSHl0YmMzaWllU3haNUpLTEZPYUttT2FsQU94ZnRPSGJHTlpnMWdUVzVxTitBNkdtT0ZST3JpYU1Xbk5kZGthN1E5SEVrdjFZWGFkZ3dwQ0xnTGJEdGVUYmNZY3l3Sjl0WWFHbjZjZGVkUW1GUm00dVFMOUE0L092dmVqSEltR2pQakRqQ2RIbk1mUENlbnlYbHVpYkxDbWZjckZGLzY1ZStXeUxQSGF5MWFQZmhKQ0ZSdkFsYzB4c2tBSXErQllpVE83R28xRmtjVlFmNWdnUGhjclJMZlEyN2F4VS90dHRTejZNdTY2NThiWUhscjByV09QOXNHRlo1MDNid3pHRWZlVUhwWVF5TlFHZFNIcUlpeVRPUUZvRlpnK3RpZzlKN0hqTjYvaExjYzBFbko4QTFaZ0VsZUl6SW1FVjVpdkxZM3FjV2ZyMS9pUDlNRC9DKzNpZlpNdXVSeGtjeVkzaEhwd21mVFJLUEs2cmU2a1dxNmNPM3ZkOW9XU3ZhaWtzZ09ZUGVkd2g2ZkpOWkV4bDUyTTYza3NtaldHSGtuVFdCejNpcTBYajZsMWlQUDlWNFA2RGh0Q0drL29KbWZuMk9tSEVyWmFMbjBhWCtpRmdaVFdSQ0ZyQnl3bHJIU0I0dkhSWENodEo1N1c0d3BFS2VocmFoNSs3THFad1U1SU00T2hwQVV0eHgxR2dkd3dmb250OS83MU54aGZQQ0Z0Qis4Y3NaUkVhSi9EaDFZZEUxMnE0Qmx4amUzbFk2STdMYTQ4Q1BmQVBKeVJOQmcrb2tUak4vYzl1MjMrZmJMOWhKanQybyt2MXNYVERqQ1g5UHZ1cHRvVmNkU3ZXM3VqVlVDOUxxMXZZOVJmZzdPMlZGZXJvdHU1WFZTVDJndjM2YzJwYTVMeXVMZGZ1NS9uTTJmNS90cWFNMEVYVTVlRmxhSFNPc21LbXp2THRCV252U210YUtybFN2RTVXZG0vaWFscThUU2x0R3ZnaWthU3RDd21pRHlWYlRMc2g3Sk5aclNsS2VVZGV1UHRlZXZ3U2FIa2JQYStmSVI5SVRZdlM2dnpPODRjcmtzSnZNem1iTENmcWFhUTQ0dXJ2clRwcFdqdWFUZFgwR01ZcHR1MmN6WFVuN0g2ZVc5MysxRis2eTQ5ZEcvS1EvYVY5bHZzNW9LWC9xWElQTzlORTBFbDZkRVVieVBnalBOMnRPZjQwb3Ezc0VZNmhOWHhEalRicmVuSHVwbEs4NTVZVlFXakdLYWpCVmhtZmNSZXdvNUxvbE13VmxIdmxNSTRISFNCbXZmS2lzbnJhTzlpc2lFN21PbE9IMVk4L1NGcTJMZHF5TWc5ZThOSnM4SzB0OWMxOXdXTmFhRjFrNXJCYmdZdVRMWHRrdkFWa1dVUVNkcUI0cnVqRkhkR2RXMHBCbkV0RkRQZWtSR1ROa3pxYW5UcHhUaEN3R25aaVJDVnd0NWwvUE1MVmtHVHV2K2h1dFVWTVpCcmt5T0NCNmpQbWNiQ04zbGlMdWFQdWgvZ1R6cWo1cHhvdmFaMDVqNzM3MjVlMXBZVFI5cEl4ZTJXalptdXcyVnFhbEc2VlhIbWk2cStmSkJEeC9pandEN1dIc2xmeU5HNEUyTFJxdVJPVkV1ck1FcjY5OG9uRjcwRmdvT1p4WkZ2K1hMT3Y1U0YyWWRwejY1aDE1SUFmb0VpMU1xVjMzWkZubUJ4SzZiK1hkbWw0SEZ6bC9NNzYrbUxwdkorV3BFeUdmUWhNakpkZUNRUzB5RFFaakxvZGwrRWE3Nng3ZHUxS2pBWXRkY1k2UHFFTTNubHhHWkYrMExkWGJLb1hHMDVaMmVEOVhrZDBXZGc4WlJ0TVJpd2JYVmR6Y3k2aENtZ0lFWk9XOEdSbUNITDRMNlBWL292bVFMNlZhdndycEtUTlM5aksyWmYvOFVGUmJFdk1tNS9aTVgrbXBLcDJRcVZ4Z1NMMSszTmJ6enZEeThBOGg1SXRUWFJEbHhTanB4Nm4xZGV0WXBSSmNqQ1E5d1BtNDFKT1dNNElSbjdEQUlyOTFhdDgwSTRRc1psVXdBa2t6NkgyTEczeFpjWWlJZFhRSFpiUzQzbWpJWjhSQU95aXNOUE5IT0ROWVZVWnhyczE0WjJhVWtjZmNoSkRGOU94bEVFMUhOdlJZTHIzTDVrRkxMaUczWVlWYUswcXNOS3NuYkRpbnlabWM1VWVRQUZhalBjUXcrTDI3eTFLOVNibnFpNm1SWHd6VGlDYTlvTnZYZEk0eGE3Y0FiMmVDU3czcm5rcHFYbHJuQTdxaGp6MFE4Z2V1R1JqSTh4N3YzZHB2R1o2Sm9BWGE2K3YzcE9laEdwcE9VdGlCSDZXNnNzSkNCQm5XYXRqVDY4aGJGV2phT3IzenhDNGpTaVdiTXRwWHNIOWFQSDhmOTdUSGF3RXVqZlIyemhXekxMc09hTDE2RmUrSEtlenNISS9LNXJvVlJ2dkNTTWlPYk42dFlGZVFMaVFGUEdrd2Vkc3lXSGdyL0tnV0xvWk1KTzJNT3BqQ1VPR1hkdExKS0lpRkU3VWlaMWc4ei9DSERnQTExWXVYcUFZTWFMVmZTalVEV2tYT203UzZGYUVNS1YyVHRsZ1J5aVRLK0ZHWlJVbGx0ZHRXNGVvL1R0VTlvbjRrR1FWTWgxeTNORVY3WFlzR1IyWE5kRERJRjJDVGxpeG5OVDgrdFB1amthVjA2M3RhSjZraTJ6eGV2RTI3WHNBd1J3SFZYVjBuS0cxOTNkTFQ3ZFJCWmRiNXBiSVFlV2paWGh2MTJwRld5Q3dwWlhqMzc1VVRrVjNBNnlQTUNCVktNcEdsc0w0dWxhMHR5MGtRMFN5L3V4ZWNuUHR5UDVZT2pqbkpKVVhiR1BwWWZEMG1rTDVxeDVDbmp6T1lMN0w4RW5KbHBQR0t6QzFFOTlmcG90Y3NhTEtTVzlNYlZQUms5aGdpcU9qS1dYbDl2ZFMxSXpRSG9wS2JoRHhmWmRVRzBYY2M1T3ZBTThyYlFpTFhvdWRiZW8xMUM5VDVRTk8xYWNvMnpWY3plekdFeG9oN0ozTU15VktNTXRhRG1wVlN2cFQ2ZTlQcmdXaTZhTmw1VUdiUEROUHlvaVo0Y3M2VENsVDF2MEQ5Zk84QkF6a1h6VGRkYlViTVdOYUkycFR0Nmp5RE5yUXkyNklwZ1h3TXFTaDQ4NWQrOFdtTXFOYm83eEc4UnhxRXdNeXdDUnlSSS82QmxoWmRUeDQvSHp6YlhVTjhtSE5QZnUzdVQvUTZKMXUxMU5Sa0pyMHZFRVNzZllIcy9IdGJPSC9KRldqbjcrQjhmZ3dIenQ4VkFadlA0bVJseWZrd3lPYzBZTTlJbzhvOEFLU1IyUW1uNGJrSmhFQm94czVKOXRac0pEV0d1dDQ5c2dtNUc5NGNla1JvQlozbzBYamRtWGJXTGhaUjVwY1ZVWklYVUtaeUZiSjZmVHljTS9vNjN3aVBqUVkvZ25kdm52RTJwaUZibTBQdC96emU2WTRZcmxjMDlEaE55V1RPSGxLV2J1aVZGOHA3NUJMSStVdnV3aFVEa3FQS2c1Q1BadHc3bFdWR3loeVJQV25WTDBxZFhvNFJ0QTUvb2lLNWNuMnJSaDhlVXMzRmQ3K2VZMkROdGxWSFFvU1IwTnZJY29uK0FIWUY2RDR4WkNFekc1a2RkaTJpenpSNlpFYXZFeGRMbjF2dk9INnl5OFFuR3VTcDFQdnNFSElxRThiaGlEOUVKakhpR0Q2c2szNy91ZVBkTGlEdGoxSjdHeEhkbVZHYk1ZUjRsT3JmYkp5WDN2NmJNTVl5ZUh6SjRhek5VNnV5dlZ1M0tmSE9UVDkxaUthYUlLU0RhaHN1U1RWcUU2dTRKeG81VGJLUzhPRDN0ZWQycXp5aklhdjJlZ1J3YnpQb0FSUzZsNDRucHlldmhsWW42VDY5ZW52MzEyeU5sYVh6SmUyK2lQU1ZKS2YyUWUzTXBkT21PR1hrNy85dUY5amMxS0kwNTR0N0I0aXhqczdnbTY3ZXFEM2xxUTRhTjNzTlVFMjkrdmdOb2pwYStXeG5Nb3Q2M3RiR1R1OThic1l2c3I2Z1d0bzdQNHBsNnkyejhTdy9QM3BNYmdFUzVtaXR5WmJvMFBCTUFDbjhvYzNmVzVrQzBnMWI2U3k4VGhtWno5RG53b3p6VXNHN3I1Z0c2K0RlYUYxdUVjNEJSVFovL1RSaHBCR0w2NTJVNnIrcE9hc2ZvNzUyZTk3cW0reVVvVjNYeWtMU1pxY3VWaGtTaUxhWTYzMCtpVjJ2NXBpWmtSUVZBcjNycTRXUTh0WjNpZTd3N1pZcHFSRFVyNVhrdGVsTHN0V1d0K2hwcWdBMWNpUFR3Vk1KMm5sUGppYWpiUWNwajNiZHF3c1Mza0dNRlMyL2RiMHVROE1iVTBnWmJicm9VdWpjdnpjTXZxNjFJY0lrSDdkbHVGOVc5Y1ppYzNsVHBuUGY3by91a1g3TGN0YlU2RXg0UHFKejY1VUd1RTlDd3N4MnlqeWpvU1RibEpNTUVFOTJMNUwrakpqRmhKQTBMUWpzTHNqRnNIbHlJNkpzajVPU3I3V25wUFFaTVRvajkrOHB0aG1Vd1BuUmNsRmpYbk9ZMHQ3NXJOdW9OZm8yUlNoOUkzNUJ0ZW5nOEk5UzdYSDY4Nno1ODlDR2ZnOVM2MlNsVExSc2RPbVBsbTNKSWgyTStqOW9CNU4xUkphalVYK2hsb09XNmRXQlkyUVlMVHc3RXpRa2loSnhEK25tS1VSamlMTjhjVEtWM2tleVB5ZisvbU10MDlyOHBUb21YMGl4djVhU2RLTzlIV1NMOGNaeEMxV2hnOWNRbitnb0QvSjdmNm9lWmc5c0VmSlp2SVpyVnM2bnBHdEdjanBlM0FYSlN4N0FMSytjN0hpcjBFV1c0dWg3UVorSnRTQkoxMGZMRWhiQkpYTkdXbXdUWHFlbFpTN2tUL1FpbjF5SEFGcTNlNDlHU1lEUlJvdDQ4NlNQOWhsN2M0cG1CWmxPNjN1T0RMYWJEczVsdDhVSlRTN0VqTmZlYmpXY0xiZGc5bzJlOWY1aWo0eWg5amplUDdKZlBkeXo5Z1VPNUhXOVdhVmV3QmZkNFZtMWZBUjRDNHhoUER5NnJ6aXNWM0xHL1Q2dGpjL2t4TGIySXI5VEFlNFRMUnQ5VnpyQzZVT2U4NDNNWUxWdkVuRUkvNUFUL3NZWE1yRTFjNUd4RkVJbU1kTUg3YmtXa2Uwb2thL25vZlVKVGFsWXlxUVllUk1nRDcxMkk5QTRsTmUwMFFET1JPNjZwSGhkWS8yR3NEUnA2L1FyL1llWmIya1E4aWhteFA1WGxpa2hLUnRPL201NnUwTmJmcy9vQ3VwL2NrZWczeENNVHVBWDFROVVlK1lTNXg5eDhRWVhCOUZuNHIyc2JaMi82ZUw5Vy81TjM2Ky9iVlgrK1Q0UnZITk9FSElrU01UbkpORDQ0Q24wQkNVWHYxaHRWZWtDM1VuT0pDdkhIQlREN0RiT2ZKMVhqcE56M3RyY0JhNlRJT002Wk9jWXlmTmlSbGhLeVZ0M2JKSEtiTklWVDM1SnNsZGVuOC9OdjVJTXI0eVdBaDRqMXJ5UVBpdmwxWjhpTVQ1bmdJM1I3ZjNGdmtLa3lmcVJseHJwTmw1N1dubThtZndBaFR4YmtkRzRFWGszblRBZHR3bWF3MFpkNVRad1dMWmxzT25KVkt3ZnAxb1VYNnlXcldkVmphQ3RvRzJhUStkU2EyRFcvNkltUTNzOHczZ2xsMkZrL0xlVzdXZ2Qwa0JkYm9QM1luU2RUcHJma3Z1aHliRHFFT3FFeGdCNW53YUV0SjhzMjIzVFc3N1hpSkZSb3Zsa2FxV2FmTG1SVnI3UDVpWTEzdGg1NTZNVXBadXpXR1piRjczamszRGQ4ejNSKzVEU2UvVkl5UjY0R2NnZlpZWE1EMFpyYWkxZDJxWlhlMXNZTHNXTG5UWFhWUldDaHBDa0lSaGNVTVRSajA0RlRaaVdya2R1ejdTMDBrV3Y5WlNWbE91VzZ2RHlhb3pjdDdZMGFQY1pIRnVoTUo2V0IyMXJwQ3gwS1d6ektjZFpLVHM3Ulh4MXYyTkdxRjgrdHRySFc0NDBzME9UN1oxUFAvTGF1cllyL3V2ZmpKYUpMSzBvRDE4Q2lRSnV3bDREVFgvTkd0L1NITlI4TDBKdXlTY29CY09QL0pxdjJvUXRob2k4UzdMTExxWXZUVFZLc2xmL25uYVYrc1F5OUVSTFkwS1pvekpteFNMYVBJTHh0L3VpYXBOUGZZQ1d0dGVIeU03eG5CS09tcWt6UjI5OTNpdWpIczFvQzJybXRPZWJTUG01NUI5SU5ON0J6cmttU0t6QnUxNFRVVHlvb29vb0pySkIwNVZhT2tUL2p0VEZlc3FnMFJOQ0lnNmNVN2VpamZGR2ZzQ0todVJYNmdieVFVVGk3cHI3MXptSVpvdzlyUXJlK2NlQ05vZ1V6b0Fmc0h3MlgxOU0xUlRtRjBmYzhKRlJCbkkvdEpnbytUallkV1FINS9jYVh1dnVnalcrRlp1YklsRVpaQkEyNGlEWUJMbVNDV3ZWaGNOaGdGNWRHWG5lVEpZZ2ZmQ1lUVTZtMDc1Tm9PbU1EM3FBZ2M2VFBFRkdtQlUyN0EwRGZlUWFjTTFSNkRHZ1J4b1RmWG9memRlQzZIN3YvQWNTQ2RmMDMvWVZGSFUyenEvOE5RRTVoWldPdmpHY1p4ZDVDVlh6RkR1TDlpUkpjMVJIOUNVUUtVMjBMUFc2TUs1UE4yMFdQdE1nTjJIR1lEeHlBYlYrc2FKZGo4aHJRZUpYaE55S0t6dmZQYXQrejg4VGtLb1VSUjlJYjFEV2IwNUc2aEtGaXVvdnd2MzNyZzBYYjhxalp1dUlQZTNad2w2TWJHVVhhTFBsU3U4eEVQSnhsTVhYVitUVlRBSGEvVHVlOE80aXU1MDhuYkw3WTFDWU1xazQxMGczQTI0dmwvZ1RpYjVRcC9YempaMjEzL0xwNzd2OWZwTjMrdUN0R3pNMy85SXJKaEhhWDQwajQwZUw3MDZxaWxRVStpem9ZNGUvdDJOTXNiTzE2WkQyWUJEdEFZek1idzRPbjZEREZKbmVtdkg3MmZPMjE2U1hqSjdlc3J6ejM5ZnFyL1MwcUY5STlSNVlTdWV0M2tka2FXVW5KZDhyalZldUpGTTVObTliRzYzYlIwdFp1Zjc2NG8vL2hkU0k0ckxybE45bHZzNXU2ekpHM1ZoSFBpSThVV3UwNjFCTmRMMngwdE9va2QzRHBzMnowZ2Zhem5hbHVoWXhJMmhDRUJoSlIyUWozVUFSTlpvMThScS9RWmNzQkdMSmpQakZwakNwalMweksxSlljWTdKNWZBczg4aHdhT2VPWXozQ0ZpNHhHRjF3ZTVTS1d1WTJCdjVqV0lEQ3pZNHZ3Zk5hR2EwUDUvbGtlbG10WDZEN0MrWDcramFkNW92WmM2ejFVbnFRWnB5MDZ1bTEyTXFKUm15bGVtU2xMbDVVUmF0TGN2SWhhVCtRa2R1TE5KMlFYaXU2dkU2VS9mWFc5eWhOQW5XRTFTZUVZWWQrbE5uSzA2WEdVSDNzaFVjc0E3UjM2dmRPMjJnWmtrcjF5cEpVUTFIeWVmN0JwS1hDekR2elBsRzhzWVhlZDgvNDFPNjN2aTZkMStUYVMrQ216UGVLb01VcGxMcnNpakRpSERrNFp0cG5jRjRacGt4Qjcxam0xZTcrWnN6akd5NkY1RU5BSGNGZW5WUG5iL1hZaXJuRHVVU0lBRExaTkNQSE0zNml5cUpVQ3lkQ0VmL1Vrdnd0c25JZ1dsdTIxR2xhaFNRcEtLL3c5anJhMWxLWktLaXhHekdLb2dwNVJJRm51dzd1bDFLVGN0M3F2MlNYdVFCclJxVTB2cXpXZVN3aWRSaVJOUXZQTlduTExzbFhEZEZvRlJuQW1kN2tRNW01N0xSNVJzdCtLS09yTUJwYWpjcnNDWDFaUkZ6VURKeC9ORjVqdHVsNnpDc3lUSzkzSUFwS2dMREtSZE5NYmtJMkxGanJaeTcxelNPTjNYa3RmVnVYMnpQVG5jOWd1cHZ3S3hGQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUFMdys4L1BlWDkyTHBjbzM1dG9MZnBwcnZkcll1N3FRbENrWGFTc3JjSW1GOXNXM1N2ak5Ld3RjeVpUZjcycUxpdXlnUlJWd2dPd092ekE4WG9yakMwYTMvUFNhZHZvQnd0NjlvMjlKalB0SU5UNDhjNDNLNUQxcGRTMm8zY2l2SDB3amNHamd1NWpHcG5RVnQ0Q2xHVjhjbUFqVG1tdnBOV2hWRmZMOTltOE9mNUpuUnRwM283QTFtN0V0WndlSWpQYTIxUDFSa2E3MU9SRk9XN3hwaExaSU03YWR1UG5OZzg0eEZBejRnWWpsbHdGVDUwdkxtWjBuM1prTlNyQjY4dFdCa2w1a0VjeDB1M2VraDQ5VG9IcmVmRDZMZERtcjlTcG1wc1EzV20wQUhuY1R3OG0vL29xZlZSMmYzU1QzU3RiWCtZZnFOR3p1WEYwY2VwZHdqNm9aSnpyMHZmNXBXTXZuWWRrWFdZampYVGNNbU94K3dDbkJLMGEwaHllai9aS3BzVy9ERG03RVpLVjgyMTZaOXFXS2sxZEgwbjFlR3FxdlM4MWZWMTQxSytkdVVoSjRZNGFkUGlPMWkweVBiejJLRTRlVGExcGVTUHBWdXpRUDlMZlNOdk1JbnFmZzQ1VE1XVG1WemJIak5EbW1EYjFyUGlHU3F2N0JGbFNPbWhaVm5TZ1ZraUpMb0ZTbWRHOGhNd0NOUmNqd1pxY01GUFhreTNsMTlKL2dGbEl5SGxFREVwMHNrZVZCTExxVndaRGlkUVJOVjRiZzBSTTR6SERkOVdVWWJUc1hzTVpNZHE5TWVPTkJ5TmQyNzl1TTd6NlRWSDByZU5iRzJiWnExUGVKTU43QkY5MFppeHhYbnBySkJnekRlN0ZwS1J2ODJnamJnYWU1cER1aWFiQkFXaXFRMHRIUG90VnNZaFdOcEl2Qy9tazQ0ZGhQOUdRMDZGV1NJOE85VUtFYmJxNlRtMSs2VGdLVlk4QkdvZlZqa21ZU09oRjdaYWN4RWUyNm55TEdwYUpYVTJDekZMWUNWOGJScUliVnJqeWthQnJnSlRQVW1ZckhjT0x3QyttRWtJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRaVB6di8veS9VdTkwOWZOajNGTDluRHFuMy84VCtHa3VzbEdZdC8wSElSR2s3V3RPQXZsQisrZ0cyRk5CdG9CRDI5UkwxK3dVN2UxMk1uTC9oN1loV1Fzd3B0alJRUUtLYWpjL20zbU1Gdkc1WFlSdVc0UHNySXJhVW9OYjVSU3I5YVg5cEt6emJiNkppOEZRV2VnK1BlQ0tXL3BHYUd4ancveWQ1NGpaWUplRjlhWTFkbUozSHM5ek1TWU9OVmZtZlpUbk5Md3YvMmpVNmIwZGtRbnA0b0E0eDh6eGlhb3RLNXlEV0RoTDVsU2tNUG9IajhiUzkrMzExV3NBaHlESXFvYUt4TEhxUDFERHc3cnVmZlp3VjdqbUR5WGxlcHNXR2RteWIrbjdDMVpkc2l0bksxUHpVWEwxWDF2V0h4bkY5YkdsNjU1MmFQTjZEeldTVVZhVXRzejJ2SFR0ZzlCdUQ4MzN5b3NQYTdpN2k5REUyYm11eW8vVzVaV240TWw3aWZwUjI4ek44WXlIR21qSUNKa2FvM1ZCMDNxZkpoaWhaK3hFNnhDMW4zdmJ2SlVaclp2RmtZWlZaOXR1ZHVUMzVoMW9BbGpQMGRxdkFOVG5VNTBlTkdWMmRjNXF0YmJwUk9GcGpLZ1RTc2dSekh4OE1rcFBXYjIyRENFa1NLOFJGUEJGdjRwd2pJQ1VoRVc5eU9rOEk3QTFRTHJvTVRBdFIzQ0ZJVDR6ZmpQaUdDbm4zOGFhVWhiYXJlL3Jndkc2TFNCZFlYSHczS1dvNmQ3ajVzOXlnNld5MEJhT2prQlBGczNxeFVTWEFqQ09SUTVpMWpJenMyeHY0bXBLMFZPaVZwb2I0RmxWUGRNMDJsd3o2akNENjY3MEJ4TnRkT3JoejZReGo3M0h2THQwV1JaSis0bkE5RHh2NlJ4VVBkbXNOUUdwV3UrYStISDA5S01rNDRIS2cxOU1KWVRNaFpZWElZUmNEQ3BtUWdnaGhCQkNDQ0ZQZ1A0dldReUhHQ0dFRUVJSUlZU2NDSjB5UWtiZ0REb0FOakloaEZ3VDZtZENDQ0ZrS2Q5ZlRIMGZxZ21IdnBqcXBTTWtTblEzM29WamJVVDB6RjNXWUtJZkNXalQ5TzZRbmZhN0wydXlxQm9lQ3JJRlI4dlV5VUgrME83RS9qN2ZISTgyL2YyNmJNYldkVDFsSkgyM1dxaVJ2ZTN6WnV6bXFyWERTTmtvaWl4MUxjektkVG1EM0x2dFYzeldncW5Lck9TZFBiUHRXcXlUUFJsa3k5d2picWZYN3Zwd2VyK1FPbU9IWkVLKzZOMjVic0pnOGx5MUhtdkRrOTNMb1hNSE1TdmFkSVJVZUVNb01uU2k2ODNqWEZaRUlXbnBXMWE3Q1VjRTlMN1M1dFQzcWNLMnNCUW8xTTdoUzhTK3hSRHhlN0tTZC84bFZhdDI2UGNzUE5CNjkyd3JYNExueVhLYXB0L0ZwNXRrK29rQWdWQkUzdjBocEFkMHBiY0QrQ2xFRE5PVnp0bmdNNDBsNGF2UlR6UDBoT3ZRc2hKUVJrU21OZkNQaktrNDdlSnA2VGI4V2c3UUVlMXp0SjZwbzM0OGJRUm5PVmJEcXkyZUF4eUJ5eXhaelVyZlJDb3JJamM2N3FNK0d5S0xjNDlNNXdoaklWTDJTbU0xQ21qa3FGL1liSzRuNlhvMG9IT0VFdWcxVnIzNFJqVG1BRGhuS2gzS2ZYZmJta1Bybks4RlhVQm5veTA1MnN1Uk1udkxRRFJHZlp6VHRkemZYak9DUzM4SDBWQWhHL3N6T2VPWkJocS9laWk5Rm9TVmQyVVR6MXF2U0lEZURqM2FIQ1pEYU8rZnRlYXp0eXhiYWFsMnlSZFJuVklOcnEvbkRvMm95TktQVnFtSHg1b1hNdzBKVGM3TkdwTmZUQ1dFRUVJSUlZdDVsdHVkR1dZZ2hCQkNqb2ZMTHlHRUVFTHV5Rk5zbktmWmNyUmRqNGR0VGdnaGhCQkNocUJCU2ViQWtVUUlJVVNEYXdRaGhCQkNQcFg4Ny8vOHQvNjk5ZmVXQU0xdm1uUHdpNmtlcTdaK0lzOEYzVjE2d2RnYjJTdXZkRjRmd3R2Q0xiTHRSeTBEdWVHWHFDS2Vob29pRHlDeXhRd1p3MmpyNk83cHJ5NzZCMGlqRlgwdmtHMU5OTVhiczMxZTNuYmFidXQrYnhMMTF2RjF6VHR1ODZUQWRTMFB1dmpYS1BlTkRQaDJXNktkUExrTnRhK1NadlU2Z3JjbkVpb2IzVU0yR2VtMC9yYnlSRmxreEdsNFRUdXkrOUdJUFhWanJLblY3bHpuZlVsMVp2Y1JZdExqQ0FaRm83dHRKeUhkekRLMXN0SHJQU3Y5aGhIbm1qd0t6WEp0cjdkcElzTUhzWTZUVU03dGgyaWtZVEJUMXRoK3VqbGg2Z2pQVHpvQjBhOUl4bURwcTY5Y1JQNitOazltTFJ1VHE5MG82cHYwcmxBV3hVay80Z0I0ZUpxcmh4VXlMOFRJenVVMWtsL2hEQ1UzMUtLY0x1Q3dMVXFaRXU2YU4zTll0ekpteUk1TzJ5T2ZhWXlFeUZiUkd6cExRRDVVTFk4WU5haWZ0S0lNTUd5MTYxNGxGcEVBODBPcVFpU1BPY1VDcW4yMnlhT2FVZHBZbTJFdzl5NWxOMThLeVFHZzY5U0pqelM2WktGd0RwRkhFZkZSZXcyczFjYWM0OFNNc0ltcDdQNUkyUE5nTCtBendvZ0JXY3RZRWZXT3hpS2tQT0I5YVorc1J4ekdQS01mZmdyL2lUM3BvS01iWmVVempkVElIbkZGVnkyck0rckFwVDlBNzZDcXI2ZkVScjhMMFpoS1V0SzNlUVB4U2pHL1ZCYkhXamNSYTdFKzc4bWM0UjVHMDFsNUhrdnZQQ2FIMHZ0NEYvMVNLaVFyMmVxWlE0U0VNWjR4SW1IMnJJZ2JpVVJvZGFqUGs5UWZuMzJBMHVBWFV3bFp4T01VTUZjY1FnZ2g1S0hRQ0NDVDRaQWloQkJDeURKb2FCQkMrc2xVSVlUMGNlYmNlZXE4UGVPK3FTTUpJWVFRY2t0bzVCQkNBbEJsRUVJSUlZU1FENGNtTGVuaDkzYmdsRlMrVGxSbi8yd1ZVSnB6dmZSc0prZElMOUd0WlNhTXd3eFc0WlFoajI2RE1MTExFbG9IVUN4VkEzbURianRGdGpqcjdvd05PQ0lidlgxR2QvVnVkZFcyWmlSL2RKdThKbDM5dGZ2WEZsSEZrOW4ybkRiSjBEcHBaWlRVdHgyK2x3NGRUVUhsMGU3MnU5dHVxK3h5NS85cjgxS3MrOFJxcGxlb3FEWElxdFNzU0h2dFV1djFleTNQcTJseGpqMlFjWENpOW1pSHNiZmRWRkxTSWR2MGZvYVNYSUs1ZGxUcXJUNk9JSFhQZzV1YnJLUnpZRVZXN1ZHdHE0SFlkT2lLNEZrWllTUmQ2NWtaVmw1eU83U3haM1gvckNIaGxTVU4yMXVpemRNSXRpbGJwU3RZdWpadFNXbjQwMkhSVDdtLzB0VFhpekpxVkJFOVBwbm1SUlV6emQ1ZjJLYXc1MVJSNnRGK1NWVkxaMTFOdTVyR0pLRDluanZUekpqWjZBUkE4dmJJbUVUME5qUS9DVWtYNUYwMWFkb3Fkb1U2ZlZ1aDN1bnNwM3RIa3ZLK25OSW1UaDMrVVVRL1J4OXFJUDN1K2I5dDNCSTFQTFZqcTJ4M25XblNSY3JTeWtUU283SlJXY2gxcTYyOWRvaFF5N0xtL2NveXBIUkNGZDdKbXFWK3BHNnEvdkhDbEpLcFVOVUxtZjlaQ2lNakNIVXJXbkNscmxPZFY1UDVGdGo4aTdaMUFXU2V1QlNTbXhCZGgxcGtZM3hPMlpFeXBlTmVrNWVReXhJMXZGbzhZMGc2bDUwNnpEQ2tIT2ZrZmV3WkVpOXhTaHhEY2l4eTVWdTYraURpbjY5WXFMVzJuV2xnZS9VZWNSeGVJckxqMDd6NnFTMnlLT2NUenM3d2hUTTJoZWJOV1NUbkxCRHozN3Vld2Z4YVUvZUVRV2JOQk04ZHR2SmtKNTJXL3RGRUJ0V0tEaWZ6bUIyTHFJKzlkS2hNWTZsMzg2ZEtUaXVYbUhoaFRDazlJck9IcU90cFdXWkVRV3U4aUgzRlJsNlBNeG0wV0dudisyWm9XSWRkLzJCUU93SjVmSjNsMDFveTFNWS93c1I1TE5FMTRVRU42SDh4bFpxVGtDRTRoUWdoaER3WHJvS0VrRGpVSElRUVFnZ2hjN2lHWFhWa0xXaEpFaktGTTZjU3AvRnhuTkhXN0Y5Q0NDR0VrRG5RcmlLRWtHdERQVTBJSVlRUVFnaDVFTC9mUDhJVmRrQnJkLzhZaGc0WG1VVzdxeFN5UmNXa3dSelorY0xiTGMzYktHa0liWnVFbVpNYTNVMnAyYWl2emQ2aTdlekFYUmR1aXJWTG5MY1FjVXNPbTl4eHVkaHB0SG1NcUlQcGRzV2xxQWNqcWh6YkFheHRYZWVKeWZ1aWQ4emF6ZFZhY0hOekR0MWoxRnNsSTZQR0dXWHQxbGRaMnhwTDJrWnJXOHI4UGUyOHRpMUpMcnVrdmRUUm1hWlpPNUh6STJVZEJMcDdVZTZRZ1hUemc5Y3VjZlB0NWxvN0xZdWlqclNQcG5rbUFrMElzZ05kdGhhZ3JZUmV1aU5BTlA5aE5wNW1iaFVsVFVxYzVBOEJ0V1NqTXJYeEh5bnJNVXUvcHNDa2h2UWFBazBmYWRCWmpkK3p0VzZkcDBpMnZpc2dqZEordFRRcm5uNVJHdDlibnl6SzI0L0ptMk10WGFwcTJhYXdqK3M4M3VLZzViTUdza1F4em5uYmEydGw5OURybXk0Z1doVkVxWHF4ZjYrcGMxT1VOSTJWYVFydm5sMkZaYlovYkkvRjIvb3VVODJybERXRU5OM3NVTVRQc1NWbmhxN1ZWQUY2SHBHSktyVlphd2VDcDU1bXlTcHAvTDZzdHZjY2c2TElHT2xmclF6bCtGMEZiNjQxR2F5cEVQV1BQRE5DMDFjOTdkSDlzZmdtYmxPRUJ0aXBqdEd4aGM1Tml3c3RpZVRER1RVbkkvUEJVeG90cUM3Vnl0TGtlZWtJdVN5ZWNYdEVtV2pnd25zZWFpaWI4bjNkdGVuYUJ5Zk9oSDRYN1VXd0RHdG5KNk5PSngyUEdIc29QWXExUlJ0TFdyOEcrck10bzJpR1VKWVBpK1BrN05JSmNuTWFOT0RPV3l4NjNFVEVaaStCc3F6cmRSaWpsajNEM0syUnlrakFPU2x2bTk2YnpRVEFtMTdvNENMclFKUkZyeXpVTklqSTlId1U3VGdweDBRbHNwTDN5SzNKeXZVam4yaHdhSHlqR1JaSk9iL1NsQ1U3UEpXb1BZck5VYU5ub0Y2Y1N3OERkVVlpejdEQVFlUWxYNkdlT0w0ZHBKQktyMTM1NGZoZlRDV0VFRUlJSWVSamVKb3JkSVg3cGZ0SkNDSGtSTGdNa1VWd2FKSDVuUG5TSHYwa2NnUFlyY2ZETmlla0MwNGRRZ2doaEJCQ0NDR0VFSUxDV0JJaGhCQkNQcDNmMlBZQWcxamJUdEdpSWdqdFQveWxYNWVuNnRxTURmQUEyZzBKMGFJUCtSRTh1bXZMeVBZSndmbUxKdWZ1UEEvRG1zKzlHNHlTT0lvQ1ExVUVNa2MvbzN1OE83SDJSc3RBdnA0NmxMUXR1cm0rcytYcTNYQzlTWVJxMStna3N5YTJsS1lHMkRsMmxGM1JWcittM2JsU0h4ZXRpUHg5T1hyL3lTdzdDVkt6Mnk1WmxPS1hnMXdiN1k4VEZUalczZU95VUxtVGh2Y25ZTG1kcngzc3RBK1M3WTYvODBVMHlhajdRRzZLc3Z5S1M2VzJmV2w5SFJoVTZHb2N0U0o2M0dISjFkWmtSMTNJYmsyUDZNekk1Q2UzWjZaVjRjbVlzZlIvSkJFRmtJRmpLVjk3WFRXbkc2TkFUTk9XbWRQNDU3eFNHdnB5YWx1cG5RenR4dTBHYWYyRHJjZFFHZ21ZajVLYjQ1R1cwL042MWx3T1NOUHllUGViZ0h5V1FTQU5kRzJGVFVvWkVXdkFta3dIZ3phNVY4Vm9WM2cyUXRxbmFVTXEwclF0MWxBeHlvUy9yRnJWcFExSGFPcXBQZWVXaFN4UXZRNVExTWlMREUxUHR2Wk1vMDJ2eWJQU3JtRENVZ1BKUVEwU1JJWldwbmRzWGRQRzJzeVlTNDZkejQ3TVZsZlVjMVJLTDUxU1Y2bm1RcXVQMUduUW1BMXR6R1IzWGFnSWFySkk2WFltakZMZmRpeXA0VmMxZ1hDTXp0Y1NURStJaDJlYVJuUmp0S3hvUGt0SEt2TjNCK2NPSVNDb2Yrb1pzd2s4RnNxcWpaV2lwS25MM0JrM3pYRkJmVmZKbS9sV0xqc0Q2eDhsYjF0SGkxNm5SWklqbGRsalNNK0tSYlJwZ1ZpRWFuaTEvYTMwNTY1YlMzVWVqVWRvNDNxY3FKdVB1b20xYksvV295TkVtaUZJWFN3TjRqSEQvSWoyNnZ6ZXZ4SGVRTllhYjkzVUlqT0lMa2RvckN3U3Q5TnMrYWdaUWFiaFdSY1NNNjBJNlRxNm5sREZDS0NMZm5hT3lWSlFkYnliRzA0OE5pc1RXVkxEV3IwSUVabG80NkhxQjQxRTlQQVlVN1czMFFRM2Z2ZjNRK0FYVXdraGhCRHlGM3BMWkRvY1ZNZkJ0aWIzSVhNNEV6SUVweEFoaEZoY1FVdFNVOThiOXU5eXptaGlkaXNoNU5PZzNpS0VFRUx1RGRkNlFnZ2hoQkJDQ0NHRUVISVJmbHNYLy82QU43cjFpMEF0Z3J1MWtOVXNHbE9SWFc2OHZKZWtwNUxCUE5GZDZOQnI1Q2FNTERjY0lOMzhhYnI4K2lQNXUzUkZtV0JGZkJpdk84N0tlUVJIVzdaZjUzbHRqVi8va3F1TTltVHZvbkRFNm1pMTVlaG93L0lqdlZtQUZQWXhWb2Y4bmRldTA1Vm40UWwxVzdHTjA4enRwVzVPcTY2azY1SGpHZENNZURoUm5ZQXM4Wk1HMVFvWGJZVlBGbDN4cHNDSlMwNWloUm54VWFDN2U5WWZadWlOQ2J2ekhGQUUzdGE0bzVRSm1ycWdEV09YMWZvSGNRbjdGQ1hOYksrakFqNGpzOVA3ZElHVTFrczNpemJXb01VZUJrQVVuQmJ1YUdYMHlMYXdidmNERmJOb1BzNmFibDNiaG9QcFpsK2ZtVGVTL2s1MjVOVmpFYk5VL3dvbnhhdkNLL3lxSE0vQW0vY0ZPSW5HVEZBZFUzcmFXcm4rUGh4ZG1oOXJlSk5MY3NVMVpOWmF3TGxHYnNOUnhvM25PRm5IdlZTZVJBa3V6THN2YXJiSkRXUG5TMGZrNWpncENXZHhwSU8wSW05UFdZaS9QM3NzWFVQNTk3cVdQZTR2bW5mME9VdUxGVUs5a25rUnZTOVNnWFlrMnNqc2pITVlYY0pYeEdsR1l5c2NROTBjYlFtc2tLbUY3amtzS2xZOTB5QlRnVlhqZ3NsMEpWdU5mQkRhb0kwK2d6VkVhTWRKT1o3QjdWWGpDbHV1NWdGcnl1YUhxZW83QkRNK1dYTTFiNXA4RmhlYmpLUFYwUmFDUTJsdkFxbU1ONCsxR3d2ZWNFL1Z5RTFveHhqeWNodnBwbFQvV3NId09tMFA5eklCOGtBYVRidDVXdS8xQTlTeXZWei91a3Y3VWVyWGoxWU5tV29kSXkva2JpcVYvRGJ5Rm91a1hHL1RvZ3RYSlN2UEc5RjdkZlY2QmJ3MHFiZm50WFJXV1ZZZDJyTXBqZHdkMGdkbnpPZ0xhNUdvN1NPZGY1Q2ZWS3AzSmp3WE16ZnZTYlRIdS9Tdk1wcmoxSnducEp2c1hPc1laS2hmaWVqM1hsVXlhZ05HMU5tTVZkaGNHbXM0NlVuU2w5MldBdVlsQmpOMVpMVHhlNVRrUjl0ZitnM2o2NHBzT1hrK1NtNUtLRXNiTVRJUVJsZXpxRnhrSVJvdEEwbmJXNmFEOS81cmZYMVYwMXN5Tzh1dy9BOXZuNjkzVWFDOTRma3V0VXhERENRVFB0OHpwVkEvZHdab3lLeW5Mck9lYVVSVndsa3Fzak5rcGw1UFRqcUV3WkJvMkk0WXNEdDJSVFludmxSZ1U4YXM3cDdaNUdvWmdINUNaSWpaUFptNG9iS1ZWd0o1Q1ZtRnQxWWs1L3BLUFRaQ1hSYm5Hcms4UjA0T0JHblNTTUdIbEh5REN6V09wREpTSUsrVXJURU8ydHRxbjBsRE9xTjMwWitWZHBTb1FhMmRSK3NhY2JhMXNyRFRIWW1TUE03MVZEMHVhSlJSbDdYbm1ZWWx3eU4zWHA5aFJralRlUVNhQ2d0aDQzNDJaenpUNkRFanlHV1lyWjlidWExMTBaWkI5MC9nU0hPVGlJellrNnFYcE1SQ015Y0E2Y1ZiZjcyQkcza0dHK1FsNGxkelBFTzlVVVZPNGdFTDhPL1hWN2J5VEUxclRUaU9TaktUQzR5cDlwa053cWxWSGxsdEloRTg0N3hYQmFxSkI4UEJzQTdseFRyUDFtRVhhQlRuV2c3azhTS0Yya01sNTgxSjZ6d2NuYlRxMEQ0Z0cvV1F5cVEwUVBxaGdYM2tyQUFYVmlmMWVIblJOTE5aWE9ZS2V6TFNkUTlTdEpFUFBFZS9sRW9UZ3B6Q29vRjI1SGlPclRSOXNzSUNKUE9pUm51Q1JtN0xUT3V5bFRWekRqd2F5VzNvYmNRVndUWHFEQlAwQjZZL20rM01MVDEydnNYelZYdktSc3JVWHZPN0FkWWJrYU5OaTRZWVBOazVLTnNUV1lEckFmMFcrY0VYclBLQ3cxVk5qdmkvWnl5TzBUcU5yQUhvZFM5RTVvVUd6MEt6bjVGMGtlc1Jlc2ZVUXFjRS9nSnEwZk1hU2JydzFOaVZWcHVOS29uYWJyMkdmZXNuYWkvOUVISWtKK3F4TUQweDhKRjVTOGgwempTd05FcndPSnEvdldZRlRTZE5XTzBkdjNxalpIZm5VYlF1TTQzNktDdU0rVWdmWEhFOGp6SGlzbzJXNVozdmthV2w4OTdtUUg3b2lyNVJNWG8vSzJMZ1dnaVlwZ0o1UEZGbDBwTzIxK3lnVFQrZFQxakYyOURKelo5b3pJRno2SFMwTGhoNnBGSHM4eU0vbTZJTjlGQkdIWitPWjdBckl3MGVWSUdUZVVCRGZuMHhOUi81OC84Wkx5Z1JVdFB6SU9XZ0t2VDg5dk4wWmxiNkl4dUFuQWJIeVRvMEJWWDhGMTJLYzU1R1o0djJLR0dpVXQwOThUQTZXSk14WEIvcFBpT1BVbExTSDkyMDF5TjE5VWJ1VEd3RHhDL1J1LzlZWFlvaEkvYVYxbjN1SDVEOEg3cjRyL1pSYUJPOVFYNlVLcVV2YkR1eUNzOFkwamhnVEs1UUhlanFmSmtwNTVrMEwyYVlFZVRTUkI3dWVOMy9rc1hoTWNBTUhZbThxWVhLV2w0R2toQWRWWjVYWGNCMFBXVkwrZW95c0hTUithakxTaHVaV2xsMlhvdXhXdnBFL2QwUElFOUlnd2FUV2lLaGhEWmRaNW1Xbi9GNjExb3RFNVQxUGwvTGFFVHVaQ1ZuUnM3U2pWWWxvbkpLNTNWRU5pcHpwdTEzaEIxNXBLMGFWVWVmWUVmUFhKYTE3RTBaVXBHaXJ0RHEwbVlPWE0vdFFkblc0VVZwenBkSzV1NDFnQ2JNM0JOenlWNisyVXVocFB0WGxVV0l4OHoxcURmdTBjT2diaVRrSGx6QjJJblVRWHYyV2kvbXhSRGxPREhhc1NqaTlYSkI3OEk3VTBtdUFGWElCNUtWRStyNjgxbEcwUkdod1Y1Nnd4K3ZhNmlyZ29aQk5EazFSYmttbmRlR1VKUVo5L0VZb2dPYURYcE5ydkpNWTBZc2dzQjRUM0N1UUFiT1VhMG9IQkZ2SnNOb3RrMlhBQ0FaV2dadElBSXo0eG1za3h3dFlzU000SGp2NEdHTjl2WERWSCtRTFZLZlI4YVF5RDI0Z0dWL2V4MHhZYnFqM2NUcFQ5NXdNS3pscFBXVzNYb1F1LzdOMm9VQnpuQ2xyKysrdjFyNHFJQmVXMVlrRUVJY2VvY2JPK0YwMkxSa090N3ZoQTdrYm9Gc3VBa1p3U2NYaE92Tk4xN0FKOUpRWmZENlZjbzRqSmh5SFBFRzl3K1o5bVZ6VHBBbFBHejlQelJjeDdBT3VSTTNHMXNsZUR4VFJvOE9Pa3h2dFVxUytvU2N5Um1UYXVaa3MvUW0zOWNoaitNS0EzNWw4RVE3bnJtUXRnczBsY2d5VUx0M2RDMDV5YzY2OHNpSmhrQUxJS3VXMS80NHRiNkdFbldMVm5TejlxNEVJYmVGenpRZWliZk1Ya0VIVWhlVE96SjFqcFhOUHorbnYwL1VtNHllYlY4UkV1Vks2eEVSMEo1eDNIVHgvbTFlTGUvL3hFQTg4eFcvbVNDa1p2TFk2akU0TGpXMHZjaFlYV25wR3JqalU3SEsyQ2VIenBPYll6Mjc0Qm94ajlhb0tick5zem5SdEg5eHhCY25YWjNXU3pjZjg0NmJOTjZ2VWFUcmRkNlNjQzNYODVpaEZaR1Z1WU5xVnVTK0xXdFlLanlxNWJOU0prSmJwaklpMzVlYisxQS9hK0tYdi85UmF2dkNkbEdPWS8xZTM4bGVOWTcycjljM1NELzBydUluclA1YU0xaER2TTVibFBNcGpkM0dBOWE4OXVzZE5kcTBLK0F3YlMvVHJpU2ZoRFZ1MFRIY085YWpmaTVxNDZVVXFKUFVBSnBQT3NNWUpSK0hwdU5iVUl2RkdtSklmdXM4aHg1QUlNWWtIaC9CempCQkNxK2VYaGJST1hOa2FZRTdTemxLYVV0VmN2NitxdmtrRWJBOCtmdG5yRzArclM2eER2WVdBUzk5Vkh0WWhuOTczZE5VcStJREJwN1NYQWw2ZThXNGhseXYwemhsV3U1OU8yMExPQ1JhVmRFZXUxOFNMSUpLZEhTa09tTVFRMnoybUloTVcydnFXSEtLY3p6eW9FRXJHN1UzcmZPb1lZR2kyYnFvQ3ZYYVFaSjlCQ05ydk5WUFZvaXdPYTJKelVVK3Z6bjNtdnRKbU1kMUpyQi9QSjJpeVNvRmw2a0JsZDNJM2d0cHJuczZCMWtDMGJWaHRuNGpCR1ZFajdYS0krcVVSdGUra255SEZqMVB5RWNTZlVZNU1zRTFtYlBMTEZWV3p6bEpZNVRLd01wTkhkS3Y2dThrSENmbEdDbzR4VmpSajE3L2VlblJkTXI1TC8wTlB0L05pR09Zd1RMT0EzbFUrd2QwMlVUY0lWUmVwQzVTMmZWeVBNTnQxSlozYnhSNmJWd0MrV2d1TkdpRFFtdFV6NlpqQTM4R0s1YWZLNVo1VXpSOVBCSjJSSWprajRSK3ZieVBoM1BsNDdEQ0dVZVZKNFVqQ1lIb0dEQVJIeWFLOTFqRlMwY2FVTWVxUHE0YisyZ0Zkd0RORDFOdmVJZmtucFJKYVNZeUkyaDBCN1RnR2lFcTdVSmJ3OEd6bEpsNnE3VWdMTm5uZGV1clZtZllPZ3RlTGgxTjAxMzRBMnpGUHc5WUwvUUE3Zy90NkoxcmQ1elpyeWVXclVXUWV4VFlqTTU0MEpxM1luclJoQ0REWE05d1dRTDY3TnZLaXg1UGgwNDN1UkJjZHdZb3dldG5OTzZLOXhVL21NZ3R5V2svelljYzlWSDRmT1dUK01UUmFSMS9CRWZZZEVlR0doNGFVaUU0bWcrbXBYc2ZPLzJMeEZiUXFSWXRlMStaTkE1YUp2MUNjaVZtK2cyOUU3YTN6SjVmc1hoeXVTYVJTM05HTUdKbG1iTWl0ZElFRmhibDEyNCtuT2ZuRU5XemF2Y3JEMEl2MXEvUm1STkpHNTBwby9sYjA3V25xYjN1cDF0SXlBVTRJMkEzeXhRZzRhWmkweEp5UEdmL09KWGhTTkpOeCtEbFdQc2d2RmpxQTM5UTlmUEQxSG9IK05mVExIUjNpTWliamE5R1pvQ2F6R2JXNnQrTWUyUjR0K0c3WW90MHowOWhORGhaVnk0WWpkT0tqSjV2MDNEQnZURlNSTlk2SmphQjZMYXFoNEx0L1ZJVmxsTjJqVzdzTlR5c1VMOTJydmVwZmRzcnhha1hvcWpic3JSalNYNmJEbzF3ZXF0Zm14NjVCMjFVQmU4TCtVTHE1ZzJzYlptbEtqTUx4Mzl6OUJyUU9udmY1ZlUxb2dMbXNNYWFkcis5WXl0aTVWeEF3V2ZoMkp0NktmbTN2ZFRZK3h5c0w2VzJhZFFQR2l2VFZyUFphVWFRYmc1MFRyd1YxRXRmZzRSakxvTm5HbGk2czMxSEtobHB5ZTN3NWdheTdFckR6N0ttUFpYd3VLWGZDK3dncm90MTNaS0JscEVHNmdKL0xzeXFET3Fib0kySmpLNzlTTGI4aE56SUtrMWRNaVJGb3lobFllbGpmZ1g2b01GYkpSRS95Q3ZMcTBOU3JpL1VHcWhCZ2Jxa3hjaUQzdjdJYlVhbmx1WS9TUG0xN203eWVxcWhSTzZ2eUdXaG9ZVFExdzJUVWJZRjZ2ZHErZXJ5cEhDRWRGN3gvMVNzdW9GdENSTXBTK3RmVFpZa1U1UFhYdGZEVjNMZGVsUmk1SG9FVkViRXpvaTBuVkRHTzVsUjF1NHJ5MG9kd21aRUVTNTd1a3lxVzUzUHFjdjd2RlEzZEk1cjE3WDViUFZqUFo2OU1wQjVUc2hzb2pyUTBzOUgxMFhLU3dnQlFRTWFLWkN1VGh0VkZzVTRwUzM2dXorVUtsUUxlR3Q0Wk5USi9FY3VDMkpVU2FMR241VzN0NndXei9CK3BmR2NVNnNzcnc2dnl4a29ldzZSbGtkbnppZmdSYTlXRTNWL285RXJBb0Q2S0tpUHprNzRERVpqS01oU0lhVXRSaGtqZmdMNTRraTlyYTNHdmFIU1ZvWVVmbjA4YUp6S2l6R1NZYUxxQ2drYnRuSGIrdnlYakNaVzZwWDNsYmI2dDUxVGlEb21EMlZDbkIyTlJJeVlJOXBhUVRPaUUwbFIzY254QmZqNVllcEdJOWN0c3lZWVFjaDBaZzNUT3czM0Vlc0dzZVFtNHoyUEpqZkVHbWYxOHNNQjBNY0pIbzdtbE5YWHlCTzRpM3Q5d21JWVpLNmxmdjM3N1FLSit2UStiL2JPVS9GOVlRWC95Z0Z0eEc0Z0lWYm9qQXZDZ0RnaGMrRFNIeUQ2VWs3ME9wcG1Tcm96N09aWW1UUDhoUEh4bkNmSTBPNzd6QlZzNVhPVGt3S3lrUjhCa1RBUnU2dFhQVjJxYTg0TUxkdzByT0Z5NUgwL3RZMHZndlN5azNaOTVQeEhvTDM5UmNoS1preWFWZTh6Ukg5N3hUbERTSUFaQVl0SU9pM3RERi9VOFU0MlgwWkZMQThraUQ1RDRWQnhmVEc5Mit2K25zUG9LTDh6N1NnKzYvNDVrd2laeUJIUFBLSnBHYjhkWnBHVmRTclUvUk9oV1RxTm5ybm1xdFZiQmtISlUvR0dNNnFLcUxZT3hOdEk1QUhQMm45dmpsNUJwcStiTHVubnk2bS9iQ25JVC8zYm4xV25KZzhodlN5ZXFETmVHRUh0bmV5a0R6RXJ2aHNwcTlpWENka2c3WVhRNHIxY3dEVmtpMmQxR3UyVkJ4V1F0RnZYWjlwVGlGSGo1WDNscjJVVW9Jd0N5UDF6V0tyazMzKy90OFBYME83SE04eXMrL2YyYnZQUTdqOHlHQWRYMG5meUFwUWhHN092TDZQaVgwcVZac3NZN1ZlSUNpeTdBT2Q2Wi9Ba0krSnFQTUJCWE1YYjFhelVWbjMrQmZwRDFYOWVjclR5WHZLRWMrMTVRcjdRMUpHMWRFN1NDVm9SSXl1aVYxYmtObnRSNnorcStpMnppandDMUxLZFdWWUxoNTZDdGdCSGRHZlFQUXAxUWxodk40YkwrL1RlTDRnWDFqT1NJNCtnaXVCcGFUNkx2U3JndnM3V04yazlwemFsVGVuSTY3V3BseThwNVJSREJscVdkNzlJV1NDZXEyMFZxVldyUHBhcWlGYlZHdTVvTnc4cVlQTUxvN0xicjhwNFo4dnllYXhDOXVYZDF3K2JmSERaVXJ2MWhBd2ttU2tvR3cxRmFHazlJb1p4NXppQ2ljb2ZNVHcwMWQ3ZXA5ZldQYzVIdEMxUmRSd0pHV3IzbXhRWjdYbGdMbjRsSy9wODJ6WDE5OEV2eVl4bzhtMnFnTnpuOTU4WmRTWWRFMkpuNmtocFFSMXByamZTc1phdnBRaHBveVlCSVZHODhUcGpIVm01SGxteVM1Sjl0WlRpOWVGY0k2ZlFhNENzTmdCSEVPcFlMOUpGU3R1bWY1MXlGbmRyM21hcGJVdVN5eXpKWC93aldJYW1WRllTMGtldVN3NmhoMlpvZVlhWkJPb0FLRzM4VGxiazg2OC90Q1lzMzJtK2ZweDZIUU1LRFEydW1NM1JwUjl0cmJZTHBPWFhxOU1NUm1WNW8xMjY5aGlReHBHdXArQjFNazZQRXZHV0NGUnhKU2RkVDlsMXVsbzJ4eEtNWWxXWjZXWXhFZ3FUbVBpVTRiNmdqV3JGbkVvd0Q3a01lV0lmY1JnOEZGU0hGQ0I5bmFZSVpjaUg3NlQvS05lVFVMUlhYYWxLajJiR1d0RWVlODgwYnNKdkRpUHk4YUFhazV5R3AyWFloUS9sWlZCSkE4TTZUejZHWjNVWEVrSHViQkhFVk9QY09KVzgySTYrdDByVTd1NmljSzROY2NRWFVpMlZ5ZTRqRzlvQkVYa0o5a1lnOGRCUjJZU1FHekl5d2RFSE5iM1hWOGgrdUVJckFadjlYazNWNjZ2d09RdnhpVDRFN3IyK1NjaWhTVDZkTThmeGQ5a0RFVjVSWk9UOGFOb2o1Q3p0SCt0NUVpRlhwVXhLczZMOCttV280cVRuNjBUa2trUW56NVc5MVhhU1NZdGVyd2N4OG90ejQ4MVlVWG1nYndPZHFVeHVaa3pNaktGZHFHbFdoZ1o3eTBhWFNIVDJXalBvRTVkZG11cmtvK2hSSXAvd1RHUEdNdnpRaVh4bEt6RUtkVEVoTXFYNW85M0haUlRPTzZLQ0ttYkRvTzVkcDdnbURERHJJZTZMQjNWRTljWFU4dlZTL2FhTk50b1lhQlgrWUlKY2daNzRiSUEyL0tvRmtWSzZhRGpjMjFwSHFyejN0TDJ6NGtqUjVPWXc0REVYSk5DazZjZ0RKcDcwQ090Njg3M253VncwYlFITGpPekpXV3RTcmNOUldWWjY1Rm8wOHVubFIrN1R5WXZlM3Z2ekIwa3NXMjVaZXd6c3Z5N2tyWHJiODNXdS9mUXRZSm15YlB2OHE0Mmx0TVhJMjdPYVI3MjA0RHoxdG9aS25kVWhYYlJmVHEzUC93SDk0U3BOQkxLTUF3Y1hXdFFaZnRMVU1pTytaMzFlazBOSWd6ZGtyUEU4T3F3OGE1c2NRSS9DVXAzUjF4Tkp6VEJaWWVPaS9xQTkwdXYvNnQ2U1hhY2ZQK0oxdkMraFRsczZacFh2cXlCNFBrcDdCOUlMdEpiYytzN1JlOVRLOHNwb3owOUF1OTNpVk1WeUI5SHV3WVlySmc5MVowSFprSjlScVlBNmZYRlVneWNiNmUzNlJZaFNuTVIxWFpKVGFDU2tvdXJHQmxSdFNiS2pJUWJ0ZlBSWUFwMk8zaHl5OElLaHFDb1lVUkhSdVRSU2hqVzI2blFqUzZTWHQ4aEpzNVpmQ1NGbVE3YTI2WmFtSzhRd280Q21ZOHd1MDNSRWN5bDd1bkhDM1BmTXEvRDZKS1ZGMTZNTTFvR1EyU0JyNFJsbHQybWs4d1ZJUndocDhJeWZsb2l4V2h2OHFPR1owdHlkUWFYRjJ6SnV0Znc5aG5OcThtWlFaZ0hxTXRwR1dqOXFkVTNLY1N2dmxjYXFvMkxNdXA5KzBwUjgyU2NMcmdFejNRdlVuZERPcjNCMWVqQmFlSmZ1NkxwcWJlaWxSOHp4eDVvUFdsaFN3K3NFK2k3UEFEVUZRUFV0eW81U0wyY2NmeHRXTklkbitVanByZXVlaklqRmVudDY0NUpvWEl0MDB4TlNPY0tlUWg5cGtJZmdEVGpKdGl0SnQvbXN2R0FSRm5YUm5zZmRzeTU5UEtnUzZkSDVEMVVPdit1RElqNzlvZG9rRjZESGVqakk2RHNqV0xTVUNkTmVpNU5jTFNCSURzWUtvRVdmSFpBWUwwVzFjRW52Q1g2d2V6c3B0TTlzUHIxdHR2MHJUZC81YytlbVl5cnk0SVlLNlZCNnZwenEyWmNKUEU5SW1OSjViVkxSOVpoZjZYdGV5azZqcVVNbXMzSklQV2E5aWRoVld0NVZySWdaWHJKajdaSGMrZzB6MW93VlMrQm56Qm10cmJYV1hmVnF5a0ZJQnNmclgydlljYTN1eHBxZnZlL0ZrQWJha3pJUGE1TURRdUpkSERGL05mOXU1Yk81WmZmRnVVek9aR2JnOFFwK2tmWFMyKzFlZUNEa0NJSS9Ib1R6SGJING9kSGdzeFppNmNub1hZMEM5QWUrQWJ5QXpsdjNOdy9yY3J5c00yeGI3ZnlaeXhoYTl0cm4vZVJXTUs1eGIxYThZRGRxUmx3MWlISWhQQXZ2aWh6NVJPT3gwSmVlUnM4enlkRm5sUm0rUU1nZ0o2NnhYTjROVmoyVTFYNGo4NENPK0oya25kUHk5MnI1ZFdwU1MyaU5URWdFWkJPNTlualErRU5zalRaNDVJVnREeG42YmNXemNsN2I1cUMrTG5sV3hTNjJUWjRTcHp4UjBBWU5Cd3hPajZKS2ErYnI1OC8zWHBzSGNZODFoZXlRcGZSU3B5TXJVSnNmUmFwRGRvNjlTT21CTCsvdTFzQzhQZTU4WGFzSTE5b3ZBTDMrOWIrY1drdHRaZjc4Vlc4a2s2djZZVDJLUG9rc1RmMGkvYnB5OWkrU1BiSU8wY2pwcG42K0xYMUIxY3VucFdlWEVKZ0xCWHhRN1p6U1BETTVZaGxvWmNLcXNwMjNtbTlhVndZeEk2UjA1QkdndXQ0S2EwaHBaODZ0MncvTlVmY0NrWTJaNVB1OFBRcHRSODhOZWY1UmRIUWdBYnQ5RGJiSHJRL2lsU2dyWmxtT0xETlhlZnZ1UHRMMjdXTFFsb0pxaVNUa0x3a1BzbGdVTVAyQVlkSXVzQmtzb3UzTzdPUXB5dm42V2pieTkrSjFzNmVQbXVNOG82bVRMZE5MOTJydTByUnBxZTd6Ni8zZ2xQUmhMTmxHOVhsTGgvYUdsSHIwY25MU2V2MkszSTkyWGJNZnRUcG9SQXdPTHk5aTQwcm5JMlY2ZVpKU2h4NlptcXlWWlhnMC9aeWRNdHV2bk9ZaUo5LzROTVV1R281dnRIOFVvU3poT2dReVI2eTZ0WFdJbEdrdHI5SnhVdEo3NVVUS21MRWVFZktIRlhwTXM3ZXNkSFhhcUcyVWhPdlprY1U1UkI3QlVZYUtWSVprL0lJK3BQZjhjMWVrczhnWDRVU090azNQUWx5VXYydmpEaW5mTTNyUk9pQmxlTTRMSXFNK0ZoemZuVTVYK24ySDAvWWIzZCtyNU8weWpwaFJHbGJaT2NWNmFOWnkyK1lweW5ucEdKWGJZMGEweDF6eU8wRDk5emE5WjNlOVZBSTc1VE9JK3IwcGtDNG5iSUwzK3RpOWFXOEVxcDhqY2p6cW9WS0FkRzBaNlBvazVTVUtxQm1wUFVjUlREblNoMmZMSmVQNk8xM2o5cURQY0JEYStjdHVKeHNpU3QxaGRFeTFacVZGMUJ1K1BWRmJ6aU1TN3Zsd2ZpVkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUFmdi81ejUrZHpQYy82czF6dDdEeXR2azRjN3NzY2oyc0hhSFF2Sk9RaXM2ZHhTNGYzbElsdlMwNXRMYnRyR3hHWkdPWDMybW9GbTVDZEF5T3BuMFM2SzVOd21sdGs5UG9SbERvK2V2aDdXdUpibUhZcHBWMmMrM2RRcVdrYmRIMXRrNXR4MldubUY1bFg0eHoydjFsUUFaU3BqZks2dlJnR2VwT3dIYisvUDZ2bms3N0dsR1pNa3RLYzlkRjZabmVzZ3A0cnBicHBVdWRkWm5BNkJDMDhuKys4anNWYWFyQlgwSlYxaXZVakdEWGtEZmVNbVBST1poNmQ5ZU9WaTJTQjJtRzR1UkZ5MUFMUmMrM29GdGlrdHZSYTFXMzEySldXSXhSTStRVU5OZW1QbzZhNkpwc1pMZlFhSmt6dHZ2VXRzenRzdkU4ZnlsVjExUENSN1lYUlVQd0dyY291UkJ2cEQyZmxiVG9JdEJlUjBEOWVMUk83VFZyc25oMWlWZ0IxYlhhQ0c3SGFlL1hUYnhzQmNnVDdiWStOOWd1TTlLTmFKR3ZxWi9scG05MzJmWjIxeTVwbnk0clpXcTRaVVhPZTJySms0R1dOZkpNSjZMN0xUazlqTnFvTTBEVldITE9Xeks4NjE2WkVhSkxYVXVrTHRyeTIrUjluOWJPTitLZ1hmUnpzMW9FelloMzJRRWQwK29wSzUwbEs3U1U1UDNoUnF4bjhuZ2dkbU1HeStoY0lnbHg4ZFloN2ZHUmROeTdIa2ZPNTRUcHpqbzlJWTlqcHZHanlmWVFBaHp1YzkrVU5nbDJYOVIwRm4vSlBjNUNQdldoVG00eXRzSXNVS2N1Sjl3WWp4cWN4YmpXWHZlSUdQR2dJMXRBNTZRNGRSSGZMUkJpRGprbDNDR3lGNHRveTBXV3hEcWZWRlpreVVQVG9TNlpKd2RKZzBhU2lwSWZLY003MzVaTkp0QTd3TWsxUU8xcGI4SW01N3dsMndPTnFXalhyVFEzd2VyR0FweWIwVHpaa1l2R2pwRGphRWpsY2FBTGFzUmtKVlBReG0wb2hGSzVVOWI1OXJoMWt4SlFGMDMxazRlQzJBS0JRVEtpeDhGSEdxSDBqd0cxM1VaQ0JqZUZYMHdsaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0VRWDE5TS9kcXh2TjR4N2IwTFFJNzlBcnAzcTZmSVZnYmtHWGk3M1ZyYllyUXNHbHVYR3JMV2ZjLzRwVDVTWGtjNlpNTW9xb1liTXJMakZ3ZkVGRFlxRnB5bjN2WEk1aTdlWm5MSDRPMVRGTm5WVkV2ajVkVzIzeHJZVnF0RTk5Uk1UbnJrdnIzcjNvVE96Yi90OVloTWJVZlo1cks2Yyt6OGtmbjZxbEFaWElqSGF1YU5DMlN2TDA5bWIxMHVSdFEzOFhiUld6ZTBQb3FaSDNoQzE2V2V2T1FHSUlhSWR4MVJrWjJEcVhleldrM1dTTlhHVmlVWjE4WUx6bmRPYU5JU3RXQVJPZDZ1cGxwWkg3M2tSM1JsUzArOHJoZFBWZ1lLUlQ4ajlpNnp4TTV2RXdYUG85ZmJkTGJ2dGUzZXJPU3hWNEZpU3QyUzNVRTA2amVnQy9xTW1Zd3NQTktYV2hLWVR6cHVVYzVIakdaUFFhR2lQTU1GS1RQcWVrcnBQQU1qMkozYUR0anQ5Zlp2NjlqOUVxRlFwWGQzQk5VVWpLMHFqa0VxSnp2WDIzU1JhZXJSYXlocjE3MHdYNFJvWG1SdTlUb01VVjJCNExVUmV2K1J0aTIyeWVPcTFaZU9hRUtMYXRxUzZzZnI5V25kdk5qOVlaOFhaWUJ0NHVtcjlqaHJKa1Q3ZDMySXpsdHRqWkRvSFkvUjVaY1FGRzA4dDljUi9WdVB5eVBYRHRRZXE5TnlMcEZMMER0WjZ2d0prSUVZVnA1Ukc1MmdScnJpeEJwS05COXlQUnZHazVYdm41LzhFQ094bG9pekdjR3lJTnMwVVlkZ3dyTjB6WWpkTllkbC9MM09WWWVtY1R4UDZhT3pHRzNaR2IwK3VneHJpSDVCZGR3VFdXcVBqM1JCU1Fkb0k5T3UrZ3dtTE9sZklQM2RxeXpSZEZtNS9nQm11ek16M0NVdno0aStubjIvSHdzYUk0MmFkdVJRZXJzaCt0alg4dTVlMXozYmpOeU1pZTc5S0RQSFdPdWp0RkQxTlhnVEhRa2xqWmJ4SWZDTHFZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaEJDTC8rei8vbFgrUDIyekordnRmZ2Qrd1JuN2hPN3F4SFhrMk0zNWxQcUZJcitoVisvV3BTQnY1emRpb0x6dGxkZUp0UUVOdUFqdjBPRG9VbGFjU3ZIU292T3VDS3NXZUxiSTg1ZW50bjlhY2wzWTFGZnQxWmkrTWZJcEIyMG5ZYThQSWFoRGROdkFsR3QwQzdYVzJWQ24zL1ZxR3JBQnNMSldPZnRXLzJycFBpZFFCRys4WDBnTFI2UnIxWmFTeUNJUzBDNTMyeFNBMkxWbkdDWU1yb3BicWRFbElQM3VUdGFIbThJUzM2VktUL2dUL250d0QxS3JVOGtscG83dEQzaUtPSVpuczdiVWUyMmYyNXhBdXJ6Tm1mMnNodG1yRVN0N0tIUEhJN0RKV3RJZVdwc012aFBMMmx1WEpLWnQvdGttemY3dEhFcW5McW5DRW9iamZINFRSemp2SEc1R0tUeUtsMDJSSWRYeUJsRmwvc0VZNjc0YUFJdnA2bFpzL002eHp4RE1OOU9GT0s2Tm5iZFRLUVBPT2xBbk9xU0dEcXM0VEthTTNuVlNXVTdhbk0wWXhWZWFDT2tnZnVSSjF4Mno5dk5ydThzWnJtMDZibDRRY3hjeTFyMDVYRTN1a0VUT2ZvMnNlSVk4RGZRNjZxdXdYeW5QaXIwdEI1MFNkOTRwejBxVTBJczdLRlJUTnFMS015UFh5S2YwVk5lb3k0SlJxYVE4QU5mbTBmQ3RtWDNUNWJhOFY1M2cxVmhsU1hUd3pnaWFBQVJyUGFHSGozcFBvTTQyVmlxd3RJd2xsY2Z5SlJGMjF5SFQyckF3VVpPaXdleWZqTGY3a1VOemxWNHVGTnU3VHpEcHdHQkNZb0l2ZHM5N01ndjVCQjU2RGUvUEcwMzl0eWxGRHlPZkMrVXNJSVJmbmFZcjZHZmVidVFBVE1vWE1xVVFJSVlRUWNpUE9mRVJHYnNWVHUvY3A5MzNWZDlEdkRGWG12V0gvRWtJSUlZUk1nb1lWdVE4Y3pZUVFRZ2doaEJCQ1Z2QmJQdjM5Vy83OCtodkUyL2pNeWtQSUg5Q2YwMXZiaTNXT0tYVGZ2cXhVQVpGOUtGazU5aXBUT3E4Umd0SzdpU1NaUStuYmlLTTAvM3JwclUzWHJrbjBqcnpqRnlYcEs0eW1tSlVWU055OTlQVjFGVzh2S0JTdjUwWVc0T2pPdVpGUExwVFlwd2plcDl2enBmcnZuMXoyYWk5OWdUU245cXVtZHJ2OGZNMFVvWVRNN09TbTdXbnpFVU1DWmRaNHJzU2hsR0JWdUhhSnRGOGgwcTVIcjMzSjFQSWxRaW9RWncwZE5EMktGeFNwSFNlbHlBS2tTVUZaTTI5dnQvRjZBZ3ZsQkNZQ3lNN3Q3VEVxYThYUy90SERHTkdaWHJCTWs0V1lqMUplcE95SURFbG04UklnQXFWMFNKNmVVZWg5dThCblg5dlcvMm12ejFnbG9tMklySXJ0NFBKVzFsV3I0SVI5eVl1elBYUEVsL0dJM0xhM20rdjRjSXlWYVNueXNzK3VpZDJJckdTMFh5dlZmQkkwM2E3d3N2bm5mYWtvOWFtUFZmc0tDMjlnOWZOWXNjZ3AvYmk1SHFuRHlPS09HaEpvR0U4ckkxSkhiNTVHK3FTZFc2TnRiYVhUK3RVNm4xTDgvaVAxMGE2MTJkczUxV1RON1VWaFhrdlhwVFM1bWQrUmVXdDkwUm1KdGFnZnkwTFhCbS9ldG9yT2sra1JuYjlvK0ptUVZZek1JU2s5a3M2em01QjhudS9HdVVOT28yY3hjUjMrQVZEanJDZUlZdVVUenIyTkFzc29hZExYQ1V0VHB2cUZWS2wrSHFZbDVhUS9hdEdXMmxvcU0rSVFvN0dJVjlxT2NkcjJXektjVjdNS2VWdVZCVVJtYjlRZG1HRm10ckkwZVpxNUhEVlROWm5vc3QzbWs0NjE5RmE5aWxNR0dxVjdOS2l0NW5YY1VlcVAyTXd5STNwdGVVU21sZytOVzUyeDdINFlzME1SZFJxcHlTUHJXcy82NmxrNDdINFF6cGZwOUhwN0NNVnozYkl0UHhMNkp1U0w2SUEyRkxFMzFyeElRMUt1UjhLV3ZXV1I5SGpsb0g4eGxjT0hFRUlJSVlTUU1QeHlLaUdFRUVJSUlVU0gvZ0loUTV3NGhUS25MeUY5bkRsM3ppajdxYnFDT3BJUVFnZzVEcTY3aEJCQ0NDRzNnYVlkSVlRUVFqNmQvTy8vL1gvQ2IzUHJuYnJMMS8vLy90ZXZCT1A5ckJwSlI0akZnV05IMjd6cWtsamIyYURiekMyNFVYUW51K2dPUUZRaEg0NDJYdG14T05IZDlXcThuZDJEVlVoMkVlTHhaekM2MTZSM1hVc0RWR0ZKWS9ZVTR2V3NOMEM5c2lMN1VTVjcyemtZcjh6WDFWS2RsZStyREhWVVZ1dWdmYTExdk15OVZManQzK2RUdXBTeEZoMXlDQjloR0Y0SDYydEUzVEpmOHBUemhIeUIrRWU5ZnRNRVBIWFZZMlZvK1UrWksraVdzaXVXU3ZMeGpJemZubDBmbzBQcG8ySkZQVVFiT2VpRGhtVFBwRFZFZHA4cU94TDBSdTNHalkxamJER00rUk55cWRuMVdYNUttODlJeE5HVGFlR3QzRUpTMVZjUnhxbVUzNVNSN0tyMEJtUlRSL29Wd1Y1UE5oaUtzS2EvNXJ1TXFvNmViTHNQM2pUM3RXdU9OYUVJV2ZZS3ZSMHRhMllkZXNmV0VVdkpES00rT28rMS9ETmorek45c3FBdVFic3hLL2RkQnNyeTBsbWdzUlgxQzZrOWFQMGMxZCt0dktnOU9RTzBNd2pSaUs0VjdiVWoxb3kyekJjOWRpUWlsNUFoVmdZSmp6VFdOTkJGcjljNWsyUXBaYmZPak9qY05FN0dUcTRVVld2VDdBUUFJQW9LTGZNSXB5VTVaVXdvODh2b000cDYwUnA1MllsRmlHVWxQeGFoWlBORWI0cEluMDF2M0xrbE10cGZhWDhKZVZFOERVbE9oSjF3YlM3eFRDUEZubmQ3eDBRRjFaVXJtblNCRmNFdVg0MFZ4MkxqaHpqREc5U2U4WXhzVE1wdWZ5Z2pMbWh3MEVTWGR1MVJEdGVXQlhpeDRBY1IrTFVwSVlRUVF1NElEVVp5S3ppZ0Q0U05UUWdoNUFKd09TS0VoS0RTT0k2bnRmWEQ3cGRUNmQ2d2Y1OEIrNW5NZ21PSkVFSUlJWVFRUWdnaGhCQkNDQ0hrc2Z3V2Yvci8ra2wwZVIwRXNYNW0vZW5iWDVGek9XRDhuTEYzM2hJS2VEMjZNME5rNjdka0Y0RnUyaVJCVlhKaDBNMCtyWjJEQ0lZM3VhUzByK3RnZTBjM2ZzNUdFWi9WeGQ3ZU10WkExNjRGQi8xYmpMSk4wK3RhNkhNWW5zYU5ySUs5eGgwNm1yejBTTExYcnI0RkV2WFRLbVdYUEZlcFpCTlhGajdySzZiYk1vdVNCaTBqWXQyVTRQa1RpRTQxeEwzeHRvamltaldkMTljK2FFYVFxVVIycXV6UkZaMmc0OXpMNzJHNWNUMXp5Rk9OTzJFemJvVDYrTEY0TzhsYmFaSFlnaFdmS0VZK1ZIVjg1TkJFYmxoTDIzUERzRktwMHZlVzlhWjh5OGw5cmd3RWVtUFJxSmpjUWJYdm9zK1IxOWRMaTFoU2U3N085L2Q4WEJFWFpURW83aUtCTHQ0emZOVG9Zby9VQll3aHFMZFp5UksvbE9wY2wvQVVWM0h5RmlGdFZxNG5SVGFpUzRwVGRuUCsvWUdmaE5IelpWUXR6NUZmU25YTDFNSWRLeGFrRWp3dkVWV1IybmswWU9uSmE5TWlLc1F5SXFUckVUd1pNKzNuSGpVc0hXdm5OTmtqK1dzNTBYeE4yZEZWZUNQSG9PaEYrbVVIN3F2K3lGbTdOQ0Q2TFBMbDU3Zk02TGlNam1kTjV5Y3d2NWRlU3VmTkIwSTBla3gzNU5vcU5EdXJkLzRTTXAwWmcyM2xnSFdjRXpmZDYvSnJBWDZkaUNnUGljWUkrRHFsVGVDbTdOYWYzQmdIdFpJcmV4bWJ2OXYweVRpT0dxSVdxTU9RbkRwcDlRajBhN2R4Q3JBYks4b1lVcitRYWx6UGtwejNmOVRLNUYyY0J5ZmlOa2pwSTI1ZW5hZW5ad3A0SHBGakxiZldERXJPZWE5OEsrVGluWWRqTFIxNWJnYzZ5T2lEM0lOWlNxV24zSnBJc0VHN1RuYU1XaGM5ZUs2WmxENGx6Slh6MXRISDBjYUFJK2tUa0pkenE1dUlwUjVHRWVwK0tiV3FWUFNSQm9mQ3c0Z3E4QURlSTFwMHpIRk1Ia0RVTWJxeEk2Vi9NWlVqa1JEU0EzVUhJWVFRUWdqcElOT09KSVFRY2dHNEhKRTdraDh6c2ptREQrZU1KbWMzazFWd2JLM256RGJtVWtnSUlZUVFRcnFnZ1VVSUlZUVFjaHRvMmhGQ0NDRkx5UC8rejMvLy91NjIyRHQ4L2Y2WHRFTzNtdHkrVGdqS3lIWVkwVjJLQWtWRzk4aWJUbkVxZytTTmJCS0liZ0lKaXZTT3ljM3h4bXZIV0hzczZMWW5SVCtjTmY4K28zdTB3WVdtUmZMMWxBa2FWQ1hTVytqa1F2SjVNaUlUV2JybW5mZGtLdmUxR2VqMVRyOElXUkZaaEpRNWxhSDczUjdiUzN3TzFtRUczclp4bm9LTzlqdGFweEkzTkZKemZnVTBha3pLaEhieGxqNmFFZVFMeEQrYXFaWVNYcDI2cUdpK1ZrWlBWVkVMQjNFSHBieFRtbzhUbGlqTWlDR014bk51T1R4SFRMbFdCcUp6bytiamlwaGdWZ29yWG1YT1I3WjErdnlFbnkraXR0SmY1L0g3YnN0YTc2TkUvRnQwTUhuUjRPUmM3L0VMbGN2aWhTeG1UVWhXS1YvVVFJazArY3k4V240bC9lNUxxa280d0FvVDFCdm1XTmVqL28zUW0vdnowbU80bVNHV1hpTVBsVGtMZEozcG5jNjlSb1JVbDBNTlpVTitTbVBxQ1ZXUkxUMU9TMi8vSW0ydUdIdGFFWnQwZGRGRkx6STBUNFh6UjA0bGo5eWhJK3MwNzh1U2drTnZhTWJZa280UkF1c0xJUnRBRTIvcU91UXhJMWlxclExUmV1WWpJY05vaTBGMFFScVpvRjRkdklscUtSRnJzWXRNT3NENHk0SnNVV2RvaHRZdlhiWlg5bkxEZVlSVnNRaEx0ck93OUJoekd5TXVHVVBHSHJjejd4SzlidVdMMXFYTnErRXQ5VnE2VjFxdlZ5T3pkNlpyanByUDZQMC9pbGtEVlRzL3l4NGpmVmdUMTFOZ0tjVVZFZUkvYUdtVFVtWnk2c0l4cFRMYXpYbEFkalFkUXU5NjgxaWljV2R5Q3IwVytmdjhndjdqa0hnNDZQcU14dGtIaW95bWowUVlhRVkwUkJ6RE9zK01aeG9YNTFjaWhCQkNDQ0VQNEdHdXdlTThvVE52K0l5eTZlb1NRZ2doaEJEaWtSL25KNXdKZlJTeUNBNHRRc2JnVXJpZUs5d25kU1VoaEJCQ2xrT0RnOXdIam1aQ0NMa20xTStFRUVMT2hPc1FHZUgzKzYvM1Q2NG43TGt4YTlzT1FsNzBqS2s3ajhQWEwrV3RGUUM5LytJY0g3REtVR1U4bU41eFNyWUUyd2RSSVdpUm4yV0l6dHhtcEhkUWRwUXBiajBQWnhva3NvVmZQYXFrUGFxaWRTcnhOTnJBTHFObDUvZC85M2UxUmtHMUxabS9TNU5ZOXlXaXY5TEhycy9PSitUMWhocTNiYm9FWmZJd1BVTWprZzlCMGdFWG0vOHp4dVNLVlZWTDUrYjlidU9pWmZTMjBhT2VKZ2N5YXFIZUVzbkk5U2pCOHlPeVY4UUVZUi9yTTBaSUFmMkV2Vm91NXZtUk9wenJvNnlXZStRV3BrSUVSMXh3SjlUQldvOUhESWxldkYxbDIzUlp6cDZkT24wOUZtdGRUQ2NQNnRzZ202b1hRM2FlRWZ1ZndVcWRIeTBUdmI2Q2tmWHB6T1ZFS3J0bm5oOHh2eGZiRWVadEZ6bU42QitoT21CUVZ4eUJWa2VrN21WV1A2Nnc5Yng4bW42bFQwcEc2WGlrc2F6c21lOFFlSEdkSkpROXlVUWxCR2ZFV090SjMxT0hFWVBMQ25wYmdaMk8reXJBQk03SktOdDdTQmU1enl2eFFYRU9WVndPaGpPeVVjUzJYNiswQkI1aFhrYVh4TjdyVXBubytZaXNpQm54ZUs2c3BzZzRvNzZtZG96bUcwbUxLZ2xVZ1QyUUVVdHRWUFpxNktJQjlQcko1SktvS3ZFVkE4N1krWkd5T0VRZXdxaUN6K1BSQzIrc2pmaHFOQ01Vb3AxbVBZKzRtWC94KzQ5R3pmK25UYi91Uy90eGF2UUJEWjB3TWd2MW0rck44Y1F4OXpFS3M3ZWkzbnlldUhKazU5aXJBcmtwN09oNTlMUmxydjRwYVlwSUw1LzF3dDN4b01yTis4VkV6NTNNV21HeWZLcDlreW9rYS9SK1N2VnY3cFNOTE82R05TNVc0ZnVQTW1wSS9BaEYvWUhSdWVTZEd5dmRNN0M4UjJRMUo0WllOTnNsT3VTNEhpMUhlN202NThlcTdEWmlZa1hMMExqR2drRTIwMzBkalV0TkQrTkk2eThoSnpGcTRSeGxSWitPOUFMYUZRSTJxQW1ibkhSRGhjeVUwK3M1MkxJeHJ5a243VWVwc2JwNGFmRjJiTC9jV3VDWmF0MHhHbTFZc2RpamhvVjMzcmxjcW90bWt4c0xjWFI5YmtWcFRhN2xSZkM2SU5LZG9HZ3JtK2VqcUtHRllDVzBseDAwL2x6dmVSSGlORVpVWTNRTjBQS3RhSy9lRU11SXpKVkUyK2hUakI1bldjcWpka1N3SGN4cDRPaVVpTTVwZjF3L3VnZDFXTjl0TW4vL3U4S1dRNWY4S0ora1k4bTFHWEZHSlZuV1dwbEFtVWljeHRHZFEzQitrY3N5WXR6MFRwcVpCbFZkQitHWkxGclV6bzV1alFCQmlXVGwvZzkxV25vZkJDWWpuOWV2bnRPQkdqOFRZeEU3MGEyejJaeEgxcFY0Z3NOWTdaSkVvbmZlOVpFUkZwRnB5WnBoUm96VWdZRGs0REc1Sml2OTRGckdMQk9pcmdQaUx6eWMzaFVmbGQxamZVeXdJa2h2WTNKUlBKeXBUVDRnekxLdk9Cd0lqRFFHd2VlZFNjamFXMlF2VklFZG9BdnZ6UmJvMytuMW85UXZsQkh2dlNCQXE0V01FbzNobmFqZHJLRFFhZFZxNDg4SUpYZ3NsU2trelVDUjJibE9iZzQ3ZXB5UjlkZDc2UzNONTdPN1BLb2NVVmxBNTBYZUFDcG50TElYcWV4ZGtEclNxdllDOG5hR2YzWHV1MC85WTJwZXlsNERLOUlTQjR6SmFGUE9uTTVvR1E5RDIwV3VmbEZ5OU9WcW1oSEVCSEhLTkYyd01KSTJVK1RzNnAweXA2TCtQM2tNWjc1Y2RBVXo0akJldXJJMTdTUlRiNFZ1N0RWRk5kMHhwZkFWY21ZRjZHejJTOThyMXIrOWtxR1NKL2htYXVyZXRrZGU5MEFmWG9BQkVjL056WWlRQkFoTFdIMGdzaThuVXBYZTRUc0x5Nlp6K3NDYlVlL1JzRExrOHZLTHRvZWJ5aHpleEFVOE43c01OTTBKenpSZ1ZvUS96bWo3bnJROTZXZmxqY3J6Vkh3VGl3aFhyV0JKNnArRzlJWXJSL1RUYUloNEtQdUt1VkxuUlJxWGtLTkExNStaYXdUSFBTR1RPR015SFJnZDd2MWtlM0VjaHR3dXhCSERXZ3NDcnpET1cwYWNGT242Z2xoRUQ3c2lnckVJcE9tOVdPRUN6bHJxSW8rVkl1KzZSWmYwR1k5TFpwc1IzdU0wTWdBYjg3TTQ4NW5HTE9WSWZ5TE15bWthRFgzUENxbjBYTDhkbkFzZlE4Uys2aEtXTVBlSllSb3loUGRNSTNkZmRuWDNnWkVJSWlGMVlFOUk1Y1A0TFo5KzdiTDEyajJMUTRxY3pJa3ZyTTRJcVViemQ5MWVHeTNUdHM2WmdmRUEvM0hPQ2htREx4SE00UVFkbWNFMDdGNk5tZHBTYW1YdklSL2FNOTdnUXNKaVdwbGVYWUl2RDF0NUIyM2ExMTF1NzJyN0ZhTFhGNEQwTC8vVTBpVHNSMWxJemYwNlJPcW1HUmFTbk5rQTJnTnJFRHh0b0dnMVg3U3NoNEgrT0JXZHJteHkwZ1VIakV0a2Jsa3J4WmVNR2FZT0RjckhFRm5hVWFUeGZPc2hGWW4vU0taZHhFWFJZazRyR2hkMUc1S1Ria29sVmhiU2Y2UDExMGhibjZVKzkxTkNnVXErcnIzbCtTWm96WVA5MmpOWGVnazErdXJLQkpnVmltaGxkUVNnVmI4Q3FFdjdCVUlZSlJUUmxqVzBMcUg2TnpLODdYQkV2RTdlK2ZwYWUxMjd2eGxrOEhvQmo2L0FtZXZ2VldVYlpVbXhDUGRMcXNId1pLMmVjaXZqbFdiQmZYdDZTL3Rpcy9aeExXbSs1QlNzKyt4K2JodDNSRThUc29xUmNlODk1NThCT25keThEd2h0NkxILzQ5T3JsbU8wUVFreDBuNkpMdFlwNmp2ZlNWRHVvZW9RNEhLV3RHdm5kZGVRUEdQNHhlRkdmRXJiYmFPdXNWb0dVZk5BcStzcUthN3l5d084OWdiSjhQTWVLWXhxalI2VEJwaU1tUGw4OWFoa3B6bFYwaHZBUzNwQ1N2ejQ0a2FFbHdERHFmWG1rNkJmS284WUFLYzhVaUQzSlI2TWFnVU1QcjZSdFFqNzRGbXhDU3NEcndwM3o5TWJVYjJJeXdOY21tS2NzeHhlU2xRNTRhTDFFTkJYdHJoWVBoWU5IKzhQVDR5d1A1WkNBc2EzRkJQTWRTdWU1OXJha1VESEdhbFV1bVZUVVczWmNKdzlzd0lOamtKODVCQmd6eFk4dkpIeXFwalNKeVhaSVFWZmdPdEs0QVNQSTZtbTBHa0xDcWlMdTdWYkF0bi9SV2VtOXdseUVJRi9lYldhb3Y5dkI2MmNZaXVwZ0xiV0ZvaWpwemZhRmtqSmh6TkxFSUFSaWJLQ2g4ckdnUkNudXZXMXdtNU5aRVhHM3BYNHBsNVpxL1UzOVpOYnEwYktvQ1BvTlhuU1RsdTgxeTBlNmMvMHdpYzk5SkZOTVVma0xDTzFuM29kVElScWozU1MrOXpGdlJhVHgyaWVUbjIzNngyaTY3UTFPeHVjZ1dpTnQxWmNWaENWakhxcTVDTElpbXNHeSs4djM5Mk9xdUNTdThiTHMxeEF5MFNzaHJ2d1llVko1cXZBWDMya3NEcmtUS25FTDJCcVBoS0hxb0t0TjFCdkIrNGNXRjlFUHdWSThiZ0pQR0M0VjZhQk9Sdno1M1RyVktwcU1ieVFrczlqeFNDaHBPMmxiMVovcXZzMFRmSUkvZVB2czJPdnMyQTNHZWRwMTZRdm1XVXhvWnRQd05Rc05EaFQ0MysvdDgyUmRuVTRlZDZmdWRwcGZnVUpmMzJQdU9tVGhGeVd1ZmJhOWFZaW9LMFI4RXVvYmVER2lBV1hKOXNtaW4zUG1lb3ZYcGExbFB5ejkrYmJ2YW03U3ZkdGlya3FlaXFjODhKZzZhM1NPOEZoUGJZbVg1alNIcTQxeUZFbDBieUdORGxObUxCV3BhcFpiR1BlQU9uRVozNE0zUmtwRUdpOWhUYUdjbEloNWJwM3NjUk40amRhTm40QmZuN3VBZ3A5OVE1MnpQeTJaa2pmcVlzTDVMb2xhazRDTm5LMS9pVVh0VTBYOVRMWjE2bzZtbDl2UVp0SGd2TjZmUzZiMFJCVy9rQm1kMWhnQ1Q3SkJZN21kbXVFekw4cFNGU3BEeld3aVpkUjFpNXFMWDFlNTJUemt2cFo5Y3RFb3FJdHJVZnpwbS9GbHJYcExLbGZLaXpNWk5laDZnbmp0UG9CbFdkbDgwLzIzbU8yRVAvbCtaWFVsYjFxRTRCMkgwaHRlanBrbEFYT0VSYWdMS1BvT2xQTTEwQzByWHBDVG1TNk5vUTlZdVNrejRCZFNMa1Zxd3dMRFdIS1ZxbVpxQkZDUm9SWHBiV0lFcjE0bCsrenhmYzMwMy9mUC83S3gwUDBoZTlFY21SV0lSbWpMZDE4WXgyRFMzZTRTUXZhVzg0NzJURTZ4UU56N1VscldaVjFNdUxQNCtXWVpWWm11T1dWZ2JxTGo3U2ZCNGRJRnJIYWVYUVIvbHNlbTMzTnMyWlNsTmNFNTdKQ2l2U3N5WldQa1hSZUV3M1I1NWRTT2ZwTTErT2w1b3l3L0d0K3pQUWo5RkhHbHpTSDQ2bDBGdGpIUncwM3RJZldVTThjNE1xYndKMUl4ZmwrSWI4ZnQrcEdDeWloVWt1Ums4OGNFS1IxaXk0MUF4Qm5kT0pSYlZoOTBoN1JPMTk4aUdNT0dicy9FTVlVUlVsZVAxY0hTbTVuMmVWTFlBR255OUZyMjE0VDN2eTc0dmdjeW5mYmR5dXI4azQ5czdmaW9nQ205bFFYSi82NkZBWnE5WW44a0NpZytMQ2d3aWRTbTBjaTVBN2NSVnI4alp6SytyWWphYUxwa1hTejR3UmZuREhTdkc1V2N4cmxrL3pCMWUxYUEvV2E0eGM3VCtGOGoya3JGRjFWdlNLRURLZkk3UnoxTVFKNnhWaktUeDg5YW5mbHVmU1IrNUltWHpkbS9EU1hFSWZRSGgxNE90RzVKS3NDQktmRVZTWlJUTmgvemdybXprSy9wRHgvWjZoSVpzMExGQ0k2RkNNNk9jRmh1WW56SWpaY3BDZWx0NjNpNVlwbFVPeitVSlFIVDZQRWIyTXlvaW0wOUJlK0YzNXdPRmhYTWt5WW5lU3UrS0dOeFlaUmJTM3lCbTA2d285OEFzalBkTjRpTkw0L2ZmbXEyRzUyeHBBKzlGcTBrYzVJYU40MjhFc0hITlNFU1hwdTQyZGlsU1p0cUphQkt5bjdab2RHbktyT3NyZVZ5VVB4ck9BdUdhY2l2YVRUVlROb3ZOYmlsY2Q2NXhGYW9ySWlkUzhqZVNWN1dHYkxnc1BBMTI1cmJCYVJrOHJJeVBBZXJTaXZUQnI0WTIrU05zN2k1N3p5WlQ5VjFHeldzTHJwNk50UzJ0ZlN0MS9TVlVybzd4VC9jaU85V1Z1WkJiaEx4eXB2cjFHUkMzUDZsZW5qQ3NhR0NQMjFSMW9wdFNtT1FTN3NhWW9xdkdWL0o5R3BwU1drS3VEcWdoTnZUVldoQ3VqT05kYjJkTDFLWE1zZXNPYzJJOG1NbTYxb1ROaU5Ycm5iN1hVSXlhN3B4eXlrMDZUazVTeWtRRXdwZkZuQ1pOdCtGalpKWmd1dTVMYnhpeXViUG42VHlyZGwvbjVXcXVIRitSdGE5dTdPQ0FEMnl2Yk82ZWtpUVJYM05zVGhMMCtUYmY3L0dacmhHZXdES0N1WGg1TjlzZ1VpNFl6bXJya0pvLzMwWjQ2TEZBM1lSbXBlMXUzWXFReFpKUmsxRi9yZzU2UWloZk9pVExEbUszelNMSjd3eEYxSGJUN1JzdUkxQUZSTjVIOExVajRycjEvTFYwcjh3d2lhcnJPNDkxL2RWeWE2MnFSaWs0cFJsbGFNMmZ2aE5QUFl0bEZUMXZIWXRUMVI2dVRWWVkzbGxBakhUTkg5R3ZJdXV2VlJVT1NUVWpOeUhvVUtXT2xmS3VNcUMzclVlc2l6aWt5RFdzQVJ5YlBFUk42UmxuTmZiV09RcEhTVnhkYVEwTHovMHdIU2pFQU1qcXhJL2N2TGZiVzRvOFNNWnlqZUFaMTI5aFdYclQ4d1hHNzA4OUtMR0tUdURXMGVoZUgrYk4xeG16dURFVmc5citBdFVSbUp3L2l5a3R1c0RmNjIveGtFSzlSUFIrR1hCdFBhY3cwTTNxWEozUk1TUXJwQnVOeDFQb2F1ZDVpdVVNUks4TEtaMEgxNG9BT0ZpOGRZc0lTaUVNZmFXUy9URFZ2a2tPcDdPNkhNZkpNWThZZ3J2aW5FbC8vYS9rQkd1TmUzODFBblZMdDJvUFdoTjkvLzdITUgrUTZJWlB3ckcwdDNRRjRzNkRYRHh6aWxFSUo2WVJqOVhMTVVDR2xJODI5aHdKb0wxbU43emJRMCt3eTUzNFhySVUvSmZhMjlYai8xRTVpOVBiaXpZSGU1OHh4TnpDT3J6Z0Z1TVl0aDAxTUlDSks4NmFEcWl5K1RzZ3FyaDdldU0zY1dIMGpNOTdmaTE0L2hjL3l5ZERhYWcrWGlpRGhtZXZGRmZwY3FVT2VVRGMrQWxwT1pONU1tMlBzMStNNG82M1p2OGN4c2EzRGNiNUEyYmR3aDN2RGxEUDZoODljaWNlTThiSGEveW1kMTJha2Izbk5LYTVWWkNyZEQxY0gwNDh3YXpMMXlEcHpZZE9pREZka1pSMUhGZUdDdW8wTXFRbk1Ic1ZITE0rUmRMT1hQajFlSjU4bmhCekFrUTlqWitscDlCY29OMkdrMldZMU9kMmhoOUYyT0FkQU4wZVlwN1NqeUdsb0x3UUhCbVBFZCtFWW44UXMyKzRCSGZMN1o0dlZhZ2kydit4RmYxR1NuZXR0MmpOallPUmFSTWJPWXJ5ZmFML1NsTFEzVUU3OWNlb3NCMUxxQzYyTXdadlZBbWVFRUJEUFN3SW1sYmE3aVpiMWwzUDlRdW84aU5jUzZNNEprU0tqVytiVTZhWDZGRUZHdEVlMDlDTjc2RXdZcUxXTSt2TUFyMCtpdkw4ZzAyWlRaTysrbFBxVy9qNytzWXlMVWlQNWZGWnlGYkJQc2lKVEttOXZkM2hqUnp1LzBwRG9HVHRHWFFUWFpRcVd3MStjZkY2YUI1SGJQOWd1NUF5OCtZdnVaRFpoL0tKYStZaG5pdEVWSG02R1ltVHlicFE2Z2pSNDFxSTNMdEdoMTZaNXpGRHN1ZEdaOXRZc0VBV2xmdmF3Vi9sTDF5TStWZ25JUmtmODMydWVQN0ExbjB0VDhyYU1vbHd2VUZCUW0xVlJIOFhLNTVVUmJjdElIYkp4WGtnWC9yR001cFhXbHp5L0RxVEhSZE9HOGNqd2paUVJxZXZyY2hVdXNLNURWY3ZiUEszczRreVBMdlBTVyt4YXZJY2F2WDJDNU9sWlg5QzhNMElSbnZyeXptdGxTZm1pYlJHMW42VjhLL3VuTFF0SnE2bE9SRVpQWFVHWk8xVmE1T3pJbDFGMzVCUnp4c0Q3M05TbDZHbWtMNm51dnB6YWdzNExLNDBXanE2dlI4b2FDVk9pam9SMy9uV3VOR21zY1UzSUgwWnNueXVnelNscnJsajUwV3VFcUVTTmlLUFJKbkIwWWtmdTgxczJiTE5hUm8yUWJnb3paTFVMY0k4aFlhV1gwa1dWbk9jQUkwNko1OEI1WlRkbGFsL1M5ZlJ6a2VJYllGMmJNbGZNV2krYWc1NzN5dEJtYzFSV1RlMkdSK295eXFpN0d4bXBqd0NLUTZkNGpJMDhqNUd4NU1sTWdPeW9MQ0xTbzllUmtKRVZXcG14MWhHSG1ZMkp4cXNJeE5SUWk5TVhrVEk0L3g0Q3VpNUg0OWpvTlNOWnhNenNmYVJScC9Qa1BKcm84N01IOFB0bmVIRVZKQmVHcTdsTjFEbTE2RlFIZFJXMEVPeUtZQ1FoNUZvOFoxNC96WGE2MFAzT2V0NzdRY3lNVDM4azlmQ1REQTRwZlU4WjFqR2FqL3hsZ2oxSmlBa1M5ZUpnZ2dpcjBqYUV4SWxMRG9KUnk4Vm9hL2RNZSt0SWJxbVg1dmxrM2t0bVZPdEJYcjhLbXY1Q2IrUkZXWUl5dmF1UU10TUZZQmlMa0NHUUllV1pUZEVoaVh3cEZUWFZ1TFozMHZxOTFDdEVZMFk4K2t4UUI0RnpnQnpHcHdZZG92VkczM0pkRVlqVjN1aEp6Zm5YNFFxLzl3dytZVUVmNkdkMGFPYTJMR0dNZlozRzIrcklXYnZ5OGJCM2ZrUzJKNVBMN1FXaEQwQ09aTFlaZ1NvVmp2RXdhTk5TaFJBeVJtVGZCL1M2bWsvWjc0V1FZYmdZa0lmeCsrOC8rZWNmYVFPc1hkRHArMS90cFhBcGR1VnQ3MEhJSDdTNEo1clhHbk1neUxPWDB4L3F0dmY1K3JjQWVaQkZyaGg1alRKbTdhSkFQaHdhVXV0QmYvMjlzT2lXejV2WDBTaWM1dTcydnBLRWxpRWxrOUpyaXRycnNSWnZJY21COUo1c2I4VTFhRzNXcklnb1dOdTJYd3JLeG4zbXFvM2xVZUVaeHJGMmtMOU90RTI3WDMvUmZ1bnB2K2lZSDlRS2RiTkZuNzFyT2xJNzltUVY1M3JOUTR5YzNaZUNOaGZsdEI0MEk4Z1FMMTBSOFFzWEdqR2FhSFFGOUtyZDZ6WjdzbDBadWNtUDZ0ZlBNeGpKQVNEVFZac2o2Qnp6eWtXNDNmQ1Zmc2pmMmx2MU5VL081UnBtMVZzY0w1QWIxNXdXOUZqMk51cXZtTzR0OUp4S2FOSEQ3bnY3NVZTYi9UeU9yb2JXWWxLY1VyMFZGbjJvSWFVdlNwclhhZVg4N25ZYUE3cjE4M05Udm5YN1VkY3NLZmxINW04Sm5yZTYyWk9sK0Z4YXM3Uk52c25hbkh1OVkxMkNiVkhRK3pSb3YzWllENlZTeS9Ca0ltb3FhcFQyOU9Oc1JzSWJ5QnpvcVhPdkVZN1VNWHEvYUo4bHBVNVdIV2JZOUVmb29ZNWk2N0piWFdIcGdXSmNhRzNhVFI1QjUxaGx0VjlLbGRLL2RVZHBqamNGNzQrMXNxR1BxcUZoNS9hNjE4ODVVS1lrWHlxalhRd2t1Wm9zTFkyMzdwSm5nbzd2cUg1RzBtdmpQalhuSXpLOU1nZ2hKMUVGYkRhQldjMENxUzYxRDI5MnZxa2dhbGRtSStzUVVNWFRVeWZQTUVlTkhzOWd0dEpGODJUbE1uci96ZjFWM2J2cjU1UzNZWk9KM2Q2N0hKMVpkby9MRlYzS2U5UGxCV1dqb1lkSG1jYW8zNk9CTm5iVXRpT2ZTWTlTV1ZVMmVkUHF6cG5yVlhISzlLeU1WbzRYcHZQQ2ZaSnM0c0Q0MEtYWm1MQUZTSGNBajdTWDdzak1OVHI2ckNyN3lVZUpodlk1bmh0Nm4yazhnTi92QnRnMTBrRExUQTVPa0FjVEdZTEZPYjRURjFWY0JUeW1lbmdJRDE1Yzc4eTk1dkVzTS8wZ1M3TmN3Y0M2a0pHbjJyQXoyQXIrS2VxSWUvOHBPL28rNGkyWjJjKzl0bUp1Nm9MSUpzT3dTWW5KeUh5OHNkOTRsSnJpL0NReldXclNUZVFqeHIzM1RodVNKK3J3bmRFd2wraU1NMGR0ck93WkhtbUIvTjVYMmxsOGdtWllVTCtuUFZlNVVvakJlWEZoRlU5NnBFSElYV2hWbHpWdmU5YmhuVjRRZEdXdjdtQllDNFFQTVFsS05BWTFRNmFXRG4yak9RSWY5Qk55SVZBTEpEaFIveGdhT1ZLbWRVd09vOXQ0eTVpTVJlK2pqZHJGUjVZOWttLzJqNW11T01zNCswL2dVeDZrRUprclRXamE5RHRRMXlyNkk1N2VwaDUxNGJBbk9ZVGNnN0w3QTh6M25iN2RlMGM3VDhoeURGdVBTL2VGS2VDNTEva0hkT0xmTDZhcU54cjgyWFZSL3BhT0NiRkF0M09aaVBmKzN1V0dNTHAxanZmUVNGdTFJZ296eVJzMmNOcVRMemdnMXRPcHNJTFRIQ3JhUzF1TTQyUFJHazFUam9qUkk5MmhkYjdZVlh1TC9UNVJMS1V2MVVzVTVxVFg4aUY1NnJ4Rk9SK1JJeVd2SXdBRnNHRlJRNklJUjJValBpc3ZXLzg1WDZMM0lsTFhFWmRZcXY5NnFlYlFNMllzZ0h5ZW9va09MYWxJZE5ocWRYbktHdGRNS1MwWUIzMXBReU0zMDcwcG1wQTMwdmk3NkVEeDFGUkVzNkp1WUFMTFNCMWxpeGNRZXZRemVRVGVFSm81SkVaOWtCUENWZjE0d1czRUZ0S0kzUGhLMlhYNkZNdzNMRHp5R29La3ViMkFuWnl1dHY5ZnZraHBydjQ5LzhPdjk5VWlsdkE2c3kvWnV0KzhPeXFRL3hnSldLNmFXVm9ibDZZcWVYdGNIMlR0aGVBbXo4NmZjSDVaSkowVGl5cDZQZHN3eG9qQzhnd1BLeDlhZGxIS2ROTHRtcmdwbzIyZWR6N0w5Y3pKL01KcTYrZnMvSjZlTnZkVVEwQlVOOUYrQnV0OENGZFlpQ1A5aklZSXRiSGt5WmRrYU5lOWNkclRwdHA5dHFEOU5xSzNoTk5mb2lRMW5oSWN4NmhYRE5mRXladC90cG1CUXN5UWNMSHp2RThWUUhhZFRoaHJXYXREMHZOc1pKWmdldStjZEI3VnU5NWNRdE1RMG9PMEJuakhLWTJ0Y1Jtc0N5RWZ4WlVHc0dkd2pZak9XLy92OVc4SjNqOWk0NVZrT0U3ZlZrOTkvSHBHVytwamlWK1ZEQSswTFNPR0JNb01ReGdoRW1QUzBxTG5qYkxSSWFTS1JNdU1GMW1uVHluZUUrNHpEU2R2VDg5YmRaMmxJVkQzMERMWnBiUkltVWtwdTZTZWtmQlFvdjYrMWFCczdPdUN4bmZRZkRQcTRsSFM0OGZVVVZhbDFOVGVrR2pUUmNKM2JYaU8rcnFUeUx4bTR4NE9QSC9SdmhuUXg5NWpJUTZQbXpENlRBTlpDSUtENVFnemd1TjZBTWtoZklEOTlmZUhxZldkaWhxYmxpaFpoR2M5SitmODB6bktRd29DUGxjbmQ0UHo5NUZFak0yakh1dDhITFRZTVY1cjNvSHRkR3h4MjlLUUpmNGVjd2hvNVRaSjlLVTBMNTJWRnIxT2hpbktBWnYrNFVUWFNFbDVSZ2ZSaHcwNlRZdU9ybUd1cWx6aGl6TDBSTkpsd3h4dkx1WFRGREROYTE1WjluVDB4aUkzdnJxUmFDekFvSzh4OWpUcCtkMndRSHQ4ZlRrRy9RWExva1VzbjFEbXd6bnJ5NmtlVkhVWGhsUHhFYUNoSk1UTWdzc2NHRnZkcHB4UTVxUDBEK2N5V1VrWlBPNHRzK2ZIcVZFbEVwazdYRGZKTUZkYW1WYldwUXllUjMvdTRNbHlyQnRvUGtlRC9FL2h4Q2lvOWh4bFVSY2RkWmVvelk3bW5ZVTFhejk5Vm5CV0UrTFFhMit2S0ZOTG13ZXVmemlqM1VBTDU2SFFwNzBFOFB3dGR2cXkrNE9RUlV6VUhWeC9MZ0Q2bms3TEF6cnQ5MzVuczlTOGhXSzBYanU2Ujk1ZUlVUmlaRXdGNDNqYVMxazlvcWRQQlN2Mm00RThJK25idkFNMzFidEIxSVNpeVJYZ0dqSE9wQWZUa2txWjFTMmYwODI5SnJxbHdRcFlodmJhYjNSckhhOXUyamtFcis0amVPNSthMWhXMTdNZ1E3Ulh2NC9Cengzc1M4N2Y1OHNFWnk2eTZwWE5kWC90bXozVDBCVlpxZ002Ym9QanRCYVBHZ1BvMUVLbkhOZXRIN1MySGFTb0IzclJoS2ljN0RoWXJsdXZHdEprdENyU091OU4xNjRtZTdWMTFBU2FYaEZ5TnlZdEx5TFNQT3d4THk1Tlc5bUlNaGd0cTcyMm9zRzZPcU8zTWl2OW4rZ3VmZnYwUmNuYm50K3JhbW1RUk91SXRvMVdsaVo3cE0zYlg5STBmdUd1RE9XaFJ1MUgxakpLMFVXZ2swdjlWRjhqdHo3WG5uOWZ6L0kxYngzdURVVklNbHZaNkxGRlhhOFNxRXJaWnQ5ZHR0ek9wbHMyWHh3c3Vveml0WDNIY0ZaL0dCczFKS09oaUZlYWtTazRnbmMvdmFHSVY5N1Y2MUVCeSs2ZEcyaTdXSG0wZGtERE9SSFFPTXRvdkVaSWxvdFRaS1hpRWFUMFdsUHVsb1F5WWVnVnZWN0Z1dGV5VC85MUdwazd5SmdvUVBvWlM3M1YyRDNqdVUxbmhLRTNaUkdDWW8ybGlJemVmRktadFQ4WUxXdkcvVWo1clRvUmNoZzlSbnQwZ2c0NEJ0M3p6U25UOVNPQVJiQTFyRlI2SE1HNjdKbXhpSlY0em5kN3ZyNldoZk1sd2M2bDFnZWF3MXhmOUI0b3FNeFQ0TDF4MlpXOU8xdTJaOHJXVFk2WXBwcE1TVFlDdXRSbjUvajI5QzRaQ0NXWW5ud21QZjI3eXV5d25oL1ZQTmgyZCtNKzM0eXNGWklGVU10RVEvc1dSMWhCSDBsVXAwdWRVWkljRzZZdW53clNWYjBoRkZVZTBJZXRHYTNaYWh3T055UDY3TXFTWWEyN3duVnRMUDJqWEIrSmRxaWhnaXFkZEV3cVVFUGlwdnhLaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFQU9SLy8rZS9mMytYNit4ODl2dGZ3azkxcFUzTHBQT0VvUFJzN3lMdDVMYTRDbWlSMDZaRTZTaGN3OXRPTGl0bGR0eG90SHBVSVIrS3QxMVRDenM2VHJTTlFYRTFPWkMyTjkzc1hZcHdvb3NKbXFmT0YxR2FiZDYyVEczcmZuUXZLSWtWR3RsYmtEUVpQUXRSblJkWmJLTGJBY3JDNUJyazZuclpuUy9oUFlMME12L0lMTVk5L0wyK2wrSGYvMHhGM051ZlRoMGlpa3JMeS9WbUhzb3dWajlDbGVSMG10aFc5Q0gyTmZsc2tNR3phaWRaaDVFaWp4amYzUmJPQlA5d2R6MDU2UWo1UnJNaXZIUVJwR0Z0N1ZaOENwNVpxYVZ2ODRCbTlqS2tyYUNQYXV5dno0dXRFcTRXbXVaWU42Mi84ZkpCSkkvQUxyTnM4aWZUNTRpa1M0NlViZW50K1JiVUlTak9kU0h0Ymk3MWFCVWx6OXRBQmtSOHBWTU1iS1RNWGtQQ0NVVU02WWdaYXp3Nlpab3kzcmVoaEZUYTgrSlhFTFBjQmZBWEZwMFllWmJTSW5JN3lsVFRKU0I5YjBnQkRTVWRvWUs5OFN6Ukd6cVQ4aCs1cnJiMGx2M3AvU3F3NlpJbWI3aTdVVDBBMW1jalc3bU9sR2w5T2RXVU5kTGZkZHJJMmpEYldIK2RsNGlhRzU0SlFVZ3ZLK2RVQ3NxVzBudStHRHAzT0pmSVJ6QmpRVnBWOWtqZFFEKzRMVU0xRHRwOGFXOXdaRXVwSUhYNUplU1YwdVcwVlZTUnN0cDBVZU1na3RaVGhoRUhONWorWFhUSDJNbWdVNXJSdHU3SE0vVzZuMmxNcUVOOXZTWmlScU9oMEY1UWw4MkM1dk5Fb21xbmhZMThUYUlUMmZPOVI4cWVpVFhPWmlxcUQrVUlkeWVxbnowNUkydkJZK2w5enRMSzRKeVpUdFNxTnE4cmNkYVpwaTY3blloSU9nVWNMSjU1MFZQMExEamVEWHBESmplQlgwd2xoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDRVErZC8vKy8vcXJjMlVWQ245L2gvZ3A3b3pkM3NoendUZHJUY3AxeVVHZHc1YXNadmFOTFJmMDYvYXltMFNKeFJKem1CMDV5QU9DSitlM2VHVjh5M292RHhBRFEvUXN4Y1l1bHV0dHAyTnQ4MkpVU2U0a2RDOXptYTArc2orbmxZNlRXYkMwN1dmUFNoUnBTUEp6dDlueS9mUjlqaEc3K3EySFRkbFNqKzJzdEZ4N3NuUytodVZNVURQa0dxSkRHL3YvTk1BdCtIcS9aTEl5R3ltWGZrUXZPWDNBZ1BBVWxPcmR2cEd0YmVWZG5jZE1TU2pTd0luTHFtWU9YMXpvQ3p2ZWsvNDZiSllOOVplMTVoa3dpL0x1eEV5d3k5b3J5Y2xIZUlYU2pKSGpGbkpSNGt0aHZ1N3dQeWV0VjlPMWE0anZydTNFR2w1bGJLUXI1NWEyeWdqWHhvWldRTzk3a2FhckJka2VLOHVDK3kyMUNacjhwbTNnWVlZd0NIVHM2YUV3eHh0WVpkK3FERlFObXBmcnF4RG5YNjB6RFBRYlByMnVqZVFMUm05VEI2L29lNXM1ck5HclhwZTgzU2pad3g5M1BNbFo2bWV5SmVlcmZ5Yk1tYjRacVB6ZHlaUk04Sll6Z2xaenFwMXAzY2UxNkJsRU5MTnB4cFNHcU1UV29zdEpPRzhVcWEzeUd1R1I0djZaZFFJMmtMYjNvZjM1ZFNqbWVWYzk4UXhvZ1pWQXNxb3MyVTgrUVYxZkRTU3RLSXNiOVphb3ozYXBMMm1xbFdtR2l0SnZpd3JIVW45c1RJMjZqMFlWVUN6WXNPMURHLzVSUjVwY0h5R3lHQ2E4djIvblB6UTk0c2ozRDhTeERQZHlhSFU4VmhvSGlnNnM2Y0xVUk9Ba0M4V0RBalBCTkR5b0NiQWg3aUwxK2RoZGhhL21FcklJazdWSGRUK2hCQnlVWjZxb0xrdzNSUDJLeUdFYUR4T1EzSkpJSVNRQUZTYXR5YWYwTDhjVXZma2FmMTZoZnRsbXhQU0I4Y1NJWVFRUWdnaGhCQkNDQ0dFRUhJTEdQSW5QZVIvLys5L2xSL3RiMytlKy90ZnhoQWIyWmJLMnphQTNCdGtWNTdGUlkvdURJYXc3TFlpTzFwNzE3TWpFOXdwMm1MR1JrL2taS3lkRzlCdEE3WDBaRTl2MjRHVExkS2RLWGg5TGRGOUlpUDd0NkIzRnNtdmJJL2ZmaW1selh2Z211Z1RxVXgwVzhpZXZsQStCOUQ5U1JHa1JqbEpYd2JLWCtkYkNib1VydzFsQ1hMWlB0NytyVDE0ZS9kRjk1QjFzTFpwOHFxd2NnNWRhbjZlZ05MR3U5NFgxSjgwejVBUlJUT0NpSXpFR2hiTjR4Ni95Tk9ncU95SXloeEdXckE0TWNrQWlCVWxwVVZBaDJqUEhEcDArRWZkb0RhZmhiZkx0bmRla3htcGc1VS9MRU83b2JDZ0FidzlSeU55ZmloTzRHNWI0dGFQMEw1NDZwMjN5OWJyc2orZjB2aHExNE96OHFwR3JISjlreVk1d1pVaTUvT01nQjFsTDhOSXNwSGRYcityWWYxcVd1VitlajRRSk1rb2dlRzl0R2w3bndGRXk1aDFFOHVOMDR0eDFQM082dWRheHBWcys1RVFVcTJtYXhWcTVLbnp0UjhieTRJc3RDNW8yVm9kMEsrNVdyTGVaYUsyblhSKzlSS3ZsV25sajF5djB5QmpLeWRDam1IbG11SE4yNVJzVzdaTmc4NzNpR3hDaG9rdVVCRzUwZnhXTEtLV05icEFHV1hzakpZQngwRXpxS1RyR3htYWdlbFJwNDhxeDRoUlU1OVB5dlVaOUJqYXpuM3YzaTFvUkwvUVloRXRVRlVjSjFySTVvbStFeE5tYlppWHJKRnZEaU1tQXBsRTd3TkJjZzZlanhuSkw4bXdsTWJvSTQyZUpWOGFkN1RoMzBTdGlKbk4xV05Gb0RKSmtFaG5zSkZQcC9lMVVmVDUwU1pQNGpCNE5LamIyeEdQSGczRGUrbDc2UFh5Yjgvb000MGJ3aSttRWtJSUlZUWN4Vk9ld3B4SlB0TjZwOXRGQ0NHRUVFTEl0WG1hdjBBZmhaQ1o1S2ROS2FvUWNnTWVOMitmQ3Z1WkVFSUlJWVFRR0pyUGhCQkNDQ0dFRUVKbWt2LzluLy91dDFOdlQvemZVN3ZmLzJPNHBKSGRYUWdCZnZIZk5hYWN6ZVBhNHIxZjhFOG9haDByQzNkMlFvNXNuS1NKcElwNEdGd2p4dWxzUTJVYWIwUUFZaUF1clRPSEdOMEpWMUtlU204VWRPczZkUHV0YU4yUlBKRXQvRVpSeXVxeEl6cTNKWXExNE92THFWZ2J2cjQyRkZHSjdSZVBQb09nMGtjVTFSbEs1Yk1WMlR5YzlXaEZFOUdNSUNaSExFZWRqS3pDMGRVMnNqUkdkM2NGRnlnaFl3Qk9iRkpoeFJ5OGVNNFJhOFlwdzlTYnNDUHlQSjNaczh2MlVaaGw5eTRHSzI0b1doY3ZZcm1sS0Q1TVRycVAwbnQzMnBkVm8xS1NXSnZvMXJKdEdzcy9WaVlSK2dVUmpiSjlmaUplODJTcWdXbnJmcFRUVWFYWUUyL1hock5xU0V6RUtmdmQ1Qk9xMEx1cmRtckt6a0JZZzY3bUpIckc5eWZRY3grelE0TWpodGJCQXp5a3pweGQ4RXNUNS9pVjVmT3BrVmttM20vUGwxTGJPcmdmeHlxNm5HalpMbE1VdEhNZE5TT2lab2FYRmtsUG5zSE05ZWNJWHd4ZE0wYlhJNmtNenBtSDgrbkdtdVFvdllqNHB1ajFEblpmMW5RV3dlNDVLZFY1NUR1T3E0aStEWmFNOUwzOTZVWDlJNmpCaE8vVG5SMjZNU1JmNHZMUHNjSEtKZEJyMGFSY24wRnZiMGJQMTBUdk93RmxhVm9MSGNWY3RnTm9TNEkzc05uSXo4RHI5NGp5MEdUMndQRUhnVTdia1c3MTFvcklldFNtYWRNOXZ0dDdEUW5PbDhNWVVXL3FuSEVlRDBhK21CcXRDM2tJSTBZOEtEcWFmdVVqSEk1dmdJYzFFcitZU2dnaGhEd2NHb2hud0ZhL0kreFZRZ2doTHg2N0puQXhKSVNRUzBHMVRHNEZCelFoWklESHFCRHFTa0lJSVlTUXlkREFJb1IwUU5WQkNPbUFxb01RUWdnaG44cHZjNHVrRjMrMkFTaDVteTZsL1hGcC9pWGtEKzAyTWQ0R2M2bmpPcG9tK2NQWDI4Mm1KTCtvMFYwRVZHWnMvK0Z0dHdZVS9iby9kT091NGh5UDdHNUNMa0IwZHc5MmREL0J5V0xwdTFuZDRPM1lxSjJiVTVxWDdwVjI1bjVpa2V0VmZYUGFucGUySVZPM29rZGFPU1cvWHRhV2pONzlhT2VMVUxhM0IyY3JROHBmSFc5RVZXMVpJdnZIOWUyaG1zMDhmM0lWNFc5c3pHWDFmTjdKbHNwTGpSUzdmMGZReG80bWYyUU9DVzJIM0lLM3c2aVhIdUdwYTVkang0OStPVU1iV1dnZWNtTkdkZ3oyMVBGaVp1d21aNm16MW83TENiUERQTlZYakVxWlRWbFMzSXlvODliL0VwTHNrRkYwQ1VmTmlNWnlOMlhOdExKZ1FMTTVhbWJ0OGxyWE5ieFlFMUtIWHNReWNtY1pVWU15QWhKRnJOUEpqVm9hZjhHUzl2cFM2bDZpN1h0a3BjeVVkQi9GcmtuRVIrbnhnNVVCK0Q3dCtJRTdIMXlUVjdZaXl1dVAxeUpaa3J1OXNucGVxYnVyalRaQ3Qxa2k4MUxLSitWcGxhV1d6cE1kbVZxV2E5MGFSeW50dms3cWRjRTdlOWxlczdwVGttZVZKWVUxa3B4RVpkY01LeGVpVVQwOU94UlJ5MExIODVIMDNHKzBqWHZ1czdkdG92bGFGVitjTkFpRFl5aVNIWTFudkdUK1UvUnJxZEVkdVdvUFEydjdaaFpReC9ZTHFkNFhZTE95WkxTVkswQlo2bEwvTGpRNWhTbFlTK0RvM1BkMFMxdWVsTGMrRnRZalV5YTVQOTY0UVd3YksyM2sra3UybGM4YnQ5cjhqZHA0bHE0Z0Q2VjNrYkFZTldZampCaE9OY2hrc2haY1kzTHRmTTdXSDI3U2JVUmxXVTV0NUlTc0hLU2ZVUWNRUll1MUlMU09zSFU5SlQyZTBkWWxHZmxReHljYk1sSWdGbEhKMk54bTNsWkIxTmx5WFdmMmVzL3kwc3B0cjZNakNWMFNSMDNka2JwbzF5T3hCN1MvVUZQbTlsZ2ROenFRTlRTMVFPYlQwNzh6eS9Eb05TTzBZMC91ZzdIQ0VmVy8ydlVabHEybmg3MnkyL05Ka1ZjUzFRd1VtTGZ5VVQ4dkIxSEwzakw4VGdlYXp5TmZTdVdRZUNpZW81Q2E4NW9NeFZXelJQeFN6aWZuZkYyazUvM1c2WWtCOGt6RFUyQTNhV1IrTVpVY3g4TWNHaXBpUWdnaGU4NWNIWjVTOWhWVzREUHE4SlF5Q1NHRUVFSUlJU2puaG1QcEw1QkZuRGkwTW9jMUlRU0J1dUlac0o4SklZUVFRZ2doaEJCQ0NDR0VFRUxTNzYvWFU4U242ZDg3WWIyM0FrajRMaEhjVVlYVVJCN01lVnZJQk1kWXo0L0pJN3ZZSU5OaUdiMkZvN3VhTm5seVU2YTNVNXdrOG9pZGc4aUJqR3k3Ukd4NmRWK3ppdytDTkdjdElydHp6ZGVScUNiUHpyRzE5OWVNL2NRU21MZE4xbXkvVkN6RkxOWEQybExGMndjVEpiS1hEcExIdXE1cy83TlppSElTUHd0ZzFyR1NJVXRXVXBYdmEraWVkQjR6M2x3YUhITlR5L1RTSTRxczZGdjBGVUFrcWl0N211ZFVvKzlFVUZYNFNnNnVRNXFOcnUxNGw1dzA1SWIwTHZuVzByZVl5TGh1MDBXMStmNjJTM1V0cTNYcHFjT2ZDNlZPSEdsWFRsZ3lpUmxXazhacm1QNUt0a1hmcHI4RW1yc2dUV3hMb1NBM25vejhsdndFMUtFWHlmQUlmODVkdXdIRS81T3VJZjVTZ3NyNitZcHBNcTk3MTdibWRURmx0TWZ0RjFWdG9qNW9CcThYUFpuMkM4SGMxRVdiSzYyYzlzdXBrbnhSVmhiL0ZHV1V0c3ptZkN1MlNDZWI2MUZEUWtzbk5UbGlTRGd1bm5rY0FaeVd4VW52cVFucmg2ZGEyQWFWV1RydWY3YnEvR0tWZnp0VDVtaG9xUjNIUGVyWnc1bzdYaDZVWUV5NHF4d3ZMekwzWnZYOWduR3BxVXJyNjhtYUhPbGtFWVJyc2tJZnNBS3ZsMDVkVnpyV2p1S05EWEFwMzlHbVE4Mk9CS1QzeHE5WEZ3UnZyU1RQUWpmZXQya3NzMW1UT1dPdDB1U2hzaU5CcHJwc3poT2lzdEtBUkJsVi9wWXhwTW1PeENMcXlTUmFOV2svNmFwLzMwVnBkWkNLbEh4aXcvbHhkKzhaTVpSN2xTUnFCRmpPK0dwRHdsTEl3UWNrYUN6Q2lsL0FZQmtSRjZ3ZDNmVjFwQWFSVVJQVkVDUExNenBMTlpsb21ZZ1puTk04RTBJNmZneElZN2NnTVhzcG5YZWV6S2VuZnoyMENXc3RROVpZa1B3SjFFZEhIbWxZQ2lxaW9EOGNWUGYzeW4yNVJwWkZoNElPTWUwYVZVekZxRGxKRG1GV3M3L25ReE52YlIvWmpaU25xVjhPblp2UzY4cit3Vm1IUGJPeHgweEJ6WWc2UFZLWHh4Rnh6cVI4MnZFTjhMK1lTbTFJQ0NHRVBJTG5MUGswYmdnaGhCQnlETFE2Q0NHRS9NQlY0VGdlMHRaWHVFME9hM0lIT0k1dkRidjM1ckNEQ1NHRUVFSUlJWVFROHVFd3ZFRUlJWVNRVHlmLyszLy8rL003WFdQcmpkLy9zblpNYTZVcTV3blJpRzQzTm5HTTllNVFJVzFHMUJMZHpRYkcyMTVPU3VmZFlQR0w4a1JyWXJ6dW84cTRPZXpZT0ZHZEdCQVgxVXZvUEVXcTFLOFRSL2NPc2pRVFdzYklIalBKN29UY3RGNVhJeUdhR05IUTJ2V1c2RjV0MW9Ma25XL1NsTjYrcUdYTHgvWlhpWExhZjVGT1A0NlAxeEl1MHllNnducGJORVpXLzA2UTRZc09LVWxPblk0R2lJd3hqTis3eFFsSlY4SHVJU1lsa3FEWGpoZ25PbzU3NTlqSUNtbkoyS2pkaUdFNTA2d2l0MmVHaFlkYzk4d0tyVTRmWVRZRTR6Mjd0Q00zUjd0cWdKaC90QjJYK3RvVzgvcy92ZU1HSTVQYUZzbG1rWTF2K25Vc0ZWbjIrV3JjZVd2ZGp5TGt5UG5vNlp1UnVsamJ1eHRvM1dsMWIzWkNEZWpROEc1LzVNdXB1dERtT0NvTDhjRjc1S2FnREtzdXRhd3p4bmZFMExCa0hhVnFSOWQyMUk2WTJSZURzVzdwdkZlVUpiTUh4TnhhTVFRMC9RWHJ0ZGR4Y3gydTYxSGplaFU1clVOclhFSlFacXlCU0Z4ZFU2cUVrQTVXR0gyOU1oMmxzWE5Pc2w1a2J0SmwxSGhINi9hcGlpanFFRnZ0Zy9aenhpNmpzUWhBNUJXSnR2eUliSzBNVDRhMTNGcnBaaEY5cW8rV2JZM21XNXNSTTUwNmRBQ1RlN0VxR0lHVTZRVXM2QS9Bek5iVEw0NEtpYks3Rzd4SGM2bTVqczRwTW8ySTZ0VEdOenBuc2xKWSt4aXdMVk9xa3paL3ljMlliUjhDQ3ZySXNlUjVxQnpYSFR5azBmd3ZwaEpDaGpoVmwxRDdFMElJZVhQbW92Q01CU2svZHVHbHdVRUlJWVFRUWdpNUFpZjZKblNMMXNNMlBvNHoycHI5UzhoY09LY0lJWVFRc2d3YUdvUjhLcHk5aEJCQ0NDRnpvWDFGN2dqSE5lbmg5K1pvc3hNM01LUks4RHdoTDZMYlFSVG4yTW5hb3lCalh4YUluUS9UdGxkMkNzMkdERTJtUWwwVUt0cGpvRHZKRmVFT2JwZkRVaG5vZkJ1ZDE3MXBqc05iSFdiVXR0NDJLY1U3b2JlczBQVlZJOExLTzFQV3JEb1U4NnFjeGo3V3QwM0xpcnp0MWRmWjdkQlpQWXRLNEZxdmhlV0E3QUsxYWhpUXY3ejY0S0QxM090dVFrVGcrWHZ3Z1A1bVZMM01WVSsyNHhleTRYcjE2TkFOSGQ5L1pDM1NpSnkxdENQWDBXSDhFV2FETnIyak1hU1pkU0VkWUoxalcrcXRyaXhkSlY0ZTZUYno2NDhVV0RJbXRFRHZKeStMTW5GRDRxUWJ6ZHZMUjlHamlHZVhvV1VyOW5Ha2pES3BUY3VLOWxnUllqbERTVnh4UVo0NXZvK3U5NGo1ZklpTlAwZld5SE0vT1RvWGs3RXFmVWgyaVozZkoveitaNlJCUGhrKzJ5Slhac1lhV0RxUHNVY2FQeUJ6WjNSOUl1UmpzSUl3UFN5S21sbkdRZ21rTlRPaTE4K0o0WTh6eXlwRUFuaXRqR0JidmZydzlaa25wTW4vNU1sNXVPZ1Z6SFRWVnNpSUxPRXJlbDE3UjZqbnpSakVCSGpFRW44RnRVNCtteXZGMnJRMHROVmhQTGNwSWtOaTVpdFNzMlhjaWl2RnhvbklTUGk5MjR0cXpXYkQyRUZ0b0F1WjBXUW1zM1JGYTd4bnZNaVZZMnFSWi9wY3hQY2JxdU0yelFjamZERzFOUDhPa0JOSEhka2pEYTNjL0s4OWJ3RW9ZcytZanhaNUdxMURxTFZiNUlhQmRLaG9Rd1I1TWh3STQzUzJvUlZEMHRUSHBLSW5zNm9XcTZJSkdUdjl4M3ZOa1JVSTdiV3JFbDF4Z2Z1ZDFxYXZvNy8vbDh3Y2lHRXl0My9tZllrMU8vK0xNc1BnTUxKR3MydDVQblhLbklrMjVab3A5anFlTllJc040RThoSkw2bCtlc0hSODdna2FzaS9uanZleGtkNWR4eWtPWWlmRXBjam1zM2gyZEI2TnpTUXE5SEVaSlk3cXdsZlZDMVpFbmNrZ2RaaGNTR1JHempGbWIwc3ltOG4wbUZyL3ovYUJJT3JUVWlLKzJVeHJtdjlxcXA1U3BHYm03K3B5TkZxR3RBcmhJTlh2Y3dTRWpZb0FGajZqRTdtM3paQ3lkVmdneThsclp3MDE3UnYrY3lkUHVOOHBNOHhsVXBVY1NtWi9SNnI1bEsvZU5ORzMyWktOMUNCQk5QNVhvK2pPcnpCVmxyWnc3NUZtTXVBM1I4WTNhY2lQWFIyRjRoMXlLSXhhdUZRWlVwM1BpSmpjTWo2L1QwZGZCMFYvQnZON0V6SFZoQnpCRGFYcXlJLzJmZ2VPSmJWUC95TmdTVzRUMEU1RmF5VXYzaVdZVnVzVDMzcDhZYXpDT1Z6MkQvY1MrR1FLZHpoRjVuenpRbjhhaTVYaVRCMVVlVWJuYWNVcTNIbnVmTnJWNkxZR0hkZXMxb042K0pCbEprRk1zdm13OHkxbjAxaVQ1SktLSzJyTDk4dWFmNFNyTXN2VTlNNEk0U0VyanhySFM3eSttMWorL2xZYk05L1ZaRzM2UlovTm5pR21UcWgxK2FOd1NMRXFhM3grbEpMWHBHUUZOWC95cWNGZUVoNkJOSGlzOVdVdEhHMXZ2Skg4T2tYM0hKaW03TG9DRmFiUEQ2SmwxUGJMTTNnVXI3MCtoeDJHRk5YcS95T3dxeHBHV1kxWGZ6LzdGQTNJK0tMcDJVYnlpc25PZHpLZHMvdW5KQ3A4bkQ4SDFCNDBKUDF1bG44Q01WYWdvWjRhYkEzRUFXeUw5WnhaS2ovS09hRXM4c3ZSN2pJejMwMVZKejdBdkhkZXVvQ01QcWNQc1FxSXZaSzZTclNNTklWOHlWblk1ZE9BMFpYbHpZM085TVZLekxQSkhWakdMTms2MmdoSnVJRWZYeExvc0pkcGRnckpYRHVjWkNOM1NFOXRIcTc1cDJaSmlQL0lxOW1reGFvVU11d2hYME9zdmpxakxsZTczcXN4cW95djZXV1g3cDJVL2hsZGp4M2FLUEJlRFpYZW1HOGt6dFJ1UERtMUhZb1c5c2owWkgvK3dtU3hueE02Ni9pTU5ERWxCWitVNklZZXljdUdhdlRETmxpR0pkUmF5UDQ3UjdzZU1pays2RjI3THZxeFJQMXF2a1VVZ2VyMUpoejEwTmw4TEZjK0xKL3FWK05IbVk0U1paVW94NzlWNGNmWXo2blE3VnFwNmNuMCswWXpROGx2eDlodlo2aXVuNWdyWk01K0xvbUVOQXZMd3VmUXBvSS9tU3FCZmVzTTI3UHFIRUxVTmdJRVJmcVlSUEQ5RE5nR1JmbndzeFV4dnhHOHhhUFI2NnY0VllBTHVXSHU1Z3hDTkE4ZE1YVlNQcldlOUczMllUcmhvckhiMHhSK3FqZytnWFNLa3ptSkhyaU1yeDBVNVZrQUN6SnBvTDEzMCtqSDBsTjY3T2lCbFpmTnduN3kyd3lMMVFjSktvMi9sZE56dkxvL2JBSEsrS1F1dzkwWnlnVkxic3RHeXQ4ZFprVk8vL04xdmQvU0VPMVpiT1U3ckNpNksrc3NWcmovSDQ3UzkxelduMk5Qa3ZuemdJRUxWVjQrYWszK2NhcWYzeW5qTFBLV3RlOVl3Y21VeWVLNCs3MWx1bXZVWm5VT1hVU1ZuRFBzVjh4dDlzZjgyUkc4NHRocms3M1NJdnE1OUN5dFhkdXFRVGQ4a204ZDJMYVZqTDhxUW1oZGdwYVRSV1QvRG9SaWNzRjJMZmYxaThMYkhSZGxMNitMa21kVEVwWHJITmh2cFVsMWtFUy9yZWN0V0ZZWi9uSnJpVGI0VXErMlBzdWt1K2t5RGZBQmVhTEU1YllXT1ZxQ3QrT3JqRXlmVTIrb2FKQ1RjL2tiRVNvZkkzS21Na0tOb1hLL1JqUFRJV2hGOVhnS09KVGhkZmYxU1NwL2NtaG4ybENjYkxkdWJZNm01M2lwbzZ6b2gwNGdxOVNQcHFadjBZS3c2M2hrU1V2N3FnbVljbVA2RE5GRzlpVzRSbWZqUy9kZmw5eXBKS1o5V1ZoTFNKaU1kV3Y2Slk3UFZ2NGhlSHREWG12MWNYNzlnS0FLU2dZeVMwYVd1TnoveWlIMTFIVWp5L1NKeUxhd2xEOG0zNHNGdmI5bUk3WTR1OFI4SXV0TFBERVgwTUhzTmpNaDRMRkZEQW8yUnRkRHZuWW9hZDYzK25xRmFjL3VjS2VGNDZwamNISytqSitpRVZXWkVBY3JTMXNMYk1zUHBSSDNybXpYbTc1OWhaYlhBaVFFUmNrOU9HbEpjNUhHUXNHcHhqajFaNUFQbzljckpPQk1VbGhab1hzazFoc2NSZHh6d0VxTEs4Wkp6N014SXlYbGxheVhqTDEzSHl2b3IyMDl6RDRUV0hUVWt1RDVkQm0vV3RoNG96UXN5eEVjTm50Z2pxcDRWTU5vY1pWSWFRcTRJTW9jdVBiNlBmSEsxb2lHb1BKYVN3UUdCMkZrOXJta0pwQjFEbWNuZUk0M0hNTEVCTHR5ZVYrMXV6Ykk3Ym41Y0hNNVJzaGhOTjR6RUdHSWVtNXdYUGQrYmJvWE1JcDM0dFBrN1VsL3FLM0psWmhrU2tuSWNEU0paYjZmeDlTTnlHcDh3dUVaWC9Yb1NUWW9HdDNQMjlIVngxZUtNeXIycllkQzhhVitmN2gxU1dJbW02RW1qR0w0K280dzJuZmQ4LzZqUlRMUDJZckF6UG8vUllNS3NkRFBLbm1GdWZEQUZPRGRUMXhPeWc4K3dwbkswbDhldUkxZUVvYlFEbWVGMHRyKzdlUWkvdi82YmY2WE5MdHVsTmFlY0Z1Rm9KeEdreWFhOWJEYzR0cXg1N1cxdWd1aUJhVU4vaGdmanZRSGpwUThXVWNjbHMzQk1ia1IyanR2enBmTTYrVUdieisyeVhMRHNyM01sNGFvQjdhWmp1eFVkaks5cjFpb3dRL0ZxaTFkMVRWT094Y29mV1JTMW5tM3Z2d0N5a2lJL1ZXVWcrYjIyUmEvWGgrVW5TMzI3dTg4RGVQZHBSMldSNEdSNmw5RCtPRFU2QzhxM25Qb0lKWU01b2daVzI5OW9YVktLMzMrVDUyeERRbElaMXZIVGFWU2NOQXErdXZMN2d2UmxEdXU1dHdUTmlJZmcyanlBZ3ZpQStZcG9ZUzh0S2pkcVhielBXMllVU2svL2tjZUJqSEhQa3Jlc1MydStsY0Q1dytscG1CNFpzN2o4UXEzNWh4R043TEhLZnQ2T2NQdEZOOW4vMGVaUVc0ZlhqMTNMeGpqWHJoZFY2aXUxZk4xcjh5VGtVMlo1L2RXV0l0U3AvWUxxcmtwZyt2STZVSXphUDNMSy84L2VtMlhKcW1QYnR0SnVxOTFiLy9MRlI3eHFuUHV4OWM1eWR6TVhZaVpqS2dFTVJvOFdlem1nRENVekF4Tk5HYSt5dGMvZzVjZ0NiaHhoVGErKzJ4dDhsbU81Z1phdzlNcXEvKzFaVXMxdFMvN0RCa3NaK0pmbGVNQk1FWEUwU05qbUNGYlZkZVlZWEhIOGU5ZFlOTTlSQk5wa1BhcXdYQnBZYXpkaVhTeGN5Zk91eDZzc2NyOVpWbmxlMmU3SDFDSkJVZTI2cGdPMDYxbzViUjdFUVhhVmhITTlvZ1ByUElUTTVBaG5kRllkaUE2SnJrTkNMc05NSTZuM21Xd0M4djBzNkc2alJtaWI1elMxdU9temM3NDRCU054bkI2blRWUDZhQWQ0NDRTTXUyZDRPTkhRWFJDL2pXY1l4cDlwUUZ0OW5wMEM5c1ZwVGVnRkRVVzAxNjdnSnBXMFJ2WFY1UmJqbkpTdmhtbzVBRHFwbkdYc0hwTjdNQ0pVSk5VUXNiL1JPYVVKejV1d1NxN1haZmZtMFVJUktjWGxOME1VQWRCNDE0ek9wVXcvSGM5K3RNYklHL3JXaTlEeWN4bzhqSmt5UkNrSzlWaVJwbWhsVXEvOE1QSjh1MmFWUTNoQi9pUkNWdEl1SnRTd20wUk9qMXJQUzlHR2tYMzdRTkNILzJnK2NoalJ3RHZDdFlmVjB3SXJKZGhQM1Y5dkM2V1lMcncwMUtxejJmc2haL2J4aVhXZmFiUkpkUmJubUVDVUh6RzRPU2VrcXg5bm8wRjI4aEErY09CWDJGczE5WStPMnEvbFJlcUcxeHJWUGxsTTlGbjZTaEI5dEFUVVgvRGVHSkxlRXp2cVJxaW9EMEEybHZjYjV0Z2xqTFhncWY3Z2FkS2hhUU1qc2pPUWZKVGhNbi8rNWFpUTAyQzRiaGxvWENOeWZZVGVzai9TVk9PY0prL2pTc0pqaGFDemdzS0VYSXFaaXpINm9BbXB1emI4WnZxb2tsZGorYUN2NStDcHN5NHJJOS95bWtZQnIyM2V6RmY2UHVqNHJsQnJQYzhQWjZ2QWtYeTlQekpDWHNQS1FuNUN5QVVZRVlhenpBaE55TlRITnc0N3I3RHN2RWR6aEpEajZCYU5QeGN5RnpUNUFNYWY3M05LZHhQdGZDdGM4NUNCK1A1aGFnbjJuTll4QzM3cFRUNllVdjE3b2hPRFRsZnR1bGYySWRPOEFKWDJSdFNVRHRDTXJodjdvZ1FCWFJob1d2SkxaSEVOOUswbnQ5Q2lQMmVZMFIrbGVpRi83M3g5TG0vLzNUM0RLM2FUU3FSM3k2VHpFVzFvS1pEaTVFM0c5YUpVODFQUDVpczBQOWNMV25hcU11NnY2N0hZL0hPOVZHbExrOVo3RVJ5YlE5dXorenEyOVh0OXE4M3ZrVG5WbXo0d24wY05pNmpzcENHRG80azN3VDdjWlMzN1lxVGltNkxkUE9TbTVNN3JKMDRVeVlUVEpWK0d5dEtsZUt1L1NocjVjV3BYSXlTMEcrWUNKZ0xhbXBIT2EzbG4rQ0lsK2EvWHRlbVhnTVRPUmlyM1RQWXpPQ3lZVmhNVlVEME5SSDltWFVMSHhmQ3hYanBBOTBseWt4UHpUV3hhcHl6S1RLWGgrZFpsZTl3bWFOT3BCYlhuSXNHeFZ4M2ErYUswS2ZsbHRoUW5XWEVjb2pOREVhVWpUNU91ZVBucUxNVSs5Z3ZZTnNWYldUMHI3YlhQMlVmWlV6UDBGc3JFVU1UMHV1djZ0ZlFyREkzT2VYd25ySzVHcDB3N05QK21ieG14S2FmSWViWHJMazRqTng4NEs3L25hdGtsSHRkbEZybk1WSmN0dFNuSitkOXBlazJJK2xncU54blhJbUhZdGt4a1FyenE4UHJFcTVPUVdVUjFXbVNlUjl1UW1ySnp3a0NDd29SY2poR0RjclZoWEMyZXQ2RlFYNnZiMEo1V0ltQ2xDVkFWd1dkdjh3N3QrSU5hWjJoNkxSOUNjWTZqYlZsaFJHaGVabnNadlAvMnk2Z2JlZHpFSjFJN3g3QVdJa1RWMFV4R1ZlR0xFUW5SbXo4WjdaQldlQ1RNNDhVNXRIeFdtdHNSakZlcDE3ME9pOXBiWkMyOVFxUEg3N1h5cllMemJNT3NSM1ZTdnFnVjBaYUZwanRMdjk2SzN2VkxUbVZud2k1Y0RHalJWT2tQSi9KWWZOSWtpVHh5alY3blBGYkl6cmttNUhKbi91eW55d1RYL3dFZFJ3QmVVMG1hV3JSK0w4dGJJZ2pyR05HTlBYV1JpNk90WXlsZFNwVC92YlF5ODZKdzNYYUFqaXM3OTRKNGd6ZlBmdmJlcVhxRWFJM2U2S2hod2pWM09KNFpRUlBpZ1lSZlpBTXlITHkyanpUaDJoOGVaYUhXdzBVYkZ5NzVZS1QxZStnYUtta3NkdWI1NWxlRk50aHllbDNRZVVOemduSllvWkREbjlhY1VQbnVIZzdveXpNTjhZYzRBVDFyaTZKeUVEcVlaQkZTWEdQMWM3TFM4YXh1K0VXU3A2NmhpYTlLRURLTjJUSHZrWGtlK2UwVytteVprTXZ5Q2NFVkpLSVZEY0I3WldVZ1BRM3hMVnEvRFFReWhnMVNvZTRKcjRrZWtXY1dzOVVyeWtnY09ycWFqMUREUno0ZkkrUlc5S2pubFhBaGIwQmpMc2p2aTQvdVZnNGxlVHE5YTZEZDUxYjlvaW9ocXdqTXRhdVpFYVRCQ3RjOFlORCsvUDdaUm9kVDJtN0Rtdnl0a2VyckRDNlR2NkRiY2JWenl6c0dLVUFWWGxQUThvZnd0aGREMWxadk5NbnE0eUwrT1QxdzFUbTg1QWpxRjJKYldhK2xiZUVBNDNpQ3FaT3piSnVWUVc2TXlKMXIrNHQ1eG85VXB5QThUYzgzV3NmSW92SzBZV1Foby9Xajk5ZGN6OGlQanFwSVFFRzBQbXBZNUorcnYrTzUvd3BSRnZNSWpUU3hXdkpiWi9tWlF0bko3ZlgxR1lJYUxCTmFLd3JVTTNPUnBya3kxVWFra0ZTbE5Qd2Mzb2NUbVFBbkdoNWVUTW5UUm0zZVl0YWxDMG5FOG5HN05IY1VTa2dBS2J5QlBMeHQ4ODV1eit4eVhUeXpFbGw3WjhpOGlOdDBvbHcrQjhrR2wvd25iU2FYNXVqWEQ2bXZGekZQM3AzNXRxdmtWWlkzL3M2K1BFM1hXRjl2clV1WHl2VHpKYWU4V21va3hXWnQ2czVsbjdZK2tiT2NiNU5VOEZPTGNOMzlTbzBtOFhLVHJGUkpzNzJtc3RMV0FnYVhsSzdkbGlrVU1lSUVsRURkV3AxZy9lMmpyZlo4MHFaSDJrNEphMGZ0N0NnbXp4WTBHWFh6eitCcWJWeGRyM1YvWHQyejJuYkZlVEFEOEw3a1dKcm5UOWxsRktBTjAwMGNSVTRWUWZhOVE2Q2Vla1hOamd5MFM3TlZvMlVpRHErVTNqc25uZmNHT2pucFgrY0tVSWZWaDRSWVNMYWRaT3VoaGdUaWt5bW1xRmx1RDF1blpGOFhJVXVacnFrRFpYZEhaRHNwUC81ZlZlN09OOTFuUVlyZGxQVjE3dVdybHUzNTBEM2x6alE5ZlQ3UzExRW5GR2xEMUpCQWpSdjB2RVFWajdCMGhYZStnK2dxSFZsQm5ycTE4czJxc3o2ZmhIS2pYYTZaQ0QxdHFxOWJkWGhsa3hTejBhVHI1QnFzTkNOZTVhZkZkVVNSYlBjUFpvWDhSdkpwUksySTNyQUhVa1lienFINENXSU5GanR6Q1ZGN3hCSm4yaytoeElKZWhmeWszejE2VEdNZUNxZkxUZkFtcURYZ0VhR2VjRjF4UlRQajQwQTdFWGtHZ3ZyYU4rT1BmUG9tbGlhNUpwSm1qaDUzVlBuUm5MQWtQVVBJTXJDaXcwVkZlR0dzOVlvcVlRN3dSelBpRkowLzlLOEpUSnRtbkRQNnNhbHo5K1BUbFRXWGxDOHdieWFiUTA1Tko5OXZ1MXdqVVYvcW1ia3NGcDF0MGJQc1NmS3BOSmJHSVliSFBVSytwZm9yQzZ2cSs3KzBnY2gxT2R0U1B6MEdyUG5hUGJiUWtVUVVONVg1S1VocksrcFhjT2hPNEdtaGk3TVZRS0J1UkJ5am9kTEhyUzJHNU5iejhENWU4VndmWGFjclRiWFNlVzEyWGFkeGdURDBHK1JYQllUME12dGRDV1JCUzQ0Q01wL3BJSkNQWXVXRTdWMklSN1lwMm9hZ0VPQW5neWJROHdiV1FWWDM2SWdPamxRclVYVWFUZGREejd2clhubGNtWVJNWXJVcVA5TGhSN0NlVVgwb0k5MDRPZ1M5Y3B3UUloTlprenR4VnB4akphTzYwU2todlhpNkZaaGowV2VVWklDWkR1UHBMeVNkZy9ERDFPcm51bDdIYVQvRFJuK3NSTzZOdGFnV3p4R2s2cGtnTDljUEZWelNkbjBoTC94bDU3cVNyaDBhU3k5Nm16bGtwMmtVRVI4Q09zRnAyY3hIMDZ2ZytpNU9rWis3QmkyRHc1TDZWanJVUkVlTUhYUnZwR0tVWVoyM3l2VHlqNGJoRUFrZW5WM1dCQzViTDEvN2JFbEIzOXJZdHQ4YXpRTGVROW5sak02aHRnMUZTTnQ3N0oxSDBod29MVEpZZFcrVGFJRGdlTWFmMDRmYTE0bGErMUpiT1J3aXN1TTk5M0p6cktSVko5SDgyZFdqQWJSalZFeVY1cS9mRFJYaVR4QTFNN09nUGljWExBR1JMS0RzcEVYUFIxUjgzMHBaWkVaSXlxOXV6TXhHSGFWb1I5eWsyekYzSmhjbFQ5a0VEYmNsL2Vhek5kRCtDNnIrUU9WMzNja3NXOG9wcDNNbXRLZHdTNVVvTjR1b1ZXN3RrK1QydkdiTWF1ZkVzcjBGL003NG14NDNBT1JqNzZ1dGFDZ2lZdDJnZ3J4bnFyVHBuQ25TRHB1NXIxV3hxMjkzelg3ZlpxUU9vMjBSVk5IWlVaWlkrTXp5SktMbGdqSFBYZnBWN2JmcWlvYnRydExIVVk3czR4U3ZDNVcyV2hYWlN3RFc3VVZLdlRSdzNZWU1sR1NNV25la1VWRkhkc2E2allZcHRUWkVKb2lXeHdwZ1JlaHBFN2tYVjRscHQ0SFoxM0drTFlUY2tqT01Ib1RnZzdLbzB2ZHV1ell3dExleWkzTTloR1VFU09uUThlb3hmbERCYlJrUjFuWEp3TkFNajZEenVUdWYvTHE5T09XRlFFTVJNK3ZxaStidGlicVJhRjJ6ek9mMk9sVy93YWh0aDU0bjZ6bmltVVpFSlhobFJOT3JPcjVKZTNIWlA0Tlp5M2Ftdm9sYUVTTmhENkxRNndiVStUZ2doeEVWaFc1QlJUdzBYUnZOYnZLdWMzcmNERTFBU3hNQ2NYT0xjdDdKVnZNdmtCM1ZoYWdaOFpoNTNhc3I2cndQb2ZwaHFoVG82TFEwYjJ5Z2tnRHRWRHFoNnR0TlEybVpubERsYUZEdDRPbEFvbGlMeDVwN0hOaVBJeUpLT0x3dGdKYnhYdHBaV2ZjeVRxajc3MFBQazdlZzhyK2VPcTZZSDd2R0pFL1Y2NHplenFJZ093eHQyYlkydW1TemM1aklGOW9QUjZDODFrVkpYcThKbVdXeERqdlZQajJtZjE1NlN2K1IwTDVrOUppUXA3REsvQWd1Wjd1TVhvNVV0S1h6R2xuR2loQmlucXd6Ylg2c1JjMlF2QlFqL2RKYXhXZjZ3TGVOckgreDhzN01kN2s3SzZYb0pDVE9haWttbFgzMlk1TXo2MzRFOTFhTjVDaU9qbWxIZk5Cb0hkNWJtTmFhc2M2bnhIVkdUdVNLV3ROYUVKUGE2K28zNi8xQldocVhKUkwwOTR4YlQrWWZ3Sm5QTUhycUdyWE5xUklKT1pnam5tbk1FR1N6ZkZMcmtmWE4vZDVSbCt5b3JxSDgvMUE0Y0ljdzlkVmJRcTVFaHg3bU5ENFFkamJNOXc5VHY3WlNyVTlid2FYay84UmZPMGVlaC9lU2tMZTl5MkRWRWlWNEhXbks5T25lTmtKcXJCZnpqVWExak9McmN6MzNpb2dNS1QzRnlBa1lvdjlOVm80NVlCaDFQNkdHSlBqN0NVdSthZXZYRzc3UjYydUlldk1SSVJrSktSWHNrclpsL1k2SXRLemJXUkl1V2R2ODZNald4MUlmb1cyVjZzNU9FNHJSZjgzTVZqOURnczNVMkF2V21ySXU0SEVTai9kZks1cUJWamZTTHdldDdwZmVzUVJWU2xoem9vWUgwVkdtek82MHNQUUthR05HaDVmY2pLekVHanoxTkZacG1vRmxYV0EvU3AxRHE3dStmNXlLNVB0bWx4WTFoUkR6ZzVBS0x3Wmo1ZkdtR2lveUVFdDJtVjZ5Zkd5cDhsbDhncUx0RFRaOUxKNWZzTDMrOGd0UWowWTcreXJOem0zN0luTitrTnJjNTNzekNzdFhLZHRUN3lRL3Z2YXU2OHJ2OVRiOXBpbEZQaFozV01uSjlPdmJyNVcyYmZtdFpKdHVkeTAzU1JFcEtaV1RCQ1BkOGIwMzJiTlpOQ3lnVTBmNlZpYTBZUTlsR0wwd1psM2tWMDlMRjZxNlJWT240SFhzemp2M1hrKzcwaloyRmF0bHJ6WHVtdXlQdG1uMVBmd0ZuYi9pV2dMenJtQ1dmcjJnanJiQ3JtMlVUZ09OVW1yYStpMUhtcnFYTHl0TkhWV2lmeU56VUxtRitIOXU0NXkwczgySW9weVgwbXR0a2ZTYVZwYm4wSnhoNnhQeWw1RzVKZGxkS2FWdW02OHR1MlVqUklYemhCeks2QVFmbWJoSTNkSEZuWk5kdExiQTA5WkIyanprZVNXdGZlL3lhd1RWMSszS0FidytSUlV1bWw5elV1cjBxQ0dSbERxU2Npd3hlbjlldVJLVnMxM1BnZmZsMHNRSHZEYSs0bGQ1azNvbVBUTU1YYTJvU2t6TmVhOU1LVDBhdjBCZFVNdmxSc3ZvQmJtdjI0Sk94T0ljYTVPTi9zTzE4WVNHZG41RVZiN3lyZlE5T2UrR0dPbStYaXNDMGZSSTJrZWpyVnN0bmZaY2daekNxR2UyS1NqWlE0ayswaGdWOWVURFFWdzc3Ym1uSTBzOFAySW1KWGlla0JmL0pFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnRHlmLzc3LzVvZk1NdGJPZno1djFsT1VpZmpUNkVKUXMrT1FST3E4Tko2VFVuSzlTV2dHL1lWNHppS1U1ZjVVWUMwYmtOVmNtRTR3SFBSMXJtWEJpeHlWRVNNN0FhNURtU0xHU205UkZSeWFWdGdGYi9xM1pmcVovU2lOOEt6Rm1wVU1VbHB3YmJzZHRwOW5ZL3NRVnJFSXR0VWJmcmZXWkROL1BFOVdmVTZzQzhoUlZjeU91NFhGT1RJMG9vMm0vcHFuR0llZGhVemJRYzdjbTh1Slo3MnVzN2JPTk9qVnp3VmN6Vmg5dEc3N21MWVFEdmJSVzdOdnRSUDVtNzNjeDI4bmtXc1NZM1JXSVJsYmxocGxsQUNqUmdSUWptWXZvZGJLL3VnWDJpVThlc1BZTDdNdm94UzFXejdacG92a3ByenYzVkg5dDFlaVNXUGhmdjFmTWVzcFd1MlJpN3g4WVQ3cFAzU3Fvb2hGS0p1Mzd2SW9sd0kwQk02bVYxWGMzN21iUFErbEx2UDhOT0dxWTM0K2ZlMmNuUVJNL3B0OXZ3OVVsUWVQVjlPMHZVUmkzMUcvS0t1U3p6ZnlBelhRMnRrUm5hT0UxTG55M1diYVVCYmNUbnRmTTBST3NJak1rSFErWXlxenducWxoQVJ6emJTNkpuZmp2MFZYbU9FM0o0WkQ2OWNTeUtaVWJTZEllRmN6OHJpYkEyTkpkUnRQTW13TkZsaGFVcmphNHpuQ3FIZnh2eTlycitRL0w1Z0tFSmR4UzA5S3RGVHR6MzNtNE4xUk5NOW11Z0VaV2RlazE1MU5Dc2VOUktPUnVlWXA0Wm93OE40OGxuRDB2eWpiZUZ3RG9DYVhlelVTeFAyeUpveHROeWdhT2lRS3Y5aFJDYmZwRWt4VWd6cWliWndYbmRRZDlhTmRRaS9tRW9JSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRaUNxTDZacVA3LzlQdi9uLy83VHR3VVVJUy9PMmttb0tjTGF2Q1JhWmU4R1NkMnM2RU5sVi9ub2ovQzU3Ry9LeUk3WHhBYmRkVHdsV0ZCRk5qYVB5c0pyRGZPTVBWZThyYTIwdXBSTy8wb2lsQ0Z0YVorYlB3cXFvVDRWVUJGRmR1VWRyQnZmb3pqL3BKL3hXUUQ1dnF3dnBmNnRQMWIzQ2c2MmRsWldSVjlsUG9JbktWeit3dHNadUU3SElYb2dVYWNNTVhZV1U4dm5yTXA0djVRNi82elFTaEgrU3Q3bmVGN1hENVdWNlBhOWlMNGxuODdJcHBIUjZYcUtuaG41NGtBMG9PV1ZnN0JTRmp4VzJmY0YwdmZEYlBrb3Y2a3NQVlYyK3FkQWRiVDZhbXdndllESDYzSlJMNG5ab2FLVnNTaEdXM0pLb1MvRmFQNXRXd2Y4eGRSZEJYb1pVVHZxUTBNUjN1MTZYeG9VelVraGVHYUZJdFF1ZHVvK25WNDVmS2lkNkVELy9qZ3VQTzdOY2cyWlc5N3RlSEYyTGIzVWx0RXVsR1JLK0l2T1JsbmJCRC8vYWpjODQ1bEdVcTVIOE9vZXFRTXRtNUJWalBwTGx0Q1o4MGpERCtkd0RaRkxNc09vbWJWQVh5QkI4VjdMb3kwU2RSamJNalEvdUdlaGU4TGxkUzFpWUZqbFNPbFJRYlhDWWZLRXFwVzJqZW5ieWZibmhUckU5eHFhSm9pM1VzVDhkTkYrUVh3VGI1V3ZxcnRPaDRDczJzY1JWUVdvYUVUVGsyT1pwUnEwTWlMQ005b1d6cVhwbk5tbEVkZXJ6ck5LM3p3YXhLUmpaMDhuYWwrOXozdlBpU2FPVlRTMFFqNFVOUGF0RVlpdjk1b1IyVG1tR1JHZ3g5Rjl1QUxtRjFNSklZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdoRS9zLy85L2VMcWY3V3FuLytieDdidFlVOGh4V2J5MDBndW1sOGN0SzFlYWJjVm1SYm05U2tiZE1QTmdyZFo1SEwvK1p3Z09lQjdvSXhzYzluN3VXSmJwQjhiV1pzUlZJQ1JRWS90UUdqN1pnN1V3RkhGVkZrKzIwSGM0dXJOWDI0TjNIenova2k1TlMrWW1yWDRhVXJhY1o5OVhLaVVSL1orQmtGTmZhbzQyRGVIM3g2blhCMmxYUExxLzZlWmtlVGUvS0I2OWdTYThYOXBJUjhOYW5sdlBRUzByRHZWRG0vOUU1VFYxT0kvb0UzeERQOHBDM2ZQQ3VYek1JS2Q2QmhqZDVkSVpPVFQ2dHJxWWhCRzRIa3RVV0tuaThwYmJEUzBzNmFRTisyK3JwdjBsS01veFdBOStPcVFPV0MrTVhVYXBLclh6RXR4anh0eXM1TjNRV1l5SzV2NnV5TjdBbTB0cWhJWGU3MjZRTzZEeFdXa2Z2cnBSMjIxK2xCWDBXc1NobnVhQlZESW5LRmZEM1RHWHRxM1ovRWpKMmdlNjREZFk1VU1RcGl3cjNQZTZxaWcyaVpta3hVUDloOTVOcVlJZGM4bDdRWTZldnJFZnU1UTMwU01vVVJYd3dWanJGSEdyRXlvd3lZck9TdWpCb2FSNEk2UkRNV0xsam1UdmtYNWJ4UTFOZDF6ZmUydVBKQ2ppaC9MWS9xZER2NXZlaW5aTlI0T0gwOUpJdVZ1ZUtVT2RPRmRjTWN6Zm1rWEorQlYzZDA5Q0loRmEwZkVMU1pGZTFUSW9Db3A1cFJINFhjSDgzUGplWWZ5VXRNZXBhdEY3NW96MnY1STlaSHIxWHhXRVlNQ1hidVlhenkrdFRIaGszZEx5d0wzc3BIUHBEUlp4cWUyeitCbVhOc05CSkJBRzdlV2Z4aUtpRjNodEtla00rRDYvYm1uRG5BWjlUTkNVMElJWVFRUXZxaE5VbnVDV2YyZXRqSGgvR1FyczZjVW9UTTRXbHJpYkxqT05qWGhCQkNDQ0dFRUVJSStWQVkxaURrYytINnZUa1BHMkRPWnpKQy9zOS8vMSt6cC9UWDZWM0N6UmRUZTdiZ0lNOWp4dTdwZzNNTDJmVUYzUUhzbE9uZHM4YWlXeFlvWlh0OTE3TjdEL2tnSnN3aDRoQlpaTUVpMFIwWlM2QXNwSTUxOUc0TEdOckRYc2tEM3FtMkxmNzdlck9UYkxFeXJ4VDZkYjY2anA0UlJXZVZ0d2RuYzE3ZHd0OHpKUEJ4bmJNN2EvdmxWTzArdDdXV0t2LzNjZG1WdTgwVm1jY2ZoQ2RrZXFBK0dnTllRcHEwYW91STd0U1loSFF6cHdiNUFEeFYzek9KZGlkNncyZmJ4dWxTZWFRdVdSZDQ4MzVFUTZqcjh5TVcyNHh4SlVlQld2S2VwV2VWMmJOV3BEcW1UditlR3ovU3hMdUJPWGxmeHZ3RTdjdXFVdDdXSjlGOGxEbk1mS0JRVFdCUkpTaEc3SzRKelFKdHQwTGUrZkhHc2RTMnpXbWhUT3Y4dTZ4MzQrSjF2Yk1XNVh6cTU4eFFSRnRXMnBiUkRxODFySFZSV2xpbkJJWnpON1dFYVRyTVNKOTljdDA5VU5jOWhoRy9xQzNqdFg3ZjAxMVo1ejExSElHcG5wSitYL0RPN1Y0b2RGV0g5TmFsNlozVW5KZnlwT1RmcndYcUQ1RG40YzNmTTllU3QwYWNSenRxUGlrTklSK042a0UweDZ0ODY1NG9tcEl1ckJzYnZ6aFMxNm4wT0RQbzgyM3ZPdnJtUmdxa0E0MGIweEZ1RGNmR1lJVHhqWjVacXExbkZMVTJSTnVFcnJCSVhkcjVmNXF5aTNJK0tXVktiWnQxdndSZ2NObnV5b240SUdROUt3V2FOTDR6QWg1MVBxUk84aVlpKzYzMHIydUkvUGFHVmhNaEhONkZvUEVmSkMzcEJ2R0N0R2M4WDllYXhaS2JUTHRuT3gxdDByd0hRcjVBbEVxT0ZkSHFnQkYveWNNTHM1T0toM2NPdjVoS3lCMmgxQ2ZrOCtFNlhnZzc5M2llMHVlY1c0UVFRZ2doaEJEeWJJNzBDMC8wUWVuK2tpdkQrVW1lekpuem4ydVBFRUlJSVlRUVFnZ2hoQkR5UUJnYUpZUThuZnlmLy80UHNFZDAzbjR4VlVwZXMrTG4xdVJ6OGJhcXFOTU0vbVFmcVVwTGUrbzBqdTZNdGJJSjRCaHdtZDhVYlFlT0dUdm1FcG1KL1RSanN6UnQrQ2FKNmNsNGU3QkU5aUZDQlRIU0ErME9vdzdhOWt6Sk85YmErRW96c2crbXhnRXpBSmxzbTYvT1J1NXpXMmpmWFhqN2NObWwvdDVlVnE0WG9XVDV5MGNmelFWc0g1RlpTK1VUaU96QTJVenZhQmNoNW9WMFhVdERia1QzQUNzN3M0ZktRKzJJREpYU3BoemJyTmJ6VnBQVHBsTGx6RC9uWHNkTjJtaFZoeXpLaUExSFBvVWVpM1cxVGpoVnh5QW1xNWRYTXovUlFKaFZOeFZ3QjMyRzVJeVF5c3Rmc0VMM2x4dlMzWTJEZm02WmVDZmFGMFRmZzFEa1BPcDVzN0RmZFBWbHlERUNkYUhhN3V5a04vSzM5M1dobUNEU2M3UFJQa2JyMVcxK0dKZk00ZFAxMStxdHJHOGFVdnFMOVFnakVyMXIxL2UvWlpzZWJZc1d4dnhLVytUejc3S0szY1kyN3d5WmNodjVkSVorNm5WVnNWQURJYi9NbUwrV1VJdzVIaktvd3krbDUxb2dsNlBQSy8rbE9OZWxOTm5KNjVWcFBNeHA2OWI4UnNRb2FBMlFqTFJ0QmhHaHNXcjhaaHRMMW4wZ1Zxd2prTnZZQXhweU9FZytlekZoS1gzTmthR0lNOHpJZHRpeWN4MWRoUkYveVdzVHFkQnNIalNHejg0OW41VkN4S3ZEazg4Uk94c1ZqcEU2T1M5Rnp1eVdpRTZJV3Fqa0I4L3dRUEtRNlhpMlRaMXVOSHl5K1dQQWdPSzBlQWllVFRjajdnWW1SOHhLMUJkRHB6dE4yUjhpOXVUTk80dGZUQ1dFRUVJSWVRUlBjUUhvMmhNeUJTNGxRb2JnRWlLRUVFSWVCcFUvSVlRUVFnZ2hoQkJ5UStqd2svdkJXVTBJSVlRUVFnalJvTDlBZXZpelBjekszODBwWlBzbFFrYTJPT3RrUmpHSFRtZXZzc2pPRzFHYXNyVXZwWHJERnRrVmdYd1lKWGdldlU1MDBPMnFpcDI5WjkxYTFVYXVId1BhaXNodW8raCtMa2pkNVNlYnNIT3N0Tk5zaWZaNjlQNUxpbStQaHdpQTNoMWttMTEzczdOYnIvcFpnVmM2Zlp6M2R5Y2JzYjlma3dQSEYwTHVTNjh1NlhycHJ2UEN4cnUzRTZOMFBscDJUOTRuNlRCa0RINlc4ZWlYTXl4cDFLWko2Vm5EOENpMGRWNGZvK3EzM3ZHN29KVklCVm5JK3FVSWRXU3dCY1ZaQVVYTjZiV2h6cGszK1gwcll0dnB1elpIVlB5dUJtOWdrM0xkdnY4K3ZEYVExVWpMR3AwWldsbW9KZXRKaHJhTUtYckl1em5MWHRGdURNbXJuYzlBdmpZOW1wYjgwTmRaKzY2Tyt4R2w4V3ZhYTZVcHc4dFhBbldIVWRkR3NkUFhCMjZjdVNsYy9VU2Q1emNKWTFHOGRpbzNHUDFjWG5zTk1jaGZ2ckgyWlpTMmpTVXJ4M1c5cWFrallVUUZkUWRlbDZvaGhPYTRSYmV5NURSV0hlLzBueUpMWnluQkkzWElYZlRWeXZiZlVKZDc3cUoyempyL0ZvV0JPcEEwWCtkTDhIenkwZktxWDFMVm52KzE0ZGRrTkNZSHp6dDFUNlVNWHEveFFnbW9XMnVWNFYybjIwcHFvb1pIcEF5MFRLOHVMMSswSFlTY1N1OUVMWjNYZXZPaVZrdVR6blJPbXNXY0JZV1UyNmM5MFlDVDBDYjFlbXJLajVRZFlaWWg0VDdVcU03WGZlRGRiMG51dUxaMTdPSUJncUVCMjNaRno5ZEpjWTY5OUJyV1RPeDFkOUdWTnFOdUwwcWxwZGVPMnpaWTUwdnpyNWRQNDFFbTdXdGd2WUhRQmhZZFlQb0c2em5DUnUxWlhKNEpFRTJId0hrSHNhS2JvcUVWUks0Zk1iVnZBYXJrMit0V1ozTU5UY2NLUnhRZ25aUnYrNGQ4dldRdEl5RS9hTFplaE9DODhuU0F4VW96NHRFZ2p1QkQ1QWUvbUVvSUlZUmNFVG95TitXTWdUMXpNbkVpRS9MeGNCa1RRZ2doaEh3d05PWUlJWVNRUjhGUU1DR0VFRUxDOUNweHZxNjZIaHBZaEJCQ3lKT2c1aWVFRUVMSXA1TC84OS8vRVNKRit6MDQvdnlmZi9TdE54aHJJaGFSYlZ3aTI0cE53aXZhMjlrTUxTY0VVcGoxYTNxa3o1V2twOXd2dVM2QlRUTkprSGI5bmlqbklubXVPZXc5VzRzTTdxMXA2YTkyYS9yZGNWS3FIekcwRmsraVRUMXBzSzZtalBmdEt2Y3Y3ZDY3Mi81ZnUvLzhVMkw1T2RvZTl4SFZodGk0eGxva0dRR1JFaTZ3a3R2dWFNL1g5Qm9nSjlxWEh3RytoSFo1WnVtSXlDem1zSDBZbXcyL0c1MG9wV3Y1Z05oRGdSYU5ubnViWGhPS1NOMzUvZC85bXRxbmF6K0pJMjZhM3RTMks2UHJQSGs2STh0NXRxVzcxTHFPM0dpdldhblZxYVZEbCt0c0dYdVVpL0xoZUJvQjY4TGZ6dDRPNjI4cGdWRGhYR0FWQndRdWN6V3BJb1pqbG5YZ2J4MUFEMnkrWHJyN3cyOUVOdnhidDR5cW5OMTF3YzV5SjFHVFFJeHJXUG1hdkVldGM2ZXUwUmcvNUI0cHcraTV0MVBXMm9vRmU0YWNmcnB1b0c2Y1NvOHA0eTJsM1hvVzFuM1VoT3R0U3pUZEprOEdWYzVkWW1jemcwcVNVckRRK2c0bFVoZDVCdG9jbkNGdzBITFFjSlZsN0dRanZWVW1JY09zZkY0MnErd1pkYUxDb2tPSWZCa1NRaEZmeFFnK0tBemlJWjBoSEJCRFlrUjRlaDZqVlJjcWdMMG1HZTFIeDFHNXJUWVVjUVJIbXFvcjFUQTZ1ck5OMllqWlRIVTlRTlJIWVdkL0prc2QrNFNwaWloSUxKanpjUU5xWmJYSC95ajVldXBFckFpdERDM2ZZNGQ1ZEEzVjVhVEVUajJZVVk5TWUzejRRbnFNbUpQdUJsbkRqM29GNUNaNGducGc0S05taEtWL1pwc1JuTjhBbHAxMVF4M0NMNllTY2tjbzNRa2hoSkNIUWVWUENDR0VrUHRDUzRjUVFpUXVJQjJQYkFLVkFTR0U0RHhOWmxKSEVFSUlJV1FaTkRUSWZlQnNQaEIyTmlHRVhCUEtaMElJSVdRSmYvd3RUNHpmUngrNTVSWDVEUDdPQ1c4S1JiYmttakRIdENKUSs3SjBYdXNpVW1CeGpyMzBRV2lQUDVERmM0cFVUT3JMSTNZZVdUUHNrdkxRMHFWazd3UGpsUlc5QXpCOXJldDJuODVRUHFVeHEyNnhFYXVZVWI1bVY3NjJuV3FPb1NMUWRzMXFmNzFINlZpWmZibWpSb0NYLzBLZ3V3UWhMTFF2UHdwTk9XemtscFBYU1laZUQxUVZ2azR1eUZ0VTVtK1pIdGxCUFRUZ25yTlpwME5zQkwrZFkxOUw3V0hidHI5ZndDdlYvZWd1TmhEUGNadmRDb3RXQi9iWWNOcDVmQXprT3VpMWZoSVJLK29NSFhCSW5WR3pja2FISFdrZlVYa1BFZXUrMG5WMTZoQlpZaGdTejQ3aG1adVQxbzd4YmxVZGQ3NnpaYXd5c3B3L1JFUy8vcVJYM2NRTy9WcTBOcTNYdDIwTjcrT2dieUtWaTE1VDEwelpYdmNzbS9iOEVIZVIwMC9YRGRTTlUwSENHaTFoblZnQ2FZUE1NTzNVUENzTHZ4cFJsUmxKT3pNdU9jUHRKYzhBTlV5aVpjNTdwT0czVVRUbXdESzVOc2d3TXoyRmtiUlcraGwxYWdwckFxVlp1QnNaMGhIcmh6bERBQ0RDY1paaDFXWFZKZHNnY1lTbmF4Um1YRTRyM04zRm1hV0d0Zk96VFZrcjcrcTZTTU9xT0E1dHBXdHhodTg5MjVidmVlejdNSHFIdVhlbzlPZitNU3dyNHRIRGZJU3kwOVlTMTlndzA4TVpQeWVzTDZkKy9WbTVDNFhqU0NRV3lwYVZ6ME9qMEYvb3dGTEFNK0swRitQUDkwMW01OFl5QlNueHFaOEFTNHZuQkpEMW1wVzAydm5YdGJ2SWdxRjN4b1MwVkR3M1lkYkRkeExEZTNOTmUzbGh3Ymg0VlhsTmpUUGl0Yld0c3p6ODNqS2JZNm40MThPNHVnajFaVTZwN0JsRVg1UWRHYmxKMm5EWGxPTW1ldjRwdS8yQmtWOGo4aWFITjY3YldyUzJQQkp2K2VZazZ5bDJYUnl0TDE4b2ZacWJQai9qbVF1NU9EdC9NR1BwWHNBcVVuckVZd21SRVh2alZZSzFhTFpuY1UyR3R1bTMvUm5PZ3publdyRDlOMC9WaDVzSS9CV1lONzVrSFZrNU4wTTNqSmdDczlxd0tUQlNhV3RXV2h5cFNGZmFWOU03L2VyWU41eDNmOW0raWUwMzdPdmFhaTNOLzhsTkh2bjYzaVJ2ak1HTkdQNzVJM3VEN1V5MmJKek1VcXVxYzYxeUc1M1g3NWR2YTcrL2pRUGtwbzVncGJ2OHlWOHpVaDR4M2FzcGVYc2NBclRwaXRjRytYSTdsYXlwdFVLT0lPSnBWclh0MUNHRUFBanIzeFdSK3l4UUZaRnlvcVlOMnFhM2VBY0toMlZLendQUk9vM1dBVFhGdWE2bGk3U2xUWXVpdFZXcUV3MnpFM0kwdmJiUWpFY2FYbHUwTlZhU1hUYlhHRG1FaFk1RU43MUtUMU5ZOVduTlQ5VDhaQ0hPL280QnAwYUdkRG1UQ1kxVDc5TVlmdjl3Rzd5NmtBZG9uakFjUlJLaWJmeGplNGlSN1NvQzJhUE1NclBRVU1RcjdZeTZaa3NRYTNSbll3M3pGU1hrYmZCRUJEcmdxRjFGMWhBVlhGZGFWSmF3UEVvQVhRUWtodFFUaW9oWUFsRnJZNVEyenI2aWpvL0hXNi9SRHZQa05lVTR6TXg0TEZ4bkU0L2Q3TW1qUHJSU3luS095VU00Y09CWFZPVjV3VnE2ajBkVDd0RUhRWWdDdmxubi9jR1NsZDhYRmdqUmVDMmkxaG16amhlQ3J2L1NrZjhKd1ppZUIvVU1VdDJFNGh3VGpPaXpCeVJkNTlqTWNNYTBxdWVKZEV1YVJEcHhsZUp4M3ByTVB3ZFNFMGJyZ1BOR0pQS01oVDFZaGpxSlpncWhZaHlscFAwSUZLc1JmWnNpSzFjcFhIZjBMbDkyNVJpYTZEUm9QM0NNd0dFaUp0NExiRjJGMVFVT0tlaE51WG56MTU2czV0eitKUjk3N2RPdkYrMytpbDFIK2JtZWZ5THFwVmloeEo4Nml0NktQa1lseEl6eEpVZXhRaDk0dmtwNzNENDM2cXBzOUIwOHJ4Rm5UK2VWaXZ0eFJzRlloQkwxWWJUVWVGN0xQeXJDT1kreCsvYnpOQzlRdnY3WTJMUUxKbHRiWnVtSkxGdmxKNzlPOTNwUWdCUkxzRWwyVlhONVlpaWkxZWlpaGw4b1E1Q2lrUmdiVWc1L2xFcElCeDNyWm5aTXZLWEhaSU0xWktEeDA3K1FXc0J6eVBYb0lFVFM5NWFOeEI2T2RtL3B6aEtVMGNjbC9ZODBjRGxndldnVnRSOEptY1luVHpadDBSZ0xHalVPMUhRWnJxb3FMSklZcERqSG8rV2hhUkhocVIxSEdEWHEwREhJNXFGZHhlc0I0Zmc0ajVwYmJld1h5ZFBMS2draXJlN283eFF0dFVxMWV3SFE1ZHBqUjVIaldPblhyaXpES3M5VGJUZWNhek5pdXJPWmJlbVFEcUorTGhJc3ROWVE1ZmloZEw4SDhNTnV1SlR4dFd5NkZWNFMrU0E4by8zQ0UrUFJmc1NvZ2pZZmROK2JQLzROMDl3aEFTUko5SnBqN2ZGQ3J2aE9YeGVXUVl1OEJTT1Y0Um5KZ2VoZHIrS0pCQWpKd2JSR2o3V1llaUsrUkFaOU5qRFF4KzF3cmhJaGZhQVNPanZIN1RsTDhXaHZuMmpwdkJkQjA5YWczSlhSMDJOYTNkcjVWdUdPbExVU3BjNDgwaGE3ajlzdkE4MzdPdWxSbmtOMFhEOEFiUW5PdEJ1cG4zQkFvNjYzU3kzOTAydFBrcHZUTmRra1dXa3FhQ0UvV2xQZTFQQjdIaTlobnh0SkwxTUVvWm1Uck9jaVg5Mkp0YU4wNUpzWmpqOUNINU5WUkhXQlprWjR0QkxoRUwyVG5XdldpeW05YnBJbm1LaHdiOE5mZmZRN25QTUhkcDdmMUZPNXRnQWFuU2VxL2ttT2dLazBPNlhJN3FzMVJUbmZYTy9oM1EwZE92THI5b1RPemRrMnQ2UnlYbW1ROHdtTC9EaEZoTk5IUnpNcW5oOFhRcjFRcUlrOGo5NElXbzgza1pYSzFMZ0g2SXRGcG5QdjE1ZGJOYnRrNlp5NUxqMHp3c3M3bzgyZUR0U09DWG14eXBDSStKb3I2dEFDQUZ3TDVOTE1qaUpGdkp6b29nRVYwQzZac1FneldzY0l2Vzh5Uk1wUHFjOFk2UFVBUjBDZGFiQnRsdkdIeGc0bkQvdks5OHRtK3YrUnNyVTZlbWZVQ09pS1F0UTFjVUFuMVl4TzVjQjhQak5rcWZZOENGVVIzanphUDNJbUlET2VjbytxMlJWV0d1bUFDdlkwUm1QRGtKV2R6VU5DdnRFbVhlQVpxK2RIQkwzQ1hkb2VuK1gyODMyRnJmWXdJUUYrTVpVUWtJczRKV2NFZGo0TjFjZ0N4MUJUVUNOMWt3dndXanpXSFBDTUpiSkY2OC9ScUhkSGxYWFZJMlZieDUvQkFxM1FDc1ZjblYvV1NVc0xKNHNvNXBVSFdpemV5MWxJbnRGMFR3R2RZaE5GU3dIT2NaaklodkNFOEl6WEZYSVZGVlRueS9Udkh5eGhuVHErRnMrMlMxQW5odEVCOHMxaHMxV2FlcWkvRUxWNXZCZkpPUDBmUVQybERwZktVK2ZZUS8yaks3SDd0VlArL2VjVGZoQnhBUjdyKzNENWtvZFJnc2NyNjE2ZGp4QnlJQ3VGeVJrUDlpWDdnSSs0eU1jd2U2SkdBa0ZJMnFPTWJ4cjZ4N0M0ajBmamtBdWJNS3VjMHBGbnRNNFhVc2pYVXVsOG9rSEl3MWhwMDZQK2cvZCtUaXZBS0lUQ1hGRitJNjhEazBIWXVkT1phZE9OaU4rL2o4a3l4NWZNSXZEanBzYytZenlUVlRIUUIvSDl3MVRPVmpLRGl6a2xXaFBRallGT1hSYmVMOHBLNnY5UkJwS3Y0RVBZczhNSXVUam80SE9nYmVyKzBRUlBkcTZucW95QktzOTRORFdIYUd1dE80MkdmclJvWEhPKy9SS0xwQXR6VlhmcGFZdTEyTm9SamtZWHZhaGpaSUdEcyszMVltdFd6b3ZsdG0ySktyZlNISldma3ZQbVdLOWJLa2RUeUo1d0xFMXFhZVdpUk5OZlhIRFBFbER0Ylk1TTZ6dlFveHlVcVJKWnBVaXpuallVeEdCSVBIbWUzU3l3OG9wb0RHaGxySmZMT2I5MFhYditwK2E2dVpzTHlTaFV1OTdiNTZOalpmVTUrUVRRT0kyWEQ3V3lyVGlHZGwxTUdPRTFQVVYvSVIyakZEV3hSSVY4RWZMUGY3Y3oyZkpkaXVLTDVDVDdPTG1aQUVYeFRlQXZwRzdzU1hReUtTdTI5UWZ6VHhwdndZcEZCeWQxNUhQaTd4OXJkdGJ4QnZYZHZ6S25yZ2hzcjVEY1ZKR2RxbCt4RU0zLzEvSVoxNlI4eVc1aTNSUlBaMFN1VVVRT2NIVEhYWDJnN2ppWjFyc3lVOUZFb29jcHZVdnc5cU9WRmp0SkhXWnU5eExJZVgvOTY3QW9aV2VnYms5Tzk4NkpTRDR0bmhVTkZWdU1UZzR2REVESUtONmFRUjVwU0htaWdkMGVrRkFaSVpmR1d5eWFvbnF4eW5DeUZwZm5MNEsrM01hSUtFcmVrUVc5cW05bUNCblVjT29WcE5hYzhmSTdqcjcxcGRUTmVhRU5xczdBMmlqTlFHUUZiWm9GbEluaVJWYWk1U0lqZ0tqWGt2cG5hWGJLL2NzL2FiTnEzVm1MbXJpa291NGtaRG1qZmdNNy85cjAycys5WnNSTW56Y0paVm5QalVZRTFVMDQ0dlpYaGxMYVBJOWxWdHlLY3ZsVW91TFhMYTk5TmFZMW44dnZ2NmpyUk1nWEVjZW5UWi9sNUxQbVdnSE9vVSt4S1JJVkhtdy8vWHd4bGFLUlRLQjFTbW80eFQ0R3lZYldaQ1NxZk1pSHdvSDhlTnIzbkh0c25jK2FCclBkejRFbTlEN0ZJQUpuV3VyUnV1bHV3U0JlN3NxNnlDK2N0dVJNaW5ZaU1qRnJXVDFpOVNEMXZPcllremQvelJFODdZK1JYdWUyeDk4cDJ2c3V1Nzl5YzE2dGRFTDM5WXpqQ0ZJd2dzS055Rmh4ak5DczhhWWFHdEdmT1ZWTFJ4cmFTUjlESy8rMzE3Q3BGSjIyN3ZSWXFYYXRPZy9qVEYvMGsyQWZFZkpJS0NLWE1jT2tvOGxIeUkxQmZ1RnlCU2g0eUNPNTBzUUgyMkxhZEtNL3FXT2NOc1pBUDNrdmJubEZ2M2M1eVg2WmcwM3F5VE5yWmVXSmRXajJ0dlhiTHJRc0x4MVhGQ0UzeGZoQmlwcHVCdGs0VDV2K0M2MGJyaXlQT1h6a3preTE2Y3B2bWZVZjcvTTU4WXVwNVBMUVQ3Z2d5QSt3YnNvZlRCVG5mU2M1eWFGMDVINUl1L2NnanBPMnM4Z0JjK2hTMDFYcmh4cnRsNk5lV1dCVldnRE4rcDBWblprYndnRmRBN3BsU0dmL1c2SWpvc1l0MXNqTXR1V29KU2JkOFVzaWFjSlNrM3JTWXdLckxxTUhhbTkwczhNbzZoWm41N3lVcjFjU2U5SS9BdmdJUnUzYTFydXZyM3ZLVHpZNDlqL29LVTNWMitzRitnV0JodnRVenluUHVsN2Zmekh5ZUhVRTV2RlJYTW9RdXpsMVh5TzJwbkJLKzBnMFduMFp1RTRlaXFYNk5pZHFid1cxSTNyNXJrdVN4dTBaVDByL0hzdnA5eldYOTcrNWFVTmRaNmx5cU92OUhVei8wWUdJeVFKeDFrcEdwQXc1RThRSzBTeWVucko2cUNYSllVaVZlaVpmRXRKYjF5TkV5NHFrZjd5eVIyMzExMUVSVXBSZE9WdE5hQmw1ZFdydit2YjQxMS82SmIvYWs3VzhMWnEvSi9sL2RoRmZmMGhmTGQyNTBNMTlhbDlFclo4dzd3b3NUaG5OeEM2S2hGTHJNSTV6MnQ3bjduTjRyeXF5WE5UdWE2Wk4yMHBUa09RdnRHaDlQRk1RTzZlMTIyelQ1alpEUnh1aitzYXovYlE4anhLTlQ5VUZSOTd6a1gxOFZEMkJkWHlMNmRYY2hQVmg3L2R3RjdzTVZ6QjVKZ0tTSmxwbVVmSkp2RzdVdTAra25FaWRWajNGU0crQktJbkRuUkx5a1F6WU9Mc3lWdGZ4Uk4xUExzVE1vSWxVZGsrNUs5dlVWZ1g0YlB0UXd6YkQ3Z0hSejhtWEViTGtMVzB0U29nR3liVHlJblZyWmFLZW9aVWVOU1M4ZHdZMEx6UTU1NldxOGo0Ym1IV1U2RW9hV1VGU1hUTlhZcjJjckRxbDgyMitmNFN5azFKT1NsTGNEcy9qemNESGcwdzYxQWREeFJnNy94cDRmdUdzOGcrV3UzQmRONWlIVVMwdTVlME5QVWpNc0NMcTg5a3BTOUlGanhVdjZFQjY1cGRWTG1YM1lYajI0MDc5dG84b20yT0xmeFF6V2ExTE9TWTNJZnJBVUdOQWRuaTZ3bXJpTEhQbWNmTTZxaHRTazc2a3gzVGFIeXhac0VjZTFJR1BSdE9jTDYyZmxUekkzRmpoekpFTlBWM3NPVHVFa0FBTDllUU1OWHo4ZWg5cE1YckhPYzAzVXFyeTJxSXBITWNJRDVVWGRsakJlSjBNUkFCRXU1aHJ6MmFGS0d6b0NXNXoyQjVDZE82NUUyUEdoSTZHaU5FWm5ZMDZ2UE5KU1ZlZmtlcUk5OE94YTIrbTFvdTg0cEVTTmU1MThHYnEyU04waWo1YStUWlVsSlYyRjVYOWRMUm5Wck9Ic1Fncmw4Tkp6dURxV3J4SG5ITXRFWElPcUJjWWVlOTRGY1V3b0tlM1lYRzg2R05aRVhabVg1TlJldWRrUForOWVUZ2FZa0hMNWxvZ1M1a3B3S01XdjdlSVpvTFdsZVh6YjNsUS95SUtLRE03MXduQWlVSlFlN3l3S013K2EyWjh5cnR1aUxsbi9WQVc3V0thbFFmQVRuNHVxNFdIcHFhbGF5dXdmbUYxRTBhNkVjMDdvQnFYYzhaYmRJU3NKR3F5dm8rTGZleWRKK1F3Z2ovVlE5TFFqSjNBREp2d0lZTUIvakExeWNIaEt6eVJJK2VqdlE4YVNkOVJwVlNWNVMraHJ4ZGY0aVhFeU52N3lHNHNVcm9pbjE0cDkwN3RZeklPdmRWeDRyODU2Q3ErcEhsRDVXMzJNYWVlWHNrajNmSElrL0Nhb05WWWZzcis2NkhtMG1UWEZvLzJDbFJ5emx0bHRYbTFkRE1qcUtod0tQTGhUaEZWMjFJVnJReE1tMmRucHRwZlNrVjUzVCttbVBjdEttS2JmcStXWFJuNGNUTGJjbGswNDQ1NmFCNVdIMXZKeXphTHB3c1kzQ0FiMEpmZXdodzEwNkkyeFBkM1RTM0I1VW54N0s2eTE1ZFQvYzdkbFJSNEE3djlRTnY1c3RpNlgwcWVxNkpaN29BYUdyWmNsOFFpVUxkalpxWEdPb1hybE5xTkJOUElCRXJnYkFJMHdENXRldXVFdlk5UjROSTBQOG1iREo2eHJ2bURsZiszS3k5OSs5ZXY5SjdMdGF1eWJPdlE2dEsrckpxRlVVQ1Y0anRyVkM5VjVYbDUyNit6N3JwUXVWOTFTMmpQR0VobWN6ZEZhQTVEWUlxMHAzYTlBVG9qeUlzRW1udGtuYXN6MXRNMEFVMGI0dFBsTS9YS2V1N1l4d1AzZE1TU3laVUtST3BCMjdSSkY3eUJ0OWp1TVpnbDJSNlIzeEhaTDZWSDZ2RHl6aGo0VnFoci9aQ2RmRnI2VjEvVDdpWlJac3laZWo3WDgzQ2t2QWhTUUd5MERZVEFkR25pUU5uUjlEMTFKQ0Jmd0NIYUZGY3FRMEs0bjlMNGlTWXpGcmJtWldrS3VNZjRpYllCVFkvVUJUNnMyMzM1Vm1tVCtoREFxN295WnQ4eGxMUU1kS1ZFVjJ2TEN2TUtiVlBrQ1FiYS9xeWtiME5tSmVIdDg2NVRQVmYwaGtZOVg0WjhGbEZWYjVXVGtpNzZJMElTellPbWY1QnQzanVjSzdzSGxiK1JVRVI3bjZoMVJYNWdoMTJPV2t4RlJXZExWaFpUL1hqUU02M1JzQ1duekUxQUoxckVMUnljSkQzZThTcXo0ekh6UEJKU3FIbUFuWVgvTUpVUWpWWkNTVkVVNlFHRGRkeFJ0VmFWbFo3b3pQQ2pqeWlUVEVBS2RDRGVOd2MwaHZVaXdvWDdzZ1RQazdTd2N4NFVBZnhZOXVPanhhaTBkSThiNThnREdncWV0VXljZHUyRHo5YThvQ1I3S08xTGJ5RjZJdjVIekxaZWd4bDFpTE41MWRJN2JhNmlwdlQ3cU1COVdZSjE0RzNZUDJLZ05DRTRTMHdJN3oyNG1kUFRNeWhIYnBCMjF3ZnlMZjlhdGFwUHVTTms1WUk2dmpaOXl0c3FqcDZYYlJ1VzFwV2NianlnSGJzMm5LOXZ6MmpCaktsR0VVckk1eE5aeDFFNTFmdnVTb1JwY3VoRG4ya2NCbDFTY2daSENJZWVsNnBxckxmYm9tM2dPaVBUV2FtSlJ4ZVBoN1c0WnRYcExMclhaazM1VmRhTU5wM0JGV0xMZ2ZwSHB5MzhMRGJqWFRNZ3AxSFZjSVRkSEdWVU1uaXZWODdtQ2pPZGtGc3hTK0RBY2hrb0k3cklCMDBCY20xWHBWZnVjOWc3b0pLOUJNUFBjdG9mb3Jid3RSUXlpNEY1RlBXZk9GMHZ6QU1HNStlSHFlMFRKT0Y0NkNWU2NrdXNuOWxuSXkzeXk5RVNxOXFxeW50WEVDbHpHU01SdHZhTi8vcThWRWFSay9YQVo4NDNRcG9uN2Z2ZXBBOUUrSGg5N1FpdUZjYWtKa0k4R2JxR25qdnNmVVF4SS9vRzF1MXVXVzhKOXBMa1VkSzBuOXNZb1N3VVN4RUI1ZTIrenRKNiszbnp6MitSVXAzZWd0c1cwdmVsVksrUDBSL2RGT0dvUGRQWnA1L0VqS2tYU2Q5YjF4MUI5RTJURkRRdk44WDkvZisvVmJwbVpaT240cTNmM2M3Zkh2WHNhczliMTJkUWhMODBNcGpPNS9lcmR4YVZkdm5wVSsvamFPOTFYb1N5M25aTGh1ckVMVW9VYVR5alpWSDZISVZtbFZscHRlT1dHU29kRFU5TncycjA0WTFwb0cxMENkb3BnczN6WDU5aUt5RkxVM1oyNnJiOUl2WDZSdVJuK2Z4dklkdHJ1NitRYWdycTUrL2MxUFgzblBiRkYvUUxvVzM2TnAxMXJpNEwrdktNY1gvMTllYlA3UW5QUHJLczh2b1FzTE4ycWp2dkEreVN5dGZ5VDVBenFxZXR4TG8zb1FPanZQcHl1LzdldCtuWnJzN0M3VnZmRGhQNjlKSk02WndMNHMwaDBvWHBVaVo1ZmJmSHJXejVSMG52aWJuWHlTODlmTUo0WjZOTktYSmVLcmk3OHFZTVVFMUJhQU9zbUJlYmZOSjU1TG8yYWJ6MmEyM3J1VzlDL3RLakt6MmYwNXVQdmNiTUszelQybzNVaWVUU2pCaWtveE1jcWJzM2lJUTlOOTJrMC95L2Q1SDdhSVJjNTh3K1JhMDZxN3lVZEVNQ0VaS29JUkVkVHduVWtIRDYxbTFLRVJJbmVWZ0hHSDJzTzlnTFEyMnA4MGwxUldhNXRJcXRGZFNERmI0cENYY1RQTW5oMVkra3ZSMm9pUEFtQy8ySHp3UlZCVDBxWTVUc1hIdjB3c1VZMFR1OWpPaEFUeGUwY05nYlBLVllEMHJiMlo3c3BteWZpamFmWjYvUjkydStuWFZ4dUI4R0VtZVc4Z0F5SkdvbVd0ZWo0Z2cxWVluQXd6cW4rbUpxR3p5cW1SeDFJSitOOVJDdW5TclNNVkwySktRbWtXK085SEhKaGJHQ0RKSXFJT05jVkRCNVRlTHdLL1IwekhCblBreXpmZGp0YXMzMWgvMkI0M3BVWGdxd0dCTWlkZTFzcGkxT1lFbzAvSldOODFHNWlqcXI1ODNvckRqYjN6OVdyZTlYWDhoRk9WUGN2dHpXNlpVNkY2UU5SOERvd2gxWU5sdlJ0M3JRYXpQU3J5cURYSXBXNDBVMG9EZHRNMXBwZTU2UUM3TkNtNlBUbnN1RGtPdHpaTGhxQmt0dDJ5ZTVQdDc5cnV3THVwa0VaZVd6cUI1LzFyc2VmY1o4ZnRpTlBKNHpyWUFqZjk2QXB2MVpqTzh2cERJQThKSEFRNVFubExHdWlLaEtXVUYwQlhsSUs4ajdFZElWVkNWaU50TzhKWStrQkkrOTh5TjFSN25LSTlnVFdPMHVrWWNRZlRoSEpUbUYyZXNTM29lVzQwZFcwK0dhVVIrZHdHZ0k2Y2F5NVB1SHFlOGJ6THFFbFRxQ3M1bTBTRDlxZTgwZDZjZHZFMTU2YjR1MG1sVG5tZFNFTWRCR1NEZUJ2ajNXZVlOYzdnOGkrbTc1SlJiUEI0Qyt5RkNNNjZXdml1Z1ExZUk2S2tMV3lvcm9qMUpHbnBLalpRYktlSDlCQlMwajBwdGVtYk5HeHVyYmVyWVU1Ynh3L1A3Q1RKR1RGYUdja3RKZTYxdHRzaW53ekpidVMyOURxVXJQdTVMSzVsaXZBNm43NWtoMkkvb1VMNlhIZGRjVTJtV3JMTi9VTE5zMmUzMWNFbU55QkFCV1YzbWJ2aUN6cTllT2tQT1Y2cS9zV0dHK09ISVdXVk4rVmp1cXBQckhxZHVyU2h0UkU2SzBKL2QxN2hObXBUQ05pSlN3Mm5BRVo5YjlXWGd4R0xTTW85VjV1TTRjUE45ZUswQWowTTcwWEFFdFhWTGFnS1lsaCtCOTFmUTdqWGJzcmNEaTFKV1Y4M1dSVGJ2YXo4VVZKMzFSem90TmxlcDZYUy9KL1pMcXJrd3Y2SkwxZE5CVDZwNzBrMklSbXl6dGNUTW91eS9ISnAxMkhObzZVSUt5UmhTWnpmQm9WaFZhbm5nTjdYYkt6SEh1Mm9lY0cwdXd0Sm9YZFMxRzNtSEFXRDRheGJYVWtGWEh4cHhFeTVDRXFHVkdhTGFzVkJhcTJrWUVPSHAvYlYzMWRXL3lSTXRFajYyNnliT0orbVpJZXNueG5USC9JbTFGWS85Qjg1S1FQVmNLY0t4c2kySkplTEVqclpnaXhFQXpHZ1Q3SjFpcFJXMVFGREJkU24zR1FqUVA4b1JNU21mbHNReUZ3UFZkTnlEOVUrV0ZkTVJyanZVTGF0Uzg3QzF2UmxsUnYwSTY3ODFldEFmYnNpUDNGNjJqUlhNVDBCQTRBZkFtRlRrSHlXWjkwYk1JUndYVGFuUG03RWV3SnpQYXhkSG5ueTk2ZEFSczBxVzlOV1Vka3dwTjhYcm1tWFl1Y3Ayb1dLRUROQlNSZ0xTU2lidDVMRmJKU0cxcVJLWU11UUdvQTZGeHNrQ082QlhwZkZ2T2JlWTVMRFRBZEtsSmQyTjc2NDhjd0ZodHpaS1BSZ3RJV1ZOSlNyK29LYmRrb1JBcUhXa29JUjRPSjhCY1RoWmtvMVUvZGpyQXdwTjIxVGhuV09KOWRTS2o3VHRpTi9ZOEVFYWVSbktwWVp3a2xqZzhSQ1E2TWJvbWtpZFhZeStPNU9wSE9nVnlqQ04xYXFueEd5OXFYbEMzcUxlUWsrLzRvMmh0OHRvcXRhRlhiMFlmQ1dqM1Q2NU1aR2JDYWJXcG82WHp6bG5YdmFXQ2xwT3JmNk41eVVlaFBaU2RXZDVwbkdIRGlsK0ZPWW9yNjUwSmd4Rzh0YVBldjBMclFxMHJpbFJDUHArWjZ6aGlObjZkNzFBRE1VOVRLUUNwYzRWZ3BydEZ5SllWTWJPUnR6aWo1YUpwWTJFNVFnSmN5UnFmMFpaYVVjN3dXcHI4WC81dk11b2s2NGlNNjR5NkNuNTVwb05zWkVYUHo2Qk12bDQ2MDNKbEVYSnhocDNyd1h3enk5RGt0UGE0OTRFQzZrNHhYRnB2NU01b1AxdEJHRjduZkZXRXJHSmdibm4rRktmckFDdUV5NTBNRG9Qdkw2YnVidGFKTGp5a2M0aEIreDdvNjEvTmFkR09KeldscEswd3RWN0UwdDRkUEdWYW95ODBldGNpNlpXNmV2cmxpTkFvK1FDUStmdEVrQWU4Zzg4WmV0OVR0cHBpcFkvV01RL3R6V3JwZW5RdnBHaGRIYnkvbklyaVBZay80cFVvOUxxVlJybVAzTnpITzVrV0NaVzBmS3dQZnI5V21qZkhhVmRqZmQyYUMzb2JzdklEbDl5MFpaOCtHWFducXF5YkNGdDZ2K2VpMmVpS1l0RkVtQ2FkSWpvamcrbklVNWd0SEN4blZhdmJrKy95dVJLcWF3MUZPdE9vMzdMVHV3VXBxTW1Ebmw4Qkdvem94U3FMeXF1SGtaOE5vK2NqVnZLbHJLbG9ZM3JkZ1hwYUgxVW5DYVBINWJDWnJhVXJQMWZsWExaL2hLK3FPbjJ2NFFqNGlWL3p0eW9mOWJPalgwYXRqNHZuRnlwbDdOSTNaZStLS0VMeW1icE5hcE9UckxJanZ1TWFVaGxLM3k2SWRiZEZlajZLbDErNlZoK1BySXBJM1lTUTlSamhqaDI5Y2ZiWEgyWDJRaSt5aW1uRHphcmM4dG9qQ1NqMEhqeTdFcTI3VHQvYmY1cWcxUWEweDU3MjZ1NXRDNVVFOGZEbUNHcmtlUE80S1Bta3ZOSGdid25VeWJWQURtTmswbm1MQ3kwYldVejFZbWtEUEVhWmIvKzJPZjl1bXFDSTlnR0o5RFpHUkJteDg5S2FmMmY0dEo3dzg5SzE2U05Qc2M0eUpCQ2pTSWhmcU9XMXA2dURJbGpLbm0yVFBhTUdJMkpuZjdwcWtGUmh2WnJyZE5KeEFjKzM1ZGQxUjFlU0oya2V3NHhKR0hWR1BidUxYQVBOeGtYeTFTQjJjbTlaUFhQcUlmTU5kWk84L0QwaUFrM2JhOWxJTWwvVENaNTE5RmkwRHZwMGcrUW1STUljVWhyMVVWNjBjcUVkR1d3TDE5ck5tVGkzdkdRUjc5WXFDL1VyMFBKdVRVOW50K2x1M2xuL0pFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnRCs3RThaUDkvVmRvTkl6bmx5YnlLLzNsNDBaNUNkdzNvMkVwMU90QktrY2RGZFRBTkZlK21rM1JDNC9EK2NudDI0T09neTFvN2YzdGFFd1NxMG5RdFg3R1p5N0hCN3JYUjIvOXlscTYrVjRIR1RmN2VqYkowa2IzY1lWVHNON1YxMDc2VGlISS9VYVNFcElxUHV0cytzdnR4Um5McTNxVEs0aFpuL3BTQTlyNytnNVhFclhXMjVrY0NOYk50RVEyTXV6dFFxMVhHNzhYVlJ4Sm9uU2F3MEhOS0hFelUwWVBWa09VaHRHdHVPc0w2Ni9mZGNFZkw1b1JOTjFzczV0THJmOWJXZnlubi9rWDkzZlh5ZFZYWTRmNVdSMzhjSnhCTGNxTVdad0hUdHVLTGxJbldObEVVa3RObU40TG1nZFRxcHpteGNiMTJ5TU43MGpwalBYbU4wSVdMWDZjbktpS2xQVGtNZnB1MlYrcjlaU1BzOTFiYWxsUERnSTlIQkttMEJuaS9zempjR2FKWXlLSklrTzNYdXZsTHEzSC9wOFF1ZE10U3ZtRFRIUmJ2ZnZQMVRpMFVrNlZwVFY5YmFLdWhHVDE3dERJMXRWWFZSMnpyVE1Mc1AzV3BWYTkzUzJSekV4OEVpRVlTUVdXaG1WTlFia2NxQ29yQjVHd3FlalNTLzZvOThmMzNnTzJIc1pLTFhTZEo5elRJam9qYXNoVmVXZG45b25SbW8wMnRMY3RwazZjcklKQ2IzWThTdm0vdElvNjh0NkpwRzVKRjFuWkFkM2lKWnNiamE2OWs1OXRKYmFVRks4MGQ1UGVkdWZMbWFMQ3kwTEJSY0d5UjI0Z1ZFRFFha0h5TUt2MDQvUzVnaWJYSU1pWGE4clhGKzVaUDhmaVhwZDFsTjJSa2Y3K2hUQWxRMWFNZHRYbTgwa1ZtRnJ1cTZUTlRIU0U3WmlBUnA3d09WZEZrNXIrVjdERkZSOHhkVTFHdm5hZXRjQTA4bzlKb1J5Snl5aEViRTNoNDBJWFoxMzRpZXJwaVoveS9lRkVPdEIrdDZWQ2UwNlI0ampsRGxaNjJwTEJ5VHFYamhEVFM5OXB4SU0ybHIwOWNiNXBtaFR2SkJlQU1mY1F2eldGWHRlUzlkWkc2aTRmUGI2NUNlQlYxM0N1Sjdmemo4WWlvaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0lFUXZwaHEvRTUveHE0dTVMNW8yMEZrNC9ya09ZUHMvb0xrV1VaMG00eWVuWkxBTFhMUXpia2tvbnNGa2d1RGJCdkl3WTJCTENZcHpjQ0dtOUdkc2hDdU1leTkrM0pGOXFSTVRoMk9vQlkzcjBYMmlKRzJQK25aS1RjMTE1S1J4am8vb3BnTFdGNjFqWlJaam5mZFNwUGYveTAvLzVPdmwwMkpwZXUrcFhidDYycXY2ek1yRzIzeHJKa1BRSnZ1N2ZYMjJvZ2U0dlpqTW9oT3lXbjd4WTBDWmQzeGJ5SWs3ZGUzWlA5NHF0MmRmRllsMG5XYzNCRUkrZjZTYWhHdmZPZEFWOUUrL1cvWjVYMzgvc3BwMGx2WGJtaWVtdk5KdVk2MjBiNVdBbmw2NnlKWG8wY05vNktnNVYvbHVoc0w4a1JEajQrRzNIZzBqdVBsUjY3MzJrTzBvNWJqbWNsN1AwSHlMN0xoL2V6SnpWK2FYc3FRM25MMjNWYTNFRzU5NjU5ajg4dW5neE5TSzF2OXlvdVRiNlR1bmF5UStrRWEwUkl3U1p3K2JyOXU0aGtTSmZYSkgrdDhSM0h2cGxqK1RKVzMvYUlxVWtkYmwwYzA1RThJNlFNeHpWN3AwUFdtNldFemZ5TWNKRGx6MUhyM1ZGUXIrZ3Nxb0JBM1Q4cUhsSzFkanpvT3hUZ2V0YmNUa044TDhiZDVyVDV0NjVnYjFpQ2ZqdmZZcUlmV3h2UHE2dkYvRVZrUm1jdWM5eVRNa1lFUXozUG84VWJRdWpvWGNtbk9xLzZ3VU1UcklMOFNhTW91WW1Ba0llMEtpOHBxbzFlZjFxWmVJZG4ybmRRMjFKQ284MVRwMjVqRDE2V2ZCNEM3TE8yRHdiejVaNVB1NjlpSnBSaXRxMnZ3UWhGYVBxdGM1RnJ2REVOTjIvYThWVTUyOHZ6VDVDbk5lYTNjdGl5a242aHVPL0I4RVc4U3pCU2RaQjZvZ0JqeGE2V3lJbjRmT29mYThydzZWcWpmbTNER2N2VEM3WmFJOGR3K2pjZUpIYStUVzd3SGJ6MG1IQW5UV3RQMStacmQ5ZFl0Y3ZSMGZ2OW5QQ3pENlhCVFVGdkFpNTFOYkVKN1Bobk42UTMxZTZLUVZHVGw3NXZDTDZhU1IwQmhSd2doNUZvOFJUT2RkNStaMnArUUlUS1hFQ0ZEY0FrUlFnZ2hQMUFwa3Nsd1NoRkNDTmx4aG5LZ1FpS0VFRUlleHBIS240WUdJWVFRUWdnaGhCQkNQb2Z2TDZaK2JSL2cvTlpaK3NVdWQwZ2hmeWtEMXlmUEphazRaRjg3Sk4xU0ZsVnU3ckttYllxWTVPTzJEQzcvbTlDemFNZ1daQnVxYU41aXB4djVXSWUxK3lPeU1VdGtyODg0bzN1cWFGSlAyNDRLMmFacVJnOW9kU1lucjFaM3o4NnJIbWliSkx4dElPdDB3blgxTnZwblZmMFZ1ZnJZKzBJZDlrV2dmYTcySmtyMTM5eTBxUTkwRDlrTEUzbCtPdXZXcU05Q2JDUm92ZnVia0daRTJrUm5MMTNQRDBKVHc5THVrTkkxc1RCbCs4RmRPZzlFQ0htR1dkNWMvYjJkckdqQ0hLakRUbFhycDQwK0taVithWFk2ejgydnk4dlB0ZmZYVlY5KzREdUxaZk1nZTZsSzE3SDczWmNSVFIvSlEyYUQ2Z1lrWFZUV1IyZk1qc2kyd0k2UHR0c0ZFL0VQcmZLbGMxNlpWdWQ2ZFpIRDJNdjQ3WGs5aDM0Mk4ybmFyMnQ3YmZnOVg4VGp0eDRxd0VSMVhXc3RzTkdXMHhTMCtXcEhsZWJydk5KNzJsYzhVRjhUU2FlMVFhM0xhWU9wbDdXNGh0WTJwODVpQ0krNi82VXZwbWgxdVRaYlRHSWp2ZENLWDYwTVpOUzFEOGVnUk51MnFUdkY2eVBrYVZnZWk3ZCt0RFhteFQzYTgxL1hETldIcm5leFR1ZVpYUSt1S3RQc3pRTGtzVHBKU3Vlb2ZvalhRSHBselE3cDl6eEg4KzVmS2llRDdTSFBBaEZ3U0xvMkQ3S1dlc051V2d4d2RCMUllYmcyeUNGNDFucFVFYlhwSXA1RG15OFNpSkxTR1laSGJxeWNZbDJ2eS81WE9SK2h2cThScXdnZEN5MlBwUHc5d2F2MUMycEl0RUt4Nk9tTEYyVnF6Nzh1NVcwVjc3L2JXRXpTcDVpenUyM0VyR3p6dE5lems3NW5ob3lxUEhUVlNxTVpKYUx5MmpvODFSc05iVDhhYlFCSFJGU2RYMWl1NUVUUUJSc2RmeVN3b2FraFRiMUlhWkUySUdZRStTS3ErYjJ5aWxPV0ZRUDNHQlZKeE1CN0JtdXRWN0lFTkJTUnF2UGVvMG5Sck5aY0UyZmNLV0lmZ2pmcExGZmRjNGljeTE3MmY1WHpVbE5RME52N2VFYWN6YllNcjV5YmRTSy9tRW9JSVlTUWgzS0dWVWQza3hCQ0NDR0VFRUlJSVRONFZveUJFUlZDeUFpVUlZUVFRZ2doNVBPZ0ZVdkk2WEFaRWtJT2hDS0hFRUlJSVo5Sy9zOS8vOGY0SGU3dlQvci8vSjkvNHR0L2NBdU9aekZqcTYrSlZYckhweERkemtaS2Q5S05jRG5mak1zdGpodUM3SHFTaERUQVdLemNIYkt0WTJhWi9Yajd1MFIzTngxcFE3dTkwWXc5WTNxMzBZdldmZFRvS1hWcHR6MzZGWnRkM2QrRjJ4dk41RTBxNy9pM2JMbFViVU8wK3ByMk5kWnoxOWFKSUx2STFlZXRmQjVQN1dSTkR3WDZvVmNYMEt3Z1gzVFpPcTB1U0JNYklUV21Ub09lbjljQy9HdmFQenFrK1NMcU83L3BDR2VocExvczFGaEZCbFJMVjV4anIyNXlKNklieVVZc2ZWZy96WnhpSTQ1VHI0aytvTnZKZGZIQzdVVzVXdXVTL1ZyS1NsMmx1VjZxLys3enlmb215ejZicFNLMmxUVEhpaC9ZNWY0M2JaTyt2dHFtbDdCOFV1MytwWFNST3MwMjVOOS9JdjR5N0hOcmdlam1FS3A2blIybEVRMGw5SWJkYmRzdVRxOHFJT1NKYUNwa3BLelVsQm5OZDNWQ0lsKzYzb0s2aFZvZXBPNGVaZ3JUcUhPQzlKV1VEb25iamZvcTVONTQ5dlhyWE1pZ0FzcTB6cWVCdXV0OGhIdzhSd1J1TElVbDFlbkZaWVgwYjcrMzhTV2h0a2xsOWpKVE9VYUU1U3doMnVMZEQySndPT05vUFY5QnV0Q2NXazNkQjhqdDZJeGFZVzdPcUd2VWZCNnR1K2RKanRhbUpPUjlQSjdmWUtXdjgvU0tEcktHbWI0bVVsZkxLaFBDZ25OTkJaV1ZQZDNXYTlrbEoxMmJ0dGMwZUJTandYNnlGRThzZDRjaW1oanFQNFk1YmRWTnlCczBkamF4cWpPWXFRcy9FbXVjUGVWK1UvakZWUElvcVB3SklaZUhnb29zNDFtVGkwdUpFRUxJRlRoRkgxRUpraHZCNlV6SUIzUHFrekJLRDBJSUllUXdycUIycWZvSklZUVFRZ2lCb2ZtOEVIWXVJYVFEaWc1Q0NDR0VmRHJORjFQMS9RSyt2cGhLU0EyNk0rNkMzWHU4bmJ4Nk5oazRaSU1qZEllcm5wMUdrV09oekVpVlhoUElCM0xpT3I0dHlLTHl0cVBTY0JZcXN2R0dCU0F5QXN6WTdpTXFOTnZ6RXFOYW9PbVpxV3NEN2FlbzFsdTlnTUUyZU0zWVRUcGtYSC9yOXBhYWxxYWYvVUpHMXBEMjVkVGJzKzhJK1h5RUdXVThpUTdkcmcyYmRqMWFIcmtacWwySk9DbGFZYjM3cTgyb3c4dmZwdTdaQWxuT2E1bVRmL1hJOXV0NG9QM3dObDNLSmwvUit1RmRPVHAreUQ2dW96YmhTQnVpZFpBb0krR09xTVdxbVFCYUhYQ2RFZEhoTlM2aGxTcGx6Qk1wZUJsVTFNdEFKS1NYTjZiNXN1aHZoTTNubjRRNTV5YWZFbHlVS3RPdWE0M0t6WVd5Y0dMMmZDbDF2Tksyc29RVGpZSkwrZXM2OC9hMFJrRXVlblpFbjI3MXBwYVdadE9FdEE2S1RVTE9BZlVHSW12VXNodGJkaC9tTnNxTEVKRmIwZnVEQzQvczhCMnRPeGxseitZSUpZRGE0cU9xSDJGTTNaSW40UWtzL2FIRzlueVBMNHEreDBESWRLSktZYVZHOWhiVGlPSnF5b1kvbXc1RXpjeU5uMll0NUxyT3VtMjlCc2pWUVFXeWxhWk81eGtnemFVU3FETWE3QTFNZzE1VDU4dzRBT1F2cEQ0Sk12dXBDa0xIRENJdmVsWEFpMTU3aXh6THFLb2ZUWWUwWlVhd2xMYjVobWhYeDU3ZGpCRnh4YXlZbVhmK2tZd1lHdXpVSlFDZVNseE1OMjVTN3RDL0ZKa0V3bnRuWkVMUm5wK1VuZXYxTmUyNjE0YWt0T1hqaWRwcWlEMzJFRjNCWDVzU2NtZG85UkJDQ0xtRU1xQkNJb1FRUWdnaGhKQkhRbmR3SWV4Y1FnZ2hoQkJDQ0NHRUVFSUlJWVRFNE5NRlFnZ2hoTXhFK0dLcXpKLy9tL0Z0cU1pemlQNnllMkRlSUhzSFdqdFNuRFpsMGEwSlR0emFMZG9rOHFHTTdHYmJ3a2xpRTlob05Db2JFVm1JNU5lYWd1YWRqM2RuSTYzcjNGbjBYYld5MTB5WnRSK21CU0toMFQwMXZUYU1qTEIzdjhwOXRuMzQzcDdxbmNBdlk1Zk9hMG4rU1lQMkMxTHFieDZyWEgwbVBseW9SbmRtdEhaeXAzNnltV0NMdjBCWENESzg1SU5vdHcvc0VkUGF1cFhTWW8wU0NyZk9lMlg0NllzNnMzOVQvSjdObXpON01TWFhyWDdkdEk3aUdEdldGK0ZnVi9mN3hLaTNiYUhkZVhUYk9QSUpJSmFyUjFSSGFEUEtTLyt1eTVybUhyMXhuaDZHWldWVEZoWHhKWmd6RE5vWFV0dXZiRy9yZEtlcDZWUlZFOUx5aTlGNW01cy9pcWE0a3FDT2xMYW9XeDhMYVh0cFA1dlhYOURQdjhXdnc2dHo5MlVjcGV6c1NFMzR0Z1RiWUpJTVJNUXpHbGEzeWticXNHNEZ2YzBWcW9FUU1yWnV3MnJLU2RkRFJEWk1VenRlNVVpalpnbm1zenF6VHArRWZHaGNzaGUwandsNWdjN3Z2a2NhWTNQUk1qdFJBOHNMR1JFeWpSRkZ0RHFZMHFzY0FJV3NQbnZOY3RaZHV1VDdrSWV3WWd3aUR6V0trVzhrQmg3Rk0rSTB0SmlEY0IyTkdYUk1DN1RIMi9RenpjdlJtVFJqdFI2NW9sQlRsdXAzQUhSUzBlYjViSHI5UXRTVzk4cVlJYmhhemhKTUp6QmI5bzkwbHphVlVHdGpCQytjYzN0NjQxbHRPbzNJZ0JJWXhLN3FVY083NnhQR2lNUDhjRkJYTFNBYlJrUGVNL0c4NE51eXdwYTdhYWZ4aTZua1VWRHBFMElJSWMvZ1hKMVBpNE1RUWdnaGhCQnlCUjdtbTF6aVJkbW5jVnlmbnptNm5GbUVFRUxlVUNrUVFnZ2hKMExQa0pBUk9Jc0pJZVRhVUU0ZkFEdVpFRUlJV2NLZnJ1MVFWbTRDUno0UDZaZmcwWTNaZ2xWSjFieCtUSTcrQW4vR0Q5aGh0QzF6aW5NK0NjZldyaTJCbTdsa1A1SDFSSGFyOWVDa3NJbHM5UmpzUzNUbkVYVFh5SHBhb0h0NW5rTmtieU12ZjI3K0xVS2FwTC9VdXZ0YVhISHEyeFNxWFBPVWdTV1J2VW5sYlQvdDFXM1JhdUQyL0t2SThudDYrOGVXRXRreXlMNHJEZi91ME5YVVYzcWRLZ2Z6ZlN6UjVkc0tKTXZJRzVTcHR3ZnNEMmt0dGRjY2lTbVdWWmRabERJNVpCOUdxeHM3UWdxNzgvQWtHTEZNeHJhMzNINXg3dnQvMytmM0tldDBrb1lzem4zOGZpbTFiV0Z1c3BXMGJWbTFwb3FjZC9kRnZiS3ZmVThXL3RZRWMxVGdwelEycmxJNWtiSXNHK2dhRnZDblkvV3dCV0w1dGhhOVdtZFZ5TzZEaVcxbG5oTTFVMmtkb1FRUjE0T0srRkRXVExIU3JBUFpSNFBONW1ZUjVVMjVMMTFTRkpHWnQ0c092YUYzbmFBZWFYU2hQTThkdjEzN29tcmtVM1JTbVYyZnNoUHl2TDVhMGdxcXVyMVNYVnI5N1JkeTNBbXd5WnhzNzdzNUxuMDZGQng5TVk5MjNvc3dTSGtTV0ZZVWlsdEN4bEFrenZ1Y0ZIUFErRWRKaDdpM0dxaFhGUDJBOThaVW5TMUlOQ0VheWV1ZDkrSjRiYnJaOW5aZEp0cVdOby9rSjJpcUVTbTdMUjlKaDZRbDl5WWExbHBoZUZpQ0dNbGpCWWVMa1krUXFZd3NEbTFDbzFhQVJ1OUVSeFNSNXVjMkRyL294K2VFdFUwVEN0R0ZMTjJQOXVBUWJVT2szbDdsanJZcEsrZnJjMVo1VXAyb0laSDE5SnZxTWo1Y3U3blR6S2ttYWNSVzMxWGhwQ3RBUGs4Tm9VVE1TMitVdkptVG5Iem82dXd4Wlh2cWVqem9wUEltanpmSnlMSDBDckNXR2VvTEZScG9HeEUxOU1IelQrb1dxd3Q3aDdZWHo2clFwa1pFRHlVbHI1VHZVVVE3dnoyT1RoYks4VzZreC9lanR0dTdITTFOS3MzMTV2eW1VRUlrUEVIZU1aZFFNM0UwR29IcUVLc050MkhWTTQwSHlBOStNWlVRUWdnaDVIRE9zREtmVWljaGhCQnlIYWdKQ1JtRGE0Z1E4bkVjK2RWV2ZpSDJNSTUrT1lrUVFzZ0hRRFZNQ0NHRUhBZ1ZMeUV6NFlwYUNEdVhFRUlJSVlRUThrRCs2TDlicnZjVytOOS9DNzBtOG9NMFphSmJsRTJxK2pWTHM1SDJFdlRzUmhSTkE5WXhzeW5rQTlHMlVpTGplTHRpSExqRlZtODFWaE0vUXlaWUUzcDA2Nkt5K2VmMzlNak9xMGZsay9MT0hPbGdXY1hMQjViemcyVUw5Slk1MHRmUm5MZlh0ejA3QXFIVGxkZ3M2TGVaVXNnN1QyN0c4blhkcHczNmFzTHNqUXc1ektNZDhYM2Z5TjMzMStSNTI1SEFBRXB4NnRidXRJbGpxV1hVMTdVeTZDaWhlRDNkcG91VU9aMTJ1czZJYTYxUWpyUFNuMVVtT1p3aW5Ka1Npbmk1d1JGVk1IdFNTY1ZGL1hBdGZYdCt4bWZvcG4zS0RoQlE0WDVJblNDUitIR0tVZlpNcTJwRnpJd1FzaGJVbmZSaTIwam9hY2JIYVZ5ejhvckNSSHR1ZEtUd084TFdYUm5LSDVrMEZuUlJDY29uKzZZMHRNakhNVVBCOU9hZkhLQlNzMlh6OER2dlMwRVZQVTBJU2VtaFN2Q01vRm5wUEg5aHBZNTAvY3VZemNBY3FZcnFZV2ErV1N1blovV2ZxZUtrdXEwd1h6YnlTZW1Jd05sMkZabkw2dkdaV1g2djJucGRPeVlFZkJnUmViVTZydHdEcXJjb1FoWXdxNU9wTElkWmF0T1ZZTjN0YXlpQjhhWDk5RkFXQ0d6dm1jYk1zdEhyMm1PRmorZUt4c0dIOE9mM1QwbGFNZ3BNQUxRWGtRNmFPaDhseUhvYmEwVi9KaTFUTDhBa1ZYWENjSk5aWlBBYUIzWXUybm9kWE1jejVlQzVNaldEMTZObXRTYTVCc3FXaE9iZkJ6QzE1OW9ldTZEM2cwanNuclNyeXNscFc0UlhScnl1dlFXN1BWUFN6RG8xSVpsL2pzb3VWWnR5WGxzK2lON2xTajAwemdsVHFuLytrOXZqcld0M3ZxSkdMRko1ek9ySmdaL2QrVDlLdGUyT2JPYVZ5Mm8xWDN1OWJadW5HL1BQaXlWN3RSM3hDS08yalZTWFZFZEp1RTNYVTNkc2JwQXRSNmlkN05TVmszT2luVW9SdVJSVmNqMGRjcVlOZEZOVDlFcWduaWM2Rk5hRG9QWmRFclNPWHgyZ3RMSmZuUXFOK0NtZ29LL0FSY282QU0zdmI5dnlQbjVkVDl2cnZ4bWI0NmlQYXBXZE9xckt6ckZUTmpnVXBSTE1lWGhTYlp2d1d3ZVdKeElibDY1SDZ5U0U0UFE4dzZyVFcxNUVUenZxc3JYanM5QzgzNjcyUlo5cEhHbFBYaUgwM1Z0MlpETE9VWTNrYnN4NXBERm5IYzhXcm9TY3dvb0FqaFlCT0ZKSkttM1pOU1hyV1VWSzgyK2RjV1JCWjZXdU00V0VOMjVSVHpCeVAyZ1VTVXVlOVNab2VldnJTRk56RnF0RzhGWlFuUTRwZStZS0cxbTlscitncGZQU1d2bDYyOVpURndrUVhMN3F3SkxQb05kK2pnUTRVT0hTUy90QWdhak03QjVVRjVJRG1HRndjTzBjenVnYXl0WnJLblVscVhrY1dINk9FeUUvZURIZ2laTmxwRWpyK1FraE02aCttS29GZUFoeGVFbXExUTRRd09XTjlkN0dsYzVyZ2FJUnU1Z0s2Y2JVaTRjREd5UGFYeDNXWFdTZHptTHVOSWcrTUlyV3JsbjBTRnU4Tjh3RDdlNysyc3JLRVo0MWtoM2x2THQ2ZER4N3FwNzNNcXRVZXV6OHJQSnZnalhkYVdqTW9iUGZKSk4rdEFtTXV6NllYbEZadEJNOXVyMm1mcExtQ1J2Wkp2aHRTYTZ1RktIczNMUUk4Vkx4VmZQMUk2RTZRdjYveDdtSm1PZXZOc2dyR3JaT2l0WE8raGpwV3kraUgza1JaNWFrSW5mQUV6V2g5K2lpbFhxRmo5Z3hNMjJnNDAxeDRoRDFFa2ZUdklpRkloVGZOZ3RQWHhFMUhHSGtSNlZuZklKTy9ScXJsaTdiK2JvczZXWVFpcFZPYUVPVzNueUw2TnVzVndXWGtIZCsvT2pVNnBrTjZFdWNNMGVQRURLSG8wdzY1RjNpMmRwb2hqd0xsNEc2NHJQSzZtSG1hdzB6bFVhdnNSY05lMURaa0FoWDhQUG9hNUxMczJLU1huanhlZThmYmZUT1BoNGRMM1NVSS9weTJrT05qcnFzWnhwSS9xd1VLL2o5UlRBa1JzTUNxWCtFWnRyUFY1bUJTTmZOTk9YUXR0RjhQSmlvNkdCUTZiTlpiVVljTVM5dU92ZU8wQTBqWFhlVXRhakYyU2x5S21ZTUJ1TTFwNEE4c3hrcXZDNnJzWk5YeElMSmh4S2RDQ2ZJaXBuaGRCTGtRYnJoai8rQ29NR0NYM0tURHlBNzUxcnJkZUw4eUFOcHZHYWNNcDNiU3IzajE3a1NLRk81bk94azVLNWs1eG9uUkQ4UklhTDE5WVgxYW4vVFN2VnZyNFdWbldPcHpzaWJIRkxaeWdNZHJTbm1sMUo3Slc5UGYya0tPWkl2bXJjdW8zbzUrZlZ2dEt2ZjE2VVhkdHZGb3d1dStxWFc5dXR3L3RmaVptcEwrVVlmWTBhajAzaWgvVWgrQUNaZDc2dm5IQzZ5UVZPQlN5WktxM0FzQTBzN2p0WlkwdThQUDcvUDVPckhtYklLek5WLzYxYTZ5bkJiOS90SFFHVmpieFRweDZuSzlvNzc5NGEwdHUxeU5ubWtPejFDT3ZSS3F1aDFnb0wyOU16WnNOU091cUt2aHJnL1Vub3E2RXZUNnlZbDRicHZQcjlrZmRubC9iMGFuREs3SDZmbUJQMHdOTy8rME12L0toc3BFNnk3VG8rVTNlcFMwKzlINjM2VjFkVHhMc3B3cHR2dGx6ZnhpTEl2YTlmK1pKT1Znd0puRXU0SHAvMVI2dXRmS1FwUXB6bEQ1S0VXRDhVeElXdFk0WFdvSVYvbHVsZlc2blYvUkIxZkNPcG9SMVRZelJEa3M5bzBVbmRJcnlaLzRtcDlyWmtHeU5pUXo2YlhrQmd4UUdhdmQ2ME1Ha2ZrRkZaWUVGSWRrZmowQ1Y3TnptOXNydStjTVRrZS9WdlcwUXQ2VkRpMkZDZVBkOTBxbzZkT0xlOGtwVjhFdzhJTFVPM096emRBZWtzY1dkV3RXZFZidDVaWE10VlFOWXRlOTZSTk1mSjZaWSttZXdTelJPQ0JLb0FNWVBscUsrcUtMT0EyM1FvL2dIelJQZzAvMGkzcURVVzBvS0dJUjRPYTZ0cDVkdW9TRU1zOFlybm5FZU1vMjJWSGlpSTNZSmFBbmtEVXRXdlQwSVF3b0owRjgvUEZWR3BEUWk3SmdxWHB4WmpKUTlDY0pmSTRwUGNadEhTUHBPZVo0R1U2YTFZMGZLRHFFZGt5bUg5TXJQbVZhdytVMEI1L3ZONHRuZGVRNjJSTE8xa1BGQTBjcXBzak9SWkZTYk9zMGxiaFdFL3JVTVV5czlIZW02Vld2dlRPKy80UjdPWjJTNU5qck4xRjlSUlRFaXBQc3JMdmJZTlg5NHl5TktPT2p0QW4wek9LNVpYQmUzTm5reUdkTzFYb3Y1TU9ScVJ6TWE4Y05BSGJMN0tjd1JYYWNBUVh2RS9Qd2pzYXplSVplYzJZRUJLblZ3c2hNaVFTQWtaZVBsOHR0eWhuQ0gyQ0IzQkVqRnlMNDBXTkhDMWMxeElKa1hHT2srbXMwSjdSWUxpM2lHYUNMbGd3Yi9aaXhraGJ1TEF4RnZSVHFjdHVyR3JKNFQxSVhvL08vSkdaVlJaZmw5SjRYZXM5MFNDRW5NaVJUcmoxbU50SzN5c3NFQjFBdnZnRWVlME5vZlVtQlFIaE9qbUYwWGpzemk1VEVqN2hrU0E1bUNNZnJmLzhtenViY1BhejJFc3pLdzc3QUJuejU3ZTNPdTQ0OHFTT2tJbTBCbkxFWUxZMks3R3V3MGlOUVpkV1VjN1ZqWnI4SUVwN0xkZnJVeTczbTBHbmFUNWFKR0pDVWNrcEdwVmpyUVZ3ekxwR0pMYjMxRHNyNll1UU5vcjNvNFdleHd6dE9VOFQ5ZkFhUWVrTmdKVDhVQmhhdDlVUFpkc1dkT0sraXhUS0xsb21yWkQycUNoVkkxYUFMaGd0NnptcnFaTlF4d01adVgxNndQMjBrOVhvUzBSS2N4aklCc21Rc0Y1QTA4Nm4xRG01ZkVtTVNlNnlTUmx0VWhIT3ZFcjgvVkwzT0grL2hDcitDTFd6OE1nSDZleSt2b0prb0hTNklwb2xKRjJYUkFsU3BvZTRudEhLaGlyNUlHaG5MY1h5Qmtlbm5zUmVPcGY2b0NQSTBQaEpvanRZZnNzdVNObFZlalZ0MmJlajV5dWxHcG9Tck05cmJYamZyOVltemRqVzJpOVlJRzBkYmQ2aWxaMmI2MVU1bTNSU1hoUmw0R1lPajNLTWVQTXpRV0pubG00amhJeURSZXV3TXJSak5COFNiMytKMjF3d2VSQ1JYNTZhSFRicHBCdU9GaGdOaGZZMEdCbUlTQnQ2eUU1ZGJWdG1QdEtJeHQzSnZaa3h2MWY0ZzV4L2hLVDRRdWlKaEtIV1N1TVBxazBUbnRIQ254TTZJampXVzdhbnNKRThHcDYzYXVWcDA0R0d4TTYvajNqRytmZWZuY05ieFk5eTlIMk40L0RNTUt0SHBYdzlkYUhYcGJxMTBVZnlTblhYMTR0eFRTTDZKc2xqMVh2RWR1OFI1VlkrOGh5c1oxWXpCWmVVdGs3ZkNpcXk0OTkwSG9nTzlQVEY0NGUzTjA1bGRUSlpBaXJPYXJHVm04eGw4VmdoajBNcFVtOE9Lak5PbmdpajNxMldyaTJmODEzaFFYYlduOTgvZTYxWjhsaVEyTjNpcVhUSjlmbHlGR2MyYmtKNWtVQllEU1hEZytBQXo0WEJtaC9hNkJuNWJJNmMyRmRZUkhJYkpGV1B4b2dmdnhwR09vQ2laQXh3U1kyWXNoeWloOU5PSHNrRWlBYjQxUVJTV0V1YnVWN2VHVy9CSXVGd3BOUnR1bnpBcWlydW9HaDlPaUlsZWw4RDk5clF2azNqbFVIT1lLV0ZGMXFacVBIV1cvbEswRGVGZXNva1M1azU5eVdKbDZyanFldnNLVjhPdlFSWDhJT2ZDM3Vma00vZ2pMVTY4c0w0a1dVUG0zUlBFNFFVL09RT3pIZ0FVWUxIMFRMNXNnRjVMQ3V0Z21pZVhpdEMrRUhrVjR3Z1RhaXpUZnQwcFJ5NC94bXlkSmJzUjk0Ym5FeWtxYU5kdGNMKzlwNWt6ZnB4S04vU21RaEZGRG1DVVJzOG10NTd4TW81VHdnNW1TSHZhUFI1UDJVZ21jMEp1dldNNlV3VGd2ejhNTldMQnVldDhkbSt2MGxQbHZ6RmtpaVRJeDdlNjZrOVpVMmR6bWlreUtzc3N0TUsyTWU5cndCem1kOE1kQTYyZVRnUjlsaDlpVnBhcjc0RisvZUlZZWlaSW5acDlRMUt4eW5wNXJDWGJzUVYxY29vMjh2dDlmZE9wTXAxc1M0TjlMNHN5VnlNYThqNUNPMDRhdGUxYk0yMlZPNHZCa2JHT2Yva0xOV1JWUkp5UDkvM25hdmo5a2M5MzYxMjVoYVpSM1NLekJWdzE4T3lROEY3bmhVa29EMzVRS3lIV0ZiNmdpYVF2RGZyU1ZrSk5HWmJnOFZ2YTc1MVFQemxoTUhWVVNYLytvSnF0ZFhqKzR1cVpWdFgzaDcrNW1uU3laVkpmVnFTSFFDbzA2WmdPbThVckRhZ1pjNlNkT1JGdTBxdDFZdGFxc3YweG1ZTmdTYjlPME1pQktiVlFrazQxalFjZ3FYWkxDbGQ1OTlsMGhxeiszSm9VaXB2TG9SMXZZSDM5VktVK2t1a2JYa2E2bGRMT3lXVitjbHlydzdQam5CODhsMDV4V2hUM21jcGtpUmZJeHlsTytuMXRMTlRKbUxob1BTc1owS0lEMkpQdG1sVGxTZVNQanRwM1hBbXdFeFpnWG03SUpINEdqSVlrZklpNlNONWlwR3ZHR1ZMSVlYV1hrcktzV1pYalJoOVd0MWFuWVM4a09aRXhORFNycU9HV1J1K1Mwa1hYSnkvNUhTaVZvUlZ4Z3FQUUl0OWUrbGJQOU8rL0gwdHkvckgvWkttMW9iazVKdmhqUjNCQ21HWm5mTmVXZDc1NXRTdTZkWmNhbU1vR2M4S2dxcUVGU3NLWldSVlMvZDMxR3lYMUc5SzIxVlhFelYxcFd1M0JSMzhXZjRQYmFMUEJsV1YwanlZNnVBTGRYbHBQazB0VHlEYTVUTzZKVHJFcUh4dXJ5R2hoTWNSZlpDd3M0V0ZjalJsMzVaSnB1RjFlWjFPdTdaSkZ6RDJ2TFhGTmZkUVBFTmJPeWVWNFJTdEpSK1pjNzBtckNRYUgyUkNqRG1LTitYbmg2bklFeHVLU1FKUWd1ZUp6WVNsaHdhU3ZIeUVjRkowOHFFcTlMamgvbFQ3NG95QmZhbzk5b24zVGJ2WjlZWlgxalU3UGVtR1hmMWcwQytyRmZTdFN1MjREbk8xK2tJTFBjK2NtYU5seGZQdk4wT29qbi82WEE3RUkzRWZ2L2I5Y1RzR1dqcWtQSlRWVDBiUk1oa3JpekN6dDlBWnBsSk5JZmczWlZkVWFsUzBsMGZTVHIxWUx4NzBTbGswUnFpaXZkMUdQcFAzWkowNWN6OFB5NXFjWVUwUlFxNU5xeHQ3M2g4NWcxdkluMDlTUFdlMGMzWTRnenlMV1hObnhCanFEUlhSeHlDSE0yUEJyQlRZV2p6V1NnOFdONVpvZ0x2N29PMjlSY1p2QVZDVjF4aUxLNWsrSTIwcGs4NUw2YWdtQ2Jrb00rM21XYUFQQXg0WUd1N3Q4azl3WFo0ZDZUOEo2L1VWc294UnUrcjkza0J6bkRsKzVDaU11ZWI5QmdoNXBrRVcwZk9hblhiOUp2TG1qM3hhZVB4ZTlxZDJ5VG1ibjRVMTdnZkYwSkFxMEIyL2xoQVZHRktmZWcxc3QrQlFzczVZcHRxdzhubm96ZUNBMmxodmcwclhTN0psUVVtd2RYak5vSVluNkVvZ1R3YnlqdVN6MG5wU3NsZEFTNkNhU0dxck5BdDZ0S0YyUFRucGtEUkttOXF2cit5K3hqSXYrcXI5K09aM3RMT1p6aXZkT3M2TUt0bk04SXBuVGZ1bkFmYUhaRCtpdzlZalNjZ05lWCtKc3l5TTFHYm5YTVFXd1BSMUs5L3JMNlcrdnB6cTEybXZpcXljZWVldWYwSDMvbkpiZFN5VnBhamJ1QzYwd3ZuYXl6U29JTzZaSjZ0K25JcVd1YUx1ZTJHNVJWRzBtZlRQejcvL3BsaFpaZk9Ia0NBcEZTWW5QWm9IUlZQQVNUbS93cDRpdzNqRDFwN3ZyYU1nMS9QdjhiYk8xNFd5ejdoTnVDOTFKd0tMZWJobjRNNmxMNmhhMTdWMDV0ZExtN0plK3JmT1d5TENvbXpMZzJoSE9LaFhmdzBKdVMxMStpS1ZVWXpybG4zUWxyTVd6MGV4UktiVTJ0YWlrU3ljS0QzaW1oQ0NFWldVSytxY1VaN0VpbnRCVk45djRvU0YrRDBCN0ozWHpsbjBkbzdXcHZxNkZnTDJuZ3RwWktCT0Q4OC9JUGRtcFNHeFlpNUZZdmcwanNnaHpGeEVveE4zdEMxdFBOWkxXMWVkOTZlTDFhWmkxT20xL3grbExBbFVFSjNoVmJWMUlvWkVFczVwenpSS2N1OW5OMjVnZisyNnE0MW5HSm5hWUpKWGgxZDFnQjR6TXBvdUdnS08xSVhHRnF3eTJuTHE0emJlSHFrN2FzTDNtS3praDE0L2lWeVQ2QUsyeW9ta2o3UmxKamVkajFkMFBWQTUyeHVLa1BKcU1OVGcwSFpRcTVEcmMwazVaaWN2Qnc1RmdMRlI2WlduNnp3Vkk1Y2tFdVFQVHBaZXM2TTlOeXNxRWpuLzhjeXc0U1J1NkdBcFAweWxLMGtNSkNPTFUrWnlyQmdTejZnaUg0aTBmam1nYzlDZUx6d09MMEozY1c0UmRiLzdSRHozL2lneWc4elFPV2dlRHM0UVZHR2tpL2FIR3NkV25td250VFhPWXE4MS9QMEJaemJybm8vOW8xRlpvTzd2c2tDNWRYTHdlaytBUUhzZHducU5vcTFybHZHZHdiSVlDUGxVM0pmdlI2ZnZUQXBZMTBwN2lpeGhaTHB3dU1sOG9qclVlN3RpSGl1MExYcTNyVVZndFlVdUtpR2ZoMmZDSWV0MWRFMmYrVmlHOHFqaHlzOXlHS0FqTDFZdTNCVnJZSmFCRlBHNXI3eVd5UVdZdVlobVd3RXp5eGg5VzlMeWhPNjB5TTY0bDRFNmU0ZHpsNjhhM3lLZG44QlBNU1Z3cTZoZFBIc1ZyNW9CVmp0WFBsWEl6YjlIUUxWTEhzTXN3YlRTQk9qTi82Q0Z6RmdJV1FMNmFrR2RuZ3podlJHRTBMNHY0SGxYaEV5blkzTE5mczJGQkRqeUIxa2Z6cC80WGxFQ25NM2s0SGN5STFXZE9qMjE5MnExWSsyOFJiRlBIZmVxRVBsWXJOOE5Vcjd2aWE1UGFZZWt0aXdqZTUxTXF4b1JIZEhoOU41MS9xMExmWjBQUWJ0ajdicDJwOXF4TlFnbDJYWDJNUHFVQ0dtYlYwZHYzNDlRbEdhMVhqMnFITEh4bG41NGs1dS95dnRITzNPRW0vMVRuMXo5OTRIaWRPVEdwV2xJZllUVEdUR3o3TWNlRTdVblBmbHdJajlLemMwZnhVM29WVjc5SzlrUjBuV1BWbzVybW1iNzVkUzZUbnp0S0NtRURQbC8rN2FVWWtiWnl5dGRwWk4vdjVDS2tqdXZTZGQ3cGNGcnZJcHlQaVg5NWFnUm15WTJSOGlXNGh6WDVOUVg5dkNzWkRYLzFmM2VLN1dGTENNNzUwdm5kUzFQa1RMdEdsRzJkVFNMSy8vbzljMlh1Nld2bFJaUmNXM1R0OGZxRFRmcHBHdnRkZlFycEY0NnErNVM3T08yREM4ZGtqNHNHelI3d3BwRjBpU3hQQVR3Zks4SllMUkVvd1RPRjdBdXphTHhtQmxaSW9Uc3NTS2tvK2JVa0w2dGpsTkhPUkdrT2tkVWhWakJLOTFvRUVoN0R1cmxlMTNydVZHdkxVbTRqdDVucE84aTZiMXpWaDB6M0dCQ3BKQktPOGMwSXNhUHRvNGpqNFVrZWtKLzVDR2drMm5FZWVuVi9pdWZVYmQxUkM3bnhzRDY4ZmRmQVFaNGpmMjdMemRNS3pSR0RaTmtsS1dOb3pjK013Mk83TlFOUmtuTjI4L0s0Yzg0dzhKZm96Ky81NVAzbUZVV1o2a01UeFZhK2J6eldob3RaaCtjV1ZTeGYwRjlrdGtUbHB6RHFBK0s1a3NkK1dlWkViU2ZkMmo2eUlvcEkyVW1vWnlvdStPVmI1VTlLL2I5V0hMd210VFo3T1JockhucmhTS2tOTHRIbUNuT0RLK04zQURVb0Y1QXBDcnRPUXBxUm96b3dzZUFQTk93T3YvRCtaTUltVUZ4anNtaFdINnhGeFlsSHc0YWNFQ3NjcTdqT1J3WXhJbFVWWUxIWHY1cjhaS0NkNU53SDNSUGFJQVc0cnIzN2ZrTlpCTHMxRGtzWEVxanp6dklEZmdhN0VyL0xqTWt0TmxXUytRQ1hKK0pWbmZFS3l2bTFicXE4bnI1eDdtTnNpc3pldCtSOUt2Q2oxcGZvbzhZTEE2SUFKUERVUFdROU9iTUt1TnRSam16bmtBVDhrT2ZGcExTbitDVC9WM0ErVUV5V3IxZnhLNGdxMmhuL2twcmloQnlETE5kMWJNMDFmSjQ1QW1xLy9IYzlaRUcrU3hRQjJKRkhiM3BYbkFORVpVamdpMnJMUDhlUDlENytWbHovdTluTGFGZlUyVEFUMGZqcll6TDJrencvN3REKzQwd1JSNXhlTC9XNlcxS09zWUhIMjEyZDFjVFFqNkQxV2JFMVFTRDlpajI0U3lQd1pCN1FoOTFDYXZGN2M1VENZNGZoNXNjQ2VxcXRYQ2VIb0QxaXVMTkRZay8ra3Vid2lsYVZlUXYxaHZuaStaSjlNZVVwMDVWcVhJdEdOZnpnQ2NEMS8vK1U4QTIyTVdvdDBOeGNCTTRrUDFvVzQxSWZTcFpleVc1TXFGSDFpRmk1YnJEcm5XcWQ5MFN2TDExdjA1bitiaFliY2dKVXdhZVlKYlN6WDRFMDdZaG1oNUltdG8rYS9FZWtzcjNYYXIvWnFjUlplWjlDVG5sWEJTd0l0cGdSV3dpR2lJMnFENHkrbENUd3V4MjRwUDl5OHNtVXVUSHFTbEZ3M0JaMENtNSt1djNpNnAxM1ZGYlJ0YVo3eS9WMVhXL3ZwejZlMkticitqdG5rdWszT3djVytlelUzZlU5aU96Y0diekxoMkN0bHBuek9LdnBaS0VBbWZKcHhtTlJkc1N0YXZJWVFCaE84Z0xRdk83b2NJczF4VmJ3TjdFQWlkZUNVeFFMVzM3OWRVVzcydWwwYStadnZKWTZYWmZndTN3UVlzWEFmZWtvelo3bXZOUVhLTjFITkFaMlJ5WG1INjI1blZVdlBhSVk2a0hTbHBzd2hKQ1ZEUzExRjZQbG1lVjJWNzMyakJDajV4Q2RENmt0aEhRTWlJeHZaRjBNOHBFQmpRTDZiWHJ5VWlibmJvalpiZnBNNUNlRUlrampaclpQdmJzdElRY0NtcDVhTmVRQjJXZ1phRTlOMEt5aHplUG1yRW9ld1ZKVDc2bzM1dVVZNjI4aUZYckdSTE5ZY1QzZG0yZHJLYzMyK1RFYWxJODVMbENaVVhWa3pZU3ZlbXNQQjR6eldzMFBobTVMNnBoQmE4VHdlVk9Ib3ltOHBGOEtibWg0amZTTWVmaE5MeWwzU3NxTEZxVmY1UXIrUEdNUEFwRHpVU3lqR2xoajR3bDZSSFA1Q0VnTWZNTW5BK0FQRFVlbmFkSUhmWDVSK00rekVtMzVKOUVDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUl3Si9mUDYxOU5iSzlTUmUzMDNnMjlUeVlQQmQ2ZjBYZnU5TndOTStHbnUyV3BieGVZM3AzWlhsdFVPY2swM1pKa0hhTWIvTkkxOGpCZUZzclJiWlVtcmFGekVQd3RnR1IwclNnSDdkUWtsbms1TytHMHJHdnFzR012VmFpTzQvV2VUelFuV08xTDRwWTlTRmIzbGpwZXZZNlM1MWxSWGQvUlhmbEZiU0cyb2NSWW9LcHdQZUgzS2RVdnQ2eVNBOStQTWlOUzJucjZ4RjlSTjBrMDJsUEZxQkkxSDRrRHdaVnphVTk0ZTBTSHJFQmtES3lrUTRyN2J1VTF4ZFNVWjNmdDBwK1ZXY1JhbWpPL2FUSjcweXBhV08wcjdWMDdkK3Z2SkZ4OWRLaEhDRjlrUHQ2TnRvcVJWYVdOcE9pOXBPNnFYamVIbit2QzdBeFh1SG85UWh0QjBqWDZ6cG9FMTJXRVduUk02ejFtb0ZDRVUyaTNRYzJXaGN1QlJvUnBmVVRjOU1xeTMvMHZxanFNWkovOTZYeWFBZEVwS1Ezc3RxeGNyNUVCQjVxSjNnMm0xMk9wbTJ0eHc2ZXp4M1ZKVWtwdndlS1owTEcwTmJ2aU4wWnJWTzdMdFZ2bFpXVjgvVnhCQzlQT1VNQWdjODBMbFUzRWd6emlJWURJcE1yQ1dYazVOZmgrU3FFb09FY1ZCQmJjOUdhajlhODU3d2xoK0ZOK0pFeVUxTldUekRKZXBtZzlkVWl2aHVhVGtsU0d4dmhMNmhHK2xieWd6WFBVY3ZmNXZHdTV4VHp2VkVGSERFQ1BNdTNTVmVTMGhhanpsMjFlWmNrR1ZYKzJqWnhnZTJOeGl0Tjd5cEVWcGJWQmtzbGF1Y2pqN2ZiODlHeU5Zcnd0MlNDSXBKR2k2bDQrUjZGTjBHOUdEN2lTSkxyb2kycVdXWkVSSEJwNmJ5Rkt3a3F6cjhRSytJNjBXSHVPZDlPTVE2N2dqYkFsZ25JVHB5S3RjWjY3YXRrbFBtVkRqSFpIYk1aVmZuazVxQVBOUko0UGxCbFMwUlBhWDRFR2lLOHpYeWZZZE41NWQxY09QQ0xxWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hCT0xuaTZuSVBnSENUM1JuL1NLWWZDWUgvSUxiMjRDa1RxTmRSeG1lemptUXh0djZETjBoVjBrM3N0TkJ6K1pMRkFVZlRMdVl1RldMejhpQzBMYm44ZklXTEpsRlVmNnU4WFpNdEVzR2QrNThYME9VU00rRTdMc0xPWDkxR05wdTNoRFFicjZ2eXB6ejFsWjJiWjVvWFVrNUg5bHZTaXN5MmllMlJyTHVNRGRYWDErTGU1MHZnNW9MNldsMFo2eGI2RkJrcVk1czhVZERBeU15cVJReGhXN0VlYXY1UytKb3FyKzlycEtCd3J6dHVDMGRxSldCdEtldVViK1JrdVMyNU4yMVYwbjJLdHJ0UHBmTjVDSi92NVQ2OTh1cTdkZFZYMTlRZlozZjYwSnZiN3ZrbkcrMzBtMlBVOUtsU0M4Um0wZkxTOGRuRmpOMGdXWlZhajZNTzNvL2lZdHRNR0tOai9wLzNqYXVJL2s5UjQ2SytYSkk4M2JVVHloZ2ZXMlpYMnRNcWV6OXNkSzhMYWQ0amJVcVMyMGhJR1gzaDFCSGxzdHR2NzZxMXVGYzcvanF4eTVQOUw2dHRzTmxkUW9ETSs0aDZmWWVQWnl4SmlTOUppa3RRbFEwamxnWlZpU01FSUtEZW9ldmF6TWtrYmQrcGV1ZWFaWlNMTWJpWFVlODRDVjRsZlVZTFNpOVpVVHQ1b2h5OGRLZ3dXSXRmUUh5b3E2MmQ1M2NneEYvc0FTUHZmTXZFS0dKeWhadjNxSytOeUc3eFlKT3NpaklwRVFGTktJVTJyK2JQRHRmcyttSHJEd1gzeFZYbWpLMWhTMGQvK3Vra3hoZDNEMStOQ3JjdERuVW5vKzJwUzVyVnJwQXZuWWFvZmFTK2xBRGF3MVNGWHFNMUtYaGpacW5iaEc3MzZOWEt2MmpsS01kajlSTkZWdWhUU3JFVVNTZmh5YXdacFFiU1lNR0kxTFNoVUUwNlBKQWVxeUkrbGhMV3dMbm8yMUNuKzVURkFsRTNRVEpJQmw5ZkVJMklFK3FrcEttUFNpZWUxVGs5TG1Ld1lucnREcWh2WS9RYTl1UkQwY2IrQVd5SVlOVlMrTEtZOFNyL1doV1B0TjRpRERnRjFNSklZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdqRUgzbGZwOGY4dHBtTUVObEJCd1Q1eGY2a3F0d2R6YWFBN3NvYjNTVFAybWtsSmVnakhGcFRadlF0dVJEb0RoeVI3VENlU3UrV1dGSVp4c2Fsa1NxMFlpTTdOWTRQdjdkRjFDdk56SDI0Mmp1TzdtWmFrdHByMmxaSkNPK3Z0c3hlVE1nZU5GZmJweWJycDNhZjQ0bG9vQnc4WDEvL204THJGNnpmY2xOblpJZFY3L3h0aU5xSlVWdW9OKzhkc1VTaWxyejhKdTJSeHQ0R216UXBia3FQQ1BYRU03elZwQ2RVME5sWGhEemJhN3JmVk91UzhqNG5SMUxrNi91VXVmcHYybjN0TklTMjVwc3lpOU1XYkVWSHQ0S3U4MWwxby9Uc3FxL05KU2w5VnY0bUVyMitpWlNuTHROYXJXcCt3UENxemZ1dUZUZHl3ejJkZ1VCRmZGbXN1UXRNVi9IOGlIVE96cmJacFRuZXAydDl1T2JhMy9QUitkZWorMHFKblc5QnYyNWFpcDdIU29zMTRwVlJ6Njk5R1ZaTjE3bjRTL2ZGaE5zUm1BMHdRK3RHTmpMWDhoUWxqNWVlRUxJR3piSkhKVitQWFRsaVZsbnRGVEhVcTVadnV0eEJuMmtnQmtqVVhwN1oyYjNwZStPU2lPM3YyRjlRM2RvampiYXVwRnluVzN0dm92TzNaNzU3NnhhWnoyM2RXb0JaQXpYTUNGR1pvUVJhdklsdDVhdlRSeFpQVTllWFA2amxrN0lXK1hDM2ppMi92NnJiNUZYR1A4MXgwaXB0cmsyM2VDcG1HaDdSY2UvSjd4a1d4VW5meERla2NkNEZqNVE2YzFPeTF6UUR0RWVqeDJjdzQ2bURkeCthNUxDZWxrbXJUanR2dFFWVjlZOUM2OXo2T0pKZnUwNWI1eHA0Zm5GVUVJMzR3Um85QzFlQ2MwNWxSZmlpMTRwQTh5Rmk2ZkhpeGhzY2JlQ3ZZSUE4RE8zWmptVGIxTzdTMTZIeUtNNXlmMTdueTA5Rkd4V1E1Zlp4V3BBM3lFTU5MYzdzQ0dRMFhLZDU0aGFleVVNbUVmRWJQZ3grTVpVUVFnZ2hENE9STkVJSUlZUWNBNjBPUXViQXRVUUlJUWFaVXBJUVFzaUpQRlVOVWYwU1FnaTVBdFJIaEpBQUZCbUVFRUlJSVd1Z25VWHVCT2N6NlNILzU3Ly9VK3h0ZTc3UC8vay8vQTByYVlqczRqcTVTbXNYR0hUVFhvMFZteEs5NmQwa3NXZW5VYVhxSTNhRUpoY2dPdUN2dEJ4d241RmR4clJkVGpxcjdrbWZ3ZXZIVGdWUHV2ZnMvZFhiMmMxV1NXb3lLOTJzYmFlUmRKYldhemxnVktkTXFzZ091WCsvUkZlcW85dzBKNnJWSW5YWDlTQ3BIc0tJSVRIYWVVODFYclQ3RGRxVE02U1pWUlhOakUvRU1TZ2prMmFqbG90eW9RYzdqbUdmYjhsS0RSRW5iTlRyL0Q0ZitYSnEvbCticEJTL0RiOWZmRzJSMjVEY2RHYXJtanpvT0VmVHQvbWt2TDFsRWcrdlo3MlpaYzFhZENXNUtnN1JnWU0rMmhEZWpWcWRSaTVOei94R3YzclFmc1F6b25YYU1uWnViVVFGekRidU5CKzcvVkpIY2NybytRS3JWM2Vrek4yZ3JGaTRTdWRIMjZ0T0FFOVlKaUhkWEYxZmhMS1A5aWU4ZFZ5bm9iZ201RmdpZXJaWGRpQ1MwYXNEbFEyMmR3anErazRWR0dKVzU2NWcxU0NnZFV0NVZ6elM4TnhkVE0yU0p4RUpVNjBJKzBSRGFraVpoRXpERS80ekhuS04xQUV1elB5VHJqaGx2LzIvSkp5dkRRbk56eXY3T3NWMFlpT0ZzaEY2Zk00ZW9JY2F5YzZmd0xSb0hWNlpFNStyN0F4SnBleUpReEJSVHluNXRubVBHbHBKMUd6dTdkb1JjeE5WdDBqY0l5b1Jic09vZitUWjl1UWVoQno3MUNjOFJueFJWQTA5Rk5TU0c2MWpSU2hpaGQ2NVBhTW1IZGZRSWJpeDRHQ010SDFNbHFWRmxHTnRVTEtScDNGZ25BdjFtK3BycTU5cGtQUlkzY0JmbTVKSFFhRkhDQ0hrdVZBTEVrTGlVSElRUWdnaGhNeUY5dFZDcnZEbDBFZTlnWGYzR2draGQ0Q3k0eUZ3b0FraGhKQU9xRUF4MkUrRUVFSUlJWVFRR1hvTGhCRHlUZjdQZi84ZnREL0FuLytiejl0T2lweEx6OVlxazZzZTJaQ2s1Y0RtLzRKc1JWQ0RibDhUdUFsMEY3bUpWWkl6aU82d3dRSEhXYm1sZWJEcVNKWElNRjUzbUtPZDNxWXBnV093NmwwMXpkWkpvVGFnekpoTW8vdlpCQ2xJVzBidnh4dmZ2MmRXenU3MmE2MFVtU0pSRzhoQ0h1WjlYVThuMk9jak8yQnBWU2FuYkE3VnpiamtnSG8yZ3BWbXEwT3lvRk55b3dQNitTbjd4NDVvZjB1amZ0SHVkUkxZN2pIbmJSMzQzbldXd08xSkorV0o3TjBuMVJHcHU0RHB5Q2dyUklLbU8wcjdoektsM0pubG01WFhsSFZYYmhzSlU0TG4vMkx0Wm1yWmVLVlhESnRickRaNnlkTlRQVjhqOWVxc3o5ZVlDalhGMmhLOXJ4bjNHVzZMTjdBUjRZRTZZZWg1T1pXV2NtYXY5WXJNaUlxZ1dDWmtMcDZFcWNuQTlRTFUxY1BzT0VkV1RtelViUFZIbDRxNWtzRHFkUXRIQjAycnczSTVFYlhiVTZkV0IrcWJhSDNvNFNsaWNoODhJVGxTbm9RM2owZE1XRUtXMGFNY1Z0YlpwdEhTWlQrYmxOVmR4NEN2dlJ4RVVSM3BsVVg5WHF0TjBUa1ZEZGg0UWhReE9KU2EzclpwRS9lWXlPZ29JdjVEblhhMVNlelZnYzRnTC84S3Q0RHFkd0IwY3RIbXVRZW8zcDJwcnFJTG1ITnNCK3FxMU5kVEdwT1puanVVVWw4WUlGSW5wNEFEYWtpd0kwOEJmbXRGaUtkYTVaVW1IN0pvZW0wODhoRFFFRU5IVVROQ3hMUDhvTWZPODZqTDdaMi9FZnhpS2lHRUVFSWV5aG5XSGQxT1FnZ2hoQkJDb3RDS0p1UUR1Y0xYUys4Tys1Z1FRbUFvTVFraGhCQkNDQ0dFSEFhZFVFSklCeFFkaEJCQ0NQbFU4bi8rK3ovU0hxc1YzNWYvL0o5LzlzbFdieHRGcmdteWU4K2liY1VpUlk3dVl0Tk5UNlV6dHJkeG1yS29DbkpWMEEwYVgyazRBWHpRUG9yc2hqRkliMUhJeGh2SFRvbm9maTRKdU40NXNYZGJJTDNPTjd0K0RuM3RwSGVyOC9aOFVxNUxkYUJsZG03dFBuV3IwVDREdytwUjZXdDNNNkFvTmVpWnRzbkl3ODZPVTRZdWZ4R1Z2ak50ZFhKaEluYm1jaERoRVBVTTVlTVNVSGJmWDFSTlRUbTZQaXI3cEhwTi8ydUxsRktYcWR4MWswNUlvVlFhMGNPYW9FYnJST3dQU3hsWTU3MkpTaEMwSHRmU1JFRjFnVFpUdExXam1mS3ZhOFVTSGFPTlFxZjFUUHNaTmVYSllVUThzWjZ5dEFSZjgxdW84NTNNczlIYk1tY3UvSlZmRWtXL1l0cHlSTjA5NWYxRit6ck42QmRtTjJYM0JMQzhOTnIxbUQ3dXNlaG1NVkozajZWRENQa2xLakc2MUpHVEY1R0lYdFExZ1dWSHBPL2hYRTJBOWRyc1NMa3A0UzVwQXRLUDFCMjl6MUgzVnpNY3lUV0lyc09aNjNaMldTVjQzcXFiYzVVTU16TEJSeWUwRjB6UzhKUkZWVVRwRlJxNXFjS3pkcHBnaEZsMjB1dUM2VlgreUJqTUtsdTczckpDVVBjS1IyVWNTNkFxb0FrUm56cGkrbmpuclRJamJVb3BObXJLU2hHdkp5UHRQMFlaVW5ranM5cnpTV2JOdUVlQ1RxS090VVZPWUpYS0dLbWpOeGpSNW8wSXJJZUF5cjRWeS9VSUs0STRSQXdQeFVRbjU0RU9YMjR1dkI5aEpxUFFZTjJjRGcvQmN6MjlCdzZCb3IwcUkxaDVldHhDcE55UEltckxVemZ3aTZtRUVFSUlJY2Z6TUxlVFhqWWhoSkNIY1FuVlIvMUxDQ0dFa0J0QjA0WVFRc2dsb0VJaWhCQkNUb0FLbUJCQ0NDR0VFRUlJT1FKNjRLU0hQOS8vdkg2V0svMW1PVytUcERSbjZ3M3l1U0RTWnRJY0dkM3B6RW9mU1hzYTNuWnd4YytXamV4dFd2TEJqR3c1RWRrNDgrNFR4bG84M3E0bXZXVU9iTkhvN1R5Q2NyMk5PU0xiVGtuWHRXUGdUcU03eXBwZmVkRUcwdHNoTmpLcHRMcEtJSzkwSHUxclphc29xU252dmtwR1lqRkJkYmE4cTl1T1pxNmFVSVM4YTRSWEJxNDlRczlLUzZ2dGdKNWQ1TFRyTkY2NmFMc1NtYU5lVi8vYkhFZHNkUTdqamJpVUlkRnJROVJwdE9QNlN0N29sdS81L1ZzSHJuZnl6MzlyTFpmTXJ6MjJYMEY5MWJ2OWlGb0JiSm5XL21qUGUzbTBHSktXWGtvWGJRUGkzWHBsWHNQYS9SUlc5SlkwV2hiV1ROdnRZdHJtZlptcVdTOUxyTkFpdWlWbGp5MFRWWkpXbmVRVVpxd2QwQk16UmFpbVZ6UTM5bjNlRTlPZXF5MDJ2am1wVnQ0eGdiVThhSmxJT3ZScnBaWVNsK3BxajYwNkN0b21SUmlVcUg2RkdxRmNYNmR2MVNsbXBLOUJvaUtvNytLVlRYRk1TQXhVY2lBeEIrMjh0MDRSbVdIbFFlM2JGTXh6T0pCdWI3QUdJU1hmZmtiYm81WFYwNUZlaUFDeDNZTmhkUFc2ZG94YzgyeTNwRnhIWEdseUhyMStJWUltdUViODNkbHdMcEpseE9LMm1HZUF4amg3TEkrVW9ETGRyTTdDclorUGF3R0hyQjc4NXYyNjlDcWcvZDVqejhMMjR0Q3pnMndJbnJDTTFPMFpVRjQ1QThJeXYvK0QyVHhtT1RhV0dZU3NzUFo2T3dJRnlPT2Q5OHpKaUNxczAwaXpBalVMLzFYT0kvY3ZyVHBKNVd2cHZldnRlZW5hclJpeGZiUko0M1VZYmFGcjBtdEdvQ29oUWxUdG9NTGlBZlNHRUY2czdMWlpvWWk2TE5LSlozaFFUaS9IZXRUdWdjNzk5M0Eyait4NmlJVDR5QTNwMGNQZ0pJbEdJcXo4a3IwL0VJbTQvN3kvUW96MHcrQVhVOGtqb0pJbmhId2NGRnlFZE1MRlF3Z2hoQkJDQ0NIa0FlUm4rci8wK2draEVTZ3pEdVRNenVaQUUwSUlJZVNXME1naGhCQkNuZ1ExUHlHRUVFSStsWjh2cGdJN2NCV2FQT1NIRTNmOWlQeW9mT1ZHb21MbWVpdUJJeW8zOHVTbVNZUk00UW03T2xpTFo4YjlGK2ZZTzY4a1E5YTZKcWJRSnMxaGRNL0V5UDR2SmRsN3UzamJtYUJONnRtREUwMi9VdXZOb0lST2QzMzVwa0tidDdrNmM2YnVPM1l0WFF4cGNDTGJNVWxsSVFMcnFWaDlaMTF2a2gwTmgrK0RRYlpDcmxteS9hYW10MGZLYU0vTFc1dEpYejl0enhYaHIxQ2JtbXp0UjlTUU1sbzFpN2RrbGpNYUdaTkJJM2dvYjhTQ0psZEFFaWxSaVRCb2htSWd4dURxZGxEWlhwcnU0VUhFVm1VL1N4L1I5STUzNTZOQkJnUjNwOWdGRTNobW1XNm5WY2VXQWtjSFk2Uk5ZWjA0QXRxR21PUnVaWDkwNTk3VWtiN0g5YVRZSmVRNnJQQXdFQjdoVlh5Q1VGeFI5Nnd5bzVQVGU2U3g0dGtWSHlvL2p6SjRQbUpnUmR0QXlHVTRJazU1SWQ1TmJqMmovSHRhekJSWjZEMXgyZGxXM295QW5SdmdTREdzQnlyb000M29kU0dwUkI0cmVxVHFGZms4SWlNUmZZc0REYlZaNTN2ZVpsbTFTa3RIWFIvTnloQWF1U2VyellnakZ0dU4vY1BlTU1jWmp4cFhsTlhLNjF2TDd4bEVIekN3TTZjeHczS2ZuYituTGs0SkluTEN4T0JjbkVEVUdkT09iendZZjdhSEs1NW1rRWN5NldWazdkM25ub0RMTW9TNHJQSk9zdy95bVdld2IwZmwxcVg2bVBpc1VGU1QxdkhIa1FldnQra3UwSWVhbURxMmFlaGJGQWlhZG5pVnFSM1hlUXRXUlZjblNYVmFsdVVSSTlGN1E5NERMZXowTEpDWFU3OUhmWHUvZWZmaklrVGg0blNvNmZzeFUrWmw0Umg1TUVxanhTU0RhUXFRMTFzNWlKUjc3RnE1QThpYXU5d0FqK3ZodlM2eDZ2QkxrL0xrbngreUZPTkhLcm42c1V0WjhtdTdIaWMwQjgvUHhocmY5andsejJ3OFhURExOT2g2RnM5aEp4ZWhad3JDb1VYQjRaZCtuQ29XaWpZQ3FIT2I2ZVJGOTlLVm8zcFNLcWYrMGFuMVk5VXNPVFZmRjFOL2U3enNucDg3TXhhQlN2LysrejdLaW1qcjlHSU9oSkR6c1NTTHQyNmpVc3FTbkxNZkU4eVRvQi9LVlc1NGxpblRxNGExUnhxbS9WV2xROXJVazVjOEUxUkllZ0xacTRPR0Zya0VzNExlSGMrazFicWtNcjMwUDJsUnYvaWRyamxYS3NXVHJmY0ltMkNFbU9hZjVuZ0ZNd3dKN3drWmFqSE9yTHUrWGxQc1pLaEJHYWx5b0l1UDlxMW5yYndaUkV5NDN2aTY5MFRIcWh2Rk15Tm4xdld4MEthNUY3MXFXTXNUOFFlbHNpUEJDTFN1U0JrM1ozVDV6cklFVWhvWEk1cE9TTTM1SXB4L3JQeU93dGpLSmZBczkrUzRRenQzaVdOSFpwR2Q0d2xGUm5WRlR4Tm12VkpBRkc2c2VKc2Zwa29tQnlFS3BmUGFvcXBQbTYwdks4ZGFPcWdCVTV4ajdSeVFMQ3JEdVBwdndzaEFjaExZZUlHaWlZYkQ2SHFXeEpSZjI0d2JXRDJKZW5xbVU0aSt6eVA1Uy9ENENLSjFkclR4b052QzFHN2t3YkIwUEFhZk82UytEdWlOZmxKZmZSUG9CKzhCYU84S2lRd0ZoKzJtZUY4Snd3dEtZeURXVDZ3T1g3ZjQwdjlkaG1KdXRUODBsY3lPTlQ5RzlVRGZVT2w5ZFNMeVVvODBycFoxd0JEb2FqeTNDRDN2WWEyd29yMXp0OEtPb0FJako3T2JndFhpT0Z3Tlp5WHoyUTdSRWJxeW5DQThTbFNmcnZWN01jYnJQSFVxcGQ5cFRqK2ZrUE5CVEx4ZXp5T2Fic1dUOUN0STdTV2dqc0ZWYnZqb1J4bzllYnh3aDFjTzNXU0NNaUpVRVVOS0Mvc2tNQzFTTnlFd0t4VEE2a1ZrbEFVYlBRSGxzQWs2Tk1HSXIxTk5ZQzVyamJtcVFocU5acTU2cGhHd1BLUDJGU0tmUy90SCsxQkRQaTBsT1lvWjV0WUtSbWNZV3E0a09ZcHdmUVp0WFk5V3Y3MmhRdTBINWVSY2VzZXo5enFhRjFFSlBYTnBsWkQ0RUhxSForWXlQa3BYUnQ2Z29EaHlRQU9WN01nbFdDSXdXd2xlNlJTN2VUZXNnZkhqY0pNdkVPVVFuQ3lqSG1ray9CYUZPbU9BbXdxTlAvdlovN3JUbzBNRGhQaTBzL1VxWlVWaWdidjBhQjZwRENWZmNiSWg1eU5Ob3NRZ2o2WkhtQ3hlTk40T1dNY3dVMUxQU2lmbEtmYjV2UHZGU0xMTFhER3drVW1HdGtIcnM4NzJSNm9jNnFKYy9iZFUvOVZTbjJlOXoxRDFId2s2emxvSHRhNkk1WVJOTmVZK0NIVDVLdjNEcmlWaE1waW1WQytpNVBQazd5L3I3SWkvK2tYNm9XcDcvbmN0T2F1cWVXbG45dzVQY3h4Qi85THJ5R095V2FGTHp4N1Q2dkJlMEVIcUpFZGpyUUkwcEJLMVlNMDZjN09tWnB2eU01UXBGVEw1UzdZdmxjMGZ0aHB1SDZRTzZaa2N2UTVXZ2loQjdhdWx1Yk9PS0cyZGtYSzB1c1h6VWY5K1ZUd2kwb2IyR05YeE1sY1FmN1hWMGRzYkZPT0VYSjllYjZoSGRhSWhNOHFPaWw2VjZMbTlXcnBJSGQ1NXI1eTJMV2pkcllJaXhLTFg2ZTVaSTIzK28rY3BFdndtWkJyUllGSlUrTS93UmlZdEJESDI3N1VKOVJONzhNcWE0WlcxOXpmYWZpUS9PSDdTbDI1N3E5WnUwMHEvbUJWMjg2d25Ha2N3c29xbHZNVzQza3NHejVFS0JvdXV5NmM0NFN1Q0VhdUV4RTFZWWJtMDVmV0dPMmExaFFCNEhhYjVudlJOVDJQalJTbjZGMTVMd2ZGanVPNUJqTVRLWHY5MlRwSWp3dEJlWFo5aVBwMEM0bFBmV0VmOFNZU1FXeEFOU3hmbk9GbzNJYVRoUktPaHJ2cTZ0c3ZNVmkyOFMrMmxGWElaMEVEZGJEUzlTNTBJVWdMWFNrY1pST1UxWDBmRUdyditJYUE2Y1BNcmw1L1pkZGdrUVNNMmxyYm9hYXdrcU9hdHFsM3BTMHdkVGRnaUZjMGE0QUttYVRWdXoyc2tOT3JPWnVZMFZsZHpzWS9OYTdQbDFvenlxSENKZzZuWkJOWDNrVlBxQ2h0ZVJIOThTajRXYTAxRjR1NWVlWVNRTVZhNFJ5dTlvZFhweVljeU9wSHAycEllb2k4UG9QbWlkZmUrVkk4d0kvaE5pTXBvTUdsR0hEcWFMenZYRzZSWS85ZGg3UmZUV3Vsam9uQ0t2a2xmOUV2d2VhU3FsQTZWdjVHWmVOYTdCRFB5VTZVUnNwZ3JxYldaajdNanYxYWgvU3p5eVRIZzZIdDBISDV5VjNaN3hHcnBsUFBSeGNHMVJGUXU4bHNDTWhsUDJXcWJnRVFWOVFmeGgxT09oSkYrNm43aUlyRjJsRW5LdGZvNEs5ZFZyUHZXdGk3ell0VFJyZHpLTnEzMEtqYTZxc1AzVHo0TER2QjZJait1MHM0N0FrdTduSjJxSmRuZ3M4SW1pQXBMNjBjbEdyMVJPSy91U01qL0oyMzRwZFhzdEFrdG96UmxSTFNpVmE2UjNpcW0vZUpMMGNxTTdLMGpqNGV2ODR0WlV4Uk43MUxVVm5oTGlaMkZnOXFOZ1dVZURyWTU5Sml5NUFaaytPU0VTaXg5SFBseDZoeCtXMU4vSVhWZk54ekFmcHNRM3hlS1pFZG83d3I5YjU0Ni9kZngzOFR3UWtOV3NPWjFJK21sT2xDcGdYcTZCV2dENlVHeUpqM3IyRkpIa3VvcXhubTRnU3ZzQzlTYzdqV3pyYnJJTS9FV2w1YmVvbDBiYmF5aFp5Rjc3QlowNHhkNlh5c1ZkV0RqYTQvK1NGVDdGYnYxQTFpdDdtaGJTa1J3b1dXRGZidWpSejlMc1ljRUhMZXMwOTJSQ0VOU1dpUlpQcEkxMHR2VGhCQU1TNUpvRVZDTjBYWExkV3pRMnptOWFpZWlPbGNNb0ZlSDV3NWJaYUYxbytvMWV0K1cvMFBPWTViaDRSazdrYkswNjBqZHIyUE41OWJtY1FUT1h6S2QwY0ROU2tzaU91R1ZoWXZFK3Q5K2NkcWZ0NDdWY2xjcWFPOThwTXlabG1GcjFIaktIU2xIT203VFZ1ZVJ4eW1iODNZYnc2R0lKS3VBU0c5R0l4RWpaYy9JaDk3dmlqQWR5cWpxakppUnZiUCs4bmdER3hWVHQrMm9oNEV1aURiUGlKRHM0V0h6ek92U3FLdWlMZGY2K3VnUWVxRUlpZGJha0s1TFpUeGU3QnloZU1rdzNhS3lXYmlxTFJ0WUNJKzFmWjdPQ2U0ZzZtbGJWYU5FdzVDUG9jZGhSQjI5bS9EenhWVE5kQ0VFNUVsVDVxVVVjbk44SW0yVGFxTFBnc2lId3dFbEZaSnMwR1RGMmxha1pFdXFDMUFHci9lbS9YU1c2c0FMejVlS3oyamxDVkFmRVFWT2pROW05NE9TemNVMFJ4cU9STyswNDVwSUcyZTBKWm83bnIvTlU5TG9LcHY1dHV3b2lQMDRxNjRaandUNFdPRTBWaWdYOUVVUktqWnlOUUlpYU5yMHZVQnM5T081d3BkaFZaMnJCY1B2cGU4aWR4VU5JWEY1RUxJR1d0MWtHZ3p3a2lzekl5U3p5amlKdktYbXRRSDF3YmxXeVNtZ2t4MmR5RE9aNU1WOCthUnBYOWJJbTY4dVZNQ1hJUExMSENRN0VDS2ZyWlptbHRlYjE4dDN3ZGNNQ1NGSDRQMlMwVXJyblo4QlZiSElxT1ZYWDc5cTkzTFlENFNkdllSdW02M1l4Mm9GSEVjeWl3bVBXbnMyS3lDVFFCeS9PcTI3RWRUOStMTTlkRnhmeXpnbTVDK0QwUlB2UjVSSW52WThtaitFdEZWTXZZTUJtcjgwLzNycGpMU2EvQ0xrQzAyUmxTWk5VZkxjZlRKSjk5MEtGMVF3SWVuYXZnYjd0OGVvM0E1amVlZkxxdFFjdFhxMFNTUWRhM1dqbll4TTdMcnNnRllac25sUW9SN2RNaUNpNmJ3eTBiS0FEc2hWMzI2NlhydFA5SDY5YTNySzEvemUvMWhuRFphL1FQTzVBMGtmc1FQM29QYmt3cXFqMXptTUh3WnNFdFNUY0ZiMEpHcER2TkpFSGdGaHVsRFRLVnJwWFhRb2kvZVhVbUcxT210czJySkdWblllVEJNWmYvVCtaODdqZXpNYWk3SFM5czRxNk1PTVIvbTVOQUlmQlRMRjNDbVJRNmZGUktva3pHbmJoaGxCVXkxbTB1WXJFeGVCVjVaMjNSTU9QWi8zOFBES0VtTytnL1dYMFZpRWRxN09veDByVGZvcEx6djV5eWF3cnMza0xCNTVzYktJdXhSOW5adWlucEMxOUVnZU5CNmhTY1lSRUkvMGxhNEdrYzdMR2FsOFpZTm5sUjE0TExCRGlsUFc2V2MrTjBwQzJZZzk1dFhSTThGbkxnNnlocFZDWThXNFI0VWtEU3l5SE5RYTBIeVQ0aHhyZVpHMklHbnI5SlBpbWFVcHkzMFFGSDJKSWducFZ6NjUxZXJzTGN2elFwTlNwMVJlcSt4UlE4SjdHdjA2Zk1VNVVoQmhIbnViYUJYdHhENGZxZ3JxOUdaVm5XWE5LTWQ3RXVGSE5mQW5HcWd2YzhTS21qRW10elV2dXg5cUJNK1RZMEFXcUtUNlcyYjZpYU5sYUF0NGtobEJaRXJuZFV2V1M4Y0lIR1lRTDZZeThsaUZITWZMbFAwWkcxZEVlbzhKQlZrWnRlVEpROGpPTVhEdHlCQmF0SzdVMU1uNS9RTnFaejNBL21wK21McktSU1czSXZJUTdFbWdUbWVFQWVHRGhrUEpRL0NjSmluTmt5Yk5hLzNlM0ZMNit5SmdNVzkwWmdkRXk1cGQ5K2dMblluME1LSHJleXM3cXVveTZmeHQ2WTJzUnRPUVM5RHp5Z2E1RTRpQnVab1pSdHlJNEVKbitaclY4UDV4cWxuejZwVzRRZ09qWWN5NmJzK1pRZWRJR3hXMGp1L1AxZHdrZDdWR3BtSjAycTVjU2xTWUg0KzJWbzdRVXBHMG5HcmtxdXpqVlNzQzdUam9lMmRjVTRUY2h4bmViZFE3NUVzYnBJdVZFK2RjOVV1aUhPR2o5czRCeVJHYUZVS0x0TzE1WVJ3U1l1YUxFYU1MTXVyNWEzNVRTbk9FQS9LVHVyWXQwZks1T0hFNitxcjdrVVlsd0dmK3dDSTQ1Q3ZqVzBldTFqb1BvaEo3dS96SUZkWFdSZk9SM0phb0lPb05LcXhTMjFhNjFveDQ0R1BRS3owZVBBcks1eE5ncHgvR0RPOEllc2VBYmd3NWlGa2hOSElnU0x6eUlRUDJSejR0aWVqRVdVeHdsQ21FWkxQT0kvR3p6cXJuNE4zQUN5K2lWSnEwU0FjMFdhd2lFVVoyZWlNbmdzNDFzaWNyeDVIMVdoOUwxOUd0Y3BTaXZIUVd2K3RWRG50L3Z3UTRneDRQck9lSEFqV1MxR3NsbEhOM3U2MlA4dWFmdmkrWG9HM3dKbHNCMHZXTzNvSkk1OSsrclB1clZ4RkJ0RDlPelQ5VnJSRiswbkltQ3UyNGU4ZEV4eE45VGwraXV1U1Zoa05DVkt5ZHNiOWt2M1ErQllYbkdYWkVlNzFVLzQyMG9XeU82dlB2Szg2Q3pNMGZpUG1CL0RoMVBiSjlPUTRTM1pjbVdVcjlIbkJkZDkyRzloZ3A0eDZnYnRMTWtmY2VITGxyWllZRFJVZ1FWREtFcFpUZ2J1MU9TeTVaVTJjUjBxbDZLV0xEZXpmUzVta1hiS1JEV2w5VHVpN1YwZnVsVmF0dTZSZ3Q2eXVkV3RIMnorNVlSRjFKYnl5aXZ1WVpjZkprMFNKTjB0VGJ4NlZzWVY2Y0Z2U0N4dGpxdExQcUpvUnNRZFo1QnZLdEFvMmhhR3AyWloxaHpoQm9zWWNhY2g2MHZiM1BlcXc4NlBXUkdLbDJ2OG5KNjUyM1FOS1FhM0hFdWgwTjEzbG1wQlpUOVBKYUlHRWNRZzZqeDRPd3JKeDZZaytLalVzK2JSdDR5RXFiWG5ueVAxSkdoZFdlRytvWFczblJPcVBQK1NOa3BTcXZUTUFJMk1VY1h1OUc1TUh1eW5aVFRtUkZVMUIxMVQ1bDZDa2pOZW5xZk5HOGJkMWVIVzFkR1NqamNYaVBxaGc4SWlqZXMvV1p3UWpKWnFmOTNCa0o5OU5GNmtMMGlvZGxUV3JYQ1lDMXR0aXB5eGoxZW5iclZuQi82dk9xM0sxa0pPcVJrSWZSKzFEaklMeHdlNTB1Q2VtaWtZakhvZGxSRDlJVmZ4SWhLQkhubUk3MFhBUmhoY3FwMGVjMW8ybkl3YUJ4YlE3ZWVhQkJvZ1Z3Mkk5a2hRWEpDT0NWNEhweW1ObEI3T3lsOUtpbDRod1Q4Z2FlTE40Ym1zazRIOVdQSzJac1g1bW82UzdudmNMS2s3elNpRlJCWDRONHBkWEd2WDBhTUlPczFFRmI3RlNDL202eHlsZ05sU05aUlBGRVVkWlBjMXArQXMvV05XZlAwOTRYZnJpMkNEbUdNeVZrejB1Q0s5SlIzaEJDZHF3VURMMi93WnBSeHlnTTQ1Q2xySDZpa3AyMDNuV3BMbWZoUXV1bHlFMElZd1g0N3J4d0o5eGJ0OHpVWGpoYklDeWxONWF0V08ySFk2bEtkT1dQU0JTcU9VSXV5c3AzWlZZSEdVWWV3ZCtFV2NOMzVlNmovcGdJZmM5RGtONFVjVE1ZNlVON3dqSWdTMGFZS0IraUpnREYwa2s4WEdiOHdmZm1JT1FIYThwTWZudGt4bk9ObWM5R05taTdZaUNWYStjTFZwK1VyWGRYRU5wTkQ0RURiNE9vUUcrOVJvU05Fb0QzMW5Idk1KWjB4SkJiRDdZMDE5RDc4VW1Qc1BTdU93T2xmVGtWeWgrVnhONGtra1pjeWhOcFMrUmhwNWMrSzU0NldzZklJaXJDWC91alpUYUF3R1FUNk5td00yMDBjYXNzWDBReXZicmNLM3BrMVpJUFJwdGpsNkJVLzBvNk8ycEQ2RWhmNWQ1M1RmNjZYdlJDNU9hODdJL3N0Kzk5VjJYZnZycm0zRlJXZGpxeXZSL0xCa0Q2c2g2RDJkS2hIZWVpMUtuWm43MWs1L2habE9ENWxvaVZXZUNUVFIydEtSOXBFRmlIbXI4NDZhZ3NId0hpQlp1WjJvelNzV0Mwb2ViejdtdXJwZm5YTS9yTXdwUGNDTStBakt5TjNpK0V0OEpCMndJNVVuNjBMYnM2QUw5L3V0eUlXUFZaYmhOY2xwWXVpNm1TV25NUnJyOXNtQzI5a1lqWHRSSTQ5cURvSjJRTVQwTG01bGpLaTlZeGsxSHpVaXR2cVN4WldZbXNBb0s2WHlpekdOZlJjaUo0ZFVidnE2Y3RXdUF1SmJrTldVa250U0YzWENmM0lXcmtmRXBkZFoza3dYeUNWZTVOMHVMa0tVRFpFVCszemR0Y2JHUFpDWTlwQnh1UTlGaHZyOEtOR0NaZWtDK2FEc2xUNXcyMDZYMGJpaEd3dVY2YU5LL0RqRTJsRWJKKzJqSTdlaU1SV242dERVajZIb21pbFkyY1IvSE01VjdVUjFuS2VhU00yM05sZFVQaW9NTGhDcUJDRUZuQTBuMlg5SGk3T3FwL2FucW5qL2NZQmRWTDNqQS9DclRUdEhTYU1telBzZE9YOFJKSElYc01mUHpISVNJd25pd3hIdnR1emxsNUJwdGdNY3VYaXBnWkg3VytSanFYZlBFSEMyclF3bncwSXc4Sjc4eXNpTTZFcXJOenZZYnk4cUZZemhGWnM1NUIxWm5UZWkwcjNWNXBhcDh2RzZKM2R0TGtwRkFjNDBSZGVFWVR0THF5Yy8wUlJEMVMxRUVuSHdsRjY4M1pEWEFlR1BUZUYwbTBNRmN0aVZIQmcxMy8rOE1JWDBSRjY4Ukt3ZktVNWpncFA5dVEwL3VDMmVwYnJ3d1VMejdWdGdYeGhLT2hWZVhGS3lxb1lZWjZzVFF6OE9lUDNGdWcrSUF3Mk1MUy9wR2RkT1FKelBRSDNISXlubmY2Tkh5MDQzTkhQUG1IUktKWDRkVzlwc2FXNkhUbjhpRGtHRmFxb3hubGpubWdKOG1TcDdvK1o5NDMzVTF5SnIyQ0pwcVBjNXljd3BsV2VUVG1qWG9oMmJudTVVY3g0ckZRTU02Smxha2NHV3k0a2dJZXVPL3dOTWdUeXRDTEV2Tk5qRitoVHlXT2ZLS2hsYWs5dWVoNW9sR25sZEpsNWZvUmVPOU9FUEt4ZklJWjBadS9ET1I5S0pxY3pzcnhsYUY4bnNEbzR4UXlSRmhNZ1JuZ2RjenhKTFBwbUZNanZzM1JudkRITFpsVkRtSjdmR05aOHNlK3pMZE1TSVgyenNuRUtlSXBlQzNRZ3BTNWhOY1MwUnF1UmNDU2NyN2cxejI1aEs3ZUJjTkl6aVQ2RzBBdFN2akVDZUc5bzk0REdFVkdaWnNXWEk2czlUYjk5OWUxOXVudzJ5NWR0ZHJDVXd2ZmVGcWlMck90S3pWbHZQNk1EdkJJRkM5YU5qTGlQWTlnSXZtU244K1RHUVV0VXg1dlpJYnQ0enF2bitKNGlqZytYdnU2OXRmSGF2aEFJa0xFMHo5YW5pZnFKUTlReDNqWnZEU1N0QjZaOTlJYTR2QmVISFZ0L2x5d0JyUjdnQ09Pay9jbzM1UGNyeExMNXFyMWhkUjlYcGwzYTJlYUcxODdtR01GYm45TXF3bGc3M3g3TG5Jekdid2V0V2FsWSs4OFNoc0ZMTXI1NXpIRHh2RXNkUytUdHF0cFZxYUh1QWFsNGVVNGs0bTAzbTU5UGlWanpqc3hpZmFESkdvNWxwM2RHSFhxUnp5MU1yTlE1dXY2bU52bjUwUFE5R1B2bDFhbE1xU1hjUDllODc3Q1dxSld4RmNocVMrNk8wTkNhM1Y0NTR0eVBpWmJyYmhWVHhsU1M2VElTalNzcXVXZk1PTUllVFNLMmxJOWxOU2tqNVNKcnRlb0xXeXBZN1NNTnQ4UzJWTEFjelBLbmxGdVBZQ1JBWStValo2UGxqdnBrWVo0N05XTnNsWEFjbENRM0JOVVFHbkMxTW8zR3ZQbjNDUExpTVlsaTNHTTVLOFp0U1FDZGU5aStNMTl0ejV1RVpSTzFxeXhOdTIvQ1d3VWNHMjJJV0VaUGVqNFJvSW0wbm5FLzlmeTVHRGRVdmtXUlVnckdTZ0FVb2lpVTViUHNJT2pxN1hPSjlXTnRrbTZiVFN5NHZIUHo3Ly9Bdms3SlVmSUJIeWNxa1lubFNjQzBHVkpXK2lhb0NKL2hpQ3I2eHdSYUwxMTNoQWtwSUE4WnBuQnFsQkVYVVkycm1uWGIwbTBVNjBCOTJRNlpmZDBKSXY5aGVjOWJjNjN6MFd0Q2tGV3lBWnlZVkIzM25xb0FhTE4rK2owUlYyMGtXY2FuZDdqUGRFRVZEMmdBMzd5MVhGK21FcFIrV2hteC9ydVNxL2pGMEVRUXA1Y1d2VmNrbndJSTU0cko4VXRRYWZFK1BDZmFUVUZCVEtTL0JiclljWjRYTThhUHJNMXJaL3dTQ0plS25wOVpkU1ZkTE5hVkhKNEw4anVZVmw3b2trbm5yT0VSTVNMUWNOY2JkbVdwRmJ1Unl6dktFcjFYeTlsek5NcnpiR1dMbExtZVBxUjE4QlgyeVJTbVBaNmR0Qm40VDJSeDBvUUpZb3p4WXBXR0NFWFJwWFdoaWpxbmRiaGZCU0hoSHhCMTVXUVoyUEpBTWtqUmZOSDZ5TmtHTS85cFR2OEhHS2hwbmcrcEN3MEhUSWZTekE5ZVNnOWI2YjNQaGtjZmNMaXZYWWRLZHY3Z2FOM3JXZFJqY2NHUHh0VW1SN3g0cGxYZDU3ZmhJRmhudm1qbk5GOFBlVWdMM2JQZ09iYXplRUFYNVBlRi9CVzJNK3JIbnZmZU43MVdtYTlWdGdWdTVMdVB2azBab2xUZUIvYm5sZ0VJWk9aTnUvVGRncGJHK2FjNVpIZWl0SjUvaVp5NWcvMlFpQ2w2cU9KdkRNNktKblFtWWFHUlEvamRkK2FRVElhYTI3UzFDSHYzTFloVVRrUWdjZzZKdDlFMTNQUGUvZDU2L0I0TXRCcmduYTlkRDB3S2orcGMzVlUvNVdiZit2cm5yV0VXbG5lZG5KUythMGlLc3I1MTJsbEt5UjFpeVRwZnFXL0xXWk5ybGRlWlhLRnkvSVEzQjF0YWhXcExVVXBSMHVucDJoYVlhUi96Vit2N2ppUGRzWkVRMlFCMHRaUDFHUDZVaG5ROVY3WFJvZVpac2ZUMFlTRWRON1NxNk4xeG9TSTFoTEhsRk5LL0w1U1VsTklVOHZ1KzE4L2grWkc5YTNKOGxWS1Q3OUZWMnBFSUkvODhGU3FxejNmbzRCUVM3c243N1BRTFBINExOeCswMWRQOWZ2dmJpa3BsZTY4QnMyMGo2QzZKam1XejByanBTT1hKUmpXKzZLZHo2Vk4rSE4rTTM4dFYwcHhkNHRRK1h0YTlzUXJnMjNvY25NOTZzNnpic0piL08xMU0vM1BEZFpwcmJxTFowa2d3cUZIUjBmU1dXM3d5dlR1U3lzdkMwY2JxK250eDdjNXRlTUV0dkJJOFJxMWhBZ2hNbk45Tkxtc09wOVVoNVVQOFhaWHlZR1ZaUjllZVkvUTdLMC80c1JFM1Y1VTVVZE1BQy8wNzZsaDM5M1N5OWFPeVRQb05XYXVZQVJKeGlQbk1abkdMQ1dJS0tUb0UxRUYxWWZQZnJxWDMxdmFoSytBeFM1RHNsa2hKR2FVR2ZVeXRYeVdKU2twN1NMazBjNXJaYU1XTXhCL2Z3ZVIwdS94Q05tKzFETmkwUWpMRWVwSXF0dTZ2NGhhd2lJcytybjJtbFIyNyt4L05OR0pWY0R6MnZLV1JBTDVmTHpBUmpLdWUyV016Sk9IemJHandoczlzcitBMTVFWUdXcEZQSjRWcGlxNUQ0MGJWSnBMWHRhVXVPWWVROFJwNlp3VVBTWUE2bm1PK2xhUG1lY2pPZ08xOVQ2VWZ4SWhoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDRUFmMzcvdFBaeGl1emJRVzRMc25GZjhOZmIzbjV0M2g1ekk1dlpEbU50TmFPbFdkU2c4djdQZHhPc1hkRFEzUks0K2N1SEVsa2s1QmRySjVLbyttdjczdG41T2h0RnpLanlXeWJrM1htcGpDS1VXc1NVU0dzUWVqdmIyOVZUdWk3Yy9VWjQ1bjFSNG5sMG41alhOV1FSUnJXaGxEZDZyYVZUYUVnN05hcnQ4RFJOckwzVzErR0s4RmViMzc2K3YrcU41bks3NDBvZ1M5ZnJEQm9lOHdIN0VKU1FvU29qdzhtaDdrWHI3UVBRZE9RbVRYMjlhbU5wRTdtVkpZeFpOa1I2NjVQMjYxeTV1Uzd4T3lwYnZaUTNKZXpyMnRYeTgxVzEzMDNJZit3dzRQT092KzJQNmEweGoxREtXOEM4MHZYby9ucnQzbjFGU1lPMDRZUTE5VUhzZTlZK0l6UG1ZTlVpYURkcW1xbmVIcnRWWm4zUmpBYW9JdTRBK1ZpMEtXWkpKOVhGbEEvMUM5WGkySHpjb3FUOUJ6MjNhc2R2T0tJYTZzY0htL1BOSFVmbnVWaFhUdHV2dFRpRlJyK1VhcEhmLzdFU3BNMWcxSFhzRzRlMVJieFhaMkRnejBSYmdzeXpKTkJKbEpKZVIzMCtxemw3aVV4ajlMcHZYL2xsRUVMNjBhUlZxczZQbUdSU0hWNmRVcjdaYlJncGF3bGo0VlkvZmJRY2lSbGxvdmVKdWpjNWVCNlpUR2pkdmVramVjajU5TXh6emJqcFhjYzlaWGx0UUgzeXBCd1RNb1ZabWhkVkJxS1RuY2JxYUtzd2xNUEdMODNpbjJBbFRVWkxJYUhlVnAwK3BYNmxiNlZEK3g2eEhMWDBvNGFFRmt3Q1l4RjFXcVNhNnRvTUU2NTNSYUg1a0hUUkdSZXBTeHFkWXVUeFpwSTNTeXhmcEM2aktPZWw5TWs1RDB3VmdnNmtaK093UTY5TnIxRHNDYnRHekFqcmVvL2ZjRE5lTXRIcUtpOUdMQjIzZWY0QnltcFpIWXFndkRZWWlXZEZCNFlNZ3o3QmlwUzN5U2lZMWZubmV0bGxFZy9kOCtTbUlEYUJwM0F5Vm9VV2xvdWFFSkpPYk92eWVNdzg5MnkvcEZ5WDBtam5QaHgrTVpVUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEVEay8vejMvLzM4THRmK1hmT2YvOFBmc0Q0ZTdXZjJKMVNGN3RxMUJHVG5BbStucTFrN0J5dkZJMFdjMm9ka1BRZXUxMXN4bzU4VzlIbDBPTFg5TnJXTk9HSk45YVNJMVVxckZWSloydlZrcEFmMk1Jdkk2eWtER3U5bHZSeUpZdFExV3lFNXhVbTh2bW96aWRnR1F2bm4yaG9oYVBWOGZUNmxCNHBoR2h6ckFBMWpaQWlpMG1tbWpUNUxNczREa1owUEF4M3drb1FFMlNoUXVoNnVUQUMxTTlxYXkwK3FiUjF6NW1mVHB0TFcvWk5LMkhIeCsveVBIaHZTbzduNmI2MFR2VDd0c1R1ME1sRGJEcFZjeWJpdXRjR3JnMWhJSXhDZFNhT213V1pIVW1YTlRDV3FxSHJjSTdUT3h4cVUxNmQzaWlENUNxQUtOMTlJVGMwVTZwa3ZQUXRVY2tHUG1xdVRmVTJ4Zkl0eTlVVTVLNTZoZ1dnSG0rMFg1N2Rmb0IvVjFkRzdueUh5ZStzbWhNaEUxaGJxSmZUS2hwa1M5UXBSNWt0eXBQQThvcTdJSTQwejY2SnIvQ3pRTU00TGRKNnVDQ0gxbVplRWRMRGlxVVkwZW9hVWhlWUhsUUlVWE11Ly8waUJ1VXZ4cVlaRTN6TU5QOUlhamE4bnc2QnV5anh3K0ZIVjRLbUtvOE5XVXFoTWFndFN6bWpkMnZsb0dEcXFsb0VaZDM5UVVVR2I1N1BwSFdjdjdRekIxUnZyZnlDOWp3TTFXWGttSTIxNHZCaENYMTlBZldvcXcwUHdZc0tlMjVNVlBUemkvbEMxUHhUVWtKYXVkUmF0cFp2Sm1YVi9CRkhkOEFENGExTkNDQ0dFRUxLV1N6NmtKSVFRUWdnaENMVGtDSmtMMXhTNUI1ekpoQkJDQ0NHRUVFSUlJWjhJb3pxRUVFSUlJWVFRUW1hUy8vUGYvNmwvMjUrMExWZjR4ZFFIZ215bWRsQlZNemJzWHdheWpWaGt1N0JrbE5lazl6WldPZVQreVRXSjdMeVJoTFNjUEh2UXJSaGJJbjBQVnRsTEVmN0N0M3c2azRrN2pxcGJsalgzV1hvR1BDcUpaMjJUaU94N3FaVnBsV0cxd2NpdVZoMmR5Vmg2cU9wSmVLTitlOUdKYnJIcTVVbEMraU1IOHRPWnBCeEdkdXYxTklUVlJBN3Z4UkEvUWZnNmJ0TzJmM2d6d0Vxak5xakpOMnFQeEdmYjNsVElQK2Yxc3I2LzhLV1ZrTlRiS084TjZ1WDd0YjZVaXE2bHR2MjVhWVRaYnFQVW1QMkIyakthMUVqSytZaWRGYlY1UitaeEN0YlZYcmZTWElkK2RUUituN3U2MzJ0cGU5MmRJdWhVc3hwQlNGcnNnMmp6Ty8xTVk2UHllbjhnSkoycTZpTWlQelY1Ly80eCs4dWkwUytsWmxVQnk4ZHR1aEhjcjlDTWRISmJSa3RQblY0YlJtMnkxZzd4eXg3MUg3eTdSVlNCZEwxT0U5ZUZoQkNKWHN1OXZmNUtFL0VlcERJMFJ1WFNSekNpS21iVm5RSnRpSllkZFgrVGtHODBKb3JXRGRsYkNrZTZ1K1I4b3VzMmRhU1BtSmZXM0pwaDR2YUdISHZ5a29jUmVhb1JWWUl6UElmZW1LaXpnSGU2UW5odXNFMVFWWkdUM1laazEzMTVROEl5QnVwejJyR1ZWMkprVGpYaldRelAxbTJDSFN0NVBkTllZUmRIZWxKS2I1WHBwWXVVaVpUUmEzWmF2TXI4UnpsdjFXMmRyOHZ3NGg5a0FLK3p5WEhNV3VoMUdVakFRa3AzaE85TnY5QmxWRmRrSisySVR1aXhOcUoxM0o3ZU5hVEppcWdmVE1LZ05oNDBCTXFqdXF5azZ3RzFXY2xOOEdSRGFxNVBuQUJSLytpSXVmZjQrVDNEdHJ0SkovTFhwb1FRUWdnaDVEYlFrU2VFRUVJSUlZU1Foak1kcFV3dmpSQkN5UGxRR3kza3FaM0xTVVVJSVlROERDcC84dmx3RmhOQ0NIa3NWSUtFRUVMSVV2Si8vdnYvZm41dmEvODhsMTlNZlFEUjdZZ0hkdUZCZjRrZjJYanpORWEyVTR0dVdQaVR4dnpLUVpxN3VRdjVVQ2F1MThleXVNK1FIUXZyNjFwZTZYcWJic1p1OGZPeHR2c29uZWRUVTZaMjNtcE9WUFAwYWpLTGtZVWIzU2xYTysra20vM0Ztd0R5ek1tcERPMGdpOVhsemFqSGlGcGthYUY2aUhyS1o4WU9tbW1PUklsSTRjL0YwazlYSnFEemR1bWQrOVErMVhicSt0WGFIemxmeEJMMUw2VG16VjlGTEZ1ano0NG9IZnIyNzA3bFpabWV0clNoMzhlNFVtaUphbVNMMHBtK3pZT3NvV2hkMXdIWk5YMEYwdWpXODNuM0JlQjJaMzVnYXVYVXJxM1BHeDl5UFdiNENhLzAvNzZPWHhIN3ZMMHV6dmVvYUl6cWNpdGROc28zeSt6d0xYZnFSZ21TNXVZUHJ3NnRMZEo1NzJ1dDd0ZGNaMHJUMmZHSTBWaUVsVmVMT2NqWTFrYlVqcERMbnRGN1IraEdRc2l4c1FoTlJjNVk3Mmo3ajdqUFN6RmpOM0VrZlYwMmF0dk1jUGNqa3loaTA0MjR4UjZXZTAvMzZSNk1ycUdST3FJUEthTm1wblNOa0dWRUY5Tm9YUzhjbjdTbU9BSTh0K21Nc3RwMDRVMm9vb3I0ZGR3VDhFaEtYYjBDRGFrcmtyNzNtWVowcmI2dW5XOU9xY0dsZEVxb3UzY2xqWnBYa2REYWFPaHNSRTIxWFQ5VExkZlh5U1NpblIwVkplUXo2Rm1vVmxsSEJDT2t0RGRubHZ2Zlh2ZktPRElVVVo5TFNoMFVOd29CODhxRW5YMG9xRTJuUGhiVU1vaUo4RGFSQnpCRFNReFd0U0tNUzlPMUlSSWVrSnpPQjhCZm14SkNDQ0dFRUVJSUVXR1FqSkFQaEF1WEVFSUlPUTkrSVhZWjdGbENDQ0hrQnlwRlFnZ2g1T1pRMlJQeXNYRDVFa0lHb0FnaGhCQkN5S2Z5SjdaZkU3azE2Qys1SjB5WkdmdlNuVTVrTjg4U1BHOTFTTEdIeXRzOStpUDdtdmg0QTAvaXpGcEVTbnAwcHl5cENVN1JZdnJJWmgxejhHcGZGVXJKeHZsYVNyYnBmODd2ZHBMZC9hRXdzbzluV3dhNjNWWXh6bW43ZktJS1NVbG5mbzBteFhUanJnQ3NEL1BQZjB1cXYyVVg3ZjlJWFROS3VobVI1UnNWWEczYXJqbDFNOXI3RHZacHI0bGcyWlgzNW95N1JUUzJSNitCWXRCdUY3aTdQcVBkNkF6TnlqR2kyeXpiNERlZG5pci9wQ3BDeWJrWnZTeUlMYXVOUCtWMWZobjFOUWJGTEN0WC8wMkE3dFQyVWtYN0dyQzNkdWVUVXk1U05zcXNhRVNQTlg4RWN5UTNzZ21vMTRPUm50Nk03dTdMQzNsZmFITi91N0piRXorMUZlWW1nOUNZSFVYT2kzWkFpdFIxSmRBbzA3T1Jlc2VTc3Q2MDJQNGhGTjRXVnB5Nmd0TjNVNENXWUhUb2U3N3V2Vk0zamdHOEM4UW9XeUNYZ1A4YmJmZXV6cUtjdC9Tdng2Z09hOXBtcHRYU2FmZUJUWlFDcE5pbjZadUVFZXREeWx2QXRJU1FmbGF1TFUyMWVkNlJWMlpSOGxnU1U2UEhmUFRxdkJUdElQU1lsYjJoWU1SR2p4cHhucHZzcGJOQTNlQ29jdFBNRHE4dDVENUVoUjR5aDd3ODFubEVpSEdPa2t2UTZ4RkVvMmRhK1VBMG9aUmtONkh4U2QvWGhlZmpHeCs4aWRmOVBYNlgxVlpTRjFLZnQyTDhHbEtmUlpUakRJVWNEUUo2YlpQUzlCSTFDb1Q4VmhiTFZsQ25yVExIa2k3dWtSNlQwbm1SQ0dtbWVHVjU2U0tnczdXdHE3MysrdUxNdjJrTWE4VkZUZktJR2ZueFdFNlkxWmwxdXBUOHlVUmI1bDcwem9NMmp5WElvbWFFbGsrcWkvUHhpeDROYjVVVjBVdDFQdWw2cjM1NmxQd2V4UnVza1FjTnhNUjdORGtyRlBGVlh1Tkc3WVkzc0ZDc0dESDVZTHhKOThJVDVGYjY3RGVoempJcW5xdzZ0UExSMjd1OUtZRVlBMUdINzJid2k2bUVFRUlJSVkvZ0JLdVdYalloYytCYUl1Umo0ZklsaEJEU1F0MUFDQ0dFRUVJSUlZU1FqK1hVd0FhaktvU013QlVVZ0oxRkNDR0VrQUEwSFc3S3d3YVc4NWlNa1AvejMvOHB5RSs2Ly93Zi9vYjFsaUMvdXZjMmdEc1FiUmNNNy9yU0pudU5rdEo2ZldudFlsVGRrRGQ4VnRONk5tZGEzcGVrbnhrN1lKSFlvcGxZVmUvNlJadFdmMWVpL1pMWFBFYTI5UER5RG00ZktIN2xNOXRwMUsrWHRHMnl0cFBUam5lTlVjcU9wSXZPSWlzTlVMZjI1VlR6TnJPZU44RDJybk16djZOTHRhOC9LRHAva0tiZ1RMM2pHWGxQQXpYZW5MNmVhZXYxYk9wSi9tTEo3Nk8zeUNwVmxVcWQ3UTdYUlNoalI5NGZGaW05WnQyZzlPakNsdXpVRUorNWIvMms5cTFtUnpUSDIzK1V1bjcvc3RyNisrVlhyUTN0K2JhV0VqeU8xSUZZdVpwUzZKMHpSNjJ4bFl6MHczZ1oyaWg2MS9VWkpnVTY1RGJwNW1UNXlhYmxLOXV5SmJtME9kODBza2xxbmtldms0L0cxVUxBMUZJTFJkd24wTUNxUHJLdFhxK3JodWE1VnJjbnJtRVhWTmFKdTdvZ1ZZOTBadkxqQkY2ZU1uTERUWGtsMHRtZ1hhSG1UMEk2VGJlbmhPbU9tTDdGYkIzSmptbFQ2UG5Sa1loWWp4VDloS3dsNHJGb2VLb0NsWmh0bVVsSTczbEp5YW1yMTl5OERTTURIUzByT3VEUmlZR1VIVkhES0o0clR1N0ZHY0xCRTFRdGtYbU56bGZPYjlKTjJDazEwczhTMU5iNUhLdzdHbjl1MDlWRmdVR0VyK3hGUGk5eXhBSWVFWTY5enhlODhxTENyOGZ3OE1vQUJIVWJ1RHBBemtaVmd6ZURJbUVxajZnNXFhMWlMWDk3M2VLVjk1L21PQ2xseG1Nczh2VTZqV2U2cHVEMVJ4QlZGYWc5UmM2aGR6eFgyT3BhMkhaQTlZZER2emRqOUpGR1ZvNkhIbWtZWlVqcEVwaGV5a01hZWg2N3NGT1hnM3BCS2NYV2NVYkhUaWowNGFLVGVQVEVmaWRQbmd5bVFkYU1kLzZ4UkIrMVAwQlk4TmVtNUJGUTJSTkNQZzNLTFVMNjROb2hoSkFBS3g2SWtTK29qd2doaExTY3Fodk9xUHhweWpCVCs2OG1DMzhSUW9nSEpRWWhoQkJDeUNKb2FCSHlzWEQ1SGdBN21SQkNDSGtFVlBtRUVQTE56eGRUMzRmVnBlMGJxdnhpNm9OQmYvb2VLQ3FEMTBjMjh6bU15SmJIWHJwZzMwWjJJU01QQVYwa0ErdjRWcXplNUhLd0NaNnNqTmRWcXJJenRCR0xMN2xub081TDVLVHYzSnZSN01Eb3ZpOXRHcXhYYlZZc1VHL0xGVkFEUjI3ZlRHZ1Zsbit1RmplMWJybXU1YkdpRTltMUo3cGxyTGFiSEkwWW5hQ2QyTHRMSXBLT3czU0Vqb3kyQVZtb1FuWXArYTdvbnhQU2w3ekV6OEFGMnlJeU9wTzE4dmJYZi9WT1ZscmkxOWwreWJ1KzhpcGxVK2E3UzNONzR1Y3d2c3JXaUZCci9KQXQzbERIMkNyYnEwUEw2OWwyU2JnZW16dm4wZE9tY2JuVlA3L1d5Y3k5ZVBMR1crRFM5c2NWOUExQlFQejdvaVZ1aGxlYnhsbTcvcm9JekdQMEE2S2Jjcjh5T0duT1hrUGFWMTJpTjR5a043K1VXbUpsdmZPbGhPays3enFxZjZWeWV2SWhaY3JzZTA2UFcrMXpyWkdKRVN2enNtcURrSnRqZVZ6YWRhK3NTRVFZOFVobXlwTEx5WnhMMjgyZGpLamhTRm4xOVNTa0c1MU1iUjdFMWY0VTk1ZWN3d3BCRlEzclNQa2pjRDZUU3hOZEFGcGVKQnJocGZXVTRjOC9scy90OGtyM2IzTjhCTWpEU1MyUGxzN3JXN1R2clR4dFBsRHBtMEVvSlc0aEpVdEdjOVRyVGFBV1lMWjVxZG53U1RrLzhrUURtVkc5a2Z1MkxPU0xxWFdkeU15UjhrWGFKT1VoRGQ1azhaeFJzcDRac2U5SVVBRkZXc2dqZHJTVzc4RUxlMVQvekZpK1dodWlVNmZYL1NjQ21weldZSXpsVk5CMXZCdFdaU3plcHF5VVdTbnpuVGRoNmNqTlFKWEJBbjJMbWgvWnlGdlRzNWEwNjQrbTE0YTdDZnkxS1NHRUVFTElJNkRwVHdqQm9jUWdoQkJDQ0NFZnh5VytXbnBHRzJpOUUwSUlJWVFRUWdnaGF6alQ1NmEvVHdnaGhCQkNDQ0dFa092elJ6NDljeThxOG5GRWRsSmRWTlhIek1BU1BIOUExZWgxOGhCT25LTWZ3Y2oyVndmMklib0prNVcrdk0rVUpKVzA5bmJrT25GSkZ0bCtTcXV6NkVuZHNsQm1iS20raXVJY2UrYzdxdWhPaUxkQm0xa3JPTEt1eTZLTGtQNHBWVHJ5UEpWSi9ZSklKUTdCa2N5V0x0WkNmVlZaN0I5dEZDRzl4L1JKTTZOQXFSLzJLNkE0eDdFYU1XRllsRDZPMm56SGdld3RQcXY4dWc1SllsbHRpZlNjMXR0YW1jRGFDdGUxZ3J2V0pkZmNuaWxsb0MxVWZxU0R5Q3FZSmpITGVDWGxydk5kdTdIb0RjTmZONVhTbG1CWlNqNzRtblQ5U2dNc3I1SWlYUGZpVmxzeVhCZENyeFZCQ0ZtTDVpVm9hUzB2SWxxWGRiNFlkV3Q1MExKSDBoM0dIWVhnQlBzcW5CNlpYS3ZyOU56Zk5zL2pnK01QNUF4Qk5ldXhZUXFtSStSU3JIaUswN3RRYS85WHVueVVKeFgxMnBEeVpxU3gwdlhjTDNxZldoemdKMjhrZUtTOTN1QmswNnJ1WWJaNUdUR3pWcHRmcjdTYXY3QnlCWTA4MFlqVVFRellRWi9CVEpVd2t3SWUvLy9zbmR1eTdLaXViYUdpWXYvLy81MkgvUjM3WlhIV25DT2RBMk1KZFlGd091M2VJcXJtTUJlQnVVZ0NPN0YzbkxYNUh2WVZyNnNSWlo5NlQ3MVgyNExiZ1hhS1owM0tUbGhHbUhvRzNPZS8zWml4TE9SQnpDanlTZDBRV2ZUWFBxdTRJZzl2Sk9HSHFSdzJSTUg2QnZNSlJWektQMFBhUWZzbU52cCtrL1krVmVxRDdCMXlwdDhVTG1MOGFKc3NsaUw2Z2ttME9aRDdxcDQ5U0VwVG16WThKYit5N04xREZzcXNWb2hldGhYbFZIOGZlOEdmdjY1RXIzMUdsZ3lEV0xlVm00ZGZHWGtZdGhlLy8wdk85OVBMWm1VVUdkaUUxa2J4SnFGMHJtOEgrakJTRzdia0VrUnBpcm1aZFFkbUIzWlB1OHpVd2ZoUjZ2YnZKYjRvRmtGUDgycWFXNUtTWHpraVIyN2ZLbVJqc3VSWGdsS2k2eVFWaXE0WVpROXpyRXhQM2phL0ZJN01KZS85MXpMdk1HZk92NGZXcHp2VE52ek9JU215K3R1SzE5TE1wQ2Uzd3JJMjRuQUFWV05ycmxWWlpaK25tSmsraExuY2I5ZVJSdm90ejVKZjIwcUYxMCtkbTBadnc2YUxuNzJ2Q0svY1d2RnFkc1czN2k4dWU1dEJtZkoxaTJlOWI1VkZDRGtIYmU2MW1tVGtFWjRXanVnU1MyT1NBTHlLZWVXekhxL3NQQ2huQks4cDFaYS92VWxHdnB0WWwrNG9KMElaMHRFaXQySmtRTTlPbm9EMDFsdlh3ODhYdlBsNnE3Wkl6bHdCeGp6VFdLSXM1NWJrS2VLNUUrclNhUzdOVmFoN1dWb3YxT0VwMmIwOFdnY2szSEpwdFd2U1liVHgyTWlreGVzU1dHdFJiZjFIVkZac0xaeTVaOFR1dlFEc2hPVm8yeHp1YlEwbDQxdDFBcTlac2J1SkNHS1BoU3dSVDRrMXRHY2FLZUd2eGxoYjMrUjVORDlNNWM0dTZSQTBQSEpBRVI4WnFTTWExRnZSTWw2MFZSUm5OeUVkMmwzaEhnR1RDWGxKWnNSWlE2c1c0d2hxandKNnI5OXFkeTZsODVUWmt1V3lScnoxTXVNK2QxWU9acjdlOVVaMnBCMmw2RVdiV1V2L0dxNUJDVWhqamFrK3lvZ1NKZHplM3JiREdtMWFPaUk0YUJzN3hDVkJwR1dIZWpMb2QwYlJhaGVFR2J1VTB2c0hEdHR1NlU2aFdZLzFWYUdkY08zK0VEK2lsMTZLMCtwUXB3dWNYQWlsZEp1eC9jMU5HekZTdy9tN0toTnBOT1VmNDMzcVl5ckNNcmQxdGNadjFEMXQ4dXF5RTFEbTZIMVphVE1RNnV2bjBrMVhqT3N0dU5KYjJ6WEFiektoN0dLVm1YelErSFdJbmpQWHBMZjZIUkxRUmp2SDJNanlkd3F2V2xMaml5KzlsQ2VNOG9FeUk4dUlVR1IxR0dvamRkbkZMRDlYVjJPNncrc0pqTndOR2s4SWlRV1p6MmhhSzkzSXFvSTY0UVM4aW5tbElvL2VqbzUwM21hMldIcmMzNlYvRHRaY0dlMXJkQXozdG5GUVdhUGptSkNQZ0E3MGlBSHRuUnpGbVdSNzVuN2lNNDJoNXloYUhkQ3lFQm1ySElsUFA5TklTbE9mcDNpanRwaFdsbTNsYTNkUXBEUjF1dFdNdHVuc3JIdTBtWjZkdnZSMXlNYXNYOXlMZi9oRWpkbzdHbTM2RmZUMGVGSENpWUZuemZwNDQvYzUzR2EyeVpDYjhPN2NNZnA1eFNxUDNJRFdLQURMM0JOV2YySHJINkxnNk8rNzhHOGlwQ1VyMTBXNWJ0TVd2MmdyM1FoR1ZjYnBLWWZSUW50dENoYnRGUTBXU2U0R08xNW5WbW1BazYzZWVNNU5Fa3QwQkg1WkVVK2cyeTMzOXM1N2IyT01vbGljWE5XdjlQS05LblBwb1pTM2h6MWxXN3ZaNlAyQWZWRzNINHpIa2NBbG5xM0c4Z1hxOEhIYWFTenRYRVkyeWhNYldWS1ZYcmJwMnRpZFhoR2VSKzJkSXVsZURCRnA1ZEVpczF3RjFZZHBiVUNib0Z1WUVEWmpRNnh3S1UyZHpwNWMyWWgzZjFIMWI1RkdmU2Urc21aNUFuYk9pSm1MS3V3Wm4wZVRvZFZoMU0rMHZQUVJSZTE1RVF3cFU3clBXZVQ3T29iaWJXeVBzRi9wZitaZDBkb1crdEp6cTlmeXI2aERtWVp1OEE3blU0emZCMnhGR0JIT3pYZWhyWDdyK0ZTbDBjYVNwN1cwWWZzT1I1ZGtJMnE2VnpncVE1TTdrMStVMmR4Z3NXeEVrYU42OXZwZzB5TnNuOFZvWTNucWxvMXJMYjEzTDZLMWRlWGdteFZUbGl6WmVxU0JnSm9JUWtnczN2a2JzY3BBZE1kcXBMSlAwMFBSeTBXUHJJaXlWKzFUMWd5NEVlNHlrUEtrZkdqWks1YTE1SE9zVkZobjd2MTduRGhDTHMrWkE5aTVGL3BPYnRSTjJnb01XdysyZVhvN0cxNkRGZUZJb0hLY2JlOHk2bHY2YkNSdjkwSno2bGV0Q0RLU2F4dXZmWHcwZ3RlM3RWclMwL3RXMmIybkI0anNYbG5lMFl5T3NDczk1M1VNcFh0RGYvdjdlY0ptNE9NbjZpL1drMmF2eFU5Vit0RW1udDJLYUhmYjIzQXlnTFZoeDhZZDVvenRBRldtVW5oUjNHYXBuMWZVbDN3eGxtS3UweXdxK2d5bzdsNW90aUYxcm04S2Y1aEtqc3hZOWlkWjFROHNQdk5BMFRPYlQrU0xZY2RmaDJZaDRuMThNa1B1bExsK0tMU2xubm5uQUY4OUY3UjJYR21ZMmpJL1lBUWJWdC90Vm9hVjVyRVU0M3BGR1NTRWtRZTk5UjZxQkx0cUJ1M1IrYWdjUzNNNTVFOTF1TGJiTWp0YUloYW5vemMyNDhNVUkzYThYZnc1dGJFeVdnZGtsWXFNejJUa2JmUDNkdlRhZUE4UjF0KzYzMkxrUlY3dUttQlpLTEt2Zmd4RnJJS0ZwdmVVOVVMTy8zM284OHBqL25oN1MrZDUyNk1wRSs1bWJmTk1tMXZJaTJWT1BmMFZYR3dkdUpnVmQxa0cwb1Q3WnAvb3dvOE9tK2VNMmF2d2UwREJaL2VRdUs0aGhFVGExQldyMzlQMDFDZE40ZFBNOERmY0w5Mmk3eUJTUVVRcHc1R0hsTXNYTjRTY2lYY0FyNXpJRzZCU3o5VVBHdysyeXRxWFJZbmExN3c2QzQwOXVGVjY1Tld4dWJNbmFsUTdZclJHN2JhMzZTdys5VVNqanM5QVdaNzdidC9pK0RUUDJoRW10OGFycU5Ed0ZjejY3R1RZckdwUFBjL0VxM1BaN1lGODlwSEdyVGhqTzBDZHgwcmhmOXpsdjJkbnR4bll6MlNVRThiT1UxYmFsMkxtRmJDYmRkaS94eGVvL3NEaFNOWmd6WitvalNSdjJtRjZPMVZiUEJKZTdHSU9ZVGtkVHVRb2pxcTFzczljQzVNVFlRZGpJQ1pRZSs4NEtkZWR1Sng4VmZCdW9sdHhSWWt2M1ZLdEY2NjFIMG9pdGJEdVdMdVc4bG10bFp1aXN5ejZRSzlNTFhNRzZ6UXlRWkYrQU50RHZOWmVmV29mYTNRTTBTNWY3N3FQWEtPZndvNGpDdjFod0J6WUhIb0lrZ09TRXUwT0NtSi90R0VON254cjJoblJFR213Q2dSbHBBVnpzbVgyUEEwdHZwSTkwc0U3WGFDOXdZQU1lQzBlcVpSWEUrZlgvNHNwV1pmd1c4OGkvSFdjUExuKzU3MmdPMngwVDN4QjFROHl3N1cybGZwcHhDaWdEclkwbHVwd2oyd3RuWVpuL0hwcDY5aTduem9QMmlmZWVsZ1NmMEtLNm0rbFY3d2lhYmVSa1p1MFdaYlRib0NnOTZVTjV6YlJ6RlNEaldSNTNVZHFFclRqR3VuL2IrTnU5L01MY21mbC9iL1h0YVd1dE9odEN1MEVDMzlMMTBtT2Q1bWJlbWdpNWhpMWJiMUttS283eS9teU1qRmRkbFZKVzRwY2RnR2Q4emV0MzRYVTdiZ0NQdjY5RTVyNnpMUUhPcEF4Mi9JVGxvVjEvMUc5anQ3ZFNHdmtaQS8zbE9iTUNDRkV4OUlva3JuUlpIam5hUzlmVG1NNm8wNVhZN3FSbnlLcUlpT2JUNUxaS1VZZVQ1bFdCeWRCSG5vZmxrc2dsWTNXVjd1Mnlzak9zbnZySjlRbElQZkVXdjltSUcrZFBxSnNsTjY0SmtURVk1bTlYc0RvR3E1T2k2WlhhUGFyOFNJRm81dG5qVVVaakVQU2U5cmNhNURSKyt3NUV0cGVkMUxDdko2a0VKN3pVVlpScWxUdkJSM2VxU2h5K0lsWVBZTGtRV2V2SmdmWmE4aWRjSFJMemlwYkdpRWo3bk9rZWFXNWZkR2IvblU4Ryt3N21EWDVNMlgwd2oxbGNhd2Q4TnFDVmQwck1iT0QzNGF6NjEvTWJoWnExMW9ZV1VJN2w2VEgvMy8vS1hyK2xQUkhtWFhFUDdsNTFxdjBzK2FaY3c0K0ZLdmp1d01ZdzlxbVEyVWdxMkpyN2ZYWWNXNDF1clMybHVKdnhPdUxxVmFML0lGcWtieVluQWdjU1RGRWJZSGZVSzg5bTJKY2s4c3l1dW1OY2oxZHNQcU9HeDdrM0sxRmE4anpPTE4wejZMcDlrTUpXUzcwMGhHWlRSVm01ZnFpc0pzM1BDOVluTm14VWxtT3dZWE9kekhPbXhsOVJETHllUDRNWmwrTTBWS2RjUythbGV1OStJS0dXMldpNGVpTE9hUHBOYng3WWVpTFFSWWVJekE2UnJ6ZWpjZUJkcmJER1NvUithRlhrUUtrVjNneWxsOHRNamR4bWhOd0Z0NXhic25oYnA4WGp4ZHhWaDJnRE94cUVzQzNES1hpdkNhRW5NdU05N1JpcjN4V0p6eGVwOURQK0R5ZldwcVE3K0dUenBGM0syS0w0N2dtdzN6RGdHbC9RWWhRanBkNWt5V2wxWjR6VkpmRDFIdGpaenNDVjNZOFZpcXNiRyt2dDFXNDBOYmZ5Rk1qVGNac2VvK2NNNTVvZklwUHpGNUNQc3FndVYxU1JpUlJqNHUrbEFoZDM4dEhIVWxJUEtiL1ZIejV1NEs1bjBCbU9ORlo1akQ5QU4vbTg1M0F2L0d1RmZsNnNuTHQzUzFSa2lGNFJwOTArc1VwbzFjcU5HSW5ETWhmT25HV0tQVzBEeVdjZkNuc1VJemVlL2ZvY1lHQmJhek4xOW1peHZKWjJzSlRxcVNwcFRLeVVSZEp0a1grZlNGZGRQU0xuay9FYW8vU1Nkdm1zVFF4b3NIck9NdFFwd1FzellGOHhaZzdWWnREOUVlNE5ITDArNDY0djJQb2lXdkVhNEk0V3RaMFJvYkVVemR6c25IZGNrSWJvWFpuUmpzL0MwU2J6R29aUkhNNXkzQTdJT2hFajhCVE9la0hab2lzZlhqUEN1c3lXMUZOanUwTHF1L295bWZwU0M1QXpNOVh4eVFyK29tWk9xcFZ0akRFeDdIS0d2Rmh0K3ZzU04rckF4S1AxTE00MDQ5UVh2Ly92ZjljaFl6d3Z1c3N4ODJNek44dlNUYkNMYUhxVTZveTRkT2k0VkxjcXY1czhZNXo0Z1o1NEdtcGlGWlcza2QzaTJqZkU4MUttZVUzL3U4bE11UUxlTjBLZFg5UnRNTjJmNXJNWXR5WWVjTXJ2RnpKVjB1QzZGNFBvL3NSczNzUlcxanZ1b0F5dDlpalAvV2plU1Rya3JzbEhzdnUxeVFDcVRWV2xVVUkrUVhSMHBZZk9iSUNrZUpINXZzS2EzSkpJcFZpU2I3RnQ3ZE1wSzdhdGpNcTQ0eU9SOHZXOW1zUjEvL3Riem55a085bmRENUg2SUZaR2JYKzJLNjFNZ2daeHZJOFBISlNzdGQ0U1VuWDVwbXNrMVNOMHV5UlNXVk5meWt6TnpMYmlUd3FjNU5WL3lzeG8zQjY0WjYxZDdSRG9UMlhBTnBWOGlPNlF5OWVxVWF0dlNOOCtNRVdQNENZSTAzR1A0ME03NU1EQkdNYmNrakdyZkEraXB3WmRNbFJGaUVTSTI2RUZCOWhqcjhVN3hQcE5yem4yYlZMN0pZUkwwS0tUMFk2S2Y1eDNSM3RBdjRCZlpXQWE5SndabGREeVBOUjlIVUJiUnVPcHYzbW9Qdk5KODUvYTR1NHh0cVY4RDV4Zml6ZUJybXhiZmhYRHVaUUlXbnQ3Z1lacHJkeGhXemJXZ3NjY25GUUo0VWRpakc3T3ZrQ3JuTjdXMk5IZWxLdFBLVkRXK1VZeXBrcmg1TlhLUmZqazNkdXZjOXdlOXJwSzAwMTZ4cUJ0dXV5b0J2a2Ewck5rK0ZYUUxPQkk0Nkl0UzJrR2IyQmRpbmFsbW52c2N2c1JCN1pwUmxONnhzemYzNHdnYmNpVnIvZkgybEVTQzZpYkR2blN1WHJuWmZXK0U3TytNaXllbm05K2J6MVJnenhUQm10ZmlwVnlibTZtaHNyUnkzb3FHUFJ4bk4rUllQM1hiOHdWU1FkV2JWdGFhNlgyQm1wN2Mrd1l3OVlDSDhZNUFVR3R3Y0FMbi9GdkpQeDVFek8wZ01qWlY1SmQ2eC9BYllINXd3aG4yV0ZwbHk1V3VwN3N1VEFKMHdoa1ZueFNJZGNtOW50amsrVXZSR3g3VXFJeVNxUG9iZFBLWGtTS3hTejlicHBkZW11Z25aL2txQ3JHcDZJT2xuM3R1QytJeDZqYU9reUdENVJoZEVaTnpNakk1L1k5ZDd0dXdKMDhRRG9DNU52b0dkbVIzandtSC9TM2pDWCt5ZkN4bDdLOUVyTUs0RDlTRVpab0FmUTlkS1p3L2F4NnE0WVlRL2F0L3czRVRMSzdFSW14U2pBZW4rcnBJVnp0YjVmOU1jWTJnMXA3M2hyOG9SZzVIVncrclEzQStuWWdIbjVPTFRkNFVVNzJrZzJ0QnUxL1g3dFduL0p2RmUycFVVc2hTWkp0MHExbEdjYjV2bHhhaE9uSG4wMDhxUm05RWNYV2poeXYxdlk2SUIxanFLZEljcnlDdDI5YXUrUG9YNE5wN2NZSnNwK0dMbHo3V2tZMmltWm5wTVgxRmFhemk5RzJzOTAxYmNNRUkrbmJkbkFTS1NlZGF3TVp1YnArNU5zclFEMEI0YW85NFA2Ry9oTnRGL3Nra29xUXA3U3M1VjZZZnUwV1E3K0RKNWFqQm9ERkdUaGt3YmpJem1qanRtNEhwWFRMaktQODNZL00zN25TanBJc3R1aE5OZjdjSVhLdDh5NS9TR3FSVE81QkptL05jaEpUTnl1Rjk1VFJIZ3hieE1Gb2JXOVExOVBFVlhHbVhQdEM2ajZ2MTB1SFlZU3VPemQ1UU9YdjlEU1VvcTN4akZTNS9jR3JTTGs4Q1ZWSmJ4Ti95NnI0UFBNK3FLcVJnYlNsYUpsVXE1N0hYc1FuakRhc3REMFNOem9Ib0xjRHEzdFFHcXMxeUNMOFJHZWlEYWxDQ0dmcGJjMkcxMXBudVhCUEVLbmVHOVNNeVc5WjdCMVhtMkRLeVc3b3oxMVJiZndaL05MZFcvdkU4a2pYU2VnRHRrSUgxM3VrdS9HdmI1dDhyWDB4cmNsdzFMNDJTR0xFQmVqRXlFQ2FaOU9pcGV3MXFadHVuU01yOWZwdFYzTzFvYkdDSFU5a2IweHhKSG81ZE1jaVo2RFlXRVpaTlRKOFpTVkJkbjFkZExEeGR1Vm5BRFU0MDZENmYxRXpFck45WWtxdXpkNzBaYlIwdjJuaVI5cEQ2OVp0VVpXVDladG1QWC9MZDg5NnRFUHVSYW9PYjRhTng5L3ZlV3ZaNG1paGZlYUwzb3J3WnRmZ3VyR1NjOFl6cXhiU1FqV2RvVDFaZFRjNmQvZEsxREoxaGxvM2NpWFlmbDBDSU5McGsrNEVhanJtcHJ3YmRWN3UzRS91aFVoNWJYQ3Z4eitNSlg4VW9MQ1NSalN0cUtsdEdmc0hyazR2ZjE0ZGpSNTBSOEt2NE1vWHJWZnlhVlV0S1cwTXZ6S3VYTkw5LzJTVUxWV1JEVUdHL1dXeEhlcmR5c1B4YXMvQjNlRlFwZ3AyL25JdXpSL2RGOUtrSzRyMmNWWnRpclRDaCtSdFFLaHJJSGgyLzRZOWp1eFhwWWFCWDBCUzFzZ2piNUkwNWFGeEdkblBrdW1aK1Z2M1ZmdkxRZXRyRHA4Umk4WHV5cWxyVlAxejMrZjltdy9SSFdmZjZMZDkrR0FsZDVZVWtRZXdxMXhZTFY5YjdFeTJyOGV2RGFTaU15K2VTWmdEdnRWYnRObCtNRFkvRE9mWFMvYVp1T2FXUHdlOW5GZTIza3M2YTJuR0NFUHh6dS9xZUVYOG5SM0ZIa0FmRllkQ0FsYS9xc2dXMGdSYzhIYU9pS2t5MHFGYU1uT0UvSFdYbjRiYnNuS2RqS1h6QjVYTUlZUFFCd1NXdHRmcXk5bVo2VzJPeHRkOXV4VE1yVFZyekJiT0ZzSlVZaDJJMVpPdGdlWlg4c3JHczEzaGFhakIzVUIyQUVmcFV3bU1BOFZKbVFWd0pqamR1MEZHSFVpMmpRUDBESEdEMVA1Qk9MUm5IQjZEN3FsYXIwb1V0S0NrUnIxWGgrQ2RFTmdVaTBiWis5TjZmMDR0VTJYRWdlQlJXOVhHTlY5RTIzZHpsT3ZLT1RSMGxFWGJDRlJXeVIxcmFWQktXbG85TVhxWGxuMWRTOXRHMXovZU9iOXYyUWVqYVRLTGNMZnF6UncyOVp0WERHdVU4TDdIUmlOY0ZzVk1MeUlWK2VvTTF6NkkrMXJ4QTBqSFVubnBZL0RYK3hsbjJsaVZFYk12TFdjSERSOEEzR2d2Z250SG9vamJUTG1aR3NiZS9vNytwYzRubEdFS2cvTk5yYXBzcHE3Wm0rTkc5bmdRdmJZeEtnL01vTFhMcytVMFRMNnVyZldYKzE4WGpXL2tYSHR1VGZQS3lYYnY3a1RQMU5HUDArcC92cWRFMWxNbzcydUJEMEFFcHY0RlZIZC9zK1BVNFZTM3YvOC9GRThydjFoWFZEL0liWDk3TmhDWkk2T3JWbnVaaU0veDkrV2JKYmNodytNYU9QVG1reEMxK1MyekVIYzVxY0FjYXJib0dRdWhsQ1h1bFZ1eUdQeTBQWHV3YjNZeWxiU3cvSzFNcVY4VnFOSGdXeWlKYkZHM1lIOGpqbW1sbXVoM1c4V1ExR29BUW01UHRMOHRuWklSelVrWUliRlBJaW5QbHFIWGhtVHJzQWMzaHV6L0lpZXZESWdFNG12bVcxazBJVnd4VWtiRW5XNHQwenBNVU85N0t2RGt4QlA3c01ubGNmcTVlOVpXMGZrUnZTVTZ1ckpnbm9hSHBITnV0aXpUdDRPZEN1dmlMQzNzNjJORHlsTmkrVU1xSnNSS1Y1bWk4Y3AwcnhXS1Yzbk9qZC9XSHNSdTJjWXVVbXZsR1ZVWVNjdkdQU0poblZkaDJsbHRPbTlqSXhtQyswTHFUWGV0VVdicnpOQ2R2R1N5MGdNckFHc1VjQjA1RnA0VE1DbzdGWHhhSm9IZ0hwOEs3b2J0WGs5ckQweW9qRGFvZWk4aVhRT3lEUTU0bEZkSzNPVDFZUjdYUUJ5Y2F3bG0yY3NTZjVlZ0s0WXlZWSswN0I0dkF1TGpvTUg3RXNhUDB5bGEwSXFMalFjUGpvM0wrSzFJL3FMM0JSa0RISUFZTFJ0ZVlKaTJZck15blYwV1ovbkNrcXpxb1AxYklsY2xxdHNtajFtcUVpS2FsWWUwVGx4Z0h1TGF0L2JRYmhtZDYrMHVCRkV0UnJnM05SZkFlc05DTGhLbmpaZG9VeG1SNmIxK3NKdmFIYkw3cGQwakY4NWU5Q09IdGt4cllsNmxXT1RKYjA1Mk5OTW8yWDIzcnExdG1LOVk3QS8xbXg5aFV4YzlPMEdDK1IxbDhtZDhjUHRIT1hoRDRYS0s3MzFWQ252L3RtSFMyTXVKYnh0Mi9STm1UQm5lcjhSWXdyaHluWTRtQW0zdzlQaVVTUEVOY1hPN3NKTERwdUhqT05MczZZUHp0SzZoSkRQNDMyODR2R2UwWldLdHc2OVBMZlNYdzl5R1FuNU9KOVFIcVBiZU40bHR2WXdsaENWTWhnWFZZYVZWdHFuK3ZUYkJSRjcvVTh3K3FQMzZjZ3owaFdqK2hqOVZlaENSdnhzYTRkL0JYUnJ5UlFjUU4vRnlBSS9TamFhbitQSlpQWUo4NVdibU4zL1FTYWVGNUk0eXVFUEpkMHJQb3VaRS91UnhPRjlSV2dDU3l5M3pBSmdBNzU1L1RDVnc0bzRhRGVXQXJCRVNVVXVkK3BITkxIMUhqajY1SGw3UjFLSjk3d1d1NkM3eUJYSXlyVzFNVXlPakw2elBkRzJHYndlN2JiUE9KSldxUnNsMlU4cUxBM3Y2YlRxcVhNcHlmLzZUbHNuWkpKZDRXbSs5eG9VR3dMVy8xbG8yMXo5RmZQakhYeTJQY3BibG42UGtZWDROcnlONjBIN2RHUWJaTzJVbUd3clNhTzJSU0ZWUytrTzNlVmRPU3hiYVRSb0M0dmtDQWZUYkR1cDdZOVQ2MnFvWC9weWxDTVgzcEhoSFYxSVBrMXg5VG5PbWQreUNwS3h6cEpmczAxMUk1cjd1UHdrUTZ4aGJUd1FlVnNlcE16V01CVWxYUzFidTBicXBjbTIwbXZ4bmc1RzM3Q01rbGV6VDd1ZkUwWDFLblhQcmlsYnFrcG51dGEvS1QyY1lwb00xTTlBdnNhU05GeTNyMExVNlVUWlZaSTZRQXNmd2p1WFpvaVEwUU5vMDd2Um1GTjRhQmdxNHgwOXNoZlJUQW4xNCtndDJvWnNiMiswR0lWNzhHWlJ2OHFhTUE2K2tHQmY4cXVjdGtQVnhoeTQ3d1BXZnNRbkhBbTV6SHlJYjYySU5ORHpMcVV1TlVhSDlIcW81MVY4b3BVSmVTcUdTWHluUWN3VXV2TnJYU09ncTRldjF5ZmFQdGJvamRYNWkxS1dsOGc4M2syME5wOFZYZ0FaYUowc0Z5RURzcXhKRkdPT3lkWFE1akVhUHVNQ3IxQ09NMXREaElRd09yQjdpbC9iSzlWRVpQbjZRQmJ5OWlqQzNBZGs3NjViUitLTWRUTUNhZ1MxWFZLdFhqMW5wNVd0aEt1M002S0lpMTVHUVdUZmg4NU1PbFYybSs2ZlNrWTBsbWxQUm5nQjhqd1d5ejlxYWRPMXFvSU4vRjFFK3JSUnBwR1k5QjUxcEhST042ellpcERVRVBXM3dPamVTcHUyMTdoczdDRjZjekRxR1k3NjZMSXF2SFdOUytNMjM5OWJKbDFHakFUcWRFK0txN0dxMlk3bk5sOXdsZStEUjFFOWhIOFNJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hBUG4vL2UvL0NiL0hQZjVNOTkvLzRXOVlid2x5RE1vSnY5aEd6Mi96bk84V0RsTFk2QkU2eW8xNVQ5T3dEbWFSWlBKd3BTK2dONmJRdk94d21WWUhTanF4Y3lMT2FxSzY3elBkUGxNcWVveWdZVDBzRzFla3NpeEd6dXB2OCs0cUVBeHF6SjMzL1c1cTdhaW85VVNjZEJVMWdSK2pTaTBkNmZFakl3NGxmaEllcDI1U1ZLOWJMVm1ETHU1SklBUDBVM2hzeElsMVJ4ZGxhc1kyODRpU2tQSkdzUi9odnlYbnB1VEJzaFUvY2hkc21OSDhTbERVSXhtM3UvaTBjaHhWMEROYUF6RThCWkRsbld1ZThZM08yOUg1alJpSDJUSzIzS1dTbkpVMFcveitPaWsxNjZWSFJsU1JQcDJxekpYZjZOS2tmMHM3NU9tSHA0RXZFbGlNakMwcC9RZ2pUaDBab1hqVWtuSTlzeFQ3K3dIZ1dvaWFNR0YxZ3dwVlpCM1NqZDVRc2N0ZTRrWm9aWS9heEJXZ09tT1ZuM1drOVZrMm0xSUdkT2Z4N3Vac25ZWm5HVXdJT1ljUnJSYWwrU0pXckY2UDdtdjF6RW83TEpVVjBRbG8vQXdYZU00MDlFaGoxYktXWEl0WjU2WTN0aXpaMmpKWWl1L0I1U3dKeDJQMXRZRWVvZnlSL1Nwa0Q4bVNyKzJkMVVtMzlYQTVodStZTVE3ZTFkZW9JWjNaNkRqVGtaaDluaEtoUkkyeGtmZTVSbWJLTE1pKzgyd2QwTjVQUWpxdmU3VUNSSk1rSVUzazdINHNuZ0hhUzAvV3NWSjlENXBqTTYzWGhhaGxjMHlwV0V1VE5oMnFLejlwSTN1eU9SU2NlQjBPY2dxOThkMmRjMDBmRld1Sk0xSkdJby9BdSt3UEhCaGVVeCs1Q243OCtFYWRBU2tPaWI4Qi9MVXBJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnaUIrRmNPWG5VT0I3a2MxaSt5NnpRTGg0WDJJL0pMSGVJanRVTjcvSVhXUnRaWEVJd2lOWEVlMEVPNHlBWHhESGowa0VUeVF6YXVwYmpndGp6alJQY1lMRVZtYWZBUnZGcXdVZEM1L0FhL3EyZFpGa3RiSWtaU1NsT0F2RE9EREQzRFRVdWp0TXRIREc5K0ZWM0VHS2tsY2JDY0swOVcvU284T3RKcWpKRlRIcDlvdTZTVGtTdzFaT0N4S1FVTVEvbE1GMzUweFRCQXE5bWk3R2lqeDNjaWN4VXVKbmhGZVJ4TDZUN3FRZXc5QXRoenZGd0dydldTMDF0aWVZWExkcWozWmRVL2NkcFhUUFA3ZituM2tQRjM1S3VzVjF1M1gwcVZ2cUJhdDFUdnJuRTgvcGJsMHlBeXBId2w0V1ZhM29EbFQ2RmpTdnJiQXZYdHRIU28vQ1RJamRKOTJ6ejQvZjgrUnNyUkh3K1dHZnN6dm45ZDlTd24zRTJrMnMxLzFUUnZzdmIvdnZQMGh1TE9qYzV5ZUMyMExVejlHcXZsU1ZvVjhzdzFpN1l4UFU3ZUxMWSt2aVB0RUJReHVxRmR3aFpOUm1kODYxL29idUpSazIrcDJBVEc3d3BYRUpmYVpiN2NYUmx0UTJqeHlTSGIwdjJwaVVjYkZTa0w3VERFWGhtRDZ5Q3JwVFN4cUQ5Mi9Fc3ZZMDZuSU5yWnNtR0VrTFZZbXRLN3Y5R1RwWlU1bzZVdElqdzlhMGQ0WmYwUG5La2tJNWFhSG5sSUdWcThWNmJIUUtGMVFGd0V5Ui9zbWVQbnVQYjNSdXIzT3J6Rk03ZDZHMWc5MExvUXNneHJFMGxUbmdXUTRSblExZ1NWOW5kcU1oamNrWi9yZmRpcTdsdDR1emNXYWh4V0dPL1JmR2hkdk04MElqREdTZStUVUgrL2hGdkZIZlIxa3pmM2E5QW1xNHNxd1g1RGZ5Y0NpN1A4YUJUTmRhdG5UWHN0cForaDF4N0ZTRk9ucmRQMTJvdUFXQXZZTmR0ZHhNTUtQOU83Tmh0eE85QTZXT3ZJaDREdWkzaUdnelY5ZTkwOHU5enhia1dNMUlrMG9JM3RNYnpFalhmRnBUMEYwd1JrUjUrdE1CL2tDN0VHSVpJUDNJZlZ0dVBRWVh2R21IMk0rdlA0Y20yOHRZMXpFL2pGVkVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRQXBILzMvLytIL0JqNkp6Ky9SOGU0L0FZcktPd0ZoU1ZtaUsxK0I0NUxhcXFkWkpRRzZjZGlhYkZEVlNGa0FNbnp0dXZCRDFwNUFQdHRxSUtuN2t0NnlpM0NGbk9BZDZlNnJrN0JYU0xINTAwdlh6ZUw0dFlKNmQ2eXBMYTJtT1lqUERpYWFlbzBaZGZOU3FtNU40WDY1QXl0UG8rUnFWNmh0THNNQ2Q3QW85SlJFK2hpandWVXVNKzNZKzJhcHUrcHFldnJjazNRSHZ5TlpTbithUDdpVFl4WThMcTc3VWxuckp0MmJIajBTaFRIVG92MndaOElWVXZXYlo1dUMzMCtCc291b1gyeWZZb1FuUXVvV2QrSS9NMEdYbXQraVB0TWFvTHRMS3NkRmFlMWhPelpFaHl5aXRVR09jSFh6MjMyWnJTOW0xOVBQd2Y2SXRkR1VCZExKbm1sMVExZW5yTUdzZFd1RlhXU25xNjRQNUlhdnd3ckJXMTVMS1N6WEExVGFFeWZhMFBoNnF5aXVQYWxLZk5vUW03cEg3UitKRFFpTDhhcy9iV2F3dG5mTml5Uy9uN1pmcWpqQjhmSm9tMTlRN05sUHk5R1ZFMklTU0dFUzAyYTRhOGRSZ3B3K09wUlpWNUN0R0tla1NSYStacWRubWJBRG5mNEViMGxxamU1MlhQY2VsSmo5NllxdE5Fek1FUkdSeW5aSXJad1RkakZGR0ZuVHJwbERMZVJTbWJFUWk1TVJwRkN2Y1FZZlNsK0ZtWnFCUFFrK2NoOG41Rzl3d0JVVWF5R1Y4V2RlV3NHWk9VZko2eTYzQk5WdXFrdCtxUU91bTh2UlJoS2lkR3lDNy9qSXpIWVExY051UjNjNFliRWYzWTZFRkVQZEpZMmRTSVBhblRXVjZFUjAvZmZzaEU3eDF4Ym4wVXIyK0h5S3YvYUY4eDdtY3kwaEh5aDRVRHhHT1hvcDlwdEdWNjg5MEc3YUhWQStFWFV3a2hoSkFMd1VVS2llZVRvK3I4c2pObkVTR0VFRUlJSWVUQ1BHYkZ3cVhaeldFSEUwSUllWEVGazBDelJBZ2hoRHdFR24xQ0NDR0VFRElBM1VoQ0NDRmtLZUFYVTFQNjkzLzRHOWJIRW5sQUhWakU3SUVrcHhCeEFqQjR6STExV28vR3BkdVByRUU3NVBJckp0VUpJQWRPV3VtQzhKeXlGYVVqeisxK3ozbVhXbDd2ZVYzRzJaTUZrU1hrNjZiVDhveWNxemFDNTh5MmdSTlh1ODJTay96MUd0QzRnZmtpVDdoQzZZMnNrMVhGTlRscmVEOEp6M0c4ZzBZZzR2VEg3K3BxN3pGVUhuMm1PVnBXSGJ4MTZvRU1ES0JNMXpIVTFwR3JVaHhhSisvbzh0Z2FTM1BuVjB4UmNoL2o2ME1RWEY4bkxicHRrOHJLUnQzT0kwclpXLzJHamkxa3ZyWnBQYjRkNmplbHdUTFB3UEtUc1h2bzkzcnVoaFpEOWtGR3NldlErOUxlUVY0ditLQ1dPbnBLL1dLcXBZZXpYSS9pc2Npb3ZTR2ZwcmNzeWxwOGswNlRHZm5oMEZhMm5tRkxxSVFuSVg1Mk9ZeTRCSWRQeEM0Ry91SnFWMGlURjdXRkVZMklOQ29pVSt0b1JMYnN5K1JEZk9ySXpkMGF5YW5zbXZYdUtxVXhENEVRc29hWjFWNWtXVkxaQXlZK1ZJOThsVjVDM2VnMkxuSXBlbVpqZVEyVEptTmtXZXh4QlhvK0hMa1AzcmtVb2NBUXAyM0d2U2JrRW93YUtxK0NUa0o2bzJ4ck0rR3dVWEQ0NDdnRy8zdGR5MGhPdEhVeGdxVlVyRFgzakRNUTdaQ2tUbDFHOTUyYmNMUloycUtSNWY4SDlURGFpK2dNOCt5MEpFVW11bFUyUTZRcmk5YnBBdDM5SE5qSTEyVDFZbnVsV2ZKTzlKRzhYMFRrSXczTHZGcnB6d0JaeWwzUXhGOExxK01pWERvaWdqUXRJcVBiSlVvaGxvOG5CYktiaWNqb2NqKzRDQ245OXZlS1p4cTNuUS9vTTQxUmgrT0c4TmVtaEJCQ1NBdFhEdVNXY0dBVFFnZ2hoQkJDQ0RrWkxrVkpNQnhTaEJCQ0hnK05JU0dFa01meFNlTkh3MHNJSVlRUVFnZ2hoQkRTNDk5RW5nMXlITXFvUEFmb1NTeG5uaUFUU25HRzk2S2JJd3VrdGtKTzdTRmZUTzhES2tpZUo0SWNiZVU5UW1TeVRaR0R3QWRWaDVndUsyWDRwRWlTMm5RWmtPVTlXMlVrWDVWV1BNMjEvRjd2UkZqSG5QVFNvZGJMZXdabkwrM0lhSENVMlczeWNzd3FuYWdMTTYrbzhISGRyNEhXMjIyNnh6R2pPOGs0N2NCMnRybDBIblJSMHZUeXR6S1NFSTdJODRQWUY0blI5TDNHSGowSFU3c3VRSjZrbElrY3k5VXVHaHJiVnlmdlVZWVNkN0JXTG1oZUszL3JVV1VsWjJseXRlbktMdmNmdCtJZGxyVXlVN2VlK1pXeEZNR1dWc21sTDZYTzJyb3hMRjhHWFkzMjVQWGl0VEFQa2piczFhRlhwOW56QUVmMVdwdmZVN2J2aUdTNUYzTXpKdmYzWVI4SzJML3YvVmVKdHoveXpyOHNxaTc4VFNPR2E4TlZwVjVMVkhYNWUyMk1uZDRYRmt0TzlsakxuZnFnNjZMUnNZWElYRkhHRGVpNEVhYjJVcHEwdGp0L3I3VWhhTldycE1NSGY4M2hqR3hHWkNPK1Y2ZjZqNEkyVkVweFgwdTFibFFvci8weWpDbjdMVVFwRTlsalNFb1k2ZzE0TzFncUExczVITzlxWDVibFgrVW12SlVtbGFYN2VKc3R5eDBwc3Rkc3RXelVDQ1NFN05IOXgzMzRpQmZpMVpnZVRTblY1MndkOGxWNkthS3lhR092S0x1dXcrZ0FRV1RYK1ZzRE5lSkdlTkpwazFDS0k5OEZNalk4Mng0elpZNXVCWmJtWDQ1Sk1rMVA2ZFh4SHVzK2F5UzBmVGRrbmRoR1cvRmFSTHNubHB0cWx1T2ZHWjJRMllpTDhLUXNKZUh4OXFTOG8vbHFMQm5JWGtUN1hLSGRDKzFzSm1WbEE4b2k5NFBQOEV1OW84QmlaSmEzZWExMEs5MnBiSlNCN2pEVjRjNWRkeElCRy9lYW9Hc3JMWDEyaG05eFVXNEVrdjRoWXk3MGtjWkUyYk9nOWhheE81Yk9mendqeTRJMkxSbmlsSzBJbzVEM3ZCRGNhTnBzMHNXNzcycUkwbHlGbE95aUk1ODRqNjdCYmpOTlJocmc0VHFDWDB3bGhCQkNMZ2pYTUhlSFBid0t0aXk1SlJ6WWhCQkNMZ0RORVNGZkNDY3VJWVNRaDBOVFNNTGhvQ0tFRUVJZUNwMEFRZ2doaEJCQ0NDR0VFSW5taTZudGI1L1JvMWpJMTJJZGwxV25XVEFVSW9wRWJpRUVqM0RyeUFMbGVJRDI0THJjbEYzcU5NbDNlT25NWVM3a1l1Uk9tSFgwQkhJc3hoMUJUcEMyVE43SWlXWk9yR3BhQndPdk9TUmNHMFJ0ZkRieUliVVpiVXpqbksvY1M2UGtNY3ZxMWRtcmtXZlRiZlh3V00yaWxLWDFaMUxTUzBGemsrRllrL3dLTDRjMFd0NVJIbThiUjNTaWxDOGwzQjQ5bmQ1cG1FRnROSHZ3SnVKMnJPMU9WQitONlBuZTNXbDV0RFJJV2UwMUlzZDdmMm1mWHZyU1Y2bmxPbVJCZGVrdGhIb0QyeXFqR05jSXN1M1d2WWpTcE40V2FVMC83dHE0dEVKZTRmc0YzdmFsMU1OY0FyNEVGei9mdkt0dnFSL3J0dTJOanhFTGp2bzRtaHhVWTQwYVFVdVdsTTh6cDFwNXFPN1FSN2FVZHYrMTBpek13RkxOaWFOdnRyK1c0OU11VnRDc09lOWEvdTk4Mk9aSzN0KzNObGQrdjBiY0ZQYWJVV2lDbkk1Zk9VMjQ3eUtWc1l2dzltK1AyZmdSdk9QMTNyVDdkaHU1K2FNZ2pwY3hUVnNUSXNtczZ5RXV4eFIxWGF6bCs4aXlGMVh4YjVsTnhOQW5ZYXU4M2ErYkZtY1p3ZzJYWGxvcHN0ZDRxWlBlcWxkcFpCZUhERS9ib21sLzZwRGQrWSsySW9zV3FDYzFkK0o4M3FYbTRWZ2VBU0VraGd5R1N4bzFHL0dvWnB6eGNEVDlnNEs2blYrTFpRcDdONHo2RzZNSzJ4cFVpTEZBWkVyaFdycVJNcjExcXErTGtTZDE4a3JweVBlaWpYMVBYbVFkcElWclkwNGJlNXJNSk1Sem5CSVJTMUdmWVpGbnZRZ3BEMmdVRHZOVzJYU285OUx5dG9kbUdWN0xTR3p4LzFUWG8wWWU3U2RycjdlbnFDeGppYXc2dldWYklwUzJiZmNsaTVhKzN1K1lVNUtISVhTQ3pyWGN5emF0dFd1RFZCbDFTK3N5aTNMZHBxdXZrYko3NGFoYjZJVXU0QURvR29XTitYbVF5V2R0dzZKdVJJUkphOU9qajZJZXhwSkhHa1o2YS84NU5kZm9Wa1FiSnVHMWpRVEEyc2ZoM0F2RE0zNmx2TVVoczMxTW1DMjN1aGJXcGtsMjNjZ0R5TXExcGp1a1BFMThHUnh6U2FsS2oxSC9mbVQxKzFYTVBOTjRPUHhpS2lHcm9HZEJDQ0dFRUVJSUlZU1FMNGZiRzRRRXdjbDBIbzlwNnl2YzZIbDE0QlFpaEJDaVFpTkJDQ0dFbkFnTkx5R0VtRkJWRWtJR29Pb2doQkJDeUxmU2ZER1ZaeHM5RHVTSWxZVy83UFllZnFseHlvL1B0Wk1MUms2dk5ZcDRVK2FyUkI3R3BTYk5GNENjREoycU5HMmVaT2ZybmNxRHBPMmwvNmZKaHg2d0lwZUkybjd2R1dCdC9KWUdPY1BST25icUZhUXB6eUxKVW9vd1FjODRDemo5VkV5Zk9uVkNaU0NudWpheWtlTStnOG5lU2JhUXg5bFo2eFNuTmcweWpWRzc5RFI2YllxMmxiTnRNeGgrNGxKQUtXWDJISzdvOUtONXBId3o2K3hpeUN5ZEttUTVRbFZvVFZtSElqVHZwaVRiSDBoS1BKclBBM3AwV1c1aWk1SWFVSHBxa2R1Umk3dC9mdS82L1pWSGU4YjlTVnNjWDVQNy9icmxvVklKeCtOSG9MNVFuYlozamRaVGs0WFdvU2RyRk84bWl6YTNVUCs2RHZNZDJ6cW1HYmV4VlpycjN4US9BY2FSb3hXbFNwKzNQSzloVU5UMnFmSWZtcnFucjNwcDZpUktQMHBmV2EzVFd3WjJ5dmF0MEprV28yWE4zT2Yxc0laeFVmS1V6blc3OUhwL1pIc0xiNlpRYlk1TDM2VGhGVVhVZXkrdURNUzNOM3k0VWVWNmsxM0xWUFdNeDlaWitZcFMrQmEycFVFYk53S3ZiTlJHU25uUWN2czI2OWh5ZlQ5c3BJelUyQ04wVkl5MERpRmtMY1dSSnFmK1N0VWpwLzYzamUvSnRsWk5kVHBMZGkvdjErZ3BheU1LVmZrRmlFZVdsdEsxMTFnZ2FLNEEwaDVudVJIU3dMWFEycHJjQTJ0ZGdjNnB5THBvc3JVNkVES05OZGhHOEE1a2EzSGRYdmM4RDJzRHc5cm5LZ0ZyYlcyaUltM2JNNXdSU2tjeXdJampVZU5WUkFVSWErdGlsS0UycGFkdWxoRXdSQU5GZVh2Tld2V2orZEVaTWpLaVBFODBSa2I2S05vYXhRczZndHF5YnN2SUdtWlFQZFBIT1JGUHY1YkplQVIwRzlhYTJOWUd4ODFCdmFxcFJ4cktkVStlSmFzTjk0TFVGNVZ4dXlFejZvajAzRFNKeHhqRmVEem10YjEyenhrd1E5M2Q2TDV6MUVxRmZBbW9INEVxNkFDOWtjRTBLNTVwM0VidG9kczRXajZKMnphV0RMK1lTZ2doaEpEdjVLdFhjNS93TUxuelFRZ2hoQkJDQ0NHZjVuRXJzOGZjTU5mY2hCQnlSYWlkYnc0NytEelkxb1FRUWk3QlV3d1NEUzhoWHd1bkx5R0VFUEpJNkFJUVFwN092M0l3ZjdkUHJrSEVvVVRUaFh0K3lUNTZRcElpWitia3NxaDA1S0w4NlVEMHRDelN4OXRtazIwOHN3RHhxcHd0VGU3V3BwOWlMeWtCYWJValBqeGxvWFhScnBzaVhiSm0wcS9Td0o3elAxRkQwMFp2cDk2bUMxQTZWMmVXM0QrMDZGWkkwM3ZVcHhsTlI1YXBCczloVFNPSGJzWVFhU05HYU10R2JkNFZjUFJPYWM0OVEyMWtzZHJCczJBYURVZmovWlFKbVg5emVpYUpldHQ0SFR4ZlMvMHBNcUxOVnZkTFQxUE5Lc2ZSc2JhbHljYTFsZDhEY3I4ckZvS05ibmlIbG03cTQ2bUlSVTZZT3NGL3huUDExWVUvNDN2WHdzWGJ4dWpSbE9qWTZ1aTNZdGlLMHY2Uk8zVkErelZxTGFXTjQ1bDFvWFdmTjMwVVovblJ1ZFBDem1rTHFmOW9NemxUSnJ6VkFLNVZXOWxSc3R5Z2RzWXJaMVdleVB6ak12UmhZdWpTQS9FK2U4K3lSMDhwUXNnNnRQMk1VVGtlcjJpMERDOWY1MDBWWjdqR3hKWjMrUEp3aGtnak03c0gwU0sxc2JlK01XYVpYQVYwcnN5dUZ6YWl0am1pakFFaHcwUWFIcS9NVVhrYXduNU9jM2tPcTFacEl3b3N5cm14UUpSaWFZSWRIZE45cU5IMHR4TGxaWGFIZjBWNW4zNmlzV29xUmJsMGFEaXl3MzBMWnRTMkZXOTllWSsrekRxaTFmY3N2VWMzYVNEYyt5am5Ka1E5MGtEMStTeWplbm1tREdzcGRqdWlIUkhrRVRRSlo3VlAwM3Q4V0tTQXZHNmxRcjZFS0FVZG9ET3UvRXpqNnhoZDlyZWRBQ3k1NzhxL2lSQU5iV0dpcFEzVVBPMnJoTmIxMTNMYkd5TkxRWGIyT0pZd0VPTy9RTGV0cHUzK3ZnKzd1bGJ0MXMxTUhabzc2L1hWdThoOGpDaHRZa0cyR1I1SlpCbklUcVZIM0V0ZTBTYUw1OUZLR1l5M1N6eHJVL0F4bkxIN1NmYTAra3ZTWjFMYXlTS3RuNldjNjZKK2F2WGRXc3VyRG5EdmowT2IreWpTdHFqWGtmVDIwZGthVzVvOCtyVi9YSGR5L0xHWGRSc3Y5Q2NQUlM4VEh6SHpvMlJZVHZ1TVB5S0ZTNjlUek9nS2p3K012SFhkbTc5SUdaTE1mZHFZSHpUdnhSNWFlcHN6cngrbmJqOUMvYm03TE5ZaHY2Um85ZXU2cnI5Q1hwV29LbGFLWE9HU2p1RnZ5bEd1RUx4UG43WEtwTDVsanNJYXg1Nng1ZUZUTnY1RWhDYjlheHFxSktZbFA2R1p6RG5pVmR2SXVrSGJEaGdaNHEyOWplTFFNSlp0Q0MxY0tPc3N2SjFpS1Zla1JFMlBIL1hQankyUVpQem1rR09rS3p2OGpONG1oUGdZTVIyelhuS1VpWnlSb2UzSm9HWGNVbi9OdXNrcnphMjFpWFptMmFQaFc1elA4Qkl5aHJSZEYwRnYvSktIRUdVRnN6TU9VWjZyOTBobkpsVzdhRmRrald4TFRrL0NTT016MHdkbkdITzBiS3N1ampadk42NXFFUkZiM3ljUXNkV2t5ZlM0VVpLTUZhWXVLWFZCZHJIT2VxTGhVaEdFbkUzRUJJOHFLeW54MHFPYjBRbnMyYnQvRURPUE5MeDhjaXRpQ3p2emZyK2VLQ2VBWEpMRG5NbFkramJzOXoySHBQWTNoOEZObWRVUldqcUhQZmF1ZjZKMklpUVpLMjNjVjBQRHloK21QcDUyaDZER296RUd0Y3ZvZTA1TGxkbVpoU2xsSVVXMitvc0sva0ZzSGQ0elhCd1E4eXhzUSsvOExVWTQ0c09NMzg1c1ExZ1A2VHkxQjFhRnBWTmtSc3I0QkJGbHR6Y1lkVDhkT1dYVWlvL2w2czBacXJ3Z1VBZUV6R1BwcXpxZEZCNVVCWTFuZFhQYkdWR2V0V2w0T3ZtMmVvekVWMmxLbTBkS04rSkY5QjVKZjlKSnhXUXZxVUh4bGUzZE1FUmt4a3Y0WkY5NVY4UXpXQjZIZHIwSzFNdnh0cUZuM3BhT0poeS8vOE9Qa0twQzZpK2o1azRkckIvTVFsOFVMdDUrQk5jaXd6K1cwMTdkOGRnanNJNkhzcVI0TXNTcjZkNi9tOHpqejVXMm9iU2lOOXdmSVk1STY1MGFKV0lOR2xqbWI2SzBocFgyZHJac1pERlN4SFMvV2lrM3FRdFluN3pNUTNGNDA0U1FpK0ExVDZqMlF1V2RqYllpV1BzTTRLSzQvUWhuZUFTUi9sVjAyYWlNM25LeGw4OUtRNGhFTWE2dGZOYjJSakxTa1JzVHJYQUxHRFlxSzRMQVp4cmF1aGpaR24xdlpNdzgwOUR5akRLaWJGYXZRcTAwdVhOZGgzdks3TFM1dEVjYU9LUlcwdDVkWkZXamR1TTNrRjcxNGgzTlo1akVzNTZlRUxLRUZmck9VaVpubWtRTi9paDFPQjNhZEZmZkR2Z0Q5WGJGckN2SXhydzBSUWt3dXpjTE1qS1VuRHlGV2VQaUdEUmVOK0xDUzdwNzgvRDlTZVdIcVJmZlpTQ3hyTml0R1FSNWhlNFBwMVIxcEREckRXTXRYaWxMQ281NFpaSGNBSy9CdXRBOC8zb20yMUtidjFLYU03RjFDS3FoTFJaN1hsbTRFNm5ScHlkRnhLU3laSGhIeG5hRHhWOW1OdEtGRGxKZjIrWERWWEdNMXdLR0k3RTN4bkk0cEdzeVQ1UmFCY1U4Zk4xcmtJMXJMNkxoV1lTaW9LWDVLbjVscktUZnI0U2xCZldwdzZWUnFHMmQrZlIzQk9hWEdMVWFsTDdVWG9LWnU4TFZjbVRielJxREtQOXBabzVaUGtJdnJEZSthNG96Zlp0dlN4TzVHWUhtTFZYby9xdWx2M09remEzTUhjVHZycjZVdXN1eXE0TlF0NWZlS3RyWERjM1BRcUpqQi9HckkranQ5R2pwSThyYXJyMzVQZUUzUjdodDZVdXBRMXBMZVRmd0xic3pQQThmOHQ3cTFFNlJOcU8xTkMyZE9FU09LTnVhcnc3YkFYMDJHYWtUWGlTZWFYU2p1VGpDUFhLdHVzaTJRY1llMmEydDZQbGQycGRTSmFsbjRXa05Rc2puUVhaSU5ZL2RvMW1RWFZoRVo2Q1BEVjEreEVwbXpWQWtVZVozeVBZSGdacmx5TG9oZzh1NnBrRzhCMUZ1NVlhMVhoalo5cGpaeGlIa3NtUXdqV2RmS3R2aVV1cHN1emViQ0QwWk96elBwRDlwY0ZzaURiRFp1RWE2MWlBajNoK284TXlIR2xVWjBwQkM5NEdDV09GbWVucXhkN3VqejNCU2s5L2owMGU0WCtnSUtzNzBvMmtlamFZU3RIVGtzNHdxcEROTUhUcDJPTVpVWmg5cDlPU015RGpMTTJMWE8vSE1aemJ1NldoYkRWSjhuU1lyL1hwNHZKajdaWi9zSnBOdjRnTzZJL3FaUmtyMmRydDJUUm91ODFEblBKUWZwdkpwQXJrbUQ1eWpCemc3Q2ZsTzZsZUxyNmpMYnF0YmluRTlKWml1OWQyZ2pTVlA0TDZhQzlnaFhDNnJnR0VKa0QrcWtWNmVocm9iMnZ4U1phZ285STFPand6a0J3OWVZcDJBUHorY0VPK3N1M04zQmNzU1dRZXZyQldPV1BzVzQweCtLVng3SE5sN3ZHSEpUSTFzUk1mTXRqVWE3N212MHNucm9MbjkvUHB4cXR6eXBTOWptTnpJVWw3NjBuN1EzOHJ3bHFuR28yVjV3cVYxeTFWWHBmZkQwOExlR2VpUjVZMFhNM3hzdUh5ZzhEL3pQbk4rUElrVm5pZ2g1SnFnOC9uTUZXaWtqU2VEMERVbVQyVldxWlNKTkZGS0VsMEdFd0lUdlg4NUV0K202YjFsWU8zWEdXWDlYZjhtUng1dGo4bktGMFhVQlArRW9takxQS0Y4dFV1RXNkVGJRanlKNkIxeE5NMHE2aVpkdVJ0THMwY0l5RmxtYWpiZHFBelBJMGp5bDFIOTZYMXlkd2EwQmVScGpLNjRDcmhIc2FWN3p5dE9NRUxJS05JMmp2WmFXa3BmcjIvK3haSlJxejZTZHNFU0NEcC9wQ3BJNjZxbGEwZFBPd3g3UEUyUkFXM2Z0c3ZDN2lSWGdoM2R4M3FPVXRMNFBPNklSY0o2OFJIZEdhY3IwUzJXMGltOWJlelJPellHZktuaURnM2czYzJUNnJocW9tbjMxYnRmYlFDM2VRd0wzSzZzaTFTT0dLSFVTVXFMdFZ0dThoZEhYdGpnRHFDTjVzZGlLYlNuMnlORXpXVWpiOHVncmZjVzgxeWlXZ1RSRHRxVC9wVDB3WU9zelhOVkJhRU80Zyt0T25JT2pOelhLRnA3WVAya3ZiNmpwZkhJMjlGMmQxdmQxd0x2WGZic2w5eUdHUEV2UExJalY1OUkvcEhkQkFScFY3QU8vell2d0dxSG4vczZmaG0xaUNsNzEvdjhLZjErRlc5TDM5U2xhdXAvOHZIcmVNVXhUK3lQSk9iOW4wVkwwL1ozTFR6NUdNb25qVDFQUHEyWGV2YUdSRkFPZjZUOTd4cUwrT2NyNFQ3aWZUbWpYaEJUTGRXaFp5UUxLRThkYXNwRWJhL0Y0UXcyaHRsb0R0dFFvbmVnUi9KSy91QlpleEhvL2N0dHFuMFJOVGNEeFBwaS9UNnRWRklka3B0MFV2djFoM21kWmxVckUwTG1RWGFmcFRuY00xZG5ndWloU3hOb2JzMThsbnRzTFc5REZ2eVZiRVNlVmFjUlJwYTFkZGt6WmFJeXVMd2dzOHpPRlduYmhwQmIwTnZQY1F6NG9za3IrS2JmRnRrZTVKVFJaeHJvTXdscjdWbVMvN2tLNmtqTXJOMXJPVkpkU3JJTnJOUFJVamRGRWNPYzVlS3puZXdzdkU4MGVpTk51bzFJazlIYm5kVzIzU3hHWEZsclhZUzJIVjI3RTJHamZ6Y1I2NzBSNlBOTzQzbDZ0cks1blpaL1NsYWI1ckZxQjIzVW9xVC8xTHduUzhqYU05cnEzN3o3UTVEUjVLRkp2eW16Yy82aXVnUGREckJzSTIyS0VGYUh0L3VXSFozeTdZQS9UTDF4Q3hBZE9rOGZKN0lMMkowUGh3UGdWaFFqdk43Y1B0K0NveVZHMUs2VFgvU2F2OTJYc2RxcmZkVHdpVHA4WjFsb3E2MSthSFVaV2lXU2txMTR5QmdYVlV2ZjFhM29GbnNHNHhGZGFtMHBlbVNoTXRISEVpbnR2dkwxL2hGcXJrU2duc1FNNlBiVldqaytieU4rNVArV1hhci8vekxyQmEzT01TNDdxcXplSEVMbjZRaWFUb2h1d3pPMExhWWoxNjRiT3JxbGZta3E3L1ZZdi9kTEk2Ym9jbDg1MURwb3BjQTYweE5kZ0RwWTlzcURObjZ2NW9Dc0czMmY0bW9mMnp4RDIrejR6R1lFT1oyNER2N3pBOVd5YU5Cb0ZxQUFlUWdoOXlKNjUzUlcxc29WelZmeVZOK0JQaE1oTVl4c3h4THlGU0I3U2NrUlB6bEJjdVNPZHZ1MjVsME5ZbnR2Z2ZlNVF0KzExZFc2cmRlZGdWV0pTaS90aks1NERDNlpJYWxKVjQ1Mm1rSkNBdkErM2orVHFNMElya04zYVByN3JyRDdBMkZqM2dKTk5Wclh5UmxQQ0xrWjFycTRmV2ZpQVlzMThJZXA1QkZvRzBnTGkwcE5rZHJwRVNkV3plY2R0RXBDdWs0SjM2enJGT05JVG9pUEoreE05dVpwbTJiUmhFUEVyU2g2ZnNHRExySHEycVBiTmFnMTZNa3B4N0ozL1oyVi9zK0FiQ1IrcHRmUVBMMjJsZElXb0F6Rk1FR2Y3QzVnMlNnOUkxbWNFcjM5c1UrditTR1BJU3RoUlVsRHg4U21wMnE4TzFiVzAxRWxlVzlXakx6T0lPVy94bEN3ZnRDcFBlcVY0a2RuZndiRHREcDQ4MG1peXUrL3V4K245c3J5NHVsNWRNR1VIREo5ZGJCR2h2VkZyNkxZaUMyc0tMZFhYdi9UUnQ0NnZJdlM2TExRY1NGUmdESlFtWWpQVktkcnIwZDJCMWQ0RXRhY3NiRDZ2WWd4K3hKLzZtQkx5cUxFUTA3aEpQK3lYVGRmZFA3OW9kSmVwdG9mNXFkVDJ4bFpaQm5GaU8rVzRiVkh4YWlqcHd6RW1VUExPQXZMVG44WVl6cVh6aEE1eEJ2TDNNTUhSMHFUSERkOVJ6NngzRDBvQ2E4VGE4MjFFV1prZVJ2UnNqT2V4bzN1SUsvSEwrMUZaS2d1dWZucjE2L0tRa201S3VrNGVmUlcyTWNYdFU2NmpqRXNBeUhrdzNoMks2M1ZFT3B0aks1VXBUcDQ4cDFkNWhLaXphMUgzb2laOWNwZWtVOHlzOGhXeXF5UGg2UmQyYWJrKzVoeGNiMktDaDF6R1F3anhBUVowTnBBMWhSMUVtVDB5dGJTQS90WjVsNlJzWmVXaENJdDBXcFpHLzlSd3JYQ1VHK3ZGNCtHVzJXVWhQZGJVZVMwWVNQZW5sUGh2dmRTT3NrUWZWeWtkRlpkNHZDYUFLOTdVdmNHYXA1bW4yaTBUU3FOaUVpODk0WE9NSnJZQ1RSVnNYNUtrVWhHbFliSGpJMzZ6VjVXSzZJdlJIOU9lZ3l6OGtmaHRYRlMzdGF6WWJjNzBScXU1OXF4a2NNeHQ4cjJyeGpzMHFYa21FdXZETGtqeThoS25zNk00bmFDUGFuZDA5c3U5cXhRNjN3azlSdkNzaCtJakMrQ1AweDlJdHJDNGtTRlNPS0kyR0lsWDBqa0JnRUh5eWw0OTQ1bWVGNlhOaE1pSi8ySlFuampjTGZ1emtqN1M0K1pYM1F3SG92SFhsMTdPQ0RiSWNqVDl6b3ZtcjVYcHBaMnRFeExYa3J2TDZhKzVYcnZJMVY1ZS9HSXJDamxFam42TUZtcXhWZWFGSEUvUGp1SElrcEgrOWZLNTQxZklSTjlZY2pLSThYUCtJcmFLeXhXT2t0ZXYwNnRPNDNKS2sxd2s3dno0N0ozV2E4MHV0WXk3aFA1QVZzeDdxek1sb0cwTWFLWEkxZVEwdU82VVNMR2RjMlpLK1VUbUdnV1BzaHBxQS9aSUxmanp3OVVNelRLNDhkQUFjTUlJZGRucFJjeDQvR01ydjhpWGpZa04rSU1OL2xtcmpnNWdlSzhSdU5HNnFCdGpYQUpRWVpCQm5SdklNODhqQjU1L1JPTkIvYTVkdk1tLy81em1GUFd2dVRvQkpRS3UrT0VIcjJud00wbUxRek5leEhPZnpvVTQ4dWpUd1dqc0Z3OW1reENCcGhWR3RwRGdJaDMyaUpmWTdnNW5tVU1FdjhOWU05OVNRaHM1Q1dZMnhFRnkrY3REMW9PRWVJaFFDR3ZXaitRQ1hwKzFoTzJPeXBlUDB3OTR5VW9jZ25xUmN3RkI3YnlXaVAwS21qWWFOVXFnUlNPcmx6QUZVMWtGeUczUTc2RWk4L2pTeUhOWjB0cFdKc3hFNVBJc3Jhb2FHMCtJL05jMTVXb3krclpyZEllVG8wMmN1N1VxZWxZNmFTUllyVk1TbU90cWcycU0vMG9xODNRK3lyN1lKZnhRSTJnSldXZnIxZUZZd3VQUGV4RlJ2MG5lL2Qwc01hZWc0N0pENGhSR0xUMVdibEdtaHg5V0htTjdodDlvYjBZOFY1NVNTbkRLcnVWNlcxVkkxK3BITWRjUGQwcUVYVllPUko2TmorcWhQeVN1TGNGUlV0WEtndVZtN1NLTS9mKzhHSWIzcFIxL0dycmVOdkdxZXVJL28wY0krMU8zVmwxME9heFZBWUs0dnYyZWhLcFV5MW55Nk1qYVVUdnFrQ3ZRVHUrWlRtdHYxV1MvRXorNzNYZTVtVXJKVlU1cFBBcS9lN0xxQ21wUjZtYS9yUWdHNks5dzlRcE80SklXZEY4d1FabEd5MTA4emFrSkwwdnlyU1dUN21mL0ZEMmlKb0Rwb3FKZFI5YVdkQlMyNmlBZWdSeVZzcnk2Z3F4ME9UejVhd085NjE0WlJsU3ZsNThCSmpzMHZ4VjI0VDZ4Nm1sMjZaN1NlM0VMRWJwMmc5ZzUvYlFDQ0VyMGN5d05KdmJlWXFhcFFoUUhYR0dWcjR0bzl2dVZtTmI1aGVSRjdXRmdyZ0NxQnRoTFRXMVNhUlJPbVdTN3lScTAvZUtpazNhVENEa2RDSzlBMjA5dEtETTBsemtaa1BpYjdEMG5FR1JkeWhUdTliaUlpYTBaU3hYT0JMSVhxSFhvR2FqYktVdWgzMlFMSXV1OTBucWZxMDN0K3JuU3J2OGNjbzJhdTN0M1dGWmJjYVFYWTBJTnpNSjhyUjlkV3NFZXRaaXhJblZzVjdWUXU0SHV1NUZmZnJSZVBKbXhJdEFaUFowZjR0bkN3RXBteVMvSG03emVmZVVTQ2hSZnFNa1Y2SmVrWlEyb0E1UDdINmlZTzNIRmlPdGcvOU1pUEhhRzIwYm12UGd4YVlyaW5GOVExNC9UTFdzS2JrTkR4blkzMDV2czJkMFZuSTIzNFF5R1U4K3pxb0ZFa3EvN0VpamtEdmhaMnp6TjBidVk0Mys2UjcvZnE3Z3JxRHZJOTJhNkJ0KytyVFFuZ2grZ0pFcWZGZjNXZlpvdFlhUmRwRWlPNzdzL3ZrdHFpMHJjbVdSQW1WZDF5dFM0eDFEQnIrN3VGY2lTcGlzaUw2SjdOL1IrUnF4M3hVOFgwUFNvdTJCM2Y5K0ZvODg2YmJMMEdpMTFIN2Jxc2podlplcVRzUDdHby8wVmtHZDlvNGU1eFU4K1hPbzM5a3N1ei9HK1lTV0lsRjg2N2cvZjg3NnZwd2FPOUpMVUJwQ3lIZWllWEtlMVJTcUk2aExGbkczYmZlenRxazg5Sll3NURzWjNBbzdoYml0TVVJK1FQU2VXWGFrWGVHUmRKNXA1QlZ2TUdreWFYaUdHVm53aW5uTzZZTlBQTkU0dzh6MGRueFhQQzNVdUp2Yi9EaW9EdS9OeUthRDEvUnovQXpqOWNMWTFBK0JldmxXYks4Y3dDc1M5ajN4c2xCbjBNZS9NSi84NmNTSCtWY081ckwwMXV6Zjh2c0tZL21SRjBYUUo5TWVabzZ0cVVTVWlYanl4YkJqL2ZUMFd6M0hJOTR3Y2RBK1Rob3RJaHZoN1dNaitXWHozUHc3V2lvYUw2VXBnK2t5VmthUjdoZDl4SUcrY0o2TXVtZ3YrQ04xS1ozMFVRTzQ5SVBmWDV4WnFZaHk5ZitmRjFUYmF0UXArM05uenVCeUg0R0VnYWd0eXlpYzhLT0dlL3FQSS9iSWl2ZW1senJUc3J2ZU1vV2V5NmdNMUpPWStiRkFPOEMxTXFUMHNkZ2w1U2I4SjhkN016ckxjcm9tOUoxWGFWUEZydWJtTCtrclluOSt4RkUrTm5NL3BUWHFPZFRpOVM5SFZ0WGFlTzZsbTZWWHBxUlR4dTk3RzFQYU1pbS9RdlM1SkkvWDB2TW5YMTg3M01zb3gyMnIzUGlKeFpqUnVma2p3b2ZWL09GRDB6WUJ1MHRwYkdnYmROWVkvQlJvSGJUNytoS01LdmMrQ3ZFZXY1b3FVY3hyYnRKQ3c5WmVHTzJUdDhNWW5ScmVMaXk5UWh1aDI0MGZvb0g1ZTVpUFNwNkNWRlNvVzdjRGs1RzNUZS9kaTJqenRuNVVleTNKOG9iMzZvZVd1YytYQWZ0VEFCbmJYM1Y0TXZkcDhIalV3aE5DenNXanZhTHhsS1ZweU5RSmIrTWV3Y2lTeGZKMVJreWRsUjd0R0crZDBNRWtwYmY4U3UzYU1vV1M3TkZ0cVM5MCtXOUxoTEtNVkZqYStQWEUxM1h3TGtrOWVRaHhZdzFnSkg4UGF5Q1BlQnBBbWFXNWZxL2YwWDFaTGI1bm1DMEQ1SFVrWnBTaDVjMmhCbGVUaXpnM1V2bENmRGJ5ZVI5cVZPRi85bU9SdTA5S0RiV2RUVStQUlBhcWw2aXlwTkhkaHJmeDdaZU9SdHpvSXNoQXpLMEdYYjRCbk5PNW00OGRFTXVaeW1SbEhieHJ0NGVObjZsSEdzbTNSQmt0cHk1cjFWWkVIVVlWWXVBMXRJZ0JKa05FcWtpMVc0MUhrSC9pTlYyZ3JSWkdWd25reXhnWm9Kck9HQndrc3l2VExTMnlvK0JkN1Q2T2tYNjllV01wUDB6OXBPZE5salB5TU96SmFEdEZHNEZLQXUySzNnS0kzWGxqcEk3bmdtYU9tN1Fic2htL0Q5c0cwN2MzZ0hBUGQ3Z3RsVnZmM0NWNW5FMmxFN0VleEsrOFNEOWNxQ29MUUI0RmI5Y3B4ZXBlcll3MFZ0WWhlNVZmK2xGR3poMGgzaDIwbVJGeXhkVk1iTm43T1ZTcS82ZVVtN0owRjc5WHAvdTBWVXpacUo5VUp0SzByNHRZc2lMYUNTMHpvaTdsc0VyNHVhNi9adGVwZy9sRHNHTGsyZmRmWGRMUEQxRWQvVnNBZlFiL1dMV1Y2WlRqK2xHczFkK1ROaU1VeTBiZVpjMjVpRzlybGs5MDVaKzVrei9WVUJ5N2QyTEc4aE5DcnNXWjJ0bnJ3Zld1clhEeVF1dmdNemFvUG1uNlAxazIzWjE3RXJVVkVjWHFyUlByZ1NqSE9WbEsxQUJHOXVXZCsxaWg5SjVwakV5eVQrNXYzY3pvaHpWbHV4K1pqMXU5b095SVVheWxYL0ZFNmd4bW4yZ2c4aEU1RWJ1MTNESDdJR3o0T0s2d09GOWxybnZoRHh0RDBtMTdtaDE1UW5jbHFKOC9pUFhyTHVMbWpHME44L0YrWWxlU1lBTDN2cTlzang2SDFSbTdsNTZhOEp2eWJ5TFA0aUlhU1Z2eldML2tsNm8vL1V5eXJZejAwLytlVVJncEszWEtTcjVOSSsyYTNCUnJ4YXdObnFjT0RrOGJhZkUzYTd0Yy9UVjJhOWF1RmFLWmV1RzFETVFhVkFxNnZCVDIzeUNsZnFxeTdGbWFYbmd2RGJyRFo1VWRVVWFUcnYzODI2RktaWjl0S2ZsVlZLbXUrbFBScmhaYWNVL2JQd3l2bzZGMTJJaHpkeWMwdGRWTGk3WTEySFk5YmUxWkg5K0gyc1prSUR5S0xKUVIyTHF0UHRkMlVnOC84dkJNN0RZOFluVjJuakpvdi9aWWR1RkhPL1QrS3lzS0RkQ1JiMW1YbmtnenpxODBSaEFmejRQbE45Wnl6NXkvS1kyWFpjMmgxTVMzWlNMdGFCbmdscUtteUVtcXd6NVBmYlY5M2JRYy9NMU92WGMvcXErRGMvVjExTjg2Wk1XSGpmZ3dhbFY2bWpMSXlOY2V4YkxzdHY0ZVZzekh6M0w0aW5ZOVh1cy9KSnV3NVduU2w0T0FmVVIzS0owNU5PcWg2U3BYMmV4RXZuYnFuZFNoU3NDenBxdzk2eFhqdmd4ZVIrNUZwTUV5OXVsKy9hM2NUVzNmbzEyV0Z0NldYUTVPM2Y3cVd6VXdJZDlNYjRYUzIxS3h2T3M2LzhocTF5b1QzZkh1eVVQUzljcTZOQjVWM3RJdWs2eDl4aG5UTm92SGhkalNSN3NSMW1BYUtXZk05Sk52WThYWTZlVkZsdHk5L0ZLZTRzeERpQXFxOE5xMHFDWDNwSjB4VXJsZmRNL3grck5PYi9mbGlyQld5NTYya2lxRFlNblExcERTRFVxT1JBSHpldXBXeTlmS3RtUmxNQnh0UzBSSmZvL3l0SGU2TWRNUTdWY2phNU5tWnFucDZyUTl0RkhkamhEdlNKRjJxYVU2RXdGdDJtcnB2SXRYRXNmSXBHdnplczJVbHRialJxRHBvcFhjbHpMU0ROYlFpSmllSzU5bzlJWVVsMDBKbnlPSVBxYXV2aXlJdjZnbDdBME5hUTdSZEQ4RXE2UFJnVk9qT2UvTlpZUWRrb3JTVnNsU21jbEk5NWp4UCt2ajNYaFJ4UittUGcxMEVVTStTazlKVzg5bzJMMDNCKzFnRG9SSFVJeHJKTTg2Nm0zcTFhVytQTFc2cU5GblEwVG1vMStyT1ovSEQ1T1psNU5tdzhtbHVFODMxU3Y2MWxpc3RGZFpLY05UWnNHSzhOU3BhTEpYVE5qSit3dGxUbEg5ZkRWU3dOaWtuckdlSTN1VzQ2VkVLdjlJcm1CZ2VtVjVWKzFJV1pyTzJPSlQ1OW9LYitNalhnQUxvTFR6N1ZXelV1UjlXbFdQeGRYaEIvU3hMU3BQVFN4Y24rVjdhMk5zWmZsbjN0OGFWaXlQdEphUG5IbG5XbDFDZXRoYVlNUnZ4c3VXeTBMU0VrTHV6cXdIOTZteXlSZHlKWmRZV25xU1ozTEdOaDdxNHFGdnZtblhoRXpUZTJOMCs5ZmF0ME5sUjAwdUpMeDVlN0xrWnY0b2E3RnRFMlQzWTFXMEx0S0VmWkkzTTJwa0IvTEFRK3RlU3RQekhPV1RJMDh6Z1dmc3hoSkNPcXg4REw1QzFtaVpWRFl3M2lhK1l0TmFTeTV1QTVCdjVUUVZhR1RnSENMaGRBYlZpamQveUNTZVJTZ3E2eVlkeUIrbVBoRnRielFMWVl1cm9NMG56MHRZMDlYVkNzdEt2SlIydE15bUxLc0xrT0tldG8zN0tDSTY5c1I1ZmdtaytSM2xxWUZ0R1RsdnJkTlBDbFNMREpadGFXaFVnN2RoUmNoYkFCbTlPbFIvdngrSWVSL0FXVmpHb2czZjRncVl0bGNtTWpwS1U2YVJUdnR5MVZ1TVVOZUMxSGRFdVpSWDd2eTYycTdyMkdndzZVOVRtVnloTGdTZC9wN3Bia1I3TlU3cXBKK1Y5Vm5xUjd2YUkxL044WStZRkJtNG5tblI3REJsMm85U1I3WGRDaTJKeXBUUzlSYTZSYzM1TzJmMmRraWlwSjJvbjY4NTdtUEZGeDIycnp2bXhwYm01aSt0YktSdWE1a2RwNGo4QkpaaFBVS0xyRTlLdHNJdVNaK0VvM05FMDBzcittQmYvLzNNMlpkdHpzcnRTNm0vQXVwL3F2QlhTT212UXNSVzZHZXQ2ckxKRURLWUw5QmxwZERtV2x0WHZLTm4rNnRubjZKb1c5dFQ1OUU2SVhQblFqU09WZDM3OVk5VC8vemRtdGgycUxWRG9nd09wZTRVQXBlRGtLeFdiaSt1ZFBJVVErWjdTSHpLeHYzQld1OGpqV3FsVlRwYWpXL1Q5aHBaazFIQWRKNHlrMUZHL3o1L2ZabzJaVG1rK2ZOWGFXS2tzbjlsYXZ0VnVhbmhzVjN5MzdKSzB0dU1FSEltOGl4Mm1UZ3pIRFZUcUx3Mjd5ZXQybW1nTjRwMG9FWUJ5LzVtTjJMbllIYlNJV1ZxZFVEb2JhblUvMnAxb1FtOUZ5UHVJNEsxVFp1U1gyZHd6SkhUYVFkd0haNkU4RGF1eDR6UkJHVVVKU3dMTXQ2NnZibWYvSnE0dzlYTXllZElqSGlCV3J6VVBsNVBNZ0V5SlZuV013MVBHZHZtRWJxeDAreU5Ib0tWK0FraVJuTWsxa2p5M3ZYb0U0MmVDUnhGMGpqYVZOZnlXRExSZkVSZzFpU1F6eEs5d0VjMkc3SVJiOG0raXVMOU1LT1BOQkJiY1lVbXRyWWkyclRTempmVmpJSzJ6NkZkMTJIaytoalBZQThjMWtvSFVlU3BvQThXUEVZakh5OGpWbys5NmhTbExDK2NEd0JTSTkvUWIvc25FVUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFBcEQvMy8vK24vQjcyK052bC8vOUgvNmUrWlpFSE53WFFPOUFrVjc0cVlVbkpWNWk5RFJQTUwxMU9zKzNuTjVERnNDT2xZazRjTE5PaDhwTXVwb2RtYWVXZXRMU2FXWElYNmV3cEo3cEQyaGxkcXpFN3ZUV0lpZHY4NGpoV2gwaUJ0T3N3WjNSNUVyZVhidWxoSDJXWi9RY09heHVhQXRHcUQxMHBOMk9rUnVmUFNMcHFZeW9rcUFpMElNM2l4R3Z4VjBmanlYMld0WThVRlpQZC9iS3R1eFRHOTJjY0kxOEhmQWdXNHZYMG0xcGtmdEY2OUlyeXlwYmpqL2VYWDZWVU1ScnNRcG1OOHFueGx0M2dhbUlXU3U0VUJHWkRZTnFxb2l6K0x6enRwY1BIZGV6UjE5Yk1qM3pHTWx6ekZ1UCs2emN0OTZ5cjdtajZKdjNGMVdScnlMKytScHhxZXZ5R3c3THFOTC9WcnIwMHhhUGZtNUIxeFZ0WE0vaXRtbXlNMXlLNjhsSDB6OElwWW1sb1NKOVVLSjRwcUJoTStDUFlQU0tzbVJZNnJvclBJRnFDcnlSa1J0dTg2Z3lSdlExdXY2ZHRiTUwxdnVIK0dTa3MvTHErWFJMci9oWHV4SnlFNS9mLy9lMXNMeW5rSnY3UjdReUllUmFqSmluMFRKR3NFeGhMNTlFaFBuOUNwQU85U3BxN3lDUjBrY3QrN1M2ZU1xMFFPdWtsV25sYTlQVmFhMzdJOTlKeEJ4QzhveHNJVm5wcFRoQ0xzZkk0aHMxVE1tUWxmZlpTbHNISWIrMlo1YTkrMWc5ZWtaUU0xejE5Y3c2R04zN1RXQVpXbGxXZS9UdXM1R2w3bjhrbzJ5aGpEeFlwUk1aTVROMTNwbVpWWXpyMUlSclpTUWdmdlVUalo0TWpjZTdlRE9EYjFRRy9aZHJzV3JSUGF2WUpOQXRjSTZ4TjRpTmtJaHNTblR2ZTdiYmV6S0l3c2hhbEkxOE9tN1AzZXQ0SlNGOXhzcm1jSGc0bm1WLzhHQ0pXb2xiK1I3TmFIOCt3R2J3aTZtRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVFSQytXTHFPenB0UDgvOTkzLzRHOVpiZ1J5MThrRXVVWlhSNHl5QVg4Qy9ENjVML3Fxc09veUpmQkVjQU9OOGNESlpxZ0ZSeTU2VHJ1bzBjN2VKbmdQcGxWZmpQWXRSeWQ5K0hlNmQzWFBPWlZMQzBXdXRmaXVQT3BmU2pxU3Y4bnhBeitpSFVlVlh2RjJwMzViMnRiazFxaCtyZHBFYjl4N2g5OVRHN0ttTTJjT1lCWkdwRWRkTHQ4WjJyR1RVRHAxeDdKVEhGcUMyejVwVVczVG5CSFA0SzRCR0dXb2QyN1FSbzJmZEdkaVlOZW1uYkwvb3RiTS9RTnVYU3M3UHRlZW9UUlNQSHpFaSsyd3RNYW9zVVYrdUplSUliRXNXWWhTMFBCb2pLd1k1OXRqaVB5SDRITnFFTmprcVAvMnZ4UHJMcUgrK2xQck90Zyt2QzFacjRmbGFnUFY1eTZ6ZGgvZUlYSzJmRDRWMzRyMXJFMFRtU0xwZTN0R3l2NE4yU0pucHE3OS94bmwxclpobGRXNDEzZHo3a0tqNWtYU3ZiTVFNYVdyTHE2NGljVGZFTytQcjM2V1ZhOHF3NW83bjJpckxBK3JiV1hZVW16UmxhQkRKTXZaV3BvN2ZoNVpEekRFUDJncUVrRmdpekZCUDdwYXZEYXZEZTNsVEo0OW5oWktNc3M2d1NxRjRPbU5MbnhLMmgraVZQY1BzVm43VWxnaXlZYmRpMmFESlRrWlo1UE9zVkJvanZuMlVJK1ZWMklSOEZFMVJXNVBBTTRIQndmOFdDV3dtcURKeWN6dGVJK21adUtzY0NWU0pSQ2lxTkNGenNVZXArVmNYdzd1cm5zRDBXcDVWN2lYU3RMMnU4R3FPQktaSFpMU3lhRzRCZXI1N3phaXZUcTdKaWpYcTZOYXZ4a1BIMUJtUE5DejlPOUxrWjI1RlVNMkFvQTExY2YvcW01bmRpdERTSUdVZFhqRnc1Q1hFUk5zNm1CQW5YWS9Zd2w1NjBzR2pzRzdlbVB5MUtTR0VFRUlJdVEzYVM2aUVFRUxJUjZBNUlvUVEwcEJwRzliem1FYm1ZQ0tFRUhJaGFKYld3elltaEJCQ0NDR0VFRUp1QjVmN2hCQkNDUGwybWkrbTZyK0I1aGRUYjhySWdYMExRUTdHVFVLYUpWVzJEdEZEOEo1ZVZQcFYwYkorc012SVNqd2RmNEg1ZTJtMEV5ZVFVNmNuaXRyRVNlRVJSY1oyTjNwYzJzZ3gyN1BIdkZoMUsvdGtJdFdKb01VemVieW4xTTRjWmQ2VGk2WkhyUU40UXV6UTUzWWt1WGorM25lNGx0bjhoZ2dYNEt1WkdXSzBSeGdudE0rbzNmbStyalAwV0dnWkdZeVBkRHhBZlgyb2ttVjNWNTRGN2JHRlhvM3JVekw5VmpEc1RuT1l2SnErYy9uejljZGlWbGY3Y3FvMm9rcnpseVZkcitGSU9pMnZ4NytTOGx2cGMwQzhWSWJYMTBPWTBSbFNtY1c0bG1TZ1BtNFMwdVVxdEFnNXM1Z3p0M2tPVmNyN2RPcm5IaXZKR1hOSDgwdDJHZkZkZDJxNk5IWHBPVHNhbHI2MjlET0NOY1lpY05vZE1kL0srZ1V4ZXB1dG1HYm9TT0dtbXMzN1BGa0ozMlVCNTRqSmpNcUlRdnQ2Qy9KVkYzTytSdm9YM25XdjFuZ1J0czlLcC9sYmJWMHMyVko2elI1dEtZdFNnOWJueVdaSmN0bkhxM0pJYTltcnZZd1Z3NW9RNHNQU2tLT2FzNVk3dWhJZDBSRm5yRkRJQzlRVWV1STlaamdCYVZlYTRkRTYxV21sTW5xY3NTUWhuMk5VRWFHS09nbnB3UFdTQ2xvbUlTcVIrM1FKa0tYSmwwQU1sYlgyVkdTSmErNHNGS0ZzZk5UaFJZcnYxZVVxOUJ5SmlIMVp5K0ZvNmZUcjc4WnFYM2JiQjRmYjZOelhCUTc2UW1lU1o4Wlo3cUtWdjVldnpkdHJ3WFp0c3RybjkrN28wbVNlaUtZcXlIZmlYWHRxRzVUSmtJUFVnZXdZWGRwNFpHdjBiQVBxZlZobHIxejJFd1UyM0RKbTVxdjF2RlI3NW5wd201VndUU2EzSWdpTVpmc2RXVmU2a2Q1dFo0NXpCOVkyemszZ3IwMEpXUTAxTHlIZkIrZnR6V0VIRTBJSUlZUVFRZ2doNUM1OFlwK0RleXVFa085aTlVdmY1TU04elN6UkRCTkNDQ0VmZ0FhWXhNQVh1UWtoaEdqUU5oQkNDUGtrdEVOa2h1YUxxVHI4WXVvTlFRNW91MzhWZEVhUFV4dTRpZEdURFBnZy9TSDBEbUtzdzYyOEpQNVlxY0VpdmQzNEh5TStUcGVPSE1rUnVXMXUzSWxhRkZoMlFjb2FQY291R2ZtMnRNaEpxaGFSZzFRNSt1a2RyUndWVlJERmhPRVp2N09IQkZwYzJpODVnNVhIQkQ3ZEhnWDZqUkZGcjh4M1BTemI1ckhJYlo0UmI5MDZrOUxTUkZaNFd3V1B2a1p0WUJMU1dhZUhXK0YxZkMxYks5TTZaYnlvc1ZMcXZlUittYVgzUmNVL1gwaXRyaTNMajNvUjBoZFYvNFNWcVNOem8veUlrZjQ4bzJ3cGZjMUtMWWZlNThnaVRodFZTTjVXRGxLV1RoSCtBak9ZMGIrbmx2N09NVEU3NUtzS2VhQXZvN2Exc2ZUeGZKdnFXRHAveEM2TjFzWExKOG9FUUp0VWk5K1NBYVlPL3FxcHNUVHo0UDZTNm9nNmttVE11Qm1ub2xRRzBTR3diQTEwcjBGTE0ySURJdXh4ejRlMTVSeW5WRmJpVzErbnpuUDBoU1RaMXRkYTIzUnBsN29QZHJlRWtGa3NiZFpMTnp0UExZOHZEWlFaWVdZdnpSazNlQ1VGM052dVNHbXVuajF6TkxLRlpLVlBSajRwYlRKa2tXZXh3c2RIeHhUSElMa0UyanJKbTkrcmlCRkRCQnFIZzAwUTB0ZWZDMnIzMUVUUUNkckxIelhKUFVhdkoyTmtEendwNFROZWJCNnNRcnRSMVJZdHhUZjdyVTZrdXgxMTZTTE5qVFZyclprVXZhUGl5VC9yWmlMdUpBbGdkSUc0QWU1TGswQWlGLzdvbWd6Tmx3TEtKQ3JlNldyWmhwVkVEQ0VPaVVtUS9TODI4bW1NK3BXcXZJQytZL2MvbEJQc3NYZkZpY3FNZUtiQmNkL0J1OWQvRS9oclUwSUlJWVM4b0t1NEhyWXhJWVFRUWdnaGhCQkM3c0o1K3h5WmV5cUVFRUt1QU0wUklZUVE4akJvL0FraERxZ3lDQ0dFRUVJSUlRL2szMFR1amVkWDFaSEhqSUY0MStKTHE2Z2RHMkFkT1ZQbjkxWU12Q0d0R3ovUVplUVQxQjJ0ZFhia2tYMTNCRG1LY1F0ZjJGWnRFZTNwaU43VDRNL1p6N1JLRzYxRjd3eks5cm8wMFUyNGRUcHI2Um5EWWx3bk1CNFpPRlpaczhmaG9RTzlya0lSZ3cveDJ2VVUrZlgvb2x5L2ltenlsTzRFeHNyVTJqNGZTcE5URXdkc3ZCOGkvRWFRVm10YjQ3aE9uOU0zdXhDajFoRkpyN1dxbFI1Sm01VDZXRFpDMGVlN0xNZ0MwS003MzRVSmFTdzVXZmtidGJ0SUhZNTVjaWRkYWY1VjA3MFBCZ2Z1KzcrSmU2NzdVVUoraGZkckljVVhjWXlNK0NNZVVPKzFUdE83anRRMDZQMUwrZEE2Uk0zbjFBbVgvR0ZQdjg2MTZkR2JMTlUxZVAvcW91YVZYL0VuMFZNWDY3cVUxcGN0bXJTaUN5ekt1QndkVXU1eGd0Z01yOHcwS0FlcEM3cHF2VGpXSWh1Y1N1S3dybVdWS2s1YXNnbDFtTkxTK2FjOGM5blczbCtFR283aTBLaENaeHcrQ1d0TldQQ0d5NHFHYU8vRFNqZVM1Z3g3ak42SDdMTWVoN3ZWWCtXUXBvQytlR3V2Y2xObUZ1UWdJMGp5Zk9hc0xpRkVRNXRiWHE4NGNuWFFtKzlXbVpvR3ZZME91WlFmOGZxM0RGNXJNaVZmcnlXNkhRQy9VYjJlUWJ0ZmJRQmI2Y2gzb3MyVmxsRkY2MVhvbXB3NlhTOE5JV0dnU2hMRlk1RGFlaVNqTHU5TjdkZGxFMzhRSVJpZTNDczdnak1uTUxyMzJ6UEFWdnhJSGFUbkpyMTB4cGg3SjJ2NnYwNWZ1aG1UdWpkeWtObW5nR0VqZUZ5NjZDY2FuanEwZXdrNUhYdmNZeEpIeU1yZnZUQ3lDTFN4dlNhQmpOT2J1QzFlNVJGQnE4RHE4RmE1cks3THc0bFlna3RlUk1BVERaYzNhWGdScE1VenQ2eDVTU0E4V3hIZWVRaWJWNkh3cUcwTWNqUFFSUW02Rk8yZ2lSUldlekN6enpSSWgxNGpQY0JQNHhkVG53b1hJWVFRUWdnaGhCQkNDQ0dFRUhJT2ZGcERDQ0dFRUVJSUlZUVE4cVZ3WTRmRXdoRkZDQ0dFRUVJSUllUXU1UC8zdi85WGtOLzAvL3MvL0EzckxmQWNPbmZpajFjakR2RkJUNmFBOFJ5SjdEeld4bnRZYjV1dlIzZzdrTS9UamkwckRjR1BSeXpPYTAwV1VKV2V5RGJkS1BoSldKNUJOYm9kN20xY3p4SGdXcm8ybTVEdjc1ZFZFZ0I2L21VYmh4eVJKWVgzeXA2MWpyMThTaHUycDU2V25neTBMQ3ZmZnN6OWZzMmtxVnBhejBqdmZoVjBQTmJqOFNOUHFrTE42R3pGN2N5VjhWaGk3VTVYMmNaZUhyQk03U3ZpeFdOLzBCNmVjVXpSdkNPajdiZHRQU2VOdGwvWGFyL1NsWnNjUlpOYTlQamNuRkNQdG5odWJLT1dhdjJzUkh5WkNKOXVyTDkvcjJzWks0eWIxM2Yxak9OZUd5TmxXbnFyaUxua0VuS1Z6cTc3WVE0aFh4NnNDdDJWL2QrNVV1Yy9mQnl4U2dlWGRjeWM1cjZPaU5vSWIzL08yQ1BMWnZSN3ZKOW4xUFpaSUhYNEFOWVUycXZ6S2ZIdHgwdXlzVVFiUWZ6QWFLcHVhMFEycXE1TU9ST05PVDJQRHdLYjZ4VzJvSTJmS1JObFZsLzE0alZaTXNldmxzcnhiWnFlSFRyNmNGclpXL3FrcG84YTFvU1F0YXljaitnYVRlSnh1dUtUTjR5YUp5di9KOXlJa1NWcjFKSjd4TlI3bHdtcmx3L2tYTkF0Qm11TVJiclZVbjZKaXk0MXlTZFpvZnhyMlN2Mm1DTExNZ3lRT3BlVTV3MVR0SFg1eElRZDlmWWtScFNrZDI5UVNwY0VuZG1VNlczT2N2ampkLzgxK1ppWmNWNVQ0TWtuTmNtTWU2VXhNNnBIVGFGajVCeWdDeGNBcXA3UnljSE9pR05VcWJReVZwajZDUGZFNjdNL21ObTlYKy95MkZPSFVieFBGNGdEZEE1eDdYa3FraGN0em12ajBhUDViQmJvMTlFdE5mS2x1SjkvTjljUlMwOGwyUm1tM25KWkhqdmV2ZHM1TFRlMElmeTFLU0dyb0dkQnlQZkRlWHdpVDJuc1Q5NG5CelFoaEJCQ0NQRkRMNUtRRzhDSlRBZ2hoSkE3OGpRZmh6NGRJWVFRUXBaRGg0TVFRZ2doaEJBVWVzOFBnUjFOaU1tL1AvL3dHSjdIME92SzltZnpFYWZ5Z016OGNuODdpTUJkVGV1bis1NzdMMHBscENNNkJKazU5YStSVXo2MHFwQWJVSThiYlpMTW5MQnhSNUNES05zMjB1YXhsbDdCbzhla0E4dlErZDJUWTVPQk1sRk5qQTVLNjFvS0ExdXo5NFdVOWdzcTdxK3A5RTV0cmVPMTlEVldYcTF1TXhOYU1lN3ZJNStLbkV6TFhwRDd5Mm5FaVA3bUxxTFVQZFpzOFo1cDE5WWg3YTdidUs5WHNjaXd0VlRBc0FORzN2U09aTndJYUY5dE5scWlyOSsxMm94Rmp5cVVCckNXZDlBK21YSjZ4MkU1Ylo5MFdybDZ2Sjkza0tGdHJPVkZ2QnNwWCsrNko2KzRjLzNrTEUySmVSZU9mWkd4ZEZXcEpVUDdNbXFCem05ZE9Xc3RwWStXYldta2JLUWJLYnNZZGZBZVlTY3QrSzB5clBBYXRDMW43eXZ2VW0zcGpxR1M3dFJxdE1ub3o3emRWMDRWY2UxY2VhdXpvWG1wVUg0a1ZoZGJEWC8vS1dyR0ZOdnZYbEI3WmNVald0SnI2N3lzbHE5Z3VSRk50VnFUNmhsNjBrYzlzMUNYM05SRjlWS1V1cmxveTBDSDcwaDN0WE1wYTV1am5zWjlDYlhTWnFzajJ3eWV4aXpHdGJXWGtJendUUVppNnpWZjFhcWJGaS9GV2V2OG91VEtYYW1pL2hYNDFmODlXWHNwUlMxTGw2WFJXbjVDeUdjWjhhN0dkZ3I3NFpxV3RyWjdabGRQbCtFTTVYandJOEIwUFhuSm1UYUJkUmhkeXMwczl5M1h3SEpEZWxqTFhmSmRqTTVUYSt5TmJMRzBjNnNJNFlqTXpuTCs4RGNoZjVreFZqM3JYcEl0MjVvc3lDUkN5NnJUUzJVWXlhUUUzZmxVN2U5bGRCUEJpdC9pQ3BoV3k0K1VoWGg1TFpyTTJldWVCNm5Vb2QzWWFmYzdpa2NocDcyTWdiVnpraVdlbGxmYjNrUGNLZzFyOWlJanl6c0tMWk9IbU5zMnJ3WTZ3MFpuNHFPd2ZITnZPaElINGtlaU1pd1RnVTVZNzBSR3pKVGxUN2ZoVXR3TlFQVzBKY1BUVEo0eVVLK3hUVzk1Vllnc0FtTE5UeHJGajlLcVkxVTlOLzEzbUZ1ditPeWRkSjJrSEJJM3grdU1vd09rWTNCUWsrK3hmZGJ1aGhTZUVsMVlGYVF4clE2NUdmeGlLaUdyb2NkQnlQZnh3WGxMbFVIdXhTZEhOR2NUdVFFY3hvUVFRZ2doNU51aFQwdUM0RkFpaE14QUhiS1FLelF1TzVnUVFnZ2hoQkJDQ0NHRUVFSUlJZVFqL0lzbCsvUFRYVDdSdVExV2QzcVBDRnZBMGlxc1BOS3RPSytWNk40cEEyajFMOUNOSkFMa3lBc3QzWlA1d0JHTUl5cGlSRWFrSEcvYWZZNkpJNE4yZWZLQWJPL3hSTmF4ZGFhQUJXbEgwa2NBR3FJMndGWFZ1ZnZDY3NmT0pvKzV2cFc2N1UwbDJwVllQRTdkWk50YjQ3aytqRXRLKy8yclBtMWdiM2RzdFVDYnB4ZmZTKzg5bjNKMklWRWNjVjRkcWwwajl6czcwR2VPa08xTFhESFd0VVBQOEJaZjY4V05jNFlmTlpKK1JBWXlINkxIN1JYdXkrL2RGRXVHNHFJWDlINmJ6MGdpSG5zSmFjdXR0RitwM2VoZU9paStkMzZrdGg3eUVyRVdxOE1sSG5KdWZ2QnRaSWVjM3k4REsvSHBHSTkrTGJWRURkK1F2ZEhtUm1jKytXb21LMGI0dkYreGxsRzdFNTErWGsrVmdjR2pmekVlSzZzNDh2em1uWXNuaEl6aE5iOFJsc1ByOFhoV0RXZ2RvdE4vakpVVnRUYXVWalpxenorS2NPRlhndGJKdWcvUDZlN2sycXdhcHlOYkxPamF3d3JYMG5LY2tpVmNaYTl3NW5sM2t1dFFnSFh4MzdrbFRLNHlXaGZ2K25Ca1lsdlBOUHg3cFg2RmhyeEw0UjFEbmwyakhwM25aemV6L1oveTJiMjd0SjU0ajBiUnVuTlVlNUVCdk5PVHJHZG1ZTTlPV0N0OFJPYm9HTHZwbUJ6eHVyeE5qRGI1NkpNN1JCYVhTUXVaTVpKczdOTVk5WStLR2VDSDNmNHdJaHhrYlI4V1NDYUZSNjQ5dk5EVkZVQ2VhZHk0d2NBZnBwTGJVS3AvcGIybU9zMEYwTGJxbGhReUlueHc3emNIdExYMFBQQkNYVWNpQUIwUWlBdk83MVA0Z0FIM0ZPbWR0MW8zbnFJcncra1pwQTF3NE82U2FhM2FDMC9KMzJxZVZwL3RvVjcrUVd0dzhBRmVBZVZFWXloSStWdUZGTW1jMUtlcXpoMW85MXJEL0dtTmVVSEZuSld3V2h0di8zN0JNa0VBcVdYdVhFZFlaRlNXdE91QXl0NlNqZWh0eXhhMjlVRjcvcW9qNDRRVlVsV0UxSXQ2K0w3TmkvSDZRamJUSVdpUHk3ejlIVWxFbVY1RE5UTFh2ZmsrV2FaSHZsNUdiNnpsbDR3dFRYdjlUcGUzOEUyb0lEUHYrKytQck5MOFdIVkx0d3ZmWkdzNnNOV1JoL1ZDcWdPYXZBbkVXcDE1SFNoTmk2eEFzL3BQY2RRRWpHN1RsazhiNnZCZVNQazJkWDJPMEJqWmtKOTFncDh4WFhiRW9nVDFXY2ZhWExNaE9yOTZDeTB4UWxzVFF1NkRWM2NrTVAwSTFFK0RiS1pnNVRMUXU2M1Q1dC9Tak1TdndQSkxMWmZIRTA3dXpRZmVxZGpsUjhydXpVL3ljTTdZaHp4am5XanQ0NHdhS0lNLzYrT3NsRDI4QVlMc2hkMXhRdmVjbWFpM1I3UjB6alFUT25YV1pFaDV2VHNSSzJjclV2WW5SbTlQUTh6VTZmR21kWFJkSWVYaGd1OThJdGFGWi9peTBTYmc0V3U1SzAwMVJQL08xbGZMcnowTkpHbTgwYVY4OWZ4bFl5OWhWQTFIZEFWaUV0anQ1TTNJSWlYUGlRVEZUSEhHODVLdkJsMGdQc0JXOEllcFQ2TWQyRzNjeFNoQmFZWUtSZHBqdFBDQVNoZmptdHdBellzZGdRUGtoOW5Ob21DUTU2ZC9tSGx2QUt2RmlBSHdsTnFXNFJ6WTc0WVlzUXAxMlpFRFlPYitSOHZLbmJnYWgvSW9SanpFbFJWTW1ZaTlzZXIwVEVGMG9mell4alQ0SXB2VFMzc2Z2MU95UnlNMkFwMFlDMlJNNmUySWVrZmttNUh0YitQeHV5dElvamZiQ01wUTh0bXhOc0lWWjNKRUhUNHhEcVBpdFR3ck4yY3dmN3FuRWRzZmcycHp4Y3hmdjdTMm0wdjVyOHdzNVZHdWhVS2FhL1hDenFzblRHTWdkbWhGSGFTeXNsQzM3N1h5UTJoTExTMThpeGFHOFd3VnRHdXQ3Rk5aVWViU0c1bWNReUYxdTlMOXplNUhXSHNSdVpPNzc5T050ZEpQbmZCVzZLZDhvT1lqNUxKWVd1dE03VHlqUVZkN2t5UmR5OHlpNFN2cXNGSWV1alNOY0RmSTkvREp4MGhvZm81Rm9uTDFkWjRsZjlVa2NreXVuVzE0cmFSeWhMRTRjK0tlNllGNSt4TjlENkFUWDBZMnVqcEdQM2RrcUp0ajIzcC92RjluUnl1MkF6Nkd4L1hCZGs1aWNZNFlnakxxVDgra3AwOFRSMFQvbmVYTHpzamsybXpIR1UxdTRlbUtWVnNSeVBzTEJLVFh5TnUvYk94bHJQTGRFTldKbUFSMk8zbmp0Yy9BNERuRGgwZnRDOGU2UWZkRnF5YmRUZUVQVTUvSWhkKzJRQS96bWFxK3BlQkhoUGQrYnpVb3ByNGVyUkkzbFc1QTBOZ2lGWXNtQitvN1JteVlqOGlVVCsrcFgzeEd2UjFOTTFsTHVKTHN4dmZXQWFXK1A2disxZ09iVWM3ZWZSaXNmejc4b1loQlJ4MmE5cGhlenIxbUFvZjRGOTlJNzhabHBVRWkwZHAwc3EwanRkZTF1MzNFRm16L1p1RTZKZHhPRmVVNkFYbTE5SllkNnVYMTRuVXdQWFZCN3RQS3ArWDEweS9KcC8yN0gwLzdFMW1FVnkyMnIwRSsxc0JvUkkzallsd2paWG5HM2xsYXNlYzNydEFOOHJ6ZGZpQ3FGZlA3UmRUR1cydStsUHJ1aWJaTHRpOHRGS2xHdjIzZDdaSDJ5Nmt6VHQxckhnOWtWQXFWd3FXMjl0Z2hxdzRhV2xranNtN0N6Rmc1bVV0VjFhc3lld0ZsWVBkWG5hZHIvSWhZMEQySEs5Nkx4eTdsWFdpQmRLT2NWNjlOU1VpZDJqcmtqbVIwRlpEU0E5MDZRazVnYmdjeEp1MURQS0R2UStvWXo3WU5HbzdJL2lUYWNuZmpTbzgwT0ptZXdjeFlzK2ExcGJpelV6WWh3M3g2TlQ2NlJ5VEpTY24zVENQdms5YkpkMXRMbzN0TFowelc2R2NhVWx6a2ZYamJET3pYdzBPTnN1ODNMZndpck5qaFIyVWtwMHg3dDhPWEJ5a3JBZm10SjNKY0p3VXl1N1hQRGFkcmNPVitqSElOSGdhaU0xRmRWNXpwVWR1d3VsdXB5eGVSd1RBU3l1emN5ZHFqU2tDUFczNFZlVGdUUys5dmhDNXNCM1R2ODZid2g2bmtseS9RRUNQUHdMNEo3d0tHRUdMd3hVcWp0NmMwb3E2TGVMMlZzcktSRnBUeFdJLzI3bFp3ejhxNzVhTG9oYWNoMkdpMzUzUFBNcUptTy9MNFZQcnhUMi9yMHZMT3ZaTW9HL0ZTOFBaanEwaU5pTlk3d3VOQTQ5ZXNoUHJqMm5kLy9SNHNTbWpNckRwbmJrYVdjc2JLdGt4ZVcrR3phV2VKWEFtTWxLWDBYVDJwMmgrRHF1SUxIT2VkTTZYN1pWUW53MTlJUk1mYUZ0ZmFvVjc0YUIya2w5VTBMWWJhWWUwcENuZXdSbGxwalpjUjViYUZ3akZJOWtSNjhETjVDQ0hyK2R3K3hscW9jd2dobHlkQ1VjMHV3YVZsN3loYzNoS1JUNjhjb2lkSkc0L0lxT1M0SHZkelVsMkdRM2ZuSnV6VnNic2ZxeWI1c2RrSHVuUDBhZE1aZUhhRXJ3Wm5KaUVMbUZVQ25rYzB4TVdLcDhCYU91bEhzTlM1aE1RU3BRckw2SEtQazVyTXN1QlZlbklCWmw0ZnZka1dDbitZU2k1Sjc5ZjA0ZXVzZGxKYkI5NUZWcW9uMDhqU1pydnJRM2lpMEhiNHdGaTZKZEs3c3FnanQyZ1NTZDJFTXVwcitJWUQrbURLVW80alpiUXlpeHlldFhSSTBmbTFta1JmN3M5Sy9NZ2thd2ZWakt4V2hqZGUrM0VCV0tmU3BJZXFqdDNmYncwS0lDRjJrcUlqODNhTW5OSWt5YURqOFV2a0lqRzRYZEZEdUVyNlJMZEtQOGhaU2UrTkpZOWpoVXdpcVRXUit3eG9oKzdYeEpBZVJwVkNoTFljV1h4WjhmdjczTDY4Q0hzUmpmdFJuNUpZakR5SG9MZXMvSkkxUDhQRXIxZ3VSL3N4MnlmNEJnUGtuUnNyNXhLV2ZxKzlzcElqNzdKdTQza0wxOGJsWVhZcjgyRk5yKzdydk5PTm1xNXNYOFE2TU9OQWJlbVJINmUyZWFSd0Q3MTVIR0dIejdEamsyZ21RNG96VEgzdnZJaHRhSlZPdDVVbS9kOHd6ZjZrZm5nb1NIc2c3b0dZcmh6VEpTRGRMa3FybUpFUDh0MjhJQTFScDVQOFFpbTlGajlENUY2RXZNK2hEWGZOcHBRbXZ1d0dUVmJUNytQUlB0QW9SbG9ybmhCeUZqMVB5Rm9kekdxS0VkQkhONVoxOHV6bjNKYmVsa0FCMHZmeUkrbWtzdEFPMVVDM1pVb25EK3BHekpqKzFxZnp1aXE5aVV1dWh6YW5JdHhtQ1k4OGEreHhqSkZoSWgrTVJWbGs1RG5ENkRPTnRpaGg4N3ZOdjIxdzUyWi96ZUpnQTJiM3MyYldzSks4TnQ1cnZOSDc4WHAzU0grMnNwUU5xNktsazZwWjc0V1dYM0YvTjdoMkNmVjhxWk11bmUremFqWHJ6YXpvOGhIWnMrVWpJNHRtTXdoRXhZNnFFbmJTK1VTNEFOR21Qd0tPblIzZWJrYVg2bWhhVFc2NzFFYkxHdGxiUXJkRUhvdTNnYmpQOGQwby9aWXpsdTVQLzlmTG96TjlXM0l4dkh2QTJrT05pU0kvOFV6RDJuNStMQjdub0c3a2tzNWZLSjhFZjVqNkpMYUJuTkp0Qi9SUzZ2WmJJTHAzZlpZTWNrRjY4N1kxVk9UMlJHNllmSjR6M1ZJYXZUQVcyc0l6ZU93b3NGYUR5Sk1xYnp6NVdzNTFMN2JTUElvRjNkN3c3aVFqdGdJdHU3Zm9HbXhWK0Zjb3ZWM1FhRThpWW9TTXRvL242ZS81Q3V0WWc3ZzZsQS9jejNnYnJxanJIUTNRaXJua1k2K3R5bEYwVCswZHZscmFyOHVmSDZSbXN3NG5vTld6U0Z2dWZ5TlNZT0dEOFNOYi9MME9qR2oxa1RwZGhNQXFxMmRDZElxMmV2a1E3bldaSXZsazJZL2htWTM4eDYvSko5MjNQa1V0SGNuQlQ4aWRzZDRCWHZtc3JqaXZFUm1FaE1MSEtzL0J1emhaaVhkcnNGMjIwM1VqTUJGVzNncVBrRC9xU1ZqaEd0cnJxQ05jY2M5b1ZsSE10c2NGbFpRNFJHTGZ0ai9ibkl6NDBkL3M4dEQ4blFBYitWNTRIakZyNGRHbVAySjhlVitOdURtZUxyclRzdGRTVjFSbEFkQW1mRFhvYXczaUQxYlo5K1JEV0c0SWgrVUhjYnpLcVliZmJQK2RQMHg5Q3ZYYjVWL3c0OVNQVmd0WmdGcHQ1L2tWL0h3MmNsZTBlVnVESG9uMEZFWi9vMkxGVGRBN2pXcFVEYU1uWS9uS2FLWDF2S0VSZWcreHJETlZ3RlZnU1ozMGFCbmV5ZFNMTDBiWkhsa28yYWlMbEQ3OXJyVGZWZWpVb1dobGVVZDBmdjIvN01UMnY3cTFMMk4yRHFIcGFKY3JicmdnbXNJN3piMXBKdENxdG9YVldrK3lBT2QxYzlRV0Nkb0p2ZDFDeXo2TnBHL2ZqcXJEaTVFM3BlTm4xSnIwaDgrcktUSUtValpxQTBjOEQ3Uk1LVitkemxkMmY4bTJsN1V6Yi9VZnI2K0ZpL1pKdUYyeHBVdS9EdHFQVFgycTVSTUtldFlYaUN5N0RrOHBkbXhaTXBLU2QyUU96VEl1ZTJ2UlhVNXBUZHJRemgzckFjN2ZMMGtlU3QySkVHc256MjdsZm5zNlVhcFk2ZGlNZ3l6dm9qd3A4VWt2OHdCYWhpYXIwNEZ1ejlpcTA1ZGdtZkJXdHpmbVZoVDVHa3FINGFUYWdIMDg5RVhVMGk5YnU0YnBxYXVTNUc1djFiR2xWdFViUmRmc1Vob0xzRk5jYUQ2ZWxiNTNYMUtiOUwwWk9WOGJuOEIwVmxsRlRhUDdOSGI2c211VGtxeERPSDd6cGlwZkhXL2wzMnFXMWJpZitOK1FVVStXRU9KRDA1U2ErWjJaZzVIejJOTFdVdnE2N052cUZPdEdaN1ljWnQwSVQyT2plVkdaSThzRXl4QjUyaENKNzZYVkppWTZjY2wzRWptbVZvRXNmelU0WG9tYjNyN2tqRmVBMGx1VWcyV3ErMXhwdi9sUjIxMTRDeWxDS1dTbDhGRkhvdDNna09MYWZKb0JsdEpxWlNGbHQvZlp1VzkxejFQWjZIcG5iemVOMnZ5ZCtPd2RBRGplMFN2bFQ4ay9BMFptMEVvZkhwWGxHVmxrQWQ1R1J0Y28xdFRxcVNFU0E3SUcxYTZqeWtKODJGR3o5REFRZmUzMTVMSlJsZ2UwbTRweGpUdzFzWVlNVVVCY3ZKTDB3VVZPWlZZdHU4cG9YUEhXYzYvVDE2enpwc2xIc0JUeWFFY0R1aVI2RFZLVTRxVnJLZjhqbU4yS3FPT3NNbTRDZjVqNkZHb3R3b1hJWmZFb2MzYmpUZEUyRzJhZVI1QmZ6bGlOZklBeUdIZGtwWmV6Tlg1a0dZMjgzVXF3L0NaWlN2UTlrVTlRbk9GZno4eU4wYjU4SFI0dDlZenViVDNxbnVNVjFYTDFXM2xvbWFWZjFHRTNzMVBuZ3BZOUc5N0R1NDAxa3U4WTEzZjlyRHFVNXFwQUk4S3o5TForZU9GdjZiT2QzZEYrWFZHMkZXNmxpeGpYVnZnWmpONi93bXRJN2NaK0didS9ValN0aW8xYjErZytISGZxU0d2R1c0K1hrcEYrSksxV0Iydm4yOUw5MmJpV3l2aml0YytLSmVsRitLUTJYczlOTzQxY0VxOFdKb1RjajhoVlFWVDZ4MEhUdjU3Uk5tYS9QQmZmRmxwY1drOCthYjFIZlVLV0ViVW5lSWJuTVNxbittRWpQSmZvNVN6SHE0OExLbVBiQkc3NmZUR3pSWGp6ejd5R2hlNExJTHV5VWRETVhaZ1ZIY1BPWHNjWnZpeVN2eGZYS2hlaVVpYlNXT0hmTkEzUHRFZVBwVzFZTnZKSGdIMjVxUGNrbTM3bUQ4QkpHSURDcGd2d0FkQ0ZvT1hqUGNpWFUzNllTaS8ybHFEZGFyd0x2Ukx0VmJxbFZjbGdvZTJwSnoyY3UxZldmV3FuYUpDYlViL0JIdVdsZm5BK2Y1VGVyb0QwcnUzQ0tyUkZGeU5ORC9Ud0RLUnNQWGRMTWRKNXRtRFF4amVPR3RtL0daLzZQMDYxNm1kWm5wbHRLN1NNTnQzTXhBVWZKR3JwM2xYWWpubnk3SXpXOWZlM1cyN0M1WnIycm16UU9hVEZmYTBxUlczS2lNT0Jxb1NJNFgxRnNoR09UUCtnd2RYVGRzVzQxa0ExNTdtTUR1Z1d6ZkZDN0pPWGRwZGhBRTB2SDhKN2p1U29KK0VObnlGZVpuNU5NbXNlSER5QXplMm9tdmhRcTZLVitjbDVja2JwVmhtai9SalovNmhSTzhNd1JaU0JhUGR4dXIyNSswcEM3K2ZVK1pXK2JFbnRjbkwxUjN0eXYxcUNwQXJ6SzN5aVRZWS9NZmtXOFBwM1JNYktEYnZlMkNsTjJUMGI0cEYvWWJ4dVJMc0VMYnQvdWw5UU5aOUdnZzdhNGVQcGtrdFF4WldTL002ZWxyN25ZTFpwNEhCbE0xU2I0RjFoRGRBNjFrT3ZnZEM5Qkd2OTM4TzcxMkRGYTQydXhVdXljamRlOXhxUnlWZmVhVXRud2FSNWRiOWZVczBEWlJOQ3JnUzZtdC9TUm5yWmx1bER5bDY1SWp0anRSZEdjVjRqY1pnNTBxODFFRGZiMi9pb0N5Q2xhKy9UZTE4amJrYTdOZGFMbDZDNXZTYlNtaVJpSEVlQWJpMTU0dHR4dlAzTDhVbkM4RTRxZllXMEQ3YzJESHF5cmZBc0Y5bWp2UDZYbTd4bVhiekd3NnlFNDdvTmoxaWpXMlVrc0t3ZWl0Ri9mN1hVa0hXNG5Tci9MbHdvTXl0ajVYQnBlY2J6U25hMS83eXlEdGJXSUlLMzNMcmJKVE9IYUNsTCs5QjBEakM2clc2cEozYkd1WGdlMVdnYkFpbmhwcjhubzFjMkVyNUtzWDRKTTFObmRxbXlvaXpVRTdLV1NXUUE1UGtZR3ptVW5vcU1sbzI0dktXNVZ0M21ZOVp1UExrSjZFRHRPZW01K2JkQkhiY1RTSzRLc2wzUDlRT0ExSmkxN3JoNVl5ay9USDI0WjNwbmtBVVV1MTlHMnRGeFpFMkphMERpQk4zdzZQSDBRVFl4YjYvSWpQcSszbENJR09ERUI1Y0F4R0JrU3FMUFphM3dwL0JsZHVtY1oxK3pqYUk5d1VGMmlDVnErMlRKbmhuUXpyeUhyLzk1clA3SVR0aG8rQldkMTZjb25yUHUwL05DalpmSWU1Z2Q5MWVqMVpYbjFIdjdpUS9FeUEvQnREeGxmNy9GMEVNaHYwRXIwZnJMSXk5NnpsaTJjTE4xVjNGS3ZzeEJxZ21zT3F5MU9tVXUwd3hmM0VWem9EZk90Zlo2NXZlUW51SVJFa0l3ck5XOTVVMUplYXp3Q0tqTEZ2RllYMGVCajI3dWk3ZGZ2MEdoU1FwYmVybVBrQ1dNUHJtZjJVT3E4MlFsUEtYNVp4cVJyN3BlYVNKZTBlZ0w5U2xHZkFUV0VHcFoyR3lyekkxbk56MXFkL1lUbzJ0MDk0b21raENCVlkvVVBla1EvU3dwT0U3cUhTdmU0cmlDenJmZzlnYTVBNWZlaXVBRUl4ZmdHK3pSbytrNUVnL29ySC83MFh6eWNFdE83dGJlM3YrbDFrYWF0aTVDR2tjYmpqVDFTSHR3dHQ2VTBkOVVQQjN0bU1BUFBJeHNxM0l0a0FieGFtNXJONndPUnp2QmF5MlFiU0xyQVJ6NmdBNDl5cTRvZjB0RVBUVFU2aUtWMVFaYlN4aHJwOVNQTDFlczFYdnNBczNUcldTUE5TMDk5bHZLRzlBWEk5M3JlVWdiUTZuK1BXc21lbHJDMndwb1BzdG1kR1M2cWpZNm1DS1V3K3hBbnJGNXZ5Q1dQL2N5S2FnZlZzek5mUnV5ZnIvc1ZacncvVi9sNHdvNmFuNk85T3MzclhTdHVUUGJqcHV1WE5zZSsvRlhrSVEvbE4wL2c0WFhrK3ZuZmtQR2YrOHJpb2NKM2R4Mys0V0I5ekJHMXhHOWNhRzFjVTZ5QnRQSzBNSjc5dFVhajltWmZwUlArQUpDOFZhM2VXUkk0ZFdHUVBlakZSMTJ3N2djNDF4ZlNtM3JlQ2hNaUVkbG8yN0V3U2NPbU92ZHo4b09DelhpdmVNVzlVaG1mRlpObHJVUWFXVkkrcXBmcitOMHlFbzZmZUtNK2tWbGFBTHZKZXhMUFpiejh6WFhPdTBIOUJZaER3S1phZEdyOXJ1dldMNENwQk0wa3piU2daS00wb24zeXRNWWZSQXN5ZmE2RVZMNnRnMTd2bTE5cmNrazkySm1ibzJXNVkyWHRrdzRMc2xmemh6QTNqck0xbTBiK0dCU2tZaVhLS0x2YTRaWlI4S1RUOHJmUys5cGE4TVRoaDlxYUp0UkwrTmZxcmlER012WTUyN1ZSbnBmVStPalBuOGF6RDhqd3pFcjNYaEdaN3VMZy9VZVRlY1FXbU5iS2tEenU1TVJUdTVMclFSYlpTS1pybEcvK2FiTTJwOGs1SSt3SnhhVzZwamQzaUFEZU4yem5zRWxVNXl5cXZEMFdmNzlCK2wyRG9lSHN1S2h4Z0xhdGRkb2xSNC96cTFYZ2Ryd2xRdkdpMkQ4TVBVQ281L0VVUTlvYTA4dGtKd2VNWmRVWnByYWs0K3o5UXRBdkZGcGM2RzMyVUI4bktqN3ZvTklEZDNLV2FqMWU4OUJUdS9mTXkzY0o2MnAxTC9mUDVtc1RUNHBMU0YzUTdNRTBpeVBud2NyVndxOXg2MjlSd29lMlJvOUhla05uK0dNVmNncUdUSHRFVEhDL3Z5bUpjTUN5cUhzZnVwaVNMbUs5ZmxrUGI3SkFwOHh2OWUwaHpoWC9nNytkQzdOajhqQ2ZwVGQrM0ZhUWEzZEs3eDRIMFdqR3dFak1wSHducXlSVFVMcmZqemN5TVBlSGtibUZQTmJ5SW9TbElaY25VK3U5KytOZjM1b3VqRnpyaEZ5UTV5ZW9EdU9EUEFVazNpbHJYNXlYNklVMUptS2JxYXNrUmYyeVFPNHdyN2M2ajFEYkNjYVI1czgrL1dSSEU1MHJIY3BITSt1cHJ1NzJnME9mby93U2pOdTVyWWlka0RCM2x4R1FIZVNUMEkvNWhxYzZVOWJqM0tzRFl6SVJ6ZGZ5T3d5NHVLL0gzSkQ5ZkVCMk9qaG5Mb1Y4U3BNN2NhOGo2ZWZSY0lBZE1mczJ5aGtJVWpqZjNwaGVETC9KdklNU3ZXdi9tN0ZQbTBnMlJtK29jM1owQ3BxUDNDS2VOSzhPU1FGU2taSS81UUVheE1pSlhxOExWa0pLMG1lK3c2ZGFLbU9iRlJycEt2V2RMTlhBMlhsZW10VVJCN3FEbHZIVURYcENsS21SYVJSV0RFaGUyMHNsYWVOekViR1pxamV5YlkyTFoyeXBVbmp1ZWVaRVQzYXRyNHlxVm9Kak9hc2pnd2lNSzAycXpVdDFzUHpVNWw0b2ozaHRpVWt2WW1XMmJONVVueWIxbnBDTkFJd3FMUmZ4YXo0dFl5YkZiYWliNCt5NkdEWElYWVpiYk1WN1Q3S3NXYWQ2TVZvYlkwcXBoa3JhT1hWNXRMS0ZySzBwRFhHRXBBT0xkUEtjNUt1T09UNExidjBWR2lWSTlVbHRmN2tEUC9WVndYUlYwTk5qT3JDYVB2VWEweHJ2cVpPdnJhTU9oeDVUS0dzRDViVDZ1MFBpM1MreE5IMUFLckkzVmRNcFNWV0ZYN296WG9lV2tTcnp4RlZtUnhwaGdIWG9BV2RDOWJhR3JIa3lEeEQ4VGJlMlhzUmYraTNXVzdpaXhMKys5WDRWdjVQWE5uRjdHVWM4OHAxMGZwZnErTStqM1p0aFJOQ1ZxSjVTeU9hZG5hMWczcVRJNnVIalpWMU81V0ZlMlBEZGVqVnFVNkRMaE8xL0ZLNEZlYUoxOUloeXdUVWpiQmtrWHNRdlJXeHNVSlpldW51YXhCeU5xTjdoVFBwTkNQWUptczNMVjZUNTExVlllTWt2eVp3YVdRTTBkc2JPOHVKMEp3QXk1RUEyeGhLaytVcW1BYmFXMDRUSjI0UlhrZDVXbTVYbTY0WnhRY1pJeU1OcllNV1BtS09FSmRPdW01bENOdVRKSkppWExmaEhwVkNQMllOSStaWWtySFNoL1dVR1hFL044VGJMTWgwRzlYandCTU5TS2ZYOFZiK05oeVJjVnM4RzNrcDRTNmU1QzZTajJINWVvZjBuajdMdTM5MndiV2ZwV1FqVDJWa2NXRXdhdktsZk5hNDlhNUFiMGVVZi9WQVcvRlBJb1FRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hCSUJmVEwwYjJxK3JJMDVtWFFENnEvb2xWYk9PbW9rNHNMRE1KWGVLSTFkbjlnaThYcHFJOFh0SDBDT2xwRGlqVGRIVFFTTFU3WGQwSTNwMldPL3NGZkRjUisya3puY3k1SmdxNjBncjd3bTBudU8xdExLc1FXaUZJNVR1NVcvNGlGS1pVMFErbXpkMkJPSHZsMWJTN2w5SitrLzZtK0U1Sms5anJPbkpBcXp4NjZWM1VpUGRpbzJSU1NRdHlwQ3pLVXNuclpRZDZQbmhyNldldVNxUnpyU1d3bXNLZEkyZVZGamVKeDcrL1BIK2F1UHVsT0p5ekt3VTBCOGRyekljYlhwVXc5YlpxbWo0YURwUFh1OVIwWkZvWldqenNlZXpTdWw3WlhqbjBNeG1oRk4zdlBQK25PZFpxcUQyYThObFMxcmwraHVqNlphRHE1NDc2WC9idlB3a2FrS2IxTGtueTBDdGI2NEtLK2w5VWJ6ckhJKy8zSk1qNVVQUFFwYXNlQy9jdzJpK1ZYTFdpanhRZHYrbzV2ZjRwZTEwWE00cU1wTWl1emZjcHorS2JxbXBsYkpkc2txVDMxcURXb1hOeHRkbHRublFkZjZNelVEdGhiZU9XcGdVYnEydXQxeW9KM1pNKy9NRjFicGtTMWJyWDJXbFRxa2JMK2xNTG9jSk9RZlVxMGF3Tk9WSUdWRjZBTkUrWGk2cG82TDhpTktKOXk2RExITXNwYkZrZU9PdFJ4aUllZmE2RVlnTDBMYTVkd0pxZFNTZlpaVVRNK1ByLzI1RkhNTWxtU051TWlGVG9Pc3RqNHlJU1ZMSFN3enVUKzdza0xBQnVQMVJXb09WZjlicTA2QnJVQlJMYVl5c2g5SDRnREtLbGpjbldYUWIzdlp2ZFEwOVMxSXZmdmRsMHppb3EyT0ZJMFM2aHhMU1NKdFp2N1N5dERLazhOMGpMQ1dPZkpBVmkxTXlCakxoczNGdFlhaHh0UzVTR2kwZCtRdTZDKytWWjRXTklnMEphU3RpOXI3YTRmdG9ScDBCYTA4RmpTTkwwTGF2TEgyOXVjS2x6cHdTL0FWVmJrVVFFOVNuNi9nQTFuckpLbUptSjBMamNXck8yMmlhNFgyZ1l1QVhVd2toaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQVMvbUhvM3Z1elgxZG92ODlIVHg1Wld4a3JyT2NKdHNDcGF1SFh5Qmc5S3VnbkNnWk9IOEJYSEJ0NkIzaWxHMmlTeEpvOFM1em5VeEFOeU1OcTUzV3lkeVNpUmxYVG91UzdOb0ZkUHJ0Tk8rUnc1YXpNYmRXblRlelF5Mm9ZUkJrazVTZGRvNHQram9kQXpkY1k1ZmdWbEM4ZHlqNEM2U2JkVm9kNlRPTGN3T2g1SHZtQXdvWnBGNnU1aXlMbzI2RGxkN1oxYjRmVzFWMjhqamtkVGI3WFJteVA3Tm4zdFBmSGFSWVE5UW1WNTJ0QUd5YlY5Y1RIbmZUK1dvdGpRUS83ZnY2VURkUFA3cjFwVTJmM2I0dnVTYXZRTW5iSDFzejVPQWRQTmNJYk1HUzA2V3IrWisvck5tNVZ3S2VqZ3l6VmZNVzFkOVNKOVBlRTlhWDUxV3dZKyt6ajBwVlJiYVBxdFZEZWhjZDNTYzdDME9kTEt6a2E2RVRzMGlyVnU2dG5SQzJHcHA4R051ZTRIaEt1OHUxWnl5andzMmFxL2g3K2N1a0kxRHN2dTJCSlRWdFNOZU93UXVzNjN5a0RtRU9wWFdUdnVXbjd2WHNTdkxjaEt1SlYvYjRPeWV2ZXl0NDdwbU4rU052K3JsOG9LSTRTc1pOUWJtOEhyZmMxNDltZDZiTGNCSFJSSlNkZWFRcXVjQ05EQjBydTNXVGZDR3NDV3k5NHJIKzBUbXRGck1Uc0hrSTFsTDZpU0hIbW1RY2h5NUJXS0hCOVZqbGFXRnQ1YmEvYkNoZURkNHF4ejcrL05pVFJBdTFjMjI0YXplOXZJMnJ1Tmo5cFhyOXRCSzdMYUNFcFY4Z0xXcFgyZTFGNW5yVzVKM1VJZDJVbXA4K0k3RVg1VGdjZ2NMUlBGY3IrUXN0SGRIa21HVlMrNmJpZUFEbEIyeHZrVU1Nd1Rmd2JXT3ZBaG5Oa1YzcVllc1ltZXZEVTlXMWpYZThRZWtSZWNjNWVpdUNOZTBjb3pWNlRBZDliOCs4OFZ6QUc1R0I3Rjd0UWoyYmp1RllVeSt0VDc4YUFMTHlUdGw4TXZwaEpDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFQWgrTWZYdWVINWx2K2hFeWQ0UHZTOXhnTWpJQ1p2YVVUS1NqR0lYblkwaXJUUHpQZWYxa1MraTduanZFWHdjQ0QrTWZ1UmlvdjFRdllZZVFJeWtHVCtIMDNNVWgyVThMS1FCN1R5UFMvbzBUSXZhajlyUjMraXg0b2htVGszaFdtV3NIdk1NUVBTWW5iejc1eDF2RnVWUlBzN1RYTis1MEMrcXhPTXA4YXRPdXJLR01YSmtVanVNcFRUU2RaMi9GLy90ZU8zeWlWZ241N1pZSjJyMWxoUFg2TjdSTzVqcE5JL1hidGtDSlc5dXd4dTZ0aERwN2JONjloT2pCTlBZUi9zano1NzIwUEV0Nzk4dk5oWjBCQll4VFRIcTFCdFI2K2lORFMwZWlVUGl2ZW4rZ0Zyb1QyZ3VSQi8xOGxxYkRUM1pJL2ViUlg4c04ySnlWa1o1YWVZTTRqT1VKcmo2Z25IOVZkUmZsZGllME44ZWE2cVZWVVVjbGlETlZ3RlVaOGRhTDJqNVI5TjR5a3hLZkhIa1Rlbm9EQ0psV05jTEdlbUtlZ1BPWVFyZlJlWDl2eDdNV2QzTW5mWkRJMjlyVmVTOGY4MVNrV1ZxK2JxVnJRdjFyQittT1ZOUHQzaDA1Nmo5UWE4bE5MOFNMVXNMVDhwMUs3dW9vVVdSa1p2N09mcGRTYTJENWllMWFYLzlKeXRjbHFmZjlWRW40cVBUbzNzSklSdnlMQjlQWjhYOTRUK05UR3UxNzdFVVdsMjhtZ0VwTTh3TXI4QzZBZVFHYmJQUlQzY0c2T0R3YkNuTlB0SklTbnhSNGhEZnpyc2tJZCtGNVNiT3pPZHNoRnR6d3JNbThialdWanJ5WUdZOERHMUFvL2sxR2NoZ1ZaNHpGR1dDU2h0NTBoeHF2NmdwRm8xT0pyRUFJV3k3dHJ5Z2xHS2NBSzhNYmMwZFNYUC9xQi9SOXZ1aFdhdUhIdVdWNE5BZFpaKzJMYXNwYkdZbkJXMDUxQ1gwempoa2hLRllaVzh6ZWNWNm9nemtJWUdnL3JQWGR5ZHhlUHhKSkw5bkludk1WYzhGOEl3eExmNm16Q3dmcExodklSdHhEeDBPYzJoekNuVkVKQmxrR21SVjBPdUtnMjVvbGtHdHkxdUg1MTNHWDNudGxocE4rRU5BMTJSYVBvRFJkWTlXWk1UYWc2NXJ3eG5iQVY4S3Y1aEt5R3JvYVJEeWZYRGVuc2duRzVzZFRRZ2hoQkJDQ0NHUDVBUEx3WSt1UUxuOEpZdmcwQ0tFRUVKT2hJYVhFRUlJZVJnMC9uZUV2VW9JSVlRUWNoL28yeEZDeUEvOFl1cmRtVGx4SjdnS2wwVTlQUTdJS3gxQkFCeW5wbjMxd0RwZHdIUDRrbFVWOHVXZ25UdHo3TVUzMDV2WE0wY2lPb3BHeGJXbmNhRnA2L1RqZWhiSkdYV3VTZTlPdGJPRHlqNXJibzRwS3Axekh3dGFYMjJTakp3NW1RQlpudlBXUmlad1Z1cFRqa0c3NUZxYnJuTWtmaVdYNW5vZE00Y2JmcFVhUlIwSlZBNTZTdVNUK0lKZEplUUVyV3lrSDlHQTE4TnpGemxocDNRanJWdkxsQndRNjh5K1JtWklvMnM2Zm9Wc0wxNHIwRThQV2EyeVg1VDk5bllSWldTd3Zjb2hUK21tMlljWEpkMlpUcjFVMW1pNVoxcDN5MEI1dklDbysxM3BWNkh4bWwvOXVxekU1THlYdVJ1LytUZ0hXaC91Tnp6djVCWEVoZDlYNjhEaGJqU2hxdXdpQ010Si9NUWt6SWd2NzlXNzFob0ZxYnVuVE1zejBOSW1KWjludlltbTd5UnZSU0hpUUw4NXQ4dXBJaVJUWkpsRFRSbStMbzFSOW1XMTRXNktjZjIzc0JUclNxZ2dpeExydXBIMXEwelNPT2k2dnluN2NOMXJiR1Nlb1hXcXIxSGRVUURaVytxczFLZ1lwZVIzdWlMSUxFQmRpeko3ZnUzVWRuMHNjMS9XcjhSV1ZuMkZqWnBUSmdjaHQ2UFZXdDY5OGkzUGpMZU5hTTZlQ2JTc1U1dW1SK1RxNGFOb1RzNE1xTnZhTnFKMXZZVlpwbnlGQzlHVzBVUGJhbXJ2S3hueGlLbnZiV3RKTXNsM2cyNDFiQ0NLU2h0REtOcTZEMXpMRWZJWk5FL0M4bklzZzRRc3pxc05ncitYeGFoaWtlTU84ell2bUY4ajY5L1pTbmozMUJBbm9ZNnZRUTJ6ZGkzSUtPMzEvdEtzVXE4b003UFhXeDhzMXNITTdhRXVUZ0xMME56S1hocHJSUFZjTndtdHh5UlpXaDZ5RUswVG90VWMwZkV1eHV0OFhnV0dxUGhlK2RvRW5ubm1jWE5HdkNZTnIwVkhtSHlpY2FoTEFzSzFaVDNWVEVOdkUxQktsNFIwYk5UbFNPYXk2NWtyeTZHRFI2djAzVDlaemxmblBaU1p5Q1B3T3VWSWZza29KTndHV0VWNXFxVE5MYzFsZmN5NEg3bFJwVi92RHIrWVNnZ2hoSkFMOEJRMzlSUDN5YVV2SVlRUVFnZ2hoSkFuOGNsMU1OZmdoQkJDeUdrOGRidjl6RHJRdFNHRUVFSmUwQ2lTV0RpaUNDR0ViTkFtRUVJSXVRSzBSMlNHL1AvKzkvODZSNkQ5OHUvLzhEZXNYODNNa1NvZjRLTlZPYUZ3OUdRejYxUzFDM1VaaWNSN1VsWXZqeFgvN1ZnblhiZnB0amprbUkvSktrVXllbExqdVhoUC9heEJqL0J1bzFGdG1vQ3lSMldkMFJ1UkJsdXA3NUJJeXlMMXozUTdmcjJrS0tYMDRuMFRlTWIrZmpXSWJ0UUkxcEdQNWNRMm5EbXcwM3N5NDNjTURmU09lc2RVb1E2SFZYWXYza0k1MHErWFZpM2p5aE03Wm5UdFcvNzNmb3VVYU5HQXZsNExyN2pSMGJGMDVtYUVkdCtlOXJpak1aVHYvNkF4cTREMnhGQkxIZVZYaHVMNUl1RzdxYkd2NVBVRi9TMjlVOGFzckpFNXBlbG4xSjZNSHFlT2xqVjZMd2llK3owQnJ5bDNtT0cvWHkxdDg3OWtpSE9xTkVVMVpXVnJPUnpKSlJaS0U0VzBuNHdOcTh2R0N0bFh0eStJWDVrT2FZN2F5Yk1QMEYrRkhFdVVkV0ZiVnB1Ky9aSnFjdGZrK3IxSHlGMUFQYUVlc3g0OXVwT3d5SU1sS0tPTnVHcTVYSE9HR3hGeEgraldXUzgvK1I0K3NkMWhsZWw1M3F2bFRZS01peTFKeVVwV2VQR1cxVWYyWTFMUzY5S3IyNmdDZGo3VHNGNU1jdFhGd3FpTHlFcUZaYTE3MGZ5eisycWVNZVYxQnZMK3o1R3R3aE4xWjZScmh2cnNxSG5hUUZwK3RNblEza1czTlh0cFIyWWpVUmhWVTViNkp1Y3l1eDZTOHFVMDNxODlsNFpBZUd3SzZrVkdka0cwaDRONHBSeENnL1NjQVRicTVUazhlejBrYU9JZGZVcFRUdjRDTE1WR1JjNVdvVTB6c3o3aXVGYndiT3ZjdkJINWExTkNDQ0dFRUxJSUxrY0lJWVJjQjFvbFFnZ2hINFdHYUQyWmpVd0lJVVNHRm9LUVNUaUpDQ0dFZkJRYUlrSUlJWVFRUWdnaDVBeTRBaWNqL0NzSHJ6cHBqSHdNN2RmWUozZTFkUnBFeFBtRTdrcWd4NHg1amhFd3lFcFpiVkdhU003UW16Tnp3ZzQ2aU81Q05xN2I4SkpPMDRPZVF6QlFXU05seFdGcGNPc2N5QUJYMVR5V1NLdURWaWRwUUNTSGJLbXNwS1NUNm1MSlRwMnlKbmwzNTZ2c3JQU3YrVlhha2JZdGpVUTVuZlVsMVJGUUV4OHhieTlGejY1WVNIN1MweHdSYVpoNy9ja3ZSdEpzMzMxYlZxY2hlVHdkcjlrRzBMcVhwdFhiby95U1ZMYlhubmdIN0l4U3NWaXhJaXpWLzNYN29uMmg3bkQ5a3JKRjlMd09GS3RGNTJ4aXBFSkM3M0RVNHE1UW5zVVo3bUcwUFNMTG1ETkVaZnRmM3NaWjJjZmxSbWFwUnFGUlJQdWwxUFlMcWoydk9DVTVyeVpiS0wwVDVaMnBhTnVpdXJHQVpTQTJ3N0lsYmJyYVJvQjJ5Q1JLWGhuSU04R2dhTXRXN1A3TzZUVzNYbUdsS1ZhZE83cnNPdHlxcHpSTlZEZWlyWk5ub2VRRnJvUkw2RSsrWXMzWGRpTTI3Nk1QZFppNVlhM3N0b3dJYkUvQ0Y1NE1lY2U0MXMvS3FaZzUwNkUydFJYSVZmam1BKzNic3V4U0hPdGsrVTg5dnlxLzdrRDI5aUpaS1p1UTcwUFRtSjZkWUV0MkJMMGRiK3VaUUIzWFhvOXE2VWVoYmJIMHdoQjVCU2dEZGRHajNJaGVuYnlEQlJtWVBkbTlNdXU4OWI4MGE5ZWdIVXN0UlVrM002YTh0R1Y3MXlyU2NqYzFjZTNmNU9aWWcyaEdwcVlVdlpQRjhub1FSYThwOEt6a01XVFg2K2xzR2JsWlJpYmtyS2ZVV3pkN1pDREtFbTE3Qk11d3R2c2NiYlo4RkZmcUJLM3NKang3NnRLdDJTRXVhalROQXJic0cyU1hwOVVVNkloSFI0cFZ0cFpPeWtQekdBanFMMXY1MlNucmNKcEdOWDlTOGtXVVhjZTFmNU11M2laR3RoU3MvYW1aYWR1ekZUMXZZOVJMNDFBYUFGMFhrekFRWDBqMUk3ME9wckl4KzM2TnRvbVdpdEJXaHh3YUQ4SHJSN1JZUGtBbmk5Y1dXRlh5UE5ONFBOWkNVVXJiL3QybXY1blM0QmRUQ1NHRUVQSlFQdUhWY2ZsSkNDR0VFRUlJSVlRUVFnZ2hoQkFuZktSQkNDR0VmQkFhUlVJSUlZU3NoZDRHSVlRUVFyNlZmeE81SjEveWEycnJMRUF0L1JUZTlvZzgxYllWM1J4Y1YyZlRpdWJKQXcrZ25iKzkwMTdyZE1RK01WZENPM2JLV2FRa0RzM1RobmtQOFRsSEw2Q2FXUnF3bzJkN2dXZXVtTW1zT2tGQ2dIU2pKNnA2ajBlMHpvYVM1RGIzSzUyUWVzampwWFRyb3JkOGJsSWs4Um9yTXpKMVhONlA0Ums2TFY1RmRHY3lHRlp6Z2JiemFqV042dzBEN3pHbUk4ZWFvbzVFVDBZU1pIaWNPbVdoWUg0SmJBUnZYcy9ab21jb2t5S1d1c1VjVEZ6ZXQ2M3A0YndTRk1Xcy92M3p2M2ExbERKOElMTGRRcVdTbDVQdnk2bW9NVURHa2pVbjJuVG90UlgrN1hqbXJkZFBIS1VhVS9rMzdGMHpZYndmeHAxU05mTmppSHV4aWt4QmQ0aWZmMnp5WldYV0ZTRk1GS2IxU1oxdlZnOTdiRWNLS0ROS0QxdnJxRm1pNUNSOUdkUXo5Vlo0STZNM3p0OWZLOTJHMzZBYm9YMHB0UURkcWFVcDZGQllxWTRQTnhaUlpqMCtlem9VMENzbTBwbklrbnl0N0pHeGJzMWpyLzRwam54YTI3YXhzbTdRMXY5eVNaWW5aZEZ2NDkrOWgzMnFJdGFrTDZ1b1VpelBjcFVPSmVRZW9ET29BSGtrYmUzVmVsWWFxMHdyM3hVOHZLOURhalRFaGJma0lkczFWZ2RhV0NaanhvMndUR2lVRzlGYnVvVDRkQ1FjZE01WStWQWlscnZlOUNQS25oQTMyK0RTMWtlOWRXSVBSSWtXb3k1SmthSFU0YjI1b01sUHYydmxlcDlOU3A5ajEyekhkRFVlNDRiSTlPelBhbTJ1OVIrU1RtcUxqa05pK2hGdHYyWWxmZE4vZi9wNjE5Kzl2dkgxZDIrR2pMaG9QYXptR2ZIdHJiS1NVZVlJWHBNNElpK2lua1RCOGtNc05jYk9XYytzR1VJM0l5UVpsb0pDMXFIVyt2ZmhGT01halpQU1dkM2RYby9zdWlORElLWCtucFFXenlHaTRIVTBVaWM5RzNrSXk0dDJ5YW95aTZzcVkvSzB2K1B3Ykdkd0srSmhvUHV6YmZyV3BvTjZBM0UvQ2hpUGxLR0ZVYzI5OEV6MlhzZmN1RUg1eFZSQ1ZrT05UQWdoNU1EVGpBT05JU0dFRUVJSUlZU1ExWHh5N2NsMUx5R0VYQmxxNlp2Q2pqMFB0alVoaEpESFFpTklDQ0dFRUVJSWtlRnFnUkJDZnVBWFUrOUtmUXhEU2ZpeHdTY1JlUUxheDArYlFJL0ZBZURKR2FSTGI3NCtkZkNnSjVvdExCb050OWk2TnpmWG4yZTBrZHM3c3NJbktMMDZlczg2cytKbjZqMTczd05IcnJ5TExHTDBIT2lSajdSdVh3bnRqY3lGN245R0s2SGFLUFoyZzNWL09BdnNrNGpScXUxUmZHQzJ6M05OcFhFNHdGWXdUKzBoNG0yOExqei85bGNwM2NOeVoxc2h4dVdON0l1bkdZUG84UjNWZnBGbnZUYzVKbFNpMmxyQWx3bUw4RmMzYnpFa3VadEJXb1Y5Kzl6cGpWOXRyWWJJR3oyVGN3Q3ZTR244YWdwNkVHMUlibmFtTmhGY0RobDhYZnVzMUJGb21hUDUxK3hIWkNIZGI0bHRyS2N1MGk1WmRyUkdnY3EyTlYvN29JVVFzZ3JVQzJsQlBMalZudnVLblFScUhJUFk1ZEQ1ZklNTHNjbVllZXhDbnN2WlkrVG9OaElTU0ptOGprU1NmZGFBcjhxV050ckQ2dEhiYVQrRFQ2ejdhNFQ3UDFTcGJYT3dEOTRiVnB2TVYxbFpNL2FmVmFhamIzbElyZkdwWHZ4VUN5S2FncVl5R0ZSMW9BMGZyVnJKTDJVZ0R1MWYxRVhJU3J5V3QvVjF5U1c1WXRkUWhRUmc2ZVBXNFdDanczam5ETm9GVU5uYmExbWUvaEw2bC83VkEvRU8zQW5qZ0t4elp2QU9mMjhlNHVRbWpjd2ZwdDRaejQ5VFV6ckZPM1p1aTUwTDRybjhBZGtEQlc4c0Q4WnJtMGhjZXo0QWRuU2ZEM2o3bGdyMXFGaXIrdFlqaHM4TWpUd1E1KzJZdlB0SFoyU0ZyN1hlcWxiMUdHU2tEcDFYcnhBZlFKUlhaMGJ6Mk1ZeGcxNkFyd1krcFRqVDIxK3BmaldsY3Rad2Z6SVhidE1oMVhDcFVsY2ErMGpaSGYxc3BtdmpxN3piem1qN0ExYlhXTlAwTnFvY2VndWtXV1ltajl5VytmMXlSWjF1dEl4V2VFNzFyNU95VUpmSTFqbDMza3BFV2NPVlk4akxHUXA3ZGx3bklYL3NTQ2lkb3R0eGZkQUlMNzJFL1BEVVhRZVRpZFZZTTMvM2VXYjZLbUtWaHZuWDgwaGFCVjJyak1nK0VlL1VHWFFCY2llUE9zUXNtWTJwdDlMMjB2Mk4veXZzOTNvbjI5dXRVbnJ2bEdudGNZbVlJN09jWVF2UU1xOVNGOHhIemRQMWxMeW51aTYxTHNsaVRza1QyNmQ3MmFsWHlpeW1zVnA4WDlyeEI3ZVcwdmlnUGlUa0lheGFxYlRoeFpFSHlSdVIvbXNaM1lZK3U4eFB5Qnd0TTJJd2F0dFpHWlJCazNjdFpwV2p0c3pWMHFVbWZacW9reVV6Ty9JU3NnenZnTFlHc2paNFBSNkljMFBqUGIrdE5Yb1ZMdjRvMVZOb1JOclpaeHBvSFpEbktHaTh0K3hGWXQ2YlJkVjFTNm4reUVGMUFjQjJJdkRkMXdMS1JNb2NpUjl0T1hRVUE3TjFWbE9RbGJBVDdzR3E5V0J2SWo5ODdIaXQ4YWgzTmRLbHZUSm5sMmFTUEU4NGNZQTJvbWFZUzJKSFRLSTlzZXFsYmRNZjRodWh4L2NkakRxVVk1eGFGaUVuYzRWbkdvOWhkckgyQVBqRDFMdFRlN1c5QjBsUG9qamplNnNHWktjSEVCV2hnMmdBdmhock5WeW5JUmdqenhvdTNNYkZlWDBkV2tNVFpYaWl0T1pJWGVKZXVseFRWck1TRHJQMW5yb1VKYlI5Q2JRNGNxK2xCS1VoNU0ySkF3Yi82dER2UzlTYWFsaFg3VkNGZEFJampvUWxZMlNyQnlsbTBsYUkxNlBoRWN6SXh1cGJJdXBmc0ZjVlZyUlVXZGIrWjFwRFZHK2R3ZFVzL096OEhFTjdJTnIrN0FhcXlVRFZ4dS9HMkh6cFNTNnJWMVVyOU5rS2tNZDZiVHFFQzluOEdUZkVVRmRTdE5zME4razkrYjFsVFEvN0FvWjVaYmk1MG53ZExldnFmbkZNeHhiWWp1bXZEeFJqQXZkK2NGckgvMTdMcWZhL3VPbVYyZlAxdnFWL0Nia2ZaMWtHeVcrT1hpVTlodEh0akJrVnUyYVJIcHZPa2pIenJHdDAyVC95U0lPbThCcEViekhNNXZlbUhaRm5MV3M1Tmtrb3EvZkpaNTRwWjE5eWFZUGhUOWoyaHZaMk1sYjl4dmJmNi9RaFJwOXBlRjZ2OVhwOXMvR3I4cVowK0NRVXN1d3RLVVg5S0hXVnV6VHEyb3pJenM3NExjMm4za2FoeWZzQzZEZmZneWdsbzhWeGZCendXbHZ2Y3FFWEhyMGRFU21QUTJXQVVYZFNnd1o0S2FQZDhwNi9CVXV2eW4zMTc0cTNvTW5EQ0JoRXErd1NBUmhSUmc5VEZ2eGg2aE9RbnBSdWZNbUF0MzY1UDZVa0wzai9kRmdlaWpZZlp3YTRaMi85RzRtYUxBUHRNMVAwdE40NmxkRTdMZFcvV2JpT0FCbmdyVGVmbXVzc3BKdWw3V0hyWmNZQ2hvOVVSWkhsK1F6UFZ5TS9KcUtkSmNPMFU4cTZQckVxZUxxU3NqQUxOSzBWZHl2ZitxUFVXVkNiZ0VYL3B2dUVIdmNNY084bytvRFRhaFg1YXVQdFMyRDkzNklxYzhwNU8wZVZrbC9YMzdJZ09NUEx2WkluSFZXWGF5emFjamVtZURLNEVEVmtUdnJIVExYTXcxajlxQm43RlRodFJ1ZG5XRmphM3ZySVd5WWFQMENFeU1WdXlIdlZLMDJWbkpaL09kVXYvUFh2SmR3SXIzOVJPdGRSZU9ZV0txc1k4UkdnK3NxekZ6SFd4cG9Qby9zMjdkNVJTdk43U2Z2NytTMDdDV1czWlZodFJ3aFpnZWJxV1pwMDVZb3pLMkdXOStncHg2T1ZId3RxRXRER1hPM1NTNHdNQ2lrZllxNUc4QzVGQ0ZuRjdOaXpucldQdUpXRURGdi9yRnhiUnNFN1lJTzloWG9qby8xeGFsdG1hY092aG5mUElRSHAwYjJ4TXpkMDhqNWFZOWVmUnRvTGZTblZJeWVsTlBWZVlWVHZuV0YyclBzbEYyTjBXNHVzUjl1TTJPSldLaFZPNU5QeDZHWFVKbmk2aXQzNmhZeTZrK1IyN003b3FmNWx0NU8vYVB2UDJuNDBNSWlRbllpVTR0WlNmQTRSalBjeDkwMlVDWCtZK2hSNldvUGFCT05FTDRKZDhsRHFoOGxGdUI2Qmc0bDhIRzFnUjlESzQyNHVJVHZPZU5tS0dGeXhFK3k2ckhWN2UyOEhSZHVJbE95WENheDRUMW5ldEJITzNwbU0zdWVLOUdmZ3Y5K29seFY2SVJGUzEzRkd2MTl0ckNEemR6YitaQTVxNmpQMUUzL010OFNzZXZzSGZab1FVUmYwYllVUHZLU295cWZqNlFYdG1jS25tMlFaVnh4YzgzdEpLN1hlTjNqdWhCQU15NE9KV0xHTXJnYktRQjVDQ0FubEU4cG10c3plRDllcFBNa3dLNnc1RWg4bHc1TXZHMm1idFZwR3lyalNldlBtbXl0bWsrZGpFMGpkNjVJNUQ3dzNOaGt2bVFMVWQ1OTlDa2dJdVRBamkrL1Zpc3Z6S2dVZnpiaVo3VDQyT1NGcldiRjBWK2Z6SytJOW44R0p2ZUl0YUhKekJnWk14UHRuSEtNZlJGc1kzcnhqK01QVUoyRzljeDM1OC9tRVZRVjk2THRrRG83Y2IxRmtXT20zUStkS1hGWElqY2hBR1BvTTRPbURLT3I0andGWkhqM2xyYVoxb01wbjZkVUtHY2hTWHZSNGtQTHozL3RUTWdtb1gxS3UyL1M5TWkwS0dKWUhaRnR5MjBjcWhzejJ0TlAzaWp2dnI5VmplK3EvcGNjNSs1cEpJV05mZ2R2S2luZ0U5ZWYvL2g4VTVUVFdZMThIY3Z6U2gvM0tVMEdkMXhOcHYzNWFtbjl6bGRMRG1uVndVYVJyNFZGbFdxZjB0UEdqQTlpYnI3N2YrTmFXMjNoR3pwVW1kRHZ1aXhLemhaUnFUdXp0VDI2K0xsN1M3aktwWHgvZlY4QlFsVE0yVDVlNnEwQ1lQRVRXNk9hQ04zd0ZJMlVoeHRBak0vSiswZDBVekppTFB3VE5XQTFLODhUbThMVmg2Zk9QYXRQK1JKaGZtclJ1VC9OMXR6ajE4NWJ2RE1tUFovV1duZUhlT3FSTzJWcmEyWFFMT1RvMyszQXBia1pXRlg5NE1MbEZWL0hhV0VXL2VBcDlJYlgwODVyNURUbS9Bc0YwSG9vWkVDQjAxdTRnVHI3bU4wcHBlMFRhSVV1bWRwL04za3FBek5Lc1J2U1dQdnB5Yjkvc2JVSDB0TFhNZjk1bHkzVnM4L2VIdDZ3Y2pwNlBwa1F1b0NzSnVSSGFESk4ySlh2VVdzN3IrYUJlMUloSEY3MHFpRFRibDhNeStWYjRobmZacTNXc0pNTzdORU8zMjVHeU5jNTRwS0hGazJzU3ZkUnNzZHptM3ZWb0hUeGpqdU9UVElNT1hIUER5b2hIeXhxWVJBZjdsZVZ3TlU5SjhoZFVyMGF2amIyT3hPaTZIekgrU3R4Qlo3WWJWRnEvYWZLYTlOdWViMmtVODk4dnF0YlhLWlJvbjNYRW45WjhlTWxNSlNXdEZLL0pITUd6dTl6R2U5YzlKQkR2QU5jR0dUc3ZIdStrMnRLTTlPZXM2ZGRvOVRjNU1OT3R5TktsaDhlREdOMjJvTXE0QUd6c2o0S295TC9wY2pxOGlsQ242YjA2RUZrbjhrQ3NQV0RFQ0Nob3RtRmt5MWRiRDNuY0pGSWhOVmpQa1hpQVQ4Y2ZwajZKZWlCTG5qWTF5WExRelNwQzNtZ0dpUFBYeDVjYTh1L3ExZzgyOGxkOE9pYjZVY3ZadEczODdmZXpaK1JPdnVydVo1NWRqK1o5bkYzNnhOWXZWdWFNaG96dnhrMTNaQ1Vjd2Jwdno0c0dhTHczWDMwL1NObkNMb1E2dHp4MWplckJLMDdvZloyMGtkV21sWCsyTUQ0KzhGRzdvZzJqWlVaYVE2K3NxeHVOYUdNWGViK3orZzJ3RU9aZVV2bU5lMmZvcEd0a2kvUDNsYmIwNnBTUzhDUzI5SytSdUprblVEOENqT3NSR2FQeHZZNnIwM0ozYXBTLzcrc05OdDlzTHlONXJxNWR2dy9PbFhYMHZia0k4UG1ReGJ5SVJpV0VYSk5WOHpiS1l5TVBoWTgweUNlSVh1NXVlSjlqMDYwbVg4dVorKzJyUEkyb3NyTWpQWEVUNVVocWU2Z0hHZldQamNzK09MQjdQL2xFd3pKRG10bnlQSWxNUmhtcjRPNHVJUVlqbStaWGVNekpSem91WnZSeWNWNFRRczVIbW9laVQxZnNmUDBJR2FwZHNnd09ydThHZVVYMVlZNEVmNWo2Rk9yM29pLzBGZ1dxVTJkK0w2RW1iSGVTMm5ndHZDZXp6V3VsTTBCK1RFOXVqRFJ2NjNEeWl6Wi82M2dwalJRK1dlUk05MWdIcEdUait2TkRveDZzOVYxb0E5aTZJNFBkNmFCYUIxdWdQUm5SdXExczFJZ2dkV2dIdEhYL3lnOEczdEdTa1d5VlVWc0d1dFczL2RDZ2lMR3ROUGtyYytoOVdzaDVJK2J6SmJCOG5OVEV6OXo0YlJyTlFEdlp5c3dRajlhdFVsZk1ka3RzOTJabitHdzVQYnZUeG1zeVJzdEh2ZmhXdjNyTFNkWHRJcmFpeWJ1ckIxRFd0TGZqeVkrWG1RZmpSKy9HOHRVaTFhSHZpNnZSZDVvQWVWcS96aXkySlZtZSs0OVk4SS95RFVaeFAwN0Uzc3VWU3FuVWxIVEFmaTJ4ZEdScVpPRXJwVnFkL3NhOUl0VzUwZnYwcFBrWjFpZ2lkblNzOFd4cHZ0cStyTEpEcVpLL0dNdUZRSmFnTFZaM3ZNZmFYbTV0ZG9zeS9MYjRBOXR3Ujh2dURPZGQ4cUxMVUVHWHZ4SEQrUlJRL1d2WmlKNU5TMERhSGlOMktkcWJqOTZMK0UzVDZ1VnlTSmQyOGNjOWhuYTFmL3pxZlc3UzRRZUE5UG85VjJYdVF3VlRlS2dEcnBjSklUMHN6ZGliWWRacTMzSWp6c0JhZ1Z2eHQyRmt1UlRsZDFnbUVDbkQ2MFprUU5Zc0hwZW1sMzVHTmszZ1BSaVpuNk5sb0hYZzJDS25FL0dnYkFYV1JzZWtKN0hiNk5qQ2xBMk9iVk1qLzFNSGRJU2FoU2FjcUhYL0NGN0R1a0tab20ycW9leVZpaktLRW84eDRtNjBvQzNvN2VWNmZZL0tHcm1mMFNjYUkrbHV1M2I0SmxBVm9WM1Q1N2tIVWI0c1l1WWVPbmFzS2RXbWl5eHJGR3QzZldRcndodFBBdkE4bWsxZ1dqSkZ6NmRyTVYzYWpFV3hlMGtvZzROb1p1eWhLMm10ck1mYW0wOCswL2d5K01QVXV6QXkyN2t6OFpXdzIyNU91M2xndlROR3h2Z0N6MGp5Uzc1akdLREx2b2xPY0RjRWw0TGZ6SitYVExQWWg5N0hPbXMySXkvSnlJWllWSmxFNGZwTDg5NU04bmR2NzM0dE8rSFpQdHpTcDlSL2pOeks5RHllN3NuVzBudmpxdmpSdVFUbG0vVXNWcjY4RVpYK1BLUWZMdlRpUnlqQ1h5TzU0MEhIVXFRMzY1MjMxdlhUL2NOOXUwRGpGVldsUThPMVFDSU92VG55MWRPd0g2VVc1N1VXdGhwdGs2R1hyZzJ2K2NLNWM4Rk5mODk2My9OU3dqSzg3dG50T09QbW45ckk2Ky9ibmg5WlRYdGRUNVNRWnpLak1aQ2RpSm9WbWduY0ZWZ2lteGhjMFF5ZlVSK3ZuOHpITFBmbkRHVXl1alVZOVpJL0lTWlh0Y2lqZTZOVzh2S2FUKzNlVVRQSjFJUGVQT1ZKRTVxVEdTSnFhTFg5T1BPR3ZzR1pNK2xLVDA4NG9nbDVPRE9iaStpam5JY1QrVnhsTmZSMGJnbzc5aXQ1SDNvZDFIY2NBZ1FtUUdkWXRvN2o4UVJHSFlzSCtuU3ZINlpxZDA0djkrdEFsZGhGdTdWOXByQkVlRklLYVF1MzRyY3dSMlhSYlQzT3VvZFNqejEwczRHRDVnZXRIVW9uclFiWWxwWktHVUZUTzFxOHhybkRRcXBsN2ZiVzE3MDhkZmhFUzd3ZnFIaGQ3OUd5a2RhMmVzS1NVWUM2Z050dmgrcS9aTHBmMEVmUzl3MnJwMldMMlMvYXo0Tm9VY2tFMHBCU3lkM0xGVVB4K0tXZ0xYeEc1dXBaSXprN252aVVjSTlhQzV1NXc2eGNXODVhY1Z4WHdUWHZEdmJvN2RFZVBWT0hXdmJYWTVkLzcxZWV2ai94aDd0NmIwSnZjNnE4cnBOSks3c2ZmeXc5b3FYLzZJS0MrZ0dLQkgrZU96RXlqODhzMjZwRFhQL0pZNmxCVXM4emhrY3BJb3h1ODRENkdCTVduRy9FMXZYS2JEY1pVaE9maEhRZnhGcitlUFk5dGIyVkVUT1RNUE9ycFRsKzhiY3Bvc2hWS1o3bHI4SEJqZkFNUzlUVXJGS1pVcUdIc3F4S0x0eUxPTWdZMll2b2xUOWlBNkwySXVxMHZmUzJyTi9XcVgwanE5MjFFdnI1ZnUrdTdNcjh6VzE1Y2phNWtmVjByNHFRV2RCZFZpa2RvcGtrajJoRVUvWTg4MCt2R3I2Q25nK2h4Yy9lUExMbFVKdHd4RHhGdVJIYUlQTmd1UjhqeTEzcmZtajB2aHZVdGROYzNNaCtYN3ArSUdRVjZDVFM4czJzUFoyOE53TGE2NklYOTNleklRbDdLODE5bC8vczQ5MEc3Q1hIbFZZemVscmJSclNsNVVpQVRvRzQwV000SG04ZHFaUngyR3l5SEJZcGpRWWdhNUNlNmk5QURWYVZQU3BQb2pkYXBiUjFPblNOb3NuUnJudDV5VUpXK2xIRVI4eERXZXc1UXk5L2pUUnhlODgwT0g1TVJwL0lJY3VpRVlwUjF1aldBbFhLaVVpTlhzOVZFbzVuUHphMGtBNDlINVdRSGRvK0s3SmtOUWJYNk5qckRYZHJibG5ydHNmUEIwU1hQS3lSWGo5TVJaYjg1R3V3SEI5MjZ4aW9Rem1nUkRnRHlRRzA4emxJYm9YbVozcTcrVHVIUlVkNXVqM1p6V1crbTFkM2hYczZydzVubEVUNzIwQ2JJb0E2MW1mT3pYVmxGampGcXZ1VnRqeXV0SjFoUFFwQThsalgvV0Q5MXlrRkRFTTRVeGxFZXpub0t3M1JsTU5WN3NUM1E3MGx6MHA1cXZMM3Z2UzBTdmFzVE9mVGt0d1RVY2xhL1I1WmgrN21kMmhYZ1BvWWpoL0oxK3ZYREtRZmVVRnNsVzhUVWZaaUxySk1qTnp1dVlKMnVqY1hHREEzNVkvL2trOXUyeEZ0N0UzSE9VYklPWGkxODhpTFM1RDdESWJQOGhqZFFyTjdIaU9UaU55TFVlZm5qTzBPT2xUa0s0amVJeHJkaXhrcEUvMUpXeGFTQy9YUFBWbldHNXFlKzU1dDgwOGFzNWZoUGR5QzlzdWpKcXUzS0UvNGg1b2xjbTlzVmRsdGVtOVRYV0ViY21RZFJNaXRpWGtvdXo1L3JUd3U4a3pqbXhqcG9rOTRhS3ZnY0RrUnJiRTViNmRCMzN3YWVwMEJmY2lUajJXeFc4a1U3UUFhc1BVemIzRnc3QzdDZXZqOHdJYi9ONUY3ME83cElRTmFlMzl0a3RJcFFrb2pZVzFSVGpIejFMalc3Q1hoKzdoTzBCL1JsODQxZVJqdG9GazZpUzVJNUh2bEV5ZmlXTms5UDVWWTQ1Y2dHbHJMTTZyUkxibVNiTW1vVmVIdFNaN0ZXbjZXanV3a2x4RTZlYXkyaXh6QVJoMXlhWXFPMkpiVExGS0JwT1JPbTVlM3ZEWWUzU25ZczhqMXVSNGpUOGYrMEhNc3RDbmxrZmwxZEJ4cjlIbjZPMzN1cHgrbzFabGFXVXJUWjhhQ2ZmT3FmTlFMQUVSb0oxOS9kSTRoeXVNVDdPdlF6aG5URnJSTjY3bWQvL1pMZWZYUmorYVliWTl2VjZicWdHNnViMnVSVDZRL1ZsVGJVWTY1L253OXVLVGVUNTczZnVYK3EzZUl1bW9TYkltcTYxek5wVjRWeG9aT2xKNGFHY2NlaDZyMlA2SjBRY2UzVWZsQTJSR3VRTHNrMFl4QWl6WlpKcHZoYjFXVXZMbjV3N1ZFQTlOdUh6dFp1dXhOcUV4dDdneFV5bDMvbWZXdk5DaXNwMDF0ZWltOGQvK0ludWh4eGw1RUVXT1BYeWM5M21mWjZRTzdMcTJNMXY3Z3RQWnJIMTd6OHpYeFkxNTlJM1lVWkRWR3lITkFab0UwKzdTVnVCUlhqTEpSTGE3SktJTjVSNG55Y0QrT3g3VE5OTExIaENONWV1bEgvRXBwQUpia0g3akpXY1lJTkZ2WEpucjVHelZ1UEdWbzZRaFp6b2h5MWJ5QU5DQkxrK25FY29MVUw2aVd0SHNlTDIxVzVNTWZCcjAxYWs4R3NsNUMyeWppbWNiTTNrSmRadXJVd2J1aHBjUmJ6NUhlVFkrMHNiV2ZjeDFHWjIrMGJHL0xhRHNPTTZheGRaOHRkNUpNTUtxdXJ6dVY3b3UxcmJmU2Y3YnlTSTlST0RZdVM4UlNmRFM4VndlcWxVa3NIVkhIVzJuSUZMMDVCdnR1alJCdE9lU3BEeUU3UEV0VVVHZk1QbC9vMllaZWxUeGxjajZBV05zZE40US9UTDBiN1NLbFI4UkNxbE1GS2g2ZGlLNng5cERKaFZteEF1U0ErR3JPNjY2YmFPaEw3cUtNN2pRVG03Z3h5dzI0RjRqTkdOMzU5S2E3TXR1UFpITEFpUGtDMWJ0ZlJxeXFzTWNPamI3eFY1ZFZ4K1dtRGlzWWViTVJpMTZRY1JHZnJNOXYyV085UEY5MzdZY1I0NUsvWFpuT0dwTzdFOWtPb0N3bDJYdk81RTZpdHd6RGtUQzd2Wmd5UzFrOVJpSnN3V3grcEE2ampsZlBKcTZxUTV2K0E0N1BoWmRrSzFxYTNJMm43cVovN3I2UGMrNzQyRldlbDU5ZUp4RkNWckppQlhPR2phY2ZRUWdSaVZJT1oyenZlQmRNWi94WWxqeWNtVjhYb2VFb0N6Yzh1c3VRS3JJNVZPNllMaVY4QXBaK1dRZWUrZ3orVElYMjJUVnBkTW1SczllS1I4elE2cFp0NVhNbUVXSmdQVTZaa1dXRmo4aXFrU2J5QngvSmtPdkM0VUR1d01UYlY3L3BSblU4ZFN2NUlQVFpiOGJESHY4YVAwemxzdlFyV2R4dGlNMzFudGNXdWVaVHNSNVlqSnhjVU1zcWFiamkxdGx5bklVUGhtb1lJNFBoeFpEUm1jZm9lcU9uYWl4MW9uVjNyQzd3ZWptekdyMU4yMU9XYlN2bi9hV2FUb3RIYUZ0M1p1Y3dPL05yUFJ1eHVsWDY1VEJBWCtuS3pIMmpWankvWWt0MVZWL25Sa29SWkdxUGM4YndqRjZTSHZyY04yUHhJMU5sa0hhdW9EWUNTZmVqeFdwOXVHSmxIUDJqVk92T3BQdUJ6ODhEeStyVjRmaUMrNkZ1M1U1WjBRY1czN2NLa1ZwWTFmR3ZQM0pXN3RNMS9INWZ5Q2xWWHFHWDVleGQyMmVOckp6S2tqNzZkdXRvamQ4VjkvZkpPWU9WblMwMWxZNmV1amJHaXZQYVJVN1FBNkx4citTbDFQd0tWNW13bllaS3ZUVERsUUhENjNoUEdTTjFHSkdUVW9yd0kzNEhvVnlFVlkxNklGdGxvTHh0eC80NkNaZTdENHBVZjZqVkIxV0l1WFQ3R2hwamVaaDNFVHJWSytNTVp4N3hIN1VOWncxVUx5Rmx6NUdGditveURsL1gzbDNYZmY5N3JkZXVqZS83NkVlYmtidjE3MXVBMW5jYjFITWlrYklJK1U1UXJXVHR0MHN5cmRWOXZHWThFcmwvVTZmOWV0ZkFnOWFoMFc2RXh6Mk85anNSR1pMckxjVzMrWHVQVTFBM3BHOTJaZG05ZUhJdVZyOXVSQ29xQzIzcmRGVDJ4RktVRUp4UFdHQnBzaGdiZlNucGUxMzFzNjJEVG45dDBHMGIzbHZhM0pTcDZuaDBROGV6bCtUZGwwTHpTWG5PQU4yN2J0S2J6eVNiZEZvUlJZdkErVjFyZS9MMGR5NUcxYmZIakVYTlhtM0V0ZmZoR2QydGEyZTFoN1NqbEpWNDdia1pDV1IwWUxGVHZndXZFa0g3ZDRYTWh6S3luTEIwcHlZNzBvT1kzVE95bHVTOU5JOEgzV1BxWGFQR20wd3o2OHVacjE4SkU3MkEvY3J1ZnlnekR6VzBQVEg1RWw1cFI4SnhiZEJiak5iOSs2RDlTdU9IcVovWWdDRWhSTzJta0ZPd25xV1NoeUROV3c2Q1dOQ0hyb0ZZUGtWdTByVCt5UGVDTnFxajhaSDVVWUxLZ25tUTEzZ2pSaDVMZmhVck5yMW9qNzRlUkZ0dHI0bmpIVDR6Mkt6SHNDV29MTTJ5OXVTczNEa1cycmI3Tkw3NHdrUHc5djhLZkxKYmYycEZHWllNcVE3V2orYmF3eHFPOFhaZVh5NkViMWY0WlRMKzI1aThuNnlJeks4L0l2YVdIUGxSMVRiMW8reTJFRmhVck02SVNZZkswbGFiVW5nVTBxT1JvNWJrV2dxblREVFgzVFFmV2NWNWMvS1BIczhmbS8vSCszeWE5MERJdHpPanJielA0a2JtLzZxVldndTlxSnR3cGt0TTk1dEVLYUxyYkFucU1qald5VkpXN2UrZ0Q3NTdieFY0QjMrWlM1T2xkTnBiK3owaEpmWGZ5bzJhMkYrdUlKQjNKVHd5SnBvaTBrOUc0eVB5clRhRjJvN29sbWZsNktQcEkrUUV6bEJVZFI1T2JEY3I5bkh5WVB5WklPK21ra1dNdmFoQ0JwbCtiZUVsb0QwTU9QZGVYU01rQWsxUEFEcGtkS1ZOVHFBNDRoN3lxc3kvaWR5WGRnRFg0Uk1XZXVWdkhMSVNIb0lsWE5QV3lCTnFhOWVwa1oxTFA1c2xaZ3RiMGs1a1BjaXZGTkZ3SXRQenZuclBORHBvamgyaXQ0cXpDcVBkdlZTSHVoNGVvV0Eva2ZMZG1lY3hnRlRHU0IxUUdXaTRCbUtRakxqMkV6OEZYYnA0K2tJYndTWEpKZTFEMm5ENXk2bG9tZVF2V3ZlT1RMRW44aVh0b25WakhZNXJqZnordnhRK0QvSVkxcVB6cFBSdG5MWGlyOFBQNUZVM2RCNGluMHVydnVMcHJ3dFNDUzJ2WjdVeXEzaU8rYzNSMmVpOHc0alFUR2NTMHU5T2pUK21iZE4vUnMzbUJiWFE3dEJLN3pVNE5FeitPWVhJUzcrYkVTLzJKVlM2NDgvdzNySzhpbjczNGtzUGxWZmE5cm9GclhYdmJxMnZDKzh5U2tLblBqVjU1cmp0YlFpZytXc2tlNXVCOEo1TWJ4MjBPS2tPZ0lnNmE2L0oyNkpLSjE2U29aVHhma0NaZE15SG1Ha2ZYNng0WkRsa2dhcmhTRmZBb3JnakpvU3ZzQ3ZGdUc3TGJ0TWhnOUtxYjFIeXR2Rm9lRTltM3djNERyR2lTUGxkNTljL1RxMi9uRnJyL0xMejlmS3VMTDEwTFh5L01qcksyNWNsaGJkbDRDUEw2aXRDU0EyaTFVWTBPcEwvbnlaZWN6UFExZENzWjlpcncyMFlNZE1qSmc0dFN6TFJCVWlINHBHRm1uakx0L1hrdGRKNVRScE4zM2N5Nmo1TCtmcHVKQzdMKzJoS1dHb1NzaDdMK25zbUY3cFBvNlR6MnBZZUI1dXdiUnBLa1FoU0pmNUo4anJibXRpampvU21zR2I2ejJzOHBiSTlTZytKYjhWVjZhV05LeXYrWkR3dURpS2oxOXZXamtKeXhpZWxyQUtVVll6d2RwZERxMXV2REhJQ2VUS2VQQS93OFVrMzN3TVpYYnBzZVQzNS9sUGxpeTRMOVNKNjZYb2VEdW5nM1V2S25UUmtpQ2lmYnpmdUc2SHVWd1J5UjNhUzV4ajlMV0l5c0U1SGR3L3F0SlpONlpWajJSdnlZblI3QjlubStITCtTWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQURrLy9lLy95ZjhYdmQ0UnNlLy84UGZzSDQxeU1tVU0wZklUSUtjRWZmeFNzd2VzZVBJKzRFdUlGZkVPcjZJQStVWDY3akFFOXBxWlpIeDFWOXhOaFo2Mm1jdmJ3dFl0NUtNTWtmdUY3Vk0zbU9hcFR5V0RPdDhmQ1dmeDhaYm4rdUJ5czQ5QWRYZDVpWjhab1JiSndaanNyWGVidU8vRHUreGVoLzBCUzlGNzBSZzcybDVIOFNyclQ1VDVRaDlMY21TOGlQNnl0TFhHaU9yR0VOL1dVZjJIVDZqdG1Md1JjanMyd1k1ZmEvTWZ2eSs5OUF4dFcvRDM2OUF2bUxmMFoyK3FYUkYvZFhJM1B6VjJyejdxRjMwZlBFMmZtYjhlc2VXQjh1L1NFQjhFdElpdXFLM1liTnVwQlF6SU9sSGpZSmZUaFdwWklwRi9sZW1LTThjWXNaOGhjS1JjVkFYdm1KY2F6S1RVZ2N0WHk5dk1tUjY4eTFrcEtsN1V5b3BjYjM0Z2FGbDRqeTFONitzdzlYY0NGTjRXNEJXcUxjeU0rUGVxd01zbjFVS1Q4NHl0UFFqK3hrSnlvdlhxTi9XUldnUDdTNys4d3JSOWh5TzRjZlMyckphRUV0T0NEbWZFYS9aMG9Rak93b1dVVmJxOWtSdFJVZ3lVRmUremVOMTZVZXd0c2dRMTE1ejRTTUduYmRNY2szUUxkRTZQS1Z4cGJkQ3NZMHNremsraWNnbkxMQ25USFFTV1h0SnZYeFM4azQrOHd1YTFzWU55c2dFM3ZMODAxeVBZQ25GdHN3Umo3Slg5a0QwdGhuVVB1OFAxWDl4UXEzUmZZYmY3QjNOM25UU0tKNWRSMGl5cFhqeVlVWlZBanZ5bXFEK3M2V2d2QzZBQjY3SjNJdytpYlU4SEd0cndWT20xNHRnOTU4SUczczVLN1lpTWpxcE1pNmJRNEYwUVJjU1FGclV2WXdBZlpMTThkOHc4c2o5cG8zSVg1c1NRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQUk1WXVwUi9qRjFJdURIcVhpT1hsbndlR0E2RUVURVFjSW1hQUg5bmwrd1c0QjNzQ0NwaWRYQkQwK2p3UEN4anFpbzhZNmJUcW9TT1NRWG04VlBMZDVIU2FPOGo2YzdqbHloUG1aWjI3T25uT0pIcHRvS0kzRDF4NkxJS0p0VTdTT3FWTjJuVmIvOXNnYW0rOXJlOHNGK0hxMTZ4M09LeFRXVndBZVE5VE9LYy9wbHd1eDVwUzNhbHByeE42dU5xaVFQS2pUN2oxU2FzYVp0K3dSV01iL1orL3NrbTFIY1N3TUZSazkvL24xUTQyalhvcnVlOC8yUGphVzBKSUEvNjR2SS9LZWJZT0VNVWdDYkN4V3ZuSWR0ZDBXN1hrR2xNeTZiaW52aUE3aWEzMHVqVnE0NGFSVnczYnBaK3o3Mk1zWkJtN0dudWZvSHJKM2RXNWp5MTg4dmo4di84aGwySnVyL0VsVnBPUWhLN1g3U3VzaHQ5TzdUNlJsSFpBcnQzeGdqZGNudEk1SC9lc0V0Q3BHMDB0WXQ4L1FIZlVaTFJsWnFmcklGMUxYT3dDM1B2aGRrT1liSmZ3WjE1RWNZUnhHNlRqU0wwVmkyWFlNWG4rZGRQKzFlUG40cjR5OUx2a29JbHN1VTFMeWI2VnZVMnJuN3g1RkVQSVVldWM5ckxRYVZzeUtSbmFrd2F6aDdscCtTckViZVdRWlpzcnFiY2prR1Zqam56cmR5RGJtcFhjNFRNaFU0Qm10ejcvZXlRaVBqcVRvVW5UWG54QXFTVTczVFJ1SnJJN3NsRWZNdDZPTHJ3Vk1IOUdsMVdsZ0RqSDN5c0pCdzRzQ0hrZHFPTnB6a3FJN05YUjZlMGhMbGplZGIxYURuSUxXY0RWNEE4L0I2a3gxT3RUQTlCZ3EzdjhtcUsrSXlKb0JlcnU5VVlQbWx3aUFGVzZoWVJpWmdqdVdzOVpnRnh5aDdoVkhQZVFDZExTcFhsVnBnbXJVRkxLZE4zaDU1ZkJ0VTBJSUlZU1FSOE9oQUNGRFlaY2loQkJDQ0NGMzQ4d1lOak9BSm9RUVFnaTVMUXpsQ0NHRUVFSUlJWVFRUWdnaGhCRFNnRjlNZlNxdDdiZ3VoTFhEMmFHRjBJaHVRYlBrQmZKRjlrSWtENEkzZUJ6ZVRTSW5xUGFZakxXSlFIYzBSTW9RSTdybnBDVlBBdDJyVWRIVjJxVjFJNlBuL0RwZFN4ZTZEeWF5SDVsSFIycWtkVnhYbWVrRWF4bEpsRldHNlBRRk96Mjc0OTJTM3R0SFAvVkR5MHhaeDd1VVlEbFExZXN2QTYyL0dvUllyZU9hUW1TM2JTdDk2d28xQnU0MjNmSjltMlNnZlhaOTNyUFhEMG55SXZtT0lsZnRmUDNYNzNHdDZyeGZUbTMzblcxWmRyb0VHZmI1clJaTEI4Nk1lR01FNi9ZMkx4NDVsaXZVZGY2VW9KSzkyU1EvLzM2Sk5LTEI2RXV5VmZwY2IwN09EeXdxNDRmdjRTUHU5NGo3YXRucllody9VaGNXcHd6QnF4SjB2eUxLNWZhTUg5UVBobVpaaDVSZkl2SUYxWFU2VGNZNDdqaVFhTjFoMUIrTnZPN2VlUTNGTnU1QU93V3VTNDl0c3FLNWlHbmJYelgxelZmdFUyczZaWTJJeFNTRXpHSDQxQXVnYTZiRlJKbDVuYmNuNm02bnplY0JzcE55dms1N1JPUFJsalJxclBOU1dqUWRrcGFNWTdTQnN2VDBodE90TktnTzhrS3VOQWExeGl4YSttU2tjK2plcVZUbXpKS1dMaWtURXA0eG1wWHVqSTY4eVArdmNPeE1sRkhucmxrSEZ6Vys1MWR5dnJMenZpaEowam11bnJ5ekdiM3BFSjNyZEpMTTJFekVIazhvMURNem5JTTZ5WUZFR3hFWmo4ZVk5T3BJZ0s1V1cyQ0hWdkZFWCtpcTJmcjRtcEhkdGplQ3BTbnB3QnR3ZUdGL1BSUzEvMVoxYjM1QjladXdFcTdvSkFSMlFBTWFqRmNFWXVhOFU0YXY4enVJalZpbjQrQ01YMHdsWkRxTVFBZ2hCT0FNWTBrRFRRaHhRSk5CQ0NHRUVISi9HTk1keUZzcis4anJab01taEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDeUhud2k2bFBSWHVyZXVidVBvWnFKSTluOTVvd25tM0VOSUF0M05hN2EzZzNrajNnTnBFekdkRUd5US9vemlJVDZ0YTd4Nm0xMjFaa1Y4algyWXdTM1FleUtSUk1qKzZybG9UejFyNXFWdXRKUnJwUDJ0Ym5ibkwxeDVJVy9sUU91b2NPM2hySHRGdHBCOW1pNm5xdDJZMStRUUJweG1UTElVRnQrZncvRzZyYTlxMXZ1REJycXkvUFNNSlR1V2lEUGpDUVdPdHMybS9GYmk5MGZlcHNaTWNlSlNzU1dXSDdtdTVjWHhKRXRWU0ZQaTlYZjcwMWYwUVdKZlZXWloveHVKTGhqdHpYV1hnaTZ5czZQMkF5NGk5S0dpUDAzVjE5NFBJMXMvVWQ5MVJ6SmEwYXI3L2Ftai9DL0Y5eWRiUXg4NU9UYUJ0Q2ZBbzZmdkQ2eFBxNEpOUFNoVjZIMStjTFphcnRyQmVrT2JRdXZ5VkRxUTdFZGJmU3RXcmNnOVZjZCtkYlRlUTBadm9BdFAxNittMXZXVFRiSWVsQ1kxaE5oOGZuYWJKYVpmczliczhvYkdNZ09TYVM3VkUyTkZqeFZmcWUveTN2K3JpL0h2Q2FqdHRLUXNnZmpod0ZSYVp6RUt2czhmbVhkTk5YSjNyRFVkazF0dHRxNStrcFN5dVdyWFZsOEhkUzhrczYwUVpLbC9kTXZPTW1yMnpFV0ViRGFlczRJVjk2dlA1SVhacE90QXhvaDNSRVBmWGtRa1lkazhVSUdiVXNkQjZneDNEVmpCcnZTeUJ6Zm8zODJwVDNSZkdHRzVFcHdWRTl5YklZTlpGYjRKM1ZXbzVGUWxTNnhvR2dOMkhCTWwva0huaGpXSS9NT3I4MURpUi9RVzJrSi9JN29vcG5yR2l3YVFSQks1dE1BeG8xVlVNVldEYnFuOWNGcVdVa1FnYlJhR09lc2NzSXZOTjByOEV4aFdMS2VEaDgyNVNRV1REeUlJUVFRazZBRHBnUVFnZ2hoQkJDL3NMaEVaa09HeGtoaEpBVE9kTU4wUVVTUWdnaGhCQkNhamhPSUlRUVFnZ2hONFdoTE9uaG4wU2V5ZnB0Ykd2WGpwN2RlVHBWV3lvSEZXbExkQWRaS1k5RytXVC83TWdSM1MxZzhLMGhWMEZyZzFaYU5vUTlVZU5TeXppcGJyMTdsVnJIenlHeUYrWDZPQ0x6azA3YnJnaXVDR2svRjI4dG85dWVTTjV3ZmE0azNBdm1odXoxNGM5eDZUTlV1NDFnaGJTSURqVXRjajNyOUgvK3YwMy9XOFQ4K1kzc0FvdnBmSjNmUldPL09yMG1vd2kvM3c0YVAwNXBWSG4xLzVhVnlzcjVzcEtVVFUxYVQ5Mm5URW0vVUdBN3VaMGNLNEwybGdFRktTczZvRkR5MW5iYUUrODV2OWJaM3Vlek44SkFmQjJTZHczcUc5dnkxdi8vZFgxWnliR1ZXWC9kVWY1Q28zMTlSYWdYN1N0aGVTUDMxMGRLWC83S0tTZjd1MlEvdWJXeWJjOUhmSDdyUEZJR3JTd1JSdTNaVjhCak0vRFVRN1NQYk05cU93VWpKdEQ2Y1BQdmwxSzNmZWZiQjNQNXBsTjkyTEs5YVNWODk2WFVSV1RLOHZtZFpJbktDSGQvalRYYXgxcXphVlovVG8xMDJVaXZSeEl5MW5rTHdYK2ozWE5rYkJzRnlJczBvZno5WDlwL1hWakpMNTIzZEJYdDlrSUZUSDExWlFyMWpzWHJOSjdDb1dtMXNsajlvYzdUOGt2MTcrSW9UekYwYURxdDR5M2RXY20vUGEvRk52c1NiTlB0eVorcmsyeWhKVXV1NjMzOGxhdlUyMGhzTzE3NnBTaC90MEhhVHRTZUV2SjhMR3VXbFBNamRYa2p1aFo5a1R6WnNMaENyNnZ6M2toMG1KelN2RENpZG9tSVEycTdSdDBOYVNHRkpEc0JhY245c0l5aGhzZFk5bzdKb2tOVnRsRmk0aG1iWlRCZm5YNW1KR0dsTXliNnBBbUc3TzA0bGdQU3l0UnpiZGtvZzVXdVRoTXhZTkd4dHpUR3JzNmh6MFo0YmFNNkpQV1BWVWVhZnV2dVRheHBTRTR0Uy9wdDVWditSbWFPYXF6ekNjeWZBcm9KZ0RaRzhmWlhLeDBaaHpZKzZuSFhOV2puS2tiZVZuNjJsYjlvcys0dEg2QmgyZmo2L0l4aGtNZTNTY2ZaTEZab2N5MmUvT1FVb1BqeGs4aU01TkdnVGJEYmJBSkV4RHN3UUlha29FcHYraDRUeUJEMVF5UStsQ3JiUCtTK0hmeGlLaUd6WVdSQ0NDRmt4NEhPZ1g2SUVFSUlJWVFRUW43ZytJaE1oNDJNRUVJSUlaTmdtRUVJSVlTY0NCMHhHUU5iRWlHRUVISWlkTVNFRUVMSUZQakYxS2ZROHhiMXlKMStVcndZcDJGdGI5TktwMjJmWnV5WW9lMmMwOHBESG9pMXFhTzJaZCtrUG50cnJFNVZwN09PQlVCTkNTcEx1LzFSbVhHMExkdzhXN3Q1OTNjMHJyVCtwRXhUZDZwa3R0SkllTy9zeUx1RDZCWmFTMVpFL1UzbTNRTnVaTnI4U1YyVXM5NzlPK04xYmJYcTI0TjJEVFRnWUdDQzArMEU4RUN6L2pLUXRndWtyVkhmRyt0WHc2SVR0ZU0xYUNPeWdpTWtyMlE3a1gyQTYrTklXczhOMTd4N3E5d0pzTnN0bituMVZTT3RZR3NidUpMOHVwRHJ6R0s2M1YvZk1FSnVXMldYdkYyM1d1dHFmUkZNODRYSWwxRHhtdE44cGRIbXVyUjc3NnQzTzFLa25WdnQyN0pUSS9zQkNxTFRHL3ZJMTFNMys4V0RsS1gxWlNDTTJQV2hkcDEvdjV5YWpPVDdyUFpsYS8zVSt0cERzWHpFSmtPVmJtWS9RTWRjM3BFaTJzWWlJR1hNTVJGZzlwMGNqd3lqYW9yU3RMSnlYdFVObUMvUGwxS2xOTzZQL2JhWVlnb3RlKzJ4dzNpazI1WnR0ZDhSalFyMVU4a29pM1dzZFR5Q0ZiUEo1L1B1ci9MNXY5WFIxMmt4TkpsMWxLYkZaRnNybFRlL3BEVExtVzBwczVqT0ptcHpDWGsybW1kQVIrVGFzVVVHRUZhSytieDV0UE9JaFpmU1QzSExkMGN6ME5hTmpBeC8wYUUxT216d05LclJZY1RNNFFMaTZzbjFzVUowZE1oYXkyakpqWWIyOWZIMWI3WkRNaHdya21qbGs0aU1lNjB5Qk1lb1psRUE1N3Jybjk2T3ZjbmNPSjRheDBkMGZOLzQxNVlUWDlQWUpVdmZDZG0wTDV1UUxsVVRXSks4WFpYbEZLbkhTR3YycGtkcUZKWGxQWitNc3JTb1d3NWFmblFja1J0NU5ZdUI5aWdTeER2b2svS1E0MERHZVZvNlJGWXR4NU1QeWF2SmVuaWJRdWVJRUpzYjlSRm9WeDh4N0xGOG9tZDE4TFhteG1vc1ZyN0lPSmgwSWJWcmM3UlFCVDlxMzdEdW0zQ2V0NXlJV0FiYVNpZWxGVUNta2oyajQ1bGprVmZoaVEvbEplakh3aSttRWtJSUlZUzhBWTZRQ1NHRUVFSUlJWVFRTWdST01oQkM3Z1d0MXNQaERTYUVFRUxJTkJob0VFSUMwSFFRUWdnaGhCQkNYZ1MvbVBvVVdtL1puelRRYlJWQjI5MmxaNmV6TUQxSzBGME9xZ3ZLV0RMeDF0VTdtMms3blpFYklEVUU3K2FYNUFlMEQwNVVhYVZEZDZlU2RzbzYxQ2FxKzJ2VlJHb0EzVE9sM3ExVjJRVzBQcjdaRFhUVTNtYldlYWtEVzVZYTNWc0d2ZU5LQ3hrU0M3UmFYM1llTDFXcS9EbGFOdjlpbTJzalBhb3RSMHA5YkYrYlNHUkxKRXZXbTFoL2J1cnY1NmRXNTlDdEI4T05DYmU1K3o2VUUxS0V2RXUzL1MxOUZkVyt6RkdPMXJQWGwyYy9TSThkMXZJbkk0MkZzRDNmL29lZ2V2RnhsdDJMMkdzVWRPL1JCT2lPK2pac3U3Rk5LRkJMckxweitkVHA3OWNjaTVnWDdlNmlrbDNhU2xjbHV6NHY2MGJyRUkyRmp2QiswZnNla1JHUjNUbytraGwxM2RNL2Y5UG1qNncvL2VMYk1pcno5Tk5YeWlxWElWWHBrS0tWeXZuYkozOE9sSi84WlovdVIzWTF1VklMMzQwVGlsQXcxRGIyT3Z1V1hkYnVtMVUyZEpaTlM1K0VkR2dlTk1BY0VCdlVsMlhSdWt6SWlDZWh6WDBPbCsyLzlaZFRseC9vVjB0ZFBiVGxWejQ2VzE5Ykhmb2wxYW4wK0NVdGxzdWc3SjZZQnUydmxvNmVQbVBGeVZvOEZabmZTSUtNSXBSb2lXV3llQnpoVDE2cCsvNGNMMEw2UmNkdk9rbW5kRnozVkZrOHM1Y3h3T1lSUXI3TWlDNmlWaGlOeUZvUlg1MUdpNllpM29sODhJWVJhR01xeVhhSnFLN2FIU05sUlljczNuZ1phWmllZEhWYWNqM1F0bVNodFlQSXNMZE9wMkcxYjRaaHhFMWt6Qmx0cE1ISkNFaFdIWW0wemt2NUVaWDFKSW1TTGxzSEl2V1FnZlJTWHE5UmtIUnFVWnhHajNNc3h2RktkdlBaQ0tGSW1uMXUxTlAzNnJYbk15NUFwQmQ3WlkvUUtkM0YxcXlWcGRNS0s3WDhaQktvcVpqWllFa2ZrV1hEYUZ4dFRRaEk2Yld4Nk1zN3ZYY0k3c0dxUW1zV1hrdnYwYkhrMDNRbDViZDBQRmY1bzlIUzQvQXU2VmhoTmprRWN6cWkvSjZYUmtlN1J3dU1qbnZCRUpoY0RUU082R3hMclJBZ0s4ZDdwcHV0TlExMkRRVTBpRmpTSXJIZFRlRVhVd2toaEJCQ0NDR0VFUEo0T0VsR0NDSGtkYnpPK2RIYkg4L3hkWjU1bndraGhCQkNDQ0dFRUVJSUlZUThETTU4SHdBcm1SQkNWR2dpU1EvOFl1b2IrUE5tOWNtV3dyTzUwR1Vwd1hQSWVWK3k3anprUnZBR1l3enFneEdWbnMwdUpOWWJZRHpDVm9vRXQyOURMeHo2QkF3c2JFQTZkSyt5K255dnM2NjJVMEVhbDRtbkJhTjU0aHBuOTRYWG1WejZHSm5sMDFMclQyRjUrMUpYM2RiQmV5eVlMN3UvYkJrRlBwT1Y5SEk2VzZ0blYzR3Z0OVIydVVieW91ZEhvT2dvSXhwZGIvbDc4a2Z6eHZKOTc3SzF6ZHRhazFISHJwSlVzdXcrVXArMThzL2dTczVnWmxtdWNKMHordEs0NjBMNlF0NW1TTE4wbDRLbDZ6UGZkN0tOUGFQUFdCd1I4K21kZUhjVVJhcWwxOFViWlNxT3RGYXlDRlkzdk0vWFV0ZEVaMGV0ejN4SnYwY3dLbzRjVWJZWmN4RytjdTFMRUwrdW90elgwa3dmb1I1N0plVjNWbFBoZHBvUUlnRzZVSEZIOE40UnArZXJGdDQwNkhYZDBsMWZsUkZoTm5yamVoblJ5RWFtUTJUUXpkMlhYbU9KSHZlbThhU3IwM3ZhWTNSWVRCN0tqTEhYSHhCbmdwNlBsc0Z6UHFpeU5mUjI5N05XeGpIclpOdjhrcTZzNk9yUmNRRHVDU0c4N2pZNW9VOUZQV3M4N0wwYXBLYlhMVXhxY2Fqc29YT0s2U2wzN0VTaXNjNnp1c3k5aVl5UG9yR3I5dnVzS2UwSE15cktHaEVaMU9TQWpwRzZhZnMvakZvM1pHVk9vMmY2Q3I1OTFUb3ZFdmF5RDVFTlVjT3RQWU1LUERwL3BUVU45b1VHTFNjZkdSamVETDZZK2hZdTFvQ3RyMWlQenVjU3FqM29KdVdwenp0WHdxZGNEN2szMFpHdDFvN2YycmlRZml6bE9hbStwSyt6dDB4UEFZL0hTek1TSTRJV2p4dFh0SXdHUzJxazg5NVFxeFpIMW92VlFIdnV0UEJ5NmpwTHBHK1k5SFdlK2tzblpVaWh4dlNXMTVuU3lNajFSTnM1bFhyVzZSZ0RuTGF6RDFuNExaRlgvOTlMOG1xdVpaV3BOeGk1dmdXMHNqTjR6bXJZQ1V5N1RoOGRHSGdHRUlzUEhCbjBIV250b2o3UXA2RnMvcWpPNTYyTytobU41WHpwZkpzSGlZQWkvUEdieGRSeU44TWN1ZTh6SFZBckd2ZVdjUTA2S0dtbHQyWXcwZksxKzhGdm11MEowVnJucmNUNlJOMlhOdW4rdjcrdHorL0dSVGtkOEdJZE9ocHI1VTlKdDJkSk9WK25HV25INjk4ZVB6dWlQRTVteFZtUjI2cm96STZ5ck1OSTVGM3Eyclh2WEgyN2FENnNwbko1cEhic2FlY2phZm1LbEtMMnVKM0dTb2ZxMG1TMXltSjFvbTNlV05PU2ROampJT3ZvTXVkUWoydjhjeEZGbFA1NzdvWmRpcENMRWJIaU0wY0ZpL3lVOERDaXh6TkVSdyswT1E2c1JuYmt0RWpFM1hwa3JjOG5JeDJpWTFRNmNrM1FNTEUrN3cxbEU1QitOR2NORjhnSmpEYWlYdW8xSFkrT0FjNEJXanVYMGpjbUkvSktkMWRmc2hZZk5hRjFuZnJIaHhnWG5qUDdGc0c0djlwazBnaWRJMFN0L3ZaTTE2R2h6cEYzeE5zQ3BkYnJyZGxaMTBuWEdLUzM0Wkx4OUlZQTZGS094NEJGT1VMSFM3Q2lxNlNjYjBVZDF1OEVucTkxSEhXYmFmTXJSb1RxcEl2b1ZNUnlEcHFLcUlSbzRmTDNOaXNkaFZNTDVFc2tqcEJrZUpaREo5SzdwdkU2clB2ZGN2TGVRT0ttOE1YVUoxS2N4dzhzUW0vK3l4aTV6Z0pxUGtsTFI4Z1h0TzA5dmZGWW5RanRaRktld1VWcDVlbkpoeHcvSHl1Q2R0YUV1N0k5VXpqSUE0aWpzTzVrYjJzU0ZncWw1TjJNRVRibnBiZjc5WllwOUZSRHZVTDJ0aXBkZnpHMW1hNyt3OXQvcFZHblZQbTRYTTh0K2RQL2xnZXkvWnFpUksrdkJJOW5JQzJTMThzby8xTW5uMkhZait6SXgvamI5anhlbVZhQ0kweGxvWTg3Z05GMVBMWUYrSTU3NWF4U2JCNUVXeCszOGkxNVNsTnovaVJ1ZVlKanZ2YllhMWVqOXdSWityWmtabWQrcVF4ZVAyeXR0a3pFb3pKYUpVbzZUMXRzaFpISUNGWDlZbkFhd0l3dzRsRE9MTEMyTERmTGhualQ5T2l5T3BjME1HelA1OFJLck5WeFMvYzZUYisyWGltMzYxS0UzSXplVVg3RVd2am1XSHpIdFhRSExHbThqNnVGRUNQU0l1bDdyenM3Wko4NFRDQURzSXhrN3pyRHdvd3BZSXZqSnIzSjZjd1lpL1dXb1hNeXdqeTNUdFpwZ1BlN042N083UktuOWdLaVowNnNQdDZTZFZaSG51MXdMZGw1Z0FxZ2ZaanJvdkUyTm10R2UyYUxzRm8xcXZ0b04rVHBNWFNOUVVhWkJNYk40eGdaQXFBR2E1YnBiMDJCTHVjSnhJRG9TcjN0NkcyWUdTR1FBZkFHblk3VnAzcjZjYW4rc0I3L2F3Mm55aXFZb3hrbWJ1ZWduYStIdngyTnE4ZWNqWjZHZXp3OWMvMUhEZ3hQaEMrbVBnM05VTlhISjFxTmxxMUUxNmxPTVdyV3N6ZkZ5RHV3MEtmV0E3a21rL3Z0N2JsUXA3R0tFb2szN21rVE5NZFRrdlc2eUcrMnoyOTR1eUwwUVZFUG50b1hINmNQeW1ySmJUMkF2bG9JblBJa2YrUWFjdVBYV0UzZVhGYWNjbHU4bGFkVlJOV2tYdU9IbHI1anZWWHdOMDJLS2xuOXEvVng3YmZuYkVxL1h3aXFTMUMrLzY1ZlRyV2s5WjNYR2hjaTB4cEp0SFJxRFZnYk1GbDRaZ3BRSGZWTVpyR3ozSUxSeGdNZG5DMmF0K25FSHFkOElkWDc1ZFFSVVlqMlJhOCt2S1B1YmdQbktJc25UelNmWmp0cW1mMHh6amtkZHZ6OTJuMmxkRzJlaWxTalJobVUweHRQWUgwYXRUdWtOOFlWTWFHZmZ5TnR5TnV1VWRrajJyRjIvSUQyN1oyWFExWXFyUkNnODdLMHBvV0VrVlk0NFdtMnJhKzAzcGNSTnlucUE1T1JyczR6cTVINUl3bFpaMDlaTWxDbVg0cytKcGJKeWxGTHRqVnVNanFkS3F0c2pwYlVLaHNoSkVKMFZnQWRnNDJjaWRCMFJCZ1VqaENKR1c3WXV2SGVNR0ptSXhzNUxDRFBvdFcySkNNNWV1cG9yU01xTTlKVzJiNWZCbXF3UjR5YjVIR0RYM2VFNkhnUlNicWVaTkFTclRwMEhqbUhwTlZwYjBmMmpnZG56aUVLNXpZcTlUSDNiN1lzSnpVbmt4UkRqS3lMS293WUQwdGhsemYvNkRLc2o3ZGtJMlhOaGc2dnJucVdLeW41RUxkTEp0S3pmRURPQVJtYnpUUVdMWjBFWmtaWG03bENaOG13SXRjYW1oaUJYZ2RjcHlPbjBqMWxWdDN2Yk56L3NwcFl6bXdEeEFOaVc4QTJOV29xYmRSSW5UaFpHNjdXSU8waDhNWFVwM0dCQnB3VEp6aDZLY0Z6NUNab000VlNHdExIRFJ5NU5CSDlqTnZmT3hSc3dQNkJNZkVXM0pYWHpQdVhRY2VYYzVLaGVqTEx5ekhtMndRUjBDbGpSRVlHZjJ2OFJ1MmF1eXliZFBzelcxbXRNcWFFTDRrV0k1OUZBWTlKdXRCOEhpb2Rxc3F5K2VjNWpMNmdNaWhOSy8yNE12dExNcU1Cak9oRHM0bU1nSzF5V3ZreW1ENmlvNGR6N3RmbXZWRFZYQmZGSldnck5ZdndwQUpiL1BCbEFvVUlFN1VkUFQ2dWg5SW9nMVFtenQ0aEJKN1h3MlZQU25zZnJEaU5qT2VaZFk3UEEyaXJHdHR4VTBzSEllUVl2TllLbWM3Q2JRVXUwNEkyNVVJdzdDQnZJVHFWRWszbnlZc2VSOWZZMmFkZlRPK2M0VWhkWnpDNVRLMjFqUzZpSGRlYTYwWFd6V1liRFVEK3FDVU5jMWxRZWluVk9POHNTb1RvNVl4czdiTm0rbzlzV1h3MGhKQWduaVhLM2lWTDVDMURiU25IQWpXZXhJMzNTUmxDaUk4cnJvZCs0eXh0MllnUUx4M3RpQzcrNXJRQ2lRZmVWTDZZK2tRdThuSnE1UGloa3lUV0tLRW40akV1YUxmemhpR092QXcyQUJ0a0RTR3QwclE2bVhPR1Zwc3ZpdHcyN1ZHMzhiUXUyRnFvU2M3elNkQlZHcjhsMlFrOHI2Vkx5UzRuZW4yV1RuUW1zaVhidWs2d1RHVjFMbU5aanFHcy92K25TUG56RzNuRWE1MFQxM1dSQzc4dTN1cFoyOUczckdwcE8wSm5JNzJyQ1k0SjB2c21JUEpHanJibTBWL1cxaXFOcEZWeTNxZzliMVU2cXF1VkQwa24yZkhzVStuVzFXcDAyWGw4ZlQ2bE9aMCs2bWZiNTV2ZHRVZzVCSlowelh2VXJydjg5OFdGOXZrZlZVWDhQUVlyNXJzcmIzRkVzOUQ3MXZKeWFsa25YZG10cFUvVUcrK2pkeU5YR1d1VEdMcXJVNzZFK2hXZXNGSjViS1huNlFMVW4wbS82M09LWDNMZEJZL09UaXpYNW5GOTlWQlVTaWZJcUZYa0t2MjZ5YW52Wmx0emhaV1NYVkdXb1IzU3pMMWRZS2FMSDRxM2dBWDhqVFl1ank3MHZDZkdhYVVwRHBtZXVZaTYwMkIxOGh2VHlKcDByREo0YUYxWFNyYlIrUDEzYnpMUXNZaTNiSVFRQ2FUSGFDN2VzcTVla0hCamhLeWp5dkFhSXBYU0Nnc2s5eFFOSTVDeW9XR0VWUllyLzNLc0ZYWll1cVBweUxQUXdxODZUVkh5akJ4NjE4TmNRazVGYTdnajVwTEFmSlpkbGlZZDFMUkpvRFJzdnFtOE9uOUd4NVYwZXh3cGVsNjZOc2tCYTllUHRpRWx2L2JDNmZxK215K2xiblgyZkNrMTJxcVBJQnF6MTNoYWxsVUdiWjZ5cEgzTHF1dFdHemN4WkJ1QU5SaERweVZSTTBDZWpiUkV3N1l3aEI2NzdzMDdlaXBDK3EzbGE2MHl2cjRwb1dQSUdqckxXMkRGbFJsZDJoSFNsWldNT3E0aVpFY3hmcStQYVEzWDJiaitHOHNHZ2E2MHZxWS9SQUlLYTd5d3lIdFlKZkxGMUx0akdhcjZONzNpb2FEcmVPU2xlSnpVMVdaazc4YkZIZmo4Mjd0RU9WbjVmYVJ1TW8ySFZmV2ZCMXZ6cEl1Wk9YRjRDMGJNaUpKT1JyUnQ3S2EwelVJUjBzNmFzdENlU05MU2FkZW5UWGNnV0RLdGZEMFBrc3p1Uk1qSUE1a0o4NXp2b1V3K1A1dTkvcTBiTHMwNXByTHJlek91eDN1Lzc4S2RydU9DWlYwZU5tbzhvMVJRTXd6clhQNHB1NGRrdnFxaUw1YWkrY3JNZTNIbXdGN3pSL1Z2MUFjZ3MrTmFHVHp4dzd2R2gvWFZlcU9JcDFqdmUvR3VObXJ6OUxyWVh4LzdIU0hQQTdYc015TzdJMFo5aERTSmhqZ01pNGhGNlV5RFBxZ2wvUjcwTUI4aHgvTDJOUTNyNmYvMWIybWljbVFIUDNKeC9RQTlhSFA1VGhsK0pvTVAvRkpxYTQ3c0NuaWZJV2k5Ni9DZ2xrVUlPUUxOMVJYak4yblNFM1hkYlVWYWFoWnNLdVRwbUtPaSt0RUlheDhZZGhveUcyM1l5N1ozYmJ6emxraWVod0srbU1vV2Z4dXNTZjJEaTREdTFuSm8vOU9DaUpIQlJUR3V5YmhnYlZlQmw5cXA1OEViT2c3UFdvclY5d2NYQlZXalBRNDhubXo4dG82ajUwZmwrVU5WTzZFdkVxNFRTdzBpcmM2di8wM0tiODhDbmJhYTdtMGxqdnF6Vm5QVU9odHBtT3JyenAvL2J4Y1A5MStMVzU5Tm0zTitYbTVnb3dhSmJKR0NXbzh4RnhsaDRiZDlaMThFOU1GcTdlaitwWEQ5OGozWEk5dUdlTG9SYUhaNnBrM1VqbGM2NndjQjZwZXFRa1hNYWN3MUhRbDJvZEk3Wi9VWFQvZlBWbno2a3ZxcHUyMis5bnR0UDNYYkUwVnM4OG45dkU3MXEvbW8rNHEyNXpPNFkvcytIbVRhWS9OeTZ0L2ZxN290ZmJWY0t1Vi9KZHZOZkpYWkFPcXdvOXFLWnpBNkN0UW5Xc3ZQYUtWUFlQM21NL3JRbXhYYlNzYlcreFNaSWJKTzMycHE2ejYwdXRwNHk5T0d4VVhXdVU3enpmNGE4NGoyUDZSQ3RMN3RsVk9YS1hJenJQa00xQTU1Qm9pSXg5QnpwVjJKNU5qbXQ2UTlaZEFtaWVSNUh1bXJMdnQ0S2pvbVFRMFZJYVFGT2p1TnV2emFIOWN5cE4rb3pBaG5SSkdQWlZTbFNYSVdWMkM1M1dTY3oyQTZyVnc5SVlBODRXN0xhTGxBSzR6SVNqcENMS3h4bjZmdnNmMlI2WXlhV3hxb1c1dW9zSWFGNmxTdk5BbW82ZDc5RVFCZEwwcHBHOVdoOHJJanJRWnFpRnFWNnd3azFDK2RwbmIrK3BtSytueFpwWEcvbEpxYlIwZE05UjVoeHExZVBLSU1ubkhOK2w5TER0S3k2QW9Qd09yT3ZkTnpXam95SG0wOG1KVGpJMEtBMXYyWGROY0xESklyZkdsYk9jcG56SlF0M1g3dlZJU1VodVpqTUxUTHI4QXpsY2FtUVA2Q3ptZDFERWx6OEhoUHlJSk9PeE9BbDFVVytHSXFNckZETGcwNnd6TklGVnNNTmhhMWpMZVdqandZM3V6SG9ObEJ4RVkrdXhsMGVJbExHY2UzZWpwNitGdkFRS0tEVlJzUG1hdjdETUgvUEpCZGxLY084Q1prWFcrcjhXbVZXMEJaSXhvMnFpc3FwenEzYVZPR0R1dnJmcTRpM3RrSVlHV3ZYOGpaUEFpcDltTk1OclpoZUZuOXZ5cGI4b085YUtycm5FZHZuNWxaV2pvN0QzL2I5WjgvRURNODhXdWpwbWkzT2NiN3pyaDBJL0tOcW9pZU9PU29KV3ZyNlltYkFCYTlka1BTWEdHb21lZTJERnJFTzNQamZoRkEyaFJuUzd3dVBQMmlmSFc5cS80SnVTdmVub3FzMWJWMEljZDZaVWFPRXpJZHVrUXlrOXFZOXc1cUhqTFVKSGNoT3JkMHd6V05oYzNMcC9WRS9LenJHam1ib3Vtem50ZzQyWmdNbjU3ODFPVnVSN1BWNmRFcW5XbU9ZbFJacEpaMEZUZWt6VXZTUlJKU29RMzhQWTh4ak5DWlV2dUYyT1ZmVGhKc09LSTZhbHQvMUdwYUQ3VDFoR3o1OW1PalE2T3hFdnNZY2RNUmlQZjZIWTRCVHVabE53QjhNWlZjRnE4WFBHaHdFbFZwYlJZd3BmaldIQ2J5bkwweThFT3lraGZqYWRpY1hOaFNHNGU2THJWK1hGSjNQV2J3ZDB0VmI1d3gxU2FxYUFzMDFuSHBuRk9HdHVWSzBmSkpXSGZEcWsxdDFyR1Z2OVVRMS85bUl4MUM5VVpPcm95R3RsUHVyaTRGdWJ1eVNOY2xuWmV2b3loeWZuUGxacnEyN25iYnlzNWU4MWl6cS9XcFZCMlg4bWpubjREMEJTL052RmpkOUVKMTFDcHEvWEpxTm5ySnJ5eXJBdHBhOWFlRVd2MVprMjM5VHNsdXdGYWdoZHBwd0g1bjQ0QnFyNVhqSVk0SUxJL1FVV2xVbnFWWXFuaFhtbEpsYk5TdDdpWi8vVy9MSE9TUWIxK3ArZnJHU1A0KzNiOHlIdXNWUDFpeHJPVWNKVWIxMTNIeTFzMjlMQ0pYTGsvOCtuQkR4dnIzTjcxbUdxdTJ1QWxkRSthbnJrbkVKenlwVHlGak1TblBxaEhXalFpdFVxdUswK284a3FmSzhqZDVsYjVVaWNUUmtqTGtxb2UzV25xSVZmOHJSZis5SzBTcC9uME5xQy8wak85Ukl2RnlBV1dnT2tmTlJiUTZXL244MnNZcyt4aG03MjgxTzErUFRZcVFvcFlsbFVsUEwrdXNwVW15TlhPVXZ0ZExDQm1CWmpuUWMyc3lrS2FWTGpLcWVzTW82blE4SVhoVU5ub2pOZDA5WmZHR0VXaW8wOUtqdSt5MnJNaXdnRndYcTYxRWhzR2F2R2dmeTBvYWJkcVp2SmlldFl5SUxudmMxQ2RMT1YrazgrdWYxWVRlYm01OEphalZ6OFFUc3pyYnVpT1BuU1BWZGF5TlNIM2VJM01VaXVGVnY0aGE1MHZiOUJ0WktZbGYyTTJ6N3FlT04yNjJwZ2g3ZW5WMm50ZkNNYVRsb0dGWG5RNEo2WktTbGlIY0FVVGpKTjZNY1l4eTdhMk9qRTR5ZU5CY0hUdHVGOGl0NnAyL21UVVZzZjZONm1iekdBQXI5VFNRR0tjMTR0cWtxNFkvSG9vbE94R3l3Z3JldmVlMDh3NGtYNEoyQlcvSStucFRhVDJ2OHNKNVNyNlkralFrejZ2TnBSM0VDU3JIY3FCQnVIVTlFWnpJaldiajZPTWlqcjB1UnZTMjNxTTVMTlovUXNVWDZjQlpOL2hDVWVQRUtuOHF0emV0VWFPQ3JHZ1ZNTzh0MFliRm53dlA2S3oveVBMTWtGMHE2YTJWRTYwTTJxcFpORjF1Nkl3MnVwSjhaY2xBSGt2SEFNcnVEeU85dDh5UThvbmN5VmpNcjh2K0Yrdk92dDlQSEl4NCt0U1pUbkh3aEU3TFJFYmpDRmgzMmFtMlBPQzFYMG85d1hjTUlYcWpJN0dLY0llL3pYaUp1OUt0OFVSeE0xckV5T2lBRUYrTHZpN2pJaC84Y1FQMlBVTHVpL2RoOEloc2NnT2U0UUp0M25LZHBCL05PTmJuMGVPSXJsSHB1RTVHZGh3NWYzTms1eGg5WFZYNkRLUlIwWjdNOUphcG5yajBMR0xPV25PN2lISHBYUzVRbC9ET3ViN2VGYnNadlRnN3o0K1lTZTJGTHBDUUQ2TUg0NUZIQ3pRaVM1RlNPbWx0ajUxZnBBeEtRd2laRDJMTzBCRlg4UWFVaEp5Tkk1aEhYVC9IQmdlZzJaTFc0N0VQaHkrbVBoRnA4SUhPMDAzaXpJZTBkbVR3L0xvdzl0T1N2M2tERjZGTnpYcGxNRjY2S2Q2RlBlTGZlcU9rNGZVWlhYcFp6SW4yYUZ0cHlHaWxHVTkwMm4wTnVyMUxObVIrZnVmUCtTTGw4ejVscituVWZwZEdmdW1jNXk0VjUrK0dqT3pKMDBwbTNaT2kvQzJsMmNyQzI3TjIzeUt6dGRwOXZURXRvektDa1JQc1YyZGpsbFl0Vkh3UkVBd2s0YVltQmVzb1dWU2xoYktJckNTV0RjbG5qYlN0Y3dYTTQ4SFNqWGpjQmFzdWVueWhKZnFUdit0THFhTWpqV3pJT3Q1WXRGcFEvcFJwOTZIMUhwZXdmSkpPeVJ1dGhlZDRLVThjZ2NqeXB2ZnFRSFVmMGI0MUJ6eG1RcWVzMWF3bEZ0K2E5L2IzNG8rcWVQVDdNMzkrN2pYazNpbzFQOWY2VGJndDFQZllqUHM1YzRiSE94Qk9TdnFXekZaYUQ0MFlKKy8rMkdiSjh1bVVqT1BMdWRiNEg3eXNySml4NytHaWk1VEN5WUxvcXZLbzFkUUs4c3BlZHBIU25jcE1iNGZlZUswTVIxUVVFcjJQa20xUmdHT1dyR1djaityVzdzWDJTRW0vWDFMTlZacWkxbUZXeXJSTmJWRjJwVUU4eGt4N1RNajdzQ0s2ZGJwTHViZ1AwaWhpamVmNm9qb2ZTM1JxR0VHYjRuOWFHTkZxZ0ZLY3FjWG1yMmh3TCtKcEUxa01xOGcwenZDNDROeityajlXYVZ1VEZ3azRKODI1ZGZjMWJiNXVwM3oxcnpWcEZHWHQ5TkV5ZVBFWVRTMnRjUnh0QjlKbGRMK1V1cTIvcTdvSWpaR3VNRnFUOW95Sm5TNDc1RnZwU1JCcmV0S3FkTzhVRXptR1hpT3hnSnAxalJIdTZDRlluaklwNStzMFBiWnhTZmRmWjc3VTBPK05BRGcwUHdEYTVXbjB4SXZoa1prMnQ5YUEvWXgwZ1N4cUtNTmN4S2Rab0hucXFYQTBoSG1kYWZRR0d0THZoOE1YVTU4QzRpZzVLT21qcnI5d2RDT0x2b0lNY2dGNEl4L1BpSW1JWnhBWTJkR0grUmpvcHhoRVhKRDEvUjExbjZVSGpvcncrMmxvMTdXOGVBWVJuWTJzSzdtV09kOXJiSnRTKzRhUHZmMmFyaG1Ocks3TDBwbE95b2ZxUG9QU2VkNlQvaHdqMGVwSm16SU51eFh0dmhHdGhlSThmaDk2Vm14R3RzOWUzVWZjQ2RRK0hhQVN6bDhKOEJTemJQN3AxKzNMbk9aUUJxVnBCVjZvWFk4c3IvZGFNQzJRZkRlUnU5bGpPUWs1bHA1V3VyVVQyNy82N0hTa0Q2SDl0TitEMU5mSG5rN0kyY3lNOUk4WTBkeC96RWhPNWVsenY4UW1PaWhoZXlHdjQ0eEdqOHdCalY3VEVIQ3RsM21SNXBDOGM2VFJzbVd3VENPY1pIU2ViTUI0c1ZTNnY1ZjF1YThUdnBSNnBvc1krZnhkZEVWajVLcHZWRjhOWnlJSWNSSnhyelhvVXM3TU1qeVU2T3Jaa3VhcE52REoxMGFlQnpvVklVWGlZYk5jUDliZ0RQcll2MGczanFDY3J2K0M5QXdVWHdKZlRIMGFWblRaT3UvY2dpSXlZYUgxU1V2MVZBTmJLMGVlczg3VnY4czU3UUtONXpSN3JvL3JoRGRreEFMZTIyKzgxaGVMOHJ0RnNDNGovWGhVUE9JMDE0TzFhcjh0RUs5aGRZNjhUVlphUmhmMU9HampRV285QzdwTFZTNUpabExLWU9XejZyUUlkV1hSdWs1a1ZyUUl1Y3IzN1BiNGtpdHYwcFhtOVhxbkdqUW5uei8vTDVDVXk5THJDN1RiWGErMWp0UjVDYko4U0RJZDM4OU1WY2ZSUlFRb3ZkSi92LzltT05jNnA4ZGIvRnorWGlmK2xhR29UNmdiV3duSXRteG1yVXV6blhhZDY3cVJCcEhsckNtbnZ0M0c4ZnZjenprUkNJcFlaV1hWSGZNMlpmblV1L3JCeGRiWGFvdjQ1OTgrSTM0VnN2SjEwV2dFUTJyWFY4ZnF4MWRqbGdPMlFPeFR1eTZsOXU2K0VpVWszN1hmdkQyKyt3UmxsVzlienZ6dG8zSVpHdjF6bXpEWm9QZlQyMU8xbU4xVDQ2Z09EY3YzU2VsUjNRak8rQUJON2hrdWdFTk1OTGJiKzVUUDhkTCt2VlpWSDVqMlhPZGw2VzFUSXlvc0lrUHpyOWE0M21wc1NHT1UrbkdydjJyajREcTlWb2FrbkcvcGxzdFNmL1cwaUdYY3BxbDFGYU9POUt1dngvL0pLTk02MWJvRUNFNTdGODVEeURQWlRjVWtQMUVQb1ZuZmlFWDA2cFJrZW1TOExvVDRRL1Npa2JBWk9kWTZqdW91eHZIbG5QUTdFa1pJWlVGY2VVcnQrSHJFY0lITVo3U3hHTkdlUitrbVJHV0VwL1hvS3NiNU5MZ3MwdGkwL0U3RW1kazdKaU55cFh0bkExcE81Wk5IUEY0ZnM4YkZyVGxTMUZpZ2M0YmVQQlpvdlZkMVZVL0U2b3NhMi95Yis2M2t6ZFo4Uit1K0pTRTlscUlBeDcwbEdSR2JqNkp1cGEzVzI1cnFUTW1hZVdtblRVcGVNZ0hVSlZnM2l6ZnBYS1Q2OTl4WDZ6aHkzaW9EMjRpTDFxeDh0Q3JSQ01FYWdzK2Fpa0I5d212UkZ4VGtkRFdzNEZOUTQ4alZpZlVRWitTYUxHODFnZkEwbE01RzVSMzFScWJwVUpQNGVLeVlqdXo0VnlLRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVFRZy8rKy8vd085eC92UC8vQWQxbHRnYlI1M0lLMjkxQzVKNy9acDFRV1gxVEYwQTVYSVJrbmt4clFhZ0xRamNoTFN2Ulh2ZG9nRE85R3M2a2QySnJtbkxRaHNDNmp0OXJrVDZXa0kxcTZzYUszMjNBWHYxdVdwU3E4ZEIyU1ZHUjRHM1M0d1Z5bTJYeWRaOGtUdlNMdHNzcFNlR3Iwc2R0WEhkczEvTXg0VDhqMXUyYVZ4MkY4Zm1xZFQzMFp3bitNWGRLdllLSlpzcEpPa05NNERONjdYNHhvaFBWV0d2MS82blRrdzlCUVMxWWx1VFptYTUwdFZEVkpaNnFyQk40bjMzWnhSTGVrblg5M1BzVnczSEpWLzZObTdiNVIrYjEybmRHemRSdXZqMDVaV0RiNXBNdExTL3NwbWprT1VuUGV5MS96MjduMTdYbi9SdUdpZm1oVEZIbEgzVmtDRjJpc3BQenJRdC95c1ZjWWxEWEo4VWh4UkduN0tHdmQ1M1U0UzBsdVhWWHlxczZKYmJMNmY0L0NJc3g0V0syV1lnblhCUXdveDQ0cThQcTkzYk43U2JjbUtOR3l2TGlrZm9ndTFWeEp5b3luSzhkOFNvYlp2NVRPK3NyVXlaS1dFOVZ4RU11UklzcXpPTWNtR0V2SnlXcFl6Rzc5bk0zT0VmYVNubUVxUDY1OTlnNUZHaGVScHBVdEsrcDZwRlcrZHR0S2oxK3VGcnZHWldIUGtJdzBXMm9kU0k5MUJ3MTFDN1BrZHBNRkdkRFhrZUwrTUtxVnZUU1d0MWVab2gwMUdQcWtRVWNmVkU1Qll1dnJXTkpwcHY1ZXJMV3JVK2NyMi9QY3dNQSszRStpZGo5d1N1RnF6QkdqNFpiV1FTS2dYY1NHTExxdkdlbHRuajN0anlEWVJhOHFJbFg5TldnWnB4dGlVOTk4TjZuMmpRNVNqMElZcW8xYzBpQU5XM3FWQnpmTXVYNzNtYWhnTk5KNGs1QXM2YkJvNFA1V1YzOVlZcGlkMDZSc2RYaGgwM2dPUlEvN0N0MDBKSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2dFdjVqNkZDSzduRTRtc3BmYUljVzFkcU9xNmR3Mm9MVzdqZldTL0FWdksrbkIwK0I1bzJVTzdyOGpRRlVpdS9uMFg4NklyVmQ2dC9UcjJGT28vaExocmk5NU9oVzZSV0VFYlo4bVZIY3JyNVIvT1FhVStSSjJaVnYrT2JGQVROcmp6SzYxTGFCbnQvd24raVhMSkNJbVkvZmJ1eGRVcEJDYXBQSkpsYXVjUlpDVWQvbVc0L3Zmc3JZbEJmYmJTNnZ5STdROGE4UXZXWjNMUTA3WVYrTThQZ0hRNmRxbitzek83eXREcThkb1gwclZ6cmZMVVBjVnVReGVZdEZJVlB2STJHY1VNOXZjeUQxelVkbm8rWW1vNWxpKy82MndPbjgrKy9nVldlMHd1a24zOS9peTlhaW9TdnY1bTBlTVEwYmNSNDhOalBRcHBHelJRTXM3Qm9zRWVaWnRzTXJRa3FWZ1hZYVhTTlZxUlZIYnVYeThUbFAzcVNMSXFKVVdSM2xiSDUvMXlIa3VVZnVMK01oZS85dnFPMUhRL3V1eEhaYU5rUEwwWGwxTXA5ZUk3Sy9TdXMrRWtORjRaeEtzMFh0SENHQ1dLVUpySnFJbEcvRkM1QUNpalNnYVRudGt6eHd5cjBIbVJpMUd4L3JrR0dZYUltOFliYlc5d0JDVWtEYWpvb0FSTXBCNUhlbDhTdVlhZW10aW81NXNxUFBzNUhtak4rK1lHOEV5RXVqNDEzdGVvbWVlMHFnYmRGR2ovcUpxRnRKYmswaDU5MGVUMWxWYmNiR1dUNU05SXlUUzdvU2xjNGJyc1Zwck5Dd2pCeE0xUjd5aDE4STdMb3plUDgwVlJJemp3MEY5Z0ZVZEViL2s3ZFlSdk5mSFlWSUFkR0tPZHZrMFpveklzdk0rZHF4Nms3Zml0UzNyWTZ1ZlBXMXVSdCt4anRmbkgwYzA4SGl4OGVEYnBvUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaEJPS2ZSSjVCNUkxcTc2NCtCbzU5M05TOFIreDA1dDdWcEhQN2dGejhSU2hBY1FiZlBuSUVTQVAzYkxUNHhnWXdZbmV4dGF4QUhhTDdiVnAyckZXa1l1aU9NMkw3amV3OHJxVUR2SWEyYmRGdVYwOUVkM1JYVnZSOE1kSkk1NzFlcjNXZFJmelRwc2NqeFRyUjcxY2Q2K01qcUhzUnRvL1BMYzBwRW5paGhzcVMvMVRVSFVtckhZT2xKclhMWXdtMUNxRXB5WUtxcFEvbFNsTDdobU9Xc29oSDExcld1a3AxM0dkTFJnVXppQzIxYkx0RkxidldnWFF1NS9WK3Z6U0lEbGFRanAwY2FUenBab0tVWVZXM2dqdjgrWHJqcXJWK3Fnci9rcHpjTDdCV3Z0VmR4UE8vZmM4Nlg1OHJ6Y2hSdzlOV3ZLRGUzUk1oanlJU1lVdDdFbHAyMHFOajVyMm9WRlNVc3U0VHEwUkZ5VnQrOCt5K2lOcVF2UkdrN0x6L00yZnlxZHY4U2FZMkRmQSs1clpPck1wNzc0czI3a0VDaTVhTWxPenhSQ3MvRm0vNHk1akE5SUFJclNoMStnbGhSRlowQjY3cUoydmRORC8vSzJYZlBFTTZoS2F4YVhFNVlmN3VBSE9FTTdJd1Z1TkIrMWd0SStKL0U2aGIwb1dldDY3WHNoMHRIMmNOaExZeHkxN2k5b2dVNDZ6SE02V2h3NnFWT203YTY5cVhibHRPeTJidXVWUVhJdVJHZUVlN0xVdWtobytnN0FpMlBlckRreDhPY1ovTzdERENNenhFUXZOb21aQVFRY3JYS291V3hwSXRsUTFKVDg1bGxnR3oydDc2V0U3MlZHcWRYa3ByVGE4VDhnVTF4RE9jU0FxVXBiTWNSWXVreXZhOE5JZTJQbGNhNDZOZG56TjBhbkpFME92WElrVnJEdEdLTUJONHZxWERrdHVJWXBlMXlXOXk0VDQxaTZBWXk5WVhWNWNrZjljZGRMeXpsZlU1TFY5TFYzTGtzWkJDdXBZT3RBV1VEbDJXTEsxMWE3UFA1Q0NpOFpSMmczbnpya0ZyYXRBekh1eWxwZXZsWXk2MGlpTzNRc3VqRFUxbVZMMDFmTytKcnNpSEl5WU5TUmVSL3B1ci9McytVZzEvTm9sckFVazJ3L0FqWElUOHdUdTNtdkN4VXM4NHlSdkN6aGd4MzRwUmdjZUxCbTM4WWlvaHMyRWdRZ2doaEJ3SUhTOGhoQkJDQ0NIa3dodzVaT0h3Nk9HODh3YXpXUk5DQ0xrRVp6b2tPa05DQ0NHRUVFSUlJWVFRUWdnaGhGd0VmakgxYVZnNzVJemFtVWZBMnBDbkFPYzh1Nk4xZ3k3YXRTNUVTbHZzdE9qK2ZLMThVK3VHakNHeU03TFZDTFRORTkvQ3lGMkpnbldvN1VhbGlVVnNYMzFiSjV2cmc3QzJjTXVOUEsxT2twSytHNmlSYjFNV3RJTjZMRE9pUzlzdnMxVUdoSlhzL1BrZnRHdXFkNjhkanhOc1Mvcjl2WlZkSU4xYSs4R3VwLzZLUzZUR0w0ZG5aeDJrcTBtMzh4RVZCYkRlZWJnQTI2TnREa1FkRkI0NTExOUdyYi84azlWOFc4a0Z1SkhibmxJZlIvQTB6S3lrMXhwaUFvOG5vMXdlb252elZiNUEySVg2VjBXUmY2czdXVit0WTlaN0VSN0JxalhuVDQwWDhlelA3MG5Ga3U1RVVYdlI5bnd5enJka3l5VkI0bzM2K0lnMk5XcTdPQS9STm9kY3B4VlhZTEhQTldnUFF1dVBoZTlUclA2MnZweTZVeVhic2IvNTZqVGU2dFMrRmxBYXZnUFcwZXVYUnZTSEVmNUtHM3RKNlZManQ2VXJ0MDgza2tSRjcrUktRMUJ2R0tFTlFldGt3VnRUdnYrenFadTMxTnpyajVmc3JGYVIwOGtGdXdvekMyUFpkU3M5a2tkakg0M0x4eVZkT2NYS1l1a1lOeGZ4RzdOOGZJTlIxNG8zU3JLR2JKUm9XKzU2UElTT2w4cEdvM1FjaWVtMHVJb1EwdUtNSHRPYXAxLy8xdEluSTMyTFM3bmRwNkRGZmlQcERTTjZ5bGFIQWxhRHRUcVZGRGZYdjB2anQxWkdjaCtzOXBqQjlGcUlHeWxEZEUwRENkWUkrUXN5QnZPaUdWRXAzYWl5Rkx0SW0yVE9TWWh2dHBKMmt3cXFMN0FjVWMvOHN6WDNxeG1UcXp1czRqdGRMS09weUxNKzU1VDM5OEliNG1qbjVUV05NZlMwS0RSRWkweEhTbm16SWFNNFpDTjN2Umc2NkNvSDRtM1EyZzJNTmtKaU04TE5qcm9QaU9HeURNWkxRVmZxWnVxMGhzTXpRZjBXSW9ObTVjTVpqWXE0UUc2SjFrKy81NFUxMVExS3gyakZzSCtIUllsOWlpaE1zQ0ZXL0IrZHJoMWg5dGorRzBnRHZSZFZHTCtZU2c2RGhvZ1FRc2cxT05NajBSc1NRZ2doaEpCN3dRaVdrQWZBamt5bXdjWkZDQ0hrQXRBZHpZTjFTd2doaEJBeUJZWlpoQkJDeUFuUUFSTkNDQ0ZUeVAvNzcvOUFMejMvOHo5OGgvVldYR2dIajl0c0p1TGRETDZWRDl6VmMrUUd1ZVNHb0p0QUZzZnh0K1BaRnJHekR0RU5oYTJOZCtvOG5sMFJiWTdjLzdCblB5RHR4bW1maUtuenJZbDJHclNXdmJ1NDluUmdwVDZnNjFpbE84MVdiSy9UWDR3UmRTMmwrNVg1VzdQeThVc3pZdHVpaUl3bit4OXpZK3ZWQWRVZWFmMDJLVXJRd2tncDR2YnE1NnREUmRpZ0thL2tKelUvYnArc1BZTmJzalU4T2pSZHlPKzFUUFMzVmthbExNMWtsUSs4TGFPTlJydXV0M2N4Yjc3aytPZnJqcHRXWHhWTCsvcGpmVnpyblJIUDNwdk9sdEpxMTYxOFNMcVpYS0VNZjdCc2haUStwYmwxak41WHpaWXFzWTZqS09xWFVpUDVWcnYybC9wcjBwdWZHZkI3UzhhVVlyN2lTTkJ4Z3ZmK0ppRzl0eDJ2MDZWazE2VlZsZ0M5NFVWcW5FOXRXYnVycW9la3FVb251V3VoaWplbmM1SS9ubTY0Zms5b01Ocjduc05JVzdrK3ZxWTA4cmZPUjNRZWVVZEcyRUtwYnlNK2NFbUpYbTlQbVlxU0ttL09GdE9HYXVNbHZFVDM3MitFWEJQRWlrVjlYazkwaGVwR3pxOWxSMlkzck9PdlpYWVlNZkxHUnFiT2tMeFN1bVRvUXMrdjAwd1lEcENKUkkyRjFZWWlSblIwR2VvMGJLTmtDbGZ5eEU2ZDlhU0M5SVZVVFhUMnppVjloWUxwUFhYcW5UdERJOHFaT09wbE4ybVVxK1Jsbi83dllmRDQrbHg5ZmxjTjQrckYwNEs4TXpISm1jZUxaeVpwWGY1SUN4dXh1dERTZFdTcmZ3WGVBYUUyVGlEejZSbVRyZE1na3hGUnQ2VGg3ZWd2d2x2Vnl6bmtOcUk2czNIZWc5V2traUg3akFqbjltZ1ZSRHQ5R1Z6VEFNYjlxdGQ1ZFVHVnNzeW04SHFRbUMrbHVJRUdESGMwak5Ca01ZUU40SEh5THgrVThXMVRRZ2doaEpERE9UQ3lQRFdJNWZDY0VFTElkYUJYSW9RUWNnbm9rQTdnakVybWpTV0VFRUplQVYwK0lZUVFRZ2had2ZDUWlMQmhFRUljMEdRUVFzaEZlWm1CcGo4aVBmQ0xxVS9EdTQzTGhLM0RyQmU2a2YzckR1VkE1Zjc5MmVOTXVyMWtCajNiTVpFZnJCMUhySFFEVmJiU2FUdUsxT25PUWR2WHhEcWVsUE9vUGlCdjZHdHhpQWRDdHJQUlpGam42elNqTGJ4WFoyUG4yMkcwNjlUV0dObUtjQXdYQ0ovNjZkaytMeGw1Mys2WFRybCsyMGJxMWhsMWlyYm1PbWZrYTBOeVdzOFdVa1g1WGFkcnljN080K3Z6bHV4VzJSUmRQVzd0V3gyTkhhK25FeG5GSFdrOXMvdExqcHZjVmQwV282N2I1amRYYVdVWnYxLzJPcUtPSWx2MkhWMkdJeml5REVqY2VBeklSeEcrNU45L29DNzFFYnJ6R1Mwem5nM1pZZFBoMlJONUZpUDNaVWIzZmxZcStZc1ZYeHl3LzZYeXhWeFJGVG9VbFVDcldKRmR1MXZ0ZUt2OXJqOXFZWDU0SkIzczBxOWdocWNXQXBVOW93em9YQUxha0JPUTNtcmdzNjdQc2lsN0NuQUVMd05tbit3eHpGS0Qrdlhnbm1Pd3pTU0UvTVdLZ0JDOEVTQml0UzBySGJYTzNwbVdVOTM1MVpuWldHWlUvcXdsalloTXJ5dXozUzA1QTZ0TlhSbHZTRS9JVktKR0g1M1BHVmtXTUpKQUp6YnFDUkdyYU9LQnlIaTRsOGpra2pTWlpLVWZSV2Rna1pXeWFKUEJ2d25XUXBKTHBTQmhGdHJkOHg0ZldRYUxlTTNhMXpVaUhDUW5ZcmtHTXArWmJsaEtqK3F5MWpSZTNrYU85RHVhN2xTVklSdnBaelFWVDNUVk41UC9RTmluWGsyMkFzVFdlYVd0c0FtOUZIUnkzOXZHaERZWG5RcU8rQVlyTDl0N0J5K3JQTDV0U2c2SEJvb1FRc2cxb0VjaWhCQkNDQ0hFZ2xFeklZUmNuVE1zTmIwREllUmUwR3FSNGREOUVrSUlJWVFRUWdnaGhOd0R6cWtRUWdnaFUxRyttTHAvejVwZlRMMEkxcFlyZGJxTGNkRmkvUkRacUMrNGU2MTNzd1J5YzZ5MkpSMjN0cVlnUDNoMkZqbEl0WFc3a2R1TVhzWTliUWF5bzJoVml5VzF6N3UzalVQSzBFb3I1WXR1cDdmTzZ6RVM5Ym42ZkU3SGYwWFBaN2grcnpxTHg0L2NZL1dZTDlRTnhyTnRrUVhTbGFROGIvRlBpSW1aVmhmMk40Vit2N1JZSDYvVEYwUHlqeXdwdmFZanFhWHIyZjV6ZlZ5U29kbE9yU3gxR3F0aEp6QnRLNytSRDZxV1NwYXJLSjdyN1dtOEVlUGhsU25YcWZ6QnZlMlhVblB0Q28yaTJYZlA4c2QySC9OSXhITFAxM0lmdkxaa3BzNGpzQnhTKzdvTDFvemJ4NWZUMzVBOWY1TnZkT1RLam4weVNGODJOdnN0dkdWd3Jnb2hKa3F4K3hmZEJsUFNxVjJnaG5aL28yT1pWdDVPM1o3THNsUm9qT2plbHV1UHVHT2hhWGxjLzRoaDNLNHZuY0lSTmhMdFUwYzFwcFlmU29xTzN2NDdjeTZpcGFQZHNjZU1zYjJ4VG1xV3BSN1RvS01JT2NMejJtdENpQWR2RCtxeGhQOVZqaGZndURYeTlscnBFZDZJZ0NDdThLZ2h0OVc0a25DK2xVNUxhK2xFc1lZRGRJSDNwRGZzOG83bEVOQmhMeUVxVjU0VHRNYUpIaDJJckZiMnhtU0VleHJMT2NtaTV1MDlMNVZocGhIeGpMR2x2Q1BhMGtlRzllWFVUVmFqVG5aZld4MWZsOTRaZlN2c09ES09IbEVMNk16Q1RCM2tBRkRUU0k0SGRVczFBODMyN2h3eTZjQTJzMkdrMXoyaXlwSHdLaklWZ2M1MWsrUjN3S3k0U3lBTlBlcG5ocVJuaUxTMTB1eVl6MklUSUNMb29PVmlLbnRIM2xLNlYyQUZISzJZLzJXVnhiZE5DWmtOSXhOQ0NMa1lOTXlFa0E1b1FnaTVMK3kvaEJCQ3lJR2M0WGpQZFBadnUxNUNDQ0dFRUVJSUlZUThqaVBmOENTRUVFTElCczc0RTBJSXVRTDBSeVRDUC9KaHpqSmNudFoySnhlOGZaZHVVY1g0N2NtN09wd2I1NTNpeUJ0aFkrampoUHJyTVNWL1dPOTY5YlVoVHAxalFQZlRHbG5DWWh4R2RlYlZ2NlVXa3Vac2E5ZHpGMGEwbXZxM2ROMUhvTmN0M3A2UEsvTnZpN3F4c1pXMnlodlpqQzFaVC9kVDZNNllVK3ZCSzd6K2xvOS9pcUJzZXV6U3lLU2VNbklmNHVJOEhrblhWNWQrcEE3cUxjS3lHM1VLY0ZRa0VURWVYcG0ydkxJZWZLMnEvc2d2eFpXcXg0MXN2Yk55UDQ5ZVd6SlM1eEVVNSsrQXlEOEFwcVJVTVh0Unp1ZEswVzRYNFB6N2I5RkNXcmh6emZBTmFMNEJrMG83TzQ1V1JNOTRvbmM3enlvMitBMGo1S1FSbzZtcDdNR1FFZklsUWg0a01oanB0ODcvV3VvZmppakVLRnM0SXZhTHlwNFJSM3Z6b2R1N1dzZEgweHNwNGZtTFlyRGs0elBtbGdoNU4xVVU0VXAzZEJqaG1YMDllaWFDT0VCYzRWRmh4TUpkbHpUSU14alYzczl1SDlKWTg2alFsVnlRSzg4SlhuRk5vMksvVENUL1hxdk9hRlFuMGVxd1NQUm42VzZkdDR3RmNyNzFPem55ZGxKUENMVytpdm9uclhaK2M1L245YVhnZEhSWGpSOEI2bjRZVnIwQVQwTmd6SEk4TTl4eHJ6eHRYYVcxM3ZKeVpubGRhWWp1K01BaVhJWlJLeHE5SzN5dkJoM25zbEpQcFJnSE5sOUxGVE1RTWhpdndSNHdYM1hBb3hIc09ocVJ4M0RXZ1VSa0t1S20vSlBJdmJDZS9ZNVlCVXRtSjYzMU15dHdQNVJCOVdEWmtwVHM2NjJMTXZrV2tkbDRubDhpUGlLZEEza2lGQlN6eG5xTUQxR0p4Q09wSWZOYXRxSlZDdFFLS29kM3liTndYSHRyTDROQ0xhSjNGc2xyR1luczBMVWNYdXBvUkV2Vjh1cHNhejZEdVVhQVhaZTFUSGxaTkhzMjhvSUcyY3hiNGFuVEV3b1JMNHB1ZS9QZmwwLzNIdWpuZUkrT0VZMHg2dlZhNTFzUE1pRCtDN1g5Z014b0g5dlo5YnBzVmlTQmpOS3V5Kzd5VjVlN2VhbHRuV2VWZEN0cksyejVYUXAybjVlK3N4UUJ5L1hSWWZxbmZicHRmNVZ6K2RyeG1mZS9KLzRZcGF0MS9kNE9lcCsrMUdyblArZjI5ZUMrR3VEMjVxV084NzRNNjdMVnYrM1k5bGVEV1lnd3MyUWpkanlDNXdFNmIzNUhsdGJselFvaklpNVB1YjMxODNxZUYwRC8raWRKWnFYS295TWNxaDlwZmg4RE92aENLL2VJbStDZFlVYjZ1YzhXV0RFUEZoUGw1bEc3Qm5QalZ4TEhRYisvNitQbzlZKzAzNFM4RDdRSGFWYlo0L3BibzJZcHZhUURQUjhkTFR6ZWJULzlBdEdoNkhKczVwSkdDNnZ6ck12VE9rOFhlQy9DQTRvSjlMYWRPblNiTmJRbUx5THF1ZGQ1dldzYWlFd3BmMnZpQUp4RHk0M3J6VkxhSHVPaDZiSW1pd1pPOEVDNmtmT3pBU2VvRW5pZmw3eEx1dWJMcWRxY2dpRyt5clVjODQvNjdmTTlQYzFiSnJRV1JyYVl5TGpvU3E3OXNiUUdmRWc4VGE2SFpqUTh5eWFXa1lpRUVlanhsNEpHVlpwZlNrRCtHVVB2MGJTYUw1dE1rSjVoQURrZGJhaWlEWXUrZlNoWHZ4TWhUcnpCZThOUWUvMFVldjdJTlkzSFlNVjZhS1VpUzlBUGdTK21rcW1XQWhWOXFMR0tHQWdIaXkxQmJJVTEvV21sSXpjRGZRNk02SXlZekFuV2UzVHBTTXFueFJsMU9pKytTK3VOYXFMR0ZBMmRrZk5Tc3ZxQlFjdWlIdEVSZTNWYStZVTZkVi9XaUhyUVpXUWgzVzhMbWhsZGw0NnpOd0FOSkdib2VESWIwK0dONm5ydEttSy9rSWUzOVh6cCsydjlRcDJzcSt6eW5kRWdvamEwQk03MStxVnluTXJpOFEwU2FFUnlMOVMxdWxaMWxLMWYwcXVoQ0VmS1RuZE9TRTFpZFYwTW5Wb3UzMi9yK0ZPSVhIZHZ6SFpkV2k5ZWw0SzJHVXVKL0RNWFNXZHRqVXE3VFBEYmdEUHZTVVIyYi85RjgybHBJalovUkl5emlGcVZvZldjNFVnR1YyblBCODIxWmx2QWRFamUrUm5mQ3VMbHIrZ3pSdGp6bG96K09CS05pTnE5RHJOVGVyUmNyd3g2NkxHUjFuVVI4bDdxbm9YMlRNbGFSeU9lSGdzNmVzVDFlTGY5OXJnRURlVzllYnoweHMzUnR6Zkl1VnlwLzNtSHl3dTE4ZGZlSzJOYkpHNTZPc2pvYUtCRFp1azh2NUNyUE0wKzFkdWg2N1JJUi9mcVNxRE0xcE9rdFk3UmhxWWhyMTdNMEJaQVNta2Z5eVBLdkwzKzBramhsYWo5dG81SGRHam5zL044cEpXaTZQTWFjaHE2eEVtZ0RiSTN6bUk4ZlJ3akRKZVdQK3F5SWgzOFpYaHZrZWZKaUNzTms2TDBSRSt2SVJxeWttdGpyTzlheVZHWHdENUZkbmdXTVF6RFBNcjhuTG1tUVF3ZTdLRDVZdXFUMFNMcDFqTTBBN21OUWZLdWJxL3pySkhtNzV5VkVNeEduc1JCL2ZOeGFEdFRhTDhQTEVwOURwbm9RT09OK0dXMUZsQ1FGMW5XTXBDMHJUSUE2VE5hUnVtNmtHa2xTV1l4am1zeUlvMnN0NEdXcmU0aDdWd3JrLy94ckxIeGM2K1JmSkNuYlhVaCtwRisvamExaHEwY1h0Yzk5bXRKN1gxaDlTZVAvU1ZHWkNUYzA5TzlkdnFJQm03cDh2aUcxQTRLZHNjL3NuZGI5U25IUmJ5UnhBaFErenpQVjJaRmRoMUd3SnZFR3hyTFR2ZnZtZTJMRHVzelJkSGw3Ny9ydkNWNTJzVVYrdEJkNlkxRFJtTEZyb0cybEpQcmhiZ2hySFQrZUp1cVBaOVNLQTJuN1RkbGVjWVZscjB1UnJvNnp2QTRKZzNuT0hJZFYrWHN5Z29YNVNKTlpkZHNxOSs1K3NQYnhKdHpEbHFYdVpWWlBxT3dsazJ0MHlMallkUm1XTE5JVW43TlJuanJ6QmZ0Sk1jNG9XOTBrRmVhZm0zSGI3eUV5OEhUdDIwZ2JpSFJLNi90TWlIdlprUXZrQ0tURVo3a3FxT29LNDFNTHNXVnd3anZEVTVBZW1zS1h5dVQ1ZUlUb0pPOEMydW9xYld0SkJ5WFpFZmFlU3V0Qk1NdThnV2QrMytZcDYzbllyeVRFU1Z0SngwMlMxbmVOV1d4Z01sUURxU0xncXgvUmNad3lQVzN4djFlV1VtL3o5S2lpUEZTNnU5VnQ4ZjkwZFVlWkNhaWxSOU5pNExPNGtSa3pjWnl3Nms2VDVjNEdPODBYWDJlTitOZUhEWFpVSGRVZkZxV05FQ0dLSGNaSG1mSGNUWVZFRmJVNWJDbUlwWTBwWkg1YTI0SHJzVXV4OWxrU0ppc0gwWkhqMmZ4Mm5aL3hsVEVUZUdMcVUraGdNY09iTWlqeG1LRXZJYjFmRG83ejFodU5ocEFiMys4bVN5TmJHYWxlQlp4REM0NUtWdlgzNFVLUnh0Q3lDQ09zSlcxcnFUbzdPL1lSVmxDM21yMlRzRzNuajVhSDEvT2FVdWhkeHR0QjJZdHBVVko2YmFXRWNzZ2tRY2RlcG50ZU1xZ05LTjA3ZnRPZHNqYXJ4L0d5KzcvZWpKNnZJZW5CaUpYdks1aS9MNGVteEpXTm0vWG5pL3pVdW9mUmcxSzBJRi9IUnUwWkNVbFhhM0wwbzA4RmhhOS9vL3NJVjlpdUIvSTNVUXB3WE1rd2gzajFCNjgxenVpYmpDZHVaRkdzMDVXZnlpQ0ZqUjI2K2ZJc1NZaHo2T245NHlLNk02R1B2OEJuT0VHNkhwSUZHc0tHSDFPSlhXazg2TE54eElTR0NrOGc4N3J5aDhaNGxCbVJKMTUxalF5SUNjSHp5ZEZWLzhhM1ZRc083Mmd2VnpjRUJrOTc4bnJsVFdqYkxOV3kyYTZIKzBXMHVVUk1wRmVBNFl5L2xFUmttelAvb1FxNXJDZlBBa3BjcmY2YmQwSHJFY042bjFjYW1oK3lUQUFBODIyZG1HaVV3MHZYQTdtaTZsM0pkSklyYTFTSmxnMXpUR2Zha0RSdW12Vnk5cUlUTHpBMWdNMURIcHVTRForVytkNHcyM0gzbUxFZWd0d0hIbEkxUHNZOEp5NFpOUUQxZWp4VnRvQ25yZCtMOGRLMG10YnUyTzFUTytDVkErdDY3R29yM2QxZUtPaUdrbC9mMnNxdFlmYS9kaUxRK1dqSVc5K3g2UmhwWmtZK2x3THJibS9wZ0tDYk9yRmFQdTUrcU9yVHV0WEZ0cUJnL1p3ZGxieUxYMUxscXg5Y1hGclEvZGZIZkkrWWFUWlRmdDY5OGUxVWIzWHc0N3NDSTNPNVEwa05GR3VMNmUybEIxbEFHYU5XbkJEMXRvVXZDVUJLYlhlYTlIckhtbVF2WFd0TmpMbCtBaWQ2M3lqbWRYV1J0QVQ0N1dZZTcxNTdlUEtyNWZJbnhNRnRFTTdWMWxrWFgzdm9IckhGVWZpSGZoTDU2MXlhK25xWlhZcFR6S09PK3V1TlhHMVh0V3IwNjJQV2I0UndVb0x4c1ZkYnJmU3RldlZxK01wOWJYT3Ird2VwM1laV29XZDVldDZ4cURlU3RkMFMyVkZaVWR2c0tRYjFZbkY2dHA0Zi91N1ZKcEtKUkh0L0dnOVpQRkkyWjN6eEhJUlpzUkRoTndielNKS29VRTk4NHRZS2N2RElMK0xrdWFJR1FjQ1lEV2lFVU15Tkl4QWRNMEtJNnpRUm5MOXZjUDd1aXgwYzlmZ2pvWUlDelA3WkpHWGdZNExvN0sxNkFDUlBkQkJXUk1ZcW04UjhsbVhsYldFR3BITzJJcm1TcHJid2EwS2tOSkxJRzNPQ2diUW9FWTVMejFoLzUySUxaK3E5STY1cmNnWlo5UXNqMGRIdE5WNmEybjlPK3JhSXVFa1hkOEpGT1AzZ3RXb2VEUEhNWEs1eUR0VjJFUFUzVHljVWI1Q2lpSkdENWRHVFVWSWViekQvaVdQSjZKNVBHamwxc2ZKNlN6OUZ1MUxQYU9GckJ5YjdRTElBMEVXTmJTMFNqSlVaYzlLTzAxbEo1SUJlbGtsOGNYVXUrT3hPcHJIbmV3MWMrcHo5bS9DTStIRVlPZWg4TWErbXRKNS90NEFYZ0t1Z0NNOXoxczgzRE91VTFzeWV3eG9JRUZmMDBZY2hhTjlBRjF0cXRONldxWFdrckViSzVjRWF6ekYzWXZRS0ZhYS92ZE1LNjVsdE5LZ3g2TVVMQWt5SmxOLzk1VDVqTTQvMXdBdHoxQ2MrUUUrS2Vxb3Y2Q3FYL1hJK3ZES0d0RXZvdVdmMFJhdjdOd2laVHRoWktBMmlkTCszU3UvUXlRa0hEby9FOGxQRmVIM0tObHJOSWVESEkvYWxMejVSMTNkbURGa08zQmwwQ3k2OXB4b211TVpyMndCeVIwWTNSa1JqWDlpcFRrNngzbGRybW9RY25XOHZSTUpGVVlzdWE3UEUzSkpvdTZOTHZGK25ERDFlYmd1WkdxWXZKeVphd085SS93WmM0WmVjYVdqLzNnanE0aWlXZlBQbnJXOEcxTStUbi8zWU93RkZsYlNPVDFtbG51NVFvdEMzbW5qTEFkNUJhTUgvajI2UitsNmNjZnRqWHhtck1SbngvR3IzRHJhZm5KM2hrOUhGUDB3MGwvWXAwZ1lSK1BoMU5nRmlBNUNXNDhHUFJ5K21Qb1V0SWczQ2Njbk4zRHBFWHRVSmZMR2ZoaDBkRkRBOUhVYVpJQllRcWZKVzBBYUFQTDB4QnVvKzZmMUhPN0FPa01mL1MyQWpHc1REVmtsTDJDZFZ3enRkNWZXeUkzTVFQbGFhTTRoQ2NlOWQxUnpMSnJPMXUreUYvTTNTWlpWV3ArTmE3Ymcxa1BzV3hucmw5eHlKVk1QVWV3bG05eE10MDdyYy9xMzk4TXpmTVBiL2MxbWdGZytkYkZhcE8ydUcybFZvaTlJdDRxa1BmZ3Q5YW1zOU9QU2RlR3ROMU9RZEZxK0VqeVBZUG1BcEp4WFpDMDJWNXFFK0NiVDdMTWdiNWU1bGJaanNES1ZmdDJiRC9DVjlmSHRkZGRWNnZHMlpobFdmOVZmSnk3TkhQN3I3amZQMGJpcU5INWZHYlMvU3ZXaWR0UjB2K3ZYeTdzOGh5UjVKaW1iYVoyTUw2cDZ2N2hhNVFaTDRaVTV3MWZVMUZhaGJTVmlPdXIwVWhuV3VxM2ppRXdnMlhLWjZEZ2VIYUlndWpSQW85OXFwdWJkVUc1dkpJcEF1Wk4xaWpIcjZyUUcwZElyK1VaSmhtaGRUOEthNU5aOG9mUjdlNTM3bXN1YjM5S1hVa3RsYzdUeGZwMzM5N2lzTTZucEkzRlhYdVgvL2IrbVM5ZWd0UzFDeUpxcy9FWkRpRFhXT0s4SEthSWJ5WXlJOS9XZzhXVUVieGlCaEF4YVVEZXlVWXdhV3RUcDZQS2V3YWgyck9VZlFhMXpoa0VtTjZmWDJMZnlhK09rSHBtalVIVHMxclpXNTdWaGF6MXBtTmM2dEE0dkNZd3l3MUY3ZEI1MXZ6YUxHbWs3R1dYb2h0WXNGU1BlL2FWVUhNc2xSR2RZSlBsSjBaVkIzU1B3MXF5VjMzdmRVajdQV0lwMFlqWGd6dWwzTWdIUG1Lelg1VnNUSHhxTWRVK1pLK21KSXJSanZYNUg4eEhTOFg0UC9oRHFKWTFXdWhhczBPa2dmYzRhaVZraGJxNlVMTCsvaDVmaFQyNlhnUkNWbmtXTlZkS0lyN0RHRGJWdlFQeFdmZnp4N1g5VXdMSEViaStjdCtTTHFYZWpGVTFLeDFzeUpqRmo0bVlZa1k0ZE1BaDFGbXZDekRMbTVLR01qQjdJYlVGczVqTnZPMkJZaDEzNERNOTBaclI0ZmQwNWpTemxpeUx6S0RNQ2lkZjVtMFk3MnkwRUwrbFQ2bDllL0NwWi9WdUVQTGxEdHBZdTd6VCtwaXpObkdPRG1HaGptOWxJWjNqbUlodkhYZVZINzJkUDJqTTcvSm4zY1k1T3JSZlg2ZUlhZWhsUkwzZHlFcjNMaFJsTWV4RjI3cW5JNTYxamFTWEhlN21HSFl1OWtQck5uY2JqdmtEanQwWlBQT3UxNDdMUDE2TjB6NmhVbTVBMGVOcVFySU9uZWI1bllqV3VwNDVQeitoVXRjNGpWaGJ3NjVSTGtzRjBoSkRSakxSU1dtVGp5UnZOajhnbEwwSnIyRmRZYk9lVS9IdXhqQ1F5TEQ1NnlwZnRsZXdZOFJRaGVtN0duTDZYd1dzQStaTkhuRW82NHZvSFg0OExMZHF6b3RHZUNMTVNNVHI5Z0tMMVVFNCtqNlpCOG1YbitUTVorN3dHSVEvR0U4djJ1anpHdW1GR1JodFhpTnhtUXg5QTdraWsvMHFQVzJXUEFFSm1ZODM5WmptTEppb2x2MjJuUDNBd2NpcGkxa0xTeGVHTHFVOGorbnpaWU5DTlJtcEtRMTdyUEFTNnE0bDJEbndmb0ZSWlNuVSt3cERySi9maUNvdk9WMGJiV2VTQU9ncytobXZLTEkzZjV4RGRDZ3JaWThVWmFlWGRINzhxL0VMQXpFZ2prNVlhaWlLcmxTODV5d2FrMFQ0THA1MTNnWlUvRCsyWVpmVi9mNzZGWEIxL1Rjdy93M0E5aWJLSzNuTGo1ZFJQRXF3Q2tVclBqYnpTZEZvVzg1VkszbS9QczV4a1NUOWZSbDFyM244cDlUcitxQmkvUGJMVytVY2kxWFYxUDdYUGV3N1ZPVXBtbWlBYjFXMk5ETGUwMWd3WGY3VHYza1g2UjhpLy9NYnIyaHZMYVY4bEh2TzE0ak1aMlQ3UGlwRFg5amZLZ1lPVmlzWE10RGJQTjB2MStmcnc4anhhT0pKdGZCSDZ6MWRVeFJkV1o1dHRGK2g5UENMQzFPeTA3dk8xT0VLWG1ReVphUDRxaVRSWjJEdGZoK2hjLzBieTFXS3FmS1U2dm02K1hWOVpGWFR1aG5aNlY3b1laOWkrV3FkMzNMOW1WRVAxMWtPazNyUTgzdnBBMHNnUjAzNE1zcFNnSHJ1MG83YnR2M1ZPN2ZweVZSYkVEcmY4ZTJ2c3BzMkIxWG10ZElTUUtDUERDQWxQbElYMmJOUktrdzhqS2daMVo2M3BqMmdZNFcya1VoNHBiekhPcHhRUEl5SXh1bmRZUVlpWFZ2OXNwU1BrRWxockdzazRYcWNCREx0M0tQY1ZMMHd5Wk9lYWhyc2YzbWxOWXhrN2x1cTNwRHRpcUl4VkNjK3dkYU95ZnFaaU5hSFZ2RjlTdEN0bmVHcU02M1UvV2xqWkE2cXpsYjU5OThnUU5QT01UTlhYY3NneElPNFpkTHR3T2cvYStJOXRaTVBzS0NJaTEzT0xpcUVUTlJGb015WEpIeWZmUFpoNUFMMjN3QXg1MHo1QnZlNWJIeWZFakNNaVM4NkRETFc4V3RvdUFpb3ptdjgxSUJYMU1vZk1GMU9meHRyQ1FCNTJIalBHWUtjQzFxZjB6RnR2UGRDb3Z4RGU5TmRSTDJuY245b1JPUnhUY1I2L0ZDZDZ2OGM1WHRJa2NyL1pQbVNXTDZKbXp5T0Z2WlhwV1lpdWozc0QvQ0llNlhrdXJpZWxIMlNKRmNubnlUc1NxZnpMUXdXZnRuYzV6aXlUZDJYZ0I2MVhaaUN2eGU4ZG05a2ppbkwwS3Uyalo5ci83RExjWGZlSmZCdi82c0dsYm9IT2M1ZXFlcS8vUVI5UEdoblVXWFU4WXBJd0dvK3NzcFcxckh2UHhMdENTSy9zMW9uTTRkKzFpVFNLKy9lSFB1WmRlMm1leVVwWjZ0bDlRc2pUc1I3OHM4NXptbTRnUjdyRUs3cmZNOHBEMTBjMHJtQ29SazZWdnoza0pnZUNybWtnbmV6aWF4cVg2Vk96NjZsbkZxYkQrTXg4NlVsTmdKVzNwMVZIWmMvZ3FOWE5HVjJGYm8wUUp5UGQ3Z3pqb1hWcWR2YnBjSDZHa0d0eFJIeVc0Uk5iYUk3SkU2aWY1aWNkSUk4Q3ZRemp4VlEydTh1UmpkL291UWxJa3lyVzRtMmRmdWJrbFlsVzJIWGhyQXVvZnhieE5MeW9qVnczZSttTjZkbldpUHpnMlhuRUNicW1PVkNsdWY1L2J0T29hd1J4TWg2bkJXU0hialI2NTVJaEMzMmczSG9OcGlTOGdXcXlXL2x6VzhSWFZIUUdkVndMeHlVZ09qWHZGeTJuckhOay81NkM5U2FXVlhERWhyNGwwR2k5VVNCMXVlSWRVYUkyU2V2ZitrM0lUbnUzdk9oV1d4aVBqTEdOSXRySVpneDJlanNWU3V0QmpzOXg3Y3ZYYWhGYUNXWjE1RWk5b0dYeHk5NS84WGROZ1YyaDVJMDlWMWpnTXVsZXQrNnZzUmFvUlpaWE11cFhLTk9JTW1neVJ0Z3BaLyt0UThQZDcyMVppOUJFOHZwNFNkK1BKT3l1N2lOcitkSnAvZnZZMit1ZFJVbEMrcHhpUVJDcWUyWDdWUmtwdGZ1dDFkYXNkSzB5V0F4czUzVWpXemUrTmQ1WVZxSVl2M05iSmxLazlaZUplL2FiMklVQXdIVmRkbytMdjV4UnNKbmpYbFMyMW1xUWZpcVZTN0lKVXRyNnZLV3JsVytkdnhocHJCTGdPcmVqbEgwY3BZUFlYMGwzU2ZzNWdOODVyMWhVUGNMM0UwSnFrSm5ncU15UmVkSG9VWk4zV1pkK0JxTXJ3OU9JckJ2cERTTzhVeVpTUGlObVZlVm9iaHdKSXl5c0VNRVhRcEJaZUlhMTBiYTZ4bXBiQlpBNVlod29JUXhCQ1RrZTc4VEhDRjBCSGFLdnE5WTBvSGxuZERZOFlqeWkxNmN0aE5aNG5PV1M5bCtOdkMyblhScUh3Zkd1dFd0YVZ2S0pKeTBqS1R2NTZHcFJMYlVsRXpYZlI4YlZxRXYwdUI5ckJxbWUxV2pOQk5jeXlVREE3cWtTYmVEazNpRGp4K3c0L21Jc1c0bmt0ZEwzZGxQdlZJUjBIQjMyVzd6U0o2QnpMQjQ1NUhUUXlIMjM5RndhYVVHWmJBb3ZCNDM5Smc3NzBaR2FSd1k2RmM3UTlZUG4vcjYwa293WFU0OGNycFBoSEh6N0ZnUDF1TDUwd2tWNWJoMTc2WTJJakliSnFjenUrcEo1V1FkN3J3L2twbGNBaDR6enVFYmRJZ3MyU1A1TEk0MFEwZG5LRWMvNFBnNXY0QmRkRHJVZVkwVGt4VzdPOG9EMzh0QjFyWEg3QVBnUkRlQktqYXluczNqUy9VbGFuTWRUdjg3aFJIUlBxTXMxNnF5Wk5aM1doNzVPV0hicHRQeXRJN0dTMzhHQVg2R01JOHJRYXpzaXNzZkkyN3pVcGpka1JWVHhxTUptdE1PTW1FWFJscGhHUm96V0kwblJvTTdTRTAwemswL2Q5Z3didkdHYlZJUUQyTVpaL1RWL0IrdE83b2JWbVdaMGx0NE9QSU04MU9JVFFwNUp5M0pGUndXMExlUTB1RHp5ZkdaTnc0MFlnbHZwUmh2SHVWT0RoSUFjdWZJUE52amltWnNwazQ5cnpPN0Fualc1MXVUcHdQczY2bkozUlp2WDltYXVGdFhwWno1dVpkMU45RzVycjI4VFFpN0VHYkdocFRNN2o3OFF6UTRmNFljU1dKYjErYU51SFRMRGY4VVplVUs4dVB1dDhWaFd2YitMMWsvWWQ4Z3dPaHBUNzhpVDdYZ2dzK2N4Yjh3L2lUeVQ2UE4wblVRTjF5WDdaTDNObUphbWRUNmd5cFBucE50TXlQV3d0dVFJZEpZUk80d2crYVVCVGF0L3ArVFJIWm51UmtOWWIyVzN6bGZwdEF2OWZrS21TZy9KcnM5NzYwUDdqVGdMTGE4a28zVytKWFA5VmtFS09HU3RMcjJleVQ3N1crSmNhU3lmNDJXVFRzWXVWL1hhaFpHdlFLa3VpOWY1My9aQ0o3UDdQSnlVSm8xU2xyd3JDLzRGVnoxbDNmK3ljQjc3T3BGbU82d2xXMDBXNHYyUTVWNnZia3VuZGQ3WnFUeFZXMGFPRkZycHZUcFFtYWhjWHhtazkrRnkvZFpQZFh1eXVwUDdJbk1ydEdoZnI5MXFUZXV2RUh2ZDc1aWE5OTV2S1g5L0tjYnFrTkwzWHVlVm1kSFA4Zmp5NStYVThrMWVoQVdZVGM3Nnk2aE81UHpWOWV5NmEwN0hmUll5Szc5Um0rKzFCSXYxYUxWMzFCZWlmU2ZpNDYzakNzM0xVaHBicnY2VlpLMlB0VzVKMi9UTDhockhXNjZoQ0VQRlZkZjZ2YXo4RVZmSkRKbTRwNXJGdjNncXB0Y21ldkpKalFpUmE2V1JkSG5tSXlLNjBjbHZTWTQxRHNEcVpEOHZzUDY3R0xvc203aWN6VXBxWFhjL1duMTRmUVFoNzBick9VaUk0Q1U2MHlDVkFaM2RzSFNob2Myanc0RWE5SUxyU2tSY1lWTFNSaXNaTmZtendvaFcvbFluOHRaeDlEeTVCdGJRVTByZk9vL3FUQUU1bGpPSXlDQXZaMVNEUnJ5K3BndE5oNWFsbGJjNnY1N2dHQjVNekp6cmpHTE45NVhVMW9Hays2K2l5eWhXODdLMVNhU2xPT2g4d0VnRE9OK1lIbUd1VVhjMG9sZWk2ZEJRampNTUp4QTFhNjA4eGZqTkczd2MzbW5vSktTZnVZekV0dEFFamJKcWVvWWluckswbW9BMUZkSEtMMkZGTTY5c1NnVTR4ejUyQzZDd0dRanF2bjJyNFhmcGtnbUU1dk5SMzEvMGMrajByS1lDTlcrdEtXRnJiZVl4SnJSM01ZZnM0SXVwZDhmVHU5bEJYZ0Z2TXlFQU40dUk0djE2aVp5dWRNRkNORGVzaUdkYzc0WHE5NHEzKzBUV0xRM3RRN2Yyb1o1UjZXdURCU053WG1hcTh0RkxubWg2NzQwcmpUTmxJM2w5L1BmaGNFU25keXJjNGlvTmVWeGRiNUo0Ym52Wi9SSEpyUHkyMG85Z1FoMkdaWGlQbytmM2FjNjQ2bnNZL3hFMTgyVG5OYUtmUjgrdlZtRzhnWk1xRStQcmR0TytDSHN6ZHVUOUgxVzNJOHNRZmZ5b3J0MklqOC9nOFVZUnZLcTllSDNzbVRTNkhJZHhWNlJ1WEdpZkc2SHJIV3pISDdOMHRIOFRRdTdIVElzNVlzbDFscDNKQitwNkRWZHl2MWRhMHBnUnM1TnJjdlFVNHNoMkxobnNkNGJVSk16TStlaG92cDR5blRNelBVNTI0Nm5jNy9uZU1UZVNSdE14YVNiSGEzZWowM2xhMm92YnpObXQ5TzR1QTcwR3VrWkNERVkvN3VCSlYrZGhoeDJHZGdzaVMxVmN3eUhrZkFxUWdOTlo1TkpvZmo3TFNjbEJ6RnJrZVhIUXdCZFQzOGhnRDR4TUViYUtJcVhKUU41aDlDaVRDbDdpT2k1UkgyUWUzaDJ2ZU1OeFBNL3BEbkw2MnU0ZlI5NDJUR2ZrNWFjZTdhMDl3SVFwbnZVYVRpNnlLRlcxZEtQclZXaExHTnA0V3JWc1RXbWg2ZXQ4M3RXbVZkYVUwL1lMcXA4VHhZcW0wUWR0aXlHakFCSktzeVFqcUhWbFo2KzVuUm1lR1VpOHhTK3RYMHFGWXJwWk5sYkttWGRINUhRL2FGOFlxdnZlTXZkUlZ1ZTNMNmZXcWJkYVpPMUp5VmVuOVJ5ZmdWZVhkZzhNR1J0Zlo0aFdYWXBseHlVQjJmaU5jcVJWTkN0Q1BTOSt2VzZWMU5wTWZQZkZ1dWJsWXI3T0ZBUGtUMjVaMW4xRysyKzA1QkhkUFRKYitWcTZXdWQ3N2RDVklnbnJ2cTRNazNMWitmTUdLZFExeENMbzlWSDN5NzlGT0x6YXJueS9vNk5PWkNDc1dab0U2bkFncVM0cEhrWllRMDZrNktWOWVEMnMrbnU4Ykk5REg5V3V5ZkpQVFlhblpSMFpQVjJUTXZIOHJsV2s5a0JCeTFlVTgvVXh6NTIzZkJ5YXZzN1hLbXZkZ2JWeHczSTBmeVRvOWJFZnI2T2xzK3lZbGI4SVp5WFFkS21SemxkV1FzZ1ByUkU0RWtaQTB6cEJldnl6dHd5dnRpQjFKYzRJZUdhRkVWSUlJYVZ2bmRjYVVYSCtUb0NNR2pTY0tFWjY4bXkwSVd1cWprdm52TEl0a1BsWFFrUkdqTDZ2UENyUG0zOTJFeDFhRnN1Ly9VMzNTYWo2QXRRSldzYWkxY0ZIZFBqdENsbDdFYWNWM2JYa0w3SnJ3RUJDbTRqSzFseUVJZjd2NVZwRzNETDJyYVBIOUpqb0RPcFZYSVpWN2xaUDBxNkJJZG9GR0RYZzY0bW5pQit2cS9kT0ZWcG1uN0hzVkxTbEt1MjhWNTdIdHlFK2FxM0RHdmF6MlFoWTY0Wlc2TU5LdlRUcWJRV0hDOXIzS2xCenZVNUxYbzQxelBVdWFnaDR4amVlNDFJYVR4OTRGYTNGS3VuOGkvbFhJb1FRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hCQ0QvNzcvL0E3M0EvTS8vOEIzV1c0SHNxQnJjaHN4NndmdDJiOFFqRy9QMW9zajA3dGkycEgzdHJnTlB3ZHAwc0Q3SEc3NEhOVVFUK3ZQbzJ6SFFQSGRxUDNuYmp2TDlYekkvUC9NOUx3cFpFcVgyOWFGYmdrZThYdlFPQmh1c3REdXRtaWE2Sno5eW5UbXR2OFRZc3p2Y09LeTlSYmZIYjJWdWtWZ1BKVHRrdmpFUUtZQ3ROTHRXYVdUUzBzbDJUUHVpVVAwVm9uMlJTcW8xN0V1MDdjZnJNOG5NYmFWcitSbVB2WjRScks5bGx3NWRWWHJyZG9aY2hlRWpNU0ZPNVRQcmZBeWU2ckMrbk9yV0RhVFpmeTJzTDUyV3Q2VGVkdkdqWGY0OVFtWWszUlVkei8wSGErdDIvL2tncW8yU3NEWkwrWE9nS0R2NHI0Ly9TYnRKWjkzdUlUWVF4U3pNNTk4UlpjbkdlYzlXbTlMdjVaam1iNEZZUjcxT0pmMnVrVFhrN0F3enBrSk1QK3UyQVUydjdpTHIzMGgwZFdqenZoV3pZeit2N0tnUDZMa08xQmQyTnZCQTJYNnREbWFYaXNOTy9jUTJhWmZ1TjE3YVN2cXZPVTVLVlk2YWlQSFFycHNRMGtOa1JOS2F4bXJKMEhxdjFkczlXSG1SU0k0RXVWSVlZVFV5SysrSXhqZHk2STI2VTdyR2V4QnRZejB5dlNIdUFzTXVjaGd6NW4wdXVLYmhtWXpRVkxtakhVUTRldDRhazFsbHNtanBQQkR2b2tZMjZxRm9lYlF4ZVVOVlF5U1N0NmRYakdoWnFFd3I5RUZDbzFrdGh5N3hZRVkxS2lzZGIreDhaaG93MUQxRjNKSHFqNG1FZDI1SjRrckQzTjRWRGJLQ0ZmTklzbUlqZjU5aitCdzNoZ2xzSGlRTU9rZ3hUcmRjUFJwRzlJWTZIbDJQaGN2RGJ2aTJLU0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlnZUFYVSsrT2QrTzNDYXFzOUdzT0tLYk56RzJIaFIyUlBCc2ZXQy9WS3lySVhSblJGbWUwNHpzeHN6K0RxbXRhbTFDMzdPanNIU2ZiSExtZEdySnJhN1ZkVWJOV05Ubm9WMHpRN1V0RzdZamI0eFU4TW5PS2ZRcXJoL2Ixb1p0QTdyK2s0dGVsblkvMDI4dmhhZWJlQzJQZzhZUDZoUytYa0VXQWNseEN1NkZaMFZBK1ozT1ZBNDBvdDdlMzdIWkNIckhOWncvZW5vajZodEhCZjYwRHdGVzF5aForeFNQMERPWVlqMTAxWE9DeXJkNTZQeE42ZDJkd0JTOSt2VWlpVkg5QW0reFg4ZVB1NjZhNzVCOS85TzJvbGZMcTkvVmFGQnFyei9BamE1RDlMeTA1SHN2a2l6OWdXckhwMy9OVnZJWEtRUEdhTFhUSXVSd0daU00xZWo4L2NVWHVPR2d4NWtNT3ZaN29YSVNVZmp1ZXQ3OEc3eDB2K2UxVVNjaVlaVDgrU3J1eisxeUVrRGxvbGxFNjcrbWZTSlFWc2NLU2RZcEVkR1FBdlZOSmQ4RnlXRDNoaGRXZ3BmVGt2U0RUc2JOa3N1MlJZWXgwQmpQR3BvTmxhaFByK2pKUys3aXNwTXJVTXlPQ1huL1BmY3dOWGY0eDZCNnJIaENNNjdPK2tMcVRkWTNyOG82MTBWQm5ab2lIWHEybmhpUEw5K3ZqbWs3UEdJVWNDR29peVhpaUEvNGs1Tk02MVJsckdpOERyV3JQYW5jMDJzb05YVWplbVg2S05sK2cxUUJTb2wyK0dlN3BLeU5jcmgvRDJqUUw1ZmtLOGpKNm5jVkF3enlpS1ViWE5GN1REYnp6azNTOFgvaTJLU0dFRVBKNk9ISTZqaFByK25ValpMWnJRZ2doaEpDUk1Mb2loQkN5NTBqdlFFOUVDQ0dFL0lYdWx4QkNDQ0dFRUVJSUlRU0g4eHVFa0I1b1F3Z3g0UmRUbjBKMGkrQUpJQnVubmxBc2ZIczBwSkN0N1FHQXJUaVFsK2JKZzBDMzdOUFNFNXdqdGtIc1ZEVmlONjc0NVIyNU5jY0FYVVhaY3FoNHR4N3BxZVdXREsvdTZKMXpHZ21YZU05MkxsRzJkYTFwMHM2M1pObkh0eko3ZHMrN0RKSG1USHdNclV1cnhXdnBsclRhOFQ5bnl1ZFhyaVJaOW1xZnJ2NUM2cy92ZmM3U3ZjMW5UV1Riei9GMlNUN3YwU1hzTXA0YnVqYVZtOU1sUHZzcEVnbFMyKzBXbDlPU3Y1SlIxK1hud1BaRGZMKzZwYTg5eHI2K3VyOU9UeFRTa2lySjdHdjlIcnR6UlZBbk55K0N2aGZ0Zml1MTgvbG1xRjMzMjI2Y1Y5MTcwNUZQc0pWSEJGamUySFpFZjg2TmM2MnhpMldoREFxaVMySFVaYU9tSk9uTkRmRVpVbk50N2ppcXlJenFlaDZSZU1TU2hZNUtFZDFlVytIeFIxSFpxZExSNHdOOU1UeGFjL0tYVlBQMy82WFphOXBsUk1kSisvUDd2N1psMGpVL3Zoc1Njaks5bHQrVFgvTVFSNHhJSWpibGlJajExcUJoUkdSZHVNNWI2N0Nkb1h3OEJjcXdQby9vbE01YlN4b1d6dUVCdVJoZUE5WVRQcTlsanRBcDVTRmtDSjRHZlFSR3AvRk9jcmZTMTVNTjB1L2g5WUVZQmNmRXpwZElGRGZhbUxTY3Z1S0ExODlHYVBkb2ZVNTdsbUt6VGxYcE1LOFRjKzVIekVTTWJHMnR1OTB6QXhNaE9uN29HYU9nTHB3RWtDcmJFN3N2OEtiTXg0b3pVM1crUjRjbDAzSVJqSGxOUnN5MStHYkE3VnN3YzFoVUg2OTFvTVArVjlBNzVpU25ZMFd3WlhVZ3J4STJiM3ZndnJOcGtDYVJPTUp3UE5xM2gxQmY4QzhsdlZhVVY0ZXNVVWRjbjY5NXNRUG0yNmFFeklhUkNTR0VYQlFhNk9OZ1hSTkNDRG1mMTMwOG5CQkNDQ0dFRUVKZURvZUI1Rkd3UVJOQ0NDRXZnODcveWZEdVBoemVZRUlJSVlRUVFzaUw0QmRUbjhib2plbEFWZFl1WXRaTDVaZGk5SFpyRFpub1Jrakk3ajNrQnFEYkUvRkc2MWpiZm1qcEF1TFJIYXlzL2psaTE2MXpiRUIwWHhOcnV3L2xmQkYwZXJZUlV4TllXMzE3OSsyTWJGbFg1MDFwNk4zY1hKYXhpNjFZbGxySUtOcjFnV3ZzcVhNZnR6Sy9Ib04xeE8xK0VwNGdkM2ZTMmw2dDVmUnpNOTJ2eEZ4SkxKdmpCYkpyZVplL1BtN2JWQ25OREk5bCthR1JaZWkwS1p1cS84Z3kzWXBtcHkwaUhmdEtnV1p3LzFLbGE2a2ZxLzMrVVlRdjBlVk5abC9OU1AzWGxpTi9IZXdxUkdPamticHI1dnQrakVreDNFNitSM1pmUGV6Q3hlOEpRVk9XODhHNmR2SSsvU0FpTFBhSjQ0T3dZb0JVblorcEM0MDNFS3pyQWJQWElqeXhiQS90OEtxZGZwVUhpVFphTHQwenp2YzA4M3Q4TVJXMVZ4NWJpSXk5VytOL1JMNlZIdlVObG44ZGVkMnRmR3ZHajZIckdFZjd2YzgvMGlaaUZDaSt5T0xSN1ZucFhLZk5KSVJzUUNNZDZYaFVCOXFMclREQ0c5bEg4aURXN0RXTUREZjA0VDVlbGpYRmVkNHF5em9QT3JXU25Qa1FXZVFaakRZYTN0QTJOZEtqYmE0RThoQ3lJV0lVVVptcGtxM09CQ2pIRDhRN0diRmUrNEFES2U4Y3NIVCtyRG1HRmt0ZXozZHBETDRUdGxXbGZpOUwwVkV2anV5K3FHb1pUWGxjWEoveE1pdEc5WVJHM2xqZGtqM3dic082YTNwYUxYSFMweEdzRytnWmZQTEdYZ2ZQdUs1WE52a0xhdk5IekxGSXZ5WGR5VGplMG9HVUlTWDdPdGhjT2tDWGJzZ3RzTlpMOCs2UGlqcHNKcVNYQTlwU05vN1BIQ2ZkSHY4Q3NDNm5Udjl5TzhLM1RjbGgwR2NUUWdnaEN3ZDZ4Vk5IemZUKzVFR3dPUk5DQ0hrNWRJWGtVYkJCSDhnWmxjMGJUQWdoaEx3S3VuNUNDQ0dFRUVJSUlZVGNGRTVyRUVJSUllVHU4SXVwZDJYbWJxNERpN0l1UWpUdmNLeXRjaUs3R25YV2NYUlRyUU52TXhrSnVoVUZiNmdOVXBmSStZR1V4bTkwbDYyVStqYkNia3ZwQmQwcXluUGxOWldzNGpIUXJWcHRvVGtIN2Z3SW9uY1czTnE5Nnd0OGZkZmJMbG4rcFBGdUxSUFJOaXJIaGZGdTlTZmwxWGJ2ZVd5Z29kbVU2clNXWkVnOW9ONUF5bGsrcWVTKzVPdGplU2Qza1ZGV1orejhmZy9WbHRsanYxQWluYWRuYjgzT0lnemJqbmZXbGwvMXVXVG9IRU1SdWs1ZTFiM0hGZFpmY2R4ZlpkdFliby9LeDhjU05kUXpBK2NyT29zeHNjMnZyQm5iSHA4eElOeTJkeWhIbHZQdStrNzlSZFQ2aXdzOVgwelZTL2Y1ZDBhNzFXUmJNMTNXZVVtM05TTFVkSGpMSnVtMjhocnN2c0FncUVSVldmTjJ5WkRaNnlxQnNyaWFyMUFtVDdWY3phbyttNTdhYi9YbkZuZWFpMWpTNGpiVFY0TzVHc1BFNHNyU2tPK1ZrTTJ4R1NGa0pucC85cVZIZFBSNkFFMnVsRzdFeVBzV3pMaUFLdzQ1RjZLTlNKdHFTSTdqMG5rdFRSVHZNTUVhRnBGenNVTFhFVXRVZFZxUC9GWit0aTF5U1VaUFJtaE1XTlBJU3ZySThEWmFobTlhejNqUXU2WWVCWjNIVzZjTjZMUSs4ZFRLOTFlMU1pOW4wck11V0tlZFo1aVBYTkh3ampXOHEyVUlkSEVYWk1UWUJwMk9Zd09ZajNZdlVuVzhsVGM1OGlCbDhjaGhHOWxnM2M1VW5WL1NQS1dxVzAzbzBVMmxKOHlVemlOd0xEcU5rYmZ6bTA2NVQ3dXdXYm12dk0zRURUcG9HY2kvS3BVZU00V091Rk5BOXEzd0RnaTlCdXVGOEcxVFFnZ2hoQkJDQ0VIaERCUWhoQkJDQ0NGa0J3Y0s4MkVkRTBJSUlYK2hTeVNFRUVMSU5CaG9FRUlJSVlRUVFnZ2h4TWMvaWR3VHo1WmdyVFE5dXptdHhDeXFOTkV6ZGk0TFkrMDJGTmw2b3hqbkFYRnJNVWk5UklwTlRvYTdKSXduSzc4ak8xUjBVb3dpSk9XM1JtdnphL3h5SkdkZ2xTQzZ2NGszWDk1bVcyZXRkd1ROUXRwTkJ2UjRhNi9LK3M2TmFEUzVvVk82SjhGZFhUZDFtUGQvcit0elY1ZGE2MExLaERtN2ZhcnlQWjRnQ2VNNjhBbW1ZVDVhSUZZZmszNWJ4NUY0OHBKWTlnaTFnNSswUlRtKytrZi9zbk1LbG1GZnBtTEk4a2xjdmthRVJwdG9vK3EzR2Y0dCthM2czb08yRlJiU1NaSlNqbEVEQTNRTDNWWlpORFJaMm5uRXQybm5nempDbU4xWGhQUHE2MXRybC9pYjRPZVU5clhId0gwdVBkZjZsYmVXbnhxNms1RTI2dldRa2I1VkpvOXNMNzAySlJMckJQdTFTcVF1MFcxZHNmSmw0ZXVsMmdiOVJZa2YxUytmVnZZTDZjWjVGY3Y2dnFqcXNZbGFYcTF1TlZ1QWxtL2tkVmoyMlRNT2FxVUhaTysybEZYT0wybGFWWnZBNGtWTW95UlRjdlZMOWlJZS9oMisxcGVkNVB4MW1VVFBXY3ZjWjJzZUR6SEMvQjdPeUVKYnNqdzY2bGtieThxaC9tam1kVVltemF6Z1MwdTNsVjEvZVZTS2xkWXBXMk9WN1ZkY1V0S3U1L2NMcVcwL3RJOTBzbmd1UVZMUStpS0VyTkdzRWpvVDBZUFZtMXRseVVLK2xnNnZwL0NNVkM3SmpPRmVBZE90ejZjMHpyMzJ4S0ZyT1ZvK1lNNWprMjVrR0pFYitwS2pUQzE1NURwNERhdlYxanpUa2puMXJXbXdiWkZMNGpYQUkwZjZvOVkwS2hsNWhQTzBvanBwRVRKWHZ5M1p0U3p0UEdLNGpFa2p0UXdEREpQMGJJUXlGL3M5djg1bmZoSnFrMWxPcWdZYSs1Ull1cTNHVmsyMzhpSG5lMkoydE9WNWVtMXZpL0QyWG1SOG9kVTUzU29JZXNNOTR3Vk9NWTNET3k1RVltRjBUQ3JsVzZlejNES2ltMjFCcEQwYjNhWmxSNUZ1ck4zbVNGa3N2RTNvTmMxbGhDUDJWaGI3NGpUVTJLY0tlYVcwMW5NTmRaaWN0UTdiS0JOdlBXa1NXZFFZNU9zdEh4QVpIMms2ME5IaDdVRGlRZ2xrRVBaUytNVlVRbWJCaUlRUVFvaktnVTRpbisrUTZCSUpJWVNjU2Q3OVFRZ2g1TFhRRnhCeWU5aU5DU0hrd2ZEQlFFSUlJWVNRRlF4MkNDR0VFRUlJSVlRUWNuM3kvLzc3UDlEN3VmLzhEOTlodlNUV0Rrb0lnN1pwOFd3Z2RFbTgyNDRGeEhtbkRHOWZwOFFIYjZ3ZmRKZXhBMVF2L0xjNmJtMTI4cHgrUG1ML0UyTWZsNEx1WnRxU2krNzdnbTVOaU54UkwrZ09yRlhhM1ZlSkdqdW83dkwwZEtMOWRiZnV5TmkySGF0emREZWZTOUN6UXhMU1pWQVlnRlI5S3JwVHNoVWh4cmZJS3FLTVZqb1BhT09KOVBobzR4clpvSHNidUhEZHV5YXcwckZSWGVrK3RKK2g5eXRTMTk0OXIvc3V2T3orU0o4dkw2NTZScVZDMm1HeFhhTHRtWFp2emF1eVNaTHk1dHlZV3ZpVm5sYmFzWFRydEszU1dMS1B2ZS9YNDNyWFpXMmEvem43bTE2eVUwdXFQMThmQnI1aSttMUpHL3NucFZqT2xVMVp0eVhMcVRUYkl1cVhSdDRUcjYvcjJZdlMwdVhweDFic29xVXZ4dTlhaENERE14RFdpcE1hNlNmR3Ryc2FyM3lINWt0cVhhM3pkVmZCL1JMZWtzNWxWSndWdmRHUnZHZ003Mm5JSStPdTBiSHNXazRMM1k3OVhxVWNMMmxmVFAyTmlTUWRrcTc5MGJJcjVWWjJmWHpKbVhmSGNaMi9NcjE0N1RJaDc4S2F4cHJwRXhFZGExMGp2SktseStQRlJubUN5M0YyR05Gem81T2lPOUtRUnc4ZkltRUVHdUtRNCtscDUwZVVRUXBkVzZCOXhwcHFJT1NTWEdoTlExMHZUdHVKQ25XdHViR21vZlpCajdIUWpudkgxblU2elJsYUlITm1BOURXOTlmbi82cFdGanNXdEVuaCtsbUMxWFg5ek1NMlZDOGlkci83NndGMURaNjdLc2tlRVY1cHpIUkRhSWluUVJjNUdNdjhlbU9mQmNiWDE4STdUa0pkc2pkdVpnYzJpVVJYU0RkdU1iTzd6cHFLa05JOERzK05aZDk2REsxUlJFcjc1eFpRbTRIR2w0VHNRQmNZQWlLalJIeWxsdmR4N2Q4Yjh5MUVweGhlNEgvNHRpa2hoQkJDWGdxSGlvUVFCelFaaEJCQ1hnNWRJWGtVYk5BSHdzcWV6NWwxelB0TENDR0VIQWJkTGlHRUVFSUlJZGVHTVRzaHBBT2FrQU5nSlJOQ0NDRlQrQ2VSWitMWlBxVmpJejFMNVNEUmM1aFlQNzJpMFJmbXlVMnd0dkFqL1p4WWw5Nk56NlRqdDdLZFh5YnVnOUlsT3JMOWlLY1FyY0tOdW5NZU9VWE9vdTJtV21ZWUpDenZuSGJkSnhYWlNmVjBGaVBoYVhKYTA1OS9tKzlQWGRlYjM2MmJNVW9wcnFPNDk4VGRhdkF4c3dGRVpZOXMwTDNYcCtUUFFKb3lzMjR0Wmc0WUQ3eXU4dGxJWER5cHQzalZWYWFHSWtHeWJKNkxLd29aVzF1OTk3VUU4bmg1cWxPNXozVnQyNy8wUlFRcGovUDZkb0ZXRVE1dmorMUZSTnBwSkowSHI4eG9uL0o4clNFU20wampKa2VVWUFiU2VaOVcrejBsdnZJUmk2cEFOMTdhTlZ0MmYrRGN3K3BNaXJPbTU0M0tQc0p1ellvayttTysrbXZ3KytPNWtYdkpLVjFmRmpTamN4RktMS2pxUk1aaXZaeHI4d2k1QzdPczNWVkFaNmRIeUxvdFR3d2pJc01EYnhqaGRUUElNQ0FheXREbHplY0tCcURYWVBVTWFkbkd5SzI0MEpwR2RFSWpwelJuVFFkMWd0NDVKS1RldkRJbjAvcHFxblU4R3d2RTMwVU5iWXl0THBCT2pjMTdaMHlzbGlYTmZHckgwVEtjOFd3QmV2MVorSDJ4Vm41dnZISHpxREVOYitDeEhCMWpSeDQvWTl2NHkraGJWWHZDK3Roc1JsMlBmOGI3QVhqdE0za0VjQXluQlhIWko1ZnVtSmlBUTIzVjkyZjVjRXJYYUgrUEN6OTY1OTJ0d1ZnU3pqOThjUFo1TWRVenpDYVhJaHZuRHI2dFVuQitHN1NndzNraE00TDZNeWExQ0xrRld1YzRzZE5rNDdlVzUvNzllNFRGczI1Y2R1WkRvamdyV295Z2VjTkpEYk5MbkRYaUxrYmV1UEw4ZlIyaFFNZjc4Tlc5bFByVWZocVppQ1orNnRYSSt2ZGY4dVlmL1Q1WTlrcFQyc3JySmEvK3Z5NXFFU2FpODZiUDFiOHRIYjRHZVVadjBuUk9MTXZ1aGVaQjhncDhZZ0JYSElWVVpWcDFvWnkxZHJ1OUIvdXJpbDlucTdkRzVwS085WTEzd2R0L3I5QnV2Wk1MODhxY3ZZMndwUDJMM3EySG9UcW8zZTFXWmZhL0NPdG1sZzlBNzJlci9WcXlOUm5vRFcrTm02d1JyYUdqYm5TdGdIcDVtTEhVWmRCa0N6SmJhVWU0MzQvT3VqbHF4NWR6NHZIVjMyKzA1bk5BYnpUYWR3NXNYQnQ1bW02dkx1MDZ6L0NOYloyL3NjMCtSeExISXBISWFxLzE5LzlwRjIwdC80OVliMjhaQ0NFeXFCV2JZZFZtOUU3dmlPVUtJNW5YNEhYOXFaRWVsVFd6NFk1YTBwQWRzNnlETHUwZVdNR05kdCtQTmtSU3FHZjlwckVrdzdpcUJ6NWhUVVBUZ1U1WHdjWHFyZlBXK0JCMVVIVVpZclA1TVYzMU9XMXlhWldubm9ocVRVeVp4ZkdzYXRqMUlvM3ZVN3BXejZwblBvdHhmQmJlOFVFVXhLMlNDZlEySXVzbWpaZ2FJei8wZExyb2RLMjFQT2psaGJId0VjTUJhL2d2cFl2b09HcEZneWFEdkpxOCtRY09tNlcreGI1RWhtQU5RWVhqUjR4UmFoNi9kakg3RWFIUmFXL0k1OFhVRjBhcmQ2ZGVnWlhPbmN3WlJoR2lPSTg3V2E2NzU5WVU0emNocjZkbEE5Zm5KNnFPVWs5Mm40ZGxxVVpHUUloVmJPanIvc3BucTlhajExc0M1eWJkOFpEREhWRkdQUzNTenZXdmxzeW9wN0w2djNaVy85M0tleWpSUU9MMWdQMGNNUlhmMzZqdDBJYnFtdExXZEhmc3hoYWovYS9UYUw5Yk9YM0hyWE96OER5Qk5ZT1ZqcDVuTFh3bkJuREV2ZkxxK0xUbktwdjg2TU1ueHlweGJzZzhGcDhQdk04THFmTjhlUC94SS9IYTcvbGw5anlqVklwMVlCenFYU3gzYWZNU1pWQWFLWjAxQUc0dENmUSthaFY0Y3FKVXV0R3VNWGVvZ3AxZmtoWDVkd2FHcitzYUQ2Z21FTDB4cXpmZjFWZUtqdlNOZldNVHFTN0xxSTVyeUpzN1V0SGFqSDdkaEJBYlQzUWRqWEE4RDFaRXZZOWxDUmdqSE1qSXVISjB2cGtVOEpqblBMazJWN2kvdlVhenB2VXVXa2tNdDBpQXF4cTZrOHFWMTM4b0V4emRmVzNFdGZXT2Y5R29MM0toV29RcFJZTktPZFlUVWxsSWg4NmRmaWV5TmdjVFBrZG9QMHRTek9QWElOcGl2TmRodmZick9ZNmV0L0xRTlI1RWI2TzNwaUY1SThmUmM2ODhFeFRJZWErc25pV2VtelB5Y3IyM3pVcnY2WjRqSTVWV1Bwb01CNnkwUnhKOTFNQmFZU2NrRE9KTXFzWm1qUi9RZHRrVGpqek9SQjRaUDczVWVQeVR5TE80MktEajB1TWdkS1ZaMndhamtTK0Q3MDZOMk4yRzNJQnNISGUwTGFLQTdqSTJzRzZ0Ujh1c0tmd0NISjluQTlZTElOSG94eHZhU3F0V2RUcmdwVEVwNnk0UlVyc3ppT3J3UG80a1ZJVDZXWjVQMmhKeGRpanlkZmU0Mlovank4TFYrUHQyUy8rcU5XdmtQSHFoRER6QWJqeTZncVNYVTIwZGRSLzV2WDN4VVMzK3BWUmM0ZzhlbWIyMmRKd2QyNTZQeWw3SktJRGROc1ZvZHYycWdlVXhaZENpaU0xTHFia3FTMVdzZld5WHEyUWpvcnRXZmtzSElnTnB4Mm1Bcmp0d2Q2ZG1PWGswdjV3M1Y1TVcwb3VnWGpPVndiaXptVXh0eHIyMnhOTWVSdHV0bHU2V3JobTJZK0tUQzZxSkVjYURNMDJqOTdMeTVwKzFFOWorMXJJcjdibFVhZFl2cTRKRjJoOG9iWjN2NElpWXpaS042cjZESC9MTVJXaCtLWC8rSDd2TzMxcUt4RkU1SUZOSzU5ZE1DRGtIeTdJZVBSck9uYnBuTG1tOGJmUzN3K3VXcnhSQ0xNZXVjTk9za0NBRnpwTnppUm9vdEEvVmVNSktUYmNIdGo5eUdtZXNhVmlpblpNSFdUbTQyWDFMK0wxWnEwNkc4THVzYWFRa3ptY05sZDJRV2E4amZmTUlhUGZadlAvNkhPSHZyM2xHVlZ6TEFkSmJibW5FRExEWDVZMnNKYlQ4WHNzeG94VVRBS3ZoZW04NE9aZFJBMzBOZEFtNk50OHZBTFhYbzZLcWtTdVJTSmxtUlQ2MC9ja2VwMDRNeFlrUGJSNFQ3VU8xa05ianMwbElqK2hpbnlLSGNFQWpROWMwckRIWDdaRXVlS1EvbURtbGNISDRZdXJWc1hwMTdZVm5SYXRrS3NWNW5Ed1kzdlE1bk9UZ3ZXcUw4WHNjaTdNNG9sSmEwMFJTT0x2Q1hTSElVeEZQNkdUdmlGai9QRVNhT2F6WDBVYUtDVGhPMnBpbVlwUXRHWDNqK3N2VS8xTHFDRTkyeHZXWHp2Tktscno4a1lTcUNaYTNlTnJOZTR5QS9PVzYzdmJvU1Y4VXkrQjVOS0NYQ2UzNDF0ejllbnZqUFVkN21CMUhmT3pXZC9xcUpiZTRUNkNGQUkrMWpvL1UvUWZ2STFoSU91OVRMSkxsS2twYUoxL1IxZGd6cXdrZlJjOVZtYjIzMXp3UUFHOGw4NGI0MmRieHlBMXlSa1JmYjR1YUNDSGpaaFE4UzdVelIzQzBZMDRZWDJHd2p1NVBORkFhYWJET05JNkVUR1BXREVCUEhxZnNqUzlFNTUxbXpHT2QyY20xZ01DNmJ2U3RCeXQ5aWxleHBsSU5TclU1d256SUhaRGlaelM5OU5zNnJoR1p2eHMwYzBvSXVSdVQzSzk3U2VlRmpJNUtMRWF1V0IwNTFjQnBEWEpuZW1LNzRrbThUc2NPUXg3QXFPYjh5dGZQUms5djFGU1B5THdKdnBoNlYxcGJORmh2Y2srMkhvam83RWc3SEd2ZXp4UFJhSFZaZkVYb0tRcDVBS2QyaUp0aFJWT3RUdFJadjVicW5ra1AxRXlQM2ZFTHJVUU5yUlJaa1ZtU3ZCcUM2TEIwSXpJc25aR2xpanFmVkM3a1RyYnlhNERsOWU2RVc2eFcxcnB1K1VqZUs5bjgzbi90Y1Mybk5BcmNIM0hjMXZ4cVRjd0tKRjRiYUFSR2VXWWQ1LzA1RjVHTVdUbTY3VXRhdmx4ZENQTGc5LzRCOFpHOXhyS1ZyZlRyUEwzZWNVSkhLS3QvTHoxejQ3V2xDMldBVEpSUCsvNzRzK1VGMU8yTHFISmIybjI5cnZwdGZkMnhLR1ZwWGQrb3EyLzFhN2xmdG43YjJ0SkhXeHkwUDgvMHZFZDJOcS85aXJJWWtYSFVMM0dMRy9EL2FXTmwzL3BhZVoybFdDU2tPR2RHY1pwdXhCK052Wjgra1BHZnd5Y2dsNUozZjFnSnR6OExsbndEbWtmeEVYVTdyMTBGMUE4KzVpaTMwbmdJekR0ZUUvVEcrc2FlVzZ4K2FSMXZ5ZEprZU10U241L2xFMXRsaU14RnRNdTV2MnZJZFczOVhCM2o3Q09jT2o1cTY3QTJ1dHBIVC9zamt0UnQ3cXljVCtCeFFrZ0xUODlaOThyMUxEUXEyNXBocU5OSnZ5V0w0SWtFejR4d0w0ODEzTE1xRDNWTGExbGFQcTh1YndqaHlST1JiYUYxSXJxeWUyUDFJWStjRkpSbGhWZEprVzBaYkVJT0pUaUhzc3VEakg4N2lZaUtxbmY3RE0vMWV1ZStVYWVwNmRpT1UyUDg2L1B2ZndVOTlhRmNUUndaZ1FUMEpkUzFydXk0SE5UZ1dtdVYwcmwyNkhUMmpLbW5SWTJNMWV1ZVVKenB0TmxuamljdWdxOEw0ZWZKWEhyZGp0V1J2YnFKaVdjbUhMV1JJMjhydXFMaEhSYTFaSkVQV2lXaW9Uajc0S1dJeGpnNTIzSlR3cVlpT0IxQm1taTJKVlhITzBScnFxeDgzaldOZFpyWHR2Y1J2dUtsbGNjWFU1K0lNVmRGanNNN2ljYmc1V1h3aHIrT2xrMm9senhRZWZkaHVjS1JEVjZURngyT2p0QjlJaGRhYWJoUVVacmNxZzlwNjZLUzhiQ2FwclZlU2JhNHpCZDZFMGIwRWw4Z3NVMWRvQktVUXdZV3ZWN3ZnZzIzYmpPWE5ZcWpJNDZ6L09Lb0oyYjYwNCs2emEyWE9jYjN5NUdOMDdZcXorREk2d2pxVWx4RTdjNDJ6ejU5VDViOU0xR1M3TjF4bjAzcE00MVhiRXRXMzd6YXdGOEtibWJISjNCQTlRaG0xVEFoQk1QZjErd256ZGgvQ1hrZkpYaHV3VE50Unh2emNqUTN4UFZETW9KUlU0QTlocW8xeHhCcDU1WlJKV1FxRDF6VDhISlkzNHZPaGZldWFVUm1jQUtHS2FyaWd2VEV6V2RlVnUvcVVqYlM1TWJ2bzZDckpLU0Rvd3hZNjlrZjBzUlRUZTJaWHl6ZFhhRHRKMDhqSExOOU1tWjBEeGFGR1U4OWs1ZlQwWmc4bzJLMjJSTjRlY1dETDZheWFaNkd0K3JyVjlrblJzcTFxbWplMDlBSzRYbmx2OWluNm1mU0VaV3Q0emtkZXBzSnVSWVRkeGJ4cXJiT2EwVnJ4UjFTL3g3RFNLbFdEYlIwT2grNzJYMk9wanIrZC9TbzFlaFJMNmQ2anRjZys5SWdNc3B2SG0ycnAySjRtSklHbEtXcEllRVA2eU02UFVPc3ZZYmJncnljV3FkUENUZGNsczZuMHpLVllYK0RibzNrcitTOXY4RmZVUDF0T25sMXZPZEdlNkxadWpTU3JPS1FjU1NPaHVCOUV3Vyt6QkgxTWFOalJ5MnNjajFWQTRmZDIxcHkzbDVuK1h3Vi9EZU1LS3QwYTJIYk1yVy9TdnlyUXk3S1RDTjZOUU05c2l4bjlQdVd6dDY2OWppUk9mZjEyOHpUUG5wZVhrSXRud1MvWHliTzMzN3lMZHZxUzZwTDMxblNGRTNwdHk5dGZtNTBYNE5vM1dzandiMm45c3RNbFN4TnB4Y3BvS3hsZDRwZUdsTUJkRWJEQ0FsdDBzd0lSYXlyVnIrY0twV3gyRFhzdmFTVXpyQWNveW1kNTBlQ2pudGJ0YS8xY1hSMmFLYXZzMlNPaWlkL1pkUmZKLzA5SzUrdjR5b3B6ckpMSjlkMXJkdk9YeDhyb3N3QzZDYUU5R0ZaeUZhdmxXUVVRSmNtZTZTVkhobnF2SmFJcTI0UmNmRkp5V00xcHVLUUw4V3lraHlyYkQxdXlXcW9kSUhQNU1qcFdLbGRieWVzdCtlMC9EU2VaQnFSTlEydmpCNmNNd0RyU2NIdEgzNVYxakM0S1dndElBSzZ3T0tSRjlXSjZrTFNWZkxyeWRMZHN4TDF4RlQxMnozUnVrLy9aL3hlb0R6K0lNRFplc1g4U0FrS3FMc1ZYbVd3RE1rb1E2bDByMTBlQ2pwT0txbGROMGc0U1FaaXhkRjFPdklNdkM0UEdSZTIwcjRRYjFkQzExZVNNMTBVN2ZaR2ZGc3RseGpVbGV5T2FjbG9VRmM1VlduN3NKaUdFSkZpL0Y2VDljT1Jad2pxMzlJd1h2dHR5VVpYdTIrRE44NUNLbmxOejhEdklZQXZwcjY0aHU1Q0FZKzFqZ2ZwZmNEcThnU2FmOVNZSStsN1paTUx3cHY0YUR6eml1Z0U5bU5CTDVCOTVrU2VFUlBldGdtaFFRQjZIS21JMS9lMzNqYVBETVc5eHM4M0hYM01MWXdNUEVZMjFDZ2pvL1RPckxmdmE5SEI1NUVWRXl2am41Y2FNbkJPbjcvS3FhUVpOOWlheVR5eVVZM1dGWkhYVzRhSXZSb2h1eWN0a0YxWnlXbDZOKzFCdFdMOHJzVlU1M2Y2TGhkU2ptckhsaC96ektKWk54UWw4Q0NjbTZLckx1cy9uakcvL0tkNTU4YWxTRmNicmVIM2h1elBhUzk5bkRIVGZwek9uMWdxY3AvSHRvMjl4OXEydjJmMk1VTElINVJ3ZVVpMFpVVjQ5SExrOHJDUnZvY3JUTWVpUnBPQkdabk9pRG5DTXpyUnFQUUdRM3pEbGVwbmhpNXRQaU1RQlU2L25HUG5IRWJQUG5wY1JISCtyckZXWnJVWjM2ejhuZ2xET0VJNm1MUk1vcDdYbG85cTg4eU8vV1ZtTk1haEJpSEhjdWhVeEVkNEJ1MHBWeWpKR1hqRGlGNWUyY2FqZ1FUNlFxcDI3RVdWYmIrWXlvanIya2lOSFowN0NzNHhJZE5sWnp3eU13eHA5Z3E5bUhvRHU4UXVSTWdVVG5UVVBhcEh2SmJrUTNJT2dVV1BEVnFVaFV6MU42eWlLeENMWElPV0IxMnlHTGxQMDZpbERjbEJyZElVOUo2MGZsdDU3ZXZYYW53dk5WS1hML0swYUd5SHBoMlI3OG1VNy8rU2I4ckphMXRiUVR6MktzTzFiaHZhNDJmbzlIUVNOTDJsQTlSZEROR1g2M3NqZmQ1YXBpUC9SNlcyQVhqVVk2eGxKdVZMcWRMVnR1YVFmaXpFei9XMVhrNzlTWHZrelk0MkxtK2ZtcTNqclhqcnRxcFRvSXAzRnUwVFBoWXcvVzlYK3JSdmRFZitYUC93MklhNjN4N0I2UFlxeFJWU1BSUkhHVFM3N1NsVEo1Q3Z5OVh2S3E5M3FOWXl6dHB2WjlXVXFrdHRSbUpHdFZsUmg5YWN6NGltcmt2djFVZnplL3NRVWdadkE2L0wweG8zZU11Q29MWGdlbTVKMDFTYXY5ZXgwZnFycXFVUmdkVmZYeTJDMWtYNk9wMHN6U0pEWjB2MytJOFE4Z2Mwd21ubHJhM1dLUDhaN2Ftei9mY2xweEptWUYybzVrNnR5a0VxYjFZRm43bWtnV0NWNzkzQjZmUHh0cGtSdzJWOU1xMHRtNkVVdVRVSHJtbnNKaDBja3hHZGN5cm5Nc0pBUlZrcXI3WGVqMWFtY3YvVUlFSEpwejVZdVB5TEdPSmMvWnVVODM0OFQwYjBNbXFHQmRYVit1MTF0eHJXVEFQRHQ4R2dqVVpyd05yWWhiSE5jVVRIU1MxVG1TcVpVY08xZGhGc0U4TnBkZCtqWnQ5SFRGZDRzSHpFSTZFenZCMGhzNXhUMytNQ3k3QW82V1ZabS9SWDlpVWlFNTA3UzZ0ODJxS0dsZ2VrZHdpdmpSYlg1eGltZk1qR09lbVpsWmRVbXYxaTZzeFJPSmtEZXI4NjcrdUwrb21MSXlleXlFMWhnM2dsUGZaeVhKTlpMTklaMWp2YnArdkpWeFByV21aYTRETzlJRDB3R2N4ai9SSzZNS3U4SkJHeW1lZ1RZeHExTWN6SzhUanlQT3lvUm5EV0luL3JOM3B1aE81QUVuZVJSbHpEOEVKZEZPOTErbDlYK08yVlJkSGdmMTJobjk0NHdWTVAwYmJDQVpGTlpMVTZUdTVxTWo3ZDIrVE9jcGN6Mms2ZnJiQmxadU04OGx2TGo2Nit6aGczT1J2VkM0YzN5QU1RNUN6ZU91WSs3cnFQK0ZJcU9nS0wwTjlQT2FkRFNBVE5TbzJZdFlua085Tm5NMTRnaEV6aDJLbUlQdGt6Z3oxQ3BuUEJOUTFreVgyMHpxRXllblMwbmhnZE1XZm1lRHpZYS92Y3R0Qytuck5tWDF0eDlzaTdQMk9tVjlKeGhIdUs2cUhySks5bjVCdUhvNS9SUmpyb1c2ZXVRU0pSMVZHclpqTmhzeUIzSm1TV0ozWFExdnd6K3hrSlVUY2NyVEUxR2xuUFUxbHNzMDVLNTNGdEt1RkZOOEorTWZVUGJKblBZRkRFck8wS2tWYkhrYnlub1JrQ2JSSlBRcnZnc2ovOTk3Znp3ajMxYzdlQkVCRzRSTWU0R2Rva3UrV3ZCdFN4WlNyQzZ3Q0NqRG1NZU95bUpiYzB6aG5IZHlJcVdkOWRYRk5WUGttM0Z1VVY0ZnhPYUNPOWRBNEY3ZXlJUXhKYVhpbU44NVl1SzU5VWxuVTVpNm1ocHdWdFUwV3VVNWZXTCtVRWVvMkU5czZrbHZhcC9tbHRhL0xxNWRUTmVjdE9XVVJhV2V2bDFKK0h1T3ZVS2EwMWJJL2tSa3BKWGd3MGdPN1JOYVBIYW1XSzZxcnlOU2NaYXJ1dHBBdGRiclN1MGV1ZWRTLzJNdXVYNVlwNC9QZDYxMVc2M3d6K2s2NXNoUlZubWRibmZpUzI2MkhkaTQvakhLMDZhT1RjcThPeVFiMjZqbkNLeUhXVTltbmg5Nzd2eE91amxsR3FydzUvL1kvalM2cC8wcGFwTDUxNnJqZnFHNksrc05WZnZSTlc5ZmxhTnRKSGFrcjdmS255UzVPRzZ5VGFjVkdtVWFRVzJ2QU5yVW9oNjBhODVQSlhWVkMwakMyaEJuWDNQZVU5N2RPWkZlTzB4cnVXYms5L1hCKzM4a2Z6SUdWSm9FNXdMaUw5eGtQYmtZdDFkZGk0NU9kTHF1dDB5L0hsdDlkKzdZL3ZZN3J0OWRkbHdIWFZYQ2srSStRNm9MMTRjZVZXZWtsMk1jNXJ2eVVkVVcvazFmbEtWMjhSZGNkV3Vvak85Zm0xN09JOGorajBoZ1NvVzVKMFJsMWFSQ2U1RDJqYmE2VkQyOGFJb1RjaFF4ZzFsOWdyUTVKcFJUMUpWNjFOY0pTaSt6QlQ5d2htamZldGRDMW51aDdoQW5XK081NGF4OEdnNXUrbm9OYkhpNTFlVEpjRTNkYkVYYTcrVFlydXJHcFpwN0x3eE5sSDlLem82RjZibFczSjZIRjVWaXV5eGg0TTRRSllVMmRhZXUwM2I4cTFhYm1BMFNFQ2NzODlSdVlsOUZRRE90eVB5RjB6TXNKcHlVWWprc2ZqQ1Q3V3NFOWREazlmV2o4L3RGNC9SVGZudHVhUTEybkl5NGtZOWRwdkcwUEdYditrcmFkNGl2NUtFemtpdHJPT3ZRRHN4VlR5REViT3lxeWd3OVh4amdPalBvdmNITjdFMTJBOUo3RCtQY2EyNXFIUzRtV29md2ZMWlBhVksxenZpZlJPZmpaNVJyMWE4LzZYcHRXOHZSZlNNOUo4SXRwTTFKQSs1VjB1SEhsY1kzMWhaWkRwaUt5OHpkQXhTbWJVV3RRUEFhUmpCZ1REaEl4cVl4RVpQVHFDOTZjcmZURlRuTStWU2plemJmV1c0V2dadlRyQU1rUm1pcnU3VXRVdkhHL05sZWx2MkkwSWZrYmNHK1Noc0ZaNmJ4a3lrSGRVbkY4OU1STUtNQ29aRDJGMDZ5NmpidGx0bVRyd3ZTQ2NlWjlOM3Z3bHQ2MDN0VGhDN2tEVUZZN3lJS05zQWg5eXVoRnZDVDlldnJ4Q0dveVllcXZiMXF5cFhyWmZNb3lyemlVT1h0UDRNOGx3aVg1ejlKcEczN3BhUEsrVFlVM0lheUQ3RzhYTVo5OW1oV1d0dTF3L3pIMUhkME1YU1VpQW85d015dHVteGdGNjdQS3NWYk02L3hWdUczMEF1U091MVgzTFhzZjJXaUZrSEE3bk12elpnc1FtUGh6R1l5cDhNZldKakhoaElhakdTbnRxWDlTQ0NIVDF0elR5Q051bmxVKzZ2MGFkUm9pc2FiV3Q3RHorVnF6QlFwM3V3RHFMemt0SjZjZTluRG9qZjgvV2ZWYWFuaHZaNmtRdFE2N3A4bnE3VnNlMXlsL3JOdXBobytyejQrL09xWjdXaGw1dnEvenJ2S1VoVzlhTU8yYnIzQXM0S01aN0RrYi9SYlpHUTAzSEpnTnlIUEVXc2ozTGxhemZyeFBWeC9OT3lxK2tYTW1VUy9UelphQ3pHaGxxK3k4eDB0QVo0OHc3bEYrdFhxSmwrclRuYjMxS3ZsREorZmxTcXVZZWM5V0dJZzgvSUNHOEI2MmZ6MlZrWC9MSzB1SVJPcmxSbU1NblIxVzdINzJxZHVwZjJ2ZVlsMUY3MmdwcWo2STZySUYvTWZMZ2NYVmJqaVpyZmJ3MStyVGlLVUZGVWxScHc0WlNDYkRDSnEvSktJMWp5aEFyeTZmYm9tdlhsTEc3SHVMMTVyRXZudmlsVlA5cTZRdVFScE5wamZPVGttNTl6SXZWaVJEZDF1UjNmZlpqMjlYeC8vYThsRDRMMTFzKy85WFMyckxhWGk4MzYzVzV6cUw4VHBWT0ZLdHNoQkNKbHN0SExKdVVibVF2SE9yYkRUM3BJRjJYby9laXZjRmRpNTR3d2lOdi9YZE9iZmVzNmVwcDZLUENEM0l2MnVHVG5oNGRrNjNsalJxS3Qvb2syeU01alZFTmZBQWUwZXQrZy9UamhTbDk3YWdJSzZJYm1jK1RUdWVmTkFWeDZxczhwWlV1Yi83NW5aUXF2L2xUbmI4bzkyOGJPYS9IekxKMk9lQm9oVFlhU0kyM1pFVjZVcTB6QytlOU1rZWpsUUVwbXphYkVaejVKUXRLbHhvbWk4d2hhaVJTUno0MGR1MkJIWGNhYXgvUk82eW84MGNqSE0yL1duWWQ4UUczUmx0T2FmMU9WUjdhNDh1QjNKTGRiYTdEN05WeFU5Z0tOZ1BTRFJMRTE4RjZuY1lRamFxMlRGODBOQ0lFNFYrSkVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUWdQeS8vLzRQOVBMelAvL0RkMWh2QWJMclI4M2czVDhpUlZpblQybFlVV0pvMjhVRUM0WHNtZGV6RVV0MFJ4MXlBTnFONVk0Nzh6bWdidEhiYTIxdTRyR1p4emFkNk41WmlOV3o4dVRxc0ZYYm1wd2xUYVJXdlZ0RVM3cU9jTVNDenZWV1VQVVhJY3ZJUFVXMU1tQllPYXd2cnRTcFc5SmJteEVoVWk4Umw2eUo3dFNveWFFLytrSHR2dFkyZTVJUTlMaGNpSzJHSDUxbDh4dnRHeHJSTDZGYVhxL1ZxTFNHT3lxYTlUVG8xczdXRXpwRTAzWGtsTW9FbmJLeU5NWm9MQnpuTTNZcWwxQkIydjB3emZlK2F5bFNYOHFLcmRDL0loWXZTeDdXbjdYenlVaTNwTzNaVjIvR0NOaGJxek9jSXJJdFlpdGR2NjY2anpSRFErZHRYTDZFcW43NU5HODdxdWdKL3orTjc4dXBrUmg5RmpNRHFiNDRZaStyeCsvbWRoRjJ6WGh2KzVwRitYUGdLNlBTbFZDZEtZbkYxbzVMTWlyWmRaRTA2cUdYMXB4bmpSSVBEU1BDb1A2bUo0WTdnMWxsUWJiNnR2SWNNZUsxN0hHdWpzcGxrOGMybHQzS2xTVFVSaTdwYmRBaHQxMkR2cklSUXJaWVBRaXhsTmJJd3dweGFqbGFwSVBvdHJpYko3d0VSN2k4MFJ3eGpFQWI5cExHZHJ0NGg2VExPeDlybkZTRGpKdFFYZEV4Mm9ocEFVS0cwektpRDEvVE1JT2NqODVEYkgvMCtsQ0hoVHJISktSSG5lUUVxbm5YM2ZIUVhINkdVdFdwdlRNUmlPeFd2cFpPSlBUUnlvQmViekowOW9ET29HbDR5azg2OEU3dWttZGhqWmZxNDZrNkg0MlhpZHZ2OU15eWU5Rjhnc2MzUnJFaVZwSllFUmRrUk4rbzEwZFZFNG9HVUVCb3o2WkVYQ0NPUzRrclJvMUFjME5HZlZ3Ni8yclF3U1lyYkFmZk5pV0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlSRC9KSElQUE51TUxXL1JJN3RZdHRJNXQ2WW9EZEd0M1ZtUTQxT0picDhHeXM2dGZLVy9LS2ZVR2NHSWJCT0k3cTcyVnF4ZGFnYlpzNVpxYnpyUHppUVRpeDhndXAySFZWcHBENWI4T1Z5MmgzY3k2bDAvbFdUZmsxS3RSbXNUdVR0ZW1TTWFicW4rVk9yTUxKckhVS1ZWMnRyYjQ5c0Q1cy94b3FRcmtGZEVnNTRrbHNqNjdkbW9jQnFScnVnSkpCNkoxbmFVWkV0U3RUdExKelRaMW5HcC9lNExrVmVGWFBwQ1hoMlJaTzgxeUMxNy9mOWNhY0xSK2pkb3I4VGp2YjJyYXorOUZQUEVoczFFaW5USVo4NW0rWFJVeGpvL1l0dnIvTC9uNjl3L094eHV2N2dJbC9helBXTCt1c3E2cjdYTFVoL2RVcGVuWFNwbnk2cnlSdTlQNlR3ZlRZdmswMndtUXJDL2RyWHpCTW9jMWFjMCtVTHFMT1ZMc295eXo5UCttcW1oMy9pUzZsL1pzQTMweFh4enNMWkJqUGhSQ1dRTW8vM09EVmxTN0o2TWNxeUxVQ3FWMVphZFJaQXJ1ZlpkV05Vb0I5cHRwWFRlcnE0TU5iK25xLzRoL1M0Tms1WWwrWldzemJsMG9UQ2lteG4rQnJXRnN5ZUxXdjdLa3VrcDI4ZzZyR1czMGlBKzRHUFRsZmlvR09PRjlmbmZyOEMzOCt4THZ6Mnkvd3ByRnZQclpkaGVuUlNONmpvc3Uwd0k4UUJFc0NhVzYxOTJiLzV2a25VWFVBNmkzNHJva2xHR091OHR3b0Rab0pVZ3U0UStWemdyakNoQVdieU54eHArcEFIbjZmS3VBeExDTGFDRzFycS9HVHhuR2JaV0dRZzVISFE4MU5OWU8vSit2MXJhbm45VHY2ajVuZGhJK3lLWk5rREpPNVJSYXhvaklrcEpma1RuQUxSUFBtWHZuTGdkeUJUamVrcmdlcGNlVTR6emVwbDh2eE1nUzVzeHRhNHZLNytSVUM0WmVTMlhXSlI4a2k2ckJ6Q0VBL0ZNMDlWWVUwZThHY2RobXo0OXo1S3ZkOHEzMVlFTHFQT2xiYVZWZFd0YTU1RUlybVZEdGU2S1JCdFpPWjRVV2VqMVJlYWxIb3QyWTYwd2lQYjNzbVNqUTlTaE1SS3BwOUtXVWRnZWlJVTNua0FOK3dydm1vWjMxSXNVL2JVaHJIYS90T1ZmYTNEMlF2akZWRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFBcEgvOTkvL2dkN2IvdWQvK0E3cnFYaGZMMGQzVlBYdTVBU3F1alRvRmpvZUduV0piR0xyUFU1dUNycHRCRys0bjhoV1dJWVlaRk1MajZxSVdVYUxmNnl0bUxRZFcvbit6OEdJTGUyaU1rZDIzTTZHS3U2MFVsMW5zWFMzbEt6VDlRUVMrU1BoZUNPSGhsR1hOTDlJbGJlT2E3SklIS2dlMGIyajFtUlZ6cllaYlB0U3J2SVZROWRlMXZaSTZiS05vL0sxOG83d2VwWXZDTkp2SWgxNTBPMjNrRDAzazVDM2w5N0JaL3Y2MWh1OS85bkZNUExGdUR6RkwyVlFYbDc5L3h6Zk9JWkJrd3FpWEltcjFOUFZ5L2VMOXBYSE5Wb2ZXdThRR3VsalJaRzM2Yjl3bjdramlGMUc3YlIzYkZKamxRSEkraTFLMWFpMDlKcG8zRVRpZVVhRUJwVXM2eklYaW5INzd2RkYwNk5CWjFkcXZIRkVxekVpc2JsWGh5ZGZWT2VvTXF6enArUWJaRzZwYXpLcFk1TmFlbGJrN2U5YnJvN2pYeXROaW83OVg3WWRUYXV5dEtSaWNnZ2hNWG84UWE4dXhIbzdveXpURXo0K2pKaHhvYlBEaU1qaWpTUS9rbS9KcTdsdFJHYlBOSkMzZ1pObk0ycDZ0dFdlVTZYRGUxdzZSOGgwZWcyMUpUc05rR09JOS9xR0xpVkhybW1nMFZ3QzVLTUd5VnVwZ0FGVHY0U2JqQ0toeHRJdXcwd1hvTk1lYzN0YWhmY3V0elVmZzlWem9xMmJISVRWbUt3YlM4NGh1cXk5NEozNlRvMzhiQXNpcUMyTVRCTjRoNzhSSFY2ZEhwc3Z5U1lDckpoYm9vNjQ4djRab2orWTY3M1dlVUs4ZUF4MXRnL1BEZ21pYXhxMzd6TG9ZenZSUU9MRjhHMVRRZ2doaEx5VXQwU0JIRDBUTXBRVHVoUjdNU0dFa0RPaEh5S0UzQStPOXdraGhCRHlRSzd3VmdRaGhCQkNDQ0dFRUVLR3dpRTNJWVFRUXU3T1A0bmNnOGpHYi9VYjNDVWdvd0c2aDlxc1BRSGRlTGZJNmR4cVp2c1ZFTCtJU0hweWNheUd3QnNlUit1L3pqck53TEhJRG9TU0hBUnIwenp0dHk0cGRaYW9KMStMb2p1U3Z5cHpkYnkrd2EyN1lHMWwxMnVoYzBDbkprdVNJNXdYRytWS1o1SHlWSTdKclJ2Sisxc0dlZlA0b21qS3pmTjYrZkQwNkc0K2wwSUtxRVlGRXVqV3FZLzFTMVgvbGJaTms1SzdaTmRZM3NTVzQrOHJzbzNNbi8rWHozOTZuaEVOb0VlR0ZxeDdQVzdMZm1XSFhJQnMvSzdWVzhkRVlYaWJ3YTVwVkVldkhiay9XbW5MM2ViUG43NWEvci8vV2wrais1TzJDSW5LcGs5RVMyZ051aldLbUhyT1Yxd3RlcHpDNlBZVERPSzdkRVdJMnNwSVhjZGlXZVJMcVJaYUhsUG1KMEgrRnFLUlBxL2FmZWpUa3RZRVR6SFN6ZERSb3RjMklqNnVQcDRUVmpaRlhoMGJXVnZHZnF1bHJLb0cxYi9LdXhFV0lOcVZscCs1WGJSY3Bkc05WVDkvbzNjczRVVTcxRVBNb1dlUTRnWHR2eEVzWCtDMUVTUEs1SlhSWDllNXV2NDZ2dEppbTFhczgvczE3VHBleXArYzJ6cmRSeEdscVh1dFp5cy9WWnEwOHYxU3hLT0VrRjRHUkFMbTZNVmFEdlQ0MzZ6ODNkTGYwbkYvWHc4eTRrS3RxWWhldVpMTW5EQmRtbHRHaGloU0xJc1FtVHFxOHlhbmJxdkRqdWpRWkI3V2ZVZjcxTWhRM2pLVzBlT0VIRUowN0huaW1rWXRmbEV4aEN1dmFVaDFiaGtncitIcG1QZlQxdlhyaWFrNmdGd21xckxYQVJmZ1hEMkdyc2ZlT0szeGRsSFA3SDlwOFhPcjVhRzZ0WkJ0UlBld1pwTHFNaVN3TEhTQkI2SEZUeVBra1RsWTdtamtWREdhVHRJcFRTNjB4cDR2YVR2bzNNa0lPNDBPOTVPaWV3UjFHZXA1S205VVNRUTRmM0VaZHJFTjhseERGVWd0WVhPZHB6aU5CRG9WUVFnTVlyaVZodGRyamhEVldma2JsWDE3UmdVU3JhbUZseG9TZmpHVmtGa3dPaUdFRUhJbE1oMFRJWVNRZDBJWFNBZ2hoQkF5aXlNRExRWjFoQkJDRk9pT0NDR0VFUElvR0hBOEdkNWRRZ2doR3ZRUmhCQkNDTGtyK1gvLy9SOW8wNDUvL29mdnNGNmFrVnV2R0NyUXpWSFhvQnRHamRpRVNLVzE2MUNVeG9VaE81elZ6Q2dpdVFISWpjNkpEVUlDM2Y2d28xUDEyRDZQL0VXSHRDSGF3TXZwWU1UT21qbnR2a3hZVm1uekt0M2Z3NzE3VVVxMTJVclRRdHVIellPMS8rV0lMZnFFNnl4SXEwS3h0dTdUNVY3UngxM2E3NktCUktSSmtUWkQ2ZzNkVDgyeVU3WWRzNzZzdU94Vy9OOVZ1cjIveWFLODM2OFZyWE9tMU5kN3pneHFvcm9OSHlDNnA4cm51WXMwTXdwQTYrRklYZXYwdXM3bVZ5Q1h6Y0RUOWd1cGRkcjkzY3lWWnA4L3htb3lHN0p0Q2JpMktDUDY5eFYxYVRxOTU1YzBWM084aW03Ukx1MHB1eitTdWlHL3V3d0oxSTNJL2x2MVI5ZnZFYU16YjNDbnBZM0dHWjUwM2thVjlDclUwbHNjYURwMmQxbnlPeWlyZWhqdGZWdFc2UXlMRkdOazMrcTljcVNSYWVOZlMvY0ZmVVdYNzVQUzdkblhaTnhXMmw1WXRsUDdMNmpHU25DZlBrWEljL0JFT3FOMTFveUkrTHl5ei9RY1U1aHhRYU1xYjlUMHgxcUc5anNaNlZxeUU1RFdpK1ZnYTUzR2NBQk9SKzdKRlpiSkNER1pNVFk3YzBRd2FVMWpsMXlZK0hEM3V6dXRhYlRxeDl1RzBPdHV6REY4SjJRVlI1cTFNdFFVSTUyMzNTT3kvYzUvVkM5RlowUkg5Q0F2d2wwTzYwWmRZNDlPTWhEdkFKWTNhenk5QS9nWmF4cWFqTWowN012YUREcDhRSWZnbHE0ZXJyU2k4V3JRZVE1eUsvTHFEK2d4TFBCK28yYVlrQjFlUjlTaDRneWlVOE9QSVRvb0kveGlLamtlOWtOQ0NDSHY1UVF2eU0vRUVVSUlJWVFRUXE0SWh5cGtPRmRhcGlPallRMFRRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2gxNEpmVEgwYXlBYnVFMVZlRHMrT1FaNk4rendiOGhWYlJYM2V1NEVXdVNtOG9YRkdiSTg0V0dWRVRuYWVuOXRrMEsyN3ZmbGFlWlgwUmNuM3Rjc1JhK25kK2xzanVtVmQ2N2VsdzlBSitTTnJ5eWluenJZeU1kOEl5Yk80aFRudTJkR3RaMlBnTitIcHByQXdkRXNzSklqUFZZNHh1eFA3dmxxVVYvOXY1VDF5UDhnakl1ZE95eFVaVDVncUhidHR0d1VCc2tmUWZjRmJTdk9ucktGMmhaK05HM0xaU3ZGZGRWNlZ3YzVwWFdYOVpWWDVydVpRdiszZmI5VnlSTWgrdFMzNVNaSFZiWkJ2U3F2TzBjbUk5RTFiaDRFNVkzV083VGk2YmJlbWExZzBGbGxXOFd4eldvNjBVNjE4S1dIUkx1TGpTMUIyTGFlbEF6MFBZQTZMVmduVzdhN0hKVmdoajJjb0JvWVJycFpoVlhYcXQ4aTlNdDdMK0hGdXV3RzJkRnI1UEdWWW4xL0xpdG9RdngvV3VtT3FZcHZmby9yWTVpZldxU1hMMHBOd3R2NXlxdjdGVkk4ZHRpak85SVFRQk05TVNscWxIZWtqMFJGM0VzNTdRV2VNR0FNNEdCazRqUm91MU1lVGNuNUpFd2svMERKSWFUUzVhQnhOcmtsc0tzRStydVZQamZUUnRzTndpM1FUR1E4aE1udWNRODNvZVM1QUpocmtTTGo3NVZYWE5FYlBmUTgwVkR2L3E4aGU1dC95T3FOMHZQNWhCeUQ3c2ZRMmIzMCtNck9naFJuUkh0RTdPN3MrWjkzTmtlRW1LaHU5UG5JUTNqaUxIRSt2aTBoQS90NDFEUXVPeGVDWjd3UWVsMlJyNmJ3K1l2UlVCQ0tMSm1aRmRDNkZsWGdhMnJJL05KMGwyR21wLzlaaE5HcU9hWDVKR0VlRFFjWkxLZm5EQ0hTNEh3bGxveUhOWmJEbXV0RkFBbDNVZVJGODI1U1EyVEFpSVlRUWdMY1p5eE91bDE5T0pZUVE4bkxvQ2draGhIQ2VqaEJDQ0NHRWtBQ01vd2toaEpDWFFLZFBDQ0dFRUVJSUlZUVFIL3hpNnRYeHZsWWUyY2h0TUo1ZHVRNG9UbHlSdGRXT2xnZjRDc0xwOVVIT3hiTXRFMm5qM1psaVlCMTdURU1yLzMwNGNPdTI0djJhUnpMU3RmRHVMNGFVTFlQSEk0NW1sVzczOWFGS2RoRjBmVldnbmNUanNYN0w0TG5LWEtYVXZxUlNYSHVyK3JoMGYzVEdIV282U3hiNXBRVHNsbCtKY0V5eUVmdXkxRi84K1pWbzlWOWJ0aXhuRk5iMVJlU2xGUFBJWTIwSVJtV1hzM0w4VUdiV3d5RFpPMmVoN09sVzl2N0g0dnVTYXBIOWoxV2twVFF4TXl5MzE1endzdmkvblBxYmM2dDdSSXh6SkdpY3RUNHVFYkVkVjBheCtkdC9mbE9qWHpsTmFmKzFZU2YzcVZudi9wQTlmc2lTYVdIRjhrZ01iMDBXQm1PZ0lUZTh1ZzdyOGhERGpJVlp5ZW9TOWE2OTBGM1hRb0NLb1RvZndZd3JIZGx2clQ0MEVqU090c2IxRWQrUGxHVVBPbWJSeC9zdHE5dzJCdnBWV3VPcFBWN1BRQWdaZzJXZFJsaXQ0dFJWZzFobHFTeVNUa21tbEY3S0krV3paTHlDRVkxSGtobTU4WktjTlROdmpuZTRuOER6a2t6ck9Ma0gzakRSTzdoWjhvdzBtbXhyWkJxYUp4NHg3ek5pTEJaVVhkTzArZDU1MkNQdzZ2YldjUkxTOXhvYW9RelJDZGZkcDU1S1crVTNYUzNEamlDajV0cEt1KzlSZGwxN1p6V1FjRXNxU3d2TDdiUmtlWHVTcGNPYUdpVVhnekhNOVVDTXhDZ2RhQ3pMamp3TXovSVJPZ3hHdTYwMTVCNHhoVkJEM3dCZ1RRNTZielFaVG1TVUpHMUlMNFhHMlJsWTBTd1RHTTlBU0V1djJLZmVzVWxFdFpYM05hQXhHdzJEQ3Q4MkplK0FSb0FRUXNnbG9FTWloQkJDQ0NIM2doRXNlU1JzMklUY0RuWmJRa2dFMmc0eURUWXVRZ2doaEJEU0FjTkpRZ2doaEJCQ0NDRlA0WjlFN2swWmxLWkR0YlY3VE92NHBTbkdieW1MOEFVRVpHZUJXOVlQNlljM1BvNjM3Z2JVOVlqTkxwNTV5MXY3eUxmMkdrTzJMa0t0NXhsM0paS3ZPSDlyWW9wOExGdTZjMFBGQ0EvK216WW45UzQzcnJvb1Vnc2dwYzJ0KzE1MDY3dzE5RGMybXpwcXRXQXRJMnFIaXZPY1hoYjhTNGtGeUh0RUl4bXRzMGZlQWRkYmpBUGYyM3BtQjUycGU0N3M4dkdCbTAzYlA3cmM0V0ZaUlBoeTFyMHlacWI3NnlmK2RlT2VlT1FLRHFVTU9vNmV2d24xcHhSZGVSTWsrajFFL2V2SWlrSWphZXQ0emRwaTlWdXlIekdSTVpueitrWlVkWS9wV3lkVDBqVnJzTWdSSGR6U2hCRGlIY3k0MHBIOVZtdkhzNmo3cjRkQkhVRE5teHVwbDlndE44OTd6eTBwMGtjNlFpMFB1ZXBvdjVVbHBjUkhUZ21SR1RtellxV05XdEE4UUdhdjlRN0ZFZW1sOUliTlNON2VJZmxWWFFMcWZza3o4YmJ6STZjVzJmYkk0ZlN2VGRyNWU2S2FRVVZvcGltS3Z6cXpRL1pHVkpHMDFzZ1EvU3plK3BBMFB3ZlFNd2Y4elljWTk5WlhVeDNYV2FXVGU0QzlKbHNxblNObUM2eHdzYXVLRlpub2NSUjB2TUNaaUpPNWV2ei9SbzV3WTE2WHJ5MGd0SDRURWM4cWQ2dEtSeSszOWs0aExHVGx1SlgrMWRBcFhwN0lLR25XOHd2YUtKQk5oK3dZTVRRRkhvMFkwZlljcXRWMHIra0RxSU5saksraXZKamE4VUFTR1V0UG96M29OcGFrZmxINmUvNFNXTjk4UitmTkZGcURGM1ZRWUl3V3JNRUVJYS9uUkJ0cFRVNTRCazFhVVRSWjU5Z0diMlZiWHFFYXRrMjdtSmFIV2l0R2EzVkc3WGZJMUo0dEYvRU1sWHV1ODZkUVdUanFrWGhrTzcrOHY0M2FLeXYyU2NieHR5QmU5NUVqUitzR1ovRlhVZE8xRjMvTGxCczlzeEhObGwwYXYxdjVVb0ptaVZwSVpqbC9EcFNaMWhKdGMyY1loVXEzMVJVL2RYaE15OHZWWCtzenYzVmFHdEorWlk0cmNmNzdhdTFiRFhpTHUwWVNVYnZVRUpkK1JXVEh2RWYrLzhSbFpZdnlweWhGU1BkWFZKR0Y1cjNnVC9xZStzSjgzcGdWZ1ZHeWF4bldyRFlTdS9mNkFHbm1xaE96U0lMdTVhRzRHVEdxMStVdFJTcnkrZS9ocktocTlhblZIMlV0cklQQkZ1TmtSdDN3dFl6WnZxRFZUMmVVWmZRZEhsVS9pTDNDK2JuS1NLeTZqYmYycWZIcmxDemxmZnNXSWZmRFkxRmE4K285VTJrTHJUbitEUHlXOG5vdHBpT0VmeSs5TGszS2Y2YnhSeHVUUng2Q2QxamhPVTZ1aWJSME4xSjJUNXRDMXpRSXVTUXp4NkpWNTlJbTdNUjhRcG1zb2tMRHZTTldnTDBUUEI0UWc5VWFHU0tWdUU1WEh4ODRwczdLZ1Z6cnJCTkxVVys5cGhGbGYzMzdtcHhqMUwwMWk3U3c2UGtSZWRId1M3K2JKRXlySS9UR1BPU2V6Qmd2U21hNWRqL3MwT2J3QUQyZVZzZTErV1R0OTBpMDRmK29GZWZIMFJ2eWVYNlQ2WXhzNzJ1WlVNUmVoOG5WK1RvOXpTOFppaU9POExROXBFOUYxelFlZzNkQmFZYWhlampLaTZtc3djdmptZE9iZkR1em9PcVdMYWl6MEphQkZsVWFPdGtUYnc1djREaG1SUGVEN2s5eC9rWmtqRTQvQjZzVWkxWE15dkZLUnBlL0tvMHlvR2w3ZFowa1UxMVpLRXFkSHRGNlN1TlhWQW9SR1dVOFdOa25VNVNqNVVZVFd6TWIwWkVORk5WbHBQUDR0SjBkUHlJcVFCNnlPQXRNZC9GbndXUTFqdjkrOGNzdnE1WXhFcjZVcW5IWGVvbU1KZ0phSUZ0VC9qN2J0aVRWc2l5eTZvV2FYeW5iNDJYSUZxWXo3TmdnSHhDbW5sMkRacFhBNDlxWUxCQnBXRjlJTmIrZ0t1Z3U2K09kZUx1UU5TLzNPWitOODU2cUhMbUw3ekVXNHlobTJJYmp4NzgvekppTEdDVmpscngyWi9ER0srMk5ONno3bkVNNk1RMUIyMGtJbVFacWhYdmthY2V0OWNBTEwyazhqeGxUL3JNcjI3dWtNYU5oUzdxOTdwZHU4ZDdNSHQ1NmRGcVRDcFljdGtWeUtRNzAyT2drUTVsWnBpdXNhVVFaOGRxaWQwNFJtUU0wbkQ4NjM1VVJoMTBNVWIxT1B3c3lvL2pMWW8vbmY0OXZuMktSZGMxd04xWlk2TDNxeUxPTHhLQUV6NUhuTXVxK1kwdDF2N0JESHhaMUhGWFZvNWEwWG1PS2VpNlVmZWx5akc2M3pZaFhDYWpRcVFnMkdUSVV4NkxHaUJHcmx1YW9OWTFMY1VRZzhYTCtTZVQ1REhxMlN4SjdrS3F4Wk9XM1ZYQWdYUTdrUVJna2hsd0Y5WWxHSlMxdi9BL3JxTWNiL2R5a0U5MzdkbWZ3MkhKY3VOTDZzek5EdnFJMEtwMlZiK2FkcXhxdzFaNDNmZVh6UjdndWtjN2phN2xaa1gxZ0RYYkxPcjJmZWd0aHJWelJ6L3lpamJxMWRGMTFweThObGxXL3lHSysxb3MvdVRwdTI3a3M2TWJRR3RjUmpTcWkrOEFlckttNnBMT1AzcmVJTVlsV3dLZmRmeDZrS0ZvWVVmQ1NvRHByYWRwRVhOMmJzVEwwOUJsVWkxZkhDQ2VCeXRES2RxUXRPWkpSZFZ2a3crS0IvcnJObjdkVHY5WVdEZGtkY2FqK0FwSzNuWDlMbGVZejBnZG00N2MzdjdTVTNhdERVNjJzNFAzNTQyL2JFVE50L2xFYlY1VjhyMk1nR1R1dkppc0pxdElSSTl6bldFYnJpcVR6ZlhHRTN4OUZpTTVGZUI0NTZlMFVhTndjbGY4N3Z1aDVPZFQ2S3J4WFJ6YnVEVjVTc01OWDJna2hPcUFiYmtaZG8yWjQwVHlvN2hGTEdtdFo1SU8zY21ZT3ZZOEtJMXFOYVdRb1lJVUF6d3RLNzR2blhrUkRPMjhZblExWk05YzBJaUVhSVljVG1VdUtqb09kM002K2oxclQwTklnY3hIb1hGdGRWaXRDbE5JWlpFVlh3ejcvWEZYN09rdGJHWGpjei83dVl2ZGJUNlhWNmY1NGI4dENaMXFrMG5teDNDNlpqR1Vha1BpSWpBWHR3Q1BIaCtqOVBWTFhTeGg1R3lWYXEycmU0VkcwaklpdVpLUjdKZEViVEM1RFpKU1VvL01lZ3R4YUJKc0tFZkVhZWFCeFJWZVlJOHhhMDNnOFBjNzlKZkRGMURmQURqQUdSMEE2SzNaRjRtWnlBN1JuZzVHMGI2YW5VOTFrUUZtTTM4OUNzR2kzdW1ET1VyeVY2YzEwNUNLRjlkQUdtL0FQRzNNMHVtOXJsWjByNWJrNjYvbENrRlhlYlJrazJmRUh4cy8wWEJIZEI1ZFhXekI2WkZDUFh0Q290bllFQlVxeHZCS3h2cTM3bG9iMVoxOWZuRlhuSStxNnQyeDM2eURlNiswZDJDQXFCdFRoWnNiNS8vLzRmanAxT1daa2QyeU1VcnJid2hYYWpIZlZvV1UxWmlJNXBoSHk2cFVUUlBib3VPdmFQTTcxVCtkZDdZUE1aMXdmWkxzazVHeEdlSWlleUx3MHlvTSsrOWFqajVCdUdHWTlneGxUU0wzNVJrNHBlZHNvMnpTNUJjWDRQU3FQZzlvbjNIYnRZcVRCbWx6bnBzRTY1aVlVUTllWnM3TGozWSs4RmlzZDczR1pkRVZrQnh2RnNSeGh1R2E3aUFWdEdZbHQ2a3YwVmtSVzZLSkRsRE52R1p1S0FTdm8wa1JNNjUvSEV2S0UrOHFtUW9ZaGpiMkZKRFhTTzllajIrVWpIMkgwMGp0M1NtUHhoUyttM2hWMEs2MEoxc0lqVW5zUG9qNS9xRkVyaHZKV29ZR0Nic2FEUnZySTlkTUozSWhUR3ZoRFFkKzU2VTBUS0lKM1J5d3REVks4Y1UwcThqQnliVHhIN3IxU1B1S3RLOVAyRjZzcHlTL0xPaTQ1ajk0SDZHdWR5ZENOaVBpOE5GQzB2TkhyYmlISktxdGZXOWxGelZkTDBmSnRVM25xRzIxQmwyREdMT1VJZy9WVS9qYWx0UzFTdHFVcVVrYXZJdVRZMGdjS2JNMXEybjdudCsvb2ZVdVNkRVFqeVlOMEhsWFdOY1ZPOGoyK09sRmEwMHRSZjlaS2k2WkhPZDVvU0I5aXROK0JxLzJUZEI3cGRUOXBwUzhiMjEvMlN0ODg0L0g1eExITTFCMXR0eU5tSXlSNzlCNG51YmpFcGIvdHZweGExZUcvUGduVkYxS0ZLbCsvNzRweFpyQ0MrbnhQeE9sdFU5RXlwTVp2Wnl5amZTRTFLK2ZyWXEzSEtYWGNKUTI1dkZqZEZoM3VHV1VRMjIyanZCNVBiNGJzVllMN1dxWElXRE02WjJEbGl6YTJpS3pJblY5Zno0aTVDTTArRlNDTjNLV1NNWDdmZjkwMFY3bEtwVVBXc3RYUnJzUDZDNmxvalBmNy83VTArZnhlb2w1dmhKQitXck95dGFYczFhSFJzc0I1VUJsNmVNMkl4VHUzYWJsZEtaL2xkalhaRmoxTEd1dTBra3dyeGkwTkdhT3VnOXlUVmxoNGhHNXJhc1p6bkpCVFFDY2ZFRG1SZkI0VjlieE8yUVl5U3pIRUl1Z2pwZTM1NkxpNGxSWk4zMFBVSUhua085UCtuVHo5ODBkUlJOUjFXZVREVFUzTG1vWWNIR2pqK1RxZHBVVTcyaDcvWTFMMXNmbHlmYitwOXkwcUM3bjJjd29JVWcyMXdxK2FxRHVPMXlEcHdwcWV5OEh6NUZ5czlZVVorcEEwYXpQLzhyYmpqVGFzTksySXBpWXlQVkFNblZZVWlVNXoxUGxmellqR1FRNWg5RlNFOUhMcXR3OFo5MTFiSmlaRVJUTHc2K090K1ZoSEEydTVma3RseTJkS2JYNW15SE03TW5pZWxiYURMNmJlbFRJb0RUbVZ5RVFTdVFIZUFJSTNtSUNNYXlwTEtIblNNR3JZN0xoMkRTOEpsUjkrbVg4V292TGdObXF0RDF5YWVzTFpBM3Joci9kSGlHMk0yazVQY0JCOW5IR3JvelNXVk8ycjBNcHdSQ01aMVREUEtDdVlKUzkvcElhSUdTT0YwZmYxYmtZanNseWtwNVV0Um1uMjJyazFkdWI5bUtsN1Z2dU1US3FNdXM2YjNTdnR6ZEg2ZUFuYXhOdHdCVnVKTGl2VXRyNC9yZ2pUZkpqeGJuNGtUcVRtdGVONWRVdmZVNE52WUI5VlhJZHRDeDR6by9RalljWlZ4NjJYTkhKcTZ5Q0VYSk1SVWNhTUNPNElhSitDWE5rTlh3blcwZk1adGU3Z1NVdkRSUjdCQTljMHhJQnExRWpwcW1zYXlQVlo2NGNwMlkvWTU0Yk02amZhdExTcFFUSGhWa2Y3cXZPQVZxblgyZnlZUGNOVnFLVmorRU5Dc09IY215TWZqVUNNaldTZzJNWk1JbFhyUFU4SUdVT2tyN1h5TkljeWNOeE15UDFoeU5EQkNCdngwaHZBRjFPZmlMVzFpblVjRUwvR00zVlgrL1ZUQTNqTGNIZ0sxNnJqbFN4MDV3THlNRHlkcGlXRERRU2ZiSytQVy9rRFJiRDZiZXY4Tlc2bk4rcnhwcThkMFhLNDdKUEJvZ3R3VEh2b0dqVFU1aDFHVzBCTFoxSmt0dVFvK1JZVm02ZVVKUkhMazh2bVk4N0c3N3BjVWgzWGU1dktPcEVhdEw5b01yY25YYzQvZTJNNkJoZ0JsUDVXdnYvNytkZmFUaTNNMmhibFQ0bnExOTRLSkdHaDNzMTRxNkYreUh6OXRjZTFnYlptNXpSYjNHTWpvdzE0Wk1QM0JoS1Nic0VITGxVNzQvSk42dnQ2VVFPaE5MVXlzTGg2RExmdE15MnlVb2VTaC95Um1hdmZwU0VYSzRQTmtZTVJUN3AxV1o3cXNOQVJRekxTOWV0dWZzUXl5MzFyT1c1Rmo3dmZIMTE1MTQ4RDk5bi9TZFdiSXQyZ1VkZWRoZDhIMStsdXpKSzJmMFRIK1pJSktZck9wTWdDS1lGaDF2ZWpGaCs5WHRmZi9ESnFlWjdGSE1PZ0d4N1N0WUQ2T09sNFNXMWJXVGZ3QkpaQncxTS9lWk12ZzdMYU1jMTJmTEtNUlg0MzJKRy8ybExML1AxdFVjZGhJOUR1YXlTL055OGg3NkcycUQwekRsZnFhWmFIc1BKR3J2L3hvQmRkZ0dPbzIvWGl1WEZvUTdiQ2pnU2MzN3A2K1hpTDRreFA1b0VheVpwSWFHZ1pzTHNiYXZJd2psclRpTTY5V3JxZHNyNGlGWm5hNUVNdFl6MDVlRnIvbkwybTRaRzVMa3VVZW9GSSs1MFNQcTdINTl0L3Z5QmFuN2V1cTIzODkyc2VscnlpeXRZMnJpNWczZVB6QkhMNEplWDE5TkpvQzlYR1BmWDUrc2o2ZXJVUWx1NDFpR1lpdlhGVzZ6emo2UEdnSGRZYUgybWR5RE5HMDg3WDZUVDNvclc5RWU3b1lzenc4QzJzYmozTGhoYnc5OGpvOEhWWWZZbDI5elJHVkxrNmxaRDM2VkxDK3hDYkErbkdHcHF0MDFYbnJEQWpOVVJKS3FVMFhxenBaZkloR3VNOUdMNlllblVpZ1pBVndWckhTWXhQMUZPUEErc2swbkh5RW5wdVBCdk43V2d0R2FCbSt0NHMxckFlK1dWNUVXeklMTk5MUTkralorZ0FsTHQvT2REbHZOUHdyZ2ZTVnd5Z1ZlbElKVnZCZTJzVkl0b2lpNW1yMVh6V0w2T1dZUU9KRVV1em82ZEhqcEFscEMvRm52d0dSWTJEeHFKTnUzNHlrRmJ2U1dqZHoyakhQVjU1ZExuZkVRMmYyOUhMNWg5dFlMSXMwdFFodW5ZOFZKS3lGQ0VncU55eHJVVEs2QW42NnZUU2J5MVAvUkJmeEM0b05pVXFiaVQxWlIwUUgvOTE4NDdyYmhYSmVnQkJTMGVleGhVNjA3TzVWaCs2eSt3SkljOWp4Q2hKa3prcWZabVVseEFUempQZm14SFRzak4xLytIQU1Sc2h2M0JOQTArL25pUk1GK21uQjh5alRrdGZvODNQRFJ3ZkZ1bUE5TExtekJ0c3IwNWE2eXZSNSt0R1BwWTFZOXd3aTRrdDZyMndBdTlKejVKbWEvSis1REpyTm42dmowc2QrNEgwM0RZa3ZmZHhLdzVWSGc1dCt5bU02bFBpeStUVkVHYTRVa0ltWW9VWlZoaEJKbUk5c0lIR2NDK0NMNmJlbmVoTXpBQWl3YmhtSUtjVlh4STg4NG11K3VYVVlpZVhmak1ldWpuSWFIWU5iN2lOWlR3bVBvbFJ4eERhcGliYW5GWEVWbDU3Z3NPNjhxejh2VDZzZElMNmN6UGYzMVc2dlVCWlh2T1lGYkxQdkFOT1hYVjlTT21YUmxQcUE1VU1FNnVlOEx5V0tSeFR3NzdlWXJYYVMvUzcxaHZ0MWdSMWE3QWp5U1EvcURibTg2YkJ4cEJuT2FtSmRXTnRSL1pyZmJOeVJ0YjRrNlpWaHBTMlgwb2R5WXpHZDR1ZS9NTTZUbEg3NTRDM3ZnNG5VdGZTY2s1RFJwWVA1T1VUaktXWis1UDIvOXMxVUxlUlB0VTZXNmEzd1d0SGl2ZGhwTTJZYWVzc3VaWHVLcHhXVW9rdjB1VXN0NjNsc0hWMU9TOFBOMW5qaFpGWU9wQXlTTDBic1ZjUjNaalB0eXhPVzRjbXM1YnRuYmpRa3ExaW82Tk1rK2Qyb3U2bkhvb21SYnpReDVvZkh5bTZqS3JiN3BNQzlYbnZqd3FqN1RmU2x6d3pOMGgrSkcxUzhrVG1JbWJkVkt1c0V1czY5TlJIK2Z3ZnY1WTZiVEYxTDM2blBvck9SbWh0S3pXT2w0ME85R3N0YlViSUlPVGVXSmJSU2krZHk0RzhVaGtRVHhLemtERmVQeHBFaDBsMWVrOUkwRnZKM2hBbnJkSkh3d2hMcDlVeHBEUzVLcE1WUm1SREhoblBpT201SThxZ2pjbTAzNFNjemdpUGpjcWNvU3UxVldtL3BYeXFUN2hqUk9LNTROWjV5K0I1amd2bjZqVkpOUnM0RjVIMU5IbDFnNHNZaUNReGZYSE5pVzREZ2l5VVFnNDRmSUhFYjY1eEFVaGRraU5iZkZHTzdOZXk5dGRKTnpzQkt5Wkg4ekZldmorZXBSdVVIRWpETnJNQmphYVEyemVxcWtlc2FLREhIMDhrWE5hV0ZiekxCdVNhNU45L1d1dXpXUWtyY3lYbmJxTWFjZ09DamFvbnpFQkdadEk1ZXhUNEFwTTRjM3JqcGY2RUw2YmVEWHBDSHpPTlJvQ2VOVUh5SUhqRGoyUEd4SkJETlhJTXpmdDhoQnNGVjhRWk4vb3RPdC9CYmZwY0s1Q3cxa3VKZ1BiRVZhcU9lMlI0c1o0SXl3R2R4WmwrSmpNYW9SVlJYNGlsU1QzT2RFZnF1dmYreVBuYnc3MzVrZGZ2N1Myci8yUDU0a1J6MHlsc0dWa2ZSOXE2WUxwaW5Cc1JSMVNyUC9zWGpQcFYrQ1VnR2l4REhmVTd2VmZjTTZIVmluSFFHODV4eDJpOFVhYVU3Ly9ZTzdNczJWRmtYVU91WERYLytkVkRqZVBjaCtSbTdIQzVJNU8xTkJKeS9WK3R5aDJpTVJDTm1ZRmM2SmxnN2Yxc3FCN3o5MHR4cGNoTVdja29NMk5lQW5BUloycm5ZbHg3NDBhbmcvNzVJdURpZ0Y2dTJKNXJrZFA3VEFOakZwek93NTlwV054MlRyYnNFVjdRUDdNY3k1NmZZVFNtLzVBTkdmSjZmM1J6Y0NVREFFQ0lNMHc2MW0waFJpeE42bmpPRTRoMkI3b1FnSGw0RCt1MURpSUc0RFM0UjVGRlRqcXphTUF3YXRIWjZqUjhJWGd4ZFhXOGg2cEpKeXR0Y1JQMnpPUnp6dVNxUk9LR1VWZTAvbGVLdC9KdllmVjFpVldoaDBuZENhNWs1QUQ1Vml4ZHFNM3JrcnJhV0ZPdmtmeWFDcm5IdkpZMHZkZWI0dTR3azM5cGVFUXh6M25oNVZnV1ovMUdsMG5LenA3N0ZBd1Q5MGtmVDVtbXQxemNkWW0zVW1UQ1BrUnhha3JDZXNlQXlxbnpQSjFTL2ZFK2hiZytYaTNGZm9tWXF2enVhNHRqeHg1Zk5kbGVpN3V5WXoyRGk3TitpY2tuV2Q0ekI3Q20rN1YwaXFocDNHMWlOeXFxNDhDdmNsUmpxL3BITW4zVU5MYTJIRlcva3Flekg5M2UrYnBDdjQ1ZXhYcGtYVkhtM2ZDdEhETDVRend4dEJySTlVSDdYUHI4K2pTajVaS1lkWXU2cDlQd3ZLelpLbmVUMlZJWEdzNFIyU0duTDNYUjhKVGlkWFZFYTByUk1xZFd2TlZWTFJ1UndnUEtROVVjVGZYK2ltbFYzMEtXYWlXbDQybTlqeU55NDFHbjNFcnZtVnZCdFhjelVmKzVwTGxsU21VWHBVNTFmSG1GV2o3UGNRTGtsSGZwc3pBamp4SnBtZWtnV3k1N3IxaU8ybGpTQ3JTTWxuV2VKQk9BNTJITkxHbXJuNmJYWkdneVBYVTd3MXg3ZHlLMnVFZTZFTkdiOWpTbWxFZTZ0dHdJdittYlo5Sm5QdEtReXZLR2czc1FVVWhTL0tobkdnQmNoalN3VTBQNEFwN0VPemhZcHlsTGx6UGFwYlVNYnJmZiswd2pRS2FiUmM0aTNsbEtNRDFIRWJKbVlSUmJIclc4ZnJaOVY3b216NDdVbkpzbTdSc2M4M3JqRzU5b3VmRHNUdjJtcys4TExJUzBmdkN1SzhBOFBKc0pvOHVLYmgzQ1R6YUo3dWNrWjNyYTlDT1c2NUdsZU90V3hOZlQweEhSdkpoemwzTlFuWTdmRkZDMzJwcS9sa2ViU0RnQXpXZ1BOWExpSGxFZW9xbW82SGFkRnRlcVhxT3V6WEo0alh5cjN3Z2ZEaSttZmlXV3B6cVlFYzc0MGpRcUNrKzd0SFRWVjdmMTA3aTlsYjRSaXhuOGs5WDBvbFFkQW9kc0RGOXZrQi9HMXArWlhOZEVsUW5HaHdEOTBZQkhJVW1OMy9LVTRaemxmbEYrWXQzL1VxczNmejJRcGJZZXZTM1N3Z1JMTGQ3V1dXMi9Dak1VMVRWdDBLYW1JN3RWVnpPeURsZmM5N2NhdmVCOUNjbC9WRS9tQWxWWlk5cjAraGRTTjdnWk8ySlJNa0tQZVI5L1JSNjlhL2VyYWJDZ2I4TTI0NmkyQlJTNDkrQytyS2tYenB0VDFKTUVBRVE0Yy9hc3VoTUJId0NjQ3N6Vjg0Z3FtZUlNNDhLalcwWVlqK0IwSHZ4TTR3ZjIyZk1kbm1tTWZJdkI4ajRiOXRCRzZObEp6QmhKbzU4TzlQYXV0V09ha3Y4bEJhenNBYmdocXk2b3VUZFFwSFFQVmp5enVvOTdDV2lFeHdNYkFZQ2ZsbVVIL2QzQk51OEtFWkd4cHdCV0pjdkJxN29zdDJaMm8wTEg0TVhVcjJPMGgreUV2c0N2cFV2Slg2MW8raVpoa3ROUmhMOGJpbnhmQzZkNFJEYTFBSGcwMGlUd1RKYUJ6MTlxY2Q0cWVXWGZiNTVyMi9QYzFnMlh2YnhXaHBZMlBDd2JoVEpUc3VzaVlmVndUdzk1clZxTDlYdWxwVWRCRlVHbWVLeVUxcmJCdXJ4UE43Vm1TZG5sMHN1Y00wczhLdVNTK1ptVHJ4Slc1V1lPdlZzajlmeVBUdkk4Wks1bHREYWExS0V5OU90RFdRZy95aXVIRUQ3OWJEdy81QmhWemxiR0ZWVDN1UnN5T1YzM1ZsWlVrMWx0T0dHMUlxM05NbDkyS2Z0eDdhbEJFV3hqeTRnNVZqT25hNzllL0Z1THRyNkl0TUFvdzlPYVBsS1hPbDIwakZIVzN6dVhCbzRkNHV2bGZKd3pwVXBhQ2xONjNueTVYem1tRzBIS21LQWh0TktGVWp4dDIydVh6aGkvWEQ2dVRLbnUwcnFvdnQvTzhWNVhxWEJsVi80VkxjcTdCTW1POUwxdVJYRGdacEwrWi9qL3N5MjVMQm5PdlVGYVZpbXlqTzlnaHI2Mk5vVWpSSFg1aUxXMWRPMGxCK01QRTVuRTFYbUtJR01McFd1WCtycnM1TlJwU25YdDdkOXkySXZ3M1hmWjNXOVdVbTQxbFdLaTlDb3NBTDRQeXlVUTNZMFV0d1JlelJqWmhwTjFoVjRHemROak9heXl2czUxOFBpSDNIVXkwdE0wWEh5ME1WdnEwT3FpVy9kdjNmZEkveHBjaTFjNXBqUm1hU3F0MFZxVktRREwwTHQzRkNsbksrTnNsTExwNXVHcDgvVE1aeHBhV1Z5L2oxenZPNkdiUTlIbHZwaEkyMnpLNU44a3hQT2h4OTNvWTU1V2w4ZGVOOVRQai9KaEZ2dDZYNUl1cDVCa1ptYytLVDFNNUdKNEIrNGx1aE1NeC9KZHZXWkh3cnNHTzhNZHVRa3o5MDY4MTU1OUhLK040T0pUOHQvZlkxWE5UUGNaK25zYUk3cnQ0R2ZsajR2ODg4OWZyMEwrY1Q2TGxib1pXMlRnelNqRkxBMHFKdHdhY3lOVW4xUUZLUXp6NEFVV2F5SjRNZld1UkJhM0o5RzZXZlJOMEhXZmR4MW9QZnVEenZweW5qNXh3STc3NmxLcThlcUhGTE4yeGFReUFZaXhvRnYxS1pSYnlIaC9YTlZTM2hQSjlSOGViNDcrQ0tHMzhPaFdWblFBRkNYa3pFNjNQTjZ6eWp1cmpNSW51ZlJUZ2FOK05lbU5QNStZSHpXdS9xUG5WSitVMXR5UmZLUEhSczhkUjNkK1o4anVsUk1veDczSkVMQVZSWkdSQS81MThmMTBadzZ0TmlZMzVCbkpXV1ZwdmtzOXFEeGFOUEw0SWVyakJQSE9od3VJVk11dHhSYStYNENPYVdmK3dKWitJUFFwMWQ2M1dzL3JCZUNaek5RWUkxWkRVYTlLa2pmenQzU0E4RlQvQ243bGN4aTFIZUZkY2t2THhjZ3pEY2w1QStCMEhIdi9wNVk1dXd6bi9aNXVQODVzNjZqUzdOM1Q5ajRQelB0TEtWbU52QUFPNHM5b3Q0YTg5aDc5UktNd1pWcTlCM01Ed0FQb1Zkc3Q0WjQzbmJnNDZlY3FzUWZoanlhNno0TWw4azFCNTkyUzNxMElMcTcwT3BUR09NSXdBODAwNkttclZCdmNqQW8wUkRONE1mVnV0R3pDbjZndHJLTE8vSGxxV0lDMVdXZWtyVS9jK0hNQ3grdGlaeVRLWGpRVmgyY3NBQmg0andHWk1KbEd6a3U2aDhURnI2Y0hQSnBMY291RHJ2TGhVekNSWFRrcnZWUW5xNnpXSGNNSTBsTWliV0RuNVB0a0RnazNWK1NSeWVRYnNVZUo1WFVkbWJCalpzWXQ3RzA5SkxuM0ltbTZPdHg3WXkxVDV4dFFONWE0eHRVNlFSSVcwWHUrdEZMM0ZuZEtUeG01a2h2UnBWY09uaFk5WlZuaVFVVFhiSFVlOGN2V1lnWnl2UnFTclNEM0dYUVoySkwrYmJzUzJIbk9uWDVFRVdZaFArTDIvUlJWMTRVTlBjYnd0VmlSVzFqa2kyRDZUek5MdTN4VllwS08rN3JqUiswd2MwZDVPVFh2RG5aSTdubkhlclRpdkRWMFI5Zlk4U29jYXgwa3BZL2VqM2FmeVNqTGc2WVQ2QzhiRkN5ejlMNzlLdUY3azR6SW9FMmxWWTh0STNrY0l4MnBEa0l6U085cTcyNDM5YUdPN2lMbktjcjFtdmk5VzExR1NlUHV0a1czUkh1OHorL3c1Zk5PSmkyZnI4eEMvcUkrRC9XVGltT2puWDQ1VmJxZkxKUWh5OWY2S3IvLzJ6YWFQR1VBQUN3OHE5eWloSE5Fd3lOWU8wanl1bENYdDc0TnZ3REoyYkhjaU93SXY4cU5hREVaVVRkQ00vbWM2WXEwQjB6ZWQrSWR4ODVIVjJ3ZUxoMFVIM2djRno3VGlDeGRKUHNwWXQyWFIzbU1wcWNNNzc2a3B2QTRPTS9SbTI3Yjg3V2NnbjE2K2d5a09EenBMTlN0eEFlR21OYmF6NUpIVEdRZ2U5cjRrKzdZbTk2OUIxMTZmWjNKdjFMNlpPU1B0QUk0RVhUSWZXamRDajdEZHkya0xMclo4SVZZVGV0WjN2ZGdXZVV0alNmYzg1U3d0YjZ0M3NmWG9HMEtlaCtqZUEwcTlQbHBST2J4d1YvTXgwZlN0YXpEYnlNcU9mVjFaSHNEUEJSckdlUjlxR0hKVmJLTWNFSG9ITExXS0YvTG9DMFdjT1N2QkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0FQamk2bG5IZk1DRG93NDJzbzZZbVZROXk1MU9rVGt3THFSUTd1UUEzYkxJVnF0Q2syWGxIRE15b1d4T3JwMUFEd1Z6M0dJWEZydWVnRFdvU1VSMVdMTmRla1FwcldHaVBjc1JzbEtsQ29vNzVWblBzT2FlTThzczhLbE1PM1lMYXRPVXBubEdKekxwdzJsK0Q5aDBWRVVPYTNYWTcyNDNPMG5qUHJSN3lONmR1OHBXQ2UybFdCZW1yKytmcXJka1k0NE80VDNuclNyb1hsMzNQVlJ2K2duSEIvbm1KVSt4a3FXcWNYeXR0YmJlZCtTNmRQU1VkbnVMMXRMMTFUMnlMNlNKbEZFUVVrbmZCT0ZWWVQ0VWo2cFhxY2dmbkpHNzVVcXlhVFhsZnpOdWFVZmliOWYraW9rWHhiOHFLM3V2dDZOanBFb00rZDVqMnpMMzVwSnRPekJiZWd4T2NabWhQWnhZdW1McDF0NGZoMDVXZzVGRmEzSW84K1h5WGd2U2ZuYWFqUThBcWVYSWo2OHBEc2tmY2RCL1dtdnZvNTRyMW40bThwejZrTHJkbWw2TG8xbkxIUE1tUEtDVE1uOFNPbCtFOHZwNm1VdnQyempxaVJZeGtNNlRjYmFTSGRLOFk1YmJ0eEhXM2tHbGxYMzFNR2FSTkZOTW84T3NjcmtmUnJUQmpqSUx3dFJtSmpQZitkNDlMWk1TMWNDQUVZUTJZMmRWVFpsaEpkb3BZdDRlSTlETW1YZXhzbUIvTjd0alNzNnh1dEdXT0V0MngvWmVRMnVad1VYdHc3cm5WTlFndUFyYWRuN2Fad0VtV3dLZXNTNWRUcWQ0RllkSS9mazNTUHpsbUVaTXEwZVZKNWwvTGI0djhoMU12SkZjQnJncmZ2Wis1VDJ1ak1Kb2V2L3pFcWhYekdsK2JtODFGVElJNFR1T1VobFNQc0cwdjNuM1pYR1g0Y3kvZENXdHZ4K0N0eXRCZEJVZ1pRR25FK3JQK2t4Q1pLaW1zRkRsVUdyRnlIdGxIc3N2dGVUK1NzZ2s4cFBSTDYwVFBJTzM4ZmJDcy9hMG9xSHZyNDFCMTBRZGYrcEhHRThZSmdBRTBtblJIM0Vrd2ViOTVuRzE2dE1yMThZL2NsQll0SS9US0hnaTZrQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1DRjhjWFVNNDU1QVN6ZXQrUkhuQUxpeFBzR3ZQZFVtQ2xrSTA0N3RXclFLLzc1L1I4aUYzdy8zbU9ZRWdrSFBGa0pXNkR0dk9kcjBzTXZQTmZ5YVpDOVdLVzNZSjNIUmRNVVJZeHdhdXNoclpST3U3OHRMQ1g3cURzcmpSU3ZIYVVTNlVYci9xV0x2QStxUHg4WGJndVA0cExPY2t0RytKYTdIRkwvaG8rYzZON2phL1RjcHhLWml0R2g5VlJNaFYzTkZldUx6V2FiVzNNbk01WGg4dFJuRE5QVGlQY1NKYXVoelQ0NXBxNUxWdko2ZGNwTXd4MlJmZFprSVhwNEsxTlNrWnZ0Ky8xYzRDdmNhUXREOTgvMWkxUXBMWjhXTHZXOU56MjVGajdyS0gzdE1iL2E4dWVyaTZZYjhUN1p1cEFhUk81WDhuUjhaNnNXNTd3OTUrdmk2VkJxZXBVNmp4NzdQTXJmcXZOcGNqMWxqMG8vSUcvV2ZmTk0wNVgrZnFhaWppMWFkdW5lNDcxd3NyTHc5ZFRXczRObkVqMHUwWU5YRDBsbGMvR1N6NTZGdjRQVS90U2ZhMm9MQ1hXVmtsQzFnK3cwSGtObFNGTkpuVEtkOWJTc01PdE5WdmR4NXVnZmk2Ylh0WGhOaHJjVlJzMWZPcmVrdVViVFdrZ0QxWHUvM3Z0cWVkREE2NTFNMHJmNE52djFUNTErTC9QNGhaVDJ0clk4Vno2bEp4d0EwSU5uVnJmdFN2THBPVnBrUjJScDRTMmFKWHJmdDhjeVQxWmplTXlzbGJmWDNHcHVoSmJQZzZkTUsrK1czbkpPclhCd0hqMWpwWldlWnhyYnRXc0JCTUJJOEV6anQ1aVdkUlNkdUNQWG5sSTlyTTBqS1o4Vkh0M0EwcERhSTJvY21UMEY4Y3UzWkZOb0FKK1dMcVJXZkJ2U05YbG0wMHVyN3F4SVRvZjgvRTdFNTYraTVOK1BvT1A0bFo3RmJ2eGp4R3Q0UjU4MDRxU2RZSmpHRTdFV2dKeEtCT2NUTmVuV3BDckMzeHFTQ2FEeFdsNXYraStoZFY4bnV0eU43dXBxM2QrN0ZlR1JhWVVub3c2QUlUb0l3QzJ3ZnVMM2RxZGZsNUxITGwwRDRNWmpVTGFrMlcvN3BGVlZCTTlLM0tyK1krWkVyeU54WE80K3JoSHh4VlR3TEs2WTJQQlNBQUJnTWFDWXp3TnREYjRRREdzQUFBQUFnTEZndnc1OEZSaGNBQUFBQVBnaTROb0FBQUFBQUFBQUFBQUFBQUFBQUVEaDd3VHVnZlRHTlBjcXUzVmt6Q0JHbm5kM0N0NmpaYUxIS0FzbjZrWk9GN0JPNENDaXdWM3dkS2duSGl6UmR0NERvQ01IbnAxL0dFWTJyaU5FR2wxcGxlSTRGb1NlQWlvV3JXblgxa0YweGNSMEtvM0MzTmZodE9tYzlxZW5SaTFRNjZtMWNxd3RaWC9pNkppdnhQbGthSWZZbkU3azVNMDZQQVhDbjRKNVF0bzJwNUo5Q1BPaERTTmEzMC9ablRHY1Uwa2xGV0dlYm5QRk9xMlh5clFIaEhRK0Z4Zm4wYUhSUmNySUdkazcrSjJUaVAzOFgrSnZwZFFYS2NXL1hqaWlQY3dCYnRCeWRHeHdITHlyK2hyZnBKMUtsU1lMY285ZllCVFN2V1B6VHA1MkoxWWJ5bmZxcy9YbmZpbDFnOWMxZTZMejJTb3JncklJUDZSTHFVM1hTV1Y1NzN1azRZM09HVDd0dTFlelhMZlBpYUw3T2JPNWswV1NMVlR2NE1LektqTHZ4bmtwSG52Q1hZOXdndWpZcC9tOFpVVDhhY3Z4U0V5OEIyN2NjdmNucFcraHd3ZXl1cjJsZTZWdTdLM1RKajVxdGgweWRZc2dwQ3VmTkNNMHpock1zRC9XWUxKYTM3SUYzTjZEejliSGRJU1g2SHowMW5sTFU1TFVCc2N2ak5EcnRMcytybnMrZFNxR1AxbFV2V2FybHYxZnRIN2ZOS2NBK0c0OGJrU3JKOWlLVmQ2SWxjcklQTGZFOHZVaWZxT0ZOWmg2VEQxTlI4dlNUYUhIMk1uNWFUcHJtU0RKOElhRCtZd1k1OUV5SW1WbTRXL3VHb0JUOEhnUldqb09kUVVmcE5PcTU4NW5HbnFtS3FGbWtLUjhMVWdHT1NxelJlRkk5K2sweFBuMWtLaHdlNFdaTCsvOWZOL2FvSkxrRkNYTHRoOHI3U05ienMwbkpSL09TLzJrelV5TmZHNkh2QSt3MzNzNFBnK2xjbzVoS2RGbnNWd3RJMGo3SFRMWkdkL2lvb0dCV0kwY21ScGdMbEVUTVdJN3VzZU40T1RVc3JUd0d4TmQxclpyWTdrN2MyT1k1Um1NMm9yd2hBTUYvWkVHR25VQnZINFNONTlMOVp5VWsxZi9IRkNTcTEwRDRFYlNNVmJTNnFMa1QxYTZWYXd4YWlmQ2F5Ty9ncWlQUjVFNkIwb0ZYMHdGQUFBQXdKVmdTVGVkakRZRzRPNWdGZ1BRQjB3aEFIMWdDZ0VBZ0Fkb3kvTkFXd01BL0VCamZEbFA3V0FNYkFBQUFPQW10QnB0R1B2elFac0RBQUFBQUFBQUFBQ3Q0SXVwcTlOeS9JbDBXRnduMlloem5OZm1McU83MnR3SlFmNWoxdnp4d1lyaUZKdUhJcDJJSloyT01IRGUzaHJ0cEs4TDJzanFydWdwWHA0MDF3NkpVZWR2R1VlNTVlMC9sUlU1SEN0V0d1dGdLWDN0U0N5UGpEcDk2U2lEbHVVOFJ5MG5wY3d0eTliT3pwTlZUWVdsM1NjdncvZGxScTRtZlNOZlV5RTBqZmVFMGN2VmMrOEpuTEF6djBTbXVkbFdyVHBTSDZGMVZ4WGhwRjk2T3U5ZkpKN0tyZk56TW9vNGo3bndWTVVuSmI0SHF5MGoxbE03L3pKaXFRM2Q2S2xxbHNvOGMyS09XcjJOT045VEdGUHZhTjRIb0UzNjUydU9TU2lSeUpCcmtJVndRUzZUS3FmNisyQzJjcEZib2JEaHRLeEM1UGt3MnA3MVJ5eGQwRnFHbGM1YkhrYzBqMmZCNzVWcDNYY0VTUi9uL2Z6SWZGSHYzT1FyQ2J1czJ4eXEzTWJNTEg1eVNxNnZRMjVsL1ZQMGNmNGJXWnpOWXVscnlXYjB0bmtrWExybTZMVUZsbDJTMGhZaDdkN3prR1VGcWxZWEtiRmJIaFlod2xGV3p4U2o1SDExdHJtUXlaenlRdTFWTG5KWmxveElqM2c5bkRYUTdBOUYwb25KQ1BlV0xaV24xWUgya09WbmpiUjlYdDFZcDlmU3RiUnBacStPYXhoYTFqRy9iUEdvenlQSjNrdVU0bzhwYVExKy9zcHN1SDhtZHVwU0FNQWZwSm5VNnZHMXpPWWUrenZLSGtkMk9SNUQxUHg2bDZCUk55SmlocTA2MURLTFVXYXJHeEZaTm5CbGc3VnBkZVU4cnA3a0xucGRWaTU5NzVpQ3V3V1d4QnFZa1hXaU1FSGZ6M3V0cWdnYkc0ZU5qK1NncXN1dWltZDZJNWFSOUNMMUVXMTd6MTZaTTl6OXBkUXFmNkV5cEd4QzJZcXZRSjlieU04SmFXYTZGcGZDajVYVlhBLzY5N0ZFTG9hbTI1ZGQ3d2R3c3ZWaG42di9KdFYxTytiNlVCeVRpKzZWME9lK2xrWTVsbG0zUGd4a2lPaDZvRVVWS2ZNU05OSzZNTlo4WENyVFdwdEY4YXdMNjNoditBMXAzVU94OW9vMG04TGwxU3k5VmJiVmpaNzd5MEo2cTJ5Z3dEVjJOdEtEb2JTcXlIZCs2a1l6V05zVFdYQ1RzK1ZlQXhCRnN1MlIvVnRtSUhwV3BGSVZJdVEweGtiZURxNS9Jb1k0QytFQVgwd0ZEd09USHdBQUZ1VUtCZjB3bzNEcDUrSmdnQUZvQVRNSEFBREFTc0F1Z1drOFpYQmhFcDNBQ28xOFpoMmVOcWd3aVFBQUFBZzg1ZkVDVENFQUFBQUFBQUFBQVBCMVlMa1BBQUJnSldDWFFBdjV2Ly83UDlmaEJILy9CKyt3TG9YM0JKMFRxckJWUTNxQjN6cnRSVXJUeFl4Q1c5cWFOSXozRkxVTHVoT013SFBBWWcwNlBJNTNFbm5URDJER29YbTlKd2VkUS9TNEQrT1lGemFMZHBhWmhNY0NqV2hkYjEwOGRZMGVpeWZFdTI2clYvRncrVDFudTMzeXRQU3FyMTUrQ2EwSEoxNDZMejJGZTRjVTdNOGVjemg3dmQ2UmxhQ3gzTG5BV1lqYmQ3QjBPbTZkYi84Vm91MHVpeWh6N0NDeWRFaXJCNzNBUUZkTlFFNnVrODF2aDlhZkhmZXJ1aDFIMjkvU3RKbjhGZjF5ZDlUWDIrZlpoMlJISFg3bmJSR3Z6K0VlWHVzZXo0Smg5SDBOMWtjdVY1am9mTWVrK1BuU2FaMU9VbFBiRjFGRm1lUjI3NmZwUmgyelBhSnN5ZjVTdlBGYVdYVTRseWZvODBUY3A5NmxpYWNPcmJJRDQ3ZytCNmgwTE5rNlY0VTNac1FhMjByWHNuL2h4UnJZWi9qUGRieFdWb3R2MzdmbXByNk4vRFhUbGoyVWFKMnNPdmc5MnUrZGp3QmNpM2VXRHpUMVRXVm9MazdMK2pCU05pQ01kS0RPZGlQT1hLSktXL3NqYVRQVFlCYTlZeWZxN0xTczliektIbU1LTElWM3hhRGxUMm51dWpHSXkwYVF6Y0t2bVpjZTR6L1RlRkk4bTJpWlJMLytPSHdKZDl5WTByNkk2aTJKODUvMzZVdW9UQm42M0NSZWgvRmZITlhyeEtXRTZic3A2TkIxc013dHhWSmdublFXSTlhVkdFczdlcnE1MTlLUDNvcm9xY3VJdkxlaTFmRUF0NkRGZzgzV0pKTGNhQUI2RWNhWTZBTmFpeE9saUlob0w0K2ZDOUoyUUIxZjQrMVhLL3lMd2R1bUFNd0dYZ3dBQUN3R0ZETUE0RjVBYXdFQUFBQUFBQkFCSGpRQUFBQUFBQUFBQUFBQVdBL3NXZ0VBQUpDQWpRQUFBQURBWGZuYmx3enV6bktNTzlqTURYM1JPenZTSmladFNSUFAvaXNEQzIyc1ZCRXY3Qk1LcEVNVHdNSjRUalNRT25UazBSVlB3VHBoWkNKV0VTT3JNdTUyWmg2NUVSbTRTdG5sL1o4cXVYVE9pNmRsb3VmY3p4eEU5VURsanJ1UmxJSWx6eEY4K01RVjdZUFdvNjZMc3dLZmNLdkZ4N1M4VDRyWDVITjNlNXBxN2ptSk1YcjYwbE1jRHF0ZDN1R2xhZ3R1M25KL1J4dlpxenR0L1UyL05rVERqeVZTbWJuS3daMEh2S1ZyMFZjYXRHMkxFVzdoYVVPcGJDN2VJOXRnMTlSVUgyOXBWcHA0bzg1UjQ4WUtsV24wd1dIZzZvcXFNSDVFcThkVG1MOGl4RlNxYmcyUFh4TTdTaTFDbm5Pdyt2dU1zbHZ5cGVUekJYdnZhNGEzWTl3M0tmSXpobDdSWkU1eFh6dmR3cll2cDc0UDJLK09HUDBOTDd2d282eDlaYXc1ZVp6QlZVajMxNlU5TTdOM1RDVkhHVjZpTWxyOGlLekVjZlBhcVZVTDQrdmt0UGV2L3ZSbjRuMHhyc3BXVmF4dTllRGNyOG1GRFZhcndMUUlteStxTVdhTTVtdUpXTkNvZnpoREgxdGxldU5qbmtNTWF5MGlEWGlQVEwwa092bU9Ha2oyYlk3azkzK0x5Ky9ZMTZZY0xNd1dubmVwdVJscHJWRGl2Y2RwQkFDQWhLVzlzaEMraFhsMkF3elQzNlMxaTFGbUhhN0o2bkdCSHNlTXBhbGtCRkthYTdZamFWWjArbURxMWlRNlRucGRWRTNwMGZqb21nMkFTMW40bVVZbWswVGFSNU1jS3E3b2JUL3VrTFlzTkNkN1BTVFBqWGdhaTJQN1BzZy9qdnpSQmhYU0g3NlVhb1FQcGJ6KysxbkQvMTUvN25QN1FtaXAwbi95eU8xUmpETFRvY3hQZVltUldwSytYOGZYb2JBeTZ4UmNQaXF4c1BIN3RrdW1KSEFaMWpUR0l1MWNKUCtTMHJKRkxQVm5MVXZhakVqSnY2Q1BibWg4TVp3bGlFd3BiNU5MYVZxbWIrK3lpY08ySnI1MGo3RWhMWTF2RFJad0dTUG0xTUh0elVRMitodk1RclB0WFB6eHdhbmJCU2pHdFFkdGQrT1JSQjBKajZPaHBYOEErR0lxT0oxTDVoa2NDd0FBQUVzQnd3UUFBQUFBQU80RlBGZ3dEUXd1QUFBQUFFd0c3c2FYOHRTT3hZQUdBQUFBQUFBQUFBQUFBQUFBQU1BaU9MK1krdk5LTDU1d0xJMTJiTVNnMDVraUwzclRrMldzNG9lZElKT05PTzVWZjVxMzg0REM2QXZ4clhuQUltakhLSG1QYzBHSDcyazVBV3pRSk9vNW4zTE5icnphZHN0blRiNWJqSnNuUlRvcXBxZVZwWFBXV2s4NzlaUWh5ZW9kTGErNmxzaGs4WjZiMXFMSXBMYU5TK3JORVpXY2hCSkdqb293TGJmdHZhRWtoTTlyNmpVUXAwVjF3ejhuUUc4blN4Y3JveWE4ZEtXclR3dk9yN2xrZlUxSWlzOUNtYlNNSXVUbHYwbzBZN0JRZlR5VElwU3RwZWtRTHdmNnlack9IOFVJMlo2MmxkSWw1ZjRLZStrNUFIYzB1cDhvM2E4WGZtN04rUXFxTlk4OW13dWo2dFdpVTFyTGRvNHhsdGJ6ZWFNMlF2T25Da2t1MUdrNy9iTllkYXV5VkVlSDFsOUVmZWNRNXVmaHk2bnZDY3I3K2RLSVV1dFhvbTJaQXVsNngvTW92ems1ODFscDZ2ZzZ2ZWJwK25wRkxhTVltMkkwUUtzYUxjSlpCWmU1NlpIRlFVN2FmWXNyaHlSc2NWYVl0MHFLcG1EajF5UXlsM3hyVDFuMkZkRDdrYTRUQ1krVzRSbGRJM3lWdlp6TXh1L1Q4UEZiS0xFaEpJZTJHdnEwcEQ2UlAyVklkYXZ6MW1YdjEwNTF1bmhMV3JvVkFPREJZeHRiTlozWEE5clMxcTVNcTcyVk5DZTl6L1Z0K1lXMHVPVGVkQ1BOYUN0blBOS3c4bmxOR0V6ZE9rUi8wQkdaQjlGMWs1Y1JZeENBVStuZFU0cEE5MTN5Y1MvbUo0MTNMMFc2dGlLUHl5S0ZXY3FpcGxlMnRTNXMyYWVMclBjMW8yN2xZNktzb3BrNmY1NERqcUljU3RqSEhNTzlaR0V0TGo3K0ZkUHNZenpET3B2MXRlK0g3TFlmMmtpK2orS3NBNWdPSFN6Y0hyYzByZEY5NDRtcUxrbFhKaVpjVXpTYTZZOCswL0NXWFpTOFg4SW9TMlNhUXFYTTZMNk81UUZvUkpkZ1VXOERFTTV3UzhFQmE1d2Z1c1g1bXdMUDlvYW84bDkvWk1HZFRpUWZBRzRzL3lJeDhXUkFlNy9vTzBLbFVkZVZDMCtPOEsvRDYzZEJhWmpnaTZuZ1dVQUpBQUFBZUFPakFBQUFBQUFBQUFBQWdMdUQvUTBBQUFEZ0VjRGtBd0FBQUFBQUFBQUFBQUFBQUFCZ01aeGZUQVduWVozU2swaDhNdEpaY1pOWTRwQ1JuMHBFSHRCWlI4NG9lYlNpNnBNRmNGb05BQTY0VTZDOWRDcWZyZWp2bktPajc4eDd6cGhIT3liaGFLUHhwM1RPVFhlVzlkdU9jVXB5bXhVanI5dVJhTGtuZWlKcVlxKzlja1lnMVNYeU5ZUnBhS2NqZWhveEcvR1JPanlWK2tpMDZXMmhGN0MzUTZNcXc4L0ozN0NpNVBBT3dyYjZ5TmRuTXFndTFwck5PcjVQbFgzWENkcHBkeGRlT0ZHMTI2S0d5Nlh6d0h0c2IwdmViK1VLQSt2c0orZGNLY0lwb1BYWFVsc3A5QXVwNzRqZFB5SStGVGxqN0kzMGZ5UDU2QzZSWml6T3JBdk5PMGdCUzdmYndrelZPV0E0V0NaN2xnYlY1dEE5dFhiRUR0M2hEanQ5SWxmYU05cWhHS0dmRllRZVQ3OVZVcFFTdGZ2S2JJN1Bmems1SGdWVXk2RDZXUzdUUGpvWFR3TUE2R0hFVEpxaGphMDhyV1hlMDM0dmdyY3o3dExJc3g5cGVQYXRvajQ4VE4vMXpIUXJXNVdrNVZiMTdKMENjQW9MR1JLNitURDYrWUUwWDdWbDBZRTdQOVBnaktPMy83MUdNRHZUMFRyMVVMcEZsbWFqNFdrUGFmTndXNk5ubzA3eTkrUEtuOXorR3o1K3BkUjdIKzFPRUwyUGVTV0JxY0NYV1orV2gxVzkvZHI2K0VXenY2Tk13NktNZWlvV2VVcTIvU3RabzJqWldqaFV4WWxFWFJVWTJHRkV0eFk4U3hyUDA2S2R5a1IvZ3JOb1hSNDYxdGo4Nm1nTVJhalNZeG5kdUE5dVRMeVlDb1lpUFRlUWY1UXlDVzJsUUoxSkN5TzlaMUVpaWZDdU03RW91UW5SQVFCa0xqVE1WamR1RkNOOExWcTNUeUxraGpJemYybXVPTFZXMTM0bzJJSTFnVnNtK0VCREpCbmVicVNkRjE5aCt4N1pYckVyN0hXOFh1MDM3TFhIeTh4amEzWFp1dnA4dWwyU1hzSVowaDRSSFp1VjBGSmQrMys4SFNtNUdDR2Y4SDNwOTJhYTBueUpiOURYZER5V05yM2JSbXYvUnZJNUZaVWxNdXZKdDlEaTJMV1c3TkN4Q3ZzK3NEd2R5UnZ4dEU1UlF2cjVOcVVmbmNjejlaaWs4MmZQMjJJWEkrcVdWMmhtRS90cXdJdnM0a2RtbTd3cngzZlAySkllY1VlZE84OFlITzFRVW9Yc0dEL1M3ZGJ4S1kzcHhsbW0zdG9iTk1xa1BUTGFkUis5Q3A1RHE4Nk1EQkJySFd1dENMMWxlUHptRkpBWkxhdU9yOHZvM2IvZzRtZE5LcGtmWDYyUTlWQVI5VnA5WFE1eWZrTUxTU1cxQTNlZGQ3SzRWQUNBZVVSdDRFeFB2MWViOThvQUw2S0xiVS9hT3IxbUFpMFhvTldsbWVWQ2FES3lFU2FiUkxBaUsyMGxXWnRuWEpwa2hBUHdlQzUrcHFGZHM4WlNrRFdNVmlPZm5QbW93cHJoY05SQjJxWm9wVVR6WC9zd3VnM3dGcmRmQjdjNHRiOXJjRG54OGZtS1ZVaXBaTXFsZnZLV3FveGV0anZ4dlp6YXN2UEVTYUgzMitwR1JsNm9CUUFNWXRZbVEyc2Q2RFhuWDk4SXpXTE1mclRqVGV0WnduaVgyaTFQRzd6MWhZVlFtT3crZzNtMFBBMmtBVmtRSUQzT3hsd0N3K2theUovZ3MwMCt0dXNFb2cxd2MxOXRCSGd4RlF6RjJqSzdoQmJ2UFlESENDelpMZ0RjaWVqa09oRnZGYTVkOTI2bG4rbnRjR1VLZFFqL0NsMTYwRkhIUlduVjFDM2x0ZDd2bVJUaldvL2I5MzRocVh2dUo1YlgyM3VSTmVFMFdvWTFISWtZUzNXNFJoRkNaK3FPeUp5L015ZmVGMmZ5T0dmZ25lNktQbWoxRFhyR1ZpT0tqdnk0RWI2eTlDOEY2eUVlbVpGbmxqMWwrbGw1UHQvZGorSjgzVlk1RFducFpzUVd0a3N1alBjaXlEVElMU3BESVRoOU5Ra1hNSFA4emhoTG9nR3EwRmF0bXJQS0pJdWtHZG1OZzRkRWNHcUo5S3pJclY1ZGRLdUU0V1FkNmJxMndpTnB6NWkzVm56Yzg3RGp4NjdCZlRLc1BZUlMvZmNIMzh3cXpGOUpEZXQ1R1hYTldRakFYUkR0cjVMMmJIcjIrcUVoT3BpMUhQUU1ybDRYWUxRTDBTT1RtMlNlUE5rcEM1ekxTa3BGcWt0a3JORzllNHd0OEhoT211Uk5jeTY2SmgxQmRIZGxocUdsOGJraC9uVWYzZzJtTFoxUlZNa2xxVldvbkZqNU9ZbGVwL2lYVTdjOGtqSElRdm9JdmpwdEIxOXRMM3p1dDlkOS9WM01WVW8yYXBNcldWWmJmM0w0aWM0UkVDYmkvNk1yN3NHVi9uUzA3Q3QrK2pjUXl6TE9MRE1wWlVkbGpFeHZXVERiNm9BRE16c01MSU9vQ291Y25nM0l1MzhhL1M4QUt1TExKWFpBbjIzeTRib1NQSHVjZ0FVdnBxNUdOcTRsNzVMdTIyalhFemloaURGNHRHZUQ0cWdQc290dHFiVnptellIUnlSUEZoMnFFL0YrRm0zVDYxOU92YkxNVXYyYmo4RnN2cEd0NVcxOXFXeFBuYUk5M0hxZmxuUFFJcXMwWGxOWjlVOUQ5Mm43dnBRYVo1YjlIWTQxREtRYmFXbkdTRU04MWRHNC9MN3RnVERtSzhUU2pjNXNBRXYyV1RxMEIwSC9TbXI1ajhrajk4V2RnTDB6aldmZlYxMzRRZzZVVTErVkJhcGFZNjBENWIycitEdytmajNNbjNOUHJ3eHJYbHRwdUhTTE92TkpmYnZjbVgvTEV5bERTLzZTYVV5R2xoZEtmMDdZcjc5Q25KMTY2bjB5UC8xS0svbmozUGtyYlo0bEpueGtHUzFJOWxtS2k4cmMvK1RLM29nY1NLdWIwYk5FaWNvZWdQU3hpMnlvWDJzNlMvSGFQaVNRT05QT3ROcENHamZDM3JhbTUvSnVWM3NabjJtcCt6WmN2UFdsVk91cjk3VHNZNzVqTGRJaEpxb0RKenhvQUFBY21HbnFlMldQM3IxT1NkNlZUa0k4VnhmdVdzcDdhNjdjR2pyTGpSanhTQ01KOFNYRnRnaTU1UU9YRDV4RFpDeDYzY25Xc2kxWE5pbnhBQ3pMaEgyOG1VWkV0QVZrZ2xzYmN0d3pqZUZyMGw2NFp4cDFuQWVQa1l6aVZhYUYvQnZKT3dCM1VWWWJSZnU5SlA2Wmh2Mk1Lak9TampMc3ZZZzZ6ZWVhOW9TMFYrcmJpL0RNSE9tcnM5R25ERWUwUGQrSDA3c3dqR3piMVduUkZXc3p3OVRYK1dyWkkwM2xGNHdwNzlLeVp6bmNVL2JvTXNIRlNDNk5ORS9CYWJRMHVmYWV4bFh1TlFBc1htT2h1UEM1VTdRa3B5aFZlZHpVYWZYMWdBaGVURjBkeS9FcGpyQW5UcG9MbE1WV1pCYkNVeHBiSmVqQ0JmRXVYREJISHcxOG1aRThkU2VYM1BlcGcrbytiUzc5ZG9iak5uT3l0NktSRGJWdlZsVHZZZXhwRUd2bnlqTDJJeHE3Qks5MXNwcG5ac2VQbG4zRklJMzJWZnJkRmMza3VrWDBWTERiUG9yMm1SVWZBTzBIUFl6bzc4amp2Wm55ejZaWGQ1WkJhUnJTQjhWdXYxbmJ2Wng2c0o5U0dYcGgxN3hRN3RrOHU1S1pjeVhpUjhBT25JVm5DWGZvS1dVcHBrU0IyNEJlSEEwOFhBREEzZWhaYll6ZE9RS1BBdyt0N2tta3p6eUxqOGdMcENQTDl1YUhVd2RPWjRaaXZNa3pqVnQ0RXRJUGMxcno5L3lxcTdkOXRKOGJGNzBvNlhwUm5jbTNsRjFaNzIyVnhyMlZUMHUzTjl3YXV6clNyeFpCTjFhemFqOFlCZmZtN01lYzBzOVJJajlUdVFtamxod3RUYTFOYVN5UEh3TDA4eEswZVBUMTd3ekVsMUs1YXpZVEFCY2d2V0EwY1d4aWhhRFF1NVZBd1pJTUw2YUNPWXc2TUtpN0VoeVdSOVBrOGV5elNGVXBrK0xCVFVCSHh0RGF5VHBkYkVBYlN6NkVKYnJsVUxWN2JteEVXMmJMVTVMcG9ZbU55RVdVNUd0MWF3VnF5WWltNTdBR3FqV3c2OHZOOE9SUDB0SlRkaExDdFFlU1ZxR0ZwQzVzVGNheWw5NXJsNU9SYmlnOUN4Sk9xYVRVNXROOEk4VUtLNzl6cVREaGgweWpWNDdGRFAwOEZ0OWVLUzBPQ1hYTzdTcHFtZXdTZURsV25xalZHK2twWDJSeFMrb3cvcFpHbXRIbUkyZ3NVK3htZnovVHJ6eCthdlJicDhLR2N6Ris0cU82djB4UEtlc3EvaFVOMDhnNnpmQWt0S2ZPZFRSL0g2cUdFTCtNK29uL2VjcXp1YURXMTFjTEZUVDBUVlJ2UDUwNXhpSytRZFMrdG5xelVoNHJmWEdVNlNpR2lyVFN6dGluTTZhTWhXV09TdUd2NmQrYTBHekVTekswWm9xTXh2WG8yV1B3cFBQSTFOTGxZSGdTWkdtK25IUHdkUHZUeFlqWHlxQVRrbCtEbC9mMTN1Y3BTdG1GN0RWSTE3WWZ4WmZoVnlHRnpWdDJjZlMrTThsNTc5a0l3TlZrWjN5TDF2SnE1Umw0WForb3pKNzh0NGMySmcyWG1MR1ZKTW1NaHRkRTNBaFAvb2lyNHgyb01IbnI0SmtIMm5nZXNhRG9tVnU1UXhZQU8yWll4OTQxV0RTK29leW9MZkNpelZPUmxaNXBlSXhsRnNyVTlnRTBtVFNkSTQxWVZHYkQ4MnREcWxqN3JsbUw0cjVlV2xNTzZYOUR0M1h3dGtyT3J2UlNHcjdGcFgwTXoxNXBTUzNQWDdJb1c5cUx5T1JmMlhXelJyTzBUckQyV1BnNnd6bGpLYzU0YlhwSHB6eTY0cDdNTXZrUldUVzFHb3crWHJvSmx2VWQzU1dwaXJlc2lwYVhTemRqaTZFMUhsVElwcHUvQnBlamUyVWtUVkJKdkhWRTNsL1RlQURjU01iQXNSWi9EOStzaTI1ZGVXcGJ2Y25JODlpNTRHMTBqNHlIZ2hkVDc4cENDd3dZWXhsdEVVUFRSY0xCWW5nM3NjRHRHS0hmeXFBMFgwdDBGNG5GcTIxSGNrV1pCRzUxdk9oZ1dzMVhXRkp0Y3lzN2IwVks4Qm9RYUtOTEQ2RnAvS2d5K2RqZWJwTWV1UEozeDI3aHBYZ3RlcXplR1FOMWNCblNqb3cwZExScnM1RFdlRythU0xxelpmbmxiVC9JNE9mUTJMRlhseEdmS1lWY1g4R1Z4bUZGUTdYeStLOWtXdW82TStsTTBZVXRxdnMreW94eGZvVStHMW5XMVdNOTRtRTRucGFzeG5aN0oxYjF6NGZSRzh0cmJlRVZOQ2I0TnVqRXVXSyswd2tzWGJkVHpMSzVjQzV2RHNnR0FNemdaSFBmWGY3TVhSRG9ueHR6aDBjYStIWGV2Uml4UmRpcVZGcnlTVnRER0dlZ200bjdjdTd3TThxZWhQU3NJelEzVjNxbWNlVXpLK3NCa3ZCcmVFNEVEUzVHR1k1TnAvZ3pEZjFhVGkrdnVYdnJZRkcvZkh2MUdrSUdodS9Xb1B1K2oyc2ViK3R2U05ZUG84ZHRsUzVMMU41WSthMjBaMDVqcUF3QWVGcm0vWHYrRm5MdHlaZ1NKaVE0SDJhUWZxa3B2emZSclFqb2tnT3ZGMU8vMkZ2OU5xUzNzYVh3Q1hqbWs1Vm0rTmFlOU9OTUxvMzN0S0xlMzJCVy8rWTVSWUFWME1iZUF2UDFsbkJ0YXExQUpyVGxsVDdEV2xiWjYwVnhuVVYvTFYvMHJPWWswaWJUcUlkRFBYbGFIMzdSK3pUYU9pc3k2MTlGNzE0R3NJeWdGWjZZK0ZxbTNBZWFCQjhScFZsQ2twWld4M1FxYWRlOWZMdGRFbjNEZXI2OC81T091L3E3UkVxOHAxQnRmdTg3MXY2Nkk2MVhMWWNMLzRSdU1tZ0orOU9KTllNOGM5RElENm5ubFJuRm9VdTVvZE1qT3NSYW5vUU91ZUVzeEJmSjNsWGpsN3daUkZ0aCtCbzByZEhTOXNubTRKY3ZNSGFjNjJtNGpZY3B4a3dwVG14RTZPR0VmbUZhZjg4b2pkNlJKNzNYYUZqK2hjZE9TMlZaZ3lrSTU3djZsZzgrbVJLNU1aOGxwdXorMlVkWjhobGZmdWQ2MXVsKy9sSEtNcm1UQzNBZzZqQkZCcEduazdqcjJaNUVhLzRaZXhFZW84TEpsTlpGaFpTMHJXRm9lSjA2czNsb1BQMDZTUkdsNlhWS3BMU2pvdUttbERSV2FCbURkU29BRDRmemNLSnVSYSsycHBZaHFqVkhsTG1GU1I1ZTc5cVdsblVyb3E3NVNOblJSeG9SMlJZejNRakw1SUY3WVNtSkdlc0laaDBVVW1Cd3E4Q3QwQVo0U3BkWTJNTldrYkhQbm9zdHE1Wkh3N3RaZVVNanVoK1hTTGlTZC9jYmljajlqMmlyVVJ0ejhRMDd6a1MwNEdueHovT1RrdXJubzlGUzVMMElpLzFUV0Y0MkgvdEpsZFZyMElDa25xUGJrMXcrZE05NldNb2lzdmdlVFhhbTRUWWpNTmIrWUhsYlVqTnhUUnFsVldWNDBrbkQ5UEhkM3VOK1dRWVhhOURUNlYwdGJmTjNONThsUjVNOGU1V0dFb1lCY0dNcGJPdWhSbUx5azRGbnJjQXNkUVljZVBaTU9kRElJcThYVTQwV1FnT3V6d0o5ZE5hYVRDMzhZbytBcnY4d2RSNEExOUhvK0Q0V21jOVg4b3doeEd5OGgyLzg0UVBGNHFDZjd0cFc4L3I1Vm5PTjZzWWVSd04yUzBEYTFVOUpialJydXlxUmNLbE1McjcxWjVWMmg1Wm0yZDc0a2F4VWx4UEtMQ05rMzJsUzk0M3puNDNsUDErclU5UE9ZNFdXTGgyNjRGbmN2RDI4M1h6R2JSNitzUHEwc1RicVIxdWVORjUvb2pVZjlYMGlXRTk5czVGM29IOC9XTnhvTEsrU1M5OVRGZ0R0bkQrWmZ2eVl0aDlVenFqbmNaR05PUVhBV2x4aDhqMi9aenV6N0ZtclArZzdKM2dVQWU3S1ZkdXJubWNhVit4ckFEQ2RxeWJkQ1dXeWo3UysvWm1HdExNejRCZXF4WlBndXh5UWxxZWhFcDVkeU4vNC9aZFRrelBmR1BhVEJ1N2tsNE1PWHBPN2I4aC91WDg4ZXovRGF5dkFUZmsrVitsUmpGSnY3TTlqc2JjQVZzSFNVOHdhKzJyVjlpaTFDa2RpT0g4bnNEWTlnNWs3L1dHQXdiVjA1RWI5Z3IrVVYvcnBmaFBSSFN6ckJDenB0M1VDM0dzTTB2MWFWUUEzdzk3cDlNVmpJSHpvblN6Qitkc0RyVm94NG1uYyt0M2U4a05qTHIyV0ovcFNLbmVVakpaMlJDdDdCcUgzQ0pYb0F5dWo3TUpjdkExUlZyTUtRcEsvcmhHMkJ5N1NEejIxKzRTQy9BT25HejFOYzZKT1hCSTZqQ1dGdlAxUnFGYzN3YUhtQ3hkaWZmSEhydy94NFRhUjlDT2NtSHRZd3gxRFZXTTk1dGdFcE5DUlJOditCS2YxM2JhdjhmdHFHL28xMUozMTJHN2o1R0hrNlRVNlNLVDVhTTNYdnBadnpYMUNmMDhwMjV1M3BZd3ovVXFqVEhkVlh2N1hleWlXM2JYbm5kSk1ObnFrTFJSZlRRUXovRzhoWmZrWFhLVTc2QjJ2dlRhME40MVVCK2NhUkZUUEpZa2JkZVgxTDEyclJKdVdXeFp5cnB2R0JGVlJ6NW55cXR2T3F5eUM2Qkl2K3VCR3JENk5XRnJtVUxUanNqUGRTRWJLanU0MVdQSGF4Q2pCc3ZtSkczblpsRnZIbEZSL2k4UTdzYVdGSDE4bmZwVkhIVXUrTExuRi9mY05BSkNoTTVDYWZNNEZpSEtHbG01ZGNXOUlXcTFGdGxUV0xWMkhFVmhtMVdOMlZ0cXU0ZkxYRkNOZVN0ZUN4OTBBTWE1d0s5UGdNaU4xa1BJQnNCUzlpbm9DWGtkaXlDT2QzalZxRDZPZWFVUVYzbTVuSjFpMmg2S0UxUjR3TFlMc3JRM1JuZm45MzdJVFRsTmxFbHNPK1g5RHl5RlBJamxwUDMxazAvNkxyZnRwZmJjdnA5WTFrSjdsY0JJOHNid2JxZTh0Z0FzWXBaNDg2d1l3bml2TjhLaHRXaTlmTnNhdTNJdFFyS25JS0MvQ2swNXkyWUFEN3lNTnE1SFI2Tk53cThiQTd4ZEVHZHMxZFpPSmJHdTVCSUJKOUxHMjlMdUc2dDlhZlhGMlM1cExrZkVyL2FTQ2xnRkFLM2d4ZFZWR0xGQ0tjUTJHc2lscXVwWEdiYTFkdWRBQ0YxS0M0ZUNyNEp3NWRIM0ZsWnVIZCtlVXRtdlpwZ1BEa1J3TFR6NlE3QzNqTFhqN2hiLzJ5N01aamVwNThEMGlYQ3NobW1ma0w5YWs2eHRRRG44RThyYjIrd2hXYnV2MXhrVjBNNi8rV1liZHl5djI4NVZ0M2xQMlRPTTQ0OWNLalduRDZ2cVZvV1V6NGd6VGNJdXZyczVhMEVmOENra1RSVFlSdVY4eXpQQnQ4dTZmZmZpZ3RjVWdNU1BKa251WmJGb3MzdzI5SmdDV1pEK1hiRDJGdVFmQXRiUzRBTjQ4MGZtZEI4cVM4bDJ4QXdXK0hHdEM0REhBV295Y3NGZHNRN1krMDZEcE1TN0JVcHhoclFQMHpJK2ZQYmx3L2l1VXlXelpMWHRqSThlQlYxa1NwV2o5SXJsRGg3YjNzdXhvK05iZWVkaDJ0TGRGdGQvMFJlb0FVd1hBU1p6eHFNNVN3eTB5NjNqdm81c3Y0K3E5Q0s4dEdBM3N3d0prNHhwTXhhMDZaK3gvakhpVEQ0QVJOQmliczljWW1BNEt6aVU2OEw2WWlnWmJuNVlmRnc3R3N6NDZiWXVXcTB4aDRyajRKRnpUUElVUFRreHhtRUlQcGFYalcvYTh2dzFObVVpL3YvVXFuWVpxV04wWUtjSnplSnFtdnRiQTJkaWxDanQ4eXN6NHRXNnA4eVdtQVR3dFFzdms0bE95Zjl3dDlRSVhQdW94aVZRR1YrYnJQdXZqbzM3YVQxeTFheS9hMWVtNXVwWGt1Mit2SXZPVU9ZYzE1NVlCZFN4YW1sZ0t2MldEQlBEY0gyMkxQeStuSm9kUTZkb0tseW9nNVMyT05XNVdVMlpCaHhUVE1rVzRjakQxbEwxdjYxQnlkeEU1elgzeFNyRVJsNVRsZmFKV2psSFZkYVpaTThsZnR5bjU0bUp1dkg5ckx0WFdrQ3ZMbzY3am8zWEUzQm9sNCt4eHJLWDlWc1BGc0J2N3hlL2lrc3RRQzFPMzhoMyttaVBraThhSEw1NEs4OVh6dGRaczJpYzU1MHQ2NmljNnhxVDF4SWl5b3ZmbFhMUHRORnJRdU5FM01BdFRkbGJ5Y2t1MWx1VUJYYUlJOXNURTJodDh4V2RpdHFRWFVYZm1LVTFFdUw5N2FVaExRN1hNYTJzZ3pGd1FXYktrc2hPVGIrdEphODBkclhmTG5vcTFZK1ZkaS9EaGRUNHFZN3UyZkxRUi9maTV5Nmt6RndCZzRObWx0VFFqbDc5MkcvNGhNbHZ3NXJVc1hEVGZJNUcyYmF6QjBzTFZiZ1Ezd090NHJ1eEV3cE1qblZWR2Nzcnk1Z2RyMGJyY2picGgyaWFadFdrR3dDTVk4RXdqay93dG9rUW5wWnFvbXYxdDV1cG5HbEthVVdVNWs1WktXUjZlSXpsbE5Rd2w3cG1HSnVTNEp0Y0txejF2dlJhMERIN25JWlByVC9wOW5iaGE4UHZNZGZqZVRGbk8zMUhPRmp0cTVJNXdhWUdCMTdlaHpGQlBvQjNMWkxTczNVYjd5VjYwUnpjUHdidGNxT05Uc3BmSFdoZlZaV2hON3UzbUdWc1Jsc3pIMlF5UG1iWWF4Um9zWUJrOHZ5bGdsVVdSZFlBa0U5MFB1dkVZRVdiY1diYUZlNmJ4VnhWSDA3Ynl1RG5BT1I0MWxpTXh5Z2Y4UXZERjFHOEJnL3RTb3V0QmROZVgwcnBLMUdROGtjM29QOURqSCtrc1hzNjdIek1KWUxCK05UU2NFWU5ycFVFYTNSM3Q0ZDZUYzhrNTFUTHh2VGZpblZ1d1BRWTljNnhuRjNPV2gxay9YaDNkK1ZjT3BoRmxUNnovOUs4QkZtZlk2REtrdUVuMys1NFdudnZ0bmJjOG5HZFQzaitONE5QMzFxeXNQcjZIQVlOa1U0TFI1R2RGSldCWlJEK2k2TmNrUHgyL3VZaEpxK3M1ODNldXJHaDY2ZGYxSThvc3pqSnlnMndyWGQ3OWN3cUxMMUVXcjk0TlFBdGVEL1YreHZYSHJ3ODFwMzliVm1Md1JBQlltMVlOTkd2bnROVmI4cWFEVGdJN3puQ0g4TkxwY3hpOTNJMCswOUFlRzBMNWdVZlJPZURGZmZKUmxIMVp3NWZuVno3VGtNTHBYbHBtNGx1VktDUDdvQVBQVTRLem5rQiswc2NIekt6ZFdQcHlLditNcHczc1dvRS9ZQkJjd3p5bE1YN0IzMW9tZmovcGptKzErR2MyOGF6OXFVY2pkUjcwOGxmZ2NZM05nNEl4NmNEVktIckt1MVVHSnREclNBQVJ2Smk2T21lK2JTM0l0SDdFMGJKZE9LUDZJcjBQUzR5VFZVcjVCRVY5MmtpYmdoc1JIZUNuVG9pYklKMUFJY1VuSTcwVHorc1dNOVR5V2c2bHBmVWxtQmJJMHNPYVdvbVNQR3BkckY3d1lHbmV5UEVuM0Nqd2pDS3Jia1VvMjhoYjZyWVZSSXIzRTZsYkxZTXVrWTUxK0tUMmV2VG5zWlQ2dlVLSlBNMytpRi8yU3RMd0pRbENoVEdGeU95clVqOGcxWDZvbmF2L3BpclB2dXdzN0hDTWZTbTFSMC9Qc29KYUhVYjk2cWxoRWtsZlRqMGN6ZWVWUFhNaXoxeDAwbUNycktwOXFvWFhMcld3amhVa2hlOHFINjdLNFljTDJjeWJYMmtMaWVmRDUrSnM4MVBxdEhwWjFoUGhrWENqcUNTejZNQnQvUm1yZ3N1cmVibzBYUHhTNnBLTUhHTWoxaWIwaDJndCtiUjRxcG1La3JhenpCSkxydWJwYWRMZXJoWHFWSCswNGsrd1VUZjZVUXQxenpCNG4xenkxcEcwSnBFZEdTdS9OYWg2L01EZXhWY1N5czVHbkxVWHdjbVM3amNaK1RsWnliajIrVGFlTDZRZWEvZTdkcEcrbkZwL25TU0dYemYyenpYUEdBWUFTSEM3a25XY3RsdEpaVWpYWEZtZWNFbEdDY2h1VGZjb3JNV0pGVzROQUc2UFVMcTJ5cExvM2Z2VnlyWUdORTJ2cGFIcHNwSU9mQzhqbEtFbHU3NHVnZlFBTEVIcnV0QWpOL0d5NlhPRlROSzViV1hIM21nV3duZlhIdGt6dloxZTJYUXZiYnZteXFqek1PRmlWVFRaTkxNbFM4KzJYZk5yOU8zVlViNGZjN1hxM3RMdlJkTzFPRmM1YWY4bHYvL3JYNWtmNHlQUFdmYlBTajhyaUU4ZENwUHVFMDVySmE5UjltMnB1NVg4dmdaTTN3bVVZTHkxYmNmbFEwZGVoMi83MHBaUkF2R3RlbHFUNmNsek16eExWSytNMFVzU2p0RmJFVFRNb3pLa0hYOHMxU3M4RFE5dWdUYS9QU3N3enJ0K3p4bnFYdWQ5ZkYwT0FNTWhBKzNQOHI2K0pzbWp6eTVhOEt6ZTZqTEJDMjluUFppL0VnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBN3lmLy8zZjl4eGE0bSsrL3ozZi9BTzYxSjRUcWowSEJNeHNBcGNrU05PdW1uQ2UyeXhOeTJYdDhqWmUxK0NQNjJkd0RXZ2czMzBIQ3Mrc0hqclRNVElZWHFUMWZMSldHY0dPYlZqa2RKcVNHZUJ0UnhabHh4NVc5SjdaRVZIRTVQc2NGdlplWnVXSTJFZGlTM0pPVmJxSTFFK3BaUm5uaGZSMlBKem1ISDhsblJEUzl6d1FoUlB4S3lqamRyTGtMNFVkR1RmNGZ4c3pRZTV1cXhqYmVKY2FRMG5uMlN1ZlFsVmlqK1Y2UDBQV2pDRjg2VmpXd2ttb2FPRUttK2ZjdlF0UGUzNTJNcitLOHV6R0QxM3pqQklWNHpmaVB4a2w4RXE3cXpya29OTEYvTTdWZEdaK0hpRkwxVDZrbXBiaTE1aE02eWpycU5IWHhjbHJrWjE4aFZaa3J3VUxLTU9IOER1S3g1T21UMU5PcGlEaTA3SzdxMkNwM2NqcTZFcnZhdHh0TTQxVGNZTWV2MnBTTThtSnMrRmV4RXUyVHJ5MTB6cXNKVHNyNXR3YWZoNHoxZGNmdjBwWHRMOTV4WUE5MFBTbUZaNkRVbmplWjhCSkNhLzF5S00xcmFyV2NZbDZEVnhxeTVScFdWQmNzcUtiK1g3WlZHWmc1WVJZRkY2WEhNQWxtSGx2Y0tKWll0T2p2T1p4dVZleEJuZWo2YXdyTjBZTHEybEFEWGo3a1M4elZjQS9RUlUzbWVOUGRQWVJCVnZKUmhaOUs3SFBOUElEWHNSM2p5MDhUSWpxNWJIN1Ruczl4cU8vVzd0R0NWblBCakFpUFVBT21oOUl2MXNQY0laVldiME1kSVh3UzEzUjNvZG51N202dEJUeG9obGZ4ME9HS0N2SDRWM0htc0I2RzR3ak9oUFJJTFpGQkZENmQwS2ZneFJIdzdLNWczZU5nVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDNysvdjJIdmdOOTlhbG40SUQwVm5YcjRXMGRhQ2NGVzZjTlp5SCtFbnFPcTZrLy9IQU1DcDhWMXhzUEZpRjZsQjA2Tk02SmJXWjl0VVNxaWpVTXZxLzduY2QvbENwTnB0bnpQdDVkbGlmdGx0NDdBYTN6ODBmaXJRdXBBK3NMNU45VGJVdDFFdXFmYTB0bVZHSHA3VkNxLzM1c3YzNmZjbXpQRWU2OEpNa2Z1UlJQRTdmZHRseUdGZjd0RkVjRS9mcHdjeUVlYStEUkFhV1NTRS9mNWRJZjYzQ01MWWwrUmNobXhDRGkyaWFxMTcxNXBMSUhVK3ZldXB4U3hZVVpPVUUzSlJLVjFWTzJOeTg1bVQwWFZSeXJJdjl0OStKbzUveHFoK01vcnExWFBkSzJ1Y2JiUlA0RTFhUENMbXlweDlyVnNpUHgrbGVUUjQzNVlzaU1salhTSUVsbFczcFlLeXN5Zm50MEVhTXpFb2s2WEJmOXBHWmprY0orZ2M2WVEvbmxWOUkwNHBkUlM5VG5TMHJaSFdyVVhhcTBia2hDM3VoODlxNGd0N1NhdnBac1lYR21vM0dhL2JmbWtKVTg4L0dKS1Q3YVZOYnRhV1Z4ZVpoMFdlaDJkU1F4NDFXcjJ1SDJpVW1NakFKdUJIUk5uVXVJenJVZmVwOXA5UGl5VWgxMG43ekYxdmYzWmc2VXhlV3gwMG5yQ2lrOEs1T3lYdmVVblNUSnZ2eksrb2VVbFozcm84OGNxa3VqOVQxSzhSSFVwUUNBRUI0WGdLYTFadU5JaXlDbFMwdytUem90VFd2Wlg0UFgzQ1loWGV0U05KS1hHekEwWEZxYVNNdUVrUU02TmNxR2lic25aMjNqdExpYkdGTmdHajFLa1ZONjNqVnJDdWFSeW01RW5MK3ZpTXhONk5ZeVc5YlltaXpPK00yQUd0eTZEcHJCOW14VUNleWVRU3BlcmZkWnBiQWY5OTYvWmRiY254ejA2NlhIUERINDl0aFc0dld6eWFTc3ZmZDF5RVNXYnkrQ2kvTWpQdy9pNnZCSm44bm9QYlp0dEVZd2pRT1IxTlJNdnhsY1QvUTVSRkxpVy8zb1hwZmdDLzNsVVJZK0cvS3Q1dXBwenVpUTJ0SjZ2QzV0LytmUmpGeGplZ2NKR0VaMHRlQlJ3MGRQYkI5T245dG00ZkUxaGdFd2FiVGQ3MnpNSUxQMjlMT1ExYkkvbXR0aFBkTjQ3Rnl3R3RtYkQrQ0xxUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3TWZyaTZtanppQUJ3NUZlYmJjT1llT0ludHFqaUttTHJzTWtUaDloVWlVOXh3czBWbFlyc3ZjVUc4elFtMkdOcVVGajdtdUpuUHJZZWtwdmdONFRDM3NPUGx0emlIZ0hjRll2K3pwYWs5VjZmRGduaTh2bnVmK3NoR3V5YUxqVnRrcTdGT3RjTmE4am9kM3Y4VDdyVkorY2V4bWZOUHdKb3pwdHM4RTdrazZkYzlheFhWdVkxNUVvZ2JLc0lmWnRTRzFONDM4aS9yUjVxZVpRMUFwNDV4Zy9sMmpvWjZiVU9lbUp3RklkK1BRU1IzbmFPWE1EOUZSNEFJNGNzSnFlYnJEVTIyZlZhdDByT2dRNWRYNytMNENsUk00bzIwQnFpM3o0WTM5VjUxTyt6cmdmeFh3NjJkTHBlb0NmMWRRdVpxS3FpMXBXRm1aK0p0cWh1TWF2dDk4ajFxODBsalhDZWJjVzlCSTk0OThheHozM3c2UnJkVmU1b3QvWHd2eklsc0FxOWlXRGZnMnllSFdaOEdWVkQvNDgzclZKeXhqeWxtbHRBR2hoVVgxdGxlbk5XNWc2MU5jMHZTQ0dpWFlWV1pSMFhId3l3cld5ckh4R21XK3hyM1RXME9SYTBpcnovYkVTUm9Zayt6dHBzVXRlV1NOOTJjVEk1dWJ4Q09WTzQzUHlHUU9yTEcyTm9yVk5ZVVAza3FqUFEzMGRQdDllUmwxaUZtdGdsZlhKdC9leml1eXdreHB3YVQxM3NLK1ZMejBBb0ViUzN0bEk2M0VWcERJaUhoM1YwbEdyMUlQa1ZsbjNmd29qYjNRV0xVdFF5NWV0MDJueE5EKzNvVTVsV1RLa09uaTJKN200a216VEJaTzJEaU9YaGRIOFdsMnNOSm9jQUM1aDhXY2FkR1BPQ24vSEoxSVY0Wm1HcXRmUDlEQ2llMlFVeVppT1VIYmV1am1NWkFtbWwvSUx0ajd5bGREanM0alBYL3N2ajI3cDArNnY0ek9OZlhqYXhkTzRmZm5IMHJKUU5rOWg2dVI5UmtyNWxKbUZjS2tUYUduSCsvK0U3U1VrSXJ2OWE2OGZTWFdkUVBLcmdqdXNhWUFmYTRIUDliZmtMN2V1QXozaDJTSC9RWGk5RDhNa212azhhYjJNOENhaHJRbFNvMnJ6TmlvYm5JYm1QYlhJT0xqVVJWa2FHWSs1QVdpR0RtanZRQzlWVXJLcy8zT2RQT3NmdmFpZVp4cVBuQ09jY3dCbEVRWmZUQVhQQXNvQkFBQUFBQUFBQUFBQUlBeTJWQUFBUUFOYThpelEwZ0FBQUFBQUFBRHdBZ3NrTUEwTUxnQUFBQUFBQUFBQUFQajRPNEcxa2ZaNVdvNlBtSGlTazNSVzNHVndKd3BKSjZkd2VhSlVOOHdkQnRwNk1CSzRLWjVUaUxXOFR4OFFQWE96c2UwaWgxMTRUeUtSNUsyTDk0NnpjZTB0cDc0MFd1M3dXUnFwbHl4bHI1MEQ0OVhRMlNITFFqcWZ4amgrL0gxcUxSbXh4WE5Ham5TVW4vK00wV042NlJ5cW5ITFhHWEFqNEpXcE5uSlNPbm1lZW9hTDFNUmNHbUJqcVRNdURUcy9JMWJEbU5lc3hKeTBVM3lscno3S2h3WG1RejViWms3T0JxclMxL0ZSSFVObHRlanJhRHFPcU93aVo2dVBOdHVsaTdiaEdZeGNHSGxsa0pQWnZYS1VKcThsNzZ6VXYzMVFmM1dSemducEs2Vm1YZFRReE1xVXY0aHFTZU5PMVQ2bWlHa0hxMHhOZW5TTWpMQzhWeGc4anlIbTBsczA2a2IycTh6VVR5YWlqYUtHZnNCWmRMVDhoZnpPMTBRRWJjTDAyUllMbjBGUFdaYVRVb1R3Sk9TamJlZGRwMFRLTk9LNVc1Q1hEMzFMRmFuY3lHMTd5OWlXWkV5dzlPSDA5KzNsajltajZaa2lEckk4dGk4NTBxN1BDTCtSeW1yMUk2VTV4VjE3NTdGVUZnZVh4MU9XVjU1SHQyZ1R0Q2d5Ni95ZmNKLy90Vjk3ZlVyTXJ4S2xldWZYZjF2OWxFOFoyMVg5bCtTOStXalJ3d0E4RjhzVDhyb1JVUTNMbFNYRmF6SzRPQ25Na2lPbDg4cTZoR2dsV255KzNySXRNMTJIU1NaUGtsa2FyemxaV256UEFPZmlhRHhNMTMxb1hTOTV4clVsUjNNRm84ODBNT2JBY0tJR3hxT2d0YkpLUngwYzZjVDVWSGhSa216UFprVDI3akpjdVJ2aE1lWmFlR3RhYS8zc2xhdkxlVC9URUlibDU2Y1RSWkQzV29NejBiWWJRVmUvV1EyM0tFb1plYmR2ZVZ5TmwvZGVnbDRYejNQVGZabTIweVB0WDN5K29Kb1BaY1RoKzYvL1M2a2ZTYUNSTTlVWmFNZHJmcVBtT0ZYcG95WXdxaFN5Y1UzbGU5TGVCTXVMR0xWVTBaNmFXVGJSUzgrU0RCaTBOSkkxUDhIcDBIbllzanJhL1RTaWtMQTZzVEd4QzVjZWdCRklTMVJtUVAvNUltcmVKLzBKbzl2UTF2RDB1aEZjdGF3OGo1d2FuSkdHamdpREw2YUNad0RsQU1COXdmd0ZZQkJQbTB4UUhnQUFBSDdKTUFrQUFMQTJUOUhUc0VmZ3F6aC9RR01LQVFBQUFDOWdGQUVBQUlBdkI4LzFBUUFBQUFBQUFBQUFjQi95Zi8vM2Y2NXpKZjcrRDk1aFBaV1dVM3BPUmp2MDBudWlUTi9wWVNsMklsRExVUnNEd09rMkQwUS9tTkEzMWtZZHkzUW5QRXBrMGp6MTBIckFtU1Z2azNuT0xiRm5DWFhJNE9SWUExdW9TNW5WQWxicnRoNlgxMUtXbHErMXpJcFE5aEdPaE85K2p5cVJQODMwQ3FUUnZKVDZQZE5XTE5rQUhZajJXREV3dXphTkdDYXJVS2x5KzdUeVYwMzNYd3FpYWZjMWtrNE1sdG0rMG1velk1RDBEdVFyQnE1UTVxNWJxL3VpNGVXc3VsNXNsMXJRVHA2dC90aDlBWFZhazQ0NTY5cFgwanEyOFJ4V01EaGFIUlpiakVXcWFMaDRiMXZ5U3RjeWQ2UzhPZS9ucDdVc1BwZm9tb1d6MHpNMzZxSnJGaHBPeTlUcUl0MmZoRldtbEp3cGc3MU5wUzVXMC9kMHE1Wk9rVFZrWDBDb3l4RFp2cUllek1qMWY3U3NtWFZwelR2aS9uOUhtVmNDL2VwSCswNkViUVRwMTAxb2VNdWFEWE1LZ0hPdzl1dEdQRjZSWkZobGEyV2NzUUxuTk5lajlkS1ppbmxVaDdlVXhjVnI5Q3hkdk0vWXJUcUFlM0NGYzJNdFNUSFd3SER3VE9PM1NPT1pCbzJYbm5WTTV3eVB5aXB6MVAzbTNULzd6ZFQ5OHo4K1hCWXBWWS91ejNMaXh2bXc3YzgwUG1WR3ZmWk1RdjFsOTM2RlZDN1RkcXdzMDVjT0V2ajlERENCRnRXQmJsbVBxQ0tMTHNKSHV4QTEzblZmUkluY0hNdE9XVS9Mb3QyYVUvc1FTb0V5bzBEVkRDQzY5cFRTZ2VHMG1sKzJPeVZkeVFtUUx3RVl6dUUzTmRhRGh1UmZOMFNmUU5NNGo1MTlIRjVuZ0YraWd2UnBRcnh0Q2dBQUFJQUZnSmNHQUFBQUFBQUFBT0FCWVBrTHZvcnpCelIrbkFrQUFPRE5sU1lCNWdnQUFBQUFBQUFBQUFBQUFBQUFBQ0Q5bmNDYVdDZVNMdkMyZGYzaXQrZFVZZTVsOHU0VFkreWp4T1MwbnBNSUl2VVFEaGVreVVZWERSYkdlendURi83RVFaR0Y2K0pJMjNNVVZ2SWRtT05WdDF1NmY1U3FlS28vWndob2Q5RnJXRHhuck5CMFdialJ5R1JwcWRjbXE3WmcwZ0JNQStzaVVYelIxbW0yTE5MUlVGWi9XMzNnWi9zU1kySHJjUzdXU1VIMCtsSlY3SjFTSHJ4VDZ0dHNUellpdUdsZU5BR2U4Vzg1bkhxNnZYOWRTQTcrOUdFYWJuMUo5Vk5pWWY5T1F1NHRwUy9jR3kvbGlaeVFIRWxubmYzbGxlWFF3L1dKMVBuMXgwOVlhVzNyQ0p5Tml5aVZFNVNCYVlhRTQrTktPV1lqMVkzZWJUSXJhY2RtOXErU2tsS1hmZHpxQ2pqYXF0WTRYdUYrUzJNY1IrdEszMGpIRHpJK1RITzVIVVZwMEs4U3Y5VmJKdmFuK09iTUNDMFh4NnZyUzdJYnMwNGZTVmNjWlhyMXNsVzJweXdMUzFIVDVJb3VVSmNjbTM1UDdYaE11OVhFWExwMFRKc2QzWDc0a2plZHE0WWJJYlY4WkJSSDhxeUxwd1c4OWttYWh4RmxHZlVrdkRyQnQwN29xNHRFMUVmbjhqRytHUk5DMXlwWmFldHRENEVMMSt1MmI5UGoraWtMNlNXWmV3OXZQMzJET2hJQTBFUjJ4byswZDlhdWp0ZU5rRndCTHIxVWhybHQ1ZUFhMy90RVdsMzFpTW4zTGhOYXQ4NDR0UHVpeXdjcEhTZFAyaXJiYjBqeXNtRHkxaU95RmVGZGFwNVpkaEprWUt5QjRaeGhQVTk4cG5IWWRCQ3lIcDRwbDZQb21scG0vVXpENVlHTThEaG1QOVBRNmxpQzZZTkd2OUQ0eEtRVGpMemwwNUNJejVkU1pXVjZkQ1BxRmJyY2pzZTdhKy92c3JzeCtTWXorZXN6bXZteXRlZWdVbmhtL3VMeitOSnR0U2hWZjViM1BzVnZ1T3ovNy9jejVGckFXRFlqcU1aUVBuVEQ5VkJURUYwWGV2cGRNb0hTRmltTmo0NnRVZWx1aUxjN3BmaWpMdVd2dmZJOFJJY2NUUk1KQjUxd0F3QjZmRGlqUFhldEhCWnVlZlJLWFA5c3E3NUcvd09UVnNWTXhoNEpGdU1QNlpRNHllWWxaN3lXOW5FSVMzRTBUSnl0eWZERlZIQWFtSjhBZ0NhZ1BNQTBuamE0cnJ0ZmZNMEVBQURBQ3NBYUFkQUc1ZzZZenBtRDdNb0JqY2wwSW1oc0FBQUFBSHdoY0hFQUFBQUE4TlhBMlFFQUFQQk1ZQUVCQUFBQWNIZnlmLy8zZjY1M3V2LytEOTVoUFJYbjRXcFhvcHpUZDhCNmlUeDhXN1R3RmlhM3BYWXdFazFqblhjR2JzNE41dk9TOUI2cTJTRERNMjlwV205UmxvNDhkemg0TkxZM3J6UDlUbTluVjVhMkl3cWxPTFlBUlVid3ROTXVvbVVaUitkTXdYRktyeEJ1bjFpM25YSnFuU3ZYYy9LcVZEWi9UZk5OSlRMRXZDY3dhbW1zTXI2SlprY3JZZzJpdE1uZW45Njd6WmxQcko2WDVtdXhTRmZxeUNnajZqRFNrY2pwY05yNE1uTnZSbVY4dHVFemxJeTJMalE1WXdPWklpTjM1YmRENlpDdVBrMmJ6bE51M241T3lMNlNsWTFBUzkyaTQ3akgybnQzUHFqc3pqSWpQaDlwd3NOVTI2TExNVXY5aC9iMTAvZVhVb08rcUNlMTNNTGVWUmtOWHgzSnVRczdMNEY4cldVNmZTR1BTSnFPcGgrOTFHcFJFV1FPQ2RHOGlPQzBUUTZaN3JMVDJPWTdselA4UzY5UEc1V3BEV2lLdlVMbTAybGx0V0tWbFpoNHZRN0h1L09zUVhTT1gxRGwyNHlHMGpMcE91cDQ5OGN5OGtGT0Z2SW10azRBZ0RsNFBCdXZETXVEajlqZFhpMGRzVXIzdHZrVDhHNW5XZUdSTW1aMitLaEhHcEZsaGRkMHdkVGRpMVlsMlZwTzFLMEU0RlJHcmkxSE02QnUzTDQ1VndSRmVxYXhyS2R4NFRPTlhYaEtmZ2NqTzBYN2xlUjdmL2E5Z1ZXMmlGZHU4a3lqL0ZObmZxZlJubWxzbFd3Zm5YTE8zN0xTSVg0Zi9vazc3aTNvdGVMMklxemVsR04wUit1NG5wRDJGcEpRbC8zOVUybTFIQmtZV0JOTGRmU29ZVFQ1ZDlLNkpvdks5NWlmRzQreEdYc3Jsc3d6bTZ0bHl5SHF5VURGQ0hDTjdIWHBKSE1yeFlNd3JWc1JUZHQxUVNjUDNRdW1rL25Md3VpaDBlUFJhM2Nsc0twSVVCSUR3TnVtQUFBQUFIZ1k4Q0FCQVBjQ1dnc0FBQUFBQUFBQUFBQUFBSUVyTnMrd1lRY0FBQUNBcndiT3ppd3k4eGVZREpvYUFBQUFBQUFBQUtieWR3TDNZTlVENlpKdjdWNk02MU1MUDRFeUtCemNISFNzbjUrMm92TTVla3dVbFRlSU03cngvS0VTUHhQU1JqcEM2bFhXVm1TdTBwWXFYZGRHY0dtTWE1RTVvN2Z1WURXS00wd0w1MlB0TDZlTXU5OWJxT1dlNGV5OXdhZmJweEtOblBta1NqNHI3bGRsZXMrcXN2RjlwY2c3cjFmMmFrZlVZYVFqVWFhSjdtY2htK1krK0xrY2szZmVodGNPNllkbGxwMTNWUTd6ZWFXT1g5a0l0TlF0bXFmbi9rOWNuTlIrYzJSZDVKeHFHenNyVkN3aFd6cWZyOWRpUFV0RGpDOStWVVk3YjdxbTB0T1cxT1h6cUlNcitZN0hQZE1zVGFSTUtyUEhrN3NIWnd5TVlseVBrR21GdDhxejR0WXNhNFFQVk14K283NWFGdVJvMTBYSnM5dlFVbElEQU03RzQxNjBFclc3STNhT292ZlE4L2prNjJqY2l1Z3FvN2Z4ZTgydzV3cytveFpuV2xuNGdmL2FuS1Vrb3VNWjR3WmN3cmZ0aVZJUnhWZUU2L2RWWmVGNWV2Ym0wUWlQaTlrMEsxcFo5bjVla2ZwejJ3UE9RcDN6M29QV25ta2MxOXBSdEozZStqNXpWWloxLzdic2o1eGpEbTI3TXJFNXRHdGFGaStOM3VYY3FRVURLekxyOFFLYS9IdmhsSWFVYmtiWkc5SmE3Q1pqYjhZempSbFB5MXBwR1JZcmU2UzNCNDI3RERPZWpuR292eFU2UXdrQXdFR1dCMFVaaTVxN01mYTNObktaaVpSNUl6ZGpMdEFoemVERjFGWHhmcGRjR3V3bk9GclptV1pLVmJ5VGZIWTdNRGVvR1FkSlY4RXZCbyttVlA5eUw2ZldhVkl3ZmlMUnFxNUhxN2ZrdlZQbWdRTHJTYi9TRGZOcXZaWkh1ZzhhN2swM2dpdEdrZVZJZU5yRDErYmJDM2JsL2RQTy9UV1g0MWhXRzlKZExJSG1MRVNHTTV5SlB2NjA0Um0va3ZFNTcvV0Q0R3pXUVIvaHVaTDFDY3ZxZGJ5c2xnRm9EZHlvN0N0MWFFZVpPWlBzSzZ3WW9vdlJTTjJDQ21zN3YwTElzbk1mL3JUbE9lMGtiOVRSdWFYLy9tNnNGK0dkeHlPUnRrbG5sYldhc1p0VUoyNTlaSm9qZm1jNzY2bmZGMmRNbmZ6NjRWTXBxL1FqN1Q5clBLKzA0dE1jU0JvdS9YS2hsbFdVOUVGZlNLcGFTWHFUMTJtait3Q1JKVXF3RzhVNVJPUTBqWW9SYmtUMXQzUzdxMmxPRzYxaFp0MlJkMDZOTE12ajgya0RlYXdYc2FkZHR0K0w1R2VYdFdhcDA5aDdDalRmZHAxMjExeHRqeTNzMVlWQm5Ra0FhS0puSzYxdmgwVXVNOEpJcjdMVklxemsyWjdDekJ1K3dvMlF3bHY5YVVwaHJtSGkxdWVNaVIwZGE1b01BQzVqOWpPTmxnbXg0TjYvcXZ0WDNFUHpyMGJsZEtQVzRKWno4R25jbi8zUy9WNnBWMGtTUmJ4dFZJbTJYNVo3empNTlRtcDVsYjNGcDFlYXVPT2g3UThjdHlPenN3Uis3NEh1TWVqMThsMFh0NFRlZE1DTng4ZEhzNitEdFhDUCtMRGM0NUlSengwOFNwUXJpMExyZGpNOFUydVdySmxORnRueHQyU0FDMERqZHhQMWxsdkw2Q2tVM1F5RzBiZ3dva3N5emQyb3c3a2l2YTZORks3WlJNd1YwQXRlVEwwN3N5MjZVcFJIQVoxU1Bhb2xxVWFlV1ltaUYrbFo5SUF2Z2xwNkt4MzRaWnMwMnFiS1NVUlVocVVUdmNQaHV5bnE1VDRpZXhMR3kzU244LzRLd3dydklicGlTUU9xRWJWVXBVSEdsc3JiNXQ1NFBXYzI0clh3VStldFZtanJjQVk4SlJybjZSU3Y5aC9SMFZ0cWF5NFZzOFIyb3ZNNElpc2EzNXQrQU5zUEJub2F1YlJxckpuTVZEN09QSUlMSWMyZytxY0FwMjk2Nzhvc1FuaHloZmRRbGg0cmR5dkxpNlFUT3pVdnR6Nnkxa3U1aEdwU3hJdnh2TVV2ODBMcXhubSthWnd6OWJEVE0zN2J2T0Q0Ymxudm43ZEVhV2VBL0NGdVJEcHZDM1FOYnRDeDRUTENpNVEwdnA0UmVXUEs5dmd0K3pTWmFibld2UWpQejAvRGhsaTRCZ0NNaEp0aG96eTZ5T3pseW96TStoR2F0RmZHOS9zTWhDdE0vSlZsdExnUW1tTUpzd1kyb2tyWGtvR3hCUzRCenpUK1lNMC9OZjdPenpRa3FCR1VQTTRSOTUyckhLWEsyNkFVTzVhZzV6N1RLRUtvcjdTZVp4LzZYb0puZjBES3IvMlV1NUMwbnhkYTliSUtTU3VWaGIySTZSUm5HalQ1R293MHY3MmJDdDU4Vnp6VFdBQ3FyWHFlYWZRdWU4OWd4SzQ3MUl4QTNPMENOK2Znd1FXVkIvMlpRc2JZQUswMDdzOGVmcCtUeGFSL2lEd0RhZDJlOHp3RmZSd2pIaUE5bkw4U1dKdWMrSUVzaFMvQ2FWVXJ4cjliWmJqL1Q2ckNWaVNIdHdxTGR5K0ljdE41ZkNyUjkzUm8yMW5Yd2Fwby94K0JWOTdhUXlRNHNGa1B1azRiNlhBYXpzVmIxeFl0clI4dE0yb05tUFNISXIxMW5qRzY4Z2xsMk96dDhyNE9VTWN2bm5MRFhmY1pOVXl0ZUR4SW52ejYzem5NSERSbjZPZVRVSjBJcmM2bDRiYThua1FrdktVTXI0ek1CMHZYbHRSLzJ6TlhiY3F0eWZacG1mREUxKzQ0dC9JcjFLOFo0cU42WCthY1VSNzFPODVrMVhuZDYwOE9LbG9hNEExbTZXY3VXTzZpWlZ2by9PdWN6a0d1R0N1dFpVWldmS04wYlRUUFFMUXF6SFFocmg0T25JbkxkdDZpUkVmblZFbWZCQ3RxVWhuclRxVVdpY2ljbVU2cVc2OVdiSjNQa1RLOStrbTdsbVRxc24xcm1GalpZOWRGbWdGK3dLL0RBTGdaUGJPeVJkdHFaWHJxNHJWOFZqNnJqRWplMW5Zd0s5RnpJNjFtcXNlTk9OUGQwT29XTmIrUzdHaWVEZW5aZWhMQ2h3OGV3REtpclZmb0s2NE9jSy9BYlRsRFFROHF3dXNNc1ByZDNJMEkwbUxrcmZDV01yZzgwblhrVjJCV01UbnhtMGJNbWpNYk1vaXM5N3I0VlpXV2RYSzgxYVJuR25KNzJMMi96MnZkUitRK3R5K2xidi8vcGVYM0tYd3NyVGxGZTdsMjNMNEdES3RJaTJyd2dDWS9seGw5ZURhenh1SmlXTGZaOGdzWnIwdERyMmw0dSthM2RMOWNKcFdoWFlNTzBMaVB3V1YrTjc4NEo3eUVDczdGYXdTTG5MVno1ZWtHVDBFcnNBYytESHd4OWE0c29BR1dlRU0razRwczF4ZFdRYVB4c0FSd045RFJ3RW5yWVd1M2hOUFAzVGU0aENVQ2k5SGlDZ3dmbXF2eldQdmpQY1hXaW8vSXRPcmc5U1RibFNoLzRPYTQwNGI3K2FJQnFRMEg2MHVCNFdid0h0ZmJtamVTYnJZTVRtengvZGFqcVE3MlhCdnR3NjFoaDZBSGpvdytwM2NnVTZ0bTZhdW5qWldaalgzVy9mUnNsaTFzcDIrOEhJeDRkbWRZZkdCeDVvYnppZ1A3elBwRTEwbHg3SjZVK2h2N1R3Q3N3cG1hVXRyRjBkSmFzcUx4RVFzVVhWc3U2U3ZjMk1jYnlwblB2ZWVaWFRDQ0VkdDRLMHgycjVMRE9BUzM0Q21yN2RIM3VjSXpqZDQ2ZENpcHdpZzhiZW5KYmg3eFNyTVFwN1dsNThZOTAyaHZwOTQ2U016ZmFlRGswZzQ4dzhEQmlJSXY1NHBISEZlWXdqb3Q5NUxFRGR5UUdSYS8xOEpqMmZzd2JqcDM3c3JaVGV1YXgraHZzQnJVQ0dVN3lWbkFScVorblVFZkpEMFl2Smg2RitoZ3BZUDRCRVBLVldFSit5MDVrdEpFOTRZSDJoaTZCUHpoeFBuNDFYRDdzMFZKVTZlVDRqdUtwbkd0VlVwR2VvMzJvVFZ6czd2Qm04clZIOFZqUmJKd1haaDZVT3I2Y1VaaHhJTXBLMCtyTXBBTWthY0t4WkQ1VGhnc0s3SjF1Ry96WXduYmEwTHpsR1UrMUVsUGQ0RmJkYXhFNnFnRU50SGFZS2RGL3NRVmR5WWxub2FYNnQ5OHlCTVpzVVdNMzY2a2RCRzg5M01GSSt2UU9JazBsWG13ZWFtcnFMMkFyWkJJbmhJSTc2RnVsQmJaL1AxbDEySjBmeitadUFEY0xPUW9PM2wxeUh6N0ZlSDNoRzlQWFViN2dEUHhqTytWalY1MGZuTHBzM0hOUkN1U0thd21JR29xNmlVZkxHSGVmaERGKzRKanVkSWVSVmVNTks4Vno4bTIwcVdCWlc2L1pDdDhkQlJqV0ErUmU0STh1dHpLampRSDJadTdhWlFWV3FzNDIyRUZEKzZEcFUxR3lHeE5sNFd3NkY2RWRxM1IyeFlqOWlKb3ZhMlNDcHVhZnZHanZOTWQvYXJNNUtieStUcndkYVZsZks1dG1YUmZ3MTRYSlNNZEFLQUhUcE5lcFNucmV2VEthUzNiNDFaZHVtcUttc2lJREN2K0RHY242a1o0TnlQcU9PbTV0MFZQMjJjbG54UVAxbURFVmlGMzdaSFpNK2VpaXNybm5nS3dPQU1OMWJiNTdiRXZXdEhzM0JydFNZeFFWRmI0S0R4T2lLV0l2RHV6akt5b0QvQnVXcm9QUzYvUFJuUFdDaE82ZjZLWlRZZEtMeWNuK1lGUzdoNUQ4bDVERWRMdWR4ajBmWkMwUzRPOWlHRkVkV1RMTmg2NjRYNUlqK2lTRUg2RmFlVE16c0pqYlliZGlUWjlib3p6N0FSN3Vxc1hxQktCeUY2U1pUNkxFQTdDZU9jbjU1blY0Ukh6RysydVEzZG52UzRBTkNQOWJxZit5WVV3NE9xNXBLMDRSeno5dGRJOEh1OFNUTUt6WmZEbCtGNU1QWCtYQW16QThyV3hhZW9SN2RZb1ovU2FGTndBNjZFdldKN1JxbU9UMlN1N2ZRaU52Q012VEhrMGlMMmhNK29JWXdwMExsWFh2VDRmSEk4NElmVm9LVEpyNjh4WEJ0K04zbzZkc1hCWTJia1pXWWZCOTVQSkgvVmJYNlczRGkxMVBiTWZlMlhHOHI4OW5meWJkMnZxUEdRYVNEOXFtTkZ5Y1lsbDZwaTVpc2hUL2lzWS9jaXhPTUxLMGFXbk85TURvQytuOW5GbUg2MDhIbnJ5amhoTFdodzNtQ0l5NjNqclVYNE9oTitQY1RiSFVWYnE1MDRXQVlCZWluRjlSUG9GTVBhU0FGaUZWV2JrS0hzNlluVy84cTdOcldnZFhHY095Q3YyZm1FSzc4RU1aWExXbHBOblhFT2hnYTlpNFdjYWJ6eDdSdEU2akZCVVZuZ1BVV1BuVmFMV3ozOUpXOWNiVE40cUZmVnlPZmhkeXV4SzE4ZlJxUm5sNHNUbC9OWWx3OEg2THRDZDk4VHppTTRLbjgzTkhxL01zdEk5NlJ2TUtRREFTZTlxb0dVckF0dFU0RzRVeDZDdHh6N0c5OFZFSFlrV3grUExzVjlNaGVlMUpnc01YdTJ0Zk9ubmFkWndzcmJtUWxpRlJ4YVRqUlZxMVVtWWRqZkh1OGRNZVdySGE1NlYxWWFEZjVCZGk3YUtIQ2w3THJOSzFjNHRxc0xxRjNIZXYzaC9oV1hycUpnMEFNa2k5ZUk5U3lieUkzRkRPYnh2cFdVMDBuYUlLaUt1VE9uK2lscXk5NVRXTTc2cytpbExyOHN5V0VNS2pzU2V3L1RQY2hxWG9HMjNZTzZXZWlZdndCNDFSUllrbk9wcEQ0QzI1YXkyUFpFc1hxVDJ0NzZpSzZxYlFXMGIrVElmL1ZBZjkrRytuUGRqSitmTUZORFRjbGtOYWV0VjNjYjEyY0J2TlJaUkhSRzl6NVoyT1hGK0h0NlZDZXFVN1QxNTRsWjJpU1R6ZE1PN0ROWkhhVTdsZG1OMEJOSTQ5NDVQVHl0bjQxcUtGdFpvNHJLQytrOVZuUW9YN3FoREVhNVBoQnYzdFcxU3EyVFVPd3ZwcExubW9kZGVYVU9yUG02eGZkWjg2R20xdzJKa0lQUitvenZNM29rc3BTMnVuQnphRHk4MXY2aVFrQzJINTVwK0tmVVRtNVY2Zm5JREFNNG51cHM2WTVVUTNUbnRLZHRycGJRZGxLeWtvMkdYTTNOYmpXNTlSN2JLdElWTWkxczl3NDJZc2N5MVhCYVl3dlVZT2RiT3dGcVVlQlU1eGlKWWdvV2VhYlJ1RVluMksvTkM2czBJOXp5OG02TDZJYkJQOWFiVk1LZkQwUGw1cGxIcXFyUlc2VmpTTUk3UExJb1J6OEhuOGFickcwbjVJUDIzaVl1Um5wODg5RXVwbjlUNzU3MkZsWkRWRW1IMEZzSXpSTkZkNTJINWxTdlI4a3pETTVZRzJJZ3o2Tm1MOEhaelN4TnplS1p6eXhhRFZkN21DdmgydUtGcTNPYWFTOHU1OE9CMjFOM29Vb0hCUjlBQWRPTmZCaDNEOHU2ZkF6MTJWY29uMlNIUUNCcndqZjFpNm9WN2FZQ0JjNXpBc2xBbnlKcEttR29QQVIyOVo3TXptVngvQ2Rwem5rY01CYm95ckpGV2lyZG9tQ3QzK2tqWnB3eW04KyszcFBtbmhTNDUxS0lMMVVqODQ0Z3Nuem12YmFSaDBwejRudTN4U1B4cUE2UVkxOTU4QzFEY2dhT0VQNTZqVmRJY2poR2w4UnFsZmVPdmRNVmIwdnZpVjJXMHJ1eE4zNW9uSURvcjF5bkZ6Rk1abE1hVHZ2Q1hzUTN6Tyt1KzNycHpIVHZUdHMveTgrbENmeXVyamdjL3pCenRzM29YZkJ2ZlBWSmFWaDN3d0FHNEYyZHNqWTd5dWlMaFd2eVozaUw0SWlTVEQ0ZnhYdHh0WW52cXkyM3JZVnlDSldsWlhVVFNYWWxSeDlDY3ZMTUhNdEt6bE1aTFB1NmZIbXkwdHFlbWxQRXVRbm1SODZld0hGZXlMVDVycjh4b09pbXZ0SzArMHRSODVEM21WMERQWnNZZ0FqWjNtbG9sZUwyRldXUHFKaXBtdE43dVFWdGVYUFhFQ3FwaklORUJnOGEvSmZTWGUxMUxFNHdCc0FyTWdKNjNSckdyQWdRa1J3SkxQaEg3eGRRZk1PcXVvNmZ0Qnk5R2lsSFU3RExDQWxydlAvSnJTYVdNK3ZrSnB0QkR5TUoxWkJ4eXAvUTh3WWhsNDVwaXRVbEwyd3RGdElxaStiUk5iK242SG1pZFZUNUpTbjJkMC92THFTVXhEeitrMXUvVnBoNUxabm1UZFRwdTlWcVlQRjZzaDM1SzJibjZZM2Q2N1N0aTk4VWlOcU1RcnQxUDNTWnkzYVVUVW91cnhESmlPak4xR2krekc2MVNIdVh3QkZzeGlzUDBwcHE2ZkhUV0gzM0ZaWktFUmNQakhWZEV5ZnU1bHMxQlJlVkdkR1EwL21xaUZsYTZuNVh1VTdKYkl6MkxudnVWeWlaakx4ZTF5UGRsT1VZZkxUYXhnWW5XWUl5blZXa0tVWEt1UW1nNkdyWVBIem5HeHR6dmZjcXd4dHlORENWamxqN1hkQTRKZWQveGUxOVFhb1dXTHpHT0dhWDhYT0hTOWRtcEdZeXdqZHE0OWRudlB1aGdjNVNWaGZpaUpQNXpPMlNOd2lsSFNaYTJET0hpTlk3R1l4OU80UmIybHVnc3pDbHZQYTM3ci9BdUUwWnNWNTFQWklIa2FRVXRYUEtyUnVJZFpOcmczTzViOGlTNFBKNHlrME5tRXNybTAyY2k5eWc5SzdYYjYvelNxQVRzcjdYc3ZNaVFOZ1lBek1Xeks4dmw4Y3pYVVNzdFRwNjFUdlRLYmZFZUgwZHI0N1p3dFJ0aERRaXRiSzZPbkhOSTAzTmxnTzhtc3ZXUzBsakZMTW1tNFFBTVovR1ZzYmk1b0tUL29RaVRhTnVIanl3OWs1QzJtUldlYWJSNFhET00rNi9NWFRlL2c2WE5ZVnJIbE1KdHRSWDI3Nys3cjdRbXp6T05JdFNnWnk3dHg0SzBWMUNNZGI4cy9YTS91Y3JEdTBQU0p1QStYTjVyeUZXTzMzMk5zcE5SZHZGZ2NUdytPTHB4UGFMK1pNL2lXN09qeVpGUFcyZGFZK3ZHWTg5ck1VWTgwK0MwdXJhZncrV2hhUzFMSWRYQmcxVW1VTkFhcXlRMDVzSjRQWGNyYkJlL0xZc1NBSk9JTGptWjlQWFBMVGo5MytwbWNFanlIcWNhclljMzNIVksva2Z1NEkzdnhWUndQVDE3T0U5aVV3NExUUFphVDhIUmVSaTlub0IyRFpiSHMxalM5cGkrRnFxZm9TUWJjQnE0Nk1QS3hWbkVyTStuTk1aNTRvR0JwS0N5a2I0RnVyVG5aSTNxME9LNjhzMHZETUpmaW5wNUxwNXgwMXZCa1U2dEZkNkRWK2FZc2oydVRIMnd3ajZjcDVncFd2aVdlWG5sT0w0STBTeFZvK3JQeWZaVkhuRndPZTcvd2lhU2ZsUlVuT25rSEdjd29rN2M3clluZmNzdktid29UMG5ZY0tQZTczSDhXcU0wZkpGQlpNR0ZBcjNkVlhtSzU5Yk9sWU5yd1lGdDhyMHJkc3dWQUo2SDVQblFOTjcxM29nZHBGb1dBS2VDUWZjY1dyZldXcDlwWUd5QkpYam9NNDFMV2VHWlJvdmlpdTdmZWZqMUtJdlZKTVZUcHdEVi9wem5COUJiK01BYXVCamxQOU80ei8zMWVPazY5dnRrTUlJQVRNT3JzQ0tQWWxyamU2QUtlWVlaV2h5UFBZcGUveEQ1UmRBSUxQbnpyQkY0ZzBaZW1ralh1T2NyK2h2Y0FJK2JNZEkrVVhsbjJNRGxLSU91c1p3emViMllDZ3Q4Rzd5L0N6dWg2UHBhbW5QUnVSaStEVzd4cGIxRDRKSGxLWHliTXNXWFRJdjNGZ20rRUF3QW5VVTJWM3E3UjlLTDZ5TFYwS3ZobFR2T1JIbSt2NVJqV1JIcGVzUWs4cDU1Sm9VWEpxNldQYnB1MWJKZzk5VWhtdlgxWU1uOE5iUjBQeTNHVUxyZi9sRi8xcnhaUWkxSEtpRTFlZlRVbm0rMVE5WlJhTHR3UVplSmJSTTFUTndjbzl2ZVF0VkVpZm1WdHJCNS9ubW4weWtwY2pkZXF6WmpjTjFnd0M1VHhUdXQ3NFc1UjA1d3o2UnQ4eXVnL0d2bjZxK3B4dTQ2MW1GWkNOTlVqTFUwbFU0VHYyWW9QWDF4b3QwLzdlbFJQbDZTeTh6a2o5MUQ2R3ArT0JYNHdVdXQzRWt1enZOQ1hTWXZHQlloVTlSaStsaDV2TGJVcmJXVlJyZERRQTVkUm5odVFYb3B0V2VaVjV6cDZiUnRiREtyaU4yMWN5N1IvRE84cDN2aDdmZ2ZzbE9HdHF2TnBaZkNScElkWld2N0VkWmVCQ2RIdTkrazFJUEtwamFSeSttYjJOeVhSanhmT04zTGl2cDBXVWd0M1M4QTRHcTBtVGhxTnpacWh3T3V1Q2s3RytsZGJsWmEwek9lUnVrTXR4cWR4aFZuV2kzY205K1RWeXJMOHRHdC9Gd2FTVGE0Sjd1OWhlUm41R0lsZDhZRE1JMlpxL0lUcmJUWGtkRGlMM0VxN3VMTmNGNmd0VllsbDhkUHBEcklnb3d0T3ZQaG5DVG1wZFN0UG0zUE5BcUpiK0hUWnR6VFVycDNrTjM3UWI5cCtlZW9zYzFDcVE2RjNMOVdMKzhYWWZIeTZrUXNmemc3d3VFWFB3dXYvK3daTzF5NEpIdFR5Rkw0RitOZExoVG5OYVZ1d3VodXN5WXpPZU1hdlFqUXd6YVgwTGlYNGRtTzR0TFI5QjRWS01wR3Y0TlJPQmM4ZE13VjhXS2YxalBldmM4YnVOVU9ad081cmUvSDBMb1ZBWjBpOG5veHRXMXJBRnhBaTRmN3pXeEtJUnZ4SnhONWVBMEFFTERtTjdnSmpDS21PejFRaGtGV25CajNtS2lsTTM0bzBxWlh0Qkk5YytqcjU1N1F5Tyt2ekVWKzJtaWxqNUxOMkZIZFV3YWxHVi9xbVRLamVSdkxXbVpPM1dseVc0OWpkTTUwRnptTjBtOVhTaUIwTmkybHJqVFdldXNTeVgrQ2hpN1ZIOXFnNjZ5SzlPS2M2NFc2OTF2aG5wL2RqSjZuSyt1NUZtZE9DcmMyQVh0YmxmdVZmZjI0WXlLam5aMHYyRGVZb1lXLzN0MS9OTmhNa1dqUmtIeExZa01TZ0xzeFk5WkdmbHdZalI4cEJ4WUJOQUYzNHJtY3RGWHFsZzIzQ3l6QlE1OXBXSncyUDcveG1ZYVVqbnVxWWYxNElyYlMvV3d0SC9kdnkrdUxxWExlTnNVOG9nZXRuVkJ2K01heHhlY042Sjkyd3d1bEFOd0VyOExxMzF3ODF4VzRBV2Q0VzlFOUZHaHVBTTVqMUI1b0RvU3JnbEtDRWdDWGs1bnpqTTUyQWM3ODNkMXk5RzY5UUljYytOdVhEQzEzT2RMeExpZlM4L0NUVm52b2VpeDZWSTRWN3NIeis5RUFQVlVCQzlMN2toSDQwTnFXQTlyY1VoM0ppUGRVNGJybi9wRnRsdWdaWVZtUVVYNy9YLy9PK2YwMElML0NXMXZEMCtwV1QwbjM2WDJrVVJ4bGVtVVkxMXhibGFxTldkbEprRW5EdlhYU1pORVJ4cmVSOWJYSE0xaksvdlpVUmxJbVQzY3dQTU5YemNpRjl6cmgvdno3TC9uMGR5TDNOU0l1VFRuZG03V3M0UXhuZmhDYUt0WGU5bnFuOTNvTFZQZ292SjdJQ2M2dFpGSWNKMzJQbXBWRkNhblpOQUh2VFhublVINm5sa3RxUmFyZHlGSkdlN0Zuek9jYkdVWHVLV3BRVmRJcHBkMzluMVB5bVRsbXZad3FlNEl6c2ZyUm82K2k0M2ZrMkpHMWg1eStKcnErOE9UTHdyWFJ3eU9PbG0xZGd0SDh4WkduMVkwby9td2xLWkVLbnBWWEhkNVl6QTNwV2VkSFpQUmk2WlRXdlFndUwxYzJsODY2dHVwU1NKaW5Udng2L3hOYjFIQ2FsMnJLa3VUOWptTXJSQzJVcnc1eWFnREEyWXp3UDcxZXBVZGIxM25PMWhGWGVyYW4wTnFvMW8xYUxrUmRkdFRQOU1MVk1XcDJvLzYwZHA5SnlEdGl3b0cxV0drN3B4NnpHR3RnR2pPZUx3UTM2c3h3aG1pMXZFdFBhYTVsZGZkUUtTZ3A2V2Q0SEdjODA1RHUxMWUyNTFrY1gwYXRESTJ5M3M5Tk5MbkgwUGNlOEwvLzV2d3BxeHljQ0U0eGozdW1jZHdoM1V2ZFB4OU5xWFV2b25ibS90cXQ4K1Z4ZnBTd3YxL3Q1VlA3aTY3SEhML3A5M1VBRTdIOGFFcHVrQVhXb2RmVVcvRXp6QnduK3d2RzJBalB3Tk1sZFJtZUpmY1c3MjNpNkY0U1IvU0pCbFNNZ2VlUkJ2ZzYvc3picXAreHRRQXVJV2pjSWordHlLbXRTTTlPaEdSZkhqOTNKUDlMY3l3QWkvUEZWS2pzeTdBV3hlaVc1V2p4YmFHcnZneDBLS2pRMVBWMVEyWFRWQmNia2U0R3VQSWVudVlieGU1M2tSRm1jc2tjSEZtbzd6a2NDT1B4NWl4blhGcVo1a0NaY3pwU2UvbTB1Ty9iRys2aHRjd0wwSFp2RG1tRmVwZm8vY3k4ZjYvc0svdEFhY2R1STlNMm5ybWZodGcva0tBbG5ObXZNOG9hTGZPTU1UWlRUdzJXZDhJRHMvMFVJb1dGMVpSMzNKOUJHWlNtSjMxRWx2VHJnc0pjOTVURGxmRUYwR2E2Q1ZidndzWGZ1R2tIZndWMFJYK0NZVEk1c3c3NUZHOEtBSEF2Nks3T2ViczRPaXZ0TUlBSEFOZnMvcXl3blFNM0g1ek93NTlwdUltOFF0RWpxNWZvTTQwV2hhT3RoN1cxYVhuOVZ5alQzRVB0MlF1aytUSWIrajZKTUdlaEJQbitSdlVxYmRsY3ZSQmFkaWxrNUI2b0plNmxIbXN4N3huczltLzlIQWhmVTcwcDFHL2hWQUw0YmthN0VaSjUwclpqdjhCL2pqU1hkTHM5bHIzT2gybjhwYXo0U0FPOEdkMFZtUWhGZDRNVmlheit6b0txU2xBQkpUSU01NHVwWUJrOHI3UlBMdHFibHYxOWRoV2Ywc1RxdHZ3V2NXQ2xlai8rZDBKM2dpdkp3alU2M004SmJTYnBLNi9xNFBLdDVkUmxaemozc3hzdXZmZEgxbElhajh5b0RLME9Yb3Vrdm5XVXhtSzFiU2JCUmFuTGR2L1M5cHpWcjlMOWN1MGhQN3JpcjdNcm42OTFZOXNMUzZsYmF3ck9yT1JUN0E0OWJ1cDkzeDV0WE0yM1F6dk5hamo5UzR2U1E4dmp5Y0g3RHVieTVkM3JTSjc3OFE0YVRaZkU1cXNmeXhJbklmNmtxZ3k3N1pFVGQxWmZERVF3WDBXOCtCQzlPNzl2ZDR5Ulh2U3ViZDY4cnhCcmorVzIrQktVR1NYYTJsRmRNcVB0THRBTkxWaE5LLzZtNXZYREYvSkRwNWduYTlpalZ4bmJDZnRGQ1Bkd25qWnFHVk85Y3lpYXZpVDcxd2JlMWFkV0h5L1I5SVFXVytoZHN0WFhFZGVrS1BGZU4ySnpFUXVmelNMU3U1RVJaTjNtbW5qdXNLUllTM0Q1SStFdFpWbnowVHV3cGZyRU5QZ25uNVl1RzlkV0dtc3Y0clBHcUgrUXFZVi9wSldERFNvSEdaOFlyZ1ova1hUeWp6K1BPajZxcnU0ejN3QzROeDdOR2QxbWkycEl6b2FMTHJsUXpzalYwSGwrOU1YVW5SOVo3clk0VkZMWjNuQnZXUzFMNkMyZmRWK1cyNUdFZkZ3YXFVendYWXhTSnEzTFh3Q1dvR2ZOMWxoVWlTcnkxTDYzUWtYNWwwY0RXUEdaUnNSZ1o1SW5LaU9DNWtFV001dTRFNUhwT3ZwM0QzZS9ydDdueXYrdXF2blZkcjhYUzlmbjJZdy83aGxzZjNIcHl2dCs4aTUyMjIzWTBwWjMrRjc2WHJLOGI4RmhQWXZsK094M2dPbjByQmU0SVFXdVFWS1ZXanJ1T3VLeldyUTgwL0RLcWszQVRmem5pSVhVdXJQbmRxM3VsOEpvK1hVNjd6YUFkLzlLczdCWmtQRjQxWk1iMG5oMUJqaWQ2Tnlxd3c1cC80M1lIY2lkZlJsTFZxTUJzQkVHOEh2OEZqdTc5QlhWRmpkQ3k4L0ZmVFhSQnVQeWVxL0JnYjhTQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRHZERjFOV3hUdTFaOUZnVXovbHkwd3YwbmdiSUg2b1dmbXQrZDlCRzhaMDZnTU5ZdmhUcmtFdnRLQXZ1YUtTbm9KMVdVNHpyaVpQS09wM0hJaHR4M2hPeTFrZnJCSEtpYThyN1kySG9aNlpGVVpHT3RnYU5GZDZDdDBldEFXNFpNQzVaTm83YXNlN2ZlOWFPZFlTZjQ5Z3A0WnpWZmF5WHR2NjcxQTQ3dS9lZE5sSkphMmhaNGQrQ05heEZCOW96ZnFVNFM2WjFwbHQ5UHEvK3BUcjZsYUhqZGRwZDB6S2tzM3piSEJLdlE5MURpejd5eEhkVTVSQ3VqQ1d6R2pPc3ZtV1BJbWNQOXBacHBkdU9JaFRHRURWOXpCY1ovNXp3ZmZBckNsc3lJL0tBckRxck10TitSdEc3K3N4RFgxc2U2OGJQYzFvalhWbzBmVXUvMXpxdXhUL3oxQ1U2Unk3UURTYUNRU3FLNzV0VFRJVVc4b2Z3OVZKMW42SzJrMG96YlRJenVRM3BTNmwvdlJMK3c4VFhOcXNNR1VQcExYR2Z2bWQ4bjBseFhrZjhqY0dVL1JnVHErQVp2NjF1Uk1SRnNRaXFqQ0lzeWFJamN4Y21DQm1wK1daNEcvMTRheFJaZzBidFRLUUhXMjFkY2FiclFacE0wdjFLZFZGOFduZlpVZ21GdmVaOG5aejRyN2NVNS8zNHAzVm15cUJ4Zk80U010S3lITDBzQUFCRjA5NldHeEhWak42NlNHVjZWbkN0dXgxMUdxdk1KUmpob2xwdXNXVnVMUmVneFJYdzNsZlBJNDFJbUVkdXhGZVBwQU5yb1M3OGswOTU5bzZ4U05rWVorQnlMQytpQldtaDcxK3RtRkdXSTJIZUJrbVFJeE4veGk3RHJHY2FyZm5xT01rSm9PbWthNmFzOTI4anFzdkNsQ0UxQ3gxYWVaL1BjMWM5S1Q0bEpiSitsOWI1bnpSOEwyY2lwYkJsY2VtMWROeTk3TCtjYXZjcjNZdXd2b0lhSWJ2MXp5aWpxZDN2bHhQMWVVYXNZY0FjNkRDT3FPY1JlUDNwWk5SRk1ubWVzSVdKTkhtMGU2UnBhWVdQSUxxWFpDMlBqcnZTZHRtUHg5TFhXcnJvTTNjd0hPL2pZQ21lVXBpTC9OTFA0blBjT2wzQ2tBQURjZnFONzkvV1ZHR1NYZkc0RFZ3VnZIejlxcUJuZTJQVTB1dkI0SXVwQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURBQmI2WXVqclMyOWZSWTJBbVZFVTdoSWhpeFhjVGVUczlHK0dORlkxOERNSUNoMjdkbkZGSFdUd1o2d1RuU1czWmMzcVh0OXM5Y2VjTmpaYmo0Nnh6eHB4eTZrOHNGZSs1THNWNXZZVlp4OHdWUjFtUnVrWFBSN1BpblFhcjBEeDFYWkpQaGhtdXhkTXl1V3QvNnh4TFBKNnNPZ3JQU0JxT05ZenJkTnAwSzRwc0w2ZmM4QVZZYXNtY1d4VkZ1dkFlZHhuUmtWbElsY2x3c09aRU1VT1BHdEl5ckZFclo5MW5qOFZ0b1hXMVl0MHZwNCtqZURPTmFMT28vWW5ZQ0dmOTZCY2lwYkdWaFRabHZ0UjQrRW9qY3dyaTNpcnQ1NUIxWGNzNVNqM2VCWGVZbW9SVXR0OFA0WkRtYXlMaFBXVkU1M0dkcnk3VFU1ZGVIVEREMkEzU1k1bjg4VFB1eTNaWmxWRWNkYUN5dHJueURpYmpnZnQ2YVdNVDBTK25wa05WK0xyVWMxZXlhYm42ZWtBeDlmaHZxbmxFWlh2U1I4ZVNaSmR5SUUrZGo4WVhPWi8zUzZtRmtmV1R4K1ByQ2tXYjVvbERVc3c1K1RDbXJjZEMxazFWaWkzTU94SmFSdnZNbVhFdFhFOFVSM3B2SzBycmZjMjNIZVJYc21rNG1iUnVHbDVmVUpNbGVUdStOcFg5ckU5NEVkcEdtczdGdVAram4wWHowOUJQbSs2LzNycXZ5ekZ2Qks4eUF1Q1owRm10YWFRNlBVMWJoLytWSkIzQ3k1VHFvdVZ2dFVwSmtHMmh1Vk5Mc1lLVFU0eHJ5MHpYWWRUOFNsakxYMmtBYTJZMkpkM042QjFVNER2d3VLSjErQWhGa2h2S1RpU1BORWNBR0ViVTBIaldlWjY4amZ4K1FsTkxrTlM5d2ZlbHNmYTBpbUJwTmNBdGFiM3JXTytPVFV2ZkZLUE1hUG9pYjZUV2wzOGVmcnd1dC8zVUxUcExrdmY5bXNrKzN2SHVzK2grU0xRODA3QjdrY282bGxwTGtzdVdPWDRobGNvdFFyNVBpcHJqODZSOW52MFhZNlg5Q2hwdnJUNTZnWEVOKzgyZWRRS2E5VHk4Sm9IaU5SRlN2bHArSksybkRBbXFWRzdPaU9WKzY5YUNwL2trVDYvVk85SFMxZldDK2hnQW5TdXk0ZDZuQTZmZzgreVNXMGx3M2JndG13NWZTczM2ZFVoSkFLQlJoTXU4KzZkSkRYbDNJbnEyMWg0L0ZTei9FRHJDaEk1VGZERVZuQWJtSndBQWdDTlhXZ2RZSmdEQVBZQzJBcUFQekNFQUFBRGdLYXhnOWMrc3c3TzhIUGgwQUlBZW9FUEFNUEJJQXdBQUFBRGdpNENEQlFBQUFBQUFBRmdQckZUQTNjai8vZC8vdVE3eCtQcy9lSWYxRXFLbitXeHgwWk4yR2ppZStDWFRjdkpOaUJtRk41N0VFVG5aNElSdUFtY2luWkxRMHRFbnplTWw4T2d4NzBsbGc5c3NVb1VXV1RUOG5oUi9zSGk2cTlEaGgwYjNIR0hYT25sYWo4bWJnVkhta01Ga0hlOHk3bjZ0d3dEdDZiMC9lWFZtWFU3RlU3ZzBuTFZ3cit3blVod1IxWmZaZnErVDBaN1dFVW1lT2FaM05EMHgxNW9MY3JxV3VXUU50bzJSZzg2cngwZnE3VWJiOGU0Y29jeGROMHMyY0FWbU9scUdvZkoyMzNZQ2VOa240OFM4NDBpYjIwWHA5Mm5OaENIbUdieUlqTG5MZHlQbTArTHFpbk5wUDVuR3FpbSswQjZSclo0OUx5bWxzWTFwcFl1T1kwcVBzK2U1WDQ4R1V5amtQaTFYU0V0RDAxRm1tS21lcGxUaVhWVWdjODNqUm96aVdvMFlMWDJrdnhudDhPUW9tNXRUSS9jaWVtUzJNc0wrNm1zTytjc3FpY25uMUVmR3V1ZjQ5WkxDMXFYT1cxL3hWaTN2VWw4enB3RDRmcWhYSmNXZkxkdTdYZGU2VW9sWUJxOFh1U1FlSldvdHJqME5JdVgxRWwwMldHWDNMQnVTVTFaeWh0TTQyYlNEcDlEcjNHQzhnRnN3dzR1LzRKbEdmcFhwdFRPSmhuc044YXFlaFhmREpnbnBMSThyR2ZrOXhMMjYzU05LemNjeG5WbFNaczVDRFpnNkpIMmRQQU5ybC9KenUzUzl2MDlKdy9leTlIME1xMUdQWFZCSWZENkU1OENkNlhqVGdUQmU5WXVtWHh2djlPNHRnK0pkeTNKcG85dlFYUHhEeHFXMDdJOXF4a2pUUmIySVNIZDZnZHBwd05xWVE2TXVTK3NlNmU0YS9RdEdFMTBPQzhiQjYrbDcwa3BGOWFSLy9OU3gvTWdOTE1uYzRHMVRBQUFBUUFCK3hKbWd0UUVBQUFBQUFBRGdrVHh0T1lqbDc1ZUNnUXdBQUFDY0Rzd1JBQUFBQUFBQUFBQUFBQUFBQUFEQXBmeWR3Sm9NT0NSdk5uV1ZyR3BOcjNaMnB2RWNvVlBJdnc2eHRXeFB1MlFqZktGdUJoRzhSeUo1T3ZwSmc4QXpmNlY1Nm8xdllHWVJuSXBmcjh1dE96WTZ6cVdYTXltT2xGVXNZY1VaMWtJV3JpTW54N2IyYlBBTXFOM25kb1JrWmwxNkZKZDBSTisrWkhxYTZTZUgza1lqdnBRYUpUTGl3bmhQME5FY2lkRW5sbis3elRFVnVOSXdadHJvcjkra3M2NXNPZFlYZjJnNmVrSndFazdwTFNHSHhEb2ZzZ1ZMUDFuR2YwUlp4WWpuNVB6OFU1ajhLYkdmSEt3LzllbXErc2kydHV6VHpOVmNNSytZWExGRDBwZFJTOW5sdEl2eTEvVm8yK1NVZXl0WlJIbS84ZnRjWmRnY3E2VzN5dERHa0NkL3BBNFIyVFBIYnl2T1VmZnVjSktlK25ac25xUWpGZFh4U2RUalNhT3ZjYnJOdFpkT1BCeklUK29RTG5USTE2YUxNMnhYZU5JZE1pMmZSejVYbDJESHVzOTFsalNXWlJQckpKc2R5L3QvaTJZRE9kMmhGQzFoYmE1WlJiWjBQMDBuZE92aHk2ZTJtZHFKNDhxUWhueGtaRW05ZklWR2JDODlzdlp1eGRvTTF1YllDTitVWTlSZWhKV0hvemhrV3hJS3lhMzdOSUtHMk1YK3lDanNYc01tbTcvZm8zKzFqeW1zc3FCckt5b3RzN0w5ZWh3QXNBcGVMMnFqeFo0YWJvUVliK1dUUEx5UmRyN0xoL2NLOVFpUEx2YzhMcjRublVjR2xlTjFJMmE1RUJ5U01iUWVBWUI3NGgxek5FK0xncFBHbGxVV1Z3N0dIVGlkVVd0Sno0QWZvUFNsdmJGUzlQakRQRFdlYVhSdG50QkNXL05UV1VXNWpqb0pFYlNOcURGT3hHKzNNYXZnWGJjVXBrcVppQkxXb3RuWVpPTHFWUDIxWDh2elpZeDhwbEdYSUsyNjlmeGxsNHZtMytUeXV3WkhhYit4Ky91aDkzbDhWbXR4Yk5NczdFWFFQTGFSaHpGMTR4MWEydG9GUHMxNmVCZlhOSDFyT1QxcEpUODZDZGNwR0w4WU01OXBlUFpNNnV0STA0M2VpdGpLanl6TmdKUG9IQUpUNEpwZGUyTGxWY3VxbVNWS1EzeTJpakVCV3VFTVRQR25GOGQ1VVdRYTQ5WGFqb3ZzUkh6bDFQRHVUOWJ4eFpEUjRrZzhISHd4RlR3TEtBY0FBQUNQNVRvakNQTUxBQUFBQUFBQUFBRE1BcXR1QUFBQTRIUmdmZ0VBQUt3QTdCR1lCZ2JYZk5ER0FBQUFmb0ZGQUFDQXhZR2lCc0FFWDB4ZERlblZkZXNWZHU2STNNbFlMKzZmVkExZlplbzAxbUZpVWo2dHlDS0xxVVZwYWVwd3o0djdZRUdzb3lob3VpU2tmd3JXYVI4dGp0ekFOcFQwbUhmK1JtU3YwZldqTkJPWGpwNzIrTHF1VDNQTlRGbEZNb0llUmgxVmFQV3Nab0NMa2lkeVQ2UU9tWXllL0lyN2FhOWl5WkN1cmY3VnhvR25qZXB2bUZ3MzRudE9DdUprTmQxSmk4NzNER2R1Q0VyMjUzRjJwK3orVWZWQTJTVk0vVjZ0ZFVSZmthdnh6cEhWSFBJWFZPVjYwNit2eW5pOTJCNUs4RG9xN3dldjd0ZjB0aEwvbmx1T3VycHZaMlJiUit5VEp4MU4zMk9uNmJGeDFBZEl1MnZKeThoRWRESFdaM3JOK0RsRjUwc204VlRLL3VUclkveVdpcE9nMlVycHEyRXlJL3JSNDBkRThsdWNvWHRvV2Ezak9MSmlxUE9sZFB4Q1FUcFc2ZUJtV1Q0ZkxTcnZzbisrYmtxS0tzZHBsNnN5Zi9KOVhQZjh6aU5YWEt6S0lWclYyb1dzSDFLc3pENUcySjlSNVhvM3NwS1ExMXJMR05sM1JSVWpieVovNWsrMnFPcndMbEUwZXJzbCs4VjFmOXgzbTJQN1N4cTl3OUpDamg3K01scjFjcDIvVHQvajQ5Q3lXL2NpdEx4MHI0WExTOU5yOFZvOXBNWG5ieDJrcFNiMVdUZzFzS1dUcC9ySEZ5czdEODJuajQ1My9aRzNEOC9rYm5pSmhTMzdlYk1OZ0RQbzBhaVdtMkVoNjZ0am1GYUhsckpHcDI5aFNoa2poZloyTUNjdkpaOGJJUTNFMFc1RVpMQlJ2Sk9scHd5d0h0N2xZVkh5ZU4xRjcyS2xqcS9ISmNZYnVEMGxlQjJWbDVMNzB6NkhmWFNhUHpxaGU1Z3B5MXJuV3VsbytqTWNDZm02MEhwYit2a1FzZTIzdmRhOXBML2Y2K2dzclZsNXhmMmI3NS9YRlo5WHZsdHRMZTE3cGxISVg1azhSem11NTdkclBqOGY5d25YNmxTRXNvN1BWL2Q5a28xOTNQMU9SZHJsOWM5WDdFV1kwRGtsTlhreXdrY3Qrc0E1RkNNODBsK1NYcmJXb3IzUE5JcWpMamNhZDVIbGhyYlU5cGhJajJiMVRPbWl5SmpwUlVqWGo2ZG5UbUh0ZVJxOXF4OXBydFhwRDNtRVF1a3lxdjVwTWdCZGVKZWFXM0tTL3YxVE9FYW1lL25mR2YrbnJQVEZsSTQwbndmQW4rdVUydnpJaDBHM2dQSEZWQUFBQUVBQS9nU1l4OU5HRjJZVEFBQUFBTUJkZ1NjSHBvSEJCWWFEdGZiNW5GZUhES1VCQUFBQUFBQUFBQUFBQUFBQVlBTFlmUVlBQUFBQWFBZGZUTDBMM0RFUUY4RzlFRTRQQmpxOWV0cXhOOUhLT1krM1VRL1FxbzdRNFY2aXQ3aXdlMEVQbnVPWE9KN2E0ZnBoZ1h5YW1jZFFkVUxQSmJ4ZnQxcG5mOUZ3SzEyTm9JaC9qbnZoUHM5a25uSFdjN3hKdEdjaXgyOVp4K054ZVR4bEMvbUtFbWZLREI3all4NHp4aG5jTGVmK3ROSlBMbnFhNmY1Nkp0N1I3Um5WM1pXZ0FqMUhmOUU4a3V4UjArQnVITm95dW4zY3M5M3M5Zm8wWS9jNS9mZTMrL2R6aEhiZzhkeGZmbTU5MG52UHlOSUdYNTB1cGJaQjVkV1pyWEFMZ3RheXFmN2Q3RmppeTh5RnplYkQwa1F6UFkzZXN3dzlNTDdBSDFFeFdidFdLdnRSTFo2T21MeW5jdXZLVTdQOHVVcTduWHpOZndGc0x5dm00UXp5STh6d0NLUEhZMFJQblZHV04yOWptKzhHa1hCZjc4RkNqMWFrOGZ1SVFyNDIvQmFuM1BiUlJTZDJoMlQrZkVGVkg5RlVkY2I4TEVuMnlMSEh6ZWdlK1o0N3BXVjR5enQwdUJCUDB4YWhEbzR5dkVkMTlwaGZiL2RxVFd2ZGJrUVdJemZ5NWQ5M1hFbit4RUUwTGNSMXdmM1IxNTV4SXAzVHU5NlAxbE9iVEZSbWI5MjA4cjExc0tSWTYvM00vS1dsNS9ZUStIVVBYVWNkdjVScXIzNk9JKzhvQXdBd24reU04OWhBeWJzODdsL3U0eTE1aWFsTFZGWlMwa1ZjcVFnOWVTK2hkMWs4NG9hOWJrUnN3Yi9QUThNbG1ka1pUNitkTGo2NENXMkw3VS9lbmdXRTlrekRPNTRCdUFXOWExQ1AvSlRlazRqdUdhb2JlbFhXUC8vU2pRdXlNU2RtWkM3TmVSbzFYQ09KeXV6eGxPamZsaXpGWUJlU3YvQnlmL1pkK1c0WDltdkpGMUtMMk8rOGwvcjcxMStKZjZheHp6bmptWWIvZVdZUjh2T2hwVEpNY3IwemlTOXFIVDNQWU9renFmN0R0bUEwM1ZpK3V1VXYwM1NhZkhUTGRYZ2ZlVWpQR3pUejVkMTI3WDJtb1kybHJNVGRGS3U3SWtzU3EwbUtNMTBrVDIvZFpucEVYOHVNUnhwYVB0Q0VwU3BiVmFObis2cCtmRjMvdmlFTGo3ZGJkQU1BS3BZZlNjSmJ2dDdyblN2V1hFdENmaTNON2RIOFJjMDNoTEp3UTVzUlgwd0Z6K0pNSlFHRkJBQzRIVmNvTGloTEFBQ1FnSVlFWUN5WVV3QUFBQUQ0VHVEbEFBQUFBQUFBQUFBQVlBVFlZd0FBQUFBQUFQY0NIaXdBQUZ4UC91Ly8vczkxTnNUZi84RTdyS2ZpUFVYeWhLSWpKNTVGWGk0ZlNxVFE2TWxYd1lwN2lnUmZnSFpjQkRxNkRldG9MQ2tObDc2eER6eW5nTFIyTDVWOWlhNE1ZVmtEYi80dFR6a0dVOTVmVGROa2JmTFloSWsvdWlRSjZmalRRTWZCbFdIVlNhc0RGMisxYmE2U3pSOWQrNXI5MXEzc3J1dVE4eGgxc3QxVVdod3NNSWJpaWJCMFM4K0owTG5LRmRFWmtteit0Rjd0bEY1ZVpqSExtRE13by9lOU1hSXVuWk50MTJUa0JIUHJSSE8yTGxSb1MzZ2RKOFgzMXFsRlJ0SmxDVU5OZHlOeWxhQ0k2U1Y3RkJ0Uk9UaW5ZbHhwTSt0YTdJRWhPakxUUUZNZHdpUUpxTXJJMTBxakhMK1lLaWIwcFp1Q3BTTmI5SE1TWkxhVTFhcW5wYnBFZXRwcDgra1JzL1FMdVpLalRhdkdGVG1TU1c2RXAyWHBxYnpSS3RFeWRnSlN6STBZWmZubjRCMmYwdm8zT2ZOTE1qenBaczdqU0ZtdFJNdG8yZlhuMjRHdS96L2hJLzFIdmxScDc4SG5WMlZUdnAxdVh3ditHZ0F3Z2xrN0ViVnNyOGFJYUU2UHZGcW01cTYwN2hpTlRqOWRhT2M2eU5XWW1veVdEcFRLc0xaenBIeGFuVnBOdk9WbWdiVVp0VDFYSnNuMmxJR3hCNzZPU1pzUnJxSkoyWmJ0RThNbDQvQXR6elFpc2pSRjVUSEVmbVg2NTR1b05MQWN5emhzeDIzclhmSzVuZU9YVXpjcDNIUEMzaEc0SDFUSHRmZytGVWMyNC9uMXZlWDhmRksxMytHbjdPMTZ6L0g1RXRmR256dmtSMVIwajhGS3Q2V0ZvVFh4VGwrUHI0OG1CajM0VGNZU1k2MW5aOThybSthenRKcTF4RzdCTS9XMWZGN3REVHJ3dUs3b2dPVm9YUzJFeXNpc080M2hBTTZERE9qaldpNGRCbVRyK0l6YTVjU2svNHE1WVcwdGVKYjNYSHlkQmtwRWhEWXgzallGcDRGNUNRQUFZQzJ1c0V3WFdzUDhzUHNGQUFBQUFBQUFBQUJPNXlucllLejNBUUFBZ05PQitRVUFBQUFBQUFBQUFBQUFnQVZiWndBQWNCMS9KN0EyZlVlVW5jNWwxZVdPVXZPOHpTNmwwOEtEVllHajg2WFVIWTFURWRvcG5mRzk2UWxidDFvSFkwUW96akF0ZkN6MERudmtjT1RxWDFLVzJkOGpKcE8zRlQxR281ZlJaYlNjRFZWMi84eG0zK3Y3VTFkWGNtcVdVTnVSNXJpWlA3Z2N6ZTNIV1lVNmZGUmhuekkrWDEya3VqUXFUN3YybkJKOGhvNzBsdDJiYmtiWkRiS0dmU0d3WmV6Tkx0dUw0bUVOVU13L3A0RmIyVFY3NUowVm00ejljbURzZUx6MlM2a2JNRDZYOHFNelJpeEtUdWhHN3hkUXIvbFM2cnYweHJnUjZTTjVXK3NpYVQvN3V3UEhkRVlkcEg2MGxpclVyV3B4Y1R4TWRpT0tJM0tVRjFVT2Z6VGtYWktlVHBvMVg3M3B0QUg4elhzUlZJYnRzSTN6WmJKYVNpemNVd1ozbjFSSFlnTVlnRzlreGpaZGI3b1JIdXlabnU0VW9USHo0NVBqSVZKVzczN0dGY3NMeTNjSDM4OG9OeXBhQnNZYStGb21iMGFvSXAzN05MWWdaMWdMTTcwZGI5bFJCZVQ1MVVoL0hYLzNTNDNQT0dXbEJhMzkxbGQ4WVdTWFlZNFdKMjlVRHpyM25ZUHBleWppODZWOWVDWjdDc2NScFkydDFzLzBLTC9UQVh1aWF0dmE2d2FnbGVobXhNVmpicWJIYzhZU0pVcnZjcCtUVlFNVk1waXhyZzJZUU9rTWQvMUs5a3FsQVlBSHVnem8rWTFjWjdxdlVaVXRXd3ZRRmNPZ1RZa1hVKytLcEJFR1RKYnN2RzRwcWlldlc3aFVRT3VOTkZRNk84TkxmMUhnU3FRZlVsb2REWDZ4MnU2aWR2TnU1eGJodXJYTWMyNjM1NGQwTGE2bzhGTHFvWitqQ3BsZTk3WityNHpaU0tOdWhFeUtkMWxmM0pKN2V5Mi9Yd0ZxN3lOdml5MHhHancySkdwLzRHQjA0UFhxcEhqdnc4U1BYczRrVFRsMHVHOUU1MU02SGs1UFA3MWV3TWgrbnJGQTRzYXJJMS9teDVabGxUUVBaNVFYVVpkeG5nL253VnViR2ZOMnJaYllzNUtlY282NlF2TjBiRVlVRXF4VUllZFBXZlZEbXkyNHVlVzIrVnlLV0FYL1hkNXI5UlZEcTFPUDd4N3hoQVAreHJ0ZmhYaE9JVnZYQzdzUjNuMkFFUmJkVzRjdDdOdFh3MjIwM2xrT3hEMmw5UzNkNEx1UGJJeHc3Z2V4WHMyM3p5V1hlZHhic0pSUVNmVVBTY3M3VFl2SENRQVl5Umt1UkVzWlYzaVpuSmJXdGd3dFgrWVN2SlhSMUcrdmJDN1BLTnBNcDA5bWNjWnJBeHFtNnJ0cDNKWnJlSWdqbDRFeEJwYmhlMWZBTHJ4TEdCZDNmS2JSSTl1U245bXJZcVE3UE5WZ2ZKMmNtYTNpK28rR1g5Ny85aDYzbzlYcWFQWEFqeVg2ZkRPVGZZSVM2dmVzbEZ3T1pYcDJXKzBTK1Qya3ZMdjJTVXBzcmFSMFZoaHc0Mmw2TlBHNjlKZ0diVkU5Y21OZUtwc3lRbDFQd0x2SDRFMTNGVE82Y1pOYkUzbU1CZ2FBUnIyYzZMT2RkejdEeFdYblRLNytxWDdQa0RFT3dObGsvWnFPeVVLV2cyZno2Q2x5NWJPQ0I0QVhVKytLOUREcHhLS2plYVpYMWZxRjhJbXJHdXQ1UzNIa0ExOEFPbFNIMjdpNUlTUG04emxENWF3ZEs4RkEvWGx5VW9TaW82MzRyWlBMZWI5RGpuZnlPaExqMnpvcWNlUlg0enkvYjdxYzBwSEcrL3ZhcDNEcWZYdEhWMlpqZUg5UmNtNjlqMFZuTnNEREJwWFY1TVdSeHkzY0NtOU5OMUxXUkMvSE1FOWN0T1JPZXNKYjRIOVNzQUpYakptWk1rZmg5WGw2WkE5T3Z4dFVqWE9vSWY3UFY0ZTNoemUxNjk3WnZaNHZwZnFMR09rSHo2SjExeXdTTHhraTZURy9KSE9rUm1QS2RDdGl5UnU2RjcwdGQzYmVFZm0vRjIzT2ZXT3JUZlR0M3JuMk9pSWJxVC8vVGJ0OFBkaDdDOGVOU2w0N3RkUmxwajhDd0hNNFl5VVQ4YVpXd1BzWTFKdnVFbWFZb1NzNzBOc0paOVpCYWcrWXBYc3kzM1dMVTR3NGFlbUpNUWhPQlN2Z2NUemhtVVpFUWUwTnJhOGtZZE9zYk5mbGRZZ2dXOFFBanV2ZmZXSGNQc2g0cFcydDB6OGw3L2NKWWlPSTc4OWkxT1ZUZHV5K3Mva0x3Yk9OSHd4dUNKaUs3MkRHaHZ1WmkycE45aUxUK2NxOWlOWW5zNVoyMXNKbmR6ZTBkQVBGbVVaemNjQTBtdWVNa1RFcmVRcEpPTStEQlVCQWVOQmcvVlRtaXBlbzhWSnFRM29vRXpkNE1mVktydHg3R0FCOVFGdUgwZkR0ZXRwdEZxYVFpMTdLbUgzZjYvendHYmpoSmdzWG40eDAzOGlveVdHMThRRFJyVVZHZGVVY3RPMFU2dzR0cEFITXlENjhuQnB0Ulc5OXJwcEVWdGtUQitvbGNBK3QvUGZXMGhyNXo2TW5UdzVkdWpXaVR1bXBFZThTUm9mY3R3MUJMMUk3SkJKK1N1RjgwY2M5MFU5TUpzNXRFWCtpblhjeVkvTnh6TnlLTVVwZnp4allYdWZOVVNhM2k5VDFsdGVYT283UmJueTFhLzNDbStSZlphZm5GWFhaUDZFbDlEQ0xsOExQYjIvOC9WamRJUFhxcHdIM0ovMW84eEJQeW5JV0taMDQrbk85ZlRtMWR0MS84L3dHbEtCTVd0TUkvcDRZcUxmZGVkdTB4cEhpeU5zNmxxVDFuckptaytyOXZ0MHNoQ2RmVlFvWFVTZHdNTEk3TzZjck4rNU5GOTJZSzdXYzNSOERWT1k5dllncjVpOU5seHpwcjdSdE0zVmdIK05LL3VpSW8weHBZa3Qxb3V1bWV0NW1wZVJqL09vZURRQlBKTHBWRnBGTDg4MWFOV2gxOUsxdTU5ajgzdnU5bE5IYldSNVpUdGQyaUt0REdWVTNjQy9PZEV5aVpRV1duZ0NzelVMUE5BN0xJR3VQTUZKbTcyNjNKZThPSG9Wbm55cllqKy9rNVJoSWhoYjdVaW9ua2o0bk9lamE3S2hRRGQybjA1Nm5iR3ZyODU1cHRMczRudjZNUWU4dnV4eXpMRXF6U211RDl1Y0Q2ZDB5ZzcreUp0NkZzWmJQbS9kczAyOXRCQ3pPckwwSWoweXJtVVpxd2hGTHIzcG9QVmhMeDRuT0plclNvTEduTUVwVjF2S2FDMFAvZ2tYd3FDdnZTNm1qbjJrOGlsYS9FVFNERjFPdlpMUkZQcG1sL0xTdExXZFVLQ2lYNjlhUjNRemR1QmgwOGNMUnNyRUF2b1lpaEoyclB4Y3hPRE9WSXdBRE9XVm9qdmd4Zk5TK1lNNzk0bExDTk5FTXpWMklDOXZhUVlXOWl2Nyt6V2NyVnZScVp3enNnZTFRUnRmdktSTlp2OC82eTQ2OXNub29xUXpSRFBiSjROL1c3MWZjVDZUTTN2b052TC9hL0dnUHpxSkZGa2Zrd1k4b0hUTGI4SXVjYWI5R0xmUWx2MExhUmNvQjJWWjRoS2duTWFLc0d6UERSYXhFejVKNXI0ZE9FeHQ1NmJLZnhubjdWc1VaRm9rSEFEd0g2WEZRaTdYbzhlaXUwRnZRaFpQd3VodHdTWURGWFg2TWNQTWYyNE9uODVCbkdzUHJkMWN2SXJvL1orMmRLcXZSUC8va2ZkTE1wTnNDWDdLS1ZWYm1EMStTb1d0emVhMXVqN2c3N0ttTTI0djRmVmFVbFRLdWFJc3J5d1pnSXIwL3FZaE1pVE5OL3hmNHliTThIRTh6YUUva3VPdVZnSlllQ0gzMEtsMkRvY3hTbFUzZGhYNEdpMkRPaTR6aGVncWNMYkRTcDRTTzZlRDFZdXA1RC80QndUb1FTeHJrRjNaWFhUVnBxODA2Q3l3YjExMFZrd1I1QytIU2NWNVBzVVdrMUZjVmNCTjZ4aGJ3WWJYZHhMWnY3UzdweEJIcHQrUTBmanljWnE0MXVXVjRMSG1jbkhLTU52T2tqanJWYVMya1FXSGRseFJla20wc0J2V3VOcDdOUVRSVEVSWG1MMjZjYjYvZ3hldmd6M05qUmJ1UXozZDdXdDduK0RPSHFLYldOSGVkTVZLWlVzVjh5dkIxOTM0ZUYyYzYzNXJaOG1LOWZKblRJMzdhTE8vK0dmOFNhZ1JQbS9kNkdpUDZsZnRoUTZwK0tPRXZvczdDVytIZkx3Rjd2WWpZWFgyK01xeHBoazlxdml6Wkc4a2tmTVRZbWpFdlIrbU1hSmtqeDNITDNPbXRneFBPL05TZk1mV1lwYUtMRm9zdURYbTJvc2xKL1g4eFh6anV4ZTlQbm1tUFBJdFd5YS9nNXBJVVg2Y1pmWC9XUEVqS21NdTJxTHJhM05jaGhNdURyQjVUNTkzSUxMSjRTK1pCcCtmOTdkS3BZSDVCTmRDOXJkcHB6a3daS1hVM2VBTHBvL0hhT24rVUp5RmJmMWxlTnNJanNpSjFxc01zbTU5Zi82VnJsSnoySldqdDZaM0FYaVdSaWZUTXB0WnRQSlhST3FLdDhRTUE0SkMwbXpaclcyVkcwRFdGbks2bG5KUjBWNmkzakJIODhYVlMwdmZhdEhoUCt0WWJsVXlIdGl3YzZVYlUxeTB5a3lEREt6dml2dVNHZVBBOVdIUE1PNDg5eTJJcEhHTU1YTTZjbGZFMGluRnRQZE1RTTU1Snk3NXNWR1p2dng0VjFPRXJwY1BHVHZraisvQ0kwaU0zNjNYUVlvK3IvVXpDOTJ2cGo2eC9kaUhIOUxaakpmZnVWcE1zaE8vTDh1MkxIR1VXVmNZV3VzOTMzTitRMDhyMStlUklSS3Fldm9XSEcxaXZieit6QzhCNVJFMUF4Q1I2L1dXUExHLzZoNHhEajZXdnJYRnZVM3ZTV0VQSXU5elJkc0NoYmdTOGEwcHA3eWdGcnNIbG1GNjBkN21RU0xxakN3L0FQQXhqd1MzTjMvdnBsUWpQMDFGdjBWcTZSOW9meVpId0xPR2hTOEs4WGt6MXRDNVlHblNoem1UbElQa3kzb1VJZUFqbytPdFlaTUZSZ3RmejJkemFHWTFEWEdiUGJ0SXR1ZE5xOXZ4NnJ0NHlTd3pKbHBWbGoweVE3R1YycmJBNFRaMFZXZFkyZFNabDdLOTVWVG1tUTMzUFhFWU5ubThiaE1MOTBKY3BMNlVNU2pNelB5ZWpUMllPaG8ranFGNlU5NjdrOWVLTU9UUnpYcDQ1NTBlUDQ1YTVjOUw5ZWx4MTZVMjJuaXAyTjNIUnJ3ZXc1bUVsTThhUzVFZDRzWGJXZTdTbDVFOVpmbFpkOXJPZFZtOUx6U3hidWdaUDQwNzdHdTNJNDV4Zm0zbGtZTzRBOEgxNDV6WGRPZXBaRjBicXNxTGVHVjRucVVIaFB1NFpZYnE5ajRlKzMwMEFVVW93M0lvRFlBa2U4a3hqcWZ1YzhVeGp4cXB0TDZPVVdXM0k3T01kYnNjb3UwZ0J0akh2ZjZaUi8rVnpIa2FWZVc5WEJZNFdBTVBvZmZ6U2szYTBhWUJxRUxtVDduL0dydnRGb0hFZnk0ODd6SFk5OWh6QXpiaGlxOXU3RmZ5VlFFZWN4dDhKckUyUEJwaXN1YVNmbnRWL1MxV2dpd1RwZWdqZUIycU5oVW9QbjZISEhvaDEwQjNRcWR0SlV6Q2VlRXQrZ0JsNmFhM2ZVRmhLMHZ1U2xVUDJueHRuN2p3WFo0T3M5c055bXBiMnJDWERhbE1oZkhlRVR2VkhZZHJ4ZmV4T012RFdRZVB6OWJqZksxN1c1N1RRTFhTSzlSL0NwVFdEN2JpR2Q3dlQrZXo1eVdFVS9vZysrcUpvTWZNWGtqODJlRDUzMHpQb3ZFZlZqU3dqcWtNSDBOTHQ0ZHRld2ZPNG9BNVp1dDdiUGs4WHRMdms4ZnYyLy9nNGQ4UktaZWMwNXdYV1R3bS9TTG93TWZGYTNwNTZ6TGpQTTNZajJucDJsMzZFdVJGS1NVbmZyd25MRkw2TXVyNUxZNDJ4YUQrT0dGdmVPa25YRkcyZU9yRTI4bWk2Mmw4U2J5ZnpNaTNUUG1JQVcyVTY4M3QraS9nK3g2TEtzOHRXMUNKdU1JY2twSnIzektub0dudGtLNTdWRTYxN0VmVjF0SjIydjYzMjh0aDhiazBqdy9reWZoOUhWRUNoWEZ0b1lldkFLNlQ0U0pPVUpnQkFvMFdMVzI1RXRHd3JUV1NucUUxcnpmRW11ZlRSTXQ2VXpuaXVFcG9iTWVMR3ZHWm1wQXZSczQxRlpiUnZmQnl4TmpaZ3V1NkhSOW1NR3Q4ZXVHMTJBRzdCaVBYa2dzODBwaXhON3ZCTTQwU1A2bDFVNUhsWjNTRk12c05uZHZJeEc1ZmVXZisyWnhyU2s4WE5tY3RzSG40ZlFDcWxITkx4ZFpNSE5QOUVnOStMa09LT0V1c2FqTkFSOUxvWTZiekFBSnRrNDNxS3pnUmZnV1VpL0dwS3pyc3daM28wM3IyVzN1a2E2VTRMei9ZR0VJaTRjdlNSQm5UMjVSZ2ViYmVPRVBkaE9mZVpSR0ZZZ0dsMEtIcXZQWTF1Y1dkSG1lQUY5aTJIZ3hkVFY4SGFWeWhHdUVjbW1NS21seXpIQ2dCZ1lHM2NnSnZBUDJoNDgvTWc1UEFWcFFSY2tMWmQwQkhtYk9LZHVXUm9ZajVjQkRkeTZVOE1hZnFaWlcvaFZyNVJOVGhqNFBXVzRlMkRDeWJSMERYWmpQcEhaYTVRaHpieXhESzVKZm1WNjhENTg3WTR3czZZaDJlMTZpcmpudkdUZDROc1lVY2hXTGQxbG4rajdlMG9uOEhUUXRabVlSWmtpYjlhUy9hODlucjZXUSsrKzhLaHMrNlIzbzJ3c0libzRJcUJzbEtaMy9rRTdNZVB5VTMzRnMvVG90WDBIK1Y2MHdNQVppTjVPaU94MW9IYXpwRWtxN1VPa2JnVmRnSENYT2ticnVDWHJ2Ujg3TnMyK1o5R2FVZ3pTNEhSdk5xbW1wUVA0eEJjeGdpbHZQQXpqYUU4L1ptRzlXTS9LODhuZlhFUGtaaVNMSWVycXN4dW8rK3ZpOWFpL0F1a2NUbCs2WE9BMlFMZ0JsejVzd2pKWk54c0RUYlNvN203RjhTQjVmU0owTVpHdzE5S2RHdkJUUDlLa0NOQ2FUakdCRmlNakRHNUR1aUxLZURGMUJWbzhiQzE0eU1tN2FsWVAzZmppaDd0YkRRUi9SMmZsRjQ1emlaWGYzaCtpMmtWQmNCajJaU0l0Qm5qL1pYSFFDd1ZvZWxFTGQrNldHZXNXRDk2MWpwd3V4U1U1ZUcweng0RGFlVzNldW9NejlON2Y2UnQ2U21ucGZwN2w2Y3c3WndabVZKWm52Q2Fza3U1L1VWZm5NbkNHUEtmUkRxUFMrZHJwSERKMTR2NE10K0VOVzBQOFhrZnZqTXUyc3VwSERsNExWV09scTExc0pabUxQYlhpcklSM3FySFBXVXVhSEhWaFpKaSs0cVVTU3RreG4xNlpROGNpKy81U1gwQW9TZ2gyYStJVHh1UGJaMTl1Mnl6bGM3ZXd1VHcreE5uOXV2c3NrYklYZDFndFJwaVRSNlRiemZJQkIxaWlLQ2lzanFIakNKZUNZNnlpQStuRlVKbHBtTWQvVGtTazN2RWVMZjZsNWFweWJIU3lkcUR2NDVTK3hkUmZlUk1SNXVhUGswcFRKcmt2QzdrM3lSY1V4bWU3aDdoUnBSWU5xZUpxOFh2d2tmYzlocTAxTFJ1RFdsK2x0UStMN253MWhhMWVrd3J1NTZ6TTJuUmlYd2ZITmY3bjVqRXhOVHJmdnJqMTd3THIzTm1vY2F4aGErMEYxSFl1T1NzQXdEZ0REd2VrdVJYdG5ybUVuUWR1T1hSck5PWlJNdHNjWUdHUTAxaFM5NVV5ZUN1UFM2QXg0M1FsZ21TNzVxTWNLME1xVXhyK1JPRmxsbi9DOWJuaW0xWWJ6eVh0azUvbHZzTHdJN0l1akFpczJVeVRiVEVVbEVoUEh0a0VRVXd3K09JeXJhY0J5dFBDWlJ0bC9XejN4bzc2MDlhNzNLaEhCOEZ2SC8rVng4ZUZYMU9GQmxzeFNXUnl2NnIya3ZRNVJRbTVMTWZJZTA1N0dYdnc0L3krTGFuam1VUlpSVTJOdytNWkRkZTlZdW12aWRuTHJxOTA3V25QamNlaDFITGtaenBXK29RelZQUytLMklMWXhMVjRTeUg2ZUdvbk9tT09LOGpRamRQNHhXTld4NjBlU25CdXpXZ2JFaGkyNEdaM1A0aVV6bTQ5bThTWCttRWQyVzA3YkVIMmx2ckcwTk1CUzhtTG82bHNidzVCa01OZlE1Q2NiL1NtWXNQcFdiOUR5RXB1a0JBQUpuYmg2ZFNIMWIzNmtEQmxnQ0tFY25WMWpkNVN4OUYvN0hWWXZTZWdPWVl3S1dOeHZ4N25JZ1hsdjZjMldlMzRIK0Y4VkgxdlZMQnZLaFNZUjZoNzkrT1BQK1cvdjd4TEpWYzlSYkwxOSt1dTdMcWlTZnpISnF2NjR3aHM2U002dU1Uay9pWUJLS0xXclFsMUoveERSUElWcUhJbVFVNnFyOVJNbC9kOW8ydXVjNlVrWnJmQ1FkVjE5TnEwU2YxSEl5VDk1NS85TDFQYVhsTnEzZlEwbnBQTExBblZHZG5aUExqdXgyanlwekhnZnorNzYyMW9INVZHOEtBTEEyMGpwd2pWMmNmbi9rY1Z4cGRxMDZuUG1ld3BJUCtvR2JLN2RoVzVlbW1uc0pSd3RNWjhiZ0d6bFpWbUpVVzYyNEh6MUNnUlU1K2U0UDJjQVc5NTZ2THN0L04rUFd1U043OVR3M1pQeit4cWZ1Kzd1UTNhc3pIUzg0ZWNOQU02N0ptZWJWZXN6UzZncllwdUlXekhnU1Y2ZTdhL053dSswblA2RURZQ3F6UEhHWGk2eWw0VngyVERRd21UdVkra2RPQTQ4K21ma1kvSUhneGRUVnlFYTQ5MWRMRTZpTDRoeG5iOTRwRktZd3ovRTBrWGdoVGUzRDVNSVhyV1RmcFlkdUF6QnlMNlJqUUN4bDA5aDJuQXFSOXBGb2ZLVEl6SlNsWFY5RDFCMldySU8yRXpkVFMyb3l0SjdXNnV0bFZPL0pQNWY4eE5kcGlpS0R5MXRmZTh1dXkrVFN5blhJcEd6dlNhUlhjb3BkOWhTaWJXN1RkRSsySFpiUDUvS3Z2ZDdzS0R3Nk1kYXhrWEdiSzlsbGw5c3J3Y3NWWG03UDVCbzBtWWJlcmpUQXMzRXR5ZEllZDh6b0o2Tk5XMjZqOE1ta0RlcFJkOWZ5TzlGeHRQU3Y1ZnVzd0VoajJGckdqSGJwbE9sUlM1YTZ5dnMvY3ZVMVlicWZrLzZjekYrVUZ2b3RUUFNXeGYycVY0VHlvcW8xYWtYQ1RieGdQNHNjZXNoUkJ5bDh0Mk9WOUVjaVJwbjBHTStJQXR5S3RwWW9LUmpQcGZPbVRWVWVTWlluWDk0bjhmNmVjSlEyc3l4N2I1bHphWmxEMGhyVUs2TUV3M3ZxS01uZzVxY2xnOHJ5cHBmcW9NVXpnL3Q5Zll5M2Y4cTZYKy9uZDc0NnZPeHkxaStLY2w4em9lbktJYVljNU5SMVNLUU9PaEZsZDRZY0FBQkhpN3ZzSmJJT2pOaGxqaDVyNUYwZWVOdkVjcG1HVWhyU1NQNWxIVi9uazh4d1NtdTRFWmJ2bVlMeGtqbVh3cVV3Y0M5YVhOZFpkYURRcGFtVzFwSUZ3SFJPbkV6dm9wUXk4K0dQeE80TXRDNGpwOHkxYjN5bXdTa3cvajVHMUd6L0pkV3lyOXIrRDVxUjFJRmVLM25mS2J5RFEwL25lZjVmZjdXMXBIcWR2bC9YL3lQVXZONDk0R1BxUFlkOEtITmZQOXBXUmF4enpiWnJzZCtocUdWeGJYcW1FWHlvUWJYV0MwVzQxaWJ3VkwwSnB0SzdLSy9qY3hxeitKWWU0ZHlNeUs1empYZnZaSGJ6YU5iREU1OGM4WndGaUZqYnJ5VTZSNkx4WERuUTM5T3dWT1Awd2hQVHZhK0F6YWRHOTROaFNNdGR5NTlVQm1HZDFUT1h2Q3BTdXY1YXBMN1o0ancrSE9nR0w2YXVRSTlsdnN5aUw4Yldob3NwaDk3bm1lQW1lRGFwb3JMQWtZbnplNllLa1RZWnRFMlY3NEF4YmhqZmM3aDBoZitkTE5PY2NDUVd3TElPMWphNng3S01zZ3IrOU9YOUNEYWVsMHJxaXg5SnBDenZrOGhHaHVybFVZb2dNbzVIMGl0YnozL08zbEZwaUJsTmFVaHpCK013WXQ3MjVwdlJUaDB5dlEvSWl2ZTZpTm5mNG92MjR5Qlp4ckVzR203UDMrMWY2U0d2WE9hM096OVIzYS90c210aE5MNUZhMHAxT0pIV3FsOVlkb3VyRU9uVmI1OGhBSXllOUpnekFJQWVqMmJVcXIwbjMraFZ6eTMwSXZiRTI3blNmd2J6V0dFK2VMYkduL0dBRk55YWh6N1RHTXFLenpRaTNwN1cxbmIrWW03Y0dtVHBKZVE2dURCcFArR0Z5TkozZitjNEJzV1E2ekVGOTNSWHVKK0J3L242R3RDTjkyU2txUnkxK1A0UzN6ZmFIS1ZEMWpjQnkzQWlVbU9qOFlkeXh2d3RrUWpOMFVUZmc0c29MMTJFSVRpUkZtVmtHV1RvampCNE1YVVZjakRjSzNPQzFaZXFkUG5pd2JFL3g2YWZWTGx5ZnBIZ0NtWjE1aE1mcWtmZUtqaEJ0N1VlYmlKUit6QnIreWxXN1NSdkt3dXl5dS8vQ3lkalM1WmZRZEhIRFpGZTZId0kxRlNtTkpHcERHdTBKU0ZkbGVaUEd4WkgyYlFNQzIzRVYvMGJrSkZKK0psZlN2VzIvTEpFYmNQdGJuQVEwbjFiQStCQVBSZEg2cU5qQ1Q5LzBTOEQ3V1VYcHNTOFMxc080VFQ5dmt6N2tYQlJjbXY1ckhSUnA3MmxqRjRHbEpHck5wUk13V2x6c3RYejZMRjV3ZzBlNXQvcmoxejRhMGZSK2ZXMXgyT045TEhXMjhzelI2K1dqcDdvM1kra0hIdktzR1MwZU5KMTNwc2J0Q3pjUDZkMlI5MHZVNlE1RGcwOVpud1ExYXdLRFN1aFhLUEcxaGxJT3Zpc2NXMnRTZXE2T0h3ZXIxL0ZqbWNsRFNkVGl1ZnlleFJydlhUeERxbWtwK09Xc1llbG1WSWxUN2pWVEMyc09GTmllSFZBajhXMThNN2JVWHNSRWFSMnNDWnVIZStkZ0paTW5tTDRIYld2UTMwZitVdXBtY2pZSTMwaHRUaENiRVhtdTI4QXdCZzhTK3lJR3pHNkxsS1pGaU50dkNUblZCK2d0YkRvVmtTZDFtcDB5M3hGL1VzdTNZZ3RSS3ZzMHBpUE0vWFNGaUFBSTVDV21EUWNZeEJjeW9YUE5GcVdsR0lSUWNPYnBZQlR2QVFIczU5cHRPN1gxUXFzWFdFZG4ybmszVCtmc3ZieGMzb3B1MkxiWEtQeWlzdUNoS0plUzJYLzlkNFhpSzdKOTdzTGlWelZLZWd6V081THFWdzRqNzkrdm56UiszNFFkQStZaTAvSnYrR0tKcjRIM20zTG1XVmJZeTRaNlc3T3pHY2FWKzZ0ZUZWSmR1U25hYUZlREZxZjVYRnJTNm1Ed0hKNHR1c2tDcm5JNkdmZ1JWcXFTQmhHN2pCdXlYN3Nia3NzNjZLRklyN1ZuVGlmdWtHaE00YnhWd0lBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUJCL3UvLy9zLzE4dlRmLzhFN3JKZXk0Q3Z1MmxseDFpRUNaeHhLMUl4MXVGaXhnNE5aMTI0UDBNNklEbzJleVBHdFhOZ0dyVVhmdDl1OFNyRHgyTURpc1E2MHJCYThsaWw2MWxscjJUVnRaNHJ5NFpYczBuSi9WaDNld2dQeXBQdmZ5eWhEK3pkR282a2ZRN1Fwa3pNZGJJVk5wTzJiaGRKd2l1K0lwY0w4SmNzcVF1eHYvRC92VTN1bE1wSlJ4a2pkd3NrY3RaTG9PVC9QZ2g1VHRoMTFKdlJuR1ZIbUhSalF4cVliUWNvb2ZMWXQ1WmplbGs3Ykx0Vi85ekUwdkxWTzBpbmNKU2dsTm05bnJFYjd6bEUvcHJtaWJqTmxDdWwzZzB2UWpkRWl0aitJWHRvWHhYOTFPRW9XVkNWbGYxZWYrenhmYzg1Mm9FYXNJN1IwRVRTZFFPT3RkY0FXVEd4aFR4RmNtcFQ4VmVweEk5b2NKRFg1WWZZR20rNHhic1FwUkgzMGtYNmpObEMxY0pvbXFrTzRzaE1KOStiWDZtTEo1bjBZeTgrcTA2VGsyVm1RWlIyL3JMcFB6OFY3VkVqZktQRW9Rd0JBSzVZN1VxZXh0TFdrU1h2cWtvU3lySFNjekJ3c0V6UmdMZmhwdWxGdWhNY3crY3l3UFpCaGx1Nk41V1ltSnQ1U0hwNng0cW1USngvR0hMZ1ZDejNUOE5vR2F4L253Rk04aVpHR1c1QjlLRUxyeit4THgrVTdscXlNcFAyYSsxZ1NqZmM3Q2ZLWFJmMTd2cDg2YlRKUzRtUnZNY2Y5Z0xTTDkrOXI3TzliWjE4SDZYN3JOSHgrS1g0bWNQcEVyQVVqRGVmaXdEcEVGOXNlVlVIelNQbTA5SFdlaU9sZmVLeEYzUDVaWlNhaERqT2JiZlR5SDZRbWQxak5YNGVCMDJsOUxDd3RaZXJucFZhMzRndXA0SElFL2RVeU5rZTRFVkk4cHNvTHk3ZERRN21oN2pQZU5nVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDN3d4ZFM3RVhtMWZYSVZXZzRRT2gzdFRmWm9CWTE4MHFrQ25yUGtUK3crY0Fib3lCanl3WVF5a3laTnkyazl4U0ZySGM0NC84U2hKRTJrODEwOFFxT24xSHJyWUlYUEpHaUFtcXBtdFhuNy9VWnQzWmt0dklCYjlhSEh3ZExDSlZuZlRQY2dHNmtyMnpyVzEyWDZQUDJVckpmZDkvWGlqeHk1akxOa1J0SmJ5dEtwZHpOSnA4M0Ruei9LRUlYdG9GZjJUT1ZoMkpjQmJnVG5DWEF4dG9YM3pUR3B6RDYxakJYaWtZc1hDcUU2YVBsVGludEhUREp4YzRFNVF0UXFTdmhpYXM1cHlwY2I3eitxZTd4YXIvM2g4cVhrMFZ4K0xCK24rTko1djV6cXZXMnVDaTFFcCt0STB5L05IVzhaU1kvL0hsckdyelJIWmhIZGk2ampabXhBWDJFTGU4dk1yOUFpNU1xSFhQdGUxb3lmUldIcmNDeXo3T29UK3pJTVY5STN6bGNBMXNEcG5RejEyRDB5dmR0MUxTZVlXL20wc210dW9aYzhTdFJ5QlNURlRGbkpqWkNXRFZMNkpLVGp5c2pCY0szc3FCa0c0K2haZ3RaeFBjdkczckkxdk1vZGdGc1FuR3pTUHA2VVZrc25iVmdjYktPUmJpODB4ZmExZWpqcm1jWUl6eW9wTWxvaFpiLzY2V0N5eVQ1Y2ZBMHFHL2ZmR2h6alAyWG9DanRlbDdndm05MmwycldoWDBnOTdoa1VOcDFFdmNjZ1BaT3k3d3hHMFVYTFlHdVY3Zldid1ZxMHE0WllHUzBML3FTa1czQk1XWHBhYXVJa3hJOWdSak5aWG9oMVg5RGlGK0JkZzBKdm40SjNiOVFqcDJiWGZZSXdhWm1FTDZpQzRYUXVPV2VPeVpabmxaZ2lMOUFRVFdoakRHK2JBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGMzhuc0NZM09rS0ZPNm1pOWNTYm1RZGJ1ZHV5NVVqa1JNUlhKM1JJaDdCd29xZmVQNWlEZHJLTzl5aUtwM2Q4YmtoendhUUpxZ1R6OEx4cnVsdHJiTzh4MnQ0ajNsNWhoWnp1cVYySGowN202aFR0S2F1c1JNcnlvQjIvMVZJZm9TNGxlcHBycE93ZVIyUi8vNVlFZXZMb3FMa1JHVm5XQ1hjMDdTbCtTc1RCR3VWNGZZczlldC9IL3VUZ04rYjllWFdSSjIya1l6K2ppejhMZWN0UnFyejFITXBzT08zZ291ak00eGVDSkNLenBoWEwza1QwUGRYTHh6Ym5aVmxIbVJVMitsQjI0U2J3cUluTDBkc2ZNNVdBVXphNVRYcDRmSDRGMUY5NXpLcXdrc3B1ZmgxYnNyVFdsWkhYNmtWa1V2Wm5KSEx6dDVVWnluNmFkYXhrZStWZk1iZGFkYUl6WGNUc0hOTHhmdVB1cW56bVJxVDE2RHprNXFWV3RaYWVHanNYanRJLzlPaFl6NXFMeTBQdGs2ZXo2L1RjdFphUFMrc1liRVVxbTVIeFo3MlhkS1VZbWQ0UnJLYjJwdCt5Q1UyY0dWZWdka0VMNDNiUmNNbERpSHc0NVZEZkpLOEtVNXFuc1dONGE2RloyRHBOWk8wZGJRa3ErOHk5aUsxTUQ5a0liNmtUTjRIamN1d2FsT292YVRVVTFiL1ptWHF6TGZ2VkdLOHJ5eUVQRit2WHh3Q0FDSnJYM2FhZGptaVd4cE5PeXlmckREMWV1ODhlcnpYS3FEWVdLUVBTbEdBNDF4a2VONklZTXJpeVBac1IwZVd2VkphRWRMK1dDd0htWW8wNTcvanRkU005NjZUY0VGK0VNcktRQjRBdzB5MVVnSWpCU2NuM0JkUlhPbkd6Z2NqS3dXY2FXYW92WjVCYTI5bXpKdTN0dzViMXZZVmxtSVhOSXVHYTN6dk4rNzh6WC9KYlpSSVpKVXVLT2FwYzY5MVdhVTNPMzUrOEVyZjNjYVVkaDZQN1pIblFSemx5YkoyN3Z1dHNwdUhLT0xaRHBPMmwxclBHbElRMHRyNk1IblZoTmJIWG53Ym4wR3JpdmYzclZSWmNYYndtTWh0bEw0N2t5dHY2Tlk2MFhFaEMyVDFObUJXWm5tV1JONzVsYXdHODhPNjFjSG1zTU5DTnBSTWlXeEZjZm5hZUt4TVZYMGNGcHlDTXUxSjg2ZDdSUlk1cnhYSkRIczBvZnhMczBKb1VYMHdGWUJaUVNBQUE0T0JweXZMSys3MmliQmhEQUFBQUFBQUFnTUJEbHloNFNIb0dhR1FBQUFBQVRBSnVCZ0FBQUFBQUFBQUE4SFZndVE4QUFBQUEwQTYrbUxvYTBsdlcwbWsrU2JnZVdKVkVpczVHdWkyTjV4U2I2T0ZUYmdwVEdlc05kdXVrRlNPK2lCZCtVUk82RWN4R08yMm5PSytmMnZIVzBWQmFIbXUrTnBJZGNkR1RzTzZ6YVJFMVBNN1RUZk9XbGlyaTZuVFhRendqUjcyT0lCMkRFcDJvTGNkek5Sb1lxUzY3dG4zOXN6c3h0eTdYNjBpMEtLampXVmhhQ3g5SG12Zm95VmkvYTNQUHVudXQ1Q20rU2hUck5CL3Z0UDEyUjBUOFVxbzJRam1La3M3cnZFdXlwQk40UC84OWFxZTh1ejdlVFJaS0xMc1VmZDE5NW1BWjRUaHhrMEd6TzBHc0w2ajJmUExzd0JWdFA3QnNhV29rb1ExSjI3MnpsZVA4a0h1NXNGV0lzODA5WG9jVVpZNVo2cGlHSE5WelVXcmwvZEx4UnhxVnNBOXZzYnN6eHlYMUYxdUorSHJSc3J5ZVJOQVgzSW5kL09ka1ZJV09kekozbE82dHAxMzlJWVpFd2o5RkZhMW84d3VxbVFndkRoMDV5MjlzenpOS1RoR3VXOWRpMm5pVy9RK1hQL1RXeXlTY3l5dFZPeG5GQjZlS0tWTlR5RjZFTGltZVBBYWhEN0U3bWFtVnoyUEVmTzdkZ1MzT01BL2UrZXhaaFhMek9pbnBleWFWTkluMnUvMGZleFBiVzZwOW9meVNKUGxEeDVwUjMweS96M3hZSnhWV0pxM1RKNzBrdVpZbDdYd0FBSzdDbXNkV1BvOUdWYndoVmx1YkxuM3kwN3RLaWpDOUhLMkJvamM2eW8zd3VBSWVsMXhMNThHNmY2L3JBL08wSm9QWEtPeG1tYllFck5OeDhiVnM3M2puWkVUckJvQ2JzeXhoQk8va1VaQTI1cVQ5cytoY3lqTTJZU1RPN0NOcmZheEJuWUJvdmZmcjRzTnppY0x0MXpIci9Yb0wrTEFOUi9mbnlEVzUvMDlkL2ptVXMzK3VrSVhWZjJGazBUVTJUYm1Yd0ZHWFZwZ2NXWlRGcit2L2V0ZHRILzdKVTVSNmJMc2F2djdPb2ZuTjdjTnF1d3ZTdFFUMklrejRnYTJuOTZRRDUyQ3R6Yno1WjJKdCtVclhpY2wzb3lrOFk2cElWamlxSVlzam5iVGJMbldqOXo2dGJRMVE0ZDNuNFBKSjZUMmRENFlncVdkci9pWVNMbTVmRVZkM0o0dGtFcGRIR0FkZ01xWmJtV1BoYkZwSE9UUjlqYlZTZVNUMGdaR20wRUFUK0dJcU9KMUw1aXVVQkFBQUxNNlppdnBwUmdGR0VBQUFBQUFBOUFPdkVnQUF3QkZZQndEQVBZQzJBZ0FBQUFBQUFGQXlWZ3JmRGJvWEFBRFdCUG9aQUFCTW9DckIzY2ovL2QvL3VWNm8vdnMvZUlmMUZLSUgwbDF3V3BQMUZyM3Y3TEdMNE41b0gzUWlWdVMwR3h5dTllVndwOUwyc3R4a09obXJUU2Zvd3RsRnJOR2RubU0rckdPWHBXejFzVVZaT01Zb2sySm10QW85NXFSWFR2UWNHcy9aTTlIejFiWnNvNVFMVndlcnZ5UFczdmNsTitrRTJabEUzYTZwZUk4cGdoTmhNK0xJUW5jQjB0d0k2a3pCazR6TWgyTkplWGY5eitGa1krNFU0NVo2dG5MRnlrRXFvN05zekVzLzBTbmhtYWVWbnpHbks2eVR2MjAxSGJmNG1rMXNIYStYV0xjVDZkVWhveGR2dGF5ZzdKMXFyTzZyUldWU3YvdndSZFYycEk5QmkxOUtWYjZnMm00UlJ2VGJxRGxsK2RWSmlHK3BreVhUT3BjNUluc1Q5Y3JUZXNUc2FCY2lLbk9XbTBIcTBsUEV6TFhKR1Y2V245SDZkdVNhZXlRdGMxK1RGUjN3WEprOWRZb3RTdTFWa2V6cjBLL0IxejhRcGJhQ2w4SGZwejVTY25DWG81YjgvVjRXQUt2VE0xOWI1eStuajZ6NGlNYzJpcS9UVDZPV2ZSdlc0T21KNzhFYVZGSzYwaGpPeFlINzRmbFJRblF2WWVSOEErQXJhTi9CYWkveXMvZDlDTmMySTd6THdzY3dlaStpSnZxTVBRWDlqQ3Foc1M4bnI3azlqZ1JYQmIrem9IMUJWWG9tYVQ5WEdlL04wajBIS2R4NldWWGJpOWhhMzFNYmNCSmUveGpjbTVaMUVCY3ZwV3VwUzJRemduTXpic3JxeTRsUnUrM1JNb0hDeVAwTlNTYVlSdXZlNkVHTzhzelYyNTM0VWlyb3hydnN6M0wySHdyUlZ6MURNMnFISGo4TkpEOHJNZUZjUEdoaWEwSzhiUXFlQlpRSEFBQUFjRG80YVJTQU5qQnpBQUFBQUFBQUFPQVhySThBQUFBc0JRd1RBQUNBRllBOUFtQUkrRDBEQUFBQUFBQUE0QUNXQ1FDNCtmdjNuK2c1SUdBYTFpazhudE0rTk5rTjNVeUwxcW93YlJSRlQ2dnlISmNSL1JTQmNleUFGQjA1b0JEY2tKWU9iaGtBM3p4WUlpZUFqZENGVHJ5SG5VaHpQdUtQenJQQ2xqTDAxRElMMThhZDBpT0k2bXpjQ1o5Y1luR3VSQlMwdDBlc0krcGFERzRSd2ozNWE0UTZaQ0Z2c1k1WTVXU25qbkQ5bnJZVFE3UFF4dVY5UXVvOFJkYzZDazdGTTR6cnRKNXVqdDdJdHpnb1hsL092TThXQStXdHpGNG1QVG00aURxa2xsallrbWlkaWhqaktYTW1IcS81Qi9mNWVZNTBVWjNuTE50MUlpUFJ6OW5TMTk2NitNWVluMGZLTjVIdHZrdDF6ZFZEVU5oc2JZc3dGLzZVdGMvSnQ4YmVIbG1sWmtjcWVycTJ0NVhsK1YzWDBUTVg0dmJhTjk1Yng4NFpCcVpYOW9pNnpicFBiWjRvUjRmdXJzdE8xRTRka1d4ZTlTUjlLZFdkSWNsZXM3OEZKZDg5UXF2UEhpMHJvcWUzT0NsdnhHNFovWEtvUytIekhXemROcWJvb01wSGtWSlJWam9KUzAxeHNxTXEwTG12bzgyVnFLbDNGdWtxVzgyZjVtcGpHMjdPY2VFY0l3ZUxWUTdON3gzUXRPemV2UWo2ZDBTV1ZZYVVQelhVWVYvR3NjUk1KTXZ5dURpdGhhVjYwN0t6VW83OTFWV3VCUG42R09QVnhRQ0FYcWhXdHVacnhLdlM4SGhmbXBiMXBzdEt1SzRyOS9rakZqSnFBVjBDbzVYUVpIbGRpTHBNajFvdWpmR2VUWU9VL08wZ05UNlh4aHR1eWRIeWdQV0l6Q2x0M0phQWJJOUM0OFlmeGhpNFBZTTlpZXhZNEwvM1gwaXhVaDY2Mzk0MTEzbzNjTHhyVksxTW1rZktGOFd2UEk5ZjBwUnlTakZNR1ljbStheGJTeVh1ejNYSjRaTHkreS9aR2JCNnR3ajVPRG0vNlFzSi96elRLSUswZXQyZUQ2SDBiNzEwT1VVdHVTUnBQeUw2T3dWdG42TUlhZmF4OU8vZkhHT0F3VDBRWGRqQlQ3NG5KUmp1alc5QlZ0RDhkUkt1RnlQNkdDVUYwMG1NbW9LYnJmUFcxNHFQM0xkc2tjRWZvbzgwYURnYTloSzhjeXE4YW5wRlpDWWo4eE9nWFdYbzQyc0F3bGpMT2NNSUZKSnV4RkQwemlHUGZYclUxUEFZWXV4Ymh0REcyQmFHTDZZQ0FBQUFBdkF2d0hnd3FnQUFBRHljQzAwaHJEQUFBQ3dLRkRRQUFBQUFBR2dCZmlRQUFBQUF3QmNCNXc0QUFBQUFBQUFBQUxnaitiLy8rMyt2bDFUMWN3disvZy9lWWIwRTc5djJrWVBjQjFWQml2Y3dRZ2FMZHYvV1NTcWNEQW1tYlNPbkRBeTdYekNmRWFjZ29NTjFlcFJJOUJpdUJxSW5lMjNYL3docEkyZC96bWZrTVI5T0xWZzg2Wlg4cnJKNlduUGlZQXFYNVRUNnUyN01mTGhiSnFYZkM1alRrbU5telZMcTJldElqRGlNK0Z1eGJJSzdQVHdPcFZXNEZTN2xUMlpaM0ptNzJyVjBNbThaT3BoT05NeGltZEc4V2o5citaZ3lyZTVYUmVhMFA5Mjhld0JyaGFVeGZUSmk4U2swbG1oMnlMZ3V2Q1IrSnUzckZyVzZGSDIyNWxTR3RMR0gwUjdreUhtN3NnRnFtYWgxM2d2YW5QcDY5T3ZMZjlJVXZRaE9WakxjajM5bEYrNHJwMGFSSmt6K1hBa3Y1ZXh4TTdwZnZXVnVSRmFJclQ2N2x0NmJOZ3NpSkNOSWltaHhweFpXSWVJSFk3V3MwaW0rQWkxdXhCV2orZit6ZDI1WmtxdkdHb2E5ZW5uKzh6c1BIb2RmekhGWHBUSVJpanNnb2RUL2VYbDNTVUNBdUFSQm9FUThLNVVtMnFtZTZvdlk0dlRvSjFvdmZiNlNJdXVlUWlnTlhRTmFGNFI4SHB4a2V4a0FBRmZnV1ptTzByWWVEYXA1aXJTeXpKaU5ydkRpbUpFS3cxV3V0ZUNSQjlWTWQwczZLYTJuZ2IxcHRjNEh2Z3VMdTA0emVheXlyZVlrQUV0enhlelhrU2ZsRTZTY0VYbGdubnhoa20xQ3ZtSlB3MnA1K2N2MisrVlVTdll4NXM5LzN6NGpiUTFOK1Y4LzRVWHdCVy94UHY2bXpXRkY1ZFBtOVZubm5qVUt1Sy9QV2xMK1VnN3k5bmQxQTFMeVJ4Ump2RGJWSjUvNnVpMURJc0t0VGxKZ3h1dk9vdUtsaENiNE5xNmNDcTNoZFp5RnNDNkh2ZjROaXg5SHVwK1N2dnlWOHFmU2UvSzBOcmVHWlVZQUw2Q2ZsNFpTaVI2THA0MzNibVppc0hITG9OU21BZUFpM2t1MjdacUtrMnh6b1RuUHRNK3p2ZisxUkZ3UjJtUVB1c0d2VFFFQUFBQUFBQUFBQUFBQUFBQ0FpYkR2Qlg0dFQ5dkZ3YTRWQUFBQUFBQUFBSUNUd0JJVWdLRmtES3J2QnMwTEFEQUFWUUVBQUFBQUVPZlBlV2RmQVJkbHdQMkZtM2JvNFNXbEVwU1o2NVNPOVRHNGZxUlRDekRLYmt6YnB5aTBneGFCVE9USWo0bmpXV3R1Uy9wSVdPL0pKMzVPek8zdlVVWGJjVER2QngzUjhORTRkOEV3cXh6R2d2Yjhta3l0OTY5U3Z3K2JXYU9QQ3dOa2o3aytPSVBTTXp0WTlkWFJhUDNjTFl3azZZUmpMYjhvWHQxeVJ1Y2IrVHpCT3V4KzdFeWttYm1pR05VdUl4YWZ4dmlHNlVrZm5keFlvbUxwVUJaTVBXN1BzK2xHNXpKUzNzb1RrTlhtYVpteHVDdjByVXhrL2I1ZkdqOUhNV1hCSFJJbytqRVkyYjBmTkczVFowT2Vjems3VDY2QmEzbzFsblpPTTJYYlVOZTl2R1R5U3ZOenZRdVBqdE1UYUUwQlJ6V1Z3eDlNdUpGTkpmVEltTXZLYzBHRVVaYkVYUmhqMnhVbXZEVHpzV1cwNzJXZG9SK091bktHcGdRQTlESGFpcklTMlEvMGxqVkMxRU8wbEQ3emJMRGNRUkZiTzZWbGthYWwxZUp4WVF1YTNTQ0F4VjAzMHpVb3hVRWZBMHR5TXg5VU1Ub2tEbk5Ea2NPdGM4bWJMR1JxdmU5aHpOcDBoRUswcDdCVXFqQUI1LzBhVlBvc2xGNG16dENJN0hlMm5TWTE5MjJ5SWlYNHBHNUw0cDJRZnRORWZvQzY1YVduYlkwNVRJS25Na3NkdVhVbFdJb3pGdCtqcDd4RitwcFZYL2M4L2t3cndpTlRtN1dsYXk2K2RjYUFhZ0YzcHppdjNWVG1GYjZXQ2xhbmZjMWh1Njc3NStneG9zMmxYenMwb2thRXRHU0QzZC9ObndTQWdtZDhVZU9WR3IvREZnK2wrcmYycGJXRnF1TU9MOFF4cTVvWkN5VndNcDdWcDBlZXR1SjlVdWZSbEVkOVA2VnBkU09wRk84ZXYxVFU3THcvbmhtNU1FLzhydFN5LzNIcTlrZXBJdVhHSWxmemFqUGg0cDQ5bUNocjFSTGZXYzVUSHl1aXVMWVhUTnNOSDd0RVc3bjZLNExyVVpOVmpseUlGTWpjdWlmNHJmT0xaZ05xOTAzQ3JQRTE2QmxuMjlpczczSTVGZVpCanZOV3BDZGJ4OWJJVVRKS1gwZG00QjZaeVRGL3ZlSU9IWU5QR2VCNzJoYjVHVFBDQ3hxN3RPLzIydjRwU2g3SDlxZDZVbXMveG5yYVBxOW50T1pmenBoeGUvTHc2dmhnbnRUVTBJcXFyd3NWM3VScFVVdlZIOVFRK2gwekgzbGxkeit4UHlhMXFFYTcxZXdkVmRwY2tKUnd6ZVpOeVY2ZTdJeWpsVmxLYjlrT3owMmFPcDJsODdXMzl6cjFVeFJKSm44N3hJamhyUzBBbXZ0VU5HNHNxYjNYV1A1UjFmVWRqTGJwdEVZZ1d6cU4xUlVqOE5xRjU1ZVJ5MUZiL3h4TCtFbkJQNFY5MVBCdXlYd0kxOHFhMHBOc09BQ3VaWVRYb3RlTUtNSjFSRjVkRnFzVjZhbUgxT1R4R0t3K3d4N1oxbWszTWZFMVU5MVRGaXVXeVEyTVovVEFqV3pkak1iVHZ3SDRLazdZMHpENnZJOGlSbHBCb3dmd3QxZ21YaVBncUJ6LytsZDN6ZHYrS1BWOWUxOW5oWG5yL3UydkphVzA1YkZnMkc4SjdHbGNQU1ZFZjV4cXAxYzJKczF1T0RYVHV3NkFUYk1tb3hmakkvTHFuWVlYNm12U3JwRjNHUnhCODhPT1lKVFc3dG14ZUN3enRsekJFRWE0R29hNkloaGgrREVxdUJyUDY0SS84ZXEwS2NiSTFmN1h3eWtpcXZKUllWMXNWWTBmcGdJejNDczc3WXNaVWhydDJzMld1YVNoaDJkNmxCRjVQUWw4Q1pJRjdiM3ZqZk50U01va0tmY1hLSUpYMVZqeW1nZjEyc3dHNTVYVnZMY0VoeXdFNWZsejdhM2RHYXZMa2ExUk9zTVZocTdnTmZvem1qRWRqNjZBT1dWMFp0cGpTRXp1Y2w5RDBRSjdObVd0YVNranR1K2s0SStVUWw1bnBnU2NGR3R1NHhnbHF3VERvaktUM2NQa2pXc1RtQjVCYWZzMUZZV3VpOExFMDhhWi9QSUdQWWJxOFJ1YnB1MHZiM3dYWnp4eHp5dy9TWGUwU0pNQVpicFRDNHBjanZHTjhPcXBrT0hhMTAwdDZzNWV6TkZHa1JSbnBrR2xiYzl0LzNyN2E4K083YXp4WjdCcXpwajZSOG5xbU9yTDRRODVQaXUzdVg3Mlh1dFpDNlhDM0h1eUwrSXNLK1dqQzR2YVBqYXI3aFA3dURJNmF0MTlPM3UxTWdCZ0RqUEdYcS9Na1ZzYW1xN3BzZVFlcjdkNkRLbFJab1JsMmpxNkN1Y3l3aEVKL0l3ZXVEM0xYeXU5WlVFZkExL0xDWTROejQ5U0tabnMvSE9HYi9Rc2VXZmhtelNMb2UwSzh5WGNuLzhTUDFMTlRiekRXOUNCTi9QbFVscDJPZlpyYmozbU1ZZFl5amlXSDZWeXZnajdsMU4vWTllNWZ2N1ZOZ0V3Y1hZenkvV1BwbG1UTTZlVms3WUxWK3RyVWQvb0ZYc2FFVTE2MW5KSmsvRklGWU8xNXJLTWNEVjBqNjNOeERYR3hZOVV3UlgwcUxHbzdwODk5cjZPZGhNSHVtSXF6QTlUWTY5UWdvRndIWit6MkF1VDlxUm1ISDM0RVBWWWFtS0tFYyt2RklaYWZFay8rWkxTZ3B1U21XdXIwd29kNFlNMmVFNm9VMDVFdEZtbGROZk90ck1zTE9LSk0vR2swb096UjhuTUhEUmF5NmNtWE91Y1hJdHpZWkY0YWNDY2Y0WWlrdk00UnhYNmNsbENQV3VHQk9ZT081WUcvVkZUSTFlaDJSbW5WSGZwMmFIZDVQVDMwMHprZGF0UndlRFYzNW9zYXp4Q3B2Y290QzYreFpCc251UHdJc1UrMkNUeDU1UnhiZ3lWamhxang5RDJGL1hGNDh6S1NEdFp1bVdRbTNpcVFrczZXdVdhbFNlUkpoblNKa1Z1VC9yZXZMUTZ0SVNuRkNxL1pjNm5PcG5Tak5xN1oycEplOVpYelpkVjE5QmVJMWRuMWlleWhIUGF3N3RHNFo0dk1lbVNNYjQzZXRVQlhVTW0wK0dwaldlZ3QxazllZWE5Q2NCOTFJUXpGN3hqbys0eFFwRzZWcVpqbVpIclJIMHM1bVdwZlkvY1RTWVgxb1pIbldWYWZJOWNtNTdLQjFzbjcxTExKZmYyWUk5c3lyNUtUVXE5bmVXU0hDVUNBTVpEclVqT0huTlVHVGFvKzVySG00dDMxdXlqcG1Wc25Lbk1ObW9peTBLTERPaytGMTZTM3JHOUhTRUh3OEJjVmxCZ0hDUEdGdm9XQUFMSy9zS0c2VWVwamZMSTBUeXY4c1BlSWMrOVA2QmRTN2EreitDbVJpSk9CZnpkNjBnOVpERkU4MFRRZDdpMWRCdHJuNDcvb1djZFYvTVN5S3Z0VDlzVVExbzVqMktXemNtMU9QWEJNbkNMc3NSY2cydm9YYU41MUhQdk5tRWRUOHFUVzRzK21ET1dSWnpmaG92SHFRYXRXYTNZdmRFUHdsclo0QkZvWTJNem8vSGpWRENVNElUMGZnOUFpcE5rM1I5VmdkcTg5V2kwU2dmRFlINllpcG44Y2tZMEFacHhESW9Tb3VZZjdScUFIOUF4YU03d01weElNZDc3V25MOXg3WVNWTktZS3doV0loakRVdlAyREtXQitjYklwcWRFbDVZaFBDWDdUa2MyNWQxdTMxSjNQZmk3eE1xZHFEanZUOHp6MURjenYyVmd6OURBYytxRyt2cndaOVRLWHp3dXpWL2NTeEJGeWR1R05lNHdnMnh3MmhIcGUvUHFyWnZCNWZlc2oxWWNVcWUvdGE0eGV0NFkrWHplaHJiYUFsbTRQNmw5dm14ZHJ4R3h5a1lNMTZnMmVsRFRBQmZQOHJIdzQ4Q3lMcVJsWUd3QmNDNDJqOG81V041ckdMRlNHNlZucmx6dExjbVZIWWpMKzJIMjlDTloyWkR3bG9WemVXOWgyTVlEb0VIWVgvQ01GOWZZV3NGRGNJV2lHKzhjYlgzMVpYd1dSUGh2aEtMOGVMbXdndjJLdVRUeC9EK3krVTF2U2FmWno5YThTeXBramptdE1CRmhNZ1NnbTFsYmoxZHNFN1lLYmdYSHhnbVVRQnhwcWJFcTNxWjhTUFBQQVJYM0NNUW1Mc1o0QUp5RTFWeUI3ajhKcWtFdWVIWG1DV3hWOXllQmUySDN1QXhEYy9iVVdXWG12alVQN3RvbHdISnFFWmUyRGk5Q25EWUo4M3VyVVFja2dadWo5VGx3WkJzOEo5ZFZ6M2p0TVJMWHNta3MycjZPSjlSRUptU1hZcERSTTROdzRiMjFIQ2xUbTJjN28zcnJsTEdVUzdQS0Zvc2FOU1FpTTFWSnRLVHRKeno3OExsejRjS0tWMmxlczJJcVR0bFBSSnFQQ3hlSlNrQzVCcUtWWGN2S3U3c2Z5ZGFmcGRJL2hzMkhUWE1MdlRyVFVoOW41SEVTcHNkdDU4QXpNNi9qUnNvd282NmRNcHZvVW1wck5VZWZaaHUxbEVhUVhwNndzUiszL3JTeng0TWxqOWtUMGhuUHVTRHNZek4xNjFJTnRIN2Fia2RyKy9DMWdGTy9LdjB1eGV0ZnozeGtkU3Ixem1HZTlGcWUyWkEyR3M3QUdmRzVFUjFaMTdjeWU1WW0ybkt3R1BOa0VDM0h3dDl2ZTV5VVpmdnhrdnRxUUszL2VzZEVwSE9OeE9PTHNNVFg1SGpnT25RMnhLY0duRlNHWXJxZmpUc0wzRmROQ3IxNFV5UmF5MER0YWVSRE9PZmhBQUNjUjhUaUdlRjl0Y0t0RTZYNHM1RmNZV0dxZGJsSlhrL2xqcDd5UldkQzZzT2FuaklSSkRPcEpKdnRMZVdWalBIQjkzSTBkbzdoSTVhb25OS3hLRVVBYm9GM3NGRHBreXpES3A0YmI5NTVWNXhUZXArWFk0VTlEYitCa3BrMXE1VENtOGNuYWRVZ2xJT3A5YlBtNHhxV3p0bW1tSXU0KzBFcmYzcFBvNUE1NWVxdjhqSjJiRk5GTWNUUWZRRjFITzBMcWZzNmk1YlJPZ2w2VnpVUHBXZDl3UkcxdDhGYXpPZ2JvL0syYmxWOUNWWnROalB2bnVYL2lLN2sxZHhmcjI0NGs0NnJiRTRQVXpZd2RQYXljRXVXTnR3elh0clhHa3AxSDRDaGVDY0J4bzZVdnFCYXoxblNMbWdPM2djRWo1K1E1NE1mcHE2RzlaMlczamdUdUhROGJwcVowOVFuRWMzeW9pWURaNE9HOW5IUk9ENmI3N05saEcyRHk5dnpTenZWS1k4bHRPc051S1VmQ2d1ZGkrRzJTdmNia1B2NEVUS1pkMnZhYnZkbHFPMWVPU2VyckRtYzljYmZCQ0xOdjhRWEExZGFyWXlSNlpzQ3grVXA1YUM5NnlkRHZiemhTenVYNHJ6VzdvOG93NE9nT3Z3cFIvSkh4UmI1ZWhtOFN0MzdISkZ0N3lqU3RrTmg3azhvZ2tmOFEyMWV5YXJrZUxEMkF6dG1ESnA3ci9lOVNKclNtZ1lBc0RabmVZQXA2eW95eDUvQnVxdjZCMk9kZm5ONjJsUU5abkRHTWxlSzB5NU4wWi9CYlZsa1QrTzBNZlROZXhvUnovMXNEODVyMHEvZXF2ZnZmVmplc3YxVnhMd24zMWYrWTg3OEhlNzZLczRaU3BqMGhnTmJBbkNzcW16K1VvejN2Nnh2VzJlbkdYbEFWVHdNTlBhU2pMZkk2VVFaUGdld01OcFVqKzU2SXZRcnV2UXJOV2lZTVBoaDZsMFljYktPRTQ5aHNNUVlsSDQ3VUtNZEcxQ1krMVNhTGJ6WTZtTkNNNEdWd2VSa1F4cGpGK2krVm5TTFJVVkljcTdSblpaY1BSc1dWUHhDeUtxdWQwWFlGSFFsb3hBeUQ2SkhOTFIyM0JZWEw5SmFWdStpZHIrbExsdjUzQ3FTaU9oZ0l2TGFoZEh5NkdGTjUvRTVpVlJLL1NDeUVqYXllcDVxbUVqZTZkMGZsTWRLYTRUc3ZPWUtWNCtaMy90RmlMbS9jMlhEenBqWkZ1Nm9scUp4WFdiYUYxUXRtVnZTMWN3c3AxS0poNmxuTzA2dTdHNjFIdytuQXZ4UHNTOWJQb1FWc3FpRkNNM3VzVEd5MzErcEkwWS9SM0hjdnp2TWM2bW41U2RlM0UrYTNUOWlFcTF1MnkraWZvYm5adHRWZG1vU1JUVXpub2VlL24wY3FiWTVYbHMzZVBLMGxDa0oxNUtjR3NxSzZKeXpwZVNjclRYcThUeWRSRjBuTVRKUDhFV1lSZHhXeGMyc3hMcVRGVU04TGsvdW1rcmYyeEFSWHdSWExnNHR2cWV1T0t5RHFvNS9sUDhwNldmT0tFMzU4K0YrbTZaRjYydjdlTmF2dU5JU3VUSlkwZk1BQVBUaDFZUmVVMEN5cnFTVnl5UHhLa3RxS3FUaWNPN3FsUFNHczVnaG1pdmNha2FNbW40OWVFMEk4QjJNV0pwcXk5NFVDS2NXL0NXaGY0S0ZHTERBUDBWbUk1ckR1Z3hPekxXYStZUm5HcEtIcHFqYWVKcWk0c3ZFZldHVExkbmJoMXJmKy9oVXQrdE51dXZwczl6WDZMVXJ0ODdkUDFQZVdiZDhIajREaTA1NzdKYnQzb3l2enV1eUZMRnVDbEVHT2krYkQ0RXJSeHRQazZVNSthTll5bkFUdEhWQ0VzSXR4RjFHNENsNGg2bDE3ZnBBTzVsYmFvOUFzd1pTa3BmNW1senJNcW1rQnkvVDk5UHRFYzJNS0VwODZPSWxzRnJ3ck12QjRJdjR5YU1JYVYvcHkrdGZmRUVWbkFhajRMV2xPSGRQeXNKNkh4QlFsZDM2S1ZHaFE4QVBVKytDMWVKZGlLZU4wKzE1TTNNZkFNQXcwOHZnaEJ2SHMvT1lyeU9zVHpiNHlia3NyUThNNWFtQUdlWVJXSVp2ZEFYNjlkMUhjZSt5OWNwcGF1MFZ3MVo0U25yRFpVUGU5WDFPam5SOUpqUHlQdk41QnVjbE52K292RFE1a2JsaTRUci9XMjltYzZYM09lenA5VDJTSzl2Z1NoMHg4em0wKzNmSDhMelU4TFpNUDRMSS9YMmxiZzlmUkQzODRTcENiQ1dpajc2NExHdjR6RHkwN1czUG16VGU4bHUyUzVRc3RheUJDVlRmMDRocnhQbk1HOWo1NStYYmMzdDdlZFYxWnN2Q3YySFdYOUl6UEpBQWdKbG9XeG9lejlGTWJtbEhQRjA5WW1vQVVVWXNUWHYzR1ZwejBlcjZCdUJTc0tkeGZsNVg3bWtJYjdzYlpiaS9LRnFPZVI3Y3FqLzdIcm0ra1JTaEwxRzBRclUrU2YzOHZic0lQYjFqL05SZ2xYaW00M0lGSnlrbVlnQ0dNV3M0ZjhudzdOMnBnNVlDNEY1RUxmSDMvYzIwdFNiWVlId08wQ0ZnQlc3cGwvOVdySy8vNHIyV0llQ0hxYXZCdmZmVlhxZm1maXRqd09EUVhudXpuT3B5aTNGcTNXU2hIcGlKWXIyZmxQalFjZUF4akZvUlROQjluR2p2Mm9jTE8yK2M1M1BEdDFYamp6SFh6Z2E5citWRXRLU2sxQzN4cjlUSTNDeTczYk5ZeU5ibmIrOFhJYjcwNG53aFNsQmVvZm4xYjluZDU4dlFqelkvTHpIZldwV0dSOWJURFluU0VlZm51T0kyVXJzNnRRalNNcTVsdmpNblU3aFBZWGJGMTNUSkZaMnFOODhSWldaa1pFTzBVYmJOZ1VqZjQrYUdLMVpycnp5bHFhMk5udEpoK3RsVmRmc1NSeUxTS0NKSHNmYjZWM00yak1wandwZ2o0Mmp4ZXZQb0dWc25vcW1FTENjai9UazUvN3dNVlpSTTJ4aWFHNnU4UDZuYXB2aGN4WDFLS3hnL0h2M2MyNDh0Y3Ftd3dCckhxNitsckF0elBRTnJIcDBtWFNFdVBPOFIxa1VvZ1NKWlY0TldQOGRZdk92K25uVytWVnNVNXpXRlYvZEhudE5hcmpOYWx1dVpWcnZDM3JNL1B3Z3RUY3I5ajFiNStZZGIvK3g5RWZ0NWpQNTU2bStlRkpveTlEQlNGZ0RQeGpJWFd2SE1ScVA5alQwMkFDVkRTMS9ITWEyU3Frem4yaENHREx6VHE4ZmxiYzNUYTBabzduZ3BQeTBPcHBSbmNlYnl0eWN2VFVrQzhKVjBXaUp2MzVraVF6UUNqREpPSmVKOG1iMm5ZUzhUbnlNblExT2VKWkhLY1B0eEt0RjI3Nit1SnFtVVNRMnRWOVppV2ZZRk04cldEWk1zU0MrQ3JQWWRBOXUrNXo0Tm4yNWZPMXhlbi90eWVxb00rNzNsa3BMcWEwbkcreEcrZENKdXE1WUtUMG5meFBBQVczd3NJMnhjcXd4cm04MllTcTNEL21aWVoxVnJFMWxtcDFhbWgySzh6N2tTZ0FOcnBVWEhyY1YzQW9Zd1FrMzNaRmFZT0FkckMvMEF6RWF4STl0bHZkUW5SNDJuRWFidDEwSnRtTlNHeHBmYVpsZUNINlorSXhkWndVdU94MUYreVpSTXE1NlJXWUVGOGF4ODIzVGdjVHkrMmJlTms4MjZaalpTZ0llb0Vqby83NUhUN3d5V0xOdU1kNGRCQiswcWxGcWRjdW1rNnhiTHVMSzZ4dmtjaW5CTnkxcWhFL1dXWWNRemRNaVlWb1VSd1NzcGhXdkwwak9MRnVGS3Zyc0taNHp6TThkdE5DLzdTeXZqNG5YZ25YYTArNlk4TFZ2Q0hubWZQNlNVM0t6cnpNUUlsVnN2TS9WelY0TVM5MmF1S2JEbDBVdVBKcHloRWdENFJ2YnJveXlHQXdEVzUyby9KR1d5VzE1TFQ0WTB5UmszYWwyT1hDWGRDbTI5ZFNXck85akJkWnpaTDd4NVVZcU9HMmNyano4QXduUU8wSjk5OWRUSmlwUEg2bnNhUlFtZDRvQmxiaXN5aTFZVzJpb3Q1TnUybENMMkd5QmVHN1kvUnp0NTZZa0drK0Jwekt4cU5PTmFqTnB1T2JOZHYyUTdwYWZxTGJQczNZY2FsdmNuQUgwOG5UUDY4RnNsUmgyVjFBL1EwRGNBZURaUE1EUVdBejlNWFpVYi9BcWJHNWZMR2RLV0hXRXF2bWMxbEdMUExXVUZGc1A2ZTVSWlBHR1ZxdjlxNWxUYTlZbFhsWGhZcTNtMUowL04vY0xjVDhjalg5aFB4MWlmUGh2amVGYW9YazNjbzdtMU9yTzhubFQybDJTY0ZQZ2hjR1JWejlWMWVZZlNxY3Z1K25pNjZYV2o0V3ZuWmFsTGZUT0hMN08xNFlrSkw2OTc5YVN2L1RoVk8ycFZLb0JFNlc2bS9CcGwxOWp1VkQzYzBhZ3hhZ2NwMnJSUGkyaGwwenl5SS9QcUVLV3Rmd1ZEekQ2RHk5WmM1T25xMFdWSkY2MUJPWjAycHM2MGRjN2lMSjNpbGQzYndtbWZYcHAyNnZBSVJGSFo2VExUczBacmFuSWZkYkJZZU5vTFNjZVc0TWF6WlQ3V2NyT2l0YmRIUCt0UFRNdlc4TXdCekgzdjBiS2wvaVBUb3FQcXlEUEVlbngvbHZTTXlKOFZHekUyZXM1b2lsYmYvZWg1c2hWcXhkcEJJeDI2enFQSGx6TElGK0hLeTZaRGlxQUR5MkVHeU9UOXNrdC9EQ21OUE80RjFXSzRZOWZESE5LOEJBQ0k4SjZIbStzNlBDVzdsclpTcW4vYk12UXlZbVUyMUk3b2QxREY1WEhtY1krOXFKVmoxRkl6WXJxMzdraHVDbS9UWW5wNk5qUEdXSlJhS2RiWGRUaDFINEFsdUhoUEk1ck5ZYTVvbmlNMDFtWTlkOFFwTTJ0UGc1djh1RExvL3JwUGpoMktXZlBINVRZdmgraDNmSnVQTUdxVGN1bCtWZisrTG8vZVdtN2RUeHRGdVFtMy9pQzE3TXF3eWFvbnFicHNWbDl3WXVKRkRDM05DUFR5eGNhZXQ2cTA5WVBVM0xCZDFpZlNyalU5Tm1wMGpmcGxkbkhQMG9SaVJKUFVzcUl5dEoxSVRYV1VORzc1L3ZXMGxjbFZIQ3B5Q1RRcm1vM1B2RnNRb2J6K3M3MldoYkVHd21qTHZxSmNkM1M2cy9ZMEhnM1Z2bDltaDQwa1lsYmpoNm1yb1Ztd2Jid0xhTWNneHVNdjJueEVnUW5oUm13TjdPbndvemZ4d09sRTlGdWtxYjZyZWEwREphSTF3UTVVNFhDK3RqclJUeHBlRlZJeW82NjRTWC9XR3pwU2VLLzhPcGZjaFBobFJjdWczMXNkWjVsSlI4YXM1L1o0eEN4cG9ubmRnYkhsMzE2TitQeDNIcnA4U1Q5OTJ5U2dlWHF2WkVSWktobmFHclJuV2lvT0VWYjkxZkg0MnF4YnlCU2NKQzBlNWM2ZjRkSHAyYkh3eXJZNkRYc2NHdGEzZWF6eGIwN1RhV2MrN2JkcGNiQXkwcVF6bC96ejZ1ZDErZnR5SGxIR2lLTVpBS0RSanF3elhLZXl6VW96T3Q1c0dXQXkzdWtBVXdmZzZCM3dNMXpmdGV5WmVRRXdsSWZ1YVV5VDRaVjcxcDVHcEoxdDRaOVl3VW1iT09qN2tITjczNUZWMmYwMTByRFl2OXpZdDZmUlc1S1NMRDlPM1h3UjUzNVo5VXBqRHI2SWJsQjE4NWhsaDFydTk4YVYwbG5sZlBsdnhXZkk5dnpFZjVYcWhSWUczMHA0ek05U0Z2QTVnQXRCMTFzY05KQ0xpRm5kL0RBVkd2a3JtTlNNOVc5bEtTTzV6QytDbmJZd1NiZ3VTanpxUVpoalBwamJiSEtNdHB0eDlvbFlUNEZTSHRiM2JDZldvYVRqUnNoZXQvbXRTcEpySkVzRFVta3M0WlphMCtKNG5tTVUzTmxuQS9LMlRqem1QTFN5MVpuVnoyTXZzLzJIQmZPSWpPL3A0OVpUS0s0dzNnZkRmQ1E4dTZhM3JHaU53cm1lNjYzcjN3WXZ1K3M2cHF4Yld0dDlibk5yQmpSbnBIc3M1NTRuR1RXU0RYUGw3dkh1TXNoRzlCSm5IZWZtRDY2dW1uajU4SktIWHBMZTEwcTRMNjdPWEFkeko0UHY0Mng1VHArcERHZ1QxSlhqZGdiV3NsbWZ2L0JKclhtcnB0NXhyR1hpajFMMnJ5alJvbDc5azNsQktsdkdkODY3OUlmVDh2TytMT09wWjhob1g3UGExNG1JcCtXcDJSRVd2TGFMRTc3aFArSGVseS9hNVI5bkNxVG1QaWV6Q0hrNDJSV2gyR3FYL2Jwd0k1VDdHTWJJSVRCaXByODMxczRqMVJTWHhycjQ0dUxQOGtYVU1pMitDRy8rMWdGcXNXa3lZMFhRNjUrUG5iVEZTK0oxYXRLMThzb2g3S2c4dkRNL0pZbVBCUUR3UWszeDJqWmZkQ2J3ZUR0YUdkNjhKRHlhWTduNXZxZEExdW5YTzAxN3B2eG9nMXFlVzN1T3JLVHpkbnl3TnRabFlsUnBGQ0ZjTXhlVEVtNVJodHA5QUU3SHNrNXE3MUh4aGJTRVA4N00zN1IxT3V2NE84d0JXWXZBaEsrT1J5bEtNanpPcGUydXZzNzlpZmR1ZnQyWStQR0Z2b005ejVTWnUrMzZ0LzJyc0d2eEtGUzk4RFZNaHhTMVJMcXhVL3NPTkY4RUY5SktwUE8yWVBPWjZQZEg4S1VUY051Vm9yWjZWcTdCdmJBTzE1NnB4S29xYm00VGU0czVkbDdwSjFvZXpjVVE2VHBRS3dvZWh4dzRsUkgreThJSVkyWG4vWi9NcXdaa0hobUREVVNwOVUvUGhxQ2hEM0ltN09nOWpVZGozYndCdzJoK21Jb1pmQmsweXphUzlrbFlKNFdMaW9BbStsS3NsZ0E2d09ONVhCZVFOcm9CQURRUlE4Szdzc1I4dEFEdGl3emEyMEtXKzF6c014cThPTUs0NTdXa2l6S3FEZ3A5bVlVWFJHN0JpRUxQZnZDMUs3WjBoaC9qbHlGeHZMbU9UN3ZDdUoyUjl5U2RNaTFOU3VJTFRWYTFiSkcxeWR2L29jbzQ5T2RUZjlnL2VtdTZEYTkvTGxHSTZ4NGtJOUJyWC9RV3BieXl3OExQeXBuNzY3YzBUeTdCcXhEdm11ZjE4RjhtYVhYbGpMeVBlWmJtdW8xbEhVTVlhd0I4SHhHTk5FTm50T1dBdmdGRG1ULzlBZ3N6Qm5hdnUwWmFjbHJTb2srQnBmRU1rQy9hMDFEdjM0V3I5NzMwZEhiM1p2Nk5lN0xPTEVxL0xtcElWdVZwdTRQY3F5UTkwOC8xUk45a0J3QU00d3hIbmxWUjNWdWhMZUdMZ1A4RGdHc1orVGJENFVEZkZJUDc4U21zS3dEQUc4a1ZBbVV4aFQ4SnJNWEluNnlQZUxmTlFESGNtLzV5RmVXcDJwNWZlOE5yNUlGbXJlaEd0alhyTTE1R0F4ZUFodFd4N29tY2NFSVM5ZnB3Zlo4alVyU1QxRFVCNStaUHhIMnVScmo0VzdKYUVTZWJVYWVlSEt1ZXJkVEV0Y3hVMnYwZWpWMmMxNG9ZYVhKNXozM2U1enRrd3NUMzFPV2VFNGJ0TUpZcDIyanZMdWFoRnpOWGxoN1pWQVB6RzdidEY0RTRhYVZwYUtyWjY1ZS85NmNXeXljSFU3bkZ3bE1WYnEyemtSMjRuUnUwbVpqUnU2N3BLS2ZZRDZ4R1BIZXZwVEZUZVdUeGNqYzBpTnUweE45KzNHOUZqSHZ1L25YZjFRcjhPbXUxbjVtNlk0UzhGSmNwbWZLTXZjaVprenVaM0NiTzYvR1pZWGs4a2RTb01tMVFlanNsLytxTVkxVC9xR1cxMTNYbFppYXRONi9VNU1IUk5xeG5ycmRHcTlad2hjcXpTU010SzdSbTgzU3EwdVRaMmRTWmFXWnBpcTlOZ0hxcGRpaCs0ZFBYNFhmVnhqb2VuVWcxdmlXZFIyZDRMSW1peU5MaWFtRmNCL1lPRms5WmtsS1dwTWlrOVJUMTVaVFdhdnQ4clNXemNlcWM5T3RzaU1GL3JiWHM2cDdUOVFDQXE5RkdwVFo2S2N1TnkwT0RNM1UwYTFHTFg1ZkR1akx4V28zTDRYMVE2MVFmd1dOR1NPRVd1ZDZscDlheHRYUjFYRXh0OThWajhubjdtSlluZDAwdGh3RzRQWUU5alo2RDEycG5YaTJuZGRRZHNuYnVhZEJDVW56ZFdHY2FZY1U5alYrWlI3OXFmMTQvWDBvVmRHWm0zcm8vcnFjL0lyZzdpWkhVWm1xMWFZOGh2Nkh5RjJVTGE5UGFSbGdocEgxOER2Vjk3c3VwbEM5aSs0dVNuUTZobHNIRVBhRW1RMXM1WUZJMW95MzBOQnNkVlgwdG8yMVdyMnUxSjYrWmVWeEV3QUxhcGJVUzFaeHQrR3BXQkREQ1RYM1c4RG9NbklZMmJ0L3hsT1dSMUhTRmtlV1JBWUFMUmQ4YytuT2c4OVZKaXpIZXJneE4rT05OV01zRVhsZTJ4N2dCS2x2Vi9wTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdnQyttM2dYNXNQRlRqMnFoc3NySzlmQml0WmxSQjlwYmo4anBLVUxoUlVuaG5rTnF3WTN3amtNY3NYU0VVaVlwK1k4TkgxU1VpR2p0NUs2MW10dHkxbEJXNGlySEN1Ym00djBGSGFFOFJadjB0REpJWWRFV1VKNVRwT2M4T0VwTUllNXpkV3M5L2svcjhkNWp4d3B6djVaUW11djVXRlZKY2FTOUJLNnFwWHNldWQ4Mkw3MmZ5Nk5idklhaVpvQnE0ZlhKd2ZYSnZrV3dJK3MwbjMrNVBPclRpYVhUZzlzMEpkVEpQSjNJR2xmVFkxNm9CWVNXdHpGUEtscjRWSFF0bmFWTXZZTjZwbElvdTMvWXp6Z2FIdlAzVlBGeW1GL1NJZWxlV05IS3BtUWVhUUgvaWJKMVdhK3dLQzM5MEdQRVUrbXQ4YjNQUDdJTVZrdkNtczRKNXdjaDQyN09pSDNaY2piMC83QytlczB6VFhycDlGUDdiTXZaOUNQcVhtdFhxeXl0akZ3OExtK0xmY0xWZzNVaFhjdGh5c3M5Umd0bForVkVOM3hSaEJYbFdydmZHOWNpeDZHMjZ1SElWWWtrdW93cU80RjJPdkc1ZUFzaHhZK09DVzhEbitHTG9OTDZMWW45dGFjc21wYy9wb2U1TlEyVnJyd212ZGFYc0Y4M1VTbmJQSC9qL1pkSmw0bWNDeHVheVRMb05VdlpTd0NBS09UU3V3cnpqTGplcVRBN3dxeWpYNXFWb3A2VWtiUWZicHZDckFmVnB0YTI4NHcwTzVJeFhISmJSVHVSSlE5TVQrdlRzejdxYlY5UHY5YjhGZ0JNUTFQY0k0aE9VSkUxV1oxY21oemFMQXFSeGt1MEhqMlRYRlJHYnhrc2NhbStWQTcyejJjOTZEY0szbnNhNWVPN0xaL0F4SmU0YkgrODRwYW1ERnZ3ZjV1eUpIUFpkUE1qSytHbHV2K3BTNXRaczZXUzJvYVN0dDNWMjUvYi8yejNUL1BSVS9lV1lDTmljRmw5dmw2ajBKUG1ab3hTR2JuNUZ6Ynl0VkFLZzlzMnNVd3AzSEQyeVBMbWNmTytvM21HT1hxR0pGVjExTjg5eXlKdkdheDVRU3NQUUhPaVJTc2RUTVZxL1d2cE14ZmdFUWJBYUpoSjRiZ3UzRWR2MDBtNnZ5alhXandNaXhjV0gzNzdOeGpHVnYzNFlpb0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQ1IvKy9mL3pFZEZQTG5YL2dONnpROFA0WDNIN0kyREswb0ZvYWZUOGpWbmVjMFd3N0xBeEt5UzFBVXVDbWVZNHpRQVdSNjZtZlFJTE9vWSt1SldOdGh3UDhsNG5qVjBsbzZ4SE15WmZXa3kvWi9ybllqRTI3MGlENHFQcEhYdXlqdEVUeDFVdTJvZXUySVBrLzdTbmxRSjR5MnNiWVRaTS9ySEJlWVQzNGlYY2dTcnVYeGpaZ2IzRk41Ylh4dHRyRGVwOEwyNGZvWXNoM3BSSTA1L3N1b21TbmppTkZFeWJaWTBqTkdjTzhxWlR2aXJCeHUvZDZ2bzJwNnVvclh5Z3d6YWhVMm9lN1o3a3MvdjNVa25hZm05bU1uSy9mdHMreitSSERmOHd6cXowTnNHb3ZNS09lMjlCS0lVd2FqTTdJOGxyWW9rcXJKalQ2ejEzclQ3aTlCOVJkVnM1RFdaaU9lTVVlY2diVS9hMnVYRm1sZWJjTnRkc1R4aXh0S1ZydTVNZHY4ZUcyNDlyZ2VPM20wNmhDV1ptS2FwbHIrOHQveUNhNko5TzVSWHpCYjQ0dXFrWEY5QjExZzlVVnM5N3dkdmNaYUQ3MStqenJIMHR6bDlQVStQcFhIY2ExQ1ArK3g5UFJ6dEY5T3BmUDRoQnh6RE9oT0FNQWw2TnFLajJ1MU1qMFdYRExLMUdRVngzVjkzNUpYZnYzbk5uYUVaWXBNcWErU2U1bXhaSkduMVNOUzNwaks3czlJMDlmcndQSzRrTkRYd0ZkdzRaN0dJZXZYRFcyOGlnS3RaZXIxVzBVWU5TRjcxdDU5WmNpRTcxT1d6VUU0amRTNGR1UGdzLzdkeDgzRW5rWWhGWGw1eDA4N0tmdHduL2xGMTdYMk5GbjBMWEN5Tllma1BsNzdCVlc5VkJIL0RkYy9PZG1ZVk0xWS9jOGFzR25HTTNMS0dDbmJzdWhPZ256dnNMNEptdmJxbVcyNVBGb1pWbVoyTFdzZVZpc0RWSGkzTkZDQlM5QnJzWHVhc2QzMzVQWkJNL29HR0lYVDBkNzZ3aU45MGVycVRuUVJucXNhTmY5a0lzS2hLNmFCWDV1QzA3bGtQRU9KQUFCT0Jtb0hBQUFBQUFBQUFBQXdjT1lDZW9YRk9od0dZRGhQNjFSWFBpOEdNQURnaTdtamlvTmFCZ0FBQUFENEFtRFVnY21naXdFQUFBQUFBQURBVlBERjFGV3hIaW1UaVBEZW95Z0UwWnQ0S1dzdVhSMCtySGp4Zzgzc3gvUndKOGdXK3JaVVJDMHJjSE84QjlrQm1rdVZTcjg0VFgzWGFJZXR6Y2R5cGhrVmwwTHA4TXYxZTZyMlV4cC9ITHFuaFkxbElNY0lOekV4UjBTeGVWclBkdE1LVmNpUTM5RDlDYVBIKzF6SzhTeXBqaTFkNW54bGNXK0tKNEpsVnlxaU82MjdYZEprdDhXd05iNmNjM3Z5TWZVVklrbXFSa1NuUnMvYVRNWndTNTVPck91SlV4aHg1dWdGR0lmSSsxUzVaQk0zbjJOL1BaNG0zaU9kUG8yN25OcHVNNnhaYXorZE1aNHYwQkZERU9vNG9qS3B6eFl4SXIza3ZNLzBjeHBrTTQ4SlgyOWxaYWRvMlhvVTh4bnRielgyclBZRkowc0w5OWcyVzdEenVFL3YwTE9rc1R4K0hkZWpyb3lVWUJhVzF1VVlZVzZNa0RHT2tVL1VLK2NNdkRidUdYa296bTgxTDkxaDl5bUpyRE9rTlVsVzB1aGZTdUhENjdRV1RhbXgxaGdENEhsbzgzTWR4M3ZkV3hZdUxCSHhadWlRVWJQdU12cXQ5NEc4aHRoVmFDWjNNY1lEOTJER0lMTXVQZXY3S1JsOERJWjQ2SmZncTlFOEFaRzFtSllscysvcjNZSmFZbXhldWFjaDVlMVpEMHRvanFvdHE5cFBhNVJadVBoMEExUDdDK05ybE43VGFQMEN2MkVmeWtIR3NWVEhwNkxiVDlwSGtmMFJrWWxyaEg4V2srVGxvQW5PNTB6VmIxT1J4L0JJM2xibndrT3hOTHUyTkJsVmpoRnpuM1Y1Sk9VTjlkT2dqUm1NcFZ0aWRUbHMvTk84eGtDOTFuQVF3dVNGcmdLRzBYU3VkNytzZ2lrOHIxSkVWNkF3T3h5Z1VrNER2ellGQUFCd0QwNDBEbUNIUElVcld2cUNQRE42TkFBQUFBQUFBQURzd0RMcFMwSERuZy9xSEFDd050QlNBQUFBQUFBQTNJV0h2TDhCQUFBQUFBQ0dBb3NPVEFPZEN3QXorR0xxNmtST25yeUluclBrTHNrOGV0cG5mVThyUS9LZGlRaStoQVhINXkzd0hQdHhZWjE2bTllaWhpeHl4dEJ6TnBEM1RKVWlaMjE2WU90NUxpTW1BV3Zla1pieW5tdkRUVVNKRHUvcVBOYm5rc3JRZTF3Z2RjWEhHOEd0MVBLSTB5SXhILzFTMmoraWV0Q1Mxak9PTGVjL1N0OUpsSFVFZHo3eW1DOHZydEM1TGl6RDRWVHE1clRxbjdERU5DOXpzcm1aeUhPZnRqb0xsRUY1SHQ5dE1xZS9YMjNjZnlTeWtESkc5YWpqU2QvSlBlN205RzZ2RFdTVkdiRjFSanpoN1BOdFo5QnJWMUk0QjBralJsSkhVWFcxZlNtMVVMcXh6cnRPazZJdHNMSk8xSnhLbnJIVHByR3VIM3JZMmkvTG9pM0RtanF1VnBvU1d0a1JSdG5KeGlPOW1ZOFJ5L0VZTTRMVG1LbTVMK2JGRi9VZ1l4Mmk0N21tOThtNGNXdnR3Q045RVJhWjBid3M4U1I5NHJIcDluT0MvblhUT2lVZDkyTmZmVUsyRkI0OFgwN2wwTFR4bW1NTmdPL256TEduelJoMW5OSG1WRXIrTW1qM0pYSWxmRG45Wm4xUXJSRkdsc0hhNE8zOVNGcHJPTGdIbzAxY0xnK0xTZGZiMXl6OUdvQkgwYkZTb01aUXhQQzR4SmQyUlo0ZTZMenlleWZoR0x1bW1LdzVwUVE1VDdIcGpHNHRNVzhyUGx2VzVrTTV5aXhOckwzUG9RM2oxdjJXdkk5eHJmYzFNRGxPSmVvc2JZRmREVm8wKzNsanRNcTRHTWtYa1pKOVR5TXg2Ymc4cWV1enJBSXE3OFNVUVp1ZmdRTlU1bGZDNlliM05UUEl1Tyt3d0lvQ3B4SmNiTFg5TjdJbTgvSzE0NkhIQ0lDU0NPR3A4cmJmNHRlbUFBQUFBQUFBQUFBQStIcndFWEVBWW1Eb2dHazh0WE5oVUgwNVQybGdkR1FBQUFBQUFBQUF1QndzelFDNElSaTRBQUFBQUFBQUFBQytpejlxakN1T0dRRWZGancwenZPTC9kTzZUMWJ1OTV5RVJhVWxqdmF4bkI3WGYwWWV1QnpQa1N0b1lCdmFzWThScFhMQ0lMTWVnaUlWNWZ3dVlqbCttenU3TE9nY0o4ZE1KaXJHVWtQV2M5WGF1SkhhNzlIWTBZNGI3Qkg1OVIvVHA2eXN4L2kwWmZMVXZRejNKUlR0dE5PUlJFKzBtNHFueTNtN21IWWlZM0xrOVJYMG5scGJrbjFNV1BRdUY0OCs4ZmNUbzVEWHVlbEVkSmNxQjVtK0x6bEdqZ1NiMVptME16aEhuK2xNUkRQRmEvUTBwN08zWDA0VzdUa2l6K1ZOMDF1SGtmbTN5Wk5UME50SjJhOTZNbGtScGUzMzB1alE1VW5rOURuTHU3eitaMDFYNXpWbXhNeWM5U2lkNkpFejRnbWplWE55UEdoSEkwZDZrL1ljelB6VEhpbks2cGdtdm9IeVBwVzBtWWUyTWFWa3llVWx6YTd2K3o5Zk9yWVU5Z3lkcU9IUjE2eHlTN2IyNS9LVzRuRjVVSXR3SXQzNzhkNGRJcEZZdTI5SmM1ZGtyUXh2dUZNaGx5ck85cFhoSWtUT3lZNDZ4aEt2Q2FPejhSeXNEWG1tamNPbGwyck42Z3lNMm5BVzdjZ1J0U1I2NG5sNk0xWHpwUXFyMXlaMWpISUliNlhVNGZ6VDBMcTNUaGZ0U1Z5clh6UFdBQUFXUzhkcVpsaG5MNTgyM09QeGFsam5kZXZ6ZWZKK3A3bEN1WTFlN2xrcmlDc0xKOWVTbHhiZmtnY1hKcnM3K2pvcU9CK3ZZb3JzSzlUcExIbHJXQlF3QU12aXRSSjZZUEt3T0FCWVVVMWFkY3haOG1nSHNsVXhSZGZERktOWGFYSktlbXFYbjdzUUtmYlJjaFc3Q2kxY3luS1FsRmsvUnQ2VjhiZ3ViaVZ1YWFpODh5NjAxeE1oMmJMVTZuOHZzL0ZESDU0Z00ra2txYlE4emRlUXd1RnR2SnJXYUFQRG9ab25ZcGVnaWI2VDZEclFvaHkxUmZhaWZVcmJWOUI4Q3UyMXA0cTV2TSt3eUxneTFQZXB2TFg3d0FIWDJUUURBNXlPTkJhNU1hVEtWQVk0TzNVM0FiVlpqWVBxd1hBNC9kUHFwN1NQNTVuSHFMbXZaL1g4ZGNPZzF4VWh5WVBPSU5HNlBSZjM3OS80WWlwNEJsQWVBTndYak4rSGdJWUdBQUFBQUFBQUFBQUFBQUFBTUE1NG5jRTAwTGtBQUFBQUFBQzRCN0RkQVFCZ1RhQ2ZBUURnQUZRanVDdjUvLzc5SDlNUHEvLzhDNzloUFFYUHo0d1h3ZkpMZnU3NlZMUlRpUVlkdFNQOW1ONTZnZzY0T2RhK2hBNndSenRKMTNNODFVQjZ4NjJtSXkzeDVpTlZycGJHbzBRcm1VT09WcC9aQVVaTXhONmpwb041THF0RGZnZnU4VFRYZllIUExQNnQxWEhrMkRINUFOM256VDhlbzVWTkdGMzZhM3Eyc1BmNWZwdWJHUHVHRFQrdXlBampKdHB4STNscGVZYlA3cVB6M2pWanB1YzY3djdRQmVBNkZvYVp0aHNmN2pkMXZ2L25uZFQzdEQzS01DZnBLNmk5TFpBUGYrbmorcGJ0em1LMEoxM1BlY1hrRjNFK1ZEMDVNdjBjeHRKMkpHUHozSzh4VlgrTjlMQUVZMHozM0l6SDlvdXEzQmRPdFdHK0sxNDZzNlcwUG1XZCs1SVN6NUluMTlEY3FyUU5sOHFTRGRkY1dpbHZCblBEN2pvWEcvUk9UOTJuNGxqaVdabzcyOHJTMVYrYllacmxZVXViRjcxbG1NcVpwYk0yN01wRWRJb21RNU1WMVdQeCtxUmJLUlBoL3JuKzA5cTBidVI2ZzAxamxsU1gxVjQ2VGs4REFIcmdMQmxwSnVEaWVEU2hSd05HeXBLVXZLVTh2RE5oWkliVXJFaXFYR0Y2elFqcmcydEwwSkZsNkhHZFdTc2ZQSU1lRTFkYkhsTHg2N3lzUzFJQXZnYnJJRWx5UE04WFVkMzdDMDFST0I5aGFMOUZzekNTSXR1Q3NRN2Q4dWI3QVk1N2RhLzdiMTlwRXNyQzFHM213alhqcGtWYnc5YSs0U3lFNm5qM05ISnEvUUR6MjZyTnYvMXJ6Nzc4MlNBcDdWTElxWHhFSjlvdk14dzl3MXA3WE91V0RXd2I0REVCVXJLcjU1dWlMUU04UGdlTGY2T25URDE0WlVKVkRFQ2VqdTN4d1Nsb3FwRk54K3lIdG51dG1ZbGZCOEpGQmk1SG1SUXRmZEppWmp6YURJa3RmMlZaWURyNHRTazRIWXh2QUVBSUtJK0pvSExQNDJsMWpiNEZBQUFBQUhCM1lOR0Jyd1FkKzBUT3JHdzA3SG1ncmdFQUFJRFR3ZlFMQUFBQWdDOGt3OGdCQUFBQUFBQUFnQjFZSllHN1lmeGlhazUvL29YdWZTbmFDWlFYWUR0RmZERThwMzBtSlc0NVJwOTFlQys0T1QzSFRZTVUrb2pMQkhxenVvV09KTEVlUDZXY2NiYi96Rkp5ZlRIVmM0S3M2ZFJXNzZDazBsRDN1VHdtelE2N0xKeDEycHYzTzh4eXRoMXR4SlQzS2EzN1dET3h0T0xsUkxxblY4YTNHaHhXZTVsOWZzMjZsVExsaUs2aDlubFRKd1czSnh4L0h1dDRoNWNjUFkzNHJwMG9PaGNZNWU3bXV1cVBza285emJSQVpzbHVqMDE4M1JhbXhJT0UvODJSeGRBR3NWNnRmem0xR1BMeW5qQnJ5NlVPbDZUTUhNOWUyVkc3WTNWZE5LbU9TMGNXbWI1cEdpdnZZU2xuYWpYaDVkNmIwL3pUOHEvb1E5WThyZmFIWlB4WWJYWXEzVUFzUmFyRFU5TFZWbExpY1dramVSdnpEQzNSbUtsT3lVb1M1VTUzRFo2MTl1dzhSOG4yckk5N1pWcWNaU05zQUsxWGVjdlNoa3AyRkw4T0trU2U5bHJZaDlTeWZtV25RNHI5ZmFxc2JRb0F3SmxvM2h5TGxocE5yV21zT3NLcXZXdEdXYkpXVDM4a0w1ZHJmOHVJSzBRYmgyTlVwWGhzV0NxOXBTemFOa015aEd1MnF4V3RET0IrV05ZL25yRTJxajhEY0FrM3RkcXpZYVVmR25NUlArd1ZSQ2ZnRFhxU1BPNm5lZktTL1JrZjI2ZThydlB1MmtUclZNcFpLY25la3ZSN0N2WDFiOCtlUmlha3RlOEo3RU56STZPUTRWeXVoWXg3TEcwUjgyN0xwOVdBaHVUTTkvbFNRSVYzMkc1d0hSWk5jUzk2cDRnTnE4dlQ0eHpzVlJrWE1XWW03RytXaUdtak5ZRWxyUmJmNm9xQXlqREFWYnAxN0tDeWw4YXJNdHY3cWtsUFpQSzJ3UmtSQUhTVGQvK29PNi90OVV6M25EcW12aDNOdlFGT0JWOU1CYzhDU2dhQSs0RnhDNGFEVGdVQXVCZlFXZ0Qwa1RHSUFBQUFiR0JPQU5ONGF1YzYvN254SlJVQWdJY3JOWWJuWlV3QUFBQUFnQkJZSG9FYkEzc1pBQURBU3NDc3VnQlVPZ0FBQVBBMS9MRkYrK3NLZ0FWd0t0cHBUQmRTQnNVNWpSbUZxVS9iU1BzUllqMDlTQkVMN2tUa3VDVk5GamhpUGFLcWs5NFp6OUlkdnFPWm5iUEJXMWx1eDhjMEozMktZancxVnB6M1I4cmplazl2aXh2cnVtY0NrdVM2dzRvaWNaMFJjUHV4Q0lORHh2MmNrbFVYblIwc3gyTHVaZjhkSS90UTI0TWM0K25weW1NNzBhRHl2NXV6MEdHNWpyUUNNOHN5dUU0M3NrMnVOQVZhVHlMM1dodmJ1ZGxpM3NiN2xHYVEwdnRpOVliMzRKVWRLY3NkOU5Ha01uYllmdFNYR2MzelRmbWtzTVZyN3FkOTN2SmpuTkcrVi9RaGE1NGp4cEQzYkdybkdrMzY1YjlrVm9teU84Tm55aTcySU92WGduUFA4ekF5NzhHOVNxdmp0UVpHeXF3SDJ3ajVuamhScTBZdkx6Y3ZjZXVld253WnBvMlhEaVg1ZkttbE1IVlpsRHNGZTJjQVhFcnJ6YWtweXZVczZqSlpUYURrak9lTjJ5c243RUdhc1N5czQ4eFN3VlE1UEd1d2FMd3JweFJwTUlGN0l2VkRTenZQR0w4QVhNYk5PNmg1VC8zMXIvcDFxY2orN3hXTVZrVEZGTXNpZzVWZHNpMjZtRVdWS1BQQ3RMVm9PZnlsVzh4ZUU4WTZuWEIrYUxwRWl0LzVGWjZaNnpZMlhRWmV1dTIrdHdZczRkWnY4U1ZqL0FmUWE1dlBhRzV3SGpOdDFhSmNSOU12M29kR0wzZXRzaVQ5SE5WOFBjMXRqUWVWMEVIYjhGSzhsT3BKSDl5QTdtYlNCTFI3ejdsS1l1MWJBSGhwK3hvVm50S2gvODNZaWZXR2Z6MVc5d1owd3luZ2k2bGdLcGVQWTR2R3pVa3VxQlRlZko2N3VlMFNGWWtIRmdBTG5uTTRhVUJZWGhMSnpmOW5zTmI0dHo2eG9VYmFsNWJ6R2RvdUc4STlaV2pqdDllVzNoUE5TN3Vmam5WOGl4bmx2RElPNk1Yek1kZ2RZUm5mYm1EMFBIYysvRUZjZThhM2xta2gvLzI4RUoxU3RMSHk2MzlVU0x3RGZJTyszampSZUNOZllzeWYvMC9Eb3l5aThrZVhYNUhaMWhsUmgrTks5RnVXVDRuMlphUHN4YWg2UGo2MVY1ZG91WUZ6bVRVMkhGbHkrb1VwR3RtZkdmMzBJNXE3THc5UHNneGxpMXdGNVdHNmNlUllzdVkxTXc4dXoyaDRqMndqUGNyU1M2VElnNnZRKzVnUmErUXpUajdqY2JqRzRjYnY4b3p1QUNPWU1VNnpJR09rTHlJSjhmUEFQTHpNMCsyNVdmZDVueDRBY0QxUmo0SjJ2OWVxOHNiM2xGR1RSY2tZOFZ4c25sYWhveXUxeDgwenc0N3NZWVdKQnBQZGZmSDB6VmxLRTRESEVSMU1YSFJtVVc3NVVlclVjVGpMZW1qekdCbXZUY1h0bThWUlpUYnQrZGZ2bWJOaWtSM2VwVWptMG13cld6bUovWmRXWENtUGVkQXgycnMyVjZHM24rbWxvL0l1YW9yNnZpMFBudEgrR2tBaU9YS3k0YjQxSHQ0UFhCTnYrNS9KdzRkNVZ2Ni9ZWGxYVTh2REdqZkNHZTZPUjlJelJhS3lsOEl6QnFucDkvMS9aam1VVXVWM2xNem5IbVVDbnNzbzAvNUVOTlAxNjFUa3FBZUNicGpLMWtUR0w2WUN3SS9KN0x3L0RlMElIU2xkTkx6NGsxaUEvcnNSZi9zY0dtd2MwamllckZTNHJMeUg1NDNnM0M3VlZucDlQMVZoUGNweWk3TGlZSmx4ak43czUzekpyL1ZQU2UwZnpQVjVTS2VmSG1PZXc2M1ZOUlpZY1U0WnR0NnhsNnQvUDZObCsxcFBOc2pndnlEa2kyL2pqTTR6WUo1UjQwOTZEczk2b2F4UWw5NTRvOUpKSXJXRmxXMk16VEhOaXhqU2p1YVlwQzE4NUR6K2JVb2ZrNWd0dWk5K2R1VEpEdE5paTllS3pVVGs5Z3ZIOFZZLzB5WnUxMDByWUxWRHRyaXp5djZTZmRMeWFHZ2FwOHk5UmFmUENlUlNqcmx1NzljZk5SbGR0V3NzMldjMHFEZmVHZlErWjFiQzYrdWVWMjY4UFhRbXRySzA5cFJ0T2ZpSmxkbTYvYXB0WEFDK0Rta2V6a282ei8yN29NMElNNTZ2bkRFZEQ3YmhYUEd2NkJSU0I3VjBiTytMVlpqcTdzM0kvanhxTEtGUGdhOW44R0Fxd1QyTnlGaHp6UlZYclBkNjQ3V3BiQ3ZETVRJTDlVLzFSMXZwbGZWS2ZpblYzOEJGYU9EQzVkM0ViNStPazFTWXZPbGRVSTFSYmZESm03dlBsZWxZYzV4bG5ZejNxZHl0YVNKRzNVTXBuZmV0VlkybVdKUGVZUW1HWWZWRmFQbzVrcWRsZU03cUV0N25CQlZSZlF5V0ltckpIL3lVeFo2V3ZQOVNJdmM4Z0JkY3h1Q0pSMTlIOVdNMWZiNW1LSXlhd0tFYlRnRS9URjJWckZ3dnNIalNEaVU1bGZwdExtM1gyZnArbm1vSkVXR0o5aGRiZlJkWUU5OFVicnhxRzNGbzhEM1NPSzd2U3dUclZsSVpYaXpkSWVKTW1VTmI2Ulk0VndwM1RWL3VSVFpwaXRWZG8rVFpoWFVnejVEdEZGV1U4SitzSXBPYkZpK3oxNWFlbFM5VWxndWFWVExaY0I5emlvNTN2bllKdGVxS3JNYkp5c0RleGs3cGNDblVMMXVYS1oxbnByRnpwdTVRNXJoVGJMclJ6K09SbzgyL0U5aHNBczh2WS82bXFlTHp5OEg5ODdRdlNCeHp0Tlg5NzF6M202dFZMWHV0Q0g3Y24wWHZoRE5qM002Y0JDMEdsaVhQTThhdll0VXduVzIvSVpQVGlGK2piVjg3M1g1Yytobk8rM3F3YUJiK2FiMWp3Yk1haStySXFIM2RrNmQyYmRWQWtmWGdKa2FMM3lPN0VUR3lTa2NPeTFaMGszY3pQUjJtdU42aXpPaGhjNWxZK2VFOHJQNk5Gb3RPc1JMcDhGNUxnc3ZMbXFaMHlGTG1LVk1KY3FKK09QcXg1YlpydThSOWlZNnlhV3A5MXE3aGpqR2xuTmNabHdCOEI1VFZZWEdsMVdtMWNUeGkvRnBubVJWMHhhVmw4Smp3TS9QMHB2R2FFVnFlV2xta0R1K3RxdzdUSFF6RXVwYlowUHJlVEpQUHFrd0J1Qld6SFFaSjhMOEY4czVLWHRqVGFCajV3STJ2cy9HSjZwU2ZOSHRUSisvU1o4YnZ0dTFBakxKTnkvdXY4ZVpXdlhiM1R3OTlUNWhGNCtpNGw4TkoyYWUxR25zV21kYjcwWGhmVG8vdG5wcTBWbHNIVlg5dlRwbjdtRHk1NjBWb2RiOTJQUXBwNlVtVllUWlkzcHhBdERPaEVTNUhVcUhkT3FNUnZxWDlSMWcrVWJ2Y3Uvdm9NMkEwMHRKaVlCWlVmNTYvQS90bGNQc0tZQmlXdm9rZnB0NkZ4MnNNaFUwenoxUWlSdm1TZ2VXOUQyNkNkMFdLQnFkcHgvRXNENGNoNjltczF3Vm1QTG1qQVc4NUpzN3NNU3ZnZTk0eFkycGVIVnRmT3JzVXJoTHJvUVhEd2tuVWhUeGlRcEx5cGxiRWN5M0srVDl1bXluL3pBNWU2T3RvVnhwU2hsNDgvZmt1eW1UMDg4anhxQnBzWDY2d3ZEL3FvVnplRnFOMFlEU2NTek5yRUViTGU0WHVLN1prVWxVZFBubWFZckJ5L0FMNXAvV1BIdHM5NmI1VmRyUWZSK0piMzVqaFpHajJpRldXd1B0WG1jLzI5dE56UmwrdFdIc045bGxHY0VVZmZzcTRXZWM1NngrKzZsWWd6YmRaMXdEY2pZVzJCN3Z6U0dtdXYvSVdldWpLS2VMRVBhbWxPSHVERE5CYzZZcUl5b1p4QTc2S0w5L1RPSldIN1drRXNpek5TV1kvVjlWOFhGVC9IZmZEVlZQdVArbXBQUTVMbnZhV0tLaytTS3JkL1p6M0JnQU1tcThIelF5OG5ERTFmSWxkUE11SzBIYnFwRmVpQUFEWFVvSmhKdG1GdjcvVEM4cThEN01BQUFDdVoxUHByeCttd3B3RE90eHJieFNsSTIwWXpjTFEzdDlMeW4wcWJCczY1WGhiWXVrZndnQWZVdU8xZmUyVWdYQnpNbk45UXAxbDViNjNDSjUwbmg4eWpFRnk4WEQzZTQ4ZTNHK3c3RmVYbW51cnAxYTR0TmJKUUlvbnlmYkVwOUlUOGVXOXBsZFlVN2ZxRHdJOGRjdTFDejBadGw5RTVXdHlaQjNMZUh2eDVXcGJHcDZSb2ZpMCtXZWt3ZlUrMFpxTkVNeE0rcWxDcnY1Yng5akdWTjVkYS9SOWNURnExS3pXK2JUQkUxd1hINzc4TFlnMFp6RlRZNDJ5UEVhMDcwdEdWaFpVVE5jcmRaaVNWQzFERTlQYlUwcWltanU3eHR5MUkyYWw4V3B0eFpKa3c4aVQxNWRNa2xyVkdhcjJZSEsrN011aVpGcXNZNGlzOHFEK1ZjclVyNTlHNk1nTmJYS2c0bzNLdTVVOVl1eFlpaUhrWWZHOVdjMlArcjVXZlZiVHhScGZpTDVOYmRzUzdlZi9WYnkzeFNlWUVWVFJ0UGxwWGJ4OU96S090YzdDeFU5Qy9PaVl0TGFrbEtmWHQ4QTlkOFNlMU5iaTJnU1RER1d3bGVzNHY3VHJvVTlJZlg5L2QvL1hiN3pQM1kvTmR2UnJXTVpjdEpjQUFNWmhuUU1sTThLYmxpcERZZTdYNmExbHRjNzlIaStBTm9ORStMRjFKT0hld2xCaDNuV045WUc1Qm90MENPNjZwNU54eTRhaXBOZDhLaFJyRzVLZ2w5SExXMjg0QUxkaWdwVnZNU0xZZU1ZOURVM1h0K0Y1eG1ybVRuc2FsS3pQbmh5M2p2d0ozN1lMRC9zUzlCcFYvV0x1ejV2MzJ6NUpXN2FvZ3MxTTJUamY0T2YrZmgxY2hCem90ZmRlS3AxakpxUzE1WkREMnpLVUpsZXF2SnMzb3h6dTEvL1djdWhycjZHbGpWOHFEaVpXRmN2Q3BnanhOYjh6bW1BTlJ0bXcxbm00cFFUSzhpVjl4Mko5cE5ScDRqUnhyUGM1MmRibTBaYlQwajFyV2FGQ0NLeCtIZTArS3ZkVzlLak8wZ1I4YkRrOUxRQkRhRHRkNXFOSjRSYUtrcVZ0ZGZUQThRQUZzQ1N2SDZiMldQSGdxYlN1S20zVDlRbFlYWU1ZY1YrQ2QvTVhQQXFyamt6cENwMndsV1pHSjdYSzdmVWlnamVveWpDbE0zdzYzTDVnUkE1UTBIVFhLSjFwZlF0dG5rWHAvYUZjVDE3WGREN1BtNDNlY0NXZHRYazlNcjFsNkk0ek9rK3ZESi9NTVZPZ1g0TGhWYUJYdkRzcDRKWEtlbVpaWnVaMVlaMzJEYTBtN1dEZFdhZy83NkNmUnFidmJhQVJ6b2l6eHhrY0pIL3A4UXQ0Wi9wc3lITnQwRy9XNDF2YTQ3ZHZIZjEyKzNWU2RyeVdDZ0FBTlJZUFUwcjZDNW9qVi9sZU84TmpSM3lGTG9UWkFZQU1weVM0ZU8yZUJzWVh1QlVYekd5SFR3THRBcE9TT0FVelRlTzV3NTZHSlVkWmNaWEdWOW9lbmhRcWM5c0gza1dJS3RHOVFpNnFJdis4TzFMSSsveDYyUHN6elN1SS91aHBYTzd3SGdEZzVxelhNanp4SXJJV3Q0Tm43bFZZNDFGN0dtZUNwUW9BY3hsbUNjRzNBSzVFNkh1Y3J4L2Q5UVFzeTl3NkxocmxGUDRrY0E4NGJ3NFhkNkpmbzFhZ3JSTHRIYmRtVngyM0twbngzRktoaUJjcW9iOGVnbWRsakE0aDR4blBKNzRGWVhXbVM0NmE0MHR1SzdtZHJSMlRxd251dXAwZHRBa3JwWGl0OVB3QU51b3E2eTF6UkphMnk1K3FJM042eXhWNVBtdDdmMkw5cGlxNzYrMnZObHpPY3d3alczVVlyV0V4c25BZXUvS3IwTWJTMzQzZlROUkhlZDN6V0htU2pwVFMyQzNLbm1hclg3SSsvNGR6YTgyR0lVYllkb2V2aDJ1WmVlck1XOGNqbE1LZ2RyVWFXbFY0bTdPOUZISW0zRmVHVzlPMU1KSzUreW5OSGdHajdLOHorOTZNU2M0cmMwbHJJSFdQclo3M29UaVJ6VmN3QzZQTDFJOEJVR21VY0I3UHFzMHlScUo2c00zTGtrYXJpUnFEVW5RVHIzV1NRMVVUdG8xMUhyV3FLUzNPaU9tMjBKZTdaRXljOW41V1pHdEYwc1pXTGJiMjE2Nm0zV3oyUi8wVVo2N0JSOERsRlZscjF6TFByb2ZvZ0pYWFE3VG00OVlvOG5OL0pEZnpreEJ6NjF0RktJTUhlNDBXSWhVQVlCYlNpTE51NlhpMU5tSDVMRFVIVDFubGVSK3dOYVM0OEFpWnljTWlVeXRYZEJyVzVMWjUxT2xhdDN0UlpFdGxwOUpKYWNCNW5Ma0VQVXQydTZkUkswVUFMcVBYZHpKNVJqZjZJOVQ3YmJnMlI3Z1k1V1Rwa1YzSHI0bDVFbytwUElxcmtjSUlmZCsyT0V0SjNkbDZlTXdsVW1LMWQ3TzRWai9YcHQwL0NlOWhLVTJxL2JzR2RVd3VCNTlmbWNMam9PUU13OW1UNUlPTVA4MTk3bzBIem1kR0c3Q09kdWErVldZWkpPc0JXS3ZIczJ5WXZUeVBNRnYrTGVGTVBLNnlVSW0zSUdxNXExWVZaeTZYYWg4V2ZRT2N4YmJNeTAzZm5kZ0hveXNQRElzR2JtNkJEcG5LTmpmZ2g2bXIwMk5GUHdIS1gzUEI4eGZoR25yc1M2SDZtblVEQU95NWFOeGFHREYrMGV3dnRuWmUrODNZZThBWnlhalRNRXRWRytjUUg5bSs2Q2NOcllMaXdtZVhZUzdIVTV2N3BGMlQ5bVpJVlcwK1NPQ01CZUdJTmptcFhVOTFGTkhQSkdtTTNsb1lWNHVTM3ZyMnZ0ZnoxdVNLT01zVmZBelhUR2ZWWDg2eXRPOWcrL0QwOTlYYW1uTXVlR3JFK2t6YzJ4S2VQRFFsVEwzNVNEM1BBR1YrNnB5d1RoR0tJOVB2c0xvV2FPakhzYUp6NFpveXpiT2EwS2NCT0FQTjJ6TXp6MlRJdTNmRkZtSG1haERjRUV4SGF6RExqZEVxcEpGb3JoaHBPUWpBWldCUG81OXY4Q3VYNnI5MDJDLyt6Vm51OEw3My9lMU5lK25RVXJQYlZYOEMrZzd2Q3l5SGNHdFpaTTZjQ3Y3V2k3UUh1cUszNHh3d0lZTWJNV09RamxoOEYrYzFDS1B0d1VPVEFYQTlrc3J6K0VaREdjR2tBU2NEZi9xTlFDTk1weGpDOE1OVVlFWXo4S2tPNTNYc21PTm1KYXdJYVNJUFFxVW5MclhYQ1JrUjRLNUVqNkR3OXIwbm9CMFNLS1ZMaWZlcGQ5U3AxcndXSjdzbDNycHdqWkVkNFlVT1N0VUdUSkZrSnlYdnBNVFh3a1pBbFVrcmZ4dlAySkdwcWoxVXY3Q1paY0piZHJzc2ZYaTNtNEh6UnRGRTFUR1dVUWR3UEVkeHlZalBGNTI4bzRYb2tVRExLRWJkcVczTW5vZGt0Si9WQ2FVeXBPUXVSemJrMGEybjc0YTBkVlNIRno0NmxUenZVcjJUYWs3d09vM1d5aFpaZnZhNXpsWFAxckgwN2NwL0pONWVkaWFLZGZNT0xxSUVVaU8rOUZhOWlaUzRlT256c3RXaEpKa3ZRcTRpVVM5eDVVYklNVXJVUUpyUlZwRitvSG1UNm5nVTNyeDYwbHY1bjh4U3YzQlgzMy85MjVaRlU5VFVmYXJMVzVabVJIRTlpRXV6NEZTZmxlZmZqYUd2VU5ralBjYlc5YXJOWHVialVKYUhONitSY0lPRWk1ZWFlTkp6YTgrbldVUHk4OU9lbENMRzNmNHExYnJtOTI2NzNzbE5Ib2RSYW9KcWJhNXM5aDZhVGZFQkFESGFjVnYvMjk0dlREeE5vMXJJalJ4ckdWSnozNXRuRXVSRUxOVHB6SEJoRjJPOERhcnlSNXNSSG1lRWxyZDFPYUIxTXQrVUNLNUdVeElXazY2Tks4bXp5cWJDc3hBSGdLL2d3ajBOenVtUTJ6OGNmbll4TTh1SzZGdWhKczVTWGUzWGRibFpxOXF5K0t4YmkrQXNiYjlpR3JYcGpsODlsWXlPck1pU0pVU21BbTdkL3lsVnUvNm5LYS8vU1hrY3ZSMWxGODZubEJ5VWxBUnRBajZiQlNka3I1M2hsYjEzT24zdTEvK0NlekRLaHZYMEtldlVaN0dIYjBCMHB0ZVdxTkhxYUdlajBWYUkxVldndVJpK3BQblBoZFBQZGJoMERVNURzbXpxT05yOWVqeGJkNVhJZHdxYXpGcWJEbDBGRElQcDJPL2JpbzgzT3pxanR2TFdWaDdaR08rMjlLd0h3RkE4VFlFZnBxNEtCdEk2S0w2M25JNEdGSm9QL0dEdENPZ3d2MkR3ZkJsQ2d3NXJaMFZCbjhJS1pmaFc1dFZ0Y2Q2L2hDdTYxV04wOE1nbCtBaFpuQ1hKdWR6N3lsMXZQMS9iNUN1TXhJbGxlRGRmSSt1eFAwb2RYTmREcG9qejIrTDRRc1djWE9iR2Z6S2xNM3dtQytoVVJiLzlEWlkyYzdNZ294ano4SEgyVmphWHBzZWJwTFY3WnZJNkF5N3Yxb3YySFl4OEdzN2lLOTlYYldBNTF1dGtaeCtvdzlWQTd5d0xhd3VBYzFqZHlqaGpOYkdDcCtYV1lJOEtySWhYZVZoY3lDdTdOd0JZbWkvZjAyQmxQWFZQWTZQMTZWc1VMU1htbGE1NlU3bG8vbFRsMnB6MTRZNzBNd0l0YlN6L2xXeDA2Z1h3ZWJsOHQwOTBTYkx6UHJnZlVWdldvOUFlNXZUcmZReDJUNE81YjVYWnMzc0dGZ1lOZWd0S0lJN1YwbWwxdy92NjljZmZjNDl6WW9RWFdGZGdJc0xFNHpVTm92MFNLcklDRmJFTW5xWmdmcGlLcnIwTTNGdDdsalRlZEE2eDlYVkplMlZhRE5sSEhzdEVFZTVweC9Ta0pwN2xRYllrVFozRDJIa29JeHYrcVdxWU84N0crcjV0VWVJN3NEcE9JbG10MDd5U3kxMVRtcFlPVDhRcGhISjlmMEVuNGtFOHF5YXpvd3phUkZ5YzE4MVJVT1FFbk5PWVQrZHdQWjY2OXMzNm1Sazl2aTIzc1V5elIzcTQ0dmNDVDV4dk9FNnZpM3Jpa242Y1d0UjVLYjNEczNpZkdudjdVNWRMYzMvVkRxTFZoRmRXWk1IRnBLR2E5U0FpSi9vSFZ0ckFYSFhnU2x2NWxySXk3Y2s4Ym0wMjVOY1hGcjFXaEwwRysrdmNlbW82MzZ2dm9yQ3Rsdk9WbHZUSXVweGgxUS9TUjlyTEYrV1l5bXVDdEtlVnNoWnhGYThrM3BxVVZPWllaclJiVDk2dERjQ2wwK1MyTW12Wm5sbzJsb0V6VE5walFMZUdsNTV6NU5SbmJkcGdudTFqWjJwTUdYMkk2dStzbWFWa0ZzYnhQWmxoKzFqVDlIU3VNMnUrZFpaeFpmQ3M1NmxyVHFZVXIyOWV0Zjd3dERScmxQcGVIY0xsVW9jV0psNHRqeXZYcHpZMEc0Y09CUURNeDJwUDlzdyszdFd1VmdadkdpNVAwOHI3Mit3SVdRMS9zS250enoyUEcyT2VNMEtmaHV0NDBuMXdUM29OaVhvSjF0Nm44b3FZMndBc2liZERuNG0yWmhNNDZQalhjMXFObVR4aWRjTFY3WXgxL1Z3b2Z6MjFEcFQ4K2EwTExKZVh6UGZqY3Z0SDViMm5VV1h1ckI2NVRybDlRbHBHWW1YVTY5L3NTdjJKc1Y5cjA3VDF6TzJuSEwrY1dwZXd6VmwrZnZ0QldKci9JNHU1Mk9KcXhxeFdscHRPekY0NzJrSTIzdit5cW53VUhsdFdHN1k5ZHZISzVzWUVSajB1VmZYU2trWFlWWExsNGNXNnE4QmRVM0llcDE2NExZMDYzQUwwOCsyUWJMNTJnRXI3cFlXSVg2ZHBSUUlRUnJJZkNUMzI3cmROK3NqOEUxMUJlK2VwMnhPeDZlbzREN0xaVm9ENVlTcGFZUmtpVFhGeTh5MDFiaTh1akdoWUpZeXN4MkIxb0tHemZEVVdBL0Q2WnQ1S2NiRTVpdjRlNDlUbVc2Q2ZUT0IyWGEvbkpSVFAvY2RBVGNoRnVlNlJUWkdaUEpQaDJyWkJ5VDNsUG1icjFpL1YvVlc1c213ZEw0eTg3MGNINXFwdG92VmJiL3F6MHZiSnQrZmNWOGExeDJLTnRWOWYyZDRqNjNKMHV4ejE4TEF5V0tjT01pMzNFbFh5NVcwTW1yOU91bHJQVWsrbzJRSjFXb2xpdUVmWk5seVoyamdScEVWTDFNNWFpT1lSUnZaZjBZUjQxRTdyNHg3NFlhelR2aDl0bFhmWE5XZGF1QUNBZXlDOS96cERCL1M2K0tDWEdtQm1nSlVaTVdBOWIwSlBjRVVBY0EzWTA1aVg5L2ZzYVZEK2RxOFB2djNhNmZ1SGprV1hjL2hTcXNWOWR4cWZ6S1Yxc2Y0am5QMURYUEU0aTd3SmN3SXdha1ZRTmZmbnpIZGtldTNoVWRzcWk5RzcrMnVwMW05ZVlrQU5nYWNoN204YTBtVkptV0JBZ1l1QlMrd0NlamRGbnJNd1hJSS9DYXdKZHlyVG9scXRQUnlnZFZDMXhaLzZXTkZEeGpKemJWd2QxYzltMmR2WjRscnVBd0FVVGhnMDNDRjZ2VEt2SCsvZVk2aTRhMDQyTlJ0b3NpVjVWRHBMNjR5dTdaNXpicnk5cWRESmR2ZG12LzVNaFhHelBwMnVmZm9aWThxSzFucEx6c2Z0VU9LNmVVb3dKRlNicjkwY0xtbi85Y3JObXJOWWR5TldyZHdQVVg3THdObk4rWERmVnBaOUR2VVhVVXZLbGRUUzFjbG1kc2FiV3RMMTBYMWx0VEo2Ni9TTXVtN0dxWHBjb2tGaWMzU2Q5WFJ0cm53OVB4Ymx2NkJxcjl1MXYyaDhKbEViYnlVOXhSbDVnYkwxVEV2TWw1ekRmdDdYbUR1OHBDVU01M2VjbEM3bzNkWmNSempzcEIrbmV1Vkk5emtEa3JKdG5KM0hGVDBmaTFDWHBXUXllcnp6NlVWUm02L0l5YVc0NnVxSXk1dkxNeFBwZzNXd3ByVmtkTHk2d3FOK0RnbHRFYWFWWmJRLzRneGZoQ1ZPMzdxZ3RyN3FyNVZJTms1cnc1VkcyakZ2T1ZUNlFnN2Y2cTB0eHlrWEFNQVZXTHdaMm5hZ3BNMHB2NHhsaG9qdUczSnhyZkZxZXR3Um5QZHFPRkpGdElVdzJuQml1R1pHWkdNNkRtNzZqVXpMSE43cHFGMG1nSE9adGVDMWpoM3BmdFIwUlQ4Q1M3UENTbmlpbjkyNkpPMFdmbVg5VWRCMXgvbmRlWC84dkNKbHhqZHFadHU2RkxKS3h1ZXk5N1NqTmF4M0lVbDYyY1d3VG9MYTh4emJkN3QvdkpQSjlIWFpyTFhqTWVLOGZpbHJmTW14NlpYMUpiUmRTdE9CM1BvQnRzdzk4YmFidGw3aWhyTm44YjNhZERrWTYyTjZsN3M5bXRRaXk0cG1zYlY1V1AwOGo0U3FwSHE2U2tSNE1vU0ROV0YwSmV1S2FBTCtlVjMvMXpDQTJ6MVdkQkV3QkVQZmU2L055dWVhak5mODYvSDFGMmZ4dnQ3OEdQbUFVQll1dkRaUnpUOEpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBL2hpNm1wb2grUXQ4Qk4zS1d2dWwvdmVYL0tIaVJ3V3oxMXZLSFVlT2RWblJGeXdJSjVUaUtscmNDUmFSd01QR05YVUwzZWFPaFZmTzkxa0RiaU9yQjBiSXAzTXFOQWVLYVBtWWIzdndYck9SNXNuZFE2SXBneGFHUnFlWStKN1pFWHl0clJ6ZnYxM08zKzBDTEhtamcrcjdLWEc2QXhENHR1UFRES2ZxcGViT0hrZnAxQkNyRHJCYytTbXBDdjRjNXk1THkxeUowSHZZLzNHYStPT095M2FzbUxRN21zZDFYSU9reFZ0ZG5lU1gvOHB6VEc5NUdPMzhVU2hhYzdBdGM2dmtUSmtXL3ozVU9IeWFQdDFmYkd2UXk1SDdtVHlFdXBqeC9MSXMvVCt1WTVmYTdXV3BSamk2bW4zOXhNVHpzbWFhWGRGcVBYc2pFa3pRaGwwL3kvZU1VVGYvd1R6ZFc4OXZkOTYyajhidnAwaXViL2NoTC9IczYrWFdGZHJFcVA2a3BTbmRiMmpsWUZyOENTVXhWTUhkVm90U1ZNV2M1WG5zVXNUTDhiSDR4QmJ3TnFGR09jQjkxVmhha2haellodHliM2NSOXRGSksrS0owM2tQa1ZFaDF1d3J2ZXBQTFB4Zm1UT3I5TmF5cWJWVDJhazcrMnJmV3RuTWVkaWZ0NlBmTzVxK3hKOWJhTVYwM05yNno0QXdCVmtRMWhScmxOelB4bkRreU04Sy9lbE1uRldJN3NlVnZLUTJPeU4wOHlJSGpQWU9qVktGVExhTnZXRWU2Y1I2M0svelF2VDFiWE1Ha3lXc1dPOVAycnRoVDRIdmdiUG5vWXdjTjRML3UxR3p5QnJuWDZiWCtiZ0REUkNEWHhKU1ppc0NFVk9ENXF2UHl2MytUSzE2MEYrZmZnS0Qzd1o5VzhhdXlmaWFDeVVKa1o2NzhWekVvNGhtWlR6Kzd4MFdiYjE4aitIRUlwODJCUDUvRmYzYU9aZG5rZVoreklkVzFkK25pejJjNjEwZmI0SU9vM1dQeC91aXhqbGJyZkloTzF5SFpFcG8zZnRGcG1lcUtrL0NkYzN3VHF6YTc0VXJZcXQvbzJjNGxaRWovWGhWUUZRR1FKYmcxbzZBWFhmR2crc1FiRUZ0ZnVmYmJQKzA0UjNEV2dBckJpWEE5eStmV2I2cmRYOGxMRHVidDllTlk3ZTFKQjgvWmhIVEhoZHlUWDRZaW9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRENSLysvZi96SDlBUHZQdi9BYjFxWFFEdFdhZUVvRWR4WWdGYTRWWmZpaEZ0S3BSRlFjcVJEYWdmWE1neFlsbWpjcnNCaVdQa2JGVFlaMDZBQTZrK3VvUi96V3JQOXQ3di9UeUxhb2xHdlF6amJUMGdtM3pWK0RHNEgxMU5vUitWam9tUVdWY0ZGMDg3d2xjbVJNZlMxbG1zWENhUWRaOGQrRHRPUWRRM3U2cGVabGkyRzFoaEs1RCtMeGFweFZXNGRIVHJkTmpyem9NZldSU09zZjdVdUwreE9DajNHT0owRFR1ZXdsQlBXWENlMnNUYzJnbXFkRFdMcXlpSzRVUEl1V2xXREtYV0xSMmlTUnA3YjJXb3RhdHVZbDNmbk5pNTkzYzVMRy9WVjRGenJhT0cvampqZy8wQm8rTSsrUk5IbHBLcE9zMnNaV2J5N0RKV3UrZ0Z3c2VhY3hZMHdwV1pxckpYcVFqRDBxYisvY3lNVXB1c3oyMkU4dlBjNUM3M0JOaHZoV2RlVnM5cDdlMFdzMXNVTk1FSDZtdHZwK29yWmNUMTRhWEZtNDhEWnVSQ1BiZkVpMDFzcEtLbHRPM0JkVk5KOEQ5MFVWajFZR0FLeUwxN1BBcGVmU2pOQVYxakxObUZFT0dySXhBY20wekw3bzBzeGNCa2FKTElOSHVmckJOY3pxV3g2WHpPaWxKL29ZK0FwRzdXa0lQaGJPcDhMNVhCcC9uV2lRWERJT294TlZaUEs3SHUzTHFYVzh2M2krMGtyNVo1cy9TQm5hbDBXTGF6WE41Wk9aVk42Sng3K25JVC9ITVY1aVMxU0lOTWUvK29oTXVHMWFUS1FtcUNIVjYvSUgxMkdaZnEyTGNFMm1kK2hGOWpTU000OEhRMVZwVHY2cW5taTVtZExYOGRITUFxaWNyNmJYVjVxWkFNby9XUytacE9VUkFEdDZ0a2NiR1ROMHYzYytlbngvdDlwNllCcFNIOFd2VFFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0lrLys4dDFUeDk3UEo1bW1keUUyUmhlRXYyRDlQcmU4S0pxbVZNTUtzUlZYMFVBSnlNTmdQWVlETzU0RERRNFRjK0hHQ2JVcVhkRzVFNUIrVy9TV2FOTGVJOE1VWTVHYm05enh4aTVQc2ZVMCtDamFublVpYm1EeTNDWVlOdnlSY3RyUFl1T1A0Y3FNNm4wYzNMSG41U3I5RnIydWovbkRyd0gxOVpwOUVwK0tPMHhWbG1PSjk3bmVsWHZhYmVGU0ptYkdMNEdyazhXTGtKK1d4d2JYR2V5VHVKU3ZPSzgxdEpIeW1DRjBzdmVPYTQ0NzF2Q3RiVGU1OWUwcDBQbSt4VDRPbDNpMHpiSEpMN0hBL0dsUldsa0ZEYUVMS1FZdTg0cnE2bTJlSjl4YU1sTEt0YzRGVDV5VXJBdWZDSzJVSzllaXNqYmVvMjNicndUODBDMDZZamlNQjRiRWY4YmY2VWFhOXpYazdZdnBHNXh5eUVDa1cwcGg2Qkk3K0JUVTNYdTF4TGo0YzY5clArbXZHZCtPNExPbzgwN0svRVQwZkNaak1abXdZbTNIUDlwTmVLNWUyMitubUh0TTdmMlJheWF1V2hscWlKWnZsRFd3dmxmTlJsbjlmaHhTR05INi9kMW5JaGVqdXFJa2JVY25aZEdZTlZEdHJKUk50RytOWGtsY216VnhqNXMycmV3S2ZreTFUSWxyY3pMb3VOWjFCZ0FZQnlhT2RMR3FlTko5eTFqbDFvdmF0ZldNcmJsS3NLMUJ2dWNqbVY5Tkc4WGxpay9ZZ3EwOTduMFBaVnNuUlNvTW1uVHIzVjVZSTBIenNHNlpxSHVTM0lzYWFTNEVhd21JZ0Mzd09NcnRNcG9ydFZGZXRGRmIvc09Wa1Bpa0Q0MWYvU3NrNHZ6dmlVOHFpUzUyUHErbXZZbDFDMzhzUFo4KzI4SW82aUs5L2tnYnFiajE1RStCWDJsYVo4MlYvL2RsN0ZLWmw0SGJ6RUtlWGYvMXpIT2Y4a3kwVk5EWVdTMHVlN2JndnNTYkl2M0s2ejFQbWttcEhFaGNqeXIwVWVYaXBZSlNDdytZY21GeU1rQTEyQmRZTS9NeXlxZld4OUtNaGNhenBhWjNqckxqclFpdk1QVDZzZnhsRUdUellVREE5WXREVXlGbDlPenAzRkk4NzlFbWRnZnJaYzByRENKemY0KzNnSkFKdGpYcUE3Y3ZtSWFzZjdydUpTSzFPYkluankvZ29neEFHVnhHdmhpS2pnZGpHOEF3RjJBdmpvRDFESUFBQUFBemdGV0J3QXhNSGJBTks3b1hPalFBQUFBQUFEZng1azJIdXhKQUFBQUFJQXBaQmhhQUFBQUFBQUFBQURBTGNuLzkrLy9DTDhSL3B5RDh1ZGYrQTNycFZpUDFxM3ZVZWtuTU9Ja25TR1paMk80OTVoaVNXYUxjbXF2OS9BWGNGTkdIcy8wUkR3blYweXFVNHZxU014OWE1Ryt0enNvaXBrNkJUUm5QWTRaeTNIU1VuaTBSYytFNllXN3FzL0dldlFlTzhiVlhSR3U2WlJhRFovUkF0cTRYb3BJYzBidmIyRjNWVlRURzFiVE1WSWF1VkMwQnQyZkVIdzg0Wm5MdzZMUGpySTlKd3ZyU004cjZldFpuZStramkwOUpxZWZ6WjlIZTRwaHlUd25NK1Z0YVVxSERSRlJsZnRZL0hoZUMwMDU5a3dPM2tYMHpQNDhVdlpvM2VFcG0vZDg0dFRJcG5VTE9kOWtlZ3psVnhHT3A1M3VuNE03L1Q4M3RuNHBaNDRWem1sMnhnanRhV2VsUFEvM2UyUW5RN2pBcCtHUG9ucXhMcjR0MWRMYjdKWWwyREU0bEVmN0VlUDNZd3JMNXV4OHZ2dGJFZDdhUG1QMXFWa1NTUW5uT3ZocVdKK25EYWVmVTFybjhMbVVYZnlpWHR1azF1V1MwL0d5Mmp4WGIwMEFub0xIMTUrWThET3R5WWhzNzBydFlGOFlwOU95cWtLelBrZkVicFRjVjVvc0M5b1NuRUxyd041NFlCeWpYUkc5c3JUK1RGMEQ4SGdXMjlPb0YveWUrY2hxOU5nS2tmcWUrenRXUnRyWFZ6bWZhQkgyZzNJYm5vKzV5bVZpeW5Jb0s1VzIzUitNMjZGMUhqT21Fclh1aGZEamM4cDdyanphNExKT3FCNmp6MXVtQjJLMTFjRjltRGxsV0lhdlI5Wk43T2dycTFTenFxeDVYRzFCYU9iVzR6aWpVNEhMbU9LS2FQYy9qUWFrMThvQ1lBcjU4ODloYno1Vi9iTWM0L2RrR2RuVCtEbzRoZFM3Zk9xUkFYNlE1Z3I4MmhTQVdVQnhBWEJiTUh5L0hiUXdBT0JlUUdzQkFBQUFBQUFBQUFBQStJRlBCUUFBQUFBQUFBQUFBT0Nld0s4REFBQmdDVTZja0REM2didWlmREgxQTc2WWVoSGFJZW9VblVmRm5IbFM4TXdEVkhaSXYzUS84YUI2VGVScDlRSE9CUTBxdzQzUHhldXRHTU8xQTYrdmVVelBtU3BXVGFXWXc4VlFBNGV2eFVXMDRuVzFxcVBOckZyODRrc2VvbThta2crVzJiNGN3bjNONUNoakZscU4zMHB0UzhPNXhYcHk4cmVpUHEvY2cvM3hMR2l5anVIY0dEcXlmMUI1K1dEOVVxcTNzNHhZdkZqek5Pck1FYno3RWxNMmNzcXJ5dWY2eE1pSWxjUENjNk8yK0V5dGJTRFFmTzNSLzlUajVzQ1orTWZyeHQyVnZFVlhqQmhiUFdYd01zS3IwcGxuYzF5cDlOVmg3bXVOM09uLzRsY0JVbXg5ZEk3SkV2R0dXZVJFK3E5bVo2aEtsSWtmeWJQWTRrbFpqQjZtbGlxMjVqbWljMlY5dW1xRzNQRm1JbXFhR1h1dkxFTkZObitvL1ZRR05RS0pkYnplZmE3a2lOU0wxMEUzcHYyMHI1Ym9LNXZmbElrc0dhL0hmKzByS3E5UGlpTEkxTDdPZXN5UmtnWUF1SkxlRlhkeXhMZGFjQjdyMFdyWmVTMWFTOTVTdkdnZTdreDdNNHVhRUpHOEkzdlEzczdDNVFIV1lQYTZLQ254cVRMd3hvNThEY0JYY3VLZWhyVGd0K0oxWTNrL2wzNFE2Q2xVcjRVMXdvclE4N1Q3MjJuWmVYLzU1dUFUSlp3eHVmWEhacCsvN3JqZTFkUFphdmE0Tm0vWHM5cFhXZlB1YjFzZGExOUdQY1pQVFh6NVBoVm1uK1I4dmdnKzkySklveEdka0Vma2ZRSFNNUFlOR1R1d2VjN0hNMFdjbVZmVWRyOEpvNWNtYmJ6VXhMZnNpdVpCZVo5aFJVQkZER0NXSGdmZFJOMVZZbk5hMXk1Y2VEb3VvUUE0bThPWFVyZjd6TFYzbnZXT3VUcVByeGtlMG9JdW1nNjY0elR3YTFQd0RLQlVBQUJnVWFDZ0FRQUFBQUFBQUFBQUFJQU1QRWdBQUFBQUFBQUFBQUFBQUFBQXdKY0FwejhBQUFEd05lQ0xxWGZoakJPQk90Rk9zem5sRWFSZnVHdEhGRmhQbEhWOC9TQks5QWYvNEdLMFBnUjhTRWZvV0k0N0hJeDJNSEJSNG10eUtkYnFRdFl6d0ppR2EwLzc3UG8weTRpYW1YWDJXeDIzWm1STE0vRjNjK0NaZFd3OU1YYzdVWFYva21wNzJ1bVovWDVKOWR4alFFVVZ6cmZPVnhmTUZiNUs5bmhZNisvN2NHTm51LzlKUTVXaC9Rb1JkZUt3LzRUb3UzWWlxLzdxUkZ3b1JmVzE5WXpDa2F1MG1VZklOckNHMS81VThaNm5HWVZucHZTZUlHdko0emhlcmVmb3pad1V6dEFKMmhHcVYrVHRTWitTZi93WjRuTmp4NXJGL28rUFdNT1hWRXVSTTlXKzBLajFjNGt5dGIwMXJHTkt3ek51dGZPbUpkblVYR0FvbHRYT2pDbXk4OVRXcU1tQ2FRSlJHMXZ6enJSTXpwb2NPUU44SDBIbjdsUW16Z0h1QVJpcEg4MSsxdlNUMXFPM3Uvcno4bDlTeWRWLzYvREU1SHhjSDVYZE5aVjNtOUlYRGdBNEg2czJzbHBkUFZobFdyU3oxUmJ3UG5jeTVNWEdhK3grWlZtdkNFditLYk9tZDlubU1iUThjcE5SRmxXR0dxdXREdTdGVEplRDFaU3pLc1ZrREFmZ0ZHYjZ1aStFMms5NFU0NS9uaklPbzRwS3IzUGQxejNQT0JpMUw1WmZiYlQ1VTl0clVrUXJKa3NSMjhoSkxhTmU4NFZNVXd5R0NPZTM1Vm90cDJOZGEzV3ZmVWsxSy9WVERuRzU1N0lhYUpSMDcrQ2p5b0FKTlF4VlphaGkwTUlwdzRpS3RUcmlGMkxHWTlieEtObmU1WVFVcHpmdjdWN2tlVGpaUUdCMFphUHlid0hybDFUMlZIUFR6cFR2a1BwU3FoWU9BSXRsVW13NjlNK3JmVVNhU04rem1CRVdNK054cWhJVDlDM0FyMDNCYVdETUF3QUFXQXZNVEFBQUFBQUFBR2pBYWdiVE9iT1RYZG1oTVpqQVY0RU9EUUFBQUFBQUFBQUFnSDd5RWo2R3B6Z29BUUFBQUFBQUFDdUQxUUs0Sy9oaTZsM3dIc3ptaVcvTVdsTjAxbE41QnhiTmw3bVZ3R2tJNm4xR0ZIY1lFMWdRei9GTVBjZE8xM2s4dldOd1k0d0xPeGxyRWI2bnViblpRTkZzN1NtdVpjVHNZT2tJWjgxRTNEbHJMU002TkhVa1ZQWEgxTHFORHo3ZWpuaWRFSHRCNzcrbGV1MXAzcWNZSEpyUk9zeWUxazhJam1WaXVaYkdUSHZ5TVgxYThmNExRQ3QzaTVVNmJrOVppSFlzSTUrcFowN3NrZW1KNXlrTE1kY2xKYXRLcEUwbHltTkpDMjhac2ZROHFxL2p1TzNuakRGMXBsWlpXNFBGNlQwZmtlRnc4aWd6MXZiUlgzRi9iNVJkR2Y3ZUw1S0lmZm9xbmZUMVZXcTlNS2FWTlp0OWhsNjJ5STcyWStzNW1KSmQwY3JxUk1xYXluS2s4aHlSaHlhVFdlWnFQV3U3VVF4VG43b0VrNGR0Q0xVcVZ6TEhmdERHN1N5Yng1T0hOdFpHNnh1eDl6RjVqbnp1a2M5Ny9HSktla3V4ck1Ib1BEKzJIUmVMbG4zOGVzdFJTaWJpdG5JQUFHdlE2b0QyZm1yQ0k3T0pOWjFtd1hIeFBYbHpNOFRNV2VnUVBzRjJxV1VYaTZsYmg5Zk1uQnFsK0hVZW5pV0t0VUV4L2R5TDNuWFJxREpRb0c4QkVHVEN3TFlhR3BtN01XaFBZN2dWa1VTWm83NWVTc245alVXdDkrajB1Zm8wVHVIQ0UrSHpGSXlodjJuNGtoNG4vZVBhYy8rOHgzMUFLdGJuSHI4ZUpzcHFuQVMwcjVwRzRQWnFlRHQ2SHlKNUt5elNmUGR0dWZYSjFveGFLczRYMGF2V2FqUWZNRGdmWFdISmFibDFWUzF6WkIvNmNxeExiT3V5d2F1dHBPWjBidVVNQlNxaUEyMmNna2RoL2NLazVqb0RZQWlOZnFyN1p6RjB2alA2cE5XMWZYdThteG9QWHg2ZGdjV3VhcHNOdnpZRnA0TnhEZ0FBNE1pWnM4UFRaaUxNdkFBQUFBQUFBQUFBbnNBSzY5K24rVGZnY3dBQUFMQUFWMHhIbUFJQkFBQUFBQUFBQUFBQUFBQUFBQURTbndUV0puSjh5NHdqWHh4aXJTZmFER1g3eVhWdXJpTjRqalEyM3AvMjNPQTgyajRXd2RNUm50cHBTbWY0UU01c2dqV2IyM1B5SWhOT25XQkNmalgxemgzZWNnYk5wT2ZiblpMcm5KaFlSc214U01Ec2FNWno3QXdZZzdsT09WMnAwUnF0V1loWG1yeDhaU25HYzVmWFk2WFNCY3BTRG44dzE3MzBMRjdPeU51YnhpWnoxOXVMSitXWU1zeGZlaFlsZkd4dTk4cmppcnpPWk13WTBhTy9Ba0lkK05VL2plbmU4YkxjNDNNVmVYenJGdU85a1hsWmJJUHgybU9QeGM0WVRERTgvMjZPblBRMi82aGxrRFZjU1NzT3RjSmNuckJzTHQwUnptWjBROTE5THFHY0xsejRDS2llUE5LSFVKclZqM2EwcmEwc3JSeStaSmxNazlseitRRUFLNk5wa05sNVVlRXo4dWVzcVJQTUNQMjVKMDZ6N3UyRkdiYmVqR2xXa3UxeEViWnlNSFd0eVFxbUtQb1NBSU9adEhBUE9hSTdIUm5pZFM4Vy8vc2NKVm5FM1dwbVRha1lOU1ZnOVB5a2VldFVhczFaVC9wMjVhdnRONlRVZnFsVmU5RXVtNmNBYnUzZE4zVVV4OTFQR2ZpbnNVanpHbzdGRVpkQ013STlZS0ptOFEwbDJENVhNSElMcHpqdjk4alV1R2tmaWk2aDIvdlJuU2xwWnl0YXRwRkFSUVRRSitSalBDMHV1QzJ0K2N5WnhkelVnRzRCaGxNdEhNUlhzSW5PdDhYUDZKajl6SFpGQURlUkpzQVBVKzlDK3oxY1RvbE5HSWh0MXBhNGw2QzlJMUtVKzVyY1NOM21WN0tpUmd0bkFVN0Uyc0c1dmxpTTk1OUtjSXlGMDNiU3FScHUyT3phRXpmaGtsT0IvSEdxbEpjejc4dUl1TVhxZE1ieWUrZXhFWGtlMHRrenQrYVVtNWd6VzFQcllVdXA1NGdCOXRSNXhlTEIvc3ZVaHJicUsrMWVHMTZJdTlvUFVQbXlIRGRqTXlQbm5qUFdQQWJPUit4Y2VLVUd1bkkxeHp3M1pVUDhSUHZNRllmKy9MODQ5Y3NnZXF2bFY3aHRZVmpTUHUrVXVERmxuODhpTlo5L1hncTVhbnllWlBPNHVISXl0RTR3WjY0ZzZMeXlGTFcrTWZNdGNzYm1vOFp6bXlMdFVoNWwyZk9QdG9HVVYwKzdSMTlBeWgxeEJ1djh3Mk9XMTF6SEpXaGJ2aVBQVnVRSlpHdXpGajVOYWE2YktVN05tNHFuTHJWdmhkY2piUjFqa3N6SWdpR3FVeVI1V3A1Y21yUHlpdGl3V2htTElZZk1wRGpHVE1hWVZKcllqMUl6ZVRXaTl3SUEvRmpzU2V2OTN2RnBLWXZWbmNYSjlsaFR2UmJyVkgwMXF0STlza2FhNmhFem9vNDNNdzl3TDZ5RGplc1BxYm52a2RuS3BtUUJBTTZuZFVTM1lTSlJmeFlYTjdJZW5FbDBQZHl5WHdkYS9PNzU1YUE1L2pBMVYvLzlpVWpIZTdkcmVlV1ptREljcmIxUGpYdWZ2K3pLVjk1LzFUbmtycFlzYkk3MnVtM2gzaUh3ZVVaNzl6Uzg4WHBreDN3Umo0U3oxYW5tb0hRcGJKeDdNV3BSS3JYL3FEd1dKTEx1cDY1ckdkRmxyNFZlRGRlejNJZUtjT0kxSjhIdGFmY2ljNlVzU3FMdnQyR2kvQzErazBmRUZ3ckFENUZKa0VwYjB1RUhxSGRlQlYvT0tCOG9PQTNMVU1JUFUxZWxkSVlEZVpMZ3drY1hBZTMwYk5EK09yMHJoUWwxYkJVNTBpRy9Oc0hTYm9aanJtL1U0VG5adi9McHZiNEtiemtHeEE4L2VqVGh2TG8rYysxd2x4NzFnMlVSQnJ2UnhxR2hxVjVubVpoNmRpVG9EV282WnFrMlcvazhqNmNRNzUrTEcxdTFSSDRqR0oxbno4REJWbGF1OHl2S0VMUEFxQkhTdnVDaDYzeGYzZ2NUSi9YSXBOUGIwbHpaVjlhekkyejZlMmJlMHZXTVBFYkhyNU1XNmJKRDd1R1BINmd4eFNaMWhFU2s5YVdMNnZVZVJ4VTN5M1AzT1JsWlNPdVJWWk9KeDJuZi9nbU9XNHR4TXh0aWczVXJ3anVLYzlIaC9ncXhNK3grZUI0bVprZm80U1VZcDRjejlOcU1QT2FYNFN6YnAzNVI5bmhvancxZjc3M1NoZ0hnTytGZW5MUVF0WHlTVUJadlhwWXlSR2VqcU1WcWpkUEZ5QXhHbVFZZVU3MTBYZ2ZNYmZDbFJQc3ZsMjdrSHV4b0pRa0FzTU81YjFKU3h1VEl0VnlQSlRHYm5qSndlMnhLS3FzZmh3dklYSjVaM1c4b2g3LzhQNTZrVkx5K0kva3BTMWIySUJOeFA3cXUxOUlaV3l6RmlLWTdaeTg1emcxOUVaeWJManZ2cDhRL09teWZlekxTTGJuQ2xEYUp5THAvbEJWQkRhWFpXcWpId2xuWjRsa1NiMldmMlJIQUZJcGhmOVBqVXRQa3Qxdk82REpnS0I0OWxLOHhENjBtN08zR2h0ZVE0SzR0aTFFd0JFdVQ0WWVwcTVPWjZ3c3NYZXU2ZkFtb1FtbktaL0NEU09LZzd4N0toZU4zU1VyMXIrVTNRRlRhd1JSRGx0NFR3Q0pGUC9OOTJpU1c0aS9XSjVPaU1ISHJUOFpjOXNEZWdSa1p5TnpyVUoxNUZpRUxOcTAxN3g2RlJSZkcva1hVODVUbGJkU3l2QU1JdkJ3YXZqUS9samRNVE85UFZXbVp0RWhidmNkWXh4K25VaksyMFB4T1k4VitPdkZadWpJRjBsMHRteEZkejRHSG8veWl1clhOUkl1cnhUZk01VmVSdVJ1dmx4NE9uNTBiYVQvcGRaMnJ2L1pmMWJMVmVNOUl1djVMcVRQemxtckkwcTh0Q3d0ck9iNWtndVZNUVk0aGorMmZBL0t0cWp4cVg5ZHhLWW9oWHVRTkMwdWVXN3dSalpEcFc2U2RsV1VSeFhqL2tGY2FoMk5CejJvcFk1bmVQYXJKYzZzNmNrN0l5b2J2N2lYSHBKYkQrdFhXKzNDeU05akZDTitDSlg2ZHg0dzh0UUViSVRhUTI1ZGkyL3NiaGZqckUzZlRVcFM5ZGZ5S0RaVytscXpYT0tVYkFRQWpXR0ZFT2N3SUZ4WTkxTWF6NnFmTUNDMFdHNGl4WVRTRzJoOGpwM2l0TXFrd2o5empOR1B2dUZtNTF1NkRhNkMyaWJUcmxQcjZjemFXQlFBUWhQVUVEQkJkTCtnL1BuQldWNHpOUE1rS3lpTW5tZExXNjdaaXRuYkdULzFENUhEdXJ0eXVXU00rN2xpRDgrdGlQdWRvMThwTS90Njl5MCtKN09HWitFdVMwMHExeDZYU1djTWlQcFpaM05RWDBWWVQ5eGhVaHk1R21XYzNCUmlEdDUwMVdaNnR5b1dHVXUrU2RaTVI4VUpiODlTR2J5MVRrOVg3dkQwV0RqQkFkYWEyNFVjWUlHQXBXRlhaK0FCYm4rSmgzRE5iemdBTXgyQVcxMS90M1Fla2JqU3o0N0VtcWRkR2g0SllBdHNQVTdIUXVwNTJZTjJBVVk2N3l6TjMrR0s4YmhzTXJTOEREZXJqVWlWeEhwRkgvTHBxc1RpREFRQitNTy9FSUhXUHRuTWdLVEl1amFkQWV6NHZSRXQ1YTNJc0hhUVlwK016WFBnek8vU0ZnNlZFMm9VVU5DSHVuWlNJclI3SG1KY3o2am9TbTVQeFZPVi81blBQeW11aHRwdGFsSUR3c3Z0bmNYcjB1clNsMEtQQmloTFc1bkhGMjhsYTN0L0ZpSnEwV1hMeHRDUFRnYWZ5M2VQNStPTHM4WG1MOHhvQUFDZzR6MUtQRHJHK0JPcE5OeXJOeVBSZlEzYmVCL2VqZEY2UFJscTBZR0FDWU9STDl6U0dLU1I3T3J2UHV3aFhmUXg3dmV5MUo1U2JYNmlXOXh2NEJsL2czN2dEYllEMks2Y3hHZXZENzZzKzVNV2twL0FjRnpPb2lid3E0UTIzeE5YNkg3ZkFQNUV4ZTlGejBrRVRBL0F3aXRFS1cwQjNBa0JTbnhmVkJHRk91NENZMndDNjVXVDBINlppOUZ6RHlJRVE5TEZvODMwaHNtalQ5RzZrbW4veFg0aEVvMytjbXBvOENoMEZQaER3aHV2QTZDQWZLT1ZCamVjcmYwL1NHWDQvdktzOVJmT1hWd1AvS01lcWdYZEs4OHFHNWdhb2RVYytVbll1YnZUTU4wbHVkRm5VdHF2dithaGhiRW0zSjFmL2JhWE9oWHJxcGJhc1poVm1BWjA3bGZyNWF0MVRTdlhNMG85UEt5c3ZYRWQyNnpnZjRtMWpnaDVWbW1hUlM5Vis5VEZYY2kwUGUwYm51V0VIL1hxbE1ZTjlPeC9lMVVpNzRIMlM2akwydE5iajFZb2l3NTc3T2IxNnhIUE55dnNNZXNvd2F1eU1yQWV0VExhOFlyYWFuT2RuV3FYenpzMnhwMjA4c1V6Tlp5SExJV1pQM1k2cDB6aVZmYUcyaHQyT0dKZUhzNGRRUlJUdHJHU3Y0aUxrWVNtWHB3bVZNbEdySldwbFhBUVpiQjRqbHBiVzhONzRKcTZZQzlvOHVVNXpKMTlFTkkyVVBpTEg2eXZpMHRGdFV2OTN2eVk1cGl4cTNwbThLNDNnMHFTSnZyUzdnZ1VFQU5qak5TTkd6QlJXRDI5RXUwdW16WERkVTR4NVJ6T09QcWhYRmllL1RiZmxhVFVqdkhqU1p5S2RsTGEzYkdBY1Y3Z2lJbmxhbDhNcElCdUE1Vmw4VDhNNjBWdU5uTnZORFZGbHVLVisrUjhudHUrN2RYT3puNjE5QnY1LzRYOS90RnJlcVpwSmZ2ZUZYTGtldURWclBwYnk5ZDl5U09OM21mazdFOWNPMWkrcGNsOUk1VmIzbVF6bERDdE9taGZOV0pNOEc1MysyTHNUVVpWRnVSNlZOK3pxYTVsVi8xYlhNVWRKNkJzbjBPdng3a21yK1d2YTlJL3REcElPYlgwcjJ2M0hWK2IxREhWak5EZmFkMzI0MTRUYjdlUXpWbXdBdkRHdW9UVXpZaVJmdTl3ZmhXZkxHdlBMYWVnL1RPM3o5NERSek5qOTdHU0o4YnIxMHpNS2MzakR6Ty96d0pCNkNPZ0lOdHJ4ZS9ONTU3bHJaVVlKYnkrUjE2dk1VWTdpeC9LcTY0WEh5cGhwK1ZmQ0ZXdURZcnczTlhOdGYyeEcrejl0TEw0N2w5WmpleXFiMmhhdHIwZkk3a3RKYjQ5NlpaL1JlVEJaeExsVDNZMHA2NXdwc2hCLzdmTWNuZXNZYVNNWEpiTjF3NGduSG1sb2ptclBNOGRnRVMrdCtNWVE0eGhwWXhWNW5OUjV0ck95K2tKWEY3TVc3dDZ4bFpuN0k0akk5bTUxY1BHM01NLzkrOEZaazNDckF6dFhqb2QxeHVMcVkyYjhDMUZuYm1vQUFLNGVhWksxRkpWbHZUK1NyN0p0V2hYY3V1dG12MWtFOWYrOVhPR0s0RFkxS0RkMGIvOGJxZEFBdUl3dm1qVy9jaXoyMWQwWmh4Mi84eWl0Yit3WWswN0xHQjY3aGJIdE9kcm4zVjlsTnU5TXBOcnZIMExSKzlIMm1sZXFVN1F2dUFtelZYcFUvZ09kL3pOOEVWZ2FBN0FHSTkwWW4zY0M5aEhlcmdUbm9NZGVLMWdaN2ExUUsram5CTjdYV2JqNE1EU20wbGE3L3NQVXY2QlJya2NiT0Z5YURrMmxuZktpZFF2K1pkMFpMM0VrZTRFeVV4anJkWk5uL1g1a1crVmFFM0QxRVdsdXNBRGNvQUU2M051YlgxYUhuRTVZeTdETXpIVXhoRE11SStsSHFmek5aTGNhS2MwYmRZbU5hSW0yUmExV0x6Y0JVZmZMUHF2Q0ZTRTZvMWpTZmNxLy85SmlHN3FQMDU1cXlqMXRmYldYM3Q5R1dpOWZnbTA0YVUwUU1iaWVabWhJdHR5N0RqUkRNanZ2YTlUNlVpeVlLR0Zma3UzblBzV1ZqdEhjQ2xkMm9wbDVyelVqMi9EVVIrL3orZVlHV1VFMWxFSUd0MTlZVE5TUDArb3hMcXpOdUpKd3N5K0g0NmtNeUhQaVdLelNSNVRpS1JQTnlndEF1UTN5YTNEOS9jSG5ZWnA4SFN6RG1obFYyaHI5NmZQQnNwUEdiWG5sUmYwb05kY3ZhdjJVWlZTLzlYaDBQSEpUc21rWFRZZHlzaWxaVWh3dDNJQkZlZVk2b0hxK242b2w3cFBwalhscGpGRDJoSmdhMWxyTTlQVGxMaE1ScjlmSGtJWHBkUndESHJRN1R5MWVwQXlVenBEU1dKNm50eUhrMWZVeFhwMXZTZlF6dElZVzE1N1J1cVpLOS92RmxLS1UvMU9DMHBRazc2NWJYMFE1cExkaGFXMnZaYjc5TlhVSUFnQitvRFNmNTM1a1pyRHlEeU5iOG54ejExYUc2TEZzc3lHNjdJMWl6SXRyU0dzZUh1T3VUaWVWeFJMT1RiL2N0S3Zoblo3QldwaU4rT2JhczlROExMb1oyVDFtTWdETGNtRUhucm40NXI2b3VmQWM0UHVhYWRUYTBmTEt4RjlNbVg0TUVTSnBLWWYwdjlHdGxkOHE2T3BwamE0eVd4NjBVeW8zVDA2bi9zUmovVjRwem1lOXZsMjM5N1BwbWk5TFNXMnI4dVcxVG9LSmlTZUZaeWJPbFp4WUZxdkxyTWNPNGJxejFTNkczWHdkMXY3QnBUMXJXcGNjOGRMMVRkR3FObXBWY1pxU1c1YjM1QjB0WTUzR096TThqaElNcXprYUFmdjdZQmx5YzZFdGJUemoyaEl4NmlvRDRJZW9FOXd5OXl0WWZQemNmYzJIL3ppMEpSa1hEd3hIR2tLMkg2YUM4OUIyUXlPeXdCZ1lheWtuZmsvSEl0SnpIOXdjV01iTDA0N24wV0RNSi9zYkt5Wm10dGFLWlZqaGVXbk85UGw2ME5UdTBtT1BNeXdzWFNDeWNINDhvOGJYcUIwdWFsVEZlblNiaXBiczdSUlhkcUtaZVErU25lZG5FUlBZbTNreHhwbFJBV2YwT1ZzZWtscjJqNlRTWE0ra2Q1VTZJNis3YzhWemptckgxOHM3bEdtdTdpUU5ITWZsODA4bXMrSmZpcXJUajZFbzE3MVlMT1laZWRheVcydkFvc0Y2SFJuY0tudlZGY1M2RktJYXo1alpuNGxtejN3cjZ6ejM5dU5VNnY0b1BrL0xld1BaK1NueE1qMzVBd0RBV2N5d2RMOXFoYWxOZ1dlWXJqQ1B3Y3hCRlRWZWVwZURBQ3dGOWpSV29aeTRjaW9HQmZockJnZy91MVI4cDIwZXFzck0rOVQxamNqQnN6SHFQTGZyN3pWRStGWC9Dcmxpa2pYelZIZmR0MU9DWVpid2tla2V0bFliK1VhZnhFejlESlZ4QTlCQXQ2S3dGOFkwd2ZSMU43bkdwZ05maWJVakVjc2svenRoNkxQRGdKOXlHYVJ4Z0IrbVBnR25ENGtidTU2eFhKaXNwNjNUMmplRDIrczZUcytiSTB5Y1ExMWxPVDU0Q05vUHpMWHdiNFVhbjlKOTZwcXJ5OEpjTzlCMG5aWkZqOTB6eitVZnFmUVc3WWRRMlpoblN2WWp6aU9LK2F5QlZKZFJLd05YTjVFSnFWcXVTSi9zTHUxWlVWNnNnNmxVUmRpK2FySlBtWlJyWHdudHNTTlBQbENWeE1uR2V6MnluMmFmWk9XKzVZdGR3ekwzeU4vcjY3WmZ0aHZsK21aKzN2MGx4ZWRlQk5lNW9wUE5HTGxlR2EvNDJaSG44RWwvcFFGT2pTWG1nYmxKWTVldWlzZzhacW1qTUY5WTVMTG1yaVV5OFR6KzlQcTR2Zjl5UWJPWUxlTjJub1g4a2MvbDNTdXJSM2IwdVprOGhlbG5NODNWV2VSVnBDS0ZwNlQvYnJVcDRtNFc3ajdFSmxMbldsMlA3aU05N1JxTlQ5azYzTHJRS3J2dFkvbVlaYW5DS09mZ3U5UElvZy9wdE9KcHk2azJ2bFNHZGluTHBOOHR6ZHB1ck9YWjNCWXBkUEt3cHBTbjE4R00xTE9qNUhIeTZ3N00wV05KOU1LdDk3bk8xb1o3QmtsN1g4czdhRWNUOGRzMUNiZithZTBxU2hKSEVlSlFtcE9UWEl4SzVKeXhCZ0N3b00yN0k4d09LbjQwTDA4ZUhzdTJTeSs5MStEN05Ua2JiMzhaeWtzTnQ3cmhxQXJRcHRGUnl3Wk5obWVhNWE2OXl3ZHdEVkVsNGx4enUyUnpvSThCME1kaGptbWNDWkpUamRNVmh6bGczRnJzTEh4ZlRwMUwvV1hRalV5dUU0K3JTTDMwMVA1UjNiQWx4ZmZra3FrMG43cmVVMGdaMU5WY2VET1NYdmR6NFlud0MvQlRsM2x3cGJaVWRMd2t5SXFHYTBobFdXaXlIbW03Rk9kOXJUbkJlbGk3OCtpRnRGWG1qZnFRZFlkMnUyZFpxa3JodFV6UDBQTldxVWNMbCtSclhpbzlsZGZqVk1rSXM3SDFkMWo5TitCeVhDcXkzUjhsd25mQ2NsTHpnRHNDRElFeTZZc3hpZUw3dHFnenlkVXJGY1d5WTB0ZGZ4MmFVUVBDakpqaVcvREQxTlVaMGRvamU0eUF0Z2k1SlBPVEZBKzNIcjZzUHNCYUZPWDZxWGczOW05R2oxTmpQRnZsWnVQOUNFNDVYOWJlNS9LcTY1SE5ONGlWbW5XL3BmZTVWMSszTEtldTIvYWxya0UvTysrWXBkSWpnNjUzZFV6MTZEck1Vb0oyZzViUGE0dnA3MlJYZE1vWkkvZUU1eDVlVmFzcGhGSHRzcFpGTlM0UFgvcjdxdnNSTSs3c3B4OHBmNlErR2p4bUZHTm9pQTFuRlNEa1hjcTVZOHVXNW9veWFUSkcyUkdaQ05mS1lNeTdYYXVZT3Bremp4VmdsbVl6MTBVOTcyaU5pZy9BT09xUmM2VC81ZHc0bG5HTnNRWUFPSHZPTDg1cmkweFBlQTlMNmtCNUdycW1ETmczZVE2ekRJbm9zdGd6Rm02NGRBTmdMWnFCK3RjZjFqT2VNaUhUVzRZTFdPRUhxVFhjang3NStNejlsMzh6U3o4V2J0cDh0YnFvc2U4dHJzZTVKYjdTc0tRTVNnQnVpbVVoUEF2UFdxd0lNaGJCdWtNcnhlWENlMzBSM0k5MlpsVGZDc3QrOEdMQmR4eUJqa2NGbCtpU0pBZkRBWmdJcWE3UUY2OGhhcWlndlZSbW1ObjRZZXBxTERBUXJEOHU1MTVscThPOW5WWnd6ZGtTMTVsU3Y3K2loRXNQWmdpbmROcmZ3KzZLSVdzQUhvbDJGQlkxam51Tml3R0RUMU1WV3JwV0o1eXZEN0x6dm9iSFhWVTNTQldIUFU2OXAzYmJNQzE4WkV0NFd6YmFxNnE0V1FudnBqakNQaHRUOVpkVFc3YWZ2SDE2Ulg1ZGIrbHA2UkZ1UGYvV3Z4M0l3clhFVXcwUWJRNmd4ZzM1NDFUdG1zS3FVNHNqN2laNVAxYW9HQi9aMUhWNnArYzJrUE43aEg2dTI3UnhvanF5R085YjAzc1lhVWpVYnhtY1BTalBxSHR0M2xXeWFtbTdjWnUzY0lwOHFhWklxU1RiaXlFZkVaOTVyTDQrbzdYNDhmMVVSZTZoYmVsb25WMVIxNVk4TzFjTzczNit0N01zT1IxUE5aWExVcFRuRVQvKzBPVEZiVXFmUzlUZ3NyWXJ4NGorek9WSmVyQ3FjSzA4dGJpOER5YnRxeVFYb1RUNWFEYWJSVVV5UzA5V1ZtSHVjOWNVMWJ5enUyN0hVSTdsY2ZnWXJXZWFiWmJjN2g1MXlUVGtXWU5hWlZHZHNRNVB6TFVFcHlNaUhiY1hyMHl0akJLbE0xd2F1SHZyYTdPUFBqNkd3dVM0ajI5ZEwxRmZqTWxOK3VNWGM3aFdiL09XOUR3QTRBcTQwYWxwYVl2RzNIU0R4eHFVaUZpWG1xemtsT0hhMDlETXhRRlRIdmZGaGJldHc1WEZZY3V4OTYxTHpwNXB1RzFzNjFJRWZBY3oyOXRpc3Racm8weUVwNFQrQ0I1S1pBYldCbDNaL2JQalp3d1NrMmRoc21DWEhpUFhuSlN5T0FmL0lVWDBjM1ByeExGN1h6YmVaU2xWUHlEYnJ3Z3k5aHk3Z2JZdTloR1IwL01sWE43TUttUThhL2puTHUyTDJGOW5wVFJjL0NMRTFSeVZuRXdOS3U4YitpTzBSWmtIb3hxK1l6VjlIU01XdnRhMW1uWmZ1eGRkKzkwUXFrcDdIbGRhUG10TEVrMkdsbWN0MitLeExvcU1Sek5qSzZPVkRiMThPaU5YRFFmWmpCK1B5MXoxdzc2VWc4V2FBb0RFMHRHSjVVSzlURzg3WFJiRXBCUnpTM3YzTHI1V2hZN2ExS0FNQ3hCQzZ0ZXRUWWNmcG9Mdm9uZEZOQ2pMQjYxSm53a21yUHR3UVZ0RmpNckhNTHc5cmh5TVVBUVNGMHpIMzhkV2lkUUxTZGJLaFVGQzh6NkptSEpyVTVWdWFZUVY5RUZwcm42dmFVZDZZV3pZUWtnYzlXemVEdGpiWVVkMCtFNFpiUmQ2MzljOHNhTVpWZmNsa0dZVXNrS0x6VHVSNStUeGxLRVk3dnplaGVMV0dUWFpYVkhYRTFZT2grbXB5T0VlV2FyZWtzUEZqeitVNHl4Ny9jdzYwK0FhMWQ4aUx5c2RyUUphWnBTaXlKYTJhUWJWeXdPWGFmSDVCNEMxNE16bkdmQUg5bnowRWZlU0ZBRGdua1IwUzZzSFJ2bzhWL0FzOVN3UG92Y2puSkhIOG1UbEd0eVhtUjFaR2p5UmZRZHQrWXQrQ2I2S3lPRHNITkM5WDA0ZFVRYVdjM2QrL1g1eG4zKzlQU3g1QnFYMXBhcVpVWXE1a1huNHkvY0RXMm5YczgwbDdtWC9yTFhQV3Q4ZnkzQm12bHB1ZXJzQzhFZ2kyeXBSR2Q3N21qUHdpNGZ6aUdheHdGVXhsaE1QQlExL0NWTmRFVVcrbjcwL1VFWWZBVmVSN2E0eWROTUwwQm9IalRJTXo5dWkrR0hxNmxoL1BtK05GOGpha3FXMFZodXhzZWxpeTdUVitOcENrek40cER6b1N6RVpKWHBDODRGWlJONlU5UjVsOFRRa1I4NklPdW1VTWVKMGsrOUVHd0NOKzZpOEd0UTBkbnJPanRIdVc3R1V3VEk1VXgyNWxlMlpjYXRyOVpqNEdiMVRPLy9rODd6MnA5ckxzazdmSGpLYk4zMjlETnp2SnBQeC9sUEp5clU0djJURDliV1Y3ZjNLY0g2bE9HNVlwMTBJLzFRZW95ZkM2RHFkTWFJN1pMS0dSRTYySDZldWJIRkV5dVp0N3lZUFllcDgzL3BmM2Y1OTZVTjFFSElPOGFTVmhVK2g3VlZhNlRsVm5KS1dYdExvNnpaZVlzSzFQUHFlMkovbm1UTGI1N3ZmeEp1Wm9mUWJadE5IYzVabSs3ck1yL0c3eGMxVGZzaC9kdnRGeHRic2VaZWpPT01uNGZGS29yOFdMdGtWbVpIbFFGUFYzcVdYSWtZc1lyWEJ1aTJIVGJ5RVp5YSs2d3VxdlYxOXlRV1NSeDk3NTRKdjhrVlE4VGliUUpObHFYT3JydFB0ajF6OXZjKzV0WS95VG9MMnRkS2p4VllJZjBSKzUxVmVDOGZ5dnE2bDJMeUYxRmRacVJUTERUVUF2aENqOVVIU1dpOTdENmgrMzR0RlMzTnJUK3ZNU0tVbEkvWTh6RWpscGswcjFnWXV5djAyYmNDR0V4eDBjamhWRnV0emFjL3BtZnBCSHlQR2psVldiMTYxY3ZPYTFTT2ZFNEJiNHJUaTFmRmM3ZnQ2NW9uNk9uc3pqV0I3N3JHKzdWSFFrMlZKMVBTNFgydW1INzlPdmFMTUJ4bTcxSy8yTEE2ZjVtZk4rYmxEWGRuTmtpeUU4ZGZGdE42WDh5enYvMjB5NlR5cG5Bb2hpN3JlUzBvN1A4TDIzK1BRb0gwTXg5enBQR1JEa3U1SlI2U1ZoSlNYeHhmeEJZWmYxTzNWSXhOY2g5U2UyWG5mSXRNU1hoeDVmQ2xPUzBldERtM2JSc3E3T05KUzl5UGVkazdHWStHbVRBL2M5S1IxanNkWC92bFl4b3hYUjRpQ3FzeU9kdlhuZm1ueVJoY0JJbHhIbGpxNHNWTnBmZTRNZC9yaityMzNnYUVZTGdVL1RQMFdMbHhFRHpNMFJySVY2aVlLQmo2UUcrSHA4TmFWS2pvQStIYklQdjZ0RnVBWnMrSUtFOXo4NTV6eGxOS1cwZExjeUthNUwyMGxleXM5NnVMT3luVXJyNzFQWFhPNUZDS0hxRkV6RXE5czc1c1pJd2pJNUxyUXo2bm5yd0NUS2wxWlEvWHNPc3lLSDAwVGsyc2RwZjZjUmo2RFZXZWM0U0tkbFg2MnpPOWRzUDJxby9MV1IrZjdkNDY1VWU2Y3NXVTZ1ejFuNkRGdVhHdTdMQnBTRC9DK0VMWEZhZDkwemtvOEI4RmtxNk90V1R5dENlN0lsM1pzRnZsNVA1ckQrc2JLUEQ0YTBwNTNHUlFIQUhBOUszbGpOZXRMdW05K2hxZE5SMWJPcUJOTFE0TjFPZE1WTVNJdmExK0R3UUpBdzJBZjk1QXZwVHJ6ZE12eXJJTldWQnJGRWJKLzN2WUhwdHJYVnRVZnBOWUg4WlZLWnVaOFpuVVpzeEpleWF1elBQdzhNeCtrZlo2S0xuODV4SlQ3aEdiU25PR0h6a3llYzh3c3ErU1pULzR3UTdLdFNvc2JHcXpIR2RzbjNuQXBEbmZmczIxeUE2S1dUdStleGd5Z0RnRHcwYU1pM1prb1NvTWJ2NWpxUVpnQkhXZmxPZS9yMENvYkxJbit3MVEwNEJvczlJTTJhcXhUNi8yUytGZmhyT3UwTHF6dnE1VG1YOHRwQ1pvdk1kbWVZZWp6Z3ZPWWFUMmM0WUZkbVZaNVhEaElyRWFrcGpJb09KM0pYVitEMVZ4VzRwVTZUZ3JLN0ttTmFHMk95Tk5xSFd2UFM0VVhKa3V2SjFSN1RpbGVXN2VGdVYvL0pPNG9tZnZxeVRGRkhWYm5GeWRhSzZkUzJ5bFcyMmJrZzN6anZNUitabXFyWktuU0Q4S3F1Slo0cVluUDVVbnBnU3ptM0g2Tkp6ZmJ4Rm9PZTlrNTJVNUdudEU1Um5XNlVYT0lSVVlUait0Qzc1Y05xcGNNMk1lMUxFcTRlSnpRbFFjMDg3eUh4NmZqRmVLaTkybTExdWRHNmNnODI1Yzc5SEc1V3Z0cWkzQXV2cVUvVzhQcmVDbjU4cDdGeEx5eVRYYm1kbkhTYXc2b3ZqcWNYMVhzTFczN2RZRGNaQ3E5cEhWdXIvYXV4cTR3dExSVnFTYkRZdE1rV1NhWDVjRSszWFlMUzdVV3pQdXduWGlQM1VXVXdkc01uY3NscXpsZVoyZDVIekdseGlTbGhIUDNPWm1GdVYvbGRiamVzanBUSmFwSURjNnRRZHZ3VmhhSGQyeEo5TWlJNXFzTjBNZ2MyTll4VjBlYWJJNmlwajJPdTB6bWJQMmlTcTY4RVZTNFZLcmpWMnc0ckRvWEFIQVYyclJLYVZCSlcwa2FNZ25wdkhndE9qYWdHTksxZGxEZTJ6VUhLNXB4amJpSlRLRVdjNWk2em80MFhqT2l2ZTk1bnQ1cHhHdTBnbmxZekRIcnNuQkUvbFFacEtXWVpsNG01VDRBajBFWnlKWXgvak1XV3dkQm90MVdiYnBEV2NpQVlMelBSS2F2aDJpWjBqNXdIYWNNVUpJZnlUMXI4aTBkVjZZdE02Szl5R2laVHR1bSs5LzEzN2hsVndaV0tobEgrMXB0K3gzVGJRb29qWXlpNXNUTHJ2YzBja3BKMnRQZ3dvOC8vbTFsRnlaZWF1SnhPZXUrQ1AvOWRrVlFoTGplL3VtWmFHODRLZmNzb0t6TnhibXhZTVBjbTE0NzJtcXJTK0VQdzFKbFVqcEo4N2ErRlM2dHRrU1JQTndhVUFrTXZlT3NFTEsweWtaalRLZlhXaFpsYysxbnpJeXlycmc0QUpBVUpVeWJQS1FGVVpOMjZsaHFybUhDTXFCQ2xtQ2I4djlKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR01qLzkrLy9tSDZvL2VkZitBM3JwU3g4Nm81MllKQTF6UkRha3dvc2hlczV2cWVTdFR1NHNJcHJPVHdCaHlyZEVFL0hIM1VnNWJkaEdhOGNYSjBOck12ZVp1cy8wM01HakFJVDQxck9McVBTYldIRUVlbFpPYytsV0J2VzB1Q3phMzFFcHh0eHhwdHlaSDBZei9QSm1kcWZaanNsdFREaDlqdzFicWwyZTNUblV5aE5iek4zWTZGeTN5Y2ZVL0VpV0EwSi9XeGs3UVJrS24wbXBOVHArZE9wTlNJNjBYclU2RWlES1RwNGpHVXdxY3ljMUUrb25VN3ZLYzBqclIvR0pzaXkzVUY5Z2RGdlJjU00rc2pUVzhldmoxRkhCSTh1a3lSelpwNHRJNDkxN1pHVDBweXlPR1VYL3BKOVd1ZlhBRW9acjdlUDQ1a2JTK05zMlRqV05ZdUV0amFMOVBlc3hGZldiTWtZM0xQTzEyVEpVNEp0aUVTblBtYVoyeTdKcUxUYWtGQjlFVVk1NjNPRkx0VDZ0VWVINkxNOG4zWVV2WGxZQm9SbXExdjFsMVlHVFFxdm56SVpaeDlDcGROS1phblZvT29BQU53WWs3M00wS3NMSXJNUkZUK2xjL1RSekx4cTE4REJWV2ZKUERMRmp6SWpOQnNXM0J2TDB1eUtnYXN0LzdpOHZFdFZBQjZEdGs1cTR3MllEYm45QkhYY2pweVJ2UXJzREh6UDEzNUprL0xMLzN5MVZIQzZ2SDJlYnlGbGY3OUoyMzR4OVRnbEZMS2MzSDFLbG1kbG5nMzNaNU9KUGNuZjhyenFzZ3BKcjVEUGY2bndsb2d2V0pQbHljc3ErMkZFM0cvZWVDdDBjR0JqNVBDTjVqMXlUMk5oZWozY2xtV0RGcTZWWVNRZXk4RGFsYUJDakhEYkM1YjFNQ3A1T1Vhc0lzeGZUczE2M3VnaVlBaFdlMUxvZkY3WG1RZnZxeEdQd2VwbkI5UHdMTVh3YTFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdBQ1gweTlLNVlqWlZJVnArY2tUcVVJVWxaVWVFcERzcWZSanNrb1FtRjZqekpnS29UNldnSk9VLzl5dktkcTlaeSs5VTE0VGtpYVZFZVNDdEZVUmU5aGF1czJlL1RKMi9STUhQSkk4NUZZajl1S0hzMFl5WHNRdTZxdGo0bVB6TkFjMXVPck5CbkZaYnFNd0RMbFUzR1h4MXYxbmpUZmFuaWMwdkJSQTVLVDA4cXF4NURjbzIxZlhteFBJNmJ2ZngrejlQS3JCcm5QcEltblFyWUxocVlQcVY4Ui81YUI2ejFiZFg4cFZlbXNFbjFpMGVPMlp5ejVXblhVMGNCSnlEVTc3OWZoRkZmMDE1RmpaZFp4ekRiOTNXWGxNRm1RcmF0OEhZQ0tYMHZia3JaZkMvaDhWWUFZd0dsMDc0ZzR6WHBrV1dSNDh2Smk2UWRSWnhjelA0bnpsalFaZHJDUWFyRStyZGdEQ1RPaUZ2aXVha3AyTmhhdWtkazI2L2Q4ZmZVdmpnZWY3b3VnOGpqTEYyR1JNVEt2eE1peWV0ZU9WNWtZN0VXY0E5dWM5L1BONTVwRDZqdmVXcUx6UEtQbkFRREdJbzNmWGl1U3M5eTRNbEI1U2g5UEUxY056bVVFU2Y0Q0d5S3lITzVWNWhhelJGcUNnM3ZSMDE5R21MQlUvOVd1QVFCcm9UbTdnK08yWFM5NTAxSmZ1OXdveWpxM0orK1ZPSHdKbGZsU2FqRTl0OWV5M0Y4ZHA0cW1MSWFPVXJmcmJETWtWOCtyZVcxdElWWmZ4QmJXczZjUjhUZDdMSDVMZkl1Y2hTZjFFV3NSU1Rac25Ydmk2UWVhSzlpYlo0K3QvbENzbnUvVXhNdEpIcGFlK1dlR0ZRR1ZvVEJiZjRNbDRIeUlIaDhnNWIrc1piUjdtMmgrY0JwQkgzZ2Q5L0JxUkJOdEJsODNScUliSzFBV1M3TTFLMzV0Q3A3RkZZb0p5aEFBQU1BU1hEa2hZVElFQUFBQUFBQUFBREFickQyL21ZejJCUUFBQUFBQUFBQUFBQUJXNEVvQ1lCbnVNQnloTWdBQUFBQUE0dUNMcWF2U2MvcmxZTFFmbTFzUG16cjFFU3duSnhWanVPZTAyaFF2RnJncGxwT1NmUjhIZUI2ZXd3VHIrMXJhWUJHOHpTVVZwU1RmNlYxQjFlSWc4cVE5UjF3SkxodlRVVW9XaFd5UmNmWWc4eDdyMHFKTlVFMjhxWThYRzJ5eGsrem92R2Fjbkt2MTlxWFZjbVFJV2s4T2V1cDhWR1o4a3NCYTZWdzZLZSs5N0dJMGFqMm1iSHZpdFJTenprT1AyOU9CRjZZOUxwRFN6MnpYeXNuM2laR0lSVUxKV0xSZVIrb3I1OWNlQ1FHT3pENmNuYU4vdktaQUxpc1E3YmZXV2wzRnpwdzhQbDBPbnYwWXlzcTQ1TDZRK2hGd3pHUDdLaXVsMGM3cm9XZDZycng1V1pXaDFIODl0Z2kxWGxUbW04TWNxSWowR0NSMXZKVDh3OU5TQmk5TVdhaWFTOFlwWGpNanhOWnQ4Z2hyeXNDSngvTVpZUXRhbE4yc3ZLL0FPK2UxeUNzRVd6eHZXV1FaMGxkNFBxWHhQVzhtMDJVMlpYbkhwMlRRTXZXdnM4WlZJZ0JnTEpwNXpNVy9BbzlPMFRoOHFjQ1FoeVRMWWtNTXRUZDB4OVlyczlTWFI4dU1LZEN5QjAxZGc3WHBjZE41KzdjbHI2akwyNnNrQWZncVZ2RVZNcUtIelEzKzU3VDdvejhwcUR3OCs3LytQSGs1V3A3aHZGN0dEcnZpYmgwNFJPeWNxTFVxcjhDMXRTbFpURU5uc2F6RkkrVGRYL3JlSmZjMTNyblRFbGVyTFI3RGtFczM2a2tlYkNpZVZjWGdQS1N0ekZuVDdLanRsVVhwV1pwWTRsT3l1ZnYvTVBjam5Mbjd5M1ZMcUpnQXFMUmw4TG9XTE82clF4cGlEN1ArUXlzRHVnc1l4aWpmR1RFNVdQdHByNnVRU3Z1NE1RS2xNWTJJdlVUSitKc2V2ellGcDRFeER3QUljVlBsTWNNZkJnQUFBQUFBQUFBQWZBMVhyUGZob0FRQUFBQUFHQXZzS3dBQUFPQjhNUCtDTHdUZEdnQUF3QXBnUGdJQUFIRGd4TWtCOHhDNEszL28yN09PbUFGbXNuSjlZdlAwS0xqTGVsR2t2ckl4dktUZEwrekpVejJZckVmOHFod3NCblVpQnRmUTJ2V1c5bWtkeEtOa3JNZnpKQ1dla3F5SHlKbUo1eG1TV1FsckZKd293OWtJbmlPUzJyVHN0YVZNUFVlVFIrTjd6NmV4bmg5WCtFdnRhSHIzRi9uYVRIem45bGhPWkcxbFp1SmtWRjFHakN5V1pER2tvL2lzYzBaRU1YMFRxcnJTRE84SVZobldSdUE3QW5kaU1IZjY5T2VhSG5PMURGNzI1dzROTmFxOEhlNktEdHByU1BUbzJVM1dTeGlyczBlY1QxV2E2enJjazRkdmJ2aWd6RmRVSE1HYzRNMkkzajdVYzNhcUhwdkt3V1pCNUNwK1NmWnZUVWJzS0UybWxSSG4xbHJTUnRKNTQxRnBSbG9TMXZZMHRzbTdpUExZb2k3L3poTy95ZWllV0ZROTFlUlpxSmhsRnpQdDhtZVRDV0dSc3lhajdhYWRUU24xeDV4c2F3UnQzTlp4WjZHc0M2Mit0UGJhOG5pMFNjUEhxNGxPbzVGbTNZTGJxYzZZVjJhZU0xdnlMbm9XbW5iL0VSUHBRcjFUZzhxSVFrVWJmT3FER2N1Z3BUblRGOEhkcTlPMDhZb1NUdVYxZks3NmF6YWFiMEJidTJRaUJaMXovVmNtUzFpRVVxUmtxOWtyZXgwQTRJTlZTMlVtZm1MU1UzbjBXblpTUFBjcVgxRlVubFZpa2V5ajZvLzMxMW1WYXhGZEViK0VWZkdwKzVUY05uejJFcFNTdDZXbnlxOTF2cFQ0NXdiem1HRk9hb2FFWkU1WnNmWVJUaGtDY0F0NkJrazAzUVNybm5McDc4S3RreDJIdjh4RldMZHhLZXgzMDBGMnZSNXN2MlpxL2VycXNUZndhOUozWGxYZEZzRlEyZUlWUTl4UFR0dHo3T01lVXhZbVBSM1BVcWVsS2tOZlA5ZDJMK2k3MUhOLzJua2Z1emd0NC8yekhjTjVXUkVydm8xbnlZdUtUNlgxVHJnM21hQzlYYzdTQkpUZDVLa08yRGpyNFcxdjIyUWl5eTVFM0MvQXVxNVBWVHlyQnJNdVRTd2FrdkpqV01yc215RnNlV2xtVjFMdVA0YUltYTFWTHZUeDZXaHVERzY4LzRUbFh6K2UyNUxNY3A1YzNrUlNBSHhvdXFmOXU0cmJ6cFhVZlUwMGRkMm10ZXdmUnRUdkxSbnB6b0h5TURHaVQyMHk4TVZVOEF5Z1hBQUF3TUNWeWhLS2VqcjUvRHJPYUZjQUFBQUFBQUFBQUtlQk5TZ0FBQUFBVGdKbUJ3QUFBQURBRURMZVUza0dxR29Bd09KQVRRRUFBQUFBeE1uLzkrLy9GTXNSTW4vK2hkK3dMc1VGUDNuWFRzV283MUh4VDhGekVwSTFqVEcrcHg2MGs0Sysva1NEcDRFR3RTRU5GaTU4SVhyT0g5Vm40Uld4SENXVHFqaUZEeWJqbXlNYjQvZWVkdW1CT2xlTndqb0xOUGVwWTZqYXFLbTVyK2JCTWFaKzZKTHNUN0cxbm1vN0l2K3ZtRzhqemZ0VVErUHdDWWJYZmM5eGlXekVGazBuUmwzWmZJTVhjNFBUSFVCKzdONFphbVNuNjVFMWVxWWRXUlpPWDN2a3BlU3pMR1ljU3h6TjI2aTRtRG9pUjRhelNyWDV4elkvZlo1clpHdm1RMGd5bENXYTJ3eHNla2hQWjgxcjlRbU9teU9rNTUzMFhLUlptWlhUL3hzUjc2ajVGVjZhK3hZNW56eDdadGNZMHZxZ1IwZHFjNzMxU1lzUzdvSFN1OVo0MXVjS0ZLWE95bUxiRHA1K2gzYzZaZjVSbDJvRytWU1pUclZ3enBnNlhFUTlzSnE4a2ZQUG1WNWc2N2oxbENVSDdudno0R1FldjRSVERMcnhtRk83d3NtSHV4Yk5YODlXUi9zd1YvOWQzeUlCQU9qMFdIYmE3TlJEdmQ3MW1ES2NnaG82QzJtMmtMeTg3OCtiQ3VEc1NJdXQxN3NzaU1TbmJGYXdOaVBOUjIrZjg4QXBKdlE1QUFnR1d2WGV5YS94bWRIN3Y4R2lITll3dnJURnZZS1NKYVpYYWZnOHRETDQ4MkJqSG95WTNQaE0wODVubWhzbmFldFBmWDlCdFcxM2J1NVBYQjBuTnNGSEZMMUd6ZTl2bEJRdVN4SnBEZTc5NFdnMjdHbjRQUXNqSjk0NnZKYXBYYmZwT0xTVmdnZXJVZnRBWU12Y2p5dGRwWlp3V1VuYTRsMkVaWmxMcFJrZGo3cHUwNDZzeWtnemMzSEFpeEdWcXNrR3l6QlQvU2JtM1lMY1pKclJMOEFLTkpNZDYyK3Vvazh1QWxTbXRzME4zWEU2bGprRHZ6WUZBQUJ3RDJCSUFIQmJNSHdCQUFBQUFBQUFMRmNzR0M1Y3BHQ1RGWHdINTNma0RPOENBT0JtUEU1clFVMERBQUFBQUFBQUFBQUFBQUFBQUFBOGpqKy8vOHc2ZmhFTVo4WkpKRVlzSit0SXhUdTlsM0dIeUhsUFhUS2VXaXJWai9WVUl1M01OWEFUMm9iVVRtNEF2MUFEeFZ0SEV3ZVBwbjU3NUZCcWFmM3U0YW5za2c1SGl4NmlGRUgwak5Ndlo2SWR5NktWUzNuZU92aDluRlJxeG94blVtdUZXdUxYYVd6eGowTzhpTmNqNGViaG1RZTlUYU1Zd3JnSGZ1cTgwK29jaStJVzY4clM5N2xlRmowaE54TTVhZzBxOWZTUGp0ek9WeTZFUkY2VFdrY0huV2VNcTlKSzhvejFVTmdMUS9OSEZpc2ExalNSTjBvOWZTSVFueHpPeWxjZWs1WkxjNko1YzdxNE5oZVdhZ0xPcVcvdUtFMFpXdDBoeS9TT3NaSGp3bXJ6YUJNVmQyMWh4ZGxjbXdNc1piTjZXWXhXVFpIeitwMHlQN0xyNkh6U29vUTNzWGZGcm50OWN3UmxrMENhUWNlMnJyV2ZSbXg5VFV0b2ZjUmFocVRFSzB3WTVVaUx6QVdFbUUwVTlmamFGR2ZzM21JWk9xY2ZLNUxWVlY1L2JOMys4T0dVTm5FYlRwVHByNHgzTWlaOFN6ZGtuRnloU25lMHVpL2FrTnI0YnVONUhyelg1dTFCRzdlZHZnZzJyOExjcjYrdCttdm44R2l1Tm5zcml5VXFiRm0ydThjeVNwYWsvSVVZbTQ2ODBob0JBTkJvR3BPWmxsMGFjZ2JTaDlORWM2ZGRXcjhTWjhaT3NNeVU3aFZvb0dLSUQ1aVJtYnBsOXpSa05zU3A0M25MMW1sK2c1TVpPZUI3VFZKcDRQWXVaOUV2d2FPSXpQNmNLR2RhYXZKK094V2F1TTV4V1RxZXF4ejg1eFkvZFVxNnc4ZU9mUTg1Vi8rMXRlWnhiMEd1YkhZdll2UGpNSVpYMXVJMW9rcHFFcnhTSGUvVjZlZ25sZmJvNjNWdXUrYjFIQTRWM2RQSWhuaWZVb3kwenFuMXZlUkV0TlpGYTd6Vzk3M09UaTd2TDVtWXVXcXdMRWFzOFdIRHJJZTNQYTNwUEdrODB4UzNmU0xGdTRnT2k0V2wxWXpXNWluTnYxbEozK2JKeWEzRHJjOXJjQ200TmYzWDR4MDdVcVBvaGlPNG1LaXEzTVZ0dHZVTEk1dzd0UGNRUCsvK0FlQWN0aVg0eXg5ZGYrR1htdkt0YzBmUHpxdDFKZk8xY1BNTmxNTTB2SGJXbHFhT2p5K21ndE80VkJkQUVRRUF3T0pBVVFNQUFBQmdEckF5QUFBQUxNRVZFeEltd1F0NFdxV2prd0VBQUhnb21BSUJBQUFBQUlhd2hsa0Y0dzRBQUZZQ1doa0FBTUJUd1J3STdzb2ZPUmhIVml6RGdrZXpXRS9NOWNqcTdtM2E2VVRTYVVXV0J6S0tidTlySndBVjVYcFkvWUJ6UVlQWjZGRWVGbG1EUkRsVkJJdEZUbkhFUFovZ2tZUzFJaXRNN1daTzIybDVGdU05QzlvWnF0cTVOOUl4MU5ZOGt5Q3ppbDhmYVU5RktaYThyRE1NRmMvemZPV1E2dmhGT2lwZE11Ym5zMWtqcHhVdFl4VnJ0azU3VDdwdkRmOFdWSHRhNjJNZW9acXVxTk5MRFdNL3g1b2ZVM0laOTE5N3pNbDI4blNrczh6U3kxZFM3TGZGNHoybHdNakFsZnBkVHo4L2srYjV4Sk0yajE5NTNKa2RTZVpZNHg0bFdsSjdodmordEhIdDlMejluY0tXZ2VjemJybHlmOG82SHJGakMvU2NyNmJkOTJMUktkRzg3QnBjRHBka045ZnM4Ry9HMHV1UDNOcmw1ZmMvdTM2YmxhOFN2Mng0UGc3OWZHVlhyQ2JQY3JRZEtVbkZtQmROWFZtU0xyWEs2WWxMYVl0NlhIdjE4NGg2c05veWpMZ3RpVEVablRlRHhSNitndElVcGEzU2JaaTJ6ZHVFdnk5TEphZE9UNlZobm5zbm96UmxxOEpaY1hsL2Y4cFU0c0s0YnYxNTN1S1F3NDBaenhqeXBLR3dyRUs1Y2RxbXM1WkJOTENFTkZKZTJxS1VReHJJelZlMUR5bm81LzJzajdUN2ZObHk5ZC95K3A4bGoxYXkxU0xZNGx3KzFBQjRBRkdUd1dObFhRbG5JbGpuZEZrck02Wk1hN3N3NFJxMW5hSit3RXdWWmt3bjJaZEpDYk9hNnR4aWhuSmdYR25UZ2o0c2ZVbGFnbG1XWkZwL3RwcVBYRDVjUEFCdXd5aUx1a1BHWWRIZFlVRjRsMVp1Z1ZFSmx2MkpGajVOZVV2TmJKZ3NzODJCOEVPYStlMURiNXRITVdKeVkveThZNy8zOFgvL0xibk5JL04ybGJMMjVPcExxa2RLWGdSdXFvdnNhWERQK2JubXhwRFZGMUdIVVdoV2J4dUhTMnZKMDNyUFVvWXZtYWkxcXUxcEVxdDdIYXpEaUttYmcxTmMzaUgyaGZZeTllaVU1OWY2dUZwOGFhbWl5ZEE4K0pZOG9SS01hSlhOeFl0TVcyaVUwOUdhemRxc0xhWFpnMnl2U1ZsTVp1Z09ZRHJDbGl6bDQ3Wlk4dGF4RXVHeFk4SzdKSVB5TUtQWllSeVdOUGhpS25nV1VEd0FBQURBQldBQ0JnQUFBQUM0SzdEa0FCak1GWVBxYVFNNVArNkJFNWdONmhnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCb1ViNllPdk00R2hEQ2MvRFhwS3c5cjJCWWl6V2wrRjZobmdjc24xK001eXFaZGppUzl5U1I1SXdId0MyaGpsOVl1Tk9mZWNicUd0WFFld1lhZDc0R2tXYUprN0M4NTM2YzJDT2tvK0hNeFlpV3YrYzVTL1ZmZjdyeGNmVlV0NWwzUnpYZnR4c2FsbU1UMVRvb3lXd2tIb1JMU0FPNDdHTHBPZHNiK3ZkcDhxRUV4MU9rVitnY056SVNObXpOeXQwd1VnYkY2WWsvRTJOWmR1TzRUTEloaWlsR05zUTk5dWIrT2k5THpHWlg5SjB6SjhGWnozZmhtTk5PK2svVjNLREVMU1ZXeDVKUEpWNHprWlF6OVhDUExKZVJiNUJud2JGMjB4U3U1UVJrZDk2S0hKZHRONTZEamgrbG5wdmxNaGxGa1huNE1xb1cvL0RIWFRCVWxwVHVVaUx6VVcrNVN6QXNvcCtrQVZ2TDFHYUZpTEZuMFZ1RkRHOXo5czU0a1JhNzNiQUQ0TXZRcG0rUHgzc0duTlVZU1NmZGwrS291ckN6WXNxVkZUdHJtcW5qYWZkeERzSzk2ZG5TNkRVa3VQRFd6RXBLdkZvVytpTzRKUXRZMU4yZi9KWmtwNlAvNC9TeE9zOWY1ZmVYRitFcWlrL0s1aHZONWdPeWNwVVR0dzV1UzhUZGJ5WGErU3N6OHVYVUVYVmNoT2NjMzUwbG40TGtrZTd4cjlZeS9MNEk4S0tuU2FpMHFPcm40bEdXVWw4WnM0bTFORjdmZ1hVWkxMMURyYVdOeHJmR3pZYjdqMlBVRnZ3V3g3SVdCYWN4MmhYeEU0ZUl0SDAxdFRhUlZWbmJGaCsrbkFwbXcvbGpLeDlhdlZkdVdlcDU1OUFJajNQWG5WR3BEMlZXRmY3dG0zOFN1QWNuL2dCMUJKekxyRldJMHg1SGUzZG1FTzJFazdXOHdiTTViUURjRUcybFg1anJpY3pLNmpuTjNtNmsxUGUzMjFVdDd5cm1acFBlQVg3ajZCT2UwdERueTVrUU42UCtMR1dYbjc5dkd1YVV4UU9KUEw2bjYzMWpWWFBQWDZUSWRRVEthenJDaXlwWGRtNysranlHZFF1QTNwaXZONTNiVWZ2M2ZpRW1aRDN2ZmZ4SGoxTktGUzVUSFZjTWNHMXVsTktsWTFxdW0vOE0wMmhleHJ5Yk9OdDRvRFNFOTduN1o5a1J1WGpIcjZjMG8vT08wSlBIbVgzTEtxTzlQYTd1RG5QRDY0WTZBelNPRXVtSHEvbTlzWlIvNG5scm1LOUpxWTRINnlPM2pDSmNVL0UxZVRWV1daNDhMYmFNSTNveEpQWld0YWNhb21tVU1sbGFWWDJzU0JkN2JleGVRbGdsWG1FbldwMUxkN2Roby9Oc3NQTU5oOUkvUlFqZjdqYnpUdklpcmZma3ZLeXNZSDBBQU1iUWVyelBISi9TZXhnenRMSVZ0dzMvS213WnFSUkhUZUdjNjAvYXN4cFpsaXNiRXN3aHNsYmhaRXh3SVV6SkM0RGJzdWdBc0d4VlhXME1uRUs5bCtWdm8yMHRWeGd2SXIxTkdITzZ0SHQ2NWVXdi9aUmg0OU9ndWJJd2k4dDMyT2FkVFhFK2V4ckhINmRLZFVYTFM2LzRjcHlpbENWVmNySW9xWTN0Z1RQMnRqRHBXaXNMbFJlWHAxWW1iMTQzWTRSOTVNMnJwSWZveW9YcGRUK2UxVSsyZjZXaHI3c3JsMkRVTW1MVnBZSDErVFNWc3pVM2R4OVVSRHVWTnFiQVZNSzc0ajMrdTBhR0h2SDFMM3dSWUJUUlZ5amE2MWU2OWtmV25pSllYMXRBOTYvb2ZWY0VtQm1wZmpkWitHSHEzYmxRRzdWdW1FMDV0dGRVbXVsSUMwSHUzUnN1M0lMaHhUVExmZkFRMEFGa1dtVlNzNERPZXk2QkdxQ3Njc3VSU0ZQZXJJMXE1QlZibmlqVDRSTTQ2Ynk4blRHTEdpTWlkVDYzMEFFanUvTTNLcjFpMlVTYzdXS1dERkdQSjhTZWwyeXo3K05ZWlZuekJoVkxWY25zZnM3bEdZaHUrWkZkT3dXV3NhZHFGMGZvY1FsNkV6dkNGUjZORzgxN2RCMzJ5SXVtbmVFWm1kZTNPTCtPMVVRdkhsdCtjK1pYenlNNTN1MDFXZlJNM1l5cTgxMnRKajR2aTQwUTNYcjN2RDJoMlU5Q09MdEx3ODFEV2w1Tk5PN2FnbmNxTlByOU9KK29LU3RqSHZkbjVTZGF5UmRoalhNMmxINnlybW1TSVI0dmkvdWF5emFINUVZbjhqVXZyNURhMk5JSTduM2EyV2tCQUhhOHF5QnBIM1FXL0F2OWZQalZaUnRPR1hUZm1vZGxxbWpUUlIwU2NkZmYrUzRlWU9mSzViOWtzZ0VBQ0JhMHZDVjNqdHZwY0hkaVgvZjhwUFo3RVl2emZRWC9sMVByTXZROTMxSGUvcS82eDdLdEg3YWRKTXF1azFGcjlDem1aZTJRVzk0Mkgxb3J1OGZxOWU1UmNNK2xsU2tSNmFnSnVjTkhlbGZPY3I5WnFocWNoN2ZkSSs1R2J4bWtvU2E1UUMzcnd3VTRZeW15b1BVMERLZ01nbDRuOTB5ZkNtQUo3NG9IRSs1ZUIrYTJpYTFsMkdRbUFJS01XaVlJcjdscmIxRDA4a2pWK2MwR3htTE1xT3JYRDFQUDNEb0RYWEMrRGk3dXdHYVZGR2htNG5pTG9MbHNYSGkxYlp1NWRwMlk2MWZjVW9WNW1zMVNOSEF6WUIzNzRaeUVDd3dDNzZ1L0hqVTl3N2ZXajlXWjNpakxiWVhLL1RnMUtXSk5lWEZ4aW5COUJkWXlLTE5GWnRKWXZBSHZxb3YyWUNxZDlNS29MdkY0UHpMUXg3VHY3RVhpNWVpVi85MXczWm1NbXp2cnd6dnBiNWEwcExjeWsxTzcrV3N2K1BqNTVzck9ORFB2Q2JJUGFvdlJZKzhqQ0ZPZ0RCYmRXSy9pb2tUbTVZZ01JbnFpaysxZW1XaXlEbG8wb2RidnJkbVBuTzMxakt2N2QrL0tmbVR0em1KRW1aUU9lZ01PWXlpOSttRTUvb3huaTFESytPZmszZ09JeS9PTUpXMlcxQXdyS1cwZGQ0YWUxbXoyWkxodnpVT0JYUS91ZWxrbHNveFpvbmdZTVJWV1pPWDZmYjlaTXJPQ2l1azJHWWZxam1LNkp2NDVYMkZkY1M2UThObzBLenlmdHd4Uy9QcjUyOEZERFNadGNCWGgvbkU5UkgzTnhlN2R5R1M4ekZ5VncxKzZzaGl4NU5abUh3REFPVmkxVjYwWnVCa2lPaE5ZdFhFZGx3dG5aVFkzSkJ0aWx5N3h3dDk1TTVGN1hrU2paRW4yU3RUZUl1TncxMWFzeXdkd0wzcE1QYzJzck9OWjhvZ29MZ0JBdW5UTlp2bjhrT1RPRWQwKzg1K0wrc3JsZHI5Rzg4TzFheklwL21kVjE2ZklzdWpQZkswMWN4TDluUWNaU3BWYmYzQktmNzNVWjY1WTh2aWsxZGI1MUgwZGl4L1dibVpwL1puenhYQ2M3ZGZSNmhRVDh3OGpmTHl0TEM0UE1KL2U5bVRXcEpmUXVpa2ZNSHdsbndJMTFEU055ZWw3eTdCTmpFeXFiSlo0SGg2ck1ub2RXUnBZazk0QzE1NkcwSjdTYThOc25wa3VBN29PNkVicjJNWkYxNmk1Umx2bjFmR2s2Ni9IdWh3RXcvR3V4Rk4xL1VkT0NpNkg4NTlZbWd6TmVpbnQyblM3RndGTmVYUFFnSStFV3hSUnVpRXgxL2ZrOWVRNTZTdERqSTB4V0ZjclhmaVcrYWNVeVlCMTYraDJYZEZiNEs5NThEdWlXWUh0YTR6dGRTMkRTOHZsS2QrbGN2ckVIZFhKem1CbTNrN1piWFBUbGR0Y00zbDAvU0xFbXJhMzdrWXNTc2UybnpTUy9OaFNjcHR4ZGdsOGZHb3NqcXN4ajZUK0o1R3ZWMkJFbVc0d3NSWTVqRFRocCtncEdlNVZxTGk4a2YyOXg3QzZZbjcxMmZHeW5CcHRGekV6dTQzY1FqR2dzVWM5MmdET0tFWlI3bVVtM0ZLMkcyZ3ZNSldGQmhQRDl1THp5RkxxVDMzVVYxeWFucGtoRWhjQThHd29hOHJyaGk5U3hLeDdzMHl5Z3ZGR3lMcUZUbDEvK2dVU0s3bnRMRzkvZTVVR0FJL2d4bnNhb2d0bC9uTVZkZy9LbDNjUnJ2aTRmYzhuSDdCWFhuR1NVMmg3cVFuSWdxZ2lYa2M1VGhYYzNtUnE3a2R6eXp0SnZSS2plWitETmMrY3Jpa2ZBQ2ZUdjVtekZwb0Qvc3VZWGYzUWdnOEhqWDhMWEhzYVZXVHFteldqWGlWQTF3R3JjTWFhQnYyOXdyeXBBVVlUMlgvWjd2MUpBQ2h3RzVEMWp6eW9PTkxhTFB5eUJsY1lTUkJYY0NxdTVUNVhubks4UDNNaU9zZHhCMEpZKzFnMC9yZGhlWk5mRzhkdG10eGNkeFJGYTU0aXhPT3lwMzdBVUpoNEtjM29FaFlOcmYySWlydGZQZm43VTJWRktjTDJ0b3RVWTFJNEo5aWFaaFRjODFxZksxTFdxcTZsRlgzeDlpYk9mS1JtLzQzOTgzTTU4ajJ1TVBGemM1K1ljQk5kMmw2V1ZNK2VRbGliZlo2eVdZdkRwNkRTQldSSG1NL2E0MDRoNXBxM1ZHa3lrUzZacEt6SWpMSTZaZjVVN3F2OU9OdUd5Mkw3bzR6U1lxdTFtVkd6YXJaZUc3Y1FTZDlUNUt1SEsxWFJZMEZrb3E3OTZiVngrQTFvMW9IRm1QZjI2NGhPR0RWMlJsb1N2V1d5MThOT2JaRk44T3F2cjBETFJ4NU1tYjdTNzVjSnZ6YXVaemJjU3hreEo4eTBDS21WSVpXUFZnWnV3Vnl2TXlRYnBBZEJibTE3a2V1L0p1eXdhN20vWkpjb1d2R2tPRjUxeEJXeGFhNTJNN1pRejh2bDJkem1rdFUzTTNIZjB2cnZyTnU4TGVPNmV5aU0xck9ld2xyemx0YS9NL0tJSWxuODF2alI1OHZCY0QrWkdaQ3RIZFZlRjBKU1cwb3B6OUxFTlkwcHF4SkphMXJzQUR5UnlCS1U4NHg2ODR6TUlOUU1TT2tuVmd0ek5rUVRXZE41cFluL2M3OTF2N1dLdElrWFdrYzRwNjEzWG0wOHFvSzRCcmJpbVFLcFRpVEYwYWNWc0FxUlplUW9KU0xGcmVOYmpCb0F3QndPK2o4d0thcHpnbmN0MXJOMkc3M3U0OVp5ZGJ4Uk9lcGs1aE5QbWZPUkpvMnlXMnUrcE8xU0hyOUs2M3RpemJ1K3o4TTZHV1Fsai8xa2t4bUp0Wm1WbFRKKzF2a2Z1VzJNSXlXTjdTSGNZR3Q5UnBZOHJSTnNkQ0ttak5yNmVsRTg3aXRyMmpZTXRzMzY5TnEybmp3c2FXODBoSnhiR204MGpkRmpFVWkwYzBBUnlpRGxvUzJuSlY5TDlQbStubDZ6c1djS2hKNitqSWpWUkkwaDZxemliR3hYVGwraFc0QXcycFpsZlYreVJjc3hyVFptSWlhc1ZEeEtObmQ5VzZJK1VUQ2NFU3RwL0REMWJ0eklLdDUweFNVNllHYm1oQkkwYmM2bXNjMkhCZElYOGZURzVNYnJCWjZBUy9YV3FWejBwSFdXb3p4YjRHVE83emZsdFVIblpjVDh1MXlYOUJiSUdoOWpUOEhTbTdRK0tybityWllrSjdPTzY4TSt2dTdVU1dhVTFTa3pFMmswRWNVYThlNWM4WHhuNU5tYngxTVVzVldmZWR5ME14aVZ4MEllZ08zRk5xdk52VG5XY3pxK0UxZWMrczFDMldkZHVMdzhnc2pyQ05JY1BrbzJCV1YvY05zUm1oM0J2YW5SODB6T2VtbUw4dVhydjdNZjEvckN4bE5tbTNHY3YvNEY2MklaUTVFeGhuRUp3RDJoWE52VS9ka1U1N1dXZnFRZE1VTm5Scm1GcnZXWTlGSjhzQmFlempkNmtHMXhja2M0QU9BY2Z0N2lUbkhJdERPVXlveTBNWW1uMmhHbGNWd3loVGlVaVhXZGJUOUs1ZmNldGZBb1kxUys3QlBVcHBaemZHWlhUSEFyVEtwYzdUNWtzbC9nZlROd0VyMHYvM0RiTEtrSnY4a1E2dlVMUkdUY2NXaEJKUUJBTTJOUGcvcVI2bmIvTCs4ZytDUEEyYlR6T2pjNVpEMHBHRWl2K3dJTk00d1J0aEorbUxvNkN3d1l5eStnbWNNQjFMV2NPMjlQZlZnWGt0NTBUWnp5ZXZCaUVGbVlhL0RsOUE2RUorQWRQS201bjR6M080ckNxWkN4MndGbllsV0MydjJOWWd2ZStjS2JXbVJQaE9XMHA2ZE0xa2xoWkV0eXF4ZXUvRTVsVVJ4eFQvbGhCSDNmK2hXNGNvai9DWWwrUVU2YmYyODFIM1BkR1hPS0g4NjJLMG1vejZpcld1dGxsSExrWkd3eGl4aUwrOG93VnhMcHg2bjhxY3lKa2VZaFdxYzk5T2FwdEtmVmlQaUpTLzNhNnl5ODljQTl0MVFmZ3hYVlllcXNiSVozMktkT2Q3MjJjWEMzODAxcmgzeWFwWkR4Wm1pQ1kzemIzQWtvUnM3dUsrdXBqbm5wcDRwZWFiWGhtOUw3QTlEY3VvY3JoZVZqRDMrL0xGQ0lDSnlQS1Juei9oNGkrcGVUUWNXWDdBOHFQU1hEQWJmOE1YY3FRN3gyYUhobGFXV3hQSDR6N3lSdXVldDkvc1RJSVpMbnRoNXkybWU1eE9BWm9hK2phVDByUTJzbjR1S1B0Sit0YUoyTEc0eUpTU2ZSNjR1USswRnRmWEhybkdPYU5qN2RKcm1KdjZVcGh0SnFITXRxVFZuTGVNSThCOEM2V0dhSTNpME44L3FRbWZ0RHF3R0RqYzZtOWVaWjZMemZTNUVlczVKeHFWaS8xaXJpbmJxczB5N1hJU3hvVXplNG5wRnRNc29Jc0xpZExlRUFmQTBqMXFDREJpaFZsTkxjcjMzZVVwNVp5MnFjbi9tNFh6U0hNaVJ2dXIybCtxaS9qRnBFcDB0eTVYbk1lMzlQZXE0MlBKdWRhMjM4bzZFeXFpVno4MWRoVitIMmE5MXNjampvV0xUeHJGbnpXcHFTN0Q2aTBZYUVkSDBobWhwdXd5MU5ZSFZ0ejZocU1BZlBrT1BTOWs3MTB2V1hRMjByVUVQT1c4V2M2Uk5OSzZINWRpbnRQTis2V1pRUlc1Q1NiS21pb1krWG84ZG5XRk1xdjUvMnhkUXpMQ1B3TUN4MlJMdW1jM1M0T3FtMlN4d3hhYTVZUGR5Q0VmTVMyT0gxYm1sOXJwYUZINmFDYm1wRis5WGpubkV5MXMvZFJpbUNLUEJGd0NvR1JzcWcrL2VnbVIwMlpVbU5FeWhGY0JLMzdXcndqQTdDTW1HWEpMOWFxR2xzanpGUUFtV3d5S05YNU8xMjZENnNNQkpuZHI0ck9uSnZuc0gwWktXZjhmeWpMSXlJbkVuUDl4NGVuQWZ4bDlqYWxCOEgwZmRHNDV0a1VQUnhSdXF0bGZWVUNRWVhReHhqdUliSnU4Nk51K1AxOWN2dE0vdUQ5c1JSZTRSN2pjQmFwdEdzMGJKM294aXF6YW9KUjFrSzRPNWNPUmE1dk9mdk5IeHl0dWQxWmsxaEhBSUFOaXd2Y3BsbEJjSkgyUkZuZUpTZ084RmxuTkhCUjZUSElBR1Bac1FBbUR5SXlBVkhYNTRqZjBoNnpvOVNyWHRWdWlTZm5GeDl1RGI2bko1MEZ0L2Z0bUxWZjVUYkh0Q2tFL0VKd29mWEIrcnZjdEFFMzAvdjlscjd3aS8zYnRzWDk2WGl2UGJJWGMzN3pBRlZFYUN0WkZUaUxSbngraEo3dG90VDlwZXJXckFDbUJ6dVJkUWRnSFpqbWVYMStGdmxmejUvd2hOOUN6eS8vQjdjck5rWXB5UjlEZGU3RmpRbDRKNWZLNFNrbEpnMDllbThKV0ZFUFlwWkRmM2tUaFFadHllZ25VQVNlYWxETzIzc25nZ3ZGRHIwS28ybXVDTnByVmhhMm1KNjFmR01icnpEdkVTVWhmM3lIdGR6UnlKUHVKL05NSmxQcll3dlkxdGpXUW5YWkowNlRtY3FpWHhpWGl2QWRZQzM4VnFOelo4eFJRbUpqaWxydWxvL1pFWlNPN2Ewc1hiczRmK2tUSTY1WFAzMVhWOXFuRFY0SERMYnphejNmVTUvMzVYb3VWcU9OUHp3SUV0U3BBZ3BtYjZnVXNSYytOaUdZcG9ZK3dWVmE1MzMyQkM5eHZzTTQzK2t6S2hPdWZDNWxHaXRDWkNLR1AwM1h2TjIvUFlsZ2Z6KytyRCtuS1hPdFB6KzBjNUx1NW1SL1FUU0NLeXJNNjNPTFcwaTlTSEtGaGlsVFViSWNxWS9kSzd0UHZHY2tVVzFGb2ViZjcwbW5ERysySU5lRis1VGgxL3hjejB1YTFsTnBvV2EvTHhEWmVUUW1wb0pOVzVIeWJZUTZaUVJ0SG1uMXhkaGtjR1ZoYXR6angxUmpIbVZKclMxajNMMTMrTjlPZWY4U2xHYThLUE1VdVdkREhuVThhZ3Y1TFJFclF3QXdGZ2szeUdsOFNKV280ZFN6ZjNrbDBLVFg4N3ZqU1k4RFVBemMxOTAxWStXQjFjaGVSOWN1UGc5RldHWmRzRnpHTzJLa0dScDRlaUxBS3lEWlhtMFRmcmU1Vjdtb3JYcnB6aG5mVGxWTHNNdjhWTGsvWjl2bnd0L1NPWEJGNXBLYzc5VS81V2dmSDliVWVxNi9ZVHpQemgxT3BjT2YybGw1cTNjbzAzTXI5azErNW16dlk5M3JBTWlHZUpiSjlTaWhMT2J6a20zMHIwK2xaZ3Z3aGIzQkxqSFNNeTFkcCtTMmNhZjRWNEg2NkU1MDdRaGxaandWazN6Nm5zcFJpNUJhcG44akdCRHFyWmFjOWIzdUxpZSsxUVlWTUlMYjJWcXpySWN5QXNzajJuWFcvSlhVa3VhWmxzNEUzbGgzSUloY09aejFjbkkxME9yRzlZdi8xcm5zUWhXNi85cnNDNlROQmEzMmI2TnJhcGZQMHpGelArVlBMRlp0NVhRQmNxa3pWcGI5NEl2d2ZJK2FRUjBudHRUQW5HK285a2RTbmozd045cUJjNllEVjUxZktPSlp0WFdqVlRmNlZVKzA4Q0k3TWZkQW1WSi9xNVB5czFGYlRSR2VyQzJVV2xKdysxMldOSnBGQ1hsdHhraU0vUndJQW5aMVo1ZTE4SG5iNGZIWll1d3dsNVpScTg5bHhsdXkxSHhScWNka1g2MnpLaXNkWi9yYlc2NGRwR0w3NzZVK1NjeEdYeVlyOG9aZFJsZDZFZFdncVBqV2QvSWFkTllPb0JtNCtSamNDSHlPT05naGkveERUSTF1d3Zqd2dHNE8veExUL2ZzOFNObkNBREFOYXpranBXMlF6bUx6UnArQmxmV0kvbXlVYVFTWUlBQmpUTmRFZHJMd3hFRkppMUdBQUNUTVF4WXg5aTgyNWRUTmZwTFVNZy9pVXNpWmJNbjhENnN6NWN1Vno4Ni9mMUJyUGZuUGIrcHFmdWx5VU8yL2lSRHlESjUwR1hobm1udWxCSTE2a2JtZVpjVnd4ZEIvVkRxQVkvOWRjemNrclJ1OVdqYkppc05iNEdWZDFneE5COEc3OXdITjhLMHB5RkZ1b251QkErQm1Jakk3bG4xVyswZE1LaTBDV2kybTdiWmtaaDRZQ3BiTS94SjRKNUlSOGljaE1kdTFOeGQ0V0pUV3Q5YUNPMDZLZmUzc1BJSnkwMmF2MTh6S0lHaWdKc1JuY0RROEhZV0dDeHRFU0pGb1l6VDdmNTYzYURIZks3VE1scXcvb3hMNWl6K0dkb3lLcU0zeitwNXpkWXhFNzFPOHo0eDErcE5iWVdPcUZ1dXZWOGJjVXhleHcyNGZhelBmVG8rbmFmTWJkY2IzSVlLZDkyYno5Zk9TMVZGN3A2eHBNOFJXSy9LYk1QZFZxNjFQRnEvTHUvcjR6eEVqdzNMcUtmR1dRay93eVoxTkU1ZHVSeUVwMnEzZVpXVDd3YzVUek1jbWVlbE9uTDd1VGpHNE9xdFFTMTlJYTU3MVRPVnB6NWUxN1FzOTNqR2QrK2t4MXNZOUgwcDcxRjRlbVB3ZVRPVEp2TjVNME5uYjZxWHZVcmJpMzdOU3c3ZDlqZU4ySjlmNDF1ejRlWnFTRTE2VDNpMGoxbjdOYWVKNmdtSmlqK1lueUpzbmFkOE9oVzdEblRJNWRKYkg4T3IzQjBpNit2ZEtrbGIvdVVtWG1NRTVscE9KVXUwV0p2bkxGeGV0NkZkWTI4MGxhVTJyTWZHbnpHcld4bGx2V2p6cjZXTVJaRmRGQm5hNER5MjY5R2prcHZ3L2Jybzg1WFQvWDNKdC9Cclg5R2xMWW51Ylh1WkdoTjBLd0RnTWxvcmFxQVpvVktZSlhKOVl6TzVLQ0p6ZnliY0cxdmU3YnBCeXJ1SGd3dEZtNWExTWhUaG5tV3FvdUpwWmdWNEZ0b3lNQ25obzhhUlpWOEJBREFRYXVFZXBKNXZMT08yY3p4YnZxaksrYVY1THhVdGM4YUttK09UMTdaTzNOYU5sc1Q1MElhNlgvNDMxdTZTZUdKdVhSc2xpeFBQbm4wTldIeUNtYnl5ZUVMMzYzRkgzUjJ3NUdhTm01eDVjT24zVDdvUFAzb3lkS1BBZ3lmZGdwUDlVVm40d2kzQXh2bE9SazBXbk1yaFZHRjkveUY5eTZ1MWZITURIWmFVKzRYSnl6NERIclZ6ZTcrK0JnVFJTdmZJQk4xbzQ5ZGpWWVhMc1BrZlg5Zi9CUHlSQUlTSVRFUnR1bnJPYjB4NnlsU3dkdXZJR0h2TWtMRWFIdDdLQmdlc2MwVEV2dHJBRDFQdkNpYnBYN1llZmFVaUlVWnF1eWFON0lHQ0crSnRTRFQ4bzVEMm10RVZvbHc5QVZ6Tk01N2RmMHJzUTZnTmpGRks1R3VWa2ViTnZPSU5IY2xTdEw2UlpHMHcrc1h1Zll4bzQ1L1JhZTdhTVl0eUc0YWpqRkIvNUpDMHJMcU1lU1JuMWtJSlpveXNGVTZrNzZmSDNYcm0ySmxWMXozUDN4dS95TGVxOStmYzZpcXltMVRvbDlrKzQ2MDBaYUR6bURzcUFuVnFEaDh6dC9QM05YdkQ0cmthVkx2YnkzeXV6L0lxY0lyNVM1Y09SWnVJa3I4Vm4yWmRnRkdjUDhnK2M4UFphN05qR1N6UGo3RUZBRGdMcS9kcXBNWEszWitwKzZCWHdlM1FYb1NUNG96czhFWElFMXN1QUV4azhNeDF3anRSRnA5emNmcmxQUEhuZTJGTGMyMUpYSnJMb2tSL2hXZW1GTnBXSlNXejJTTXZ5cXJVL256dE92aktkZjYzNEgwYVRNUUF1RG5qblJqdU5ZMkg0ZlVoV0g1N3VIbzFSdDQwQUEzUmhzYVVPSlFaNzZlRWhGbjhIMGJRUmNCMHBGL3JEWnJFdm12dE01aW9qeFFUZDRqSWI5b3NydTROL0RBVmhQSDhJdHE3SUFrVmhNc3crbE51ajlLcXlyQjlzYUI5eFk4UzZhbERjRU42UE1KUFhQRzI0elk0QmcreUJxTk5zdHFlUXM5ampvZFNsdHkxVjRsS2NiUzBXdTFKeDlob0t3WHVPVWEyUkp0WGl6WWJORWRGWld2dm9zcVE2Q3pNNWlNbGw0c3ZQKytuOUw2Tnk5K3dhRjErT2ZDT01qUmpoTzBtK1JqblhhZlpsa1hSSWxqdVMzcXJ2dHBueXM5SDIwOTUrTTZoZFozanlkZlJzUlZKWjEwcFJHVVh4MzJMUEc4Wk9GR043bCtDM3ZZYldOZk4xRTliTUxMc2d3VlErQ3k0a0tMa1pYbDZMdXczWEIrL1ZKcjVQMWI5cGduSHFtTzR0RFBxWVlRdUNjcWdUTUxteDZsV2laSFNINmJvdjE5UUxjMFhVbS9UOVR4dG9NL0VNdHJhekdwdlZBMnU1cWt0dWdYNzY1MUY1cE5MV2JhUFc4dVFpbEdZKzU0OHJmZVpQRXZob3labTZpL3l3b2prL1JFUDY3Skp1MzhKSTN3TjF2QUk3WUxCMmtsUzhINEVieGtzZGQ3cURxdS9KaW54a3BLbmZyYzBlUjYvbk5yRzV5VVc0dDZ2SkRvUFRoSnY0OG5oRmtiSUFBRFlzV3ExR3NuamtKTFBqTEJBV25iT0tkTGtpcGk1SUxDaUtQWDI3Sk1TZVU0dXIxNGtXMWE2VDRXQmV5T3RWU3pMdzJqZkxNbHUwbkY1QS9Bb0FvTXVOd084S1BIc2p1bjBIc0NadWU5bTNNcmlITCswRi8vejVhcjlxQitmYnY3S3E2QVBjSllWOVAremQyN0xycU82R29hdXJuNy85MXNYNnpuV1RiUDNIQ05Pc0N5aFh4eHNKL20vcXU0NXpFRmdEcExBTWJhK3lGcU0xRzFaV3ozMi83N2kvMHBiUFMyT0w5VCtqbC9VUGJJZEpzL0RydE43ZmVodFJDWWpYank4Z3ZENjB5cmp3NGp1dzZaR2VPOTJPbjJkZFVUVnNUZmx2THdqSmxFcjY0M0d4dVJIR2wzTjBMUFV0bmJacmZSV2VLVHJaMW1DajhkcWlHS0VweW84Mm5qVXc4dkpUbmgwNlFKVDdVVVVVZWlYZWo3a0ROQmxnNVZYMFdNL3orQ041RkVRT3pUemllelh3UWFCUWQxbjFKK3MrU3NSUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkFDa1AvejMvOUJaeHI4L1EvZlliMDFyZU5yVGlvU2lXOGRtTEtFbnVPSmk1TnVpeXZIYU91dzAxNmlCMGlSaXhrNStaZ2N1ZmFRejBNMXZHNUZWRWRMdml6anZzUERQQ3RKaWUrMERxVzNOUkY2em9WcjVmUEthdDN2SU0xVHRKMWo0cWZVSlRaaVg3MjZuY3BhZHRkSFNmUDZIVDBwNkMzVWN1VDA5RkVGOWVrczlaL1JVU2ZUeXp5ZVRxMVQ3dWRVYkM3cEoxdmY4OFRybGN3Y0NPTDR2MWEzN3E1SGp4NzhGTnd6R3RYNDNaZnBSTnVPdGlpbVF0dG4yS0h6YVV4OWo0NWpaTkdTZytGZVdTdjhGSy9NSk1yNEZDUHAzQWZpUjlRQmNsS1ZjVTlOVTNNL1h4N1FObG1TUGRLMHVKNnZEdXZTWjR4akpBK2FEL1ZpZTQvNHh2ME5XOFJEUm1zZHN2dGk2b1F5dmV3WFRPZUlSeGMraFZpYk8wbDNJdzUxS2pzUis3ZzYzQ243ZlZSa2RIMC9abmt4UEp1WGpQZ3R6WWhlUXU5bjlqNkJKc3ZUVTZVWnE4bVFPdDlhRC9YdFJlelhRemw1YTdJMjFzN1oyMHd0UWtoN09aL09lYVJobGZubjc4MFgrQmUwL2M5cm94SVIzK1puK2FESWVMdHREczlWOTN4UHhMUnI4aWE2eHdSZzl0YkpSc3Y5UXBka1hwa1JGeFlaenh4N2hOeWJqQ1FZTjdJamUyckh0Vlo2WEVka3pGa05uNHE0MFp6UnRlcCtqZW10T2ZWbmQ4ZS8ydGpLM2pZRlczMy9WZk5aZGVyYnBld1pOVnArclRRdFRXU25Uc3V2cFkvc2QwUWRpUTgzMENQZFQ5L2x2a1RYUlo2TXlMT3Q2Qm9NVlZnZjZEZWpkdGJTWWx2WVgrSTZXZ2RKcTZuUnBYZEx0WHg0dDY2bnQxTzBOR1E1WHBQM2JsdkpaNVBXNDJCa0hIeVo1MFBPeEhPN1cya2NrWEs4anE1b0ltVi9ISzBOZ1pTK2RwazBFOC9ubXpGK3R6TDR0aWtoaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDSUhnRjFQZkJldU43d3VySU1PMU9Ca3YwNTE2RzVIVFdXcWdZejhTZEpKdzVCQlREL1RVSW5JQjNsaUxISmIzVGZTY2VwR2M4QW5WaVo2Uk9IcXkrUnA2am5SRGp4cnh6dEx3bEdjdEJtM2xGS2lESldQMStUUTlQUXdPZUxVSnhmRlR5K2h2djlkZDZhZnVSazdqalg3RnNkY0YwTXUraVpvZVVTSXpISkZQcGlDTkd6MTJ5UnFGVmpxWkZ0Zlg5dHl3NCsyN2JKL3dyT1hZVXZxTUR0d2Iwem9lMEtMNzlqNThBaitIdDNPZjBKQjdqTG1DWnhFQ0FvVzlpSTN5L1R3OXAzZS96UWlzMUZPSXZKcVJPdlI2TllCLzZRUnZwLytYaDI1cmZTQlRTKytobDdtUE9HZTBva2N6ZXVGZUdSSnZmZFVDM1hTSWdDN0dGOUIyYWVac29vMnF3TUNVUXI4V1pwbStWay9rUnBuUVV2dHQ2TlhMSS9zYVNjbHoxd2J0WGVoRlJoV1N0emRkMU9ibDNaVlhoOXhJLzd2SDRHUGRoV2NSdnMzYkl1U2JHTkVkbzdxaXVldHUrQURSeHkzSmlOZkt2QkxYNXhsUnhJMUhHcXBNMUQwdW5la2plY2g2SWhNWmZXeGtqYm1SWlQrNnpVeklWN0p3cjlEYUNJZ1dlVExSWjdBOUpmeHlEMC9DdTk4L2U1dk5mYzBzL25qdW1jcTlmdjk1Ry9JRjFaYk1vN3g5K25hcVBxeG5HaEprdFI4cDFaWTZTMVo3TCtJWWpwUWgwMytaSVVhYnp0dkdJKzlGZE9zd0tlbGJVd2hSYjk1aVhJdjdZRUxQRjZxL2tjY3JrUytub3NzaExSNHRvMDVQT3BqVjJGeURYZ3E2Z3BueFRDT2plMmhaTDV1UTZhQXV2WXhQMVg2ekkxS0d6L2o1UWgzL1ZVUVZGbG5HeUtxWGI1c1NRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQ0l4eGRUL2ZldS8vNkhyeGpmZ3BGRHVCYURIbTV5YWxVako2NmdCNkJ0Y1IzSDlveWNLRUxlQ0I2VFA0ZklrU016UHN6Z2lJMmVKbDRjV1ROT0d6c0g3NmlZVG5sRE40SDBCbnFFeWtnWldwNmVzOTg2amJvOEJ2OFFQL01jT1V1R254ODk3TklMbjBudlBMNFZ0Q0VOSEwyRjJwZEwycmkvME5kZDcyL21YL1dVNHRmODFiV1JjMEswT0FINTg1bmtTRVNjZ1NWTmkxWmlaaG10ZERWQmF3RzRFMllUaTRQcUR4WS8rSFhIU09sUm00aElydWY4bkRrNTArZHA1ZmZLdUtOc3JheWVpVHpTeG91VWh6S252TFhKbGN6MTNXYnB3azZmWHMxcjBUT212TFVIV21ZMG55RUdFYlZpNzNPMnlSdFEzS1dWcnBsZ24wNHpVNTZsOXo3V2tvd3FxUG1tdGVsTXZUMXByUjB1WStWZUJDSXo2bi9ObkdUUmpicklobnZyU3pFalhvOWRCL1RMcWZMck5EMHRPbHN0RVVMT0plSTNSelhsTTEvRDVxUHk0R2NhempwNVMyUDVIOXNmYXJ5MVBXZmNWK1MrclRyWkdYYi92UElxTjd3N0ZiK2pqQ1R6ZW1iWVlzU1ZKK2N4ODVFVjR2cWwxTGN3dGhRV3h4YjVDbWF1UFNjUm5iY2gwZWM5dytuZENVWFdUOWxaSng3VDI3THFGTHQwTzkwb25ZRnF2U2ljbXVPNmNIOHQweUZZWDIrMXl0aXUveEpyMDdyMFZtbEkyVmp1ZG9tNUdYTEdYa1NyVE0rSVIxYjZIcU9HT09wSTNnVEx0MEg4cDFhNnBLU25UL1BkUlAza0x4dExrU1hLN0dWRHl6NGZMWDI4anBwc3I2NVVIUlhvV3JXVm43dzlyay9mZWphWjIzdUd6N3lwWFRZaHA1SDFvS0lZQjgwdWpSVFZzelg0ZFhQRTgvK0p5YWhKMStTbDVHOTUxL0NMcWVSMHFDTUlJZThDOVJWWkIwY1hJWVFRUWdoNUQraTVFa0xlaHp0b3JDdnE4RzJhK3JyN25mbEFqeEJDUGc2YVFFSUlJWVFRUWdDK3pJbWx6MDRJR1lBcTVBVFl5SVFRY2l1b2xzbTc4dmZ2UDk3ajlEL3hIT2EzNEViZElOOTRSZzRTOGc2Nk9nWDBMZnJCdCsxYmI0U2o3WEJwTzVGK2NqQ2M2Q0FUQUowY0E1TW9CNjlsc1JsSTV3Mk5hM1hCNkFtTk0yb3RXNkJNS0FNOW1qRlNSZ21XNWVWM2p1N0w1Ulg5UE03ZU9JYnFVSWNaRmhuTGN6ekZaMytLcXhjK2sraUJtNWZpSFF1SVZQWXRiblFGb0pOWEg4czJmTW9TZXJaYmNkTGdGWWpQb2Jyanl5RTBWYkhlNEJpYnA2aE9qTWhMUVpuUk9uaHBqVHBBVG9RMndSVlpJYXl6UkdmWXowMmVsYjg0ZFpIcHdQbHFYTFptMkxNRVlScExXeVRVTEpIVHcwYzlDRVRHZVY5S1RZRTBTUDRWOC9jTTQyYk5LYXNPUGZjWnZROWpZRnViTVVhMlhmVC9UeDd0eThIb0Y0d09YMTFxZlkzNGVlTGtzVXpQY2xwcEdqVkx1cmJRMGtWS1FmbzlHL25RT25qeDZHYUVWNmNGSU1WRW5mVklGMFc3ZWFTc1NuWlJ1amNyNlg1RW9nTzVWTm15SFMvK2hNbzROSG1yYnRQVTdhZ1YxR1I1ZWhwRnE4T29QNFVPOEVnWjQ1NkVuaGNKajA1Y2ExSnBlZVVLQmwzLzZCUDJtRDd2SktFakp1L3k3c3NvUmlxdGxhWk5JVUxJSlhqZVZXbGthbjJWZENjVFdadm1vN3k2VHBiV3pVN2hKVklmUTRsR3YvanFsaE5JYTM2SjRSRlFnQTZNMXZzZ3kzUE52WFFKakNmWFlzMGwxS2xBdHN5aTdwWVc1NEdPUjBMZW1oRVAzTFR1bmVLYzV3bnExbG5zYTVaZTJwRm5zdHBYVExkUzlicTAyVlpzK3hYVjcvMldvSUsxWS9kMUxJMU1lWE93cW1mdnFsLzE5Q3ZFbXROeXpnRHFMNksydnB3cTE3bTFoQzNsTWQrcmpiWGUreFBxK2FkMWJEbVVzZi9YWjJST2VjWVJ5U1BEdlh6SktSTlpJUnozSTJJZ2RYOWpZMjUxYTA5M2srdEErd2xUWDhmNEZpVVlMdEUyN200NHBXWSswdEEwV1VtK2hvdE94MGh6OWl5dGF0RGxFWmMrQWFMelZhYmIwdW9PQ0RrWmJ4dmpvRXNhKzN2U2JVNGlqNVJ0Y1dPVlMrNU9qMnR1NE5uRTN2SFo0N3ArL0p6d3RsaWlEVUFsOG1SMHFXUXR4VHo1ZFRpL21Fb0lJZVRldktuRHdQM1FkK0Ridk5IcjdwZCtQeUdFa0N2Sk5FU0VFRUxJbDBIalR3Z2g1RHEremdyUjdCSkNDQ0dFM0ppWXMwYlhqaEJDQ0NHRUVFSUlJVkgrVHVTOThZNTNXZkJtVk84NVlxY1NPV0VGUGVETXkvTTRIcUduNk9oSlF1Uk5zRHAwOUNpcGIyYm1VVmlkUlhzaTBmTU5yY1BXM25jWUREUjJGbis0eDVHUGRPd1ZqMUprRDBlUGFRa2NoVjJRYzBrUW1WYStGdTBqemw0bEZuRzlEOWZsMWluNzhkVHZyZVpmcTdMMUVOS2FKenN5djk3ZTVPYmxJUnhxTDIvdXRLeUlOdzlsR3Uya1kzc09aU0dqdlh6b3RVUzlweExQR0l3ajU0dk53dkVTV3FkQnlyU3VhVUJzd3FwSjNtTkQwZk1QSjFXaCtFbjlyN1pZY3dscDQrMGs4NWV0RzFtZUYxRjJmVVk4L20wdjFJOFlzZmxXK0lodXRCZ2Qzek9NNFdnZFd2blI0d0hyOUVxODUvU0FpNVlzTHJSVFR5ME9YeWR1Wlh4RWJWOFlxTnZocHc2SG8xVjFtNGIxcmoxL01mdU16am1rYk11WmE2V3Z3NzN4b01uSkNmUDV2VFE5TnNGaDVpWmFTeDBoVGUxZGd6U3JLaUlQOXNtWXQ2VXhUUC9JYUo1ZUxLNkxVWmRqZ2l0QUNyZDBaclRpRWR2ZzZlbFd2ck54QnBNTDZrTzB5ckxLUk91U1JhcVgvcSsvSlBPSzBTUysvQ2lyTG1XWHR1Vzg1Nm9HdFN5c1RWdVNKU00rSkNGa0hXME40ZVJwYkJVa1JRNjBPZ29xQ0tzdVQyM1c4aU9xR3paOW13NkZGZm15YXYyRjJGYVozVjg3L2NtY1lveWFXZkxlUkNaeTFOZEd0MUM4cFJxaXFEZ2VDWEU0N2xkTmtZZm9oV2RTWTgrdnV3YVdVb25rM1V1d1Y1RDdtQ0p5NXQwS0w0WmYrNnltYSs3R0ZTTWc3MlhLTDk5RytpanZWcmxGRGMrT2hDMzM3Lzl6c3h5dmRZdGlMT3duQVBzMU9Gckh0SlBxR2RDazVOVmtSc2F4TEJ2Ymp6aldKWnEvVmFhM2IrTmR2NGtCOTN3Vkw3dzNIYmtHVkpsNzA2SW1LOWNqNWpnNi9XOUlBY0lpVFJTOVpWUzJ0M1RaMG1RbnZxZHNLejlSNkRYTE1seWJxNjFyY2duaHJRamg0aFlsYmdNK0xMNjAwNlBlRmlGUnZkVGNoODc3OU42MjNBaW9LL094YzZGbGR4QW5wMDVmLzB1bWc2eTBKZnhpS2lHRUVFTElhZEFUSm9RUVFnZ2g3d2s5V2ZJUmNDQVRNb2tySnRQK1I4V0VFRUp1eG5XbWdSQkNDQ0dFVEladUZpR0VFRUlJSVlRUVFsRDR4ZFIzeHoyQ2QzMlIydmxtOHJvWTExTG10R3IzN0pCRkRqUnJ4T2ZxZ0VQdlByM3JoZDFJVm1KMWFBS3Z2eDN2SUVNdkRTcXJrOGpCYlZaOE52NUd5engzeUhobnJ5QzFjYjd6VU1RZnhoZVJtakpzb1VaNDlNaEZWSFBYWVRMY3E1TlZwcE0rUC83WGRSUThxcWdRUEJuNnFiVDdXSzFrcEczSHVNQ2R3cEczN3psaWRaaDM4S29tbzViMXFmYkptN1liMEp4Q0d4a3VOSG5PNXZHcncwV2t5azlKU2Z4MWxCaHptdTNUbFdmb0RMOTBQZjgxMWxHbjRFbGNkYlpDUCtkR1hLc09rVHlyRU8xUkdxbmtaMXhFV205cTI5YTNWT1hZUjdWbFVTUDVEYTZVV2w3RlBxUW9aZTlMTzVKRm1YRS9ZeVl6blhiUE1LR0dDMm1QVVNQb3JleDcrc0FlYzY5NElEbzdaZFFUSk8vTGU1Nkltdlg1K0N6cUVXOS9JYlZ4LzlXNllOY2pRcFkxaDBxa0xMUHczdjd2NmRlVzN5REhaQ3U5bEtleHlmVDZ4UXNQdG8xMkcwamFDRm9WdmFZNmd5SnVYM2JyTm5kQWsvK2FneUsvbHNkVENlQnd0ZWJhTTNCRVZRN2hqZWM2WFkxdDVmSDBYcG5STWxwWU8rMnRhNjFNcjA1ZWZoblhxb01uMHdzdlJscE53K2VtaEt6SzBWTFdaV2k1c3lJbEMwbGxWNmNaVnVleTZVVUlhWktOYThUTHVuSmV1NVlPTUZNN1g2UW9janpmeFpBWCtWSnExMk9DbmFCQXZ2ejZwMWxIMU1TalMxRnlMM29uTU9KZW9xNWRBV1ZINFhnalg4Tk1TeHlVWVQ3dkR0UnArZHA3WFBqcnJ2VDdrcyswclB4Nm5tekc2WG16ZWxVT2RXb2hZdk5yRmZobnY5UDgrdWpUZDlEWGk2MHdmWDNiOGpTemtxYSszcGZqclZXUGRYYjJoSkxmbi9ueEYrYnFlUHN4MW4wV0o3MVhUcVJNUkFaU0pyb1hnVnpQY2dwdUF0b0Y1SjVFN1ZYUG94dnJHaTA3dW1aRDhpemt6RDFEVkF1TnlpMUFtdDU0Q1pjN0UrZzFUK1RXZUY2VnR4WHhrd2JwODVZVG1QV2syVWhPU0RmR2ZuWFBJTE5XWUY3NkJLWW5DZDhEWldPNjlMckhudHV0SWJ1Slgwd2xwMFBIZ1JCQ0NDR0VFRUlJSVlRUThsVndVNVJNNXc2RGlnT2JFRUlJSVlRUVFnajVGTGpLUHhPMk5pR0VFRUlJSVlTUXo0QmZUUDBVc0dQR1RpbXlkVzdiOGhmVlcrMHdla1FPY2lKdUpUTUQrYndYL1BsaS81dmlkV0QwR0tkdkkzTEN4WW1uWVNBbkFpSDVVMGYrZVRxaHgxak1PSG14enRPNEcrdmsyQzM4b0NUUjFodHB1ZElSWDhBNlJMVytrYTRvWVQvSHlNc3FGSm1wVWFjSVhodkwwejZQc2ZJdnV5N0ZLUVBqclE3VWlTZ1BkRWdoMDFnYnhsYmN1Nkk1cmJ1aDFLTzVQWjNwNmM3V3FOeWZiQ3h6bE9mcHc5WUp5TnVwemtXVVVLZG8xNjhNSFZlN1NoOUhkZWtGaEp3SXo0SHMwZC9hcWN2SXdtbGxXMGI3QytqbmVnRW1qMndzMVpkTTNhODVidUsyT1RSaWo5cHo1amdrU2lPMW5sWXZjZlo4OE81clJLNG5yKzFIdkpnNVhrZGw5YTRRdFB0RTc5K1FuY0Y4dFQrWjIvcDZtenZTUlpmeHo1b0lINytPMzc1ODlBclkvbmxGUk83K09LSjZiSVNsSzFlT1FWbW1ad3NTR0YrTU1yVHlMWDJGbHVIVnJZSFhkR2ozS1dQSnpkZTdNSERxcEppaHcvSTFwN2FNU0JsMW5xSjA1Mkd1U1ZuTy9ZWmNsakE5Tml2cVA2QjFrUG0wdXFFKzdReGJITlU3YmIvam1HNW1IVDBkZ05RdFE3bXpzMDZ6djA0ank1UzdFWEw5bEVUNmZaNmsxQ25Tc29NV2Z0NFVKSVJBdEN6Qkh6c3IzVzV2L3JmUzlzNXZXVWZWSGRwOGVFTXRhejVCMUkrUWVzcnpNM0wyMDFseFp0ME1aUm5Tb1k5RUpUc1pveTY2a0QvaVJwT0ZvSVk2TXFGekkzOWRWblJaT09abUVmSUY5RnJXQ1o2M1pjQ2VlMnZHL3JNMXJ5L0dXZzFyWDhiOERUZnU3MEVCVmt6bG9CenIrT1B6TVZrTFc1WGFkVHZjcC9jWmVJSGNPMjJYbGF1NmJtdmEzL0NpcExMM1BQZFg1UkNTbExKZmY1WEs4QnpYM1BtWnlpNVprNnRoOVdjVTFKR3luRGZFU0tJVEVkbGM5TXJzZFJoUFZBNW9NMjFwVzkwcmJ3dTlEYlRieVRWNFU4YnpiVDJUMENyUDIvcnp0a1lqZFRtUjBhV0lsUjZkbm5LSmd0RFRoTElzR1c2QmFta1NvSGNPVUQrL0phaktsT2sza0QzRWx6K00xWVdRNlFSOFdPMm4xbHEyM3BXSXRnVm9ZZG5BajFlMzBYVkVOUDZMNlBVam83WkJnMTlNSldRMVZIS0VqTUU1Uk1nYzhwV1RpUk9aRUVMSWhkQU1FVUlJK1hab0N3a2hoSkRUb05rOUVUWTJJWVFRUWo0UXVqaUVFRUsrSGRwQ1FnZ2gzd3B0SUhsWCtNWFVUMlRSeVQzZWdVRmJtdnBRSzdRcTA2cWNSU1VpaFVaTytJcktiZ2QzcHlNM28vZkVCWFk0UnF0ZEwyakRXVVZHZEdVZnFGTHNrUnZOVXV5WEkrdHdlYXhTRVpPcnpHaXhFZ3hINDJjUXJKczJpQTV0bUJhQ3RabC9WeVBIMW1BM2lCNkcrUGFzY0RnKzBWWkozWExaUUxETzNCcHI5R0tPK05veWxNcDlYamYzNG1sN2VMTkJlbWwxNzZBTmd3M3dyR0xERm9xMHo1VDExMUovTHNlVnBCZlRrM01lSzhwWVlWalE5SitvTzFib3p1SmMrOUZQMi9EanN6ZVRwaTBaUW12T0ZhUGErNjk1NDk3eDNMbDNwN0VSUGEvV2k5ZkNvMk1OdEJtMTZHSmxNeU5peUxJaVJFMWh3YUx5STBCZHNxWE9Nc3BMTm5LYlpwUGZoanRWQnVtbDBmcWlHcTAzelFqZU1iUXRIU0psZVBySUtrTVAxN2I4N2EvdTdHdHdqTkh5bE9kNjZEaTNJZzhjY0hwNzgxYlRsNUF2Ukh2K0tkeG5OYjNHN1BtTWFLdm90bnBySzcvY1FDR1ZvRm50cW5QVUJMYlNrUGRoeGZKSWN6VXprRzQwbm1PUWtFN1dHN3JubnBuMkE2ejVTNUJocmpYOTFucTlyNUZLYzMxb2hBY2RDZTlEcTYxbmNrVU1nR0xlYjJsY3RjT0xHcHZGMVN1K3R3ZjA0V3hKNnlXNmR6cGpFN0Uzai9VTHk1c3pZM3NIVGU5MUkrTHJ2RkhUZml5ZWtoaVo5cjBQaktMYnJ6Y2ZRMUZMR0czeUhuY2tZb2U4c2xkQTFlRFFPN2RrT0J2NTFtQmVwWjJ2bFZqN1dxcVczUHRTSHlGWFVJU1IwRnlDNC9QRGdQelV4MWZOaTZnZDZua1VUWGJNY0o4bGZESDFVN2hnZ2xrT1FxMmZvK3ZMS2JlQlBnSHVYZlZJaTlOUjJSbjNPV0xrQ0hrN3NuTjlJWkg1Yk0xYjYvY0w0N2VwYWVaUmVuNE1YZjFTUlhzNXRmdExuajNhOUE0ZWFiUU9NcjJTdi9WaWIwaDJoTmFJOXVWWkpiL0N0eCtGNmcrOFJsaHgxMitGMy9oZlJtazlHVjdrbUZabEg2NWxvZWlja285MVM3UEV2YytPUERxdWMvdTFpYVdmeVpzTjVFUDNHdlUzYit1SysyMlY2WTFYSkQ2bDBQMG9qcFExczBaS3lzK2ZZYlJ6ZUw1ZWpHTXQ4NDlsWE5IZm4yb0UwUHVhNGRVaitkQXl6dVZnR3g1L3FHdVRoODNjZm94bGhjOGt1cmUwcHZUb1RoYXlDWldkK0JtZ0dtaDBUZVlrMFJ5UVo0Q0lRSnMwTzJWZGdEcG5qT3ZuNnU0UlVhSkRMT0ZXMVlzL05MWElPSGRhMzJreDBtK2g0NFB0RGphZ2R3L0ZuTUFwM29hSVI2YTNyVCtlTjE4dG1tN2JjOWkvbkxxUDdSc3J3RzRPTEdOZkgwTEkyWGh1QjZJaFI2d09TdFR6TTkwUHhNWExobzhnWGJwaTU0OWlsZmtUL2xPWW5hOVZGN2RCWnBoQThobWd5ME5KWkd4WlpmVXNQYk1SYnVVbDVLdTVjczJtUGZkTmI4UysvdmphcmIzdUc5bnZDSlg1LzQ1Q3NSeU05UEQ1R2hzak9RdlpydVB4cW8vR3l6Um96d3RqK0tQYTNzbWFPUVR6NEgzTXFzWHhXcnYvYUQwakxhV2xSWnlCTHlmcXE3Y1dhZVQ5bWFGS0VKK2RZK2VISzVyQjl5TitpUTRGcW9ZT1JocWJqWHdac05kbDlPOWhLNkxsMmxaN2dOcExxZHR2RG9vVVRzalZXSHRwaHY2cWcxY01ZMnZlY2p0YTBMc3ZTMVJXL2NxQkw2YStHL0xoZ3d5L3NBcWJja1EzQzF1eXc1bXlFeCtWRndsM1JGbGJTNk5jdlcxSEJtRG4rWGlUcDNmeDIxbVZ1a2dyM3JwRzQxcXkrbjBtcVprMVRWMlhoalM2UjlIRG5rWFhxOUl0dXJjamUvSmRNUUVqb3lRb3J5aGhwekhSWU81eUYzRzlua2dadDFEaEU0Y1FGUDdwSEY3c1JyYTdSL1dXMU10V0dWcTZzUlcyN3JQWFA4S2U4ZExibFlQcFpnTTV1bGF4YkdMME15QUhrSEdMeXBycDdVVGorN0xNV0pPaDg4TDZPVU5LYzhwY056OC8xUWpNR05jamFXZmtXNCswTXR1REl0Vm1GTU5YVy9qSnBLUGRPcE9WZWkydUZXSkUxbjI5Z090RmN5bXFSUFJPMnhtM05UaTRXaXR1cTRpUnFkT1NoVFNIYVJFS0xpUE9uZXpRU0ptcjUrOE1adTlGekpDSmJPek5hU3ZjWnpyT1hNMERTODRQaDdWcktiRjB6S29yUmc0aHBBOXZIYmpHcmlhekxrUCtDS0I4dk8wTDc4WFRIaDhvdkdVQ3hydjNPN0twNEEyQUt3WUk2UWNkUzVGbm1MM3JINnZNMUxndWpYaEN2cDRMUFc5cHFLUWpjZlA1YWozWHpVYWJlbDhyZlQwVnM1OVZGZVd2RnMweVd3NUdCbFQvb2YvOE90WDFxUTlJT25iMzJMalV2N1NxeWNUWHU5THdZSzdNNlB5YXNaZms3VERQMUFFUldZalhQcUlFYnF4RVJuMGdtZWFsUE41Q2QzNE5LN1lqWjhsRGZ2ajhCbHpvd1V3aHVrU0pMb3RxMlZRTlFYb0hsMmZhMkFsTGdjMHJtTEI0ajdtM253SG5kUGhXelUvVzNNNU95RktzUVRiZ0E4encwQzJacytWK0hGUWEwMWo1SzRmSGk2azVzY2UrR1BEaENKTE0yODZLeUlJbzFiL1JCNFBUS3FHalZVMFdpVlpoY1ZYSkxMeUhmaHZzeURiZXZHNXg0a3Y3M3J5TVZrVTZtS1dqVEt3bXMzY0FBbmQ2K0ZLcWtWd2V0L1M4VGljeVEvTkcvYXZncUduYU9QbWtiSFRIeURPb3ZueExVdis0L2xKbGlpZ0xTWTl1L0lZbU5qOEYxZENGendFN3VoV2dQU0d6Q2pzVW5qRHM5SnJQM25vNTFaZjA4WU5GWEtPN3ROVy9XZlN6TjhmY1Q1WDF0SDFVYVp6UnIyRGJadkhIOXVNT2ErclVUYjIxZmZSMmdKUE56YXlEU2hUOU9pc3FMVDJramNrQUdydExia3I0dUN4S1hqVC9DTE9ONGhWK3BzeCtITisxeEoyVnF2VVhVT1RBMUttRUhJdjg4KzlmNGEreWpveXhWcnFhWG44ZnNmM0pLTXVyZzdjWjBmQjFYQVo4SVBNWEFkTG1PZWt0a05zYW5YNnQvTG42cDhkblQrMHlJaU12dTM1R3U0eWl5VXVEODNvcDZBMXZyTkFoczVobEl5SXlSdlNhSjJ2a2Z0cjlhdmxMeC8xM1BWMVNjMmtsenRDZE9MTzlEa0xJTlVRMGhxV0ZzMUJvcUc0NGJFV2tkSGcvUXJwYlZwbG1HVXE4OWRWUzFJODQwOThJZlIyKzh2R2FWVHNhb1AyMWwvNGNNME91NUN3am56dmpDUGs0cmxqUEdVU3JzdG1FZ0kydzEwRkp4T0JFRHpIMXkydy9hVkwzSmNFNnpOMVByMURhUGd0SHd0cW56T0RuNGZmUDVoNTVIeTJ5MzduZFNYL21ycS85ZHJBM3RNWVByWjI1RHp1NnIySGxsNU9ycDJ3dlBySXB1Tm93MzhUUlJMZXl2ZTdXMHRuS2cxeUZ1Y0Exd3ExOFZycEltVDNjY095TUxpT0FSeHBtL0lveXZUd3J5NkpxY09qcHVEcWZ4MDNNMHJjUjFpRzlhNWVVekVQcVVPK0trR2wwNkxQRFQ2MFZJcllHZFlHMHZGK1B0ODl1TGYvSWdVay9Vd254OTdnSWNpa3p1bTVSOTQ4dWpFS0ZaQ2YrakRwVVJQeXltZW5JVGJBTUlNSHc1dldiTVBNV3p0TUJKemM2K2t5RVNsRG5GRU5MYm9kOHdJTFFNMDQrZW15dE1OVG8weE9acDM1Q05yb1QyMU1IV2ZMckFmaGVNcXF3UDVXT01YT3daY0VGdy9EblBIclQ5cVFmWVUzZDlpYnlIY2ZwekRxdjNEUVlsVDB5anU4OFRzK1FOeWlqL2h4aUpVcDNMNE5sVGI2OVhaM0tTbjBXZGF3OG0xQ01NTTMyYS9FOWRmRHFwaTIyNVM5NXlDY3dxMWRML2NkWERvK3Z2ZkVUdUs1dHJaSnQ3WHpVblNPV0FLa2ZJZVI5V0xrOUs3OHlBT1VaalJkSzB2UXFzKythaHozM0UwM0RMZlV6WFk3UG9vQmhVUm1SOU5sSXc3Rkd2b1lQOHF5QmVYdmNZVUpYTFMyWnNUWXN3NTVJUk5aWWVwZzhYcGFYUHB2UENkdFM5V3V2djl2N2tYMC8weGtmYSs4TjJtSlh0RTlmajk0VzcxYm80OXlEM3NlSmxpK0xMTHA3VGNDYnFLOVZUMksxZHpxNFhDQkw0U0M3aEs3OXVZRThtZjFMM2hSazZQYzhDNkRhNjZBNDF3Um05WGEweHQrSnZCYzMwRkRXejk2MHVKRURqV0NRdmJWSUpYcU9MS2pTN0J5dGhDR0xKQjhPTzl6SCszMXRaSDVxc29GMFZwSEp1TmJTM2FlTExjWFYwdUNqNGM2T28xcjA0NC9EbDFLdDFoWXluM0hvUUxCa1hJMzNNTWw5ZThBZndJZUV2ZkZvbWhkWlZLb29LWHo1ZmYyRnVneTNWOC9hOUQycjBtZVd0UXBrZm16M09YMnhLd3UxWGxDcHc5c3kvSWNKK1pHdU5HcjFPZ25aZWptMXpZelpNMnR3UmVveVdxWlJWcGRac216ZUdVUnRJako1ckR4V3ZpQ1dIL0duL1o1dVJQNDVyVncycWVsbWhyL0VlQmVWR1BWOTNsMkpYOW5xWHRsWHR2RkEyZUtyd3RJRTd1MkpMOSswU3gxenJDNDVxWFhDeXI0WGx1M1g0aVZXUDBkdFh6TFN0OHBHNUMzQ2QzWmU2YlNtUVJicHFDbHNOYkdYNTFGR0Z0ZnU4aGZvMXNQTElXWC9aM1JFcWF5ZVlFTyswT2k2MXRJeUplRTNqclptMU84NkUyOXpZYVJ2SXJ0bXRpWDZ6VlZFYXJuZTBkUFhYKytSS3ltNS9qa3V1YTI4K3RnNWh1YVVrdTlGZUY2MEo0TVFjZzMxa2xUYTREcGVYcHRyMCtwNjkzSnFKVnQ3TVhTdnQ1UkFEVWM5bDVUTUw3RzdMNmM2WmF0ZkxlMVVjdDdYV25kbEtPbGNFQVV0dzFIMzVBUjNta3pBVzRwWjZVSU9kN0JzTDE0dUJJb1JUc2pYY3VJekRXZitIdFkwOW5JSUwxTmtQNjVOeGxjV3ZWL1luTlB5N1hXaWxtTkx1Yi9lZkpwai92cUxwMDM1SFRvMUszLzlYdjIyNmI5cXJDWkg3OC9YM1dZenp6NWZPZVMxcm85cjd1TmY4aXJlUktPR1ZKYU83a1ZvWlZ2NTVONVJidFFqSjd0dUxaQVZnNWF1SmVNQ2VoWkNWcnFTamsydnBTWHZUOTNYTWRNWG03NDNCTDFkN3phOTlFaWEzdVVOV3YrV2R1NWRjaU5hbkNyalFYUXVSQWNkSW9QY0Z1U1JuYm8vV2U5bC9nUlVRMFgwZjhTaklRVENXOHdBZWl2cW9TZWdDTTNHdGRKOTdOeUkrblJrR2NmbjRMOUVWOHRhZXI2WVNvYlpCdWpIT2diQm02c25yUFhNaDN3bzdPQ1A0eXk5ZHY3UWtUdDRaMnJ3UjVtSW84azVKVEQ2aWs1N0dHK1Q4cmJjb1lLZk9OYWVjMGpUaWF0MHBGV1dSbThkL0MwSys0SHh5RVBlWG1ZTnJvaWMwZnMwOHN2dWhXemVsWk5yWm4rZnJHRzFqY1V5cTh5Ui9HTmw0ODkvSXJyaFV4VDRuZWZLamV0V1lwRlBOYll6VTlmZG4yVXhyOTJIV21uN29uZnM2ZVhXSTN6THRxR1BWWHA5bEFtOU4wbk11eUwzSDF1QUhneDVjdVhnK3ZLQmZRbXg5bDYxQlhPeUYwMEllU1BRTDZmMjZLZlNrZWFLM1p0ZVdkUEtzSDZwUWI2SDNrRjJ0U0hYeXVmNEplVEJmWjVwSEo3SE5CL2Z4OG9zdzg5K2NObkgrUGIxeXJLMUhOYTF1dVg1NTlETGxKNnZmZmFoNThzZGVmQjRtUTc1V1hWMEh5SzJKK2k5MkhvT1ovNll3aXVycDgwOXVKZEV2b0NaQzk3ZVJ5SW5zV0pkSDBtMzhXbGFaWVgySmVTVDhYVEd0bGNKdlp4S3lCdHkxcTlISlI4OWRXWS9XS0NlbVVidlRvVG1YL0hGMUhlbjlkcnhvcjBWYlU1bklMMUdCdEpNb3pVeld2RmJYRGJDTlpINUVWWEdEQkpTdFRPMzBNaGtUcDBBSDhLTUp4aGdudXhjUzNGU04vWnMvc3ozbFJEcHMwdEY3anp2L2pua2NZOWRpblI4MGNzZWZyQ0RHR0JVaGxkbVhaWmhWWDZLTE1mcllzbUtsT21oL1RMSGFwZmp3OEpqU2VjcFJiUTFia0ZQNWJ4dXRJNnpHU256SGNqR0hOcitlRTdmV3NNakQyL0RGYW4rOXZTZFZvZThrM0w4Z1VIYXhWdVNwVVE5WEorL1BtYzZPMWM2VmtyWmlDTmgvT0RoTjI3a1B1NjBRbGhVbDl5T3E3KzAwcXZhamw5YVBjNERYOWIrL3IyNnhLeHZqOTVCbUxISmdON0ppTDh4eXN6VmRxLytXYUczUUpuQXhNajFwNUhNK1BUOG9rQ3ViV2tWM3NXejZQcUwzc3JVTnorQkZDb2trSDVYbUFnZitibUFWcGVXLzRIT2Y4U1hRZnlSaWRTZnFUcjBuNUduMWNUb3NnNTFpQ1kzd2E2WHhYVGFyc09tdjJxUDU4Z1JzZzUxV0h5ZlV6amw1ZmZJZkIydHo0aVZSK3luWmFmUi9HaDVjbjhEblV3dGVaSDB5U3hiK21iSHI1SmE2NlY4a0llcWtvMi9SRm5lVjF0YjNNbHpKNFIwWXF4QkxZMFgxVGsvWVVXL2xqLytjbmV2UktWS3c0ZDR4Zy82RWVoWDRhZCtQTjNiODdUU3RjaWdDTlFVZVBFbGtKYXNvM2U1NThsRTNDOUVqblpOeDRLUVFTWk9KbWY1bE9VZVdnYnlUcUxubVkvMy9DZ1p6NmhHcEsvZW5kMEx5WWN5LzdTUDdVWmdiWmdiYTNCWjF0R044SnlZL2JYL0RQNTQvZnVWVnR5Rk9hNnNzeEd1RVIzWTF2NXJUNDlIVjk5V2l5Q09wdHh2eFZySHAxVVh0QWNIR1psczZONnZWVVlHWkMrK2ZUS0FyUXIzOFRQOFpCUlpadXN4eWcyWWZmc2VyY2N4VVZXZ3BXOU4yNUxhdHN2S2g5YURHS0R6a2pyM0xmSG1iV1JmVHU0amFqOHAwRjVPUmJ3b1FvWkE5NEpsZWhFblhZT0lxNERZU004dC9uaWlUbzNuUjVKTGthdGZ2cGo2cWRUN0dSZFB3aHRVWVM3S0RhMWFtNVpKYWNoRmpPeUxrbzlFODJXanptdU1uTlpwcUFXODFjcnp5blo5aHo1OUQrdi9WbXE1NXdjcjNnMUcwNzh0MFNkWGxvWkc4MnRsdGVwUVFGbDlIZFI2Y0g1TWE4dm80K3JISXpjczI1MlhNKzdqVHBQNW1qR3cvVGgzcHJXTXpDVXZEenJyVWRsenJXN1BGdW5xZE5HMHMrU3R1SThaK1JiSVZQMklvQ05SalBCS0hEU0hjcU1NcXlaVGZyM2VtLzVNdlQyU1RxNGh2TlVwaXZmekFlWHBaTkhxOHBtUFdwYXN5SVhBSG8rVmtCaG5ydTl2OUZBRHdOS0FWM280aEpCcmVKZGRlRlJ2elYxTGcrbmUxQ1ZjcHNmZjdOSE94eks3ZzVIK1hMMFZRUWh4T0c5eWxRc25jay9aNlBPalB0TlZBcUg5NmRwQ3lsRldmbHdQTFZHOS9mYnRoZGg4ZUo3d2V4MXAwV0pJMTd4QWF4Y0pkVUJhZTRMdnhzcDdPTk9wTzZHTU8vbW5jbDdTYjc0M3djZE5VSjZJckVpWk54eExrV2ZOSzh2c2hVdGJRdTVQNUZHN2xsYjlsVjNoM0NmdkI3ZmJUbURXejFFK2FVbDZNalBIdWZ5bE5WOU0vUlN5RXpkeEZGbEZ0ZGI3MW1rWHQxRGlWcVZhbGRSTytVanBkZnFIOFJSWGZoMGg2Y2xvM040VmR1RDVYTkRteHZRMjQ2MXdhWkNMRWk3TDZMdk5XWjRYNnNsNXRUV1VhbEhLR1BvQ1VnTEx6OEh3bGl3djNKS2RqZkJrcEdzWW1tZVdhTjFHUmhrcXMreEM4ZG5Ua2kzellmZnh0dXJhOCtsR212U2JLZktQOG5ocDRzL2YxaHUvbzdxMUpQMkptZU40Q2duN1ZOdmo1YVBPS0tETVd0YVZQNHJRaWE0b2tKaytlYUhVSktmbUR1MzJSOC9uMHFDMDc2NFFuUHZkVGFYZisxM2hSa1JFdEh5N0VTeS8wZTVsOUNmSEs4WklWUGFLdXFDNjQyMjlBd2V4R1dHbUtiWjdKWUtPcDZBKzdBOHd5Vnd2T1R2MjUvbmxncjdSZmc1WGpDVndBMHYxUCtyd1d0WW9EUzI0K1ZsRnBFTy9vTnJDR2NjbVVrWEk4QUhjOVgweHdyZjBtb3NnbDg1YmZOa25zYjUraHQ3bWxBKzVud0s2VVBMV3lkbUpIK0VkOXlKazNwTHMrdmJXTFFObDdtWElWWTc4a2E2TTMzN1dhLzJZdDdZN1docTVZdHVIN2R2eStOVldRc2hIb3FzbjJJdUs3bTYwS0ZIVnIvZ1FxcHpHemRUK1JmRmRkek5OMDhkeE9Id3BOaDlkeXgwRGl2bnBaMmtSdFd6TG5mYmNESzl3Y2k2b1c3a1JjU016SUhQRXBkWGtvWFVnaEN4aVAzR2Y2d1c1VDlkNlJwQTFtZWVzT0t6blJQVnozdGdYVi9mdFVUcktmc1VuVjRZbDl5ZGY1UVExVzdUYTFyTDJMZTB2cDdiMzY4cHUxWHBjdDc1aW95K24xbVhMMG85N2czVWQ2anE5MXJsUzh2NStMUmRJQisyeGxqR0x5bzN1UjFnT3RKUVhNZjVlMm1qL2VnN29ZbWFwb0R3WWo2WWhuNHRVNEwzYnJkcTB2OEhZaXU0eGJLQzNxZVZGaVc1RmJIOXJkYlc2S3puaGxnYWxXcGdJYW41bkRpNHlqS1VhdFhRMXB1b0VIZS82bVdTOWwxYUhXME9HdzRWTUJ6VlVDNHRHbjd6VythSnE5K01ZY1dySWp1WStoMGluZ1RhdDVqN3p4ZFIzdzlJc25HRHJNUmFlMllpcUozWmthNHA4SU94Z2t2eUZuNll6a25IOW50UWI0K0tPUnA0bGZCWE9EcWo4UlE3NVRKQ1ZBNGRCakdlYklsN2R6RUtsYkt1TTNyS0xXd083eEhjWVJMTW13b3IrVGNwUUtuYTZWbnl6Z0JWcDc4b1o5enUzbmJTUk5hT0V1TXdyamNiS2NkMHI4OXVNWkltbkNRK1o2TFprSzRuMjQ2N2pUNlVzM1htUDNrV2ZkTXgwNnRBZlgvV1VqVDdhS0VZWlJ2NkQvN1dRRDNzNk04TWlvdHZMMzZZeDcwRmozcHpPR2ZXNDAvMk80ODA1UWdoWmhlYnhJZW5OWjVZTjlXeEZSZjJJRWQwNHpXZnh6RkErejJVbE42RXNqdS9KTzB2bWg2MkxDSGxIeWpRbGNvNWhzdXBibEwvMGVGMGU1a2UwNzYvL0NZRGNXd1JrbFNwdlZmbm5JWDBkdjZ4SHhvSzZKNnFrMHd1MXd2Vzl3ZnJGMlAzaFRWZnc3Z2JMMlJNbGhLeGoxRFRlYVByS0YxVWk2L3dJRWRrem1vWGE4VXRnSjEvS3JGOW5SSDkraWg1a1I4aXRjSmJXa1Y5V3JPS3JWS3JuS0FUVzNOOU8vNTVKWDdxNlMvaGlLaGxtWlBzMEEybW1ZMjBNSWs4eVMxdWtqRCtjMHVzVVNUNEVxNE85WC94dGFUZ3dqbmlUQnAzWEFWQS9CcTFTSFpZYWVhN1htZDZEQ2krZlJ1TWxyK0xsUmVMcmxpbDJXU0haTTF1NTkrZStJdC8yQ1p6Y0dBbmRMNmVpZGRLUWJZek9pcUttdGsrVzdTRTJhOTdHUG5PQkZTUmpTVXFWOXFBSzVYeFU4ditFbzA2QVdyaHhyY3Q0bGRRZXNhMDVKUjlxNERJUXA4YVdGazhmU2Rjemc3VSs2SldWOW1xdWQ3NHUrVVRacUtQWjB5N2VLSnZVMWxaMDhVdktTdHBXK2dnWkRMY3RaeGJwVnM2MXU0UGVEOXB6SzZ6K25UeUp6cm8wMXFpejdxNzFoVlhQaTd3blBiWmZTeE5aVDBtUWhYQjBmZWVCYm5BbzBWbEdaMXVFSnE3bGpyUzZvUmpobGl5a0xwNXNSVTdVbXlvZHk5bm5zbkJVRlphWFBMY3VNQ3YwOUtyTkl0VHV0QWFmMDdqaHVBaTlleEV5YjJTdDBqTjV2SDJjN0VpU2V3dDdKV1BYVEs4cjBqUDVVTlkrUmMrWFU2T2UyNTI4RGtJK2t0WWtHM2FJMDc0SVlXOTMyK1lBbW5hM25sa21KM3huOHh0NVM1VzJEdGV1VFQraW94MU5INmNjMCsyaWpmam1mV3IrWWsvZlcrMlVFM2tIempLNGlMdGxrVUdaaEpBQlloUHp1ZmUxQlppMnBtSDg1VkpUK0E5Ly90cS9RTGlWZWQwS1lVVWR2QytuSWhKZS84ZnFsaXRINHJCL1dlcitMVWFKbWhQeHlKeVFrU1Q3dFFBcFh6bTBtSHFOV2tUWVVRSm1OSTdQTHF6OEkwWnQ1dDZSM09mdzluSFEvVmhOZmc3azZ3SGRtTHlJM3EyamFCZVFhMEZObytlcm9vODBabXlhQlI5cFhJVjIyeVhOcTFvT3l1NnBBN0svbXBSNnRaYm9jc2g0Ty8vYU1LQmFFYUR6Q3RYUGJPQkxpRzRodE9Ta29LeXM5UG51OXpsNXZBeENmb2dPSG1TdnJFNWJHYUNjWXlLdGRFaFZQYmNZRGY4b1pqbzlaRHFJZjhVWFV3bFpRSzBiYStlUFR0V1hNK0p0a0xkamhZLzBXY1Bqb1IybnJKRHBrWkk1dk8wY28rMVl5T2hXdGZmRW93NUhkZG1NSjNLbGNhV2xudkRyd2U2OGFQcWVPbm1QTmpxUkN3QnRZZUN4NUJqQlVaa3oyeGlOZDhEZVc3Z3Q2TnpydTYxUE13NnpkY0ZNdlRaVHhpd0NkVms4VFEvaVN1bWZxc3J2OUs1bjFKWWdSZ0wxSjd3eU5sbG5LY3Vxck4zdFRhcURKMmJsYlE3ZXd1b2VtRDFIeXBuRDVsWHFGWVVTTW9VVlh2Tm9la0xJNTRKc05hQmVadFRtSTJja3p0UlhzMWFGM1hXYThpeWpxZ1JkbmZ0enh3RnNwYmRlcHVZNEkyUUNzWWxaUmllODNDckt2dXdyWDBoTkMrc3dMck5VL3dkei9ObTd6TnArMWl0ZUthSzYzUGIwclJjLzVTTU5XMUgva1pXTm1CUUszNWM5Wmhvc3cxUEhmNlB4dWNOOTAraVRFNG1hdXV6RVIrT1FlS3NPWHBrM21Vcm9VOHpSWlVZMjB2Yjh2SUVRY2o2elZXV283S0s4ZkFyc0ZSSnlPN2lIUmdnRTRrYnp4ZFIzbzBmeExWb2g3RGZMOEFXUkZ6ZEVxMUxXQXROYmVTRUwxS3FzM1cvUWk1ODFDaGQ4YjRoM0doYzdGRWM3dXFzT1QwWjRSeHRiS2lBNVJjcXdrVzVHeXBoUDFOQVVSMVpKYml0bWJ6Y3k2ZmwyZGZDMjRTenQyWHVtVzgvNU5qa29vK2pKcmJUTnJuaGtQdVZGSjZ1dGkzclZkNEl1MkdhZ1RNVGszOWIrZWxPd1RrTzdnL1BUNFhKZU5YWWhpaVpBalhBS2pZUnZzVm05THFEZWNseGJTTWJuTXVoSWxFYUFmRWZJbElQcTd5djZabVdaQVFXV0QzK282WjZTUlBwU3JCL3piT250ZE1jVDI5dldJaC8rNm0rN2MrMVNiMm5SKzN3WEhlTnROdHpKQUR0bEk2Nzg4L3IzU1ZML0d1VlZsNE9GK24vWjlSejd1WmFiTEpCa0dkN2paK0xTWStFV014N3haekJ1dDJPVjVtS05qS3FzblgrbFBhMFVXWk1oc2s3bjdla2xSNVoxamVEVk0rbWFJdHJ5MGhYWTVjL3A4SFh3clhucnZJY3ExdDJUYksyVjZyS25xVEN2MHdxUTFzTzhvNGxzclIwWnNESS9Rc3hiYjljaHBYYWR0THdvYUw5RzYzMXNZL3V1cE03WHJ6Y0pJM3NSMWsrRHZTK2xJbnNOM2pVaDVDVEFpZWZOMy9yZnB5YlViSG9qSE1IY1ViTDhDQ1BjY3ROa0hXVVpMZitqK2JYU0tFWWVXUWUzL3hyeGg2K3llbVkwNjhHSHNyUUJzY0l0SjMxRURTN2lUczNHY25HOWRUMGg1SHhhdWg5SlZ4T2V4L01VbFBXMVVrOWxadkJabExZbXk0MzBTTmt1aWlNaTl5Vi9vOFhMcVZxbHhHMTZYMUt0TTd5NlBLdWk2K3RTcFR2dXJscHIwNzhNcVZvT3RGWDM5MmU1U0ZhNUdIN2I5YWRISGNUb0hKTE8zUmFHckJUUU10cjlmVHVEYnpVRDJzU1d6K09WaDZRbDc0MW5KS3owM2xpVE1tK3dUaHUzNGhpNVVYYmRET0ZuR2tLV0YxNkhXV1ZGdFRJWjRFM01EVGtIYlIrdmZ2bFVlem4xcnkyUGtCWDF4Z2g1MG1zRWtEVjNBdUlDOUs0cVdqSzg4SzhoTzlkZkN2THMyY3FEeWs1S0dWcjRuMy81WXVxN0V0RXdKNjFXME8ycVV5cXhRdUdBY2xlM3crVnRUT0o0MnBpczR5WWJSam1RcHRZaEh6dEUxRWJKZXJyYmN1WGd1c0hBZm5OSzhOb0t1eHgwMXdaTlQvWTBqM0tic2R4dnpXVnBEWEozSGV3VGxlbWkrQXkyeEc1aFVQcEV3Ny9VdktMWHpsejFJR1g1YVhwK0hQSDdJeFF6dG5sdHo5NVkyMTF2bDJiL2tHUlcrcXNvZzlkbjRwVGQyc0E0M01ib2ZRVHlsK05jNnBFODUwc05aMWpMM3JtQ2JncGFxODBaYTRxZ1Q3VDVWL2s3MWpObjdKVzI5aERrQTRqVWlFZkNDYmtMczdUWDY2ZTlrVkdmVlZsb21WN1luYndJUW9pUGZDUjVpK2VrSGFpdWY2WHVJczh1ZW4zM0VTN3p6SE5uUG5JL1JyY3ZSZ1pBcnlQQlFVY0lVWm1uSE95dnM4YnkyVDlrTEIyeUIxSDJOODJESzRON29lWHdiS0RkRHQ1T2plNVhjaWNIWTlhK1p3LzhEVWVUbGMzRHByODN3Y2NJcGd4azhkMnJLdVVDL3lLdTF1ZzMrT24xRXFnaUNOa3o4bk1sK1pJcUlaK0U5Mno5TEw1NmFrWDNTcjljRHlIUG5udGt0TUpiYWZoaTZxY3c4bnI5UkxiRmlUWGZUNmxlSG93dlFKenpkRGs3L1dFZDhNWHR3Zy9ENnVnRWhwTVhWbHNoeDJ5Vk5EVEpldWVycklLRjlyTmdTOFdjb3l2UUFkdHFkQzNQb3lXMEc0WmZtUnFaTEVoOW84eit0UUxxSlF0TFd3Q0R0T1JMcWM5Q2t0N3ZkZnpyQVp6MUU4NVhqMXluQk4vS0hzdVZzTHlXYVZJanZ1Zm9uRzlCdnB6NjAxWWwwRGFlZmlzcC9uSnFlMDY5dXZXVnJpaXk5ZERjbklPdm9ZTGFnc2lzNnYxQitCa0RkZENSMk0ydGpPbGtzMGlrTGkxUDRzMG50dVdteUdSeTJ0Wi9sTjAvV0xHbFhaMVduRGZMUFRrb3VUR3ZmOHVJbG5JWHE0aU8yenVNNzJpYjliUnhhMzdYQkdScXRxN3BaenpHMUNOUFBsenJ4VHkveGdTNHB5M1BjbGRHeDN6dVowYi9Sc1p6emVqOHRWYWJpSVphZ1BlVUVuR2Z0SFRlY2tzcnc3TXJQWU5MZFBNMnhRNUZBWFBoRC8rS3VhTk5FTlBkS1B1azRRZkVnWGs3emt6aDZHQVk2WGkwdm1Vdy80eThpL1lpbm1FYW8vRTIyWm44TXI0WTZmWWh2N1BvdGNiS3BuU2RmYnYwMzUzUHFJVWdoRXhBMm5vbE9pWGJ6VURYaDZPNjVFZHJXMzVFNVVQc3lxeHR2dUZIUEc5ZlZNd01GemU4eEovd3RxZEdaUFc2RWRsSTUvbWY1QjcwYmpFZ2hycFhObG9tSVVTd2NyL09tZEFIbTdqZlExczdmK2V0U3J6blJxOTBWb245enpSeUZYN1cyaWVzcHNYdFBmMHBJTk0rVFRuRTk2Ny83R2Z5V2pyZE9jbEs2dC93bVFQWDIrc1d6bXRvcjZFRXkvVHdlcVBWTGtoOTYyc3JuU1gzUkdjZ29scWl0eld5M1VWLzZIcWlVd3YxbTJXODlhaWpUait5UHJ6eFdQSTA1Z2FxY2J5eVJtaHBiVTg3VzkxbmFVeHZ5VTMxMEFGcVhpNHdRNlNmZWF1RFNxYjFtd0FyUFJoUGlJazNpQ3dqSU5acU12bVdWTnNXWGprdUxWZW1sZjZyV0tHNHZwd3p4dEJmaVJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUlEOG4vLytEM3FYK085LytBN3JXM0tETjhXUk4vcFByYVpYR0hwZ255RjNkNzk1ZjBMd2pNT1p5QnN5NHpncThrdjBWS1lUcXRBNjZRdVJzK1ZGem9LTXh1T2wxMkhSY3pGNk9rVTVzMnlvejg2WVREMDlqaDRMR0IzUVJ0bEZTZk5NT3NQNGVYajNxOStuUEdYM1ZaTmpuVjRsb0cwcnk1Smx0TG0xbWthVVNCMmYwaGZiRzFCUHdVNHJrckNYL282MWJjWCs1T1VpNXRUMlYra2FSRm5FZnNzZzY1eFVyZTY5Wko3MjZkSTFLTDdCTHR6UjRNWnRRRlo0TzhGOGNsUHN1MWUvRDJ2TzlKMWFtNVU2UkNTQS9zWVNvbmZjcjYvaTNrQlBIZXAwdldXZ3NwTlJ4bURabHFrcnh6L1huTENhWDErUEFMQXNmVitkb3JyUkczTTl0VUg5aTZDdTNNWDFBdnBWWnI2T3ZITTdlQzlyNnNCTlhhcWhnT2s4bWRxVThmWWxMUnNJclhaeld2UUYxWjdPaWZvUk10MElaL2hUbXVQWVl3dXRkQllSSGVLMU1hb3JMYm12dE5wWFRldndkQ2dCMll2WXIydCs0MlVzYnZ2c3RWazdYa3VMcGllRTNCZlVlMExYcnlXaVJJcFRCMGM5MTJYSnNuUEQvNUI1dGZpTm1mN0VvV3hIOGJaT3lUK2t0ZUtqcG8zY2k2Z1B2NEV1LzJaTWZGbUc1MmdRUWh4V3JBdURSVjlnTzdKWVQ3WFRqdTNTZXVzbmI5ZXFiWS8zS2FiMFhzNXEyVC9YbGFQeXMxKzVlNzdXVnY1YjJyK2UxL3QwMnBvVHJyTFpuOGUxN2I2R3haUWw0L1B6T3lmb1NqakNxSUdNN1BkNEk5V3JRNlFzcEl5Um5uOVRaalUxZVU5bW10MVIzOTFXam5iZUc0SGVQaUtuQnJuOTZHN3pxQi9Sc3k5TEZiS0Ezbld3RmtlV01lcnB1UEtkZmI0NlRSUU9FM0lhZ2NIbVBTZWNWWVdlZWZ1MnJOcGtJQWNzUHlxbHVYNWtxNXY0dGlraGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0lIZ0YxTS9sU2xIdzQwWGlSdzJkRHJSSTNRMGxOZksxWk9CVHlpYVhNek1ZekhZc1Q2UjA1Y1dFejN3MkJzcVBlYzIzbnZJSUdkdlZPSHl1UFdkcUo1am82MjZSRUdQQUl2V2NlQ010NjVqNUwweXZmQ0liQzljcHpUbFl5bWp6RGpyOURRaVNzSTdOWDFHdDM4eUxZVnR0cDAzZjFHQldocU1BbmJzL2JwNXRuY2JQWXN6QmRKUG91a1VpUHFYVmFkUWV5c09MdzFTRnFLNFppQVdZNFo3RVpEMm16Zk5aQy8xcFRHc2s4MWJrdVRKN08rc3ZsRWZ5TXA3bHp2M1BJbGt4Szgra3c0c0dsWU52M090S01FL1daMHFoTDVPbkxkLzlDK256bDBXUm81b2JKWGU0MkJGeHpIcW1FUnBHaVlqYlc5WkFHZ0hvMVhkMGtaZGc1VEdYRG90VDVrOWZoMWhtN3hCZFJOYW90L1NNRVhQVVovcEE0M2d5ZXJWSVFXOEhpbXJ6amVyREgzUzQxOVF6YWxkZzJLbVBjck1hdGt5SHJsN3pXdldha1FJZVFNTU5XYjV6OC80OHNxZTBrVnozL0NyWm56TkZQVWpRdXNGczdDdEVPZGFZcGtsTFQ3cUJwL2dQcE1PWnJrMlhyb0VwdThwR3gzZmhKRDVtSjhOVDlpaldCRWYrNXJwYTdLWEtjcGxuR3dvcEJuMVErODNQeHlKTXVCSS9Id1J0Zm1GMUdQdHRwcTkvbSt2VFhQVE9QU3RCTE81VHQ3L2RheFRMU09LN0cvRUVKMjlXWVNzdnFPeUpOWjllNDVsUkpZVjcrMHlkTEJ5TVlMNjRONGVNSDJlOXdUMWkxRVYyWktEVEJHazdEZGpWUk9mQmRxOU1qMVZ4RVJXUFhva2w5RG5WZnJ5ZGpxaldnNzkrUnQ5c29ONlR4eHk1RW5VaGM5WU5QS0VVcnVPTU9KZWN3NFlzR0dHaVc1YnRlUlk4RzFUUWdnaGhOeUFiL01jcjdqZmJ5bVRFRUlJSVlSOEN2UW15VWZCQWYwbG5OblJIRlNFRUVJSUlZUVFjaHU0UkNPRUVFSUlJWVFRUWdnaFg4amZpWHdXa1ZOZEI0dklqV0syZEdlZWVlYmlIWTFqdmZxTnZCSXU0bkwxV25uazFBU2t2VzdWcGtTZlh6T09lWW1lOXZHdDNLaU4wRlBIa3BPdTFwMGpKNmRjajNaSGtsbG5sclhLOHF5VnJJdVZ6cnVITFUvcjJwTUZXb25JOGZIUFk2cUtMc3NxNHlpb0VSL3JYKytFM09QSndMMW5CeFczUnVob3dFdFlDREpOSWdlbXRzSy9EVGx0M1VOOXF3d2w2bGdpNTI0aGprS2RMb3ZVY2c3MWQ3VDhNbU1rSjE1bVhjOFpnekVpNDR6QkQ5eFhNUytBcG95YzZZYmEzUlh0c3JLdE1kbFdUMGl6aXFuU1hNbTAybjVMWDBTdVd0WVducHZYTlZyWVZwdTVwK1RQTkJLb1lVTEdjU3Z0TEViMTBleCtDR3hHV0Q2czVSS1h0TytXaHNuWnZoaVFoWXo2Uk5UNitpQ2lRejBYdzBaazQ3TkxmYTRPV3JFKzZXYWZIUDZXYVpGeEwrdlExa2U2bk95azhmd1FwTHdnYUpFanJrNnJXN1Jycnk3Qm90WGVGZmR4bUZQYWZXWXh0NlFiOFRpcCtKQ3VpdCtWWVlWM3pOOXJpTnFNYU1jalpXS2V4Qnc3cSt2SW1KMnQwL2VVbFJ5WjN2M1g4ajJicHRmSjhwdXNyOVNVWksvaFhyNmRsVGJ2NnBxTnRkaXJ6RGhvTDEwNjFRZ2hPa0czMHRQU2x0OE40WmtHeDladnZvRG1LOVQxaXZnWEhqMGZPSk1mckR0WXdGRlRPTXRNay92UnU0enp4bENQL3l4bFdQbXRNZVc1V1lRUWtNQWFyUmpybzA3ZFVyTGlIQmh6T2JyLzI3UHlsTStGTkxlaU5PcDAzQU0veXRmeWFXV2p5aTM2cFZSc0ZWeDJkU3BLaWkzKzk5OTkrTEVzb0lNUDZFNmRaYWFPSmlLYlV2RXlaVm4vQ3RsZWoxdGhmbG43ZENuaGswd2JzU1ZoWldON0VlMDZTYVB1aldQUG1LUHhBL1EwYlN0dGRCaG82UmJjSnJtQTREclpmWnlocFpIVHZNZjRuUXhTUmQwQzJQbTgyKzNSZUo2V2p1NkFhL2V0ZGErbHpWUGdtZ1NnM3Ywb29xb3Zpd2xuYmFWbFkzejhjY1BOTkE2WXAwKyttbG0yL0xuMlBrYjkyRHBqSEkrTXpkZ2F2QzNqYSthSTF4RFdOWlVJak5lVUhraFQ4NHVwaEt5Q3lvNFFRc2dkeU45cWtHaUl5U0k0dEFoNVd6aDlDU0dFM0lGTDdOSFhQN1g2ZE9qbG5BZmJtaER5Sm55THVxSmFKb1FRUWdpWkRCMHNRZ2dodjF4cEVXaU5DQ0dFRUVMZWkveWYvLzRQZXVIMTczLzREdXRiWVIxemM4SnBRSzNUOHVyd2xQRHFURG5NeURvK3dEdW1SNmFUY2NnQmFFWlNyMGdySDNrejJJSHo4Q2JSaVZWQVR2WnFoYmRPOWtxTnRJanNlNENldDFhQUV4anpNMmxmV1lnbGlocUhWczlIejY3VDBpRTQ5eDArUnQrVGpjZ1lINDJ2bHJWUHpNWExqTjNYcmRVMTR0dWhSeWoxS0pXVC9NaExnZHV5Wjh6MWJwdjdaZmtuWkxmbmdYN2I3Uzh2V2w4Zk9oZFViNStKVXpaaUtnNk9oTFNCVWQwK29rTmIrV1JkemxZUzFSR01WWkQrdFphcWJrcDhYd3RZYzZTdkhYcVdwRnFkdGhUbEVGNkhlY2ZIcmVqSEsrYmx6REpYais4ZUE0ejZRTWJZaDh5U1VrWnJmOE1vY3Z1NmFmdkxCWDRiRjYyc0xhNjhwTWkwUFdVZDAydFMwVEUyWXl5dThpTVF3M1FEZWpmVHRQeW92NnpsbmNScmJvaUE3UkljTW5KT3FEYnc4TWNqcjBncnYyeG1mdW1zcXR1NFpud0l5NGFlQ3N1YU1hK3RkRWxKUDh1UGl0Z0FkTjVHQi9USVhrUjBFZHBUeDloOUZoSGVvNFY3ZXhkVlMxWSttWGVCQ2lMa001amhYbzJXMzFFMm92bnIrTlJJcDMwcE5GSWw2WThjZkFQand2cEM2cTR1bGt6TGg3ZjhqZ2ExTEcyckR0NUtRY1pTUGw0V1JLWkhyOUVnOXdaeDlkRGxmREprRVVJNmtldURCWTVFYXhzdnRmWnB6M051amlWdDdYTGNWMFprRlRPbVZsdTZiRjFGNnZ2dTFyTXJ1T1d5ck5Nam4rS0E1TjFtaXQwdTJTaTlIT0pmMG43ajlmUjFHdXRMcDBYTlZlZlVjMmpQM1BNdERJdTFBdlk4NHZiOVlnYllXMzJQN0dkOGdkR09ibWRwRkREZWswUHVTV1RQdms0L3d4UisyRmpSYmllaU1XVzZFVzFsZGRQTS9WZnZmbHZweUNJOEUwaHVBYnJWWU9vSVo5OXVoS2hYUllnN29MWDBLZUZHc0dFVWUyMWpVa1JxOFZhNkxlMVgyVHp2aHRGSHpUSWZPWUJPS1c5YkdobWZmTnVVa05WUTJSRkNTSU52VTVJMENvUVFRc2hsMEF3VFFnZ2g1S09nYzBNSUllUUcwQndSUWdnaHY5QW1FdExKbFpPSEU1Y1FRdTRNdFRRaGhCQkN5SHZ3ZHlLZlJRSGlvcWNKREtLOUtlMmRuQ092bDFTM0dOZlIwMnkxNE8zRUVCRVhQUkJLNWp1eDI4aE0wQk01a3BPTzNLSXRVUldSTytNanB4ZU4zOTZNa3hzanl0UFEvdTV4NlU1WjZySHFYdXNVTU53Nzk2TUVaS1JLRnBJdlFuN2NmOVYyYXJ2MGpEeFJqcGwrcnFPQlNiREszSzVMTTVmazF2YTJaNHJKdkwzVFFvczcyWjg4aGJxZDRPRThZcGlRVHJYUGhDemlwT05YcktmSDlGT2E5L25iblZ1UzU4MmZnYWZIcjY2VE1uZ2lwamJQcUw4M2NYdGxyMmpUNlAzV0M2N1hmV1ZONURabmhIdnhNcG1QMDhJRG4yZVJjK0JWZzFLbHFlUDNoYUplU0ZKUE1yZXNzR1h6Z20wYUFqVUc2THpzR2ZlamZwVjFIR0xQWE9tZHQ1WnQwUFJ4MjhjeGllcVUzY1pHek9nZnJKQ1lXMW5VcFZSbFdWOWJrbjJDVGxmOXJsLzJzd3lOM3hsekt3UHhtb3plVmFrMnJ0SDFRYzltV2NUd0dTSjY4Mm5MQXl1dEZpN2RKcVJPNEZUWnhybjgwbTh0UmkzU3FVczJMa3FIeXZDK3FOcW9ScVNVM1Q5VFpJWFRlM05Na3l2MWNFeEg5cVcxZEgvME9yS3ZFY1diUFBCSU44aU5FajE5aGtrc1RYc3N3L1V5VVkxcTFVZU9MRUtJd1JUYnNiQjgxQ2ZvRVAvVUZZb2ZzUzJQaTJXK0dzTHo0WTlIOGdMa1NVcWVPbDNXdzYzMENNVlJsZ1UwZ2M5Z1pNdGJwUDN4NlJycFhLam9Qd1BQcFdtTktXdmIxNHIzdGxJSUlRN3RmZG1KUmJ3NDJGWExxTDcycW43RnpLK2xyYTY4OVRHKzZrWDN3RnNjOTkxLzkrK3FYVUdSSGhXOHIxTnVmZnFwN08vQS8wcVUxVzkyWGZOdUpWc1VXY2Njci85clpmcjltSVFFRGV5THFvNGpGaUppUUJOUWw4anpoK2grUkhIS0hzRXovdDRleXdVY2grY3IzS3NtZWx2MGNkNGJ4eVoyYmN0cXNxTCtkbXFraitRNUFlODJaVnhXOG1sNVIyNHhhdHVSN3BScHZmUlVEUk5BbmJzb041MUwzMElCNHc5ZE03QnZoMzVOZGFVWFJUNFV6WGkxOXJ5dGEyTzVkTmdUVnJMMHVCRm9QQ3I3NCtlSWZBeXVoYWZVdTd3bEZWWlRweW84cFQ0WFhuWVh2NWhLVG9NNmdCQkNDTms0MFNybWI3WEE5RHdJSVlRUVFqNEZlbmJra3poMWljYkpRd2doaEp6UGhmYjNhN2VDQ1NHRUVFSUlJWVFRUWdnaGhId2UzUE1tNUMzSS8vbnYvd3B5RE1iZi8vQWQxcmRBbmp5Q0hLMTdRcEdSRTNDR2FGWEdNMHk5cHpDSk1uWmY5MGhZa2FlMUR6bUg2RmppQUpqSGhXMDRxMmhOYmEyN3JaWEhWWGtLdWRUSGtqNytMcS9yblNnUlhtYTJ5QlVUMERyKzBiTUtScnRZUlN5L3BiRkM5RE4zdFpnZWc0emw3YW45S1UyTE1OTUJveDM2UmY5RUcraGZSOC9NTWl1aGhDRk9QU0twZEpTTWZrM093anVUay93dzFDenZQb0dqanJMaUN6VFdmZnRwblVOZlJVV0l6aEZMVTBScVpYaFY1dlV4djNXQ2V5M2hOOFU2M25YY2pub0JxTTgzUTNZUXhQd29MdndySWozbjF5dFloQzl3NVZlMHBNL01HWXltRy9XVDM0ekRKNjVueWEzK251WFVMNWpHN2h4eHl0emRwbGhxSDBRSldkZG81U3R0Z3FXWGt3amY0cjUxTDZLT3MrSzlNaElZdnNYaGVrMzdvazVLTFkycDdVYlUzNmdwUnZpKzFMMVVqSmtycXhreUNTRVhNOUVPYjE5a2o1YnBwZE5rNXNNZmJYOERwV2U5NFBrNnJYeHVXY2ppdXk3N0RkM3VyNlRYcFlzdXlVYVhhcTJ4MWlPUEVCSWc3LzdwMnNoQ2wwRURYTEd0RWRuVmFzbWM4V1hWbzh4YUlwQmU3RnZ1aEVoQldaYmwzK0UrL3JnZm53M0hJaXZweXNBZW9iWSt6a3BQN3N1cy8ybzB4S24wdGZrTDZ6NmkrN3FXVEMwK09lbGJNcjBkZ0JQN0lycDExTE5sUkgvNnU0Z3E3SmFNS0RjYWV5TlRLVnJHU3FKTGxSRi80MGFhOFh0aEo3d0ZxRG0yQW5wK29tczl6dlcyMHF4d0RpVmkwdXR2R3NudUJzZStBUnRtR3Q0cWYvUVhCSC9nMjZhRUVFSUlJWVFRZ3NJRkx5RnZDNzhjUXdnaDVBbHRBaUdFRUVJSUlZUVFRZ2k1TWR5K0lvUVFRZ2doN3dwOVdUSWREaXBDYnMzZnYvL01PR2VGM0lMNnRXU3ZXeGQwZS8xMmRGSENMV1ljaU9RS1JsN2RydU1SQ2hhTm5zKzJyQjNJdWVSZ09EdThIL1NvbkltVHl5b1NPU1VDT1g4eG9yYlc2b3llOHkvcStKWkJFc2NyUFpNN3h5MDlxeURUalp5dkZyMnZudGFXUFcrMFJ6TmZsVzQzcUxMZVhvZkJrcE4vQkh4TGdFYXIzbjcrNHhmYnlqTjMya2tZR2VIelo4ZHRWRGFpTEM1endONFU2MnZOdjVIcHA2R0trYWU3RFdVWm5zYlhKTFFMZjgwMS94UnFYVU5tSlVUTzMxcENMZjJNd1hYbFFBNldyVG9GLy85SExzYzBCL05yamM4ZVcxaFg0bW9GNEkxMXk0Y1FlWjYzWHhxMzlCaS94dkdPaU9XU0tmR3ZwZXI5ZzZycFZNMDVvMFhnc29zN1poRHQwQ3ByMUlkQTYrQ2RtVHZXTnpyV2pnZkt6TGFlek9hTGw3MCsyclc0TnYzK0pETjh6S2xmU2hYTnN2MzUxMFA0dnlIaG8rTTVxcmU4dksweW9ydEpNdHhETlV6QnZIbWl6QzJidEhsQmNZaXE4RlRoQ0xsUlhvTVNWWTBQODFlMFplTGplbmV5c2RJMWg0L1RGcXpvTGMrY0x5Q3ZhdnpJK2hjWkNKWU5tR1VUV3ZTV0FmcFZVTDZvL3ZMQzVTVFVGcmh0aWxpYkpLV0dyZlJsNTlOWlpWams2di8xNnFjMDQvTWhYUjNhQnZVYlo4NG9RbTdKUmU2eWlsTVgxNFV4N0s0TXNMNWF1dHUvY1ZUNjArWnZ3U0w4b0tjcWVka3lmYzROV3VzQUs3ekhyK2dkQ2xhZGR2R082WG8yQzZiR3FhZnZRbXV1SUZzTVIrTWZLeWNGMG50bFIyU0M0NVNRendhZFJBVkxobENzbWp6V0pNVnpCc0tpZ1IwaXVWZHNvNm5HYmFYVDJoZC9xYTBzcnJjeTVWcXVRR1Z2ZWJTeXA5aFh1VWRTbFZxcWNmSDhPNy9xdEJkVERybGx1bnJGV0NySFNuYy90RlZ2VnROYjFHdlJZdFpIWG8wYWp4SHZ4eks0bHN5SVFhNWw5ZFJSMWdWTnYrVVpHYTBaTEFPdEN3RFMxSllvdVUxbk5SMzlsTS9DOG1FVEdLN0prdWxRSStoeHdkaUw3RUszWkNDYUpLcXRSc3JROG12eHplY05xYTBxa2xNV2FURDc4UUliL1hRaUhvdWJSZ2dyeGtUdCtYSnFMZmZuejJ4RzFVVVJnaE5kQUluTDUxNTRkck5NdzdOOWtnNlAvWDFBN1ZIUE11MkxRWm9yRyttOWxYVFAwbzFmVENYZkFiMFlRZ2doVDY0MENoZVd6Yy9FRVVJSUlZUVFRc2gzOG5YTFFhNS8xOE0ySm9TY0ROVU9JWVFRUWdnaEovSXREamdYR3N0aEV4TkNDQ0dFRUVMSXgvTjNJaVNJZkJPNmRZaG94MEVaWTlTRmx1UWZLZENxVE9kSlN0cDlJNGVJdGNMSm04TVRnK2FEVGlvMGZrSVZrUGpaMVJpWHQya3NlVnpoTElLdDVCWmRqSFE5cDFpaTRUT0l5dlpPL2F5akFkblFDNmt6RlZVQlkyZTFlYnpPSDJWdnBlOFQ0ZXNjajhZNC8zTXNsanRYRkMrdlJNdHFlZElGQ0k5VGpMb2dQcXQxZytWVzN1d2JEV1IxdmhyMVAzVE9DbWZuam0wM2NCOUsxbDJUZTIyT2xuTmkzaDZiaWM3ajkrdC9YMk8xdzFHNXEvTGNRYlpYZERtNG56M1dLS3krRUN4VldWYjJYelJkajYyTzZuYlV2NUJ4cldQcnJmWGc2THBnNFFaSWNZcU0rTWVqNC9PS2hYK3hvOHdzSW1ES3F1K09abVQ2L0VieTNySWhIb3p1UmRSaFZ0cFJ4blZPNjB1b3JmUXk5S2hFL0RyMWV4MTRHWEhaaEh3d2R4dm95TFpzUi9ic0pBaHBEc05zUlpweTkvVlVJY3A3VHV6SkcyYVNyRkNkckRaMFBtQlZGcnJIWkFLd1k1M200TGxiTTM3Zk1OL2RJT1ROT2RHUmNIUktXVmlYbFdZMnVsZGRRTVVWK2IxWldXejhjNlZEWDQ4Tnk2c3VxazR0MWYrYmhTcC9JWGx5STZmelc0SkQ2dCt2djJiMXV5ZHlGN2kzclJkdUJrOGY0U05HVWhwZXBHNWxjaDBrNkhQdXljNkJ0VERRaXFKZjh2bFl4aU03NlR4WnlPTFRVcEUzWXFXRzlOSkhtbVAyWTVOZURibEIxVEhJcUVtUFBKSWtTNWpwQVVYM0JwRTlzOTNQN2JnWFFhNWtRRCt0R3JibGdqTGZIdFNmSkQvMCtGbWpzbHRkd1JkVHY0bVJ2YU5PMFY2UnNXMnlqc3JNME54YUpUT1c1V2ZEc3NvclJWbjN2NlJkeUgxaGgvZHpRZHRGaTZ6VGovcElhMjQzZytIUlhXTkxhUlkvK1RQYkkxL29seUU1WHZZaGZ3cm1PWXU4KzBldDIrSDI3KytSSDhkMVpLU2o5L2ZoaXRZYTltZmM3a0wvOGpRMkhRTy9uQm9KTnd0TnMxNU9SWCtBcmVlTitmQjRXVE1HNFlqRnZUSFJPZE5sQzJjVlh1ZjdxVVNLMHhwbE5ZUDNaL2tScGNDMXQ5WnFLVERIcm1oaFcyWk9LMy9rRk9QRDdmQVMwTkhrMlNXd3pZdkltNHU2ai9GampTYTZsL24vaGZXOFhJcXVUTjVueEhscmx1anVrUXkzL1FpLzdBVGtROEpQd0hLakVHd2pzQStmaVNnekczVVljUUYrVEdFdE0xYWxuWnp1dW5TYmdGYkcxWXVRbWI1c0FtV2RNZWhRdHNrMGMyL0Zpa2YxVkhFbFJEbXViY3JEZi9xTnRVdHVhZCtJRGx5akwrbDFFWElCaHJLWU5jc3pVT1pqK1h2TVZCb3lXbVVhdGw5YWlKMzdaZmdkbmgvUmlwZjNkYmpQRkpNcDF6SUZlWUM5eTVBSStjVmFQMWpYV2w0a3ZxY3VXaHdoWDAzdjduQkhFWnVWUk5mZ1dhNUoxb09vSzJzZGhKY1J2Ni9XTTZtV0hIc2Y0MUdIVXBycHREeS82Y3BQcHYxV0U3WnVSOU5aZVkvM2E2K1hqLzNwSy80TXJiM3RNdGN5dXFMTllKckludW5xVGNIOUtCdVROenR0QUd0ZmRzYnRrYytpZDJwWlk2eW43SnN5KzVGR0V2RXpHRmtHUmNyQUxTRVpJdnBjTER2aDVOWmtNRUZrSHRmN2RJZVhVenZnVUNMZGdBUDN1V2RzeEkvWW0ralc0TlVycjFzaW5ZQ1ZTekt5WTJaVDg4WFViMkxoNU5SMFFYMWRnSHpMNkMya2RNYlYwYVdkamZyeXcvRUdmbVN5RUowM2FDOWtQUzRkekhOMVJhOTc2MjF2NVpqc1plTS9lbjkzR2xUQVNQQ1NoSDg1ZlA3OUgyOGhVZ2MwN1ljcVY5cU1PV3k3WmZMWGFjOWROS21oTFUyZVVsemZ5Q2NvTFdzd1VwWXR6OXJjMXlXY09lZnVyNys2eTR6WXZGdDhTbVNrRGlldEJOVTJMVVArUlZIK3d2UDBsaldQdVQ5b0dwMzdORmh4RnJkNTZZdTg2NWtudlpaeExpdDBwUlcvNnFjR3VhT3NhRG9yYjlhRGUza0h0Vk4yLy95OEQ3NkxEdDZEMm51R2pBS1daZTF2aHVqT083QXhld3RtK2JKWGFUWjBoWURtSDhuVGV2TFFUMUYyN09Mcm91eVVjVDcwdWdpNWdPREVpM3ArRzdtVlNDNS9COWZCbTErQytCZW92MkdXR2FqcnFNd3RQSFF1SFJVcjBYQ2Z5eVE4NzJnNlFvakRDWk91MHdCZmNhaWdMTE9vYWVhVzhRcHZYK3R4eFNuTGlpamhza3QxeU9YemlWMnU4MmhmR3UycW5VUGtxZDFzZXU1djVrOVl4MGZmdkR3cjI3eDNud1BiaTdpTTNvV09CSDN6amJ3WHMvc1BlZjVybFhuY0Vyd0ZFYTJ6NGhkK1d4b3ZQbkxkZ3laRFc2SlRGU3pBbXpOczlMY0dYaFdCQ2QvZ095bmttd0IvR29NTVc4OFd0dksxcnBHNDNsWEMyeEJkTC9UK2JJVmNDdmhpS252eG94aDhvTlphcjJVbnoxbmJaYzFLU0NaWFNsMGdiU2N0VkE5enJiUWVBNyt0SnU4QU83aVBDNVNNdHgvYXlsTlRxbi9QUC9SRGxsNlhPb1BJTHp5cVMrc284OE9EUGJTRldrdUc2QzRrMnRPdDdiSm8vWTEwVXdaR2RKVDFqTXA5SG04UHF4ajUrdEJsSEhzaVA2N2ZTQUgzT2hHdHZGcjhvTjk0THhvNnlkbzFlMzd1NFErYXp1d29hNGVsZitPTkxSK0l0MCtSM3ArNi9GN3VSMVIzSmlEOWloWndaSjV2OU4rVWdOMTF6SzkwTXc2U3AzeXBYWXZYcm9wYUIrdHVOVHYxWHZOMkl6SXY2enljR1AwRWxJdGpobjYvR3RDd0xYTGZJKzhGUjc2TXFuN3hxV3gvR0JYY010Wk1uYyt0ZkQrRkdkYzlST3VDK2gxbnkwS0krRmRCa1NuWjl0WWlXb1h4NVZFODNzclRNb1VqVStPdHNTM3JuaG4yYUlVek4ydEFqdWlwTzlsaGZYOG1HL1Y3K1U4V3RuSTQ4NjU3TlQ2OUkwSk9KcW82YXh6WEZYMXVDTzFHQ1prdTIzcTV2TXF3WkliazNnM1UvMHBpV2VUc01VRE5jYlo3VGVZd2EzbllTNCt1SVlUY0I2RUwwQytqamp6akNWWkpsZWVWcWNuRWQ4YmZZdzF6ZUdMM0UvQnFhLzNsMUZ6OXY5WFdlZmRYMlpXYUdqS0w4anhiU3plTDBaN3pXd0tYY1lkUms0M3J5T2l2aVd4VUV2Skc5RzV3YlpRT21jNHpyVThoK29oRHk1K1N2elBjZWxLejhKRkdNNTVjRFBwNGhkeUMzbTJNT244Q1pmQ2xWSElaMXRnTERuN1BEVG1zQzlONlYrT3JWd2xYUElML1VNemZpbFIvUjdhZHBmK0lBTDZZcXJtYzVOYTBKdXJreWJrVmRhc1JNdXBwM1JqcTFqY0FuWHZzeksvSDIxdGJQMFN1MU9CQW1ad2piUzZ4ZGUvcEUzcE84bHNPdFo3K0x4M3hQWGt1QjEwV0llbXNNWS9lZUFIVElFdkFtWTVFYVZ6ZG5abHQzNVAyU3BuZkNEcUh6aW9ybW1kTzNiUWZCTDNuQ0Z2UnhxUU4ySDdhVSthRDJTbnRQR2JSalRxNG4ybUVJNFRZSzhmYUREbXJiRjEycm10UW45L3lUOUQ4Q3hjMVp5eGJMRmZ4WnJ4Sk5XOEVXMnc5ZDJyaitmVll1UktoWjBUSVJYeVphZWoxRE4rRjBobFhOd1QxOFlkelpRZHpjQkh5M2loR0UzM1pNL0pTYVBTZ1hYOFhPNjU4ZkptL3ZKTWZrZFdBeDUwVWNmMWt4SE5xL1FTNmxvZnV2NkhQUFJPUWJwUnYzVnR4ajVKSjNIY2lIOG1xUnhxdDZ5OGgyclRJb3pzdERiVVRJZDlONzVkU3Q4T20rYklxZVFlNDVYWlRSanZtSFRjZkZvSHUwMFR6eVhTdHBnWmZUQ1Z2Q2ZvYitnbHZrMXMvWmJOTzdUbEZ3WHQ3Y05iK1lBR3Y2ekJOWHFvY3J0S3VJZzNlaDRLT05kSlB6N3hkREZwa2NXU2NwenVqSGxuUGpxSjFSNjA4OVhYZVp5dm93NVNSY0tNT1F5L0lvRHVuR1V5WEFGc3YyeTVhQiszK05hWFc2dTkyRzY0ZDMrMzcyNzZzc2oxd0RiVDhQZENlUmNyNGxHaHZYTVFXKytGRm1tb1h6V3hMT2RlY2RPYkQ1dFpjYXNzb2JyclhkV25tMDByTVNzN2ZtS1RXWXNiZ2k4cEEwbnR0N0UycUUraHV1bGJHMGZ1YTBiYXphZGVwVkZGWlpNbUdpRS81ZWx6MHRIeFU2cHIrdFBSVUV1R2ZUczhjaStSVjBtZWdMR08vNDlWYmUzL3FtWHN6bVVDVkRsYmw4ZkRxV2Niaks2MjJXZDNxWUVRNzVjVlk2VmdaamQxZEI5VGYwUHlQV1d5eUVYSW8ySXl2bHlyb2tqT0Q4Y2p5Q0czS29oZnhGTlBUSFY0ZEh2UEtlakFzOXkrTENCK3lrZDZ3WFRtMTRQVitUMTVyM1RzVGIwQmI2YjF3cnpQcWRONzZQd1ZrYWZYeU50eTl1bWdsWnpXVnZWNnlLQWVaOFY0dXUvejcwR050bGt3RFFraU1sbDFxcWMrV1NSQXlyUytseXVTV3VHYlZvb3BFODIyVU5KQWZrY1JhZklZZjRmQ3pmcWpLTkxmQ3JVWnNOYmJSTVFkOUhUWFg1QjZNYmNQR3lobkpYOHVZbFk0UThxQzEwTytVbUkxOVdjTTNRTDVTS3ZkNmozdS8xNjhrZWxzdWk1eEZ4QTN0Y2VmOXZ1WGh2RDNsSzdhNTFaWnlLKzJSWXgrcFhiM1NIYmVTaWxITXJwQ3FibHExL3QzRis5dGlSNmNvUSt0M0RjVHdSR1Zaemx0MFQ3UlZ2cldKWnJkYXV3d3Z2Q2Z0cUlPSjNOY2cxbmFPZG8zNDNscThkMDN1Z1dlR1p2akRLSlpwdDlMZGpGNkwzdlBVeUdvaVZCTkc0MXQ1R284MG52RXBYZTN0ZkNqZTR3VHIrVmdTNGVTV0RLOFN4QjViTTJsd0xIRG9FQmh2MzcxT1Y4ZGJSaVRqUlhsRlJ1bGRkWDBsTlA1TEdQRXpJL0RGMUU4R0hVV2N2QmpIL1Q4VnhLbnpOd1RKUjhNT1BnOXczbDZCcGl1czZyN25rTm51a012SjY1alo5bGYwNVhYajU2M21uS1ZNaUFLNHhmNXNVNm5IaHJmdXRFS3FheG51N1FSSDZhOTdtVjZYRlpTT05OWXZ6azY0cituenRuVEdqY3FlbVdlZS9JTVhjckU3MHZzemlyNnkxa2hkQXczWUx6MzZLNUozc0N5emFEQmRoT0tVNFdWWVVDVmYybWdwbWw4eVdoWnFFeUkrRHZERVpzZUZpdmVNb3EybHlrbHVoR1IwWktDL0QvdGV2bVZmd3hyWTM4cjhmUzNPS1VMSVhSbGRrYXg2cHJGOEI2eER6Vk9YZndnemxsWkkrcGtESnJva0k0UTR6TmZvY1pWUndtbktsYzgwRElLN2QxWDRiMHh1eFBWU3dKTXh0aGRnODIrbVI5bFZmSDc5dTRsOEhpNlMyN3NzTDdYOXVzWlUrUDVGMXBsb0x6cC9GcktWcjUwYkgwM1VqNmIvOHJuMEdvRXorRkQvMlhybUhFM0hhVW5JWjdGcU8rTGwreVpDeUFEV1NvVlRDMkRsZnV1WGNHYVQ4Y1hVVCtYazMxSjdCMTlGV2ZKRFhVOG9vcnpBc0d6RWVRZklSTzZYVzJnM3hsck5lNnQrZGlpT2Q1cUpkdFJYSFRlaHJYdjhIVXRYU2puM2REalJuNnBtNCs5V0hvT3VWVzJPbDJQbXIyV2NNVUZSSy9HNHJoK3ExVS9FbnRlVkNObDlKV29VclhwRnJIMVJyM0lnenpqNmZiLzlJaStxMTVZNFduZGl3Z3NUdTVkVFV6VmdqVHhTVlJ6bW1sVklzM0RqV3MvLzZ0WWlycEV5V3FGYTdyd3JheTloTmFnRE5UTFFaM2p0amRic3FwS2krejhTc0kyTGtrVktVdDlLdGVWYVg0c2I1YXdlc3pXRm5LK1dJMjFkSTZWOEdyMzNlYWFCUGNuNGEvc2RRaC9OdU51Zkwwb1U3Y3orVHlQaW8yaUtEdk9nZS95SWNSdSt3QWRBMUpJTTk2b1JXYzYyMGxsaG00eFdreHZMdWtPUGdLYS9LQmVIRWJRdEQ3MDJsSFdjTVFrOUdlN2FWQU50WkxQUTVNdVBndnFvWHY3SVlKdkZ5Q1lhcXA4aWJZcjJUMnhYUWE2WDlEYlBJa1JldDhzY0hRV1d6TSt6aDRUY21KWjl0OUpGdHlXazdSZXlqMS8wZW9YWDIxTzdyZUFrWkVUTnE2alR3WS9RVEVTVnQ2UjAzRElMS2kvVjk0a3F3TkpYeGpNOEFiSVh1TDJFL0lCdFh4RkNwck53UDJNclFSakp3MHVUQjZlZ0JKN1Y3UDhxaCtlZiszRGJSWWlYN2RkTnI1UGt4NDlJbzJXOVpNWHpabk9mczFSK3dyWi9xVWxBUy9kWHU3bVpUL1kzdW8yVmdUTEc2ZDFMc2ZZaVVzSWRiYm12a1pXME5WcVpmdS9vWmFJYzl4NXNXWlpqZlROSDFHcEMyYTB6dG9ySWRWaFRTRXNYTTF5NlRPOFJaV3JFZnlqb2JVZWVQdFYvOSt6OG90b1pJU3FMcWlOQWRGNjI5SHI5TC9rb3NyRXZPZUpmbzl6VXd5RjNBalVDem5QdXd6aFA1eUZYS25YWVI0LzlpQktadFNId1pjelUwejErcEFWZlRIMTNidUI5MTBweXhxYmgyOUZ3NHIzdUdWRUlYN1RHL2x6WWlTUzFmMDc1bmtOa2dTWGdTbFR3YU9OYkQ1TDNHc0Z2cjQ0bi8waUx0QmgxdmxHRkZwbERsc3pTeUZHR2ZQaHp2cUE2V3NZS1QzdkNZNVRlYXQzK2hkUlo5WXYrY2hWSmRPMHF0V2MyejhSLzFjKzdSdU0ralI1ZjVzejJXVmczTCtrS2ZUUW84MzNlMmUvOTJZQm5sNksvN3BFL1pVQi9YWUtVMldLeVBrWitaL1lGYU5vcW90bkpYYmpXWC9sdW9pdWlZenBQTXlKejhJd1ZGaUZrZ0N2VjlJVmx5NzBqTCtISWpuRHB1TTlacXlLNGJKcnF6K1pPanpUcXVrU1haaU5MTmtLK2t2WFBOUEN2ZnhibEx6UW5WbmJycVpHZkpnWjYzN0MvMFN3cm1QNnhtU2gzeUNUN0h6Q1h3K0VndjZIN2dEWHFON3JxdEg2WjdlMEJJbnVHNzhBZDYyN3RQYXlvWjNTZmc1QUdjUk9HcGV2WlJIT2ZYYVcrTW0vQ0xCdkltVThJbVVIcjJYdDllTXMrSWxFSmtWdlM4NHpPV2lYMWxQMlYwMkxDenl0Sm16Vy9ML3dGMlVtdzRJdXBuNGExajZIdW9qWENVM0pIYlFiREVCbm9OdGxVb3NLOVU1a09HNUI5b3FMYzZUa1pBVms2c0wrTTN0L0NEb0FhMytMazFaelhxRUdQM3dyaU1sdWxvejkyTHNtdW1YWG5WaDJzT3NuckRKU2RIQm5XVS83bzhTMHJYVDRsYkN1eUdOZUlxR1cwK3plTHRwVW50SmF3ODJLUHJXejI3d2NRdVNWditIODhBMHY5bjZ4bDRzTVhaT3NCMDd0SGpaZ2Y0WHBIbDEwTmZ1ZE8zc2tlR1ZRam5PSFZJbVVzcklOVVU2cmFldnhoNlhIcjgybHF1UGV6aWpjbUkyT3YvcFhJYTNmYzlDSzZtc2diVTNLT0hXUHJ2OHFuOVpPSjFYOWFlTVQyejI2L1ZYcnBTZ1BzbE8wUDU5Y2Nlc3lwTENaUDdLNStoUjVHZ3ZnQ3dlRUxScVhPdndzQVNzeURjeTI2U2tQcmlQZ0dLQm1NMjNzRjdmVEZpZmRBeWdLUnk3L1dZaHgxdDRxU3Q1WE9vdmh4enpua2xCV3hTN1ViVVZyTFI2dXRjaXpkM0pmQmU0U1ZZTGlrTldpczhPamM3MEhUSCtoZVJFcHo2aUFwZzllUzgvZFlqc3ZndlU5WWgvMkdGMFhHbHFlOXo3SEZIMzA4dlY2UjhMM0VOYjFOeUZjU21WVFJpV2ZZV1MrOXFtbEUzdU1MRVdtZk9WaFh1Y1RPV3IxQUY4NUwxOXpPNkczakdla3RreWJ1NTZDbkRUK3FKRXdlT1JuVTBFcXMrZXk1bGEwNXVkcm96MXhpRWtKVURsL1FqQzVKZ2ZUSVB0YU1QZVVSbGVOOUdUVUg5b0t6dW0rbDU5WWxPSWdNbTZyY3JROGQzUW43Uklkci9ka2U3Q1EyWk9PN2R0STRlSzNhTWlZelZxZm8vazcwV2d1N3d4NUxkcTZ0T1lJNktDM1pnL1NzbTdZbVIvMWc2L1lKc2JEVTJjcHBQSWt6cWpoakNpSGF0aTZyejQvb1c2SVJ3VWdub0IzclBWOGlwNEo0ZEQzK3MvVnpwR2RaNWZWdkJoODVlNnNCUW1Bc3ZlTXRXWnhnNlVabzltOWt2TmI1cFh0OFkzZmx2bEI1aFBGc3hrejRZdXFuVWU5TDFNWmVJeHJlVVpXUFVwcEI2M0xXL2RNd0VmSTl6SG1zTk9vcUw4Q3FrcnZMZGNON3VRTmZ2MnF4eDhSSDdvdEYraHZkT1NZR3JjYWVNYnE4Qjd3OUQxNlA0WHRMSUIvc1J3ZkZ6RUgwQlo1emE0MzJIRUtkZFd5OWhmS1JHUGUybXlwbEg3NmtQV0kvR3JHZjI0elg3YjE2TzdJWjBmdmpsRjdPMkpLN3NyZWNzaEZUOTd5ZWNSK2dqR0pjZHRSaGZMNzE1a2VjdGxHbnp2TWpja0JtTDYwblFsNGRKdkVHNjZIWnJRQzFiTjZucjRQZzVqcXBDNi9uYTI3MHdUdmQ3M2c5L2J0ZHIwUkd0UEY3K1h5RWtKbWM2ZUljUERyaFI4eGNOYjJiWHFPZWZuTWkyeEZJT204cGhzcVNrMnFHYThaSFo0UXM1NHhEQnM4NnlIQ2tGTFNPeDcySThXY2E0WG9YTUUwT2hNTkZ5Nk9PckIvM0lTdkczb3Fjc2ZkTkNDRUFvK3FzbHZHR1JLcE9iVTBndnUyUkJ1bldEZWEyeUNNaWo3aVpISWZrVGJEbWdiWkNtMWttTWowNGhRQm0rSkZmUnBrVWp6UTVYMHg5ZDdJVFZ3TGhnMmpQVDd5aVpGeDI0cGNnZjRYVitsVlc4SUZUdHNvWXFBSjVZMmdJNTJGTmxzams2ZFNGWHBIMzJqZXpOSE1MOUlncnRBV0trYWY4L3JkN3p2TElLNDlmTW84Wk53T1QvV0RGVXVRV252elcvYUdnQTFkTFo1Umw3UlRVWDQ0Ylp1eFhITVhvaSszRVdMMVZ2RExIUEltM3RiOXlHRVIxWTJCb2ZUMzUwVERUblRia29YT0dKTHhTYjYrZWxzTjFWbVRyWHdhU2NyTlptaDdlbHRibXpqTnlvQjBPOHpXbnNaZTc3dFpPSnlzUDJaWi9BaW8zNDFrbExhdTFOaE5OdXVadTlIN3pUcGUzSkoxWngvY2hXdjh4SDJJZXMzcDA0SDZrWGhKVk9ueXdlUHNhOFNPUDkySG5aNDEyTXNVWEpnU3VsM3pLdkoyQjVyUjV0ck5taHIzb1RSL05YOFpsNU9DMWpKTzJvTDdXMHFka20vWVI1QnhTb3VzL1FtNUJOVjEvV3R5emJSdWVMeHZaekoyRmVReHpSSitqYVpFeWlnaEhHMm1tL1VSbGVCMXEwYm8vTFcweDhtb3lKWkc5Q05DWkUrR3ZkWThlbjZ0MDVSQ3lwVUdmYXV6NTYxQVhIVVJ0b2VGYXVwUWl0U2FFL0RCaWR1bzgxZ1J1eVBKMk0zTkRwQlQ3ZE9GN1RFQkt6VHJXZnNUTzc4aXBhenZqWVBJbktLNmZ1aWl5ekRXSXVQL0Q0d2ZwRXV5RUdua1A2eVFqSHlHV1c1VlNhbTRSbzJPSVk0MlFTUUJPZ2RENXo2K2Jna3UwMXVQdjJJcEV6NytYUFhNL09rUHBjNkIyZU5rTDFqeTVrcnJUdzVZVEpMS2IzdHlSSXE1KzIvSlh5cXNYaWlKem4vOW9JanpsMzZwajNhcWxrY2VyelF3SHVoZHZMMEwrM1pMUjhzYTE4QUtra2Vtc3NucjNkVTdBMjhJdXdUeVdISEovVmozU1FOVlVSTWFiamFuZXAwZWUxcHBSbDFhNmxPTGRQTjJXazEvUVJ4Z1NhLzcxYkZ5UjIzTFFHV0QvaFY1VXpVa3RTMFFmNEpBaVlhSXVPd0RxUm5qanU2VjY2Mm9qVDBFL251aXlrSTdFTkx4SFdpUHd4ZFJQUnhzOW5KUnJhQ2pKVWlWSnllOFNkdEdId280bER2Slp4dmlReVlyVXM5RzJ6NnJ3WjNTampyZWNPMWUwNjlWOStmbDhySm91SGZFZjBSZzlPNlV0VFN6MDF4Q3R1V3pOOWJFeTlSZFNYM0dvbEZoNE5NMUkraGtzYkllNlczUHFiOHB5OTVYRHlmWFp1VHJ2cExpS0VScS9oM1YzL2U2RzRCMTBqc2FzZW5USXFlZFNaQmtoOVZLeGsyVllScXorei9OczBoMUJIajk0OGVpZGVUNU9FdkV6ZkJvclA5Y3RQOHhzNmtZUm5wdUJUdWQ3Y21YdDM3dmwzcE1USnMwVDJiL2FZK2UrT2lEYUcvWHFSMWNvaEpEUDVZeWQveFd5VitpcjZUb1UvV1ZHcHY0bER5S0RjSld6anY3aWt4QUMwck5QRzl6UDZvenJLM1BlZmpUS2ExMkVybjV3bVZQUjlpR3plS2EyWkluYStsVUl1bWNvWlJYbmVpWXJaYytpOTIyMkZhQU81b2RDditSemlLcW5VWGxvbXA0eWJ6WXU1MW5MdG56dnRzL2NuU1dFck1OOVAyRjd0cDR4T1UvZGtCL1AvUE5SbGlhUExnQWhiYjc2cFZSeU8yYjRmbnd4OVJ1NFlLVmdMV1ptcjArN0JIbVZHcW1FSXJzOC90M0ZGL1dTRUs3c1VieTlkTTl4S1VuZnIzZmVKOW1TMWY5NjZaRG56blZZOGFzU09ua2xLNDk3ZEtJUEtpS043c2pJVmwyc2ExUjdGcEZIWGlNeVBQbWFuQklzMDZ0RG5RL0lXNVJ3NjJ1MHpiSlcwUzZqRFBlSlgvTFhRd2RFcC81VVF4Yno5em12aEJVSXQySGt4WkxXUSttWHJDejBkV25vekxJTEs0N2tmVG9NeFB2Mzd1dU9lUGZsVENwcDVEV1JLU1p5RGQ2UEY4NEVHVXRHVXBuTE1JbW1LU3k3ZjZhMlFqWkRTak4wcEE0OXA5NXJVbDdRZVBTemNrNWRyNmV5K0hKcXF4Z3YvRkQ3eDFNdU9TYzh1Vm44MGZlQjZtaS96ZWpuNkErVkl1dWk3UnJ0NkNpejVRV3dtcXlrL3U2d05nS1FoYjYxWkhZR2NzQUNtaStrSEw1Zzl0aWZ6STV3ejBhMmJ2L3dzZVdzMjJHVDVnUnR6ZktpcExOdXRHZCtCamVQRHB5aCs0djRGL1Vra0RySlNXUk5LcS9ObytzRXEreGtYaDk5SHVsZmFSTlpycVdTV29keUtHT1AxNUtSZWIxU0JpRUVvR2R5b1U2dUlCdnBNdUx5MWR2cUhiNk9hWjAydVloNWxWa2QyMi81R1RMY1hiTW4zZGRSTWN6VjgvNlZlNnJYRU0xbXpVNDQyRzdrVFZpeHpLdXZOYWUrVGhjSlQ0Qk1Rb2hDWTZLYnY3cE9iVHZjV3NvdUlvdS81Tk1oR1QvenhkUVJWZW10dE0yZE1yRWZtWVVqY1RESGdKOVIrd0E3Vldwc3FoeE4vNzV0OWYzNTluNzcwWVhSK3d2ZEJaZzc1S3k5aUFqb0t0cTZvd1NHYjM5N295dFNObEkzcXo3V1BrY0M2M0FCK3JEM3cxb3l5SGVDaktWUm1SY1N0WUV6bGhjemFHblArdHJiZFo5UkIwOWJrd0hReHZYTWJoTHg1QzNRdGlKU0FzeDN0dE5aeTZQbnRkaC9lOFlsUFp4RGlzQllTeEYwc0JsaUlrU1gvNjIwSHozMlc0M2NXZ2FoajQvSms1Wi9OdXBmOWN5VnZ4SWhoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDRUErVC8vL1IvMEl1dmYvL0FkMXJmRWVudDh3UkV6eUZ2V2w1NzQ0eDJlRmoxa0xWaGNUeEYzT1NHSlRBSTVXYWg5T0NLeFdIazhsMU9VZDRLWWxiODRlYng0bWVhOUtjMUxINjAzWnAzM2tZVHNXVWRqSXpMQlVWWWl4bjdVNHN5M1RPaXByMXZzU05udmRrSmhrOXM3WGg5RVN5RVhLM0ZFaDNqRzN6dkRUcmNTQlp6bjdYT0NzM0dLYyt1a1o1VFd3RjF4VEdwRTVxTEpBODFieDBaTXFWSnZHeVB0TXF2L1d2SWJkUUIwNFdGbXlGUFZoOFoxcW1RVTk3UzhucEVtNTZVOWszS2FlZUw5SE00d1RDdktpSTVyOUNqWkMvdW5wWThjcy9RY3Y5dEpxUU8zY2ZqU2tabHcrMmMvWDJXZFJISXozaThzVUtsREtUTVcvS2h6aDl4cHE0TmJGREE5NnVPY1NLUUszdUN4MHZlNGRFSFJNdHpMcCtXdEE0cE1IT0FHV3N2Qm03Y3JkMVZtK3o2ZURqbGpMNkpWbGpkQ1YrNStZL1YveFdZUjY4OHlhLzNUT3dlMmZQL2lXYWFQS0VJK2toSER0TktvamZnUlZmamhpNkpHY3FRcXFCOGhxeTYvaXFENTdKcVgyZHptYU1qeVVML01yamxCUWRtdHJ6OUkwVFhVMCtUQUxGZG5aRnhmdFB3aTVOMFkyZnY5czQ5Y1ZLUDRtTUNkV3ltNXFwMldFTnZHNjcrdmNmVG5SbHI5ZXlXbkZOdnJmdWF6dnFocXRLcjBON0JTaWhHTFBydUxZMzJWTlU0OUdGZXVScVA3cldmczdmZldDWDFPbHBSMCtoeTN5N2dSU0RPZ2pyTzNUVWVmNWoySlRxa054SCsyalo4dUo3bzJQNEdSWlFFU1Bzb3NDekN5ZitGQkZURVJiKzM1Qm1hSnZCajJkTVIrWk0vemY4OXY1cEFpMHdIMzRheTkzNVk3c21wOFJsY1JYMG5VSWFFeU1VR1haaVB5TFBpMktTR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSWdmZzdrZStrZFhyVmhOUHo2OU10YW5HcnpsZUQ4QTRmczlJalI0cDBIaDJFSHRKRVBoUnRqTEhUeHppaC9iSnp2ZUdkVk9iTmYrMGNSZThFb1hPR2o2YzhSODZRRVVmRHl1T1lrZ2kzOGgrdWU0NWlqQjVESFRsL3FoalhxQ0V1eDJRNWkvRFN6dXVHZTNXWmNkWmRVU1cxVDRwRis3NDBVM2wzRysyUlUrazU3VkV5NDhZNmZaOXo4ZlNWazgzTVdwMThEWi90MWpyZVV4dVJ5RHpBN212a0JIQXZEL3BWMWxjYzR2VE1tb0VqQTNUUjRFYWRpRjBWcEMyY2NaWnFWT2NuTVA0TW5QUGpjckdUbWJjcEF2Sm1uL2FucVV0UnBYR056N2Y4K0g5NTVQT1JzbDh6UnA0YUg2dkR0ZjJMbmcrSXRkQjhvakk5UGRZN0I3ZTBQZmNvajRkc0pLMnJueHVTaWlyNWxjNDRVYlgrU2pGODJ1cHphdXR0bXcvSHVlNHZkK1VucndXRGxkcEpyc1BSL20vSmpucXBNK2R6ZEJQdFFoM1MwdmxXZkNzOWtnZFo1b0Vpb2kzYTlENnpHUGZTalVqNzYrUDgzT2VUTG04MmxxSWpYMDUrQ2RxWEhRTnRyWkhDVWYzckRTWlBWMFFhSUtvTHJPdEk0M3RsUlgxODZWRWxKVHc1WldZUnUvbFZlNTlPcGl1S3ZLTEtMRXBhbVRPcHNwRVdSbGRKV2o2dHpKbVdnSkRic25LNWY4WldoS01xUjZvUXpadkZINXROYjMwdGJMUDlSUkcyMDU1T0pYcSt3UENVTFdXbFlIdHRaV3NDcTBjVXUvdk1UVkhVdTNjbTZ1dTM4bG95UEJjb0lodkppK1FuaEtoRTkyM3J5VmdzbzFWOWpYTW5QK2lrSTNXejFjOTFsc2g2eml1L25OcGVGNzJzZVRsSUw4ZFE4U1ZVRTdQUFJCRlB1WDR5KzVsYjNxVkQrdk80cC84S3IydFJHdm5IUU5maFdwN0ltTFB2WUd4RkhOMW5MVWE0bHQ0cnM1V3ZUdFBxSTFUbURZeCtyNHBCcW03cFN2bzY2NW01bUVGbDZLcXpuUjhaRXptUTc0S3gxYk9yN01sQWx5cVJhVGhLNzFLck9QSGFOUmtrZzJIazlrUzNJdzU3Z1RJZk1KRnpZNCtzTk9yQ0lVYW1BYTYxbzZzTExkK3NjWXZZdXEvSFZWeE9QamFvc1lOaXA5UENhNkkrN0ovMC9HSXFJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnaUI0QmRUUHgzdDllWG9NUmtnOHBRQXJTanJMZXRMOEY3dGJwM1NaS1UxYmpBYlpYa0hRYzA4bklyY2dKa2ZZQ0MvUkE4c0hHaGI3MkFOR2E4VjJWSVZyWk5Xck90emh3cDZVbVB3M0F6a3hCSjVkSG5PZXZoVGtOZWFsb1hxd1RvN3BDN0RxMU14WkRsdHQ3TkxSYStDSFFCaWpiWWVXUVVLYlorWUc1RnliUFBYS2IxNkxrL3FMV2o1STVidWswUjBvM2VrMmEzeDlCV1k3VENXcWs5QWxORmpYRDFya1pTLzl6cmpsWG8vemwrcHJka2s1YlZPUk1wQ3BrVnJjSG56MUpLRjRwMWhOakpvUnl6dm8relcwTkJNaEN4U2ZrVzh6R3k3aUNhT3lvb1NMTHRsWG8yMFdYd09UamFsOWNIMmVvNzFXOFh0MUhSckhxZm05YXNlNVJCdWZVblZaMmIvV3pJOG1VaFphSDJzc2liTVkvUGFBaTByVWlkMEFTVERBVEd1NmRyZmQyNnAzZVRYTEZMV0VXTVd5bm1ycU13U0xrdEwzNmlEZWUzbDEvRFNISXlGQ05mU3RlclZVcXE1a2U4a2tOdlQ4RnlFRnVBNFArUUJWTWJoTnNSOVdDYS9XWVh5a0p2RnVCZFR4UG5JaS9taDl0TElNOHdzT1Q5c2pUN1RMOUVHb0ZhR05WQmx2SFVkQVYwUVduVXFoaHdyYkVZZFFEdUZiUkkxdzYwMVRHN215NDI2SE1jQnJuYktyazY5M2tpZEYyc0ZRcjRRejdXYnNUU3haSTRpYlAvQk45aGY3c0kyMi8vVVVqbG9vNDB5UzEwZmNYMFFJV1VZOFJhdDdZN2ltTS9uSmJvY2xFWWg3NU9xWGdScVhnMGlxd0RTQ2JwVWl6RFRuZlRrZStzY0RpSkNsbko4dnFMc0lOVmZSTlhzbFF4MHRsYXl1MkZSWE5kR2lpNUN0dmZWVG12L0dmK3liR3YxSjlkUHBTR2pQRk8yV3VVVitFci8rOGVqakVlNGFhYUx2ZjZ0NzN2LzlmaDlMOHo0VXVvK3Q5VSs1ZENmTWlhN2V3OHpIRlYwTmVySnNOcytqdWZzYVNQYnlwUEE4TWdDQW0xM3I1ODZIYytEL0o2OEJ0YWlSSE9nclc3UHdXdXlqalA5eXNpMlpKM2VtOGFJUDMwRFVGZmVtaktSMmR4ejIrQWpEVFZmU24xTGxqcFBxN3VwRWd3aWplMDkwckJrc3ZIZkcyTWlGK3RaWkJMWFJiOXVjYVpaSVYrS0hOZVd2Z0wxbVdWZlI5UWZ0Sjc5WktMMnFUalhHbzI5L1c5bjFuaUx1QUl5TGIrWVNrNkhPb0FRUXNpQlU3M3diN1ZFMzNiZjlEZ0lJWVFRUWdnaEFpNFR2Z1IyTkprTnh4UWg1TDNJVkZ1RUVFSUlJWVFRUWdnaGhCQkNQZ1h1ZVJOeWEvSi8vdnMvNkZXUXYvL2hPNnh2ellrdi9FVE9BN3ZWYVFEZUs5NDlSd09sdmpQSWVnNExJQjhBY3ZRVjBVRlBxNTdZbHQ2Slg2M0RQNkxkNnFXTkhEU0NsemJxeGZjZWU5SVNaUnpIRlBxQ0tscDJ6eUJhTldHZEh0N2RSbFdIQXNnODNONTZoVE0yUFhNd2g5NTIzdng5ZTFZcWpXKzBTNXFxT09pYmtWTnFhK0U5bnVNbXNRaHAxaW5MKzFSMWZIMjZjdlJVNTNHcys1OVpqenNNNEx6WHRTMHpsVkxBd1JpZDJIVmU3M29Hb3pJN1BDMXhPeTgzWWg5Z25RYTVLeUhMOEZ5RisvZDAxQno3K1RxenhXMVpQVjZzSlFOTi8yNnN1aitraldlWFBiZ3JjL0EzcThCeVRLTFdvRG1uWHZPMkJJYmVacmYrM2I2U0lMNk9JSzlsbVhWNDlHc1FhMENQZmZUbTdTeS9wSlZtdEV4TmJsREd5RDZlZDN1U2FIcXRUQWR2bmFUMnZySDhzNzZTSmw5UTZUbnh1SjllNjZibFE5ZjVxTXlJVGZTT2IyM2xIUzNMSWpqWVFvenVxV2o1TkhyNmM5OW1yOTdNUmdtb3ZqcmVWKzlPaE16VDA3dWVURUxJWkZCWGZlVUVEbXdGUjZ0UWpJRFdPamdmL2hEeE9lWkRaS2ZzdEk5K0ZvMlU0WDNWd1NyaldTWEFMWjVsZFhzOUkvSm1ST1ovNzVLS0VISWVoMlhRM2dnK3Y2aHFMRFd0Tlhsci91ZXEwSjdWN2h6Mk45NjdDazRpSHYycXF5NUw3S2U3UnIrb2dnNCtUUldkMWVkbnBmcyt0SFRhK3JYZHRzWE1wMHRCakF2cTNVUmtqakpqVDhXU1dSTVp5V2dkV21YTTdMZVRtSEZiMGZRM2JBWUNNTHB4aFk2TExTMndkb09uNlFYMDdBUjcrNU1aS0FPcDEwd2ZBdDJGMThxbUNsaUlOWmlzRGlOdmlhY3pEdW1NL2g0WkRwNGJ3U0ZHRHZRYW90d09qcXlsVy9FOXE0ZFdPczRCZ2VVTVdFcWpnT2srbE9qNFJwN3FqK2p0clF5K2JVb0lJWVNRQzduU0U2UjdUd2doaEJCQ0NDR0VmQTdmdXM2LzRyNi9zNjI1azBRSUlRcFVqb1FRUWdnaGhCQUxyaGNJSWVTZVVEOFRRZ2dNVlNZaFBuOG44aDMwSElNVHBIV2F6UzBQSVpLdmNFY09QbXVsaVJ4bjVGU3BBR25KRzlCellGOEtwQ0gyMFY4YkM5clI2OGFaOHpkNlFzVVlLNlJheXJFMHJrWHkrZy9aZ0YyZmRVR1BUSW0wdHJ3ZmxNZzVjVmIyeDZtOHU1Tmd4VEd2TlVVY1NkOFdubUwzVStjdFNpZ21VejloTmpyNnNYcWpvK0RXdEU0TThzSTFyT1BUM3FveEJ2VlphY3loVjhUdW4xZjdJS01wb2xlVU1rV2NmVUp5cXc1RnhQU2M0ZFVLdDJSbzZjNFlYRmNNWU9WK2tYVkZORHhhaHliRnVaNEJzdWpxeWQrSU14YW5wY09QZUpyYnRKMmFqdHJWTForUTk4allkMHI4OGVSMkxIK1ByeUx6M2NFb1JNZDNsSjRGZnZTb3ZwWk83TFZsVW5hd2pab2JQT1YxWFNYTjBtY1h3bHBmSDViejBQN3EwbGJvUStaejdtekJ3cTQxNXZjaExXd0RYem5hNFY0K0dkY3lDbDZaWHZwV2ZheXdualE5RE1oRmppNzEwcU11VFkrYUNlYUp0a1I1L3U4M2J6NUVLbm1rUytLY0lDdW1uSm1tYlVvTkF3elQya3RvcFVWbDF0ZWVQMTNTK09CQWJFQUM0bnBsMWtUc1Vxdk1rdXcyN0ZsZForVnZmeHhZL3RVclB1OGtaU1BkbHJZb2tqWVpYa3YxOWtBZEpzTmxXRS9MRXZMVmpDNGJXcWJBWTNYNkNrK0hQT1AyTHYwcm53amYzUzdxUnhqYjBNZUVlN25OOVlLNHRpaENkcDF2VjBhdisxdU9aZlJDdlgxVExGMkJ1azJ0cFhoT21HdGpqUzNQQ1JnY2s0UVFtNTh2b2U0TTBoWmphUE1zOHh1cGdYa2IyU2YrVFQrRHR1TlVCc096VS9MMlYvUGVEL3EyN0M2ekxCMzBXL2ErMUxiditGdVg0aHFCTmtWUi90b1hVQkYxZnN3M1lpVFFmUWxrendRbEo5MFllcUI5b0xXREo5L2F6NGoyZTh1UjhOTGV3TWg3ZTZOWlNkZTZqUjZmaHo3TmV2clUyRkZHblgrT0FlcFRCUlkzR0V1anU3VjFXQ3U4amh2cDN0RnU3Tmt6UlZVRG1RamEwZXlVMjlHYVk1WmFycmNpWkxoMmZjQklvUDJjenZMb0xEZUNrQU9qaGtqa0w5NXo4SDdSYm5nckhXMmZBUFhwdk9VVGxZc0p1cnhENWJUUzg0dXBoS3lHeW80UVFnQ29MRDhUOWlzaGhKQWJRYk5FQ0NHRVhBQU44R2R6UmY5eVRCRkNPdmd5MVVGTlNRZ2hoQkF5Qi9wVlo4QlcvZ3JZellRUVFnZ2hoQkR5c2ZDTHFaK0c5bHE5aFJjZkJIMHAvZTJJM0FCNnlGcHBaNXR4aWhGNUE5akI4N253R0JIMG5NTXRiVVJkVzdMaXR4czVQNjBYOUdSSzdSaEZVRWsrajVadEhTOHRNL2UyY2crdE50RDZvQVR5SSttVXVJS2V1Sm5BY0NuTE8vTks2NU5qcXZyNjhBV3NGR0hNeVhsN3RXdzNhaHR0V3I0bGs0eEEvVGtGY3c1RnZiYVpCa3FmeDFqWDdjK2RQa3FScWZNanJ2YzA0bHE2MXBiSTJXQXJCeVdxbjN1UXVyRFlWZERLZG9kZU5VN2RPc3hpWlo5NFk2cmcyUzFUc0ozWVdOb2lYazJLMzI5dmk3eEt3Q1VjVDJxUHlyQjhnWlpOMTJSY2JUQThYeS9pUHlVbkxUbytVYjlxcE8yaWJSK2N0L254djFxM0NMVzB6YUZEQ3dlK1Ftd2x0Y0x6bzFBN2ZoTWc1S1daZVBhcHgyZTM3R1lHMDgxQ3M0WEpxY1BxT2sxZ2hZblBUaG5JUm9ESWF2VTJPdEord3FwcHE2NldwZHZnREMza2kyVCtDQ2pIU25yQ1VWa3dudSsrd3JlSnlwcnBkMHJRKy9YeTk5U2hSMGYyK2pJeU5qZHp0YjQ0WDlRY3lZaXZRN0tUenFJdU96c3A5R3ZKU28rZGtGdGhMZWRUYW0xSHhrMEJNcGxRRjExTTg2ZnRkb3orN2tzRUNkT2dxQjlobWVjc0xrTG0yL0gxbjE5VE1OcEQvajFVNXZhSDBlK3RjckxJajNZenVUbTlqelJRWFlHNFc5b1dhRWtjWUlTY1JINFlvRzBmS3d1RDlMSU41YkRYOWJOK3FNSit2cWlhbEM5cWJsL3hkSlpVRWQ5OS8yUm52Nlo1MUxaYjlvdVlZckxLZnNYdnBYcTFLbTZjdlMrWnBaUkh1cjhlL2Z1dll2VHpNYk1vczkwZTluMXY3ZkxLL1VwZm5tbTBQWDVMbHJYT2JiV0VuaFp4ZW5OcXk5SHkxTmZxemxYU3g5VG9mZ1FpTHp2eGMvWWkvSGpOR1JpVmhiYVRWclRVVzBZUkU0cmNsVTJ1eFp0eU0vMVJhKzN0MWFVbGE4dUhianN1R0hPdHJZaTY2TWhXQktLWjZ6d0pERTlPSGJZd1MzUDJiQU1nUXlrYmY1TUZSTTBOTytTMkZDUk82VzlOWHozbks3QTNKc21QLzVWR09ZUjBFZFZYbllQT1d5Mk00TGsreVFuL1NsQm5CNDMvRXJ5cFVvQnJid3BsOFM5U0gzNHhsUkJDQ0NFWDhtMmU0cmQ2eGxmY04xY2hoQkJDQ0NHRWtCdkJKUW9oaEJCQ0NDR0VFRUlJSWVTSEN6Y0x1VTlKQ0FHZ3FpQ0VFRUlJSVNqNVAvLzlIL1RPK04vLzhCM1d0K1RDWXlpUWd3c3VxVjdrZUo2YWlTc3Q2K3NGM3VuRlBGWGt3K2dkaXdRbmNpeEVVS1RYYmFQZDJqcXRxQWY5ZHJWU2JvRDNDYVJESjFqM0VUdGJWaGN1d3lQTVBzYkhHQW5JVVhhb3JDbFk1d08yeTRxcFJLdWYydzBRT1pId3JhRWpZZUNkUndWbXIwWEFiUm90R3ptZnl4cTU3ZE9wanpMbDZjNW5FelhJSzZ4aW45NEtFOUhYUTE4VG04MUllM2h0cmFWSHluTFNRUzdPWTY0OFQ4WGY1KzJiUWJGNFNld2syVnpsK3hRRlAydCtqOHE0WTlub1hFSnRoY011MjZNc3d3VnRmZUdvbDU4dlRUUUV5YTlhMkFuVHREckZhYlY1VkRkYXNpMDhKUWdwU1pHMjAzOEtsVFVJTWlVaWVWdjVDeGh2eVFTNnU3VHlLd25xS3RWZlR0MENtMThDTStiS0RIY2s1NGx6MEJXR3pxVWVmWTJlTFJxUnA5WEIwdU1SMEIyclNCblIrMnZKYVJIcFAwdkN3N2NUNlpDZEF2bmxWRmttYW1WbEhZcWlORVpIRUNGa2tPam12cFkrYW5hU0kxUFkzV3pKTW53QUkvcVlQOWt5L3RKc3YxZG1mbHc3ZmtUWEZ4Z0FIOFo4TktBRUY2UHQ1V09IWnAzQWRLMzhhRm5rUkZhNWRscWFsT3hsVW10NzBuT2pDQ0duNGU5Yi9mNzdtcjc3ZFVIRUZ0UXJpTkpZdThTL1dockgzd3VQM1dkMDV5dzU4bmI1cys1WUhiNVUzNnhaWFpkR2Y0czdLUWM1MXZwUTY4ZWpkQTFyM1Z1blFPVFlyYnlLYUUrdUtsdlM0OVMzWkNCdDJUTDZNaHpGMjdkU1FKVkRuK0lpeEFiWm5tejV5UVdRZGNPeGlDNGJJaHJGdWwxMEswSXIwNnRUbE9oeWlVd0NlYVJSNHpsdDVKYTRlMmZpdWxUNTZ1dGs3ZDlsWGM0VzF2TkV6cm9tSkV6UWpiWnM0TXlpSTNscnpsNlozUXJFRVVtSlNrUVFYYUxOWE1xMXl1YmJwb1FRUWdnaDVJUGdsZ1ZaQkljV0lhUURxZzVDQ0NFSHJqQU9WeHFrVTh2K21oc2xoQkJDVkw3eWh5dUVFRUlJSVF1aHUvSHBmTnRHSFNHRXhLSFdJb1FRUWdnaEhuOG44dG1NSGxuVHlVZWVjSU9jQ2xOaUlyeHI4cUd3NDljUmFjc2J0ZnVmcXF6V2pldHZWenVDeExxekFxWnp5aXBBbW01R2oxU0pub1NKVU95aTZpYTh5UGEvR0NzY3kxMkdjdmVsdmlIYVZDTG5JSStOZzQvaWJCM1QxWnJJclk0ZTZmalN1RHFMU2Jwd3FveEZMWEU3ZlkweWI0ek5hM3Nubld6ck9tZHB5NWpwVHFMeFBkN0c1M3dsdGVhTStiMlNsV1dqYzJuQVJ5cmhpSzVra0tqZzV4Vk5xM3RibjNqMldnVTlFN3RPYThYM1lxMEhWNVJsNExsUFhuTzBLSlBTS09uQ284RlpGbHEwNGxmT2xhbXlwd203ZzcwWjBOZkQ5SlF4dTE3V3VpamlJRnN5WkNwUFo3N0tiSDB0dGM1NUxNUEtZWE9waVNLRXpObUttT2xISk52TTdiU1dzeTN1RnRXcmZKcU94THJ0RGMvMEZ6ZWdHV3duenUzb0Vhai9iOG9aSFR1NmpPOXhPQWdoUzREM1pUZTduZnVmd3hRd1YzSGp4MW05S3BSWVcveVEzekcwZjFDZS94OVpvUjdqeCt2a3grZGdmT05CeWhMdTRBbU43bGRHRExKczI5RU5TZy9ySWVRRTV6YXF1T2luRUE5UGJkVnBXdUVjYXlaOS9rWmYvS2g4ZHVOSlJOZWs1QzBJNzUwNStZcXhGL0ZVMi9rUVJjamJNSE5yYmRicUx1QzVmeTZySFJFU1h2YU5qRU8rbVBvTldMdGxpNTRVbGtZUnQxYWE4cmNwS05FZHlaUU9uN3p2TFpxOE9kNjM0VGtnNWpGeGtpRS85VVhpaS9KdlZOYTloNGgxWjYzd3gvVXpXQ2hMaE95bDl3YkRTRHhxNVN3WjNnL0xHOGI4TURDTnVyaUdKekxLZWgwSnZmRDhDRi81b2sxVUZkemFQc3VwZEZZbHp5eHJPaE04VVhUNndobGxCOWE2RWJVS3VzN0k0cnI5QTRhOG0zdFp1ZDdMT25NUXpKaUpOeHE0cGlOaDNLY1ZIN29kYlZVMjJwN2hTcHdneXhDOUMrajNFZkxEdG1vdnpPWHFyNUg1a2NFMEJRajM1dTJZM1QxekRLRmxyWmpuZDVvcnN6RHE1TG0yTTlaUllvQ0hYUHhIVjdoWlRtM3lxRTkvaGUyVUZDQU5Lc3VqcDZ3SnRIN2JWWkpkbFdnVlQxZzJoVFJsL3AxVEdVaFhFLzJkcHR6UDdPSVMxVGk2RDdDeURwSEJ0TG9Pa1EzSzlscmtTQUhpNWVQWFByeHBydCtOOU9IRzlOYkx6M3FGeEdYZ0hsQkthMGNPSWN1NGczcWVDZUtDUmNRbzJ3QmpHbElwSzdvMFMzYjYxbG9WcVFQaVgydytUemVvdVJLUEtsYTZQdFRqRTBFYWMrNGpqVFVkT0h1aUUvSUc5RXdsZjZkM1pPOXpsTmdkWlNOMHhqN3oyaFdtVjhmOCtQOCtEVlNuaDlHdjk5MWJLeXgvWlJyYnIxTmNnb1EvSjh2Vi82TjlvSTNzOXZNSVBZM1ZRaVUxSGxKZHdQR3B4aDUwM3pVWjRWNWI3bnRZVDlPTGJITjlWTzNUenVpTHdmNzF1a0NtcytLMW9VYmVoNVZHSktxMlpKcVd5dkRDUDVRVnQzdkdrb1FxNG9hd1V5Nm41N25ndExMQi9ibWZaNUhHV0VFOU9ldWFFQmZVandERnpLeUNqRTlPdWpvK0czbUpnRW9FeHQ4elcrZnI4Y1hVYjhGYW5DMFlYWnRJYmM2dlhyU0VtRm1aRWdxK1dVT1F5eWhnR1BGQlBMaVRhZm0vVWgyWFJyd21jNTVQMWRMWUtDVWd1N1g1cjlSQnJuYVJGWFdKRG9ibzRDaVQwaUQ1a0I2M0RGQlJmc1VrNGlQeWhrQmxycHVvdlhPSEtsbmhZeHZGMEVkRi9CTE56UjV0SU10alJrYXJmSmhmaE9USUR5K0tFMXQyTXM5bHhxQzdvYU9RbkRwSVBaMkxtcXhMOXZEOW5yQ1FtaVU2eTRCRzh0SWZYNVMvUnVpUmN1emw0cWl0a2JxZU9ZYXU5Q1B1TkZkbUlYUUpxdFliZTBmb1E2K1JoMlBIWmNFTjliWVp2bkw5WU1tSit4RjJQaWt6T25pMlBDZjdFT2p0OWNpSnhLTnBCck1kUmwwMTFYT1ZZTlpJRzNyZ3ZYVDZvdk55cHV6UitEdllMeTg5OHNQWTFpNVlLeDBhNThrOTVvLzRPdHRxcDcyUGhaU2RkMWVsUzJmdUpjNUtSOGd0bVdGblYzR2g2YkMybUZZODFtMzVFTTh5cFYrUmpqK3RSOG93TFVQZ1pvcG5mbHdCVHJCaUNvbzBEWE9LaE9OSmdDdTJxMlozNEJWYnI0VGNnQmw3b2NmNFJSb1dNTWd6OXEzOEw2QjY4V2ZRWG9NTjljR2pEVjltZVBDT3JOOGNnRCtxLzYxQmJGM3YzWC85d3V1VzlyaW5QOXVUOE5hMXJkOTFyREJTc1RiMTl5SWtpTmM2T2x1S0V5YVZScysrcmJmSE12S3MyUkNKTW5OeFF1N0RtWDA2dEFtZXNFY2Fid2FpK2ZGZFNqdmVLK01xT3JVWDBZaTRFV3owV3hCU2lUZTB2NTYzeFdGR2hwaG84MGZHNU9oZXVJVHpndlF5K3NSOVZkbDhNZldiOEU0S21qZ1NvOHJTK25uYmtzbGhGWmFNNitMSU1wejBvdVNsRVNGaHVKRTNuNHZhdERTS2JtM3h0NWlqSzFkcUp1OTFYQzFkZmIwOUZCTEhNaDArODNMNG8xSFdhbGFXQmZaNC9Yd2w3LzVJL1orNFdXR1pkWmx6VGpHMjZwdEZMQlhzTUI5aHA0eW5HRVZNcG1vcStWUENjN3lST3QzWmN4engzalViMEdQOWtsSG1pRE9QbGszZFlUUGF2NVBLUHRqQ0twVXh0UTd2QXZlYXpPWGdiVHBQay9SNnE2amM2RHhjWFFldmpGbDFhTjEvYngyQ2Jmb3pTTUQ3a1hOSlRMZG5lR0R1L1BrU2NlVEhldGFYaTdjeXBSK3BwVjgxbXVlQzlQOEtSclNHbCs5RTM2WTFOVVlaa1dOTXo1RWZpQ0Q1bW5zUkE3WXV5eGMydm9iV2swOHQzZWk2RnZXdlI4dEN5NURsb0dYMzJ2eHhtZkp3bmVQWFRQZHhyM0JyTnRrcmp2Wk94REg5VE00b2c1RExHSEdiTFJranFyTjNPZUJNVkZPSEtCSGF5cnNodWx0SFNEK2k5dWg2RDZxSWZNSGRLdU1RYmoxT1NFbjhnVlN3K2x1N2NTTTU5ZTZYNEJuN2lENlM2VE9RWHVZaGhMalk5bFhmWTFKbDVQMlhRWjh2RWdhM2Irem5uL3VFMnJQTFhQMFZlYlo1N1pkamRWQ1ZDWmhodnhBaDdPQlhLWHVqdWVyWW1BdWhyelcxUHNoS21sS1ZtVjF2YjZNNDhWNStLVWQ2ZjdPWTdVQ2pxKytlc3Vmc1JlaXlVR00veXREc2FaT2RNUG9weEtKbktDTFRkOEV3bjhuczlhSzZOaGR4VmgyU2s2NlZ0N2YrMGJJWGFxL1BZOFFjeVh4czdOdUN6S0hvMW1nU3p3WE5yNThHOXU4SVdjNGlQWFdHdmZsYUZZdllLVzhkUWZ0ME9pT3I0YzBlOGNYVVQ4VFRsblFTVGlHeXZZVXV2QWdobncrNnQzWmZGcmpzeGJsK3N1SkJ5UnVURDM4TThGbGJmeVVZZmt2a3I4SmFyTHl4ajVoeW11Nm9mMVFnVjhLZnVmTGREeW05WTZNblFxT2x4Wmc1NEdlWFBZRzNWMUJYVmxUNWxlNmJUZGNDcFltMThad2VXZFd2UFhKbjE2V0FZWkg0a2JLUnVGWjhzRzY1STg5VU5Sd3R1elNEc3l4Y1NmOFJyc3VURWZ2cnlleFZvT2pQSDA3a3l4NWFyTnlQSFAxaUdDRTRkeHhvNDNVYXNmd2pzZ2toYjQ1aGY4OVk5czU4MUR4ejlUZGQ1MWtOQ1RReTllK2IwZHRoVjI1SGp1WWo1TXV4YlFrK3FYNVQxaThyOWszSStIT1hzYlE5NldPeTErVnIvVFFBOGsrS2tiYll1ZjdzZVdnL3pNZjlMWDFQN2ZnVlZGMzY5bktxL25vcnVsOG4wN1h5MVhlV2pldHZZNlpuZmVXK3hzS1ZnaWYyVzRjTzhlbDVsTEg5aS9qaU45MnpMczYxaC9lK3hydlNlazMveHQxSnlPbjArTTF1dXNGSDg1a1RsSnpONGpGSHU3TUlUOWNnVGs1cDVDRkRlRTJlRzlkZU4vREYxRStqL24xM2JzVGZERzliYlVtMTBXTjVXcFZ3VnBCbjZrSHU3N3dSNkg0eHdZa29pMG50YTIzalcvNVFNZUswNnJUQ1UrcFJWK2pqR2kxUGRzSzErTlpEamxxR1U2YjFwZFRTa2k5YnJ4amhTY2dvd2ZDa3hJZVgrMDVaeVFsLzVMV09qVmRGalV5QTNtM1QvZjA5djJCbHBKdjdrSFI3bUZjN1NETDJ4ZHVwMzFuR2Y2bkQ5UzRZSzk0c3dzc1duNVg0U3M3U3Rzek5VR3NPdFUvRy9oMU10cVpjTlQvbnovZjdEdVRPK3pYTmtiU0pNL2d3WmVDWVFuazZ1cno3WW9UTElrWmFLNFBoYlU4Z2Q4N05mcy95bnN6V0thdGtub1hUZjcyYkZjcXk0dmtsdWxJT1NTTGlacVQvOS9GdkZqcHlpc3AwMXlJOWN5bmFFYjBkaDhwQTZoaXB3NHo2RHVJdFNiMHFldmtqZ0V2TExwTnY3VWNhd3crZUU4aGVhQ1h6ZkxmRTA5TlJXNGRZZlcrUElZRXlrUnZzM1dOQTAwVTJ2Uk9ZRjUxMFNMOVo2YXgrMitlUlgwb3RJbjFyTjhzdXN5N0JqczlHdUpVak1uVlFEKzNkUERsQ21xeFFsVE8zU0tXSnFNTTd5czVvbWRzL2hnL3hFKy9ZL096NEg1WWFMdFg5bWhheGltL1dvVlZIcTYwNisrL3d0WWY2RDJGV252ZGxxSEo1MzlTN0g0Ym42dFhwVWpxMzQzTWloTXlnYTk2S2hhK3p1WHRRRVFkYll6OTMwZFRRREZWamJFVVlhZnYybmUzVm9uMi9MVmxhTzd6MlBSeG5CMFJtTDhxL2Z4bHJUTVFGYlBmdzY0NzBMNlhLMWF4V1dwUmoyV043Z0doNXRXekUrVU5hRnkwWDNVUFM4bXBsWjZjc0x4eWhkK01TeVJ1a3ZuMnJhZXByeGI4bWI4U003YnZlTXFOeGlEcTdJYzZTKzBCTGszaFRjdmIyUnl0ZXB2UHl0L0lTaDBqSGV2bzRhdkxJTFVDM0xhYVYxekVPT0hUSU1FR2poajZobE9FbDJTNnRWWVkzLzVDVnpOZk5FYy9Ka2VuT1ZISWZBckxxamZpVkd0NGpHNzZZK21sc293YWR3TVRIYXMrZ2lOV3dlOThRZHRwWDBLdENlaGFReFpWMnBqdUxscldpVG1jdnZ5L0c4eGlKeTF1UGxobkRuZlpJWU9sTTVLY0FzeWFnZkpxejFybjNmZ2d3OTRYVVZRUHU3Z081czM3bWluN0YvYjZMekhNNTI0T1NaZnRwZXRzNHVsVjZkemgrOXdUcjN2SW52VWxRN3RoTyt4K0dUWm5EeGZJQlBPa0ZqRU1mZDNneXRiUVpDSit0U3k1Y2xLRCs4UmV0bXp3UGRrVVpVd1Rlcm8rdTJGc2hxN2lpSnlNclRZdlo2UWdoZzlRL2ZMM1p4QnZTY1pXeTBqeFdxYzlHYm4rNDJUSXUweTByNDJuUDhLL0loVnhwY0RtWUNMa2hnWWtaTXNBRmpwbWxHbUk3U24ybGxrbnlrS1lzby91UzIwdkN1M2VPeXk0NlhrSUJpbXp0Q1dvNW92dVMzbjdrcCs1djNQR2VQbnd2S1RmQzZkTzhMOWpEeVRYRFdsTnZyV2RYYndxaXBaRzBoTUR3a2NiSE1WczN0QTZVdStWUEFjam4wNkczcEJ1QnJxdlBVSkhTdm4rbFdxWXVXVTcwbWNZSytHTHFKN0wyZCtzdzNsdlhYaG9rdmd2TCtyUXFoVlpFMlZ4QjJpRlNIUGR2Q0FuUU04a0dSV3VuU1BUK0VDTDZhaWZ5bUFNSHZjTm9mQ3N0bVBkd3RMbjE4NWhuZ3VUM1FxUkh0WEtLa1JmZHRkVmtJVDFiOWtsM1VaR0JqbHJtSHZiM2swVjRPYVJEaUxhdHpLM2ZiNFp5M3hDMDRqMUQ3R3NCZGNLU3R0TWVOZmhQZHdva0Q4dlg3Mi9PMEltaklCT2l0eTRuVEJyNVdaS3VvcUwzWjkxWDVIN1BYcVZvZGZQcThCdHZmU0ZsQzg4aTRNK1BXMXd2NHYvVDFqK0N5ZW84MW1xM3Y0OXNoQ1BJdXorM1I4N3UvNnRCeGxwS3NZMkVTUHBGdFBhU2ZzeVFmdCtXZHl6ajhVcjRPYll2b202ek03dFovRGFXODdnTy84bFpvdjJaM0RLUDZhTHJJOHU1U3lMYytpbEQvVU8wWk1pSU1wcS9BMnM1V0M4RG8wMnJ5WTdrcStzZzh4YnhieU03a202WFJ6NGdMa1lWNURMU1dHSWpic216ekNMRDgyL1F5QlByUTFiWnFKN3N4cFAwbjJocmdMVHcxZ25vWXN2YkI3RFNhMmw2ZmJoV1hUMTk3RTBPNzc1VG8reG92eGIxNmpqdGM5Skx3dS83VlZ1OUZLL211VkdDN2ozNjNNU0xJT1MrakU0U1MwVmFhVnZxYk9ieW9HQXJFcTlNdVI1Ry9JaGsrQkdITWgzVFlIM2dyTG4xTHdGOXZHZFpDWlRqRk5seThiVDBOVFAxTlczQUNjenNRTSs5OHVSSFhGWkNDSXk1TTE3YktYUlo1NVZsMmFtMDMrZXlVa0Y3Wm1sZnRUUHc2byt0ZXZkZlozV2IxSEFrL2hKN2h2YlM5ZGhTbHIvd2w3S1cvSld3bDFIY2RvZzRsbFplUCtXeGpKbzYvSzhVMjJ2d3lvaU12dDRSYW5ab0ZZL2MrNVozM2w1RUcyK3ZwM2NmSjFnRnhNK0lOSjhWYiszUFdubkoreUlmTzZRMHozL2VaQmNnL0laamF0UWVSMjV6cHUyUDdnaHIrU1BoSkVCUFIyc05qd3lxU2I0djZXZnFWb1I4YmhqTnY4bHcwbWp4SERLa0cvU0JtVFZaZ251OUdxaGJqTXF2M1dMT0NRTTZFc3VJK3BWb091MEpPMTlNL1dTMEJTQTVIVy9SVnJOeWk0NjhLZXp3TlVRbTVnMzRPcWYwTFc2WVJ2WVRlWHVWdS9LWkdYa1FuZnVJUXJPV2ZxUGJISmd5dFo3cHpPZXNBZmNtSHJVNWxLNm8yNHd0dGJQclhjQ3dTUHhJK3Q1WlZJelFlSHRlcStLL3phQmNPZFpPcGpZUzhxblZrbXFEUXAwbmFJZXFBay9jckRSKzNsbVBKVnA1clNmT3ZiOFVTa3E4SlR1NjVtbmxXN3lHMG5iS0Z4ZjVEclMyUHlLL0tZdnlXWmJoekVGMHhhQzljcUs4d3lRZHIxL3JZZC9vWFBrMkw0eVEwL2x5WHdKeHA2ejRibThTYmZPQTRKbTZjdTdxZnd6YWdCTllPWGpRK043SlJBZ1pBclpITFJuT05SSVRTM09WYlNpaFdHc3ZZcmNObWJ3aVN5ejhtSEQvWndiVE5wL2hlZTFRR3NYTTZybVYrNVEwUkJoZjJrN29QaXlIMGVjeitsZ0JaZVlqalFXTWFuVnBHMXZXNXgybTFaZHZyVndERy95dG1ib1ZVZnJpNjNOZE9aekl1NEhPSVdsZk9kWXZobnVqeTVqMXE2STZuNVdXTDZaK0t2V08zUTBuSS9vVE95dDhpQnk4VG9GS0dBcHcrM3JITTlxNXNXeUl1MllqbVN3bk11WmF2eWo4Wm5yYVpMQXRyL1IzUEoyd1ZtZFlkNDVvTE5ub25xd3R1cmVWSXkzUTA1cm9Md25Rd1lZK21tdmwyNDY2ZW9SWmJTYy9nVE55UEpaTGUwVDJqZGRJMjJ2cFAxQ1JpbUd3QzV2aFdHaEg1M3lkUGFvYzdGdy9Ea2pwOE5rcDJLblZPazVOMkNCWC82OGxGRFg4bUxlWUpmODVoYmwwZFhSTHIwZnY4d005NFdvbzJSMTA1WDIvY1p0YlF5MlF0NGhyS0d0UlJRMkRuWmEvU2hib2R5d2ZKNnZMaVBpdVo1UzV1ZzRkODFzZXBTcEVlRjlVbE81bTVBdElyN1MvZGFqVjUzcWliWitkY05RVzl0akdES1JGWlVheGJMNzFjNG1tOFp0VEJTVE84NHZSdmNJVzZCSlR6aWtqMmhLbHJiQzFkRTNBcFRuQzZ3dXFLMmFxMWxFZDVSUjAza1U2dm1jdVcrblE5YTRYSDlINXhaRXhLNTlXdDFiN1cvYlpsaTIvSkZORWVNd1N0bVc5d3ZWY1h1LzJ6QkowVDNDa0RQSmhvS295TmpuNnlxalQ5NVlWclVOa2dscnBTc0xVbGdkYWRtbkxrSzU1anlXUlZXbFpqcFlsS0kvLy9UUlJiZ2hKZ1A2cTF3M29EZXdxQXNUbjFLNExldU1Ba2RVQkNYSkdJM2E2bWJEc0RjVFY0V0FoRjNIRzdoWHEyeTdkamN6R3BLdnQwZE4rNVAwQlp0bE85eXVpMU1GRDlSNjk3M1BzVC84VDM5cU5zRlJqVTJWdVgwcTE5aUt5ZmxtQTdhb2lybDc5MjBackRYMVhveHp5RERzaTBETTZaQjhqNG1tMlBNb29HWlR0T1lGSlNTY25ybFYyVkRiUzVpamUvWGN3c2dhcGl5NUFHaXZkNkxBbTU3RnF6YTdKSE4yTFNBUDVKOUN6eGVDbGFZVkh0SEtrYkUvV2pPMk1ocWtsQ09nWUgybGt6OXl3QTVlejBtZlA0Zy9wTnJlZTM0KzZFWVIwMFZyQ1dIdThqcDd5UFByVzJ2U2NOZldYWUMzd3RYUXBzZEVYTWRxczFvNENYMHo5VkxhSjYrM2duVkFGRXFjNDErVE44VmJpdlhuSng0SHFnbnZxRE1zOXQ4SUJ2bjc4ZzF0MU5NRGZTZDN2SzJ6SjF6b24xcndMUGdRMHAyOU84TnlHa1kvSiswOWg3bjhaVHJhUGRwK283RHNOdGtsMTBmUjA4OWVRVVdadkg3d1JLNmJVUWp4TlVpYjJSVnpXeUNQS21hd3VZMlJ4dHFMTWtiU3JLR1ArcGNoWFNtQ0tsc01mSnpKcnp2VDhnR3NtTGZ1NzhnbTE1TTBVTklINTdHVUN4K3gzMHRaWCtlSXh3YTFqUWk3aWhpWmh4ZVBmNkcwK3k4NTdHVkttVmRidStzUTJOdHRyb3N0NnBzZi9kYnp6VmdTeU5Vb1hsTnlFTTNhdmVuemIrZFBUa2JpemNVV1BsM3RmaDJjMDQ5eDV4NzhvZjBXb1gvTXNUanI1R1BUMWdtblpYUjhvKzN4YTJwODlTK2lIekhOYTgzVjRVbGFlNDYzY2w1d2xzL1d6N3FzTTJaM0s1ZzgyZHRDM2VTOW1PQUdyTm8xYkw4eGRNT1ZtL3RyQnNsR29adk8wTS9rU3VKNThhMDdaN2lqdDhNenhRKzVPWXg5NlJPUXE5YW10RXI2ZVdSc2NiTXh1MFAyNG5pYm1pNm1mVEZhdVMrTjZFRzJCWkJWaG5XTm1oVStsR0pXeDRqWFF0aE0zbHEyeUF6Zks3YXNQb21mc0VSM1BBaTVvVzdUN0l0MWNxNFJpaENjZ1hLWTV4bHRiV2xvYXpaaFlKU0ZocmZBdGVtUnl0SG9DYVgxRWpoVnZ2YnpXSTh0SzV5MkRxcDJDUDdzR3hTa2JidG9PZ3lYcjlIeGNWeUNKclMrNzRiYXdiL0tQM08ybCtJMnF4Ny90RFMrbWRWU3lWSkhabWxQSWpvaG54TWJ6K1YzYi9sV1UvNlZGcEM3dE1qN1B5MjJ0aElyZkhNL2tZb0lXSjkzVXI1T3RWQTVSMlFIZklCdHRYNXFYYlhFcE9WOTF6UFpwN0ZncHFhNFY4blZUZE1iSWxyYStJblovWnVtSU00eGhqNCszaW9uM203RStRUFoxcGoyc1B3N3czMzhhOHoxWGYzUk4yMlg2dHFzeVlMcVM5RTNCR2JJanJKQ3BZTjBtc3NpV2FXZXFESzhzSVRzTDA2OE9QZG10VmoydGVDSGJDdGVHKyt2THFIb1pQL0YxSldiT0diUHdSdnFhWW5Ud3dhY1BsR0VYdmk4akZCKzE5cEtlTWowNTJaRVYzV09Tc29xUnB3RDFrM3NPZWZmdjhXdW5MVDhyR3oyaSsxSHlpem5lVkd6UjIrdDM4RHJJVFJsMXZKREJFeDFZSzF4eGRPS2h0ckxseFBhNmJvTVRzRHovWjJ2alpHd2hISnE0NGJUL2VJNmFTVFRJMmFpajRRSTAzZW1TbWw5bzJCZFVDelhDNVRyQlNLYktVaTViYmxoVUw4K0F1dDFoUmdQMWJsK1ZScHlNMThKTEZSNXhKQWk1R2IwbTg5UXlEblpLMjF6UzkzNXp0ZGRmRkZtV1RibWozbTd2Uis5YjJXdHp1ZVlxSGVtc010eitoaHlKL1dyL3VjWHdTSDdjSThuVi8rdDIwTmVhUlRnZ2VWZnFYcWFVZFV3WFpkYnFzK1hseVBDaVhNOGE1VksyVmJhV0p5bDV0THBaanJFM1kxdjNuWTB5L2RtRGhSY25mUWZSMjAxT2VpMHRJYU5jOFVnanlPaFdSSDFkYTR5U2JFM29NVU1qby91T012MmRmWitQUVd2ODNuMjZFOHdOd2VpWk82Yi9iRVI0Ym5Qa0JWVnJqOHp5cmdoeGFibjByZlRHSGpBeTloRGJyS1ZIYkx4bXgwbUZ0eHorOHNicnRRbEp5V2ZwNjVud3hkUnZRNjVhRm9qT1J2akhRQXRCVnZGeGs0WDhvY2V4UklkQjZVNWphV3pTejVsdGVVWGZmV2FaeU9PMmo4QmJhZFAyNkR5ZlJzc0hpQm9qVzJseXJGOHhNb3NUNjVYOU5iTXBBTmdtYmhPQmJWaFd0UFdkK2k5U2w3bjFSazVLdjZLdGV2M0Y5M2tSVlRMN3h5eG8rTXd5cnFBNDEwNldyRVIwaUR3Tm80b2JPMnZiVys5YjZOdWVPcGdkNjZUdmVYVFRrbm5DbXNMYm9IelRaVEJtanpwbEI4TzlPQ1NleklMN09sRnNOU0IvTkx5K0htZks0WndrNVAwNTA1V0orQjJ6UGRrenY1eUtnUHBKVitoWjZuYUhNMzZCUFVPV3RmMDhZd2xHeU1XY29hZEd5empvOHg4aktKL1lGQ2h2dEt3N1VRSTdBUDUrd0crS0RLYlQ0MTRnVDg5ZUNjb3VuZmZidGVkN3lMbnQvMlJWd2t4dndESUdTTDdXdFNRN1phZU9PcEE5ZVZMNG0wUC9oYUNnNXVkTnh0Uk0zOEM3L1hkY0x0eHN1VS9JYlptNkZWSGE0ZFlMcXBrdktwTTNoaXVaTjRNUE9wdU0vaktvRmI1Q3RmUEYxRzlrNFI2U3Q1VmliZEZsSTN3SjZBd2ErZTJkdnhzTEZVaytsT3pFbFVBNDJXTXBsOGprQ2s3RUFtUkRSSlZrVno4NVpmUzlhK1lwdGRVcnlkWTJtbXhWY2VmUWtlMXkwcURLM0hPLzBOWkhzSHJJczVwTzN1YVhZN3o3YU4xdlNXT1dxdjBnTWpmeStLRlJKWm5WT2xITmtnUFowTVN0NlJtaUZuUjRKSjVzL2RaQ2p1Lzh1SXBYOXZkTFFaODRNMUNkWWRrbkwzM1FpWWhrUGFqcmJVeWk5eE1aVTVQdmQ1ZG5SRWFVeDMzblkraFB5V1ZmQTYxSnRSTWlXL0dSbW5raGNabFh6TnN6Rnl0ZVdZdm43UktRT29SK2d0V1A1Z283UlhlcEk4bmp1TllzOG0rbnVOcWVMV2Jqd0k4bG1LVThjcVh6NmRXWnJYVGplcVpQanZSNUZoTmJkTmhOTnJMOGkwNWJVUWR0WlNiSHJqdVduWGgzM3BaR3VxTExlcVpycnRkVG45TFlURUQ5Wkx3QXV0TzdRVE9kTmpCUU8xU1V2RWk4VmordnJDaTJWajNHZTVPaWxSZUozNDN3S3F5MW4rUHRkdW0rUVAxVlUzMVBBZGt4S2lMOVM2YVZvMDR2UTdlWXdDd2c1SHhHQmlnNndGZE1BbFFtbWs1VFYxRjA5UlJLbHh1eWEvdHI3S3EvUkFMMzRLYkpTZDJHZnRiUjhpTkV1RnF1c3daL2ZabDlMOU55bjQxZzExdnVjT0hNY015S2tSRHYzc2kxanF5WFNYUU9DTGwrT2xkenNtc0x5UWdlYzZ0ZXlxRzQ2VjY0ZTJiZzN0cE1XbVZLRldqZGR4YU94TXYvVUp5SUt2eFB2bXlWN2ZUZk1XUXY0MldPZEVGRmtaQjJkU2xWM3R6SUlhWFpkV3A0ajJudjJKWmtlMHpKQ1crVmdlTHRsWXpOSHQySmwrRldIZEFaM09vanRDMHRaRjM4M1l0d0dUTlV3SXloUUQ2UE9VYndxL0FzUUNzZkV0NzJJN0IwTWoycUlUV3RTd1pCWEFLcll5MVRoNW9iOHBZTVBjLy95WmdPWXlQcUpSRVNwbmZqdFdQd29kdHk2SXJzYTVqcGNIajk5cVZLQlIzbXFBK0hkbEZVRmw5TS9VYStWdk5kend3bmpOMzN4bmdMT2lRdmlhSHRvZDhVeEtrdFR2aDdPYmpiSGEvb0lDNXAxL0ZHa3lyQTI2dFl0RnUrM3BhY3VjMk5HSDFyZGUzOUVpbTJ4Q3lwbUhmc0RaMXpYMjY3NHdEdHJSTzRWU1YvZ0laVUpWc1JDSjRua2F4Q2d2SzhQTkhIV3FQY1gvbWhwOGhIWkozTG5YUkZ0QzVYam84WjgzY3lsdGxwbWFVNjNTaWV5WE16WUxqdnNrMG9ZeTY5UG96blIrUkdXZFoxcEU3YTRPRmE3UXBHVzk3N2NsbisyRzc5dGpGN3hmM2VvWTF6OWYvelNtd3RBMGIyQ0FraGkzZ0RrL0Q4MGxjNmoxUDBWZTVZSmhqcGtlY25zMWFVbzNVbUFIZHM1SkZsUGdjSklVOXVNWjBoMjQvVmRPYjkrSGIzUHNxa1RJZ3g3K2Q1WU5VVzBIb0tWbWQ3UEM4TE9VelJaeHJ0NXkxWnBMbDJ4MnhWNmQrMm45Smk5S1hVM2pJWDlRRzdsa1NaL2R6SWV4eVJ3TFFYZzY1Sk9kMUltS2llNWlEN0dGQjFHejRBVjVKajBSeGk1QTcwL3RLQ0JGajg4MHExckMvclVQUTV4SWlzR2ZERjFHL0QrcVdERlRlNVNPdG44N2ZZSHJVcWtZRjBubklNM3VEaUxpR2ZRSTlCL2lhMDQ3YTBOQVdVTVpETU9veXFSNVVnc3U4RHNsMDI2QjJxRGRBcVN4c1FyWmZHYXFJUG1SQlFxd2pXcVZSaDJqSHlQOUV6ZmlvemQ4UmxZeVFYSjljK1JkOEs1U1BzYlQxczZ0LzkxM0VlcmZTeXFWc0t6Skx4N3JUVW1hVkMzSFpBREZCOWpUZHNNY0tzazdMcm9ZTnkvREpRcnc0YzBaMVJmVDdUd2lJZDNmRnlLa1RQWkp2bGVjeWlaOVJOS2piWlJac2VoR0pDclErMXZWcjA5eSsvdCtMOW1aWFNNSTJ5emR0M1VOU1JkcmxpSEovaHRhTS9kcHBwZ0IvM3BSV3QrUm55MHZnOTJHdStQTWFnNG8vbVJ6clBJNVh6Y2Y4VHJsZElQalRMMFNia3FodGpyWWNhL3g1Yk1Xb2JrVEpxcEQ2V2RhbkRVTDB0OHpVR3p4MUFsNm85WmhkMUl3ei9Nb3Y4WGFjWTU5Y3lzU1J0YmpqWjZ6S04rblRUY3h4ejNXWUZrWUhPeThqNk4xcHZiVTVvNFpIZG96U3BUbHIrNHFUVjB0UmhxSTYwOHBha1Q0NEMxczJTZXd4SHZtS1REaVh1L2FuaTFpRTNZOXBsWVhWcTVVdWRNZ2lCaUV6dlNKN1ZqT3ladFd5NzVrYWxLbS9yT2dYaUhlVmgyZnF3SDZISXNRNTNNYXZrMUFXcVJqWmt0OXpidXV5SjlIcnFkeXVEVEtKbnZjQU9KdVJKNzA3WjZWUG9ZTVB5Y3kyQUxGRmU5Nm5mY1h0N29DcEx6UzNMMnE5VlpzYVA3b1QyZkpVMUsvZi9FdzZlTnJmdFErYm4ydTFWSjdrYjV2RmEvZjIyUkZIcW1wSi9mOTd1WFIvWnVlNlJnYWIzSERJcmJ3SHlSRmUycmIwSTFIRnM3eUVjeTBxT1hKbTJ0V0R3OE9yWXl0TlpWQkpGZW1Ia00wQU05R3lESEozdWxoSy8rYmpzOVgwaThhTmJFYTAwR1l6M3l0YTBjNzhOSkNaZUJ5VHdtdHdPeEV3ZjhtRHVzMXRtQWNZSGh4U1pUdVJCV2tydUhuajBpYVVXN3VXenl2eFladmlQYUNQMU9GUWZ3TWh0ejNiZEVmNUtoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VBT1QvL1BkLzBNdXdmLy9EZDFnL0NxM1hUM2liL0k0SEpEK3hEa1JyWWIxT0hqelJ5VHRqclFCRmtqZkdHa1BzNkhrc21FVGU2U2lqK2cxUjAvaUJJeU1uTUtLTW5HZm01SFdQYm9xY1RHbmw4U3hVcEtkemlnMDY5SXdkenpySTZIS01MajNuWjZYVWQrNldKV04vT20zUVpBcUorb201OFRxMVM3MjFPbzRNYjNUWVcvRmJtcSsxVDZWcVMzSE0xdk82U3ZzYllWdzN5bmlDbnFTcmQyUTVuTDZ0aDVkRG1wSTBxWWlzTmkzSGVjWFJxaXM4NkI3ckhpemJHenFsVlk0bXFBVnFuMFowZnMzWnlrTy9QK2xXWkVkbjlwd2dlVHc5ZmN5T29sNEVNbStQYy93T3loLzNhczh0YzFUV0RQK3BWV2JFQ1ZpQWFkb2VOa0pNbnRZSmxUOWZuR2hNdHUxckNPaEpsSzk1TGNaOTJkZW5weTVLRHFzV1J2Z1dOMktuUEEvYUs5c0xiOUhyNDF4QXorMk5sRkdYaFN6b3dmRFdjSVJIVG42a014SkxXMmpaU213T1ZYS2UvMHR4dFNzLytUYWt6dERDczBpTytsTTF2VGVjR3ZuUVFlVmRXL2tUVUdaVWQwUjFBMXEyVEt2RnQrdFFsUEJlTGR6YjhsSldwT3pSRWRaVEppRXdkMWcyek1qVGk2VytncllmRHRmS0ZIbEdUb2QzeTZqamEzbU9IMkd0QzFyK3lNSHZNT3BrZlkwMTBxUkpTVHZpRWN4S2ozRG1jSDhMWmpUeWlrYjFYQjFDYnNwS0hYT0cvdHErb0ludStUVFRTOE9FYmcySjRGZXlSMW03SFZ2amk2RUpXeDNXY3FUc1Z2cFdHVkU4MThaZXF6VlVvOWkzeTYvZ2h3enBlRHlGNjlkMTJPT1BiTlFwSlV4a05sTnFhSGZhNDNsNE1wQjE4eFVyeFlDaitVTnh3bVcreUg2czNaTkhXVnA4TXNyMHdpL0NuNkR0ZU85MjZPdThONmo2NmxtYlM1QXBkK09wWk5HenZFZGxlbVV0MkZxWXNuMVJ4NU1GUkRjNldoUXdIVm5HaUs0d1pScjdjMTJ5RWswOU9abk9RWWFzSmxhdGdsRFg1bVBwZFR5aXkrY1BaSVlOV05XVTNyaitjODIzVFFraGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0lUeHhkVGp1N0w4WXVvYm9yM2VqN3dDUGVuMS85YlpZbDc0SmZRY0hSUTlNc2dwQ2psVGpYd1I3UGgrWnA3Y0Zpd3FlZ2hWU1hzZGdKeU80cDB1WnBmZGMvYktHVWRoQmM5TGM3OVFhT1dOSEEzVzA3UGVTWnNvZzlaUnRVdVB1aFJaaHNoME9MSit5VGxjamt6OTlONHp1TFdmTWdMdFNSQkhsNmhPTHVyTm9jY1Bqc3ZhNWxCdW5EcGRTOXRMekViNjF0bEhYdnlxYzhacStYV1pkNS9CWUh1WXFsTHE2ek9KTEl4a25nU21XNmlSbjBOa0w5TStIZkpobDRDMmppNFBYNk5WSDc4OXRuRE5URU9sbnVIN29HUHREbk4vWmwxbStaa25VSGIvREhINEFJWGpxbTVmcy9pMzlmWFZaTFRrOUNZZFBmc2ExYWsxcUwrQllNa0tydDJ1WklaYkZiM2RCZXJwVU1XR0N3QVA0NkFiZ2JnZDFoZFVUOFg3akN0Y1FhQ3pmc3BLU2pwTnl6aXkzSFNJVHVncFU1UFRrdytSaWRKajY5QUp1ZmV2c3BHdkFIVjRmWFZvRGxhdnQrSlI3dVFaa1RmbHpFRjB4bEhRUGZKU3dsUjl6Y2cyZEc4Nm9IanphNlZPUGltakZPQ1pobWdYOCt1dE1wMlExZnB5NnM0Y0swSU9qdzhNUnF4d1JGWWRuNXgwUFdWL0Rmb1dpbjI5b3N4b3ZKWldwdmRjdXFoYlJjZ05PRk9QamU0WW1udE95Y21vcFRYSzlLZjFmczJTbkNKbnVoc0lyYSs0MXBSRy90LzQ5cjZkeDA1Vm9vOFR6RTlFdGVwaVBTYzd4bXRwdlBoOTJ1TmZkYzVreHFOR0l1ck05ckRKK1ZkY1g4R005a0E5eUpac3J3d3JyemV3RitJTnNRTGs4YUJ2ODVtTUduMWtTclhHekFxMUZnQTFSMWErcEtUek5FZEVDMFhxMUp1MmxaK2NpRGVvdkhCeUs1QTVDSzhMNUI2WjNEdXozT1RBK09CUUlzc0EzZWZlMVpKVjFJaXQ1SHlZQUJ1eHlZcG5HbWg4eTJmbDI2YUVFRUlJSVY4QnZYVkNwc0NwUkFnaGhKd0d6UzRoSkVTK2c5YTRvZzdVbG9RUWNpdW9sZ2toaEJCQ1BnYTZkcDhPZTVnUVFnZ2hoQkJDQ0JubGJ6MTR4bmxwNUhKNlQ2WHk1RTBjSGlzUEx3M2pIUzJrVmM2cXNIZFVNS2NZcVdrZEh5Q0pIbVh3clZ4NEFwcDEzVklodVpIUFN0ZkhGWnZxNlBGYmdhT2djNk4xbjhlbVc0cllZK1Q4bXRZUmtUT09Cd1NQcEh4R1YvR0hZL0NMTG1McUoyNWlSdkIxZC9xSnNtVklPV0puRk1wVTZNbEhYNkdXbzBkQ3ZUVTVucVQxZVFjSVMxZEc4dmFlNHF0YnFQWk1UVWFac2k1MXZLZVg0YlA4UkZuSktEdmlZRjBCV0IvemRxKzhud0tFeVRaSDYrc3RzRFNDL1p2M01sK25QejdzVGJIR2xzK2hGZjVmNWg5NS9rbTRaWmMvUCswU1lnUGJSTHdJRzY5L1crbFM4a3REOG0xbFJtWE5BTlZiVVU4aW9xLzZ4NlZkVml1dGtjNXFocFkwWVNOTFFIOGR2MlFzN3FPa3BtenI0d2Y1R1ZuSk9VNWdFZWJVKytBTElMNnBSbXVjSXpaY2hrZlhZQjVvSFc2QTVZYjB5TERvN2VhZUtvaFRpMU9yT3A1cHZMTGJQSFhVODFYNDU2ZmJMTjBWdldIUHI5eUNFRHMxNGdQMTJyNVcvYU5vdWdMUkhaWXRkUFl6ekxCV0hXU1pjaTBpSmVaZDZuM2M4Ym9vSWVYZ3F5V2pyTlNNbCtsU2xkNXJPZXM2S2JMSUczQm44enFqTHA1ZG1sbldhQjBrMnFScnFWMUVYY2w4YUIwNjhQeUlnNTU2QkZoYng3V01ySld6UzZoSFJyWTVacXdrV3lEcFoza1JHVXlucFlreXd3TzROYjN1Rm9LM3pJL0lzZkxWblkrc0daQTA1S3V4VnYxM1lMUStrU2tZdFJsdW9TS29JTnVWeG1NaTAvWWQ0c3RCdE1VSmJrU1NkZkdlR21sUGhmYnBzTnBvYXRnS044ZUk1L01vZFRsK0ViWTQ4VnNxNjc1a2ZubmxHUWs5cDU0TzhTd1NFTGZKR0hHYy94TFhQYUQzWlhsWXJUMlcyWFd3Wm9BbHJ3ZlBzd3lLYXZrNjBjMEk4dDdNMkl1UXRsQ0xSOHBBeDVobEpON1VaMjVwSzIvRzkxcUNTRGVQcmtsYjh0NjB5NjRuT2tleUUwOXV3V0VlRy90NHFLem1mbDc5aU1zVHBGeHF5NkZkT2JZSVF2WWdmcVhuUitSMmRES3k1OEUwV3ZwUk9hUUNkWDYrbEpGVnY3Y2M5SnBXOHpkbFdmeGlLaUdyb1dVaGhCQUFLc3ZQaFAxS0NDSGt1N25GaDlzSUlZUVFjZ0kwK3VkeFpWdXpud25wNGc1VDU0bzZVR1VRUWdnaGhId00zK1BhMFluOWFOaTloQkJDQ0NHRUVFSVdrUC96My85QjV5cjgvUS9mWVgxTHZDTW9UampGeWpyZHg0cTdEUFNvb1MwTldQbGROdWZHdmNQSGdrV1R1OUk2cHVxaWVmcTFYREM1WmhhQm5IaTI3cllpNTY5WloyM0lkSkxjTGxNN0dxcCsrOE1ValpTSmFHUXRiMDh2ZU1mN2VPbEZQbWw0b0NPMHZQdUwxbEhtYloyMUVwYzhPcTdSODFYZlN2MGlEbGZQamRIeDBDbnlqN3o3NXpYdm9rY1FSZ3lUMWNGU1lrVC92T1RwUXlvYk1oRUh1azdiTTZpaUEzaEViNkd5UnlaWFoxbVE4YmQwZjdUdFo5elhiQ1V5c2ExbGsyYnN1TDFTMXZYejYrdGI3Wm9jYy9ycFh1bTllYnhTNmErZWw2Z1hNYnZzbFdWb2ZoUmk5S1B4WUYxQ1h6QjhsQ2l5YUY4bmhsMVc5RDRNMVFtUmcvZnBGUjVxKzE0OW5UcksxTWFXUm5IaWs1TlBsdm1tUkZRbTJyUmVHWUZraDJGYnVhWkZXeVlhc3JMNDQzQ0NjZ0hLZHNKaFZxanJ3MUhRUFRyVG1LZTd2WWpXQUZqbFI0ejQxeHNSTzJvUjFYM1JQYVJXbVdoNlRJcFdCN3VsTng4dTczS2lyZEM2K3pvY2tXV2xYekdseUljeU1samlpeE1zN1F4MzZvcEpNRnFtcFNJbHhVOW1XanhMV2NqOGdLTDZzZjBKUUpSMVhDL3NrMVZKRCtHSE9xUjJrU05FNjFDQzRacnM2SlRxb2RlTHVBWG9Namc1NmF5OEVRZDZSRC9WOFlTOE9XZXZUS0IwMW5vMjY1ZmFveDIxck1pU3BRUHI2NXg0L2w4Y0V6KzZVMmcwdzc1MFpFMlNtdzZHRnI0WHRxWDRTK3c3d2wrRWV0WmhqOVlIeDdiTnU3Uld2Q1l6bTlKckNacFVHUjR4U0pac05FOXZtU09NN0lHMlpGNi9GOUdXSGQyREdRQjFWcE9TTG5mRWs4OGh1Z1lmOGF1ajAvUkVlbThMWFEvT3FFdFVCbEtYbFpxUVRNU2JwK1EyUlBiMEkrdWgxck82UE1IZDRGQWlwNUhid2VoVDM2ekV0ZkszWktIcHZucWVlRXN2TFQyWnd1aHpsWjVuR256YmxCQkNDQ0VYY29VbitXWGU2eTArMWNZVkF5R0VFRUlJSVlTY3phWEx3VzlkQm1idWMzd3liR2xDQ0xHaGppU0VFRUlJSWU4THZWbENDQ0dFRUVJSUlhU1h4eGRUVzhkaS9JYnppNmtmQ25MSTJvRElXblNycUVsRjl6RlNpZDVEMU1wNEZkQlRUOGlOaVJ4UkdUMmFnK3haMkdZOUI3a2xKVTlKOXBEd3lsaWpROUZTWjhnSFQ3azhWRWtlYzlwemJnMm9xQS81dlhSYjJ0VVR0dFVQcFhtNXkzOFlSRFB1dnc5c1R2bSs2ejYzSlQwUys0YWdSMEY5TGFBVFZ4OGZaK21kdzdIYmdJN01RcmFhUUpTekMrL1R4MFg1UzQvL1BjbTVtSFBObHFFRG45bVgydmZiRzI2VmxaVDB2Wk1rYWxNYW9GbGFuekE3bFY2YjUvVmpNdUk3T0V3WnZXeXJLYlhVdVpLRmZFblYrbHJwY1RidjA2MVEyNjJUMm51a3hmVkJTdmRZQ2QvQktNNDZ2N2dsWStaOUNyMWpxRDVFTGYzNWV1cHU3Z3gycjJVWjlYbGJ4UTgxdmVVRElMNnFGMTdIYTNqOXJhWHovR1h5ZzJlV1d1a2pMaytkMSt0bUVWOVdUR2VuRE0zdGtLY3QyeDl1ejdoUWxOYm5XclZ4UHROZm12VkoyT2M0aUF5YW53eEF1cFcyRFowVTNuNlBsYStWeHBMbDZXSHBoKzA5cjZLVUxjT3RMNkphTlhxRmUvZTl6LzhxMjJlV0YzR2xKMFJPWm1XSHQ5eU1xd2JaN0tWcVMyWjA0aVpSeHF3SkxlVXFzaTFYSjdTcWU1akNVbDN2RUdWWlgyYzEvWkM2ckFRMk9haWd2ZTVOUnZZWnpMVFNaMWo4cFl6cUk2dWZlOU1oWmNIN2RVcDZ6N1d4d053SVFwYXpVdWRZSG4wUzRXZVNzMXcvQUFpYmhqL1J3TXNDVFgwWTlLdWVJNjZPTEN0U3hzSE45SmFCMlM1TERRZjB0ZFZHR1Y2NzZsSmpLOEdvSTlreVNLT3J6cUxJMDlMTkJMMy8xaWowdkwzWmV4RmJYS3NNMElrTjArR0l4TFpZc1BVZmZaajdNVEo4bzJWSVBGblcySHF6TVlWcVJPUjJaVnBFUml0ZENwVHBFZTBLcW9hTG9aNytDalMvV2Z2Sm0wdGdMeTN0a3hJeUR1cXlPK1BVV3lWc1lZaEw2K0c1elNTOXBVOTNKNkpqckVkZlczTUY5VGYvd0xkTnlXbFFoeEJDQ0NFWDhqV0dtQjRISVlRUVFnZ2hoSHczWEJjU1FvakpGU3J5U3JYOHJTYUJwcEFRUWdnaGhCQUFPczZFRUVJSUlZVGNHcnJzaEx3Rmp5K20rdkNMcVIvQ3lJRm5FNG9jT1N0dUdUMEhtbms0UnduMUhDNUdQb2pSbzJNNE1IeE9iQ1B2bk1Mb0daY2xJUE1jWGVIVnhzdTM1WTBjbCtpVWlYN09wVmwyOUx5NFp5Rk9PdFRRV25XdFpRU1BLcFJmbTBwS21lSEIwalBLdkpHdXBUK1dnZlJtdkN4TlluMnFiYnZzVnQxdXlZcUtvc1AzVW5yMTFvUWlMeWpzZGJmWS9SYnhsNjZkc3hwL3BFY0hIc3ZBd3JWMHJiSm5XT2FWZ0dVL08vaHhQK2JuUEoxNDhvdmxqcVJqMHgyczhIWktQdmhsVkRuWHJKUjJCZlZRZStic3YzQjg5SUQyTnUrZXJQUTdaaTc0MFRKa2VETGkzNGlHRCtDNTZLMDVKTCtjbXF1dkhaYWU3dFV2RC9VN1IyVkd6N3d1Z0F4dzNYUWdvbzlRb25WNGN5SWJBTDJJN2owVTJXUHlrYzJJcUV5dnlJeDlUWHl0NmpkdXpQV2I1Tkc2SXo2cmtBbnZSVVQ5NFFGbENlbXAzb1hnaUwxRjc4L1RQekU5cGZsd2U5OXVuaGVoeVd5Rnl6aU5oWTgweUtkdzFyVFZXRG1BejJSMDIyTGw4cURUajJoVnlmdEkrQ0VlZmFnaHdnL2JIOGxubFRWdXlRYmRxaWVJMWUydHl3dytVdmRmOTBnRFM2Zk5rWmFiUmNoTlFJWjk3MVR5UUpkL1pjVThsbm5VK1l6ZCtad3ZvNkxQYm1KZy9adlZ1cU1yelVOL0szdUZub3AweDB6R09yYXYrOUYxOGI2ZnM1a3VOV1RWSUN2RU00M0dUR2ZXMjN0QVIxY0t4bnQxcXZIS3NBaU5YQ1B2Q2YzcU5YRUM0OG5uTStvdm85TldFbFdaTjZWSG0yWGwrdTViRVpFeXFVWVdnVFk2TytNV1JEMld5RStDM0MrbGl2MDRNOTBXbm83cFBlK1lrRzY4WlVFK0prOHBNSmVNdnlValQxNWxQR2tRZlVENlpZMjY0cG1HTmNWYWN0RTY4RzFUUWxaQmkwSUk2ZUQ3Vk1lM0tzc3I3cHVHaVJCQ3lKZHpvaW1rMVNWa0RweExoRXppa2lVb1ovQjVzSzFYd3hZbWhCQWJtbnhDQ0NHM2dQYUlrQStBRTVrUVFpeW9JUWtoaEJCQ3lKM2hGMU8vRGVUSWloTlljVzdaTU5ZcFRUTVBVOXRFUFdTNUh6NlMrVVRjUmQxSFZqRXl4amdZOXJUbTc4bVRwN2Vvbm9QZmZMVzE0c2dyUkZraVpRV09WYmVPYXlxV0xLUTFad3lLc3daWHl6b1l3ZVlSZkVMVzFNL3VSTUg2WW1hSnI5R3JuMTc3dHFyVk80TFFVeUlFeDNUcUVJZHkxWkdFK0duWnh4T3U5Uk92RVVsMTJYYWFtUVlaMUlWVHlxcmxlR1ZOQmpHekIyYWRtZG83RnREenQzckxHSzFMRzNTdDlwc0cvQnBjdEE2YmZIRzloZDFIWFZ0NjdJNTgrOEpwY0tOamw4M0orMHo3OEs4ZWMrVGdkcWEyR0kzdWowTVB1YnllalU5T2VBKzlPak95aStUNUc1NVBrNXp3TjhQcVRpc2Q0aytqcmc5NmxLcGpYcjNSQVhrRzNqNmxzOCs1cFduT01hTVE4NnZLUTJ2V1RycVVUWERlVHYzYS9WbCtsU1F5b0ZGZFlwWGQ0dzMxNmFXV3BpeUh2L0l1WFZta0UvK1B2WGRibGx6bDBYYmhpNHErLy92cmc3Nk9YZ2ZOK3F0R09nZVdKZlNLalRlWjd4TXpabzIwUWNKc0pJRXpZZFVNalpBZFozYWFzM1gxaEZVUm1hMTBMVjBMNjJIVUduVVZTZFRMb1F4NS8zbTczNXlEQzVsMVdCQUpzeVJuZUV4VVI4KzhIKzJDSDBza2pORHlybmlsa1VSWlJrS2Qram9oRCtGTXU5UTdPMUFGcGRTWXN1M2ZHdzdwZXVjL3lyVFR6dkVGRVowbzNvcHdUNGlEUE8vUEgvczUyUCs5QW9mL3lEV0Z3eFIweTNkOGYyYWZCS3ZQZytNclpQdkNhS0ZwMitnalRpSmVLajNkbGxZdkpTWmpwUU5EMXh6a1BldDVrRjduclFtMzhzNEdDVFJBM1dnelQxUkpIc3BxSjMrSG9kVUI2cmNLK0JuUmgrYVp1UlRCcWNvRGFObG5OQTk1Skc1TTdyeXJrK3R3Y3YzTzA4MVFnQ3dGakQ4T1h4bHZpQnRsOURYRDE0MFRiNHFXbFBzMEp2L29jZTJ6ZEVYemFTc0ovTFVwSVlRUVFtNEFJMHRDQ0NHRUVFSnV6Y3BWVDBLK0FVNTdQNXh2YStBcm41ZURpUkFTZ0NialBGalhoQkJDQ0NHRVBBUEc3b1FRQUpvS1FnZ2g1QWY2UkVKOC9pVHl2Wnp3aGNLL0t0RDl4cEQ3bHpCU3FOTDg2TW8rWTA4NThuRDR4ZUEyQmJ4Mmt1clplVXM0ZjcxM2k3VFFveFR3SHFLenMvYmVqN2Y5c1ZEWGNsbWRlbnFidGF2b2M1LzN5dE5LNVU2NEgyTmF2VUNDZ1lhQ05ZaWN3Ulh1TkpGS3h3YTJIRU9vWkUxR25NZ2VZQ1dZWjFUM1diNXVNc1g1SE1vY1RiY2lpaGw2b0U1SysvS0VybEVXbjlyMkhILzBoSkorakhmdlpIQU1Sc0xydDRyUyt0aEZWSVkxM04wVEhYOVROcVNpMTZORWRQYkk3b3gxZHVsU211dGZIOENNVUtlMzYzaGJtMDhrTXNhc3RLNE1JNEh0VTR2NjUxSkdqMlZHR21kcURISHU3SGxOdnB6dy9mZWpzYTUvWXN6ZmVWQSt2TVhJdzFFMW1uZUY1Zi8yeUlkMDhLbWRadlpVOUVFaDBNajZVQmVna0hlb0pOK2ZBdTl5aW1FMGU4T3BGZlRxdXVxTnh0Y3h1L0s4Y0tNWHJ0ZVRoM0dsWGVyVzdYNVA1NzdXTnViajV6N0hDdk9VSS9kZkFjTWh4RHNFRm9jRVAvK29jWVN4VHFIT0U0K2ZvbldpKzN4MFBqd0RMZUtRcGVwWkRENkRudjdjK3A2S3RSYVIwdGhFQWwxLzFUNm5kRXE5UngvUFhHZ1hhUmpEZkI1M2NZY2pyelFXVUJiZm41Vm5GTTlDOG10SU4yRDBWUVo1TEoydjRxYnJaaWhBbGhCY1p6NWN1Q0NjSm9MaTNMdjcxUE5Dcm96NVpxeHY4SWVwWkJuMTk3QWVZVFBRRmM4Sm8xNzdVbVJOVDJBb2w4eGFTMmprQWJCQng1RGp0WFYydUpmM1JEelZQYmIwK0ppemY1eHFWWFlTMTlNRW5VSlh6bmFTdjMrVWxveTZQSXBzdHd5cGtYN1ZnTTF0blp2eitGZkZtaEdwODU3aDlDd1pGdzR5QVdJcXZwYXY5RHVXYld6WlRQSDVFTlNsZHZydU1yWFk5K1R0eFhrNXlOUTEvZWJSWHZCSFBkV1pOcktXSDBtRGxBVzFGajFXeEtrUDJEMjlFazVkWWI2alZSd3BreGY4dlQ2OVB4YmordXR1UVdSSHlhLy9hK052aG1TdDEyNDJvdGNiZnVPazVVblBpYlFuYUJNenFHT0JQY3F2WDVLVzF2MS9LcmN5N0l0azV5bTdkTHJQaTRMV3VXK1AxbUI5ZzJQN056djVMTi8zY0tKaGxwZW1PSjlUOHNPSWhWV2VqUXZvc0VYUy9SdTIveEtuT1lUQ0srT0Jwb1kyZWZmUDRibzdENWdaeTlUM2UyVWo5Q3lpV1IyN2xYYVVXRDJVZDl4VmR2TWd6Q2IybGV4WHQ2NEo4UkM5a1JzaFMvRjhJSkkvcGJFT3ZTcFU3NGtCTEJsbythTHZOS3JyR1RYUHlVa0g0TG5kcU1uVTVPMDJsbW1aNXdtQVZUd2t2K2NlQVZocFE4NTB1T3dJNUlQd3VyTVYweTVZWlc5blROVWFhWm52QmJKN1g2N1B0bVJnWlpFeUxSM2FkYzhVOW5Kc1o3dWwxYWwyU1c2Nm5qWENGc2Q1b2swT0tNTmtBdThrdzlkTFFQYk14YkplMEVXMGlDejBlclRUeURKWk0zM3QrZ2wxM1J2amVFMlF4UDNGc1RxNWtERlhpTWxQNlRqL3RiaFpueHQwTjZxc1dicG54RlV6bjQrY2lOV1E1SGJNakhpR0MrRmN0cm9VUXdFeUJCcG5HSVBDV2xQb1VUM3JsY2JYamdQMG5VWnRMR2cwaG1qNWl0SCtiZWxxWGVNUFU3K0JpMllGV3dlK3ZjMUF2ZEdDZWl5SFA1eDBqV3ZlWi9JQVdvT0dEVG9IeERBTjF2VklkdStGVzQvczY3dU9GMW1tTkszU2R5Smw5RnBFWWtzSXFtdzB6V3lLNk45RlBMYlJteTdwSUdYZzdsb2VhMnFqZGcweExoL2hkNkpMRHBxVENLN1VscWhPVDRkbXYySkxLc2NmbStrMjhmajBQMWYyVnR6ckdLWHpYZzhSZVo0ZjZzbVBwT3VSSGJ2OW0yN0ZvTDJqSVpnUmFWblg5MTlhaVcwZU5LdXVTdlgvVm9wNUZMaC82N25ibnorVkp6M25pdGhWeEpGWjVGOWdqOEtuRXp0RjJyNXlWN3VDWWdsWjB0d3RlNlQ1NjZoY3krZG5SMWNHWkZyWHJYVEowSGtUa0dMUG9HZVJOREI4a2FRWmtPT3FDM1RKYWFhZ0s3d3E4MlNwNUwydUxENHZXOWdiaWNWWEVTMlRsMzdpV3BITEsrWkx0YVZFNTM5OTlybThaR3F6UGt3Q2ZwMlFTeGlkT3A5aEtsZkwxWmRjc00rSVRyVHVRTm5EMVpVQkdlV1k1eXhtcnRMTW40di9ZRVhvcE1FZG5kK3M1YXJJbEl5UUJ3QXZiVHVma1h2ZHcvRHRFNHQ2L2YzT05mWHI4Tit2RlBlS3RxclQxbG1hbjFOQWR3cnF4aWtISGVaekZzeEVyampwMXBQNVc0YlN6Si9WWEMwaWE0U1dzMEJIRXpML3pZQ2MyY3djOGEwOE0zdTR0UWdZbVNoWVJOWlU2ank1dnlxdG9scVB4M2psYzdsaXJ0MHlVemZyYzlHaFpESGpjVWFYSW5yemtKdUJ2UDRqWDAxQkRaZm9PNjAzejRSME14Z09veUZySksrWERyMytkV01FZmFkQjR6RU5OSnhHUHFPNld1ODArTVBVVHlleW5yVmdGdUY5eWVMV0U1Zkl6OGl0NnpJd0F4OTRacE1zYkY2eUFqcmN1U0JiTkN4V2Jaa0VlYjIxcHFibHNYUzBycThsZy9kYTAxUHdTODNadUw2SlZMZFBSMTdhcU1vcVdUMzNUd2F0MGxzVWQxOFlhL2ZlZEhoNXV1V2Q1eVdSaytsbWFaeU8xZDNyZXlpVzRmcXFJS0pscVoza01rc3JYMFFIMkFoWjVEK09xZjNkb2pSMFZxVFdlVXZZRnQ0aHFtMHRBMTBaZURudGFyckUxeC92SGIvRjUrMGE5R3VRVHgvZ3h2UEp1blRxWU96d3gzWWRlN3ZoM3l6S1NPZjFtWjdKdUNkalJXMzJsbVZFOW9QR2JkN0hXUnRGY1gwNUdXUE1zR2VIMHcvYVJUaUllSHVBOHBOb2R5ckUzOCt3RGQyRXRDNjd3VUt5WCtQTjZNZWE3SmF1NU9nYTljZFgrOThMeWM3bmFQNnkrd2NUSWNlRWFFNXpxbDEwV2JIcjJMaTlCZStLMmk0NGhrditPUFdzZnI3Z2hPcDFvTFpEMnFrUm1Sbk9sOFg4S0R2dDE0cnUycHArUDF2V1Y1TVlxWTFhQjFJV1RjZURvbzNQWTBYSTJzdXE4SG0yekphdXE1WWlaaThuWDd5MHN0dC9RWWdxU3JxRDZOS1dXNXc0cEljcmg1SmxqOUVWd2pPaWlEdVptc2ZoVGRIUWhtN0pKcVNUTzhWd3F5TDZxU3ZlMXJLT25HWU5HR2JrSk5SSStzaHM2VmZtYjk1ZTVHdzNubTlmQ3ZYOTcyc3hvYVhyWnhrdkozM1JJVG1sS01EVjlDNWZHVmpUVDQyY3RsYVpCcjArQzZ1ajZ6VmszN3NqeUtpSkRQVFJkaXdOV2IzdGJPVlREQm5hZkY3TTA4cEQ3c3ZzSmY4Um5kSDAyakM5WVo4YnFjclJ4NW05Rk5HYnA4NUhUaVIzM2lQM1puUGZ5dnRBYTExT28vVUtxV2M5em5yVFRBaEV4TGxZb2J6UjZjejE2UTZpNnhIUjlGOE5qY2JwZU8rQmtYZlZLZWtoK3ZidmxvWS9UUDEwMERVVzhyR3dlVytNdHI3SUJ2c1l6cGg0OVhlWHpUazhQTXF6Rmt4UEw4Ulppcjl0T24rdjU3MnRlVVppUFpRQ1h2dElyTGNadmYzUWUxT1hBUjFSM1ZwZ1VkOHR4aDI3TEQ5NVpvekRHUjBWemQvemF1U0tqbDQ2YjRzYlF6OUUrUFFCSHAwSXI2aVArMHpHNTJnNnE3eWw4MTRyM1JYdEcwMkg1RGx4M0k2R1l1OXZtRmZ5R2pyVTc1V1pweDVpdHJCbElvdVJDUC9SSEZpMjBEY3VpcE5uZFovTHp2MlV4cjRnTmRxcEhzUlY0Y1Vra05adWZnOU5HYytQcW83REQwM0paNU5mLzg4VDV6OWplQzhJVzh5SUlCNXN2Z2laengzQ2x5OEtvV3EyZUNMTCtRSlFGMWZhc1RMaCt1cnlmNnlkbi9GZ1hrTkZ2MlVtODBXK1VFZUhUSUxjcWN2TVdyMll1YUxXellBUFJuKzRXSlMvUm1YK3BoKzczNXUyVHA4NzEybFZrMWw2UzNHOG1vTjUwanRQYnk4cllKcVI5VG52ZmdRNm9qVmNzVWJLTlM3eVlzYWkwU3lkUGVubDBEbDdLQzNrak1mNG9Pb2lHbXpnUjJPYVorUTlkNVYydDdtY3RxWTJVaGlITDNzTFRFWVk3U2l0SDJFNzE5ay9id2FOeG1uTUR2ZGJUY2NmcG40RDJqY1pOazVlUzlMZXY5VFhQYUxwUTBJalNxT0JtclZEUThLSXZ1Y2lENFVOdTQ2ZXV1M2NMYTYrWFpUUEdxTTJzTTgyM3VGbnM5YUxxR3g4TnZMbjNxL0xhcnE4L0loVFFMOWRzT0tWcWxOWDd5cmR0Z2lLOXNwSWI0dSs3bXgvRGFlNGFSRmsrUXVVNnZhZ3NZekVHbktXak9KOGJzbTRwRkpSTzFmM0IrM0hxVURXZDNEcmphMms2TXJCTXRrU1U4SmVXZjlpUCsvMkJZZjJsN090L0pZTjlHeGo2NzcxaEVpblFuUkVPalJDVHJGNmFJZ1p4dE41NWdBTlB2OUszYzZnS2NDZ0duMGFlMHdXY1RXTGZJL3hVSUtaZlEydC9aa1I5Qm45ZDdhT3pqcEgzSkIzdmV3dnZFL3dscWNtVmpya0M3TzNoTmNiTXl1Q083U3UwSkZGbWJwcStKU1RDYVB0N3dWNUtQRzRJeHd6d1dsT0JvMlRlNHErTldkMFN1b00yOUxUUllxUjF3dXZzaXBHK2FDb3pxOGs3KzVWamdtMDY2N1FSdnFaYmtZcmI2a2FkR2ZqU3VyL1Vmb0FjSjMyeE04SFpjNTliMTdncmZlMDFsZ3NIVllIVHFET3JHaklwcFI5VHVIYjNwOWwzcUxLalpnRytkbHIzWm1jRWZtY3dwTWU1TXh5ZXFiQkM1OTdiRzdFRlBSY0g2RWxVOU9QcExOa28rYkx1NmFWeGFtemcrdXdrbGZwZHllYTFsTnFwL3h2R1k2aGFpM3R5M3V0MDF1VkloenVvMDAwa3pPNzhRaVBNSlc5bFhhSHlxNm5XdGE0bGVsYjl3bTVHRysxM1VvL0VrYlVzblpEeEpnbVd0T2p3d2txV2ROUXB5dHVhVkFiMm5QU3BpVTdHMWZ3MDFuVEt6MVN0cHhPWDQ5V1RsRGQzOVliK1AxY3hvU3FmazR0Skt2bmFubVgrZmo4K2FnMXFXVk5VV3FuTVlvbnB3RFhleU10TDk5TWtEVUd6UUZyNlNTOWF4R1dUaTB2MnQ2V05XMlU0YjFBZDd6VkZCMVZTVDZMRVVlTnlwYjQ3dlkzbmZaNU1pMy8yeFA3V1BjaldESWp3N3BWWFNQTEhEUU5ONkhsaWpuSC9BcTJINk8rWDhHWHRQdHg2bmF0L213aDd5TmRpRjJMd05RT3FUanBVcXJtYy9ydEZVVERZbm45YThaRGI5eTRPSmI3Qks1OHB5SFJadHhXVE1vZnBuNEwyOHpJQ2pnZndyZllJTVRYa2c4RVhjRWdqMkxFYnFIZDRaN2Q1cUlPL2RWajZMTTg1SlUrLy9IZENIbVBpRnh2cFVGWHZOSDdsMklGeWpOV2FyMm9ManRsR3NITDMzNisvVHNkdElGN2xvSHFldENlTzlyWlBCMFIzYjBzV0lvZEt0cWRCdWlWeHFCVDk2a09xUmhYZjY2djZLM25NclBVbzVGeXJ5MTVHcDFsMWx3anFpcGJONnpQQ1RCVHdlZFljVlRqMGgrazlob2FzOUlkWkFNai9uZUVVdzBwbWNoSUwzaW1uekxnNmFrT00rcm56T2ptZkpzVTBSaDloZFByQ1RRWjZIVkMvbkgxd2gxTjh6R1VtMWtuRjlaeHk2NjE3RlVHWlBiZS93WWVVUWQzS09SSVo5S21ZQ3VYaGdsWlNPLzNEYTNQSTh4K0hSYjdBV2FwL28ra25qK3dmMDNKbXZkSmMyVEhLWTBmcGI0U0dOZGYvMmJyZGx1dWJuN1BqaVJtdklQMElpcFB4NngzbEdjSGxKYk9iM080S3lZSUx6Z1grdzVXdndycEFYbWxNWkgrT09MK2NCaC9DVGw0blh3TWgxZmt4V2gySjI3MjRMSUZHYWJESWJIUGZRQXIzMmw4R0t2anpsVjJuRDlNL1NhODc5WlA3bUdsVVFSVWxaWisra0R3Z3F5V1Fqa3kwWFUvOENGNnZ0cFBIb1MzSnNvR244ZklkM3lsRFBBOVIydDNpRnBrTVdSNXBpZWxzN3VJWmNpc3ovTHZIb0tHdVVqbjF2SkVVcGIzWE1uNGpIaXFyU3hlM3BHV0JZM0hXNFZSRnZQK09vNGwyVjV6cm5wRmEzUE4yRm9JSjI4QnRESDBtZ0h2am15cnJrUHlSRzg2N09Mc2ZRTUowYkY5Mm44dXp2Vk5RbEh0M1BISHFmT3BwU052a2taSHFGWFhVamRDeitBSzVuR2JYL2FsYjhicnFjWjlVY2VIM1NGTDlVOUp4MTBoU3pYT2NtOVQ2UDA2Ry9kYkk2VjN2TTQ5alhXdDFUaWZPei9QQ1dYTE1SMkgyVUNXNG13N1BycW9LazlJMVdZbTdieXZmTkIwUXRoZjk0UkN5NmZaL3JkUjJvYk1hTHJzZlBhdW95QXh6NDFBTzA5a0xYRTB2TWp0TE0zZTBGcU1xTzlieitPRnNwWmF4SFI0aWRTcHRxYzR4ZkFlQ1BsQjZzRWhPemJoTU9kR3g3V2x2TW9iUGtGMVpoa2tCVXhucFdtVkJleXd6ZWUwemdISzVoMU5nN3grMUpncmpiaHAyZExhSmNHSHQ1V21wN1VmeTUwZmRtVDQ5ZWhxTFY5NmxNYTEwVTVWZ3RlOWU2Mzc2Skp2Sy8yczl1b3hsVmJhWUJ4eENHbTFSS0o4ZGZoYkh5SnU2WUlQOERhdWw1VE1FMUpya1ZxMGVjYlFRbFlpWnNtMFBHVHZjMzZNci9CQ2dUTkJHMFBycUo1TVFwTGV4YzRhcHhGYkV5MVROS0pYNllrajZ2dW9mMHJlZk1HYUxheHFwOSt5SUhPTmJGejV2YTZWMzM0dXoxK05vUGwycWJUVTExT3Nya3VTczhPOWpDeXVTNnlacGwwS2F3VFBCSFdLYXUyQ011WDFJdjdWN3EreVVxMjFpR2lRSGEwN0pMM3NSZEZlSmE4bjhMcVN4bE9aRE5WZXN6Sk9lVFpySFZTZkxuU1MwdnA4WTJaVStjem1HcldVYUQ2eUFIUnhPQ25wdk1VRjhraVFPZGh1S1FMc1E0MXAwVUUza3BZUUZhZnpvdXZRVWRNWWllZ3RPcFlVdmhjR0VwY2grN0UzRnREWmNVc0hmNWo2alhnTENwTkFncDV2UXpvZEpDaXMwNU12Z0lPR1RPRGFiblRDU3ZUQmoxMjUrbjNIbGZlVkh2aXozelRRQkg4ejhsdEIxZWR0cFNONytWTnlvN3lEbkd5VVFTSy9hcWZKd0hydzNrSzBYN0Q2RWxlOVB0SHMySXdSYWkwbkllbFFlVFBTRHNyN3VoK3Jvck9xUVMwbExUZ3dMVjUyeTFMMFB1WHZhYXljZFI2NVlpeXRzRCs5bEw3YnBrc3MrK3RUd2V0anQvQmFmOUVkZFR2cVhLU0hucGdkcmZTV0R1UXQ5Q3krelIrZHk0cWg1SG9sWURyNFVhMit4dm5mRUtCaFAxTDNudnorWXJiOHN2bTg4bmxQbTFOL2pWdzVNeUhrbzdtUG1ib0ZaN2pGdHkzTSt2VWE2L01aVFZZVzNFZW5JTjUxanpJcHplV2dEWDZENmZNaExlMEtDUkt4R1dmb2JoRlo3VURUdGQ2T25Fa0pXdVRWYnpSNjZzVi9OMVNualQzQmtCOFdtODBkNUl3NlhnT3J2L2E5YVkvMGFDUnZhOTBPallMa2RUbnJISm1GV255N280cysrMFByaXZITXN6blRtYzUyaHVoWEsyN0dJK1pYQmh6cUR5TTZMdGpBanljNkQ4aEJnNFIyS1hZbHNvSlIvOW1hSlhudjZyWi9uK3pEVDJIR21xaTVFRUJHOGFvMnVvNkQrQVQrTVBYYk9ObEtlc3RleFVoLzZzS3lWUmdrblRZcUM1aVhFQW5TUHhqdHhJaXU0VWRsR1dLOTVGc3plalpRWGs5T2VpMy92QzZUbmM4MTZCT2crWHQwYW1XSTFIckVLVmk2VUZreUhkS3lVcGYyWWttUlhaSWgwd3N6VzgrYmdEeCtxdlJPWGNUMXZMcytRK2U4Zk9RenFNZUJNWWFzYjk1WncvV1FvTkpWdEh0YUdUeGxPcjlGc1czbWorWFFSdFd2L1pveEduSm8vQjV6cDFkdUxGMFM2VnVlT2VKUFZpTjlodkhjMmJ2L3VoNzZnWlFYSmZUWXhubVJ4Mm04aXF1ZWxKcjJWV3RWYi9SM2FXYk5ndTM0WXluMHVwWS9wckRqeTVIeCtTUkdKdnl6ZGF6aytqSjRFYjhYYmFveVg5M2NlNnJmOGZycTE4WVlLbEwyZG4ySzA3UEdMeExMaDVVMVpFWjBsTWI5U0V0WnNoOEkrdGlSNnZGQ0U2ODVTN0xGaU9ielR2QzJ1cWw1ZlYrRTNRZXBTKzVhKysveklYTUtGRzZDWGRPT085Yyt0L3h2OUhqWUFqYWt2QjdDV04rUXp4RXlic1dvQnlOV2ZUZVAxY0VqYXc2bHJldWRwaGo1a3FHN1RYdStsRjB0Ky9SNldpMnZ0NEkwYW4wanlCb21GMkNadkJXaDNXelprYVhDMXZSOEZWYUkwek10S0VFZGxrNDBZTmIweUhSb0hScSszZFJodWF1VTdLVXhMd3kyVkRYa0lSRnF5MXRwNlZPS3IyNGcrVllNMTFXc21KbTg4emZDS2FuSEtzTjBybHpXMG5UWHNrczYxK21UajBhTEoxczJzYmVMejFxSjJPNjNaT1VPbVRDZW5kcldsalNuNkl4YiswUlZtZTRvR3MyalhVZnFlcVVGOWlWajd6U1FxczU1ZTd1bFM1YnRaNFhaKzlMOXRGdXBQdittL1MxVkVmL2E1T0Qxbm5VN3RBeEloQlIxU0FYUUZRMmcwZjdwVFp4YVpVRVg1cndJTW1LNVVqRHRCY0hCaUVsb0RTenlESkFoVktjZG1qQVlzcjBsUllrMGpUZUxxOWQ1MnppUnBZakljb1IybitiZ1JKRHhpcm8wTnRodG1Hazd6SGQzbGxLQTRseGpWeUpkSUIwZkRlVkJrY2dyalo3UTVLdm9OVmhXN0taTnQyaFV1bW05UDVGNHR0M0NteUh6aDZuZnhFMHM0T050eHVoa3U0T3ZjMTdmQ3RLMzJCa2VEMm9EdGU3UXM1akRMdk9YWFAwN2EycHNSY0dmR2hsSG8vNlo5Y0FaUnpjMEFBNW5ycndpYjFsVzkzWEVpOHp0TlBnUDN0QXBjRnViL2xuNmdOWUtSNit1RWJ3cE81cXRwMHdyQWs4YW5qSDJYOEpwajlZQ1hTOE5DWWk4R0hkc2Y3Uk1NNzZCY1NYUEdYdnVJZVM3eE5GMDdReTc3eXVVMUhuaVV3RXZXMzVvdXpjNkYybGRSMzFkejh3eWcvZXRHUzNqK3RtZ3k1UTkvYjBFWmRVdnVJZXQwdGVjVm5valdPZTNZL1ZyQ0VidWhEeUVHNFJRWjdxSDNzZWQ5VDVGNXAyVjdnNGczL1BxbHQyNW5EVUZiM3FFTXZ1VmhpYmJXcDVrQ0VZR0tNNW43M3F2bnQ0MFBick9IQ0tITmRMQXE1dFZHd0RxcXp5WXJtajZtTXpCZk1KNVlGVXRGaDJtZEE1MEZLR2dYM0Z1cFpYNU9IdkR1Sk5UbFQwNllFeWVCR09ZWnhNeGY2dE1vN1RubnA3VzY0Y2JNUHROSzRjWTZjWWJLK3hjSDR1MlBxUDlPRlh1MnhybFF5TWJjaVlMT2hEeURUajIyVUZtZjQyd0ZkTk5uZmQvQjNkNHA4RWZwbjRMMXF6bGhFbGFhOElrNTVXWHpobkJYUlhlMTRxU05xZ2lPeE5yTGk5K0liM3IwV1NQTlg1THd0OEZETmI3akM4N1BDdW1hbFZnM1NDUlpiVEd0MTMvaVMzNjU2YU15RStETlZyR1B6ZGtGVWRXNjNxa014WTkyNkdPakxLWHlHcno3QldzWFAzL1YxLzlmMC96Nk90UVpMMzdwbXZjZTlDRmUwL0dWL21mWUwvdG52em16bnQ0T3V2a24vb0xDTm44WWF6KzJUOVpjY1JqclE1KzVJdmYranFLTjZnbUJ4R1FqbEZaTGZ0ZHdPc3pkYS9FMFNtcTlqMjhHMVh1bmJTWUQ3SmVZNmhvWGsxUkxpUmxjZU44OC93RXB3RC9OT3YxN3hYUDAyTXJldTNXQ1FUZDFydm15MzZjdGNMUDZCT2JWcm82TFNHbnREdE0wSDNoMW5VaWRVUFdMaDVINTBNRi9DenBpZFZuKzVza3lvSTg5d1B4cXJxMUZxR2xyMlcybXJuOEp2bW53dERoOVhQNEJGV2c2ZnBQVGkxWXdTSmpFZjZGaEZOeDc5c2Rkc0E4Q2RhU3FUVDQ0Ym5SaFdTcjg3UU1MMXBuN2dXakRLM245Y281dHRaZ2YwNXFHRkVPODZOV2pWcnQ2eE0xRGRaMXRMWTZlakU1WTVxRWRuODBCSWpvUW9ub2xHUEtHaUtqb1U0TE5JOW5wa1lZSFlndEV5blRwTlEyN3pKNUVTckVaOHZuSTRlTHV5ZTBpL3hhTTQ5MjB6dlFNL3ZUWkJ5OUVTNXZwcG02Qk1VL0w1TVpuWnA1K1ZxaHdSZE5rMGg4RlhhMjdxVG91Y0kyb0RwYk14Z3RqQ2l0ejRZLzJtV1FTcXo3MlJLQm5aRGF3K2hiRSsrZFRoYTFiZlhUNG54T3pjOXh3L2FmWkpTbFBpbTFLRnJ6L2puazg3ZWUxNnZyL0hweTcybGFwcitkSSsyMDZWaUJja3RXU3g0Q09uSWpQYk9BMTF2V29QVjV1eGFKTUZldFJXaDVVVmxvYjRyM3VqQzlqMENlVGN2RWVNNEJsZDJUQjcyK29BaXpRRWQxL2RsYlNrRjFSS3NjWFlyUXlrUlRjUUtSRG5BRGQwSjBocUlNWmNMWGpOVTdqVjhyRzdzTWFZTDBPV1NSb0haSVlLZkxqU0lVVUpXVWxReVpQVXVESDAxdnJIZEZZSFp6VnNXczNucklxRzcrTVBWYjJBYXVFcENjcFpyZ3NMNkl1cnBBdmhack9melpYV1JpNllzMVlMNThFTkVCaDJGMVZYeFZaWnhwS3hBTFBob0VTQjJsa2FaT3Q2ZitVa1U1dFVORWRSVXd6Y2hFYU9hTDkwNUd0eXpjQzBzeG5tNFE3bEQrM2pLVTZ2LzdCZFRScDRybGYwSWZlRkkvbmZGbG5Sc1FuWlI0N21naGYzOFUvcStZMjNmVlV1MFppcGM1Z1ZxYzYxbEpnbnp0cjVVZWZWdFRmL2JTZVhGRTcyeFVXNWo4SUQ1czdtWDJ3RmNUZXBIc3gzREpDYUlmUEU2YWVJUG9panE1cDkxQ1pudXQ2NFJNNDF2TjFabmNzSTZqZTBTY3hSMXRYbS9Vck1tb1AwZmtQZDRYckhnQWF3cld1dCs2anVyenBtSzBweC9MbGJIYW5lSkVkRFVqOG4zVkc2ellkNzgzNmNrVlg5RXZRL2QvMHZ5aXJVdjc1bXZjRzc1MS9KdWZLNFZRYzJ5SlpqSjc0UWZwd1NPckw5Yk04VnNjRHAwcklVUE1kTWdSMlJvTGh2S2Q1a25JZElHUUVMMHVrSjN0VXJybUI2VzluREVyR21KVVJRZ0owUnRvZmRoM0xXWXdxenFRbFlXWmRwNC9UUDBtdkJjcjNyY1pKcWkybHIrU2MvMFN2QjJnSWt4YythZjkvUUphcS9uc0FCaXQ4V3N4V0srZWs0NllrQlcyc0wvcldKYmFTamNTeWhnbGhINk1JL0srajJXUjk3d1hNSjZIYXFXelpQWjZ1d2xiQjcxRmxQMW5NM3VrOXcyVWExcWV0ZHdxTHBtQjkwRGFmZVNMT1k5bFlGcDFNQ1ZDbGp3R1FqMjFXTlB2M1k4VVNoVGgvZk9iK2lzSDJaR1lSZXBmR1hYK28yYXY3RWh3SEIyQm5vSGI2dlRxamh3dGcxRVByZXBaL2szUks2M2ppRzZqN3N2dW4vZkppdHNWN1lCMkt6VDVtL2Z2RCtBT3ZlL1FmSElzL2Q3NStiLytmTFZsUUg2K3NhNkZaa3UvZzhkZEZZSFBsbmtsU0s5THlZcDkzeWNVMUdNSkZUMkJzdjB2LzZvTUFaK2NhdFZEeExlamM1UWVXYTEwUGUwYllTRDJlZ0t5Q21mMWFlbHppbnI3WFlUOUg2ODBVb1lWWGlEZC9EVjJ0ZWs1RW41a1VjaFNoQ051TVN1K2laeUVYRmNlb2o0YmxSOWFpeWlHakVvSGNtUzdZWS9CQjlITEV1N1lrVExreHZXV2JIUU5wcEhQZkN6TWJ2M0dkaFpXV2VkeCs2ampCRisvREdUNk9vdFdHTkg2dktJTVVwZW1NMW8zMGVkQXpWVXJmVHRFSFRPVld0NFNTSTh3bzQ2U0gwY2dKNlJ1YVE1dVNNVFhsbnM5Y3loWnpJcXFWNVhaMGxGM3JjaXN3cElmOGNLM3hnc0JvakpXVmtDcjRkYUZCK1RMdU12SzkwYkVqVTh0dHlmMDdiZjJnNi9rSXBKWjY3ZXRtVXZzQkZYVWpKM1JycTJ5YUxQWHRsL2FOd0prNWw0QmhyYXNVazl4MzlQNWJ0dDU3Q0I0aUpyVmZIS3BSYytIYWRqZmozaDlORjFFNW9vQUdtV0dMQzlZajY0bHlIUkl1N2FpdXhhejJyMmgwN0dSNU11NDArdXhDL3BnVDFGUkM0TEsxS3l6WjRWUVhTdVdJaXhvUWhhQWRpYnQ5UUs2WnNhR2V5eWI3U2pPZlkzLzVOODBOVnFYOCtKbGRpR2lndHF0Vm40dlpoWDJEcDE1SWYzY3VvNzZTSTZMRHRCZ2lNQ2NVWVV5M1BoUElvUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaEJNQTVNYlcxbndMNU9FNW82aFc3OUZ4Q1pCY2E1THE0bkkzMHJVMGd5QWRoN2Z5Z2RZQVZPNWQ5T3ZZMnB1MTZkT29hM2EzTXVnYW9PTnlQN01qUzMwWFF2ZDVHdGl5UjFxOEVSU0cxMzd2N3A2V3JWV1owcDlQUnN0UlVIYmo1Mk51V1YxYnZFZTFwZHNwNXZjMXBmWFZYNGxVbXp4dGoxclZib0xXN05YeXR5bzRhck5hdWV0L2lsenlUY0tpUEdidmdGaWR0RnArT1kyaExrdy9YOXhKS2xiOGxzNFM4WUU4YUJNT09oVUQzVDdQeWVZRkVLNWhMdW01cHI2MFRzRFB3dk81SnFyMFJTSVNaZFlySTBQeXprQzFjM2p2MWRqdlFsVXBwMStHdjV2YU11RFhLUFFzZzAzbTBkditmSVIxTFA4TU9lTUc4cDZ1bkRKN09TTFFlbFgwRzFoaXFidThvNmtmelpPQzg3KzkvTC8vVHFEejJ6MG5HVlN5SW1pdTVFYnhpaHYrT2dYZFp5bDVuT1dUV2RHcEtVc0xtQ1ZvN2EwR2Q5YmtZOTVFSmJ6YlNKRWRtajMvOUlHSmhtRi9sTFIweW45R3Nxdjh5dXF2c251K1BRb2c4VUZRN1lOUUtVVXlkaHpLVXR0SUlNc2F4eGlXcUkxUVd3MTQzYllGMkdkQzFQYWNsMnkzdmxiNCtBL255UHAzcENwMjZOWFcwQjJqdHIzTEtqaFV2UXBLTTlYeXlJaGN4R2Q1VGVaN0NLNVBsUVVLeUVCZjRDWGh1TnpYdWErbTh0R2N4T2dWRDVLSERWOHJvQ2EraTRmL0k4MXNEMDJQRndLM3ZhektOZWZCdkRIOVVZYzJScmVXSmcvc1ZPcXg2MG5TbmRwWlFsOUh5V1RwYWtYb0t5TlN1WjBESHUrN1RHSWdkdjdXWnR2cTVyRXh2N0JYd1dnOWVnMnRwa3BHSGZBV2VyVWpHZlN2dERGdmhNY09XU0JtZTYxVERDREg5cTRWbjhmbWZER002NkoyUXVsdm5sVlBNWkpVMzFncGUreU5rWVNTak03bFd2dTBFMkdNNy9kdzVTbnZWM2V0ZmR5MjhhcFJjOUJYRWYrdHpwYnlseTljanR1eDNncDkvOHI1TSs2UnlQdmo3VjluVndQNStEczA1TGJ4Z3JwVlBvMmVtNlBVOGIvUmZFVVVnRmttbWxmbDZBd2xFZHpaMGVMS2l3VXlIMWZDNkR1cVllZ3dXdVE4OTVxck9pd1FvU0h5c1hSOHhWNE40cXIybGlQcDY5UEd0endnanc3STEveVVmREczNE1xS1IzY2k0ZTc4dU1xNi9kWGdobkRQWFFhSVRoZ2VrQzJOZXIvNXRJTmVkMFQ3b2hSZXRvdEZmdnBoZElTZkdmRStuZHlXaVZjVm9jeUx2TkhoaUtpR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSWdmaVR5R2VEYk5KVmYvYnlESUx1Q0hRTHJBM1NXbHNpeVkzUGVnRXFocnNXZlNDdHZsVmZiOEd0T1hTUVRTRzlPanVoVGkwVkdienVkWm5TMUlodU5STGRnVlBlMzlJZzIxT0R1MFVlS2tMWkVtcTRBZEV0K2lJN2MvYnVXNnZwZHBKN0o3NVlXOWVmME8rUHczTy9LL0dWQmcxeC9iZGhaQXRFYTZqMThBai80OW1yaUtodGUyWTVodEF5OUpTanp3NW44THAwaWRndTMwaWR6dHI1R1oxUklJR1U5SktlSjdZR2k2VnJYNU02MXZNRWFaMlFaUjM1Nlo2Z09wTXJyS2RUNTRkdXEvZWxNc1ZreFBZVmE0K2svVTcxSHRiTzdYUDlyQlZ4bnRubTZQaGR5VXhkZFh1ZFBYYThoUTN3T1VVeTgyRFIxRFpUZi9NWDFGWTVya0FydVNXN2hFOVVGSXRIMHJhVXlQekhTdWZNaTM0TGwySWdjUW02R05FaiswSE1DdHNpZVlKVGJlaXd6L0pPdnZ0OGlFb2E1YS92NlNjZEMzWG1kRjhVR0RtdTlSQm1BWVltZ3BhdkdIWTV2LzluNURYSzBGTzAwWFdPbmxOcC84V0w5ZWRnZnRkbldCMitrY1dOemZ2OGNRN1pNYjNjUmNpeVByY2tlL2RSejVFYitiTHgyZk5DTG4xVkgrTU1IU2lBblRVWkdCcVgweW9iK3R5SUxJM0k4a1F2aUNtbzAwWUdVNTNPazEybmF3M2c0dVJCNDRpRzBTaE8yYnpsWnVzNjB2MjlWWnRvNUJvTnMzb3dReDRqZlYzbHFJMi9BdG4xa1BRcERYcG5kR3FhZW9SUEl2S0Fuck1uWDBWdjNLWFpqSnhpN3F1WG1iSXNkNFhra1grbjF4SzNOMDBwam9FK25JcVpzM29kTGFPbVNxWTd6aGVLS3pOWGYybW5lU1loMDZwZHo2ZVdxanpaeloyYU9rdy9XelhLY1QzaW1DdS9yeXY1akdVQnFWeXI4OS9uUEhxNzNQaTB6NGRRZ0d0eTdjR3RSVWNYa2cvcERhUDBSaEtwc3l5dENFdW1RV1Y3MFEyaTA1T2RqREsxMXlKc1dSMVJiblR4Z1R3THE5dDZYU1V5N3g4TmN0RHJFNGpNVVhvZkc3MnZZVmxPenhxMTVDVlJKdFJDa2hPSWRFaU5sanRpZzU3R21lN3kvVm9zZ1VzUlZoaGg5Qk8wMjdCN2tRT3o3TmttUzM1dXFMUm9SZEZSLzRtR1RSODdOcUx2dGlTV2Y2SXhlZVBGZWxZZmk0VGhYaHpwM1cvTmZubGlLaUdFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlnY2ovL1QvL0MvMHUvYzkvOFRlc0gwRnJONEdMaXFEZEc5MDBZUW9uRmliNkMvYWFpNXFSek1UYnlBN1oxcWFBMThrZXIyNG4xTjlJODNxeXptMW1iejhYYVA4bEkzMXd5NU42MnljcFN0V05PTDhyQjlNTUhWNGRpMHV3eWxaQ2RKQ2crM1A1dS9hdTlua2ZaekpuYlFJcjg5SzNIREhIRm1KVG90cyt4ZmJya3JzMjF6dG8vNXk4K0p2U3UxNjY5OXc4eW9MdFZ0anZvRWNVSUhZTjNlc3NvaVBJd2YzS0xiNEJIY01uby9iNEtiU09aOUlwMnhxbVZuSkZ4ZCtkMmt0WjlWeVZidVhhYUkzYXJUc3pQbGtkUjkyOWpGY3c0dXlET2tSc0xvZUNkVktTUERGMXhoQ3lEZ01zTW8wdzlXWEc0SUpPSW96TWkzb3FaTVJ2V1RLc0lNZEw5NldNaEhpV0xHOUtadVJUazN0aGhOSE0xb21vYUJpaVlaK3U5b3BaUjVSR2dVNXBYYVQ3VWo4MHcxZk1zRHN0MmNqNnpjQmdDOWo2b2d4d2I5ZmFMUEphSjZkR0dGbWR1eFdqSWR5bjRaa0NyN090S01QS3RTTTAzSmlCWjBwa0daSlJscEdsQmtzbXFndHBpMmg3QmVhOW1pODNJMWdsWDdrd1RGelp0WkloKzR6aFNoeXVmS1dCZElBTHhnTDViSkR1cW5YQmxlNjJkM1VEY3JlVnN2MTZ6ODhKb3I0QW9TVEwyL3I3RlN0TjYzN3IzY3crL1NiTEJsMXR6MDBKeHpMazk3L3RNbzRSNzNYbWVqczRCZjA5Y2JYdGtmZDFseHZ0NlpmZERuazh4NFJLYnNucWNTNm9VN3dqWUVjWWtvMDYrVFBvMVNuWHRSS09OMmNqbjBHUEE1cHRPaUxER1hkNlRWWGU2TzdCVzZlTEZEVmE1ZEVscGFqdUdwcUNHOUhybGdiR0VPa25zaFNSR21sYnI2SVA0emY3NjN0SUdWQlhRWWpKekhjQklvL1hyeU1tRXZXM1BiSS9rcWdmb3Y4eFdSMmpJbFhmWS9zdCtHdFRjanEwS1lTUXgwQ0Q5YUd3WWMrSGRVN0kwK0NvSllRUVFnZ2hoSHdzNFMrdmNZWkV5R1BoOEQyTnpMb21oQkJ5QitpUENDR0VFRUlJSVlRUVFnZzVsVC82NWRuYjI1RGJVUCtNK2NJbTluN2hmU2t6ZG1TdzhobmJKc2dOKzd5TlZNdFJCRWZ0ay9HMnp0clNSSGFOWUdmb1o2dnJ6dTNFV3B1QVNORTVZYWJHc2dtV3Jybk5qMjVyc25MN0xhTU1xcDNOQ1R2RnhMS21LTFAySkduSmlMUXM2QTJnazV3Mk9iWGNsazZQMkg0dWJhbS81emg2NmRxT0dOdVZlRVlyWDRMMUFOYm55SVBTditpODYxQUVkOFhiYTJnallodXRoclJTNTExcStaVnFyZm4xUGJPUGQrSkVuaHUxZ2JQM050T2VGL1ZYMm1TcmxiZGpvaUg3bURXUjJLa1piYmVaZm5XRy8wbWdiSy9kcTJRdHFiTEtGVzNXYWFrclQxSkZRdGJ5L2l1bHVOOHRUYWtZSzU2OU40YXpiTW9kSE51S3VQS001eEtEWSt0eDRNNlVkWkdqdzhROEdmVmRwSmZ2Sy90UnNDOUFYWkJqQWF4VEVreWdoL0I4ZzNWLzlUNkprZnRvYlBPbFJLckJtOUFqb1ZHVjlyRHpzZmhjeXRHbldicUwrS3lOdVlPc2RMd24vOWFRNDdWWXh5NlhnZ2lMRzVSTjltZ2FUN2M1Rnk4ZE1xUCtXTXZ2NklibkFPanNPV0t2ck5oOHkrOU5jRDIyanA2TnU5Yk1xZllOMjdxRUx1TllNamtuaTh6L2ROa1N0Q1U4bWFWeGY2VFhIYWdMUEZYd0JOQUhicVdiSFRaSHVqbXF1emVzUnZCTUFacHZwUE41RTZaTzA2SHE4TXFBMG12V2tzaUg1QlU2V242OXZyK2x5UTJSYjVsVit0MzlmYkpoajZZdWcxVDNaZnJXL1JrckVkSDdxRmNlNlVxUEoyTFhVc0pDRjQvZURvdDB2dDR4VG5iY3RaK1BkdGVlNTVvVlJrUWo5aFZoaEdjTER4OTJjOCt5dTljekJkc25LKzQ5UEl6WXl6cm1PejRRRW1ab2Y2UElQUDhuZEI5VDY2WFJ3by90Mm45ZVZ6YloveEh6L3hhNzlsUTZteG16aVB5L2NZaHNzL3o2LzE2NG5BRzJBOHFXck4vci9teXRLRHFsakdUSXN2RFN0UnhTTlBKWWdXZVJvcEZSeERKYm55ZXRSVFR6SUlGRUszODY1dHQxWXhIVUk2cVRjNTNjaTlsckVYVWFKSkNZRmJPUGxnWE1Yc1MvTmFPV2NOWlNoQ1lMalJHaWxxL2xHY2hDZWp0Yno5dzJKemJ1UmZRMDExOE80N240ZVhmemhHcE9KS1pMdi9NbVExNnJxN0Fia1JCSVNPOU5nNHhrMnYxYTlJaS9sVEtKWUhSNjlNVjRhMnBvTEllOG91eHRsaDdkbTA2ZW1FcklLbWhnQ1hrdUhMOWZBaHY2czJIN0VrSUl1UjZlR0VNSUllUU9mSTAvdXZKQjZmUlA0UG82NXNtcDVLTmdkMTRQNjNnNXJHSkNDQ0dFa05rd3dpS0VrRHRESzAwSUlZUVFRdTVJL3UvLytWOWdRNGFjL3Z3WFE5cVBZdlV1UmFENkdidEJqdTVTNUxKVXVLNEtQdEF1d01MbUpLdXhkZ05oWThheHRvZG8zVCtoQ0J1V1BiTjJydkEySHBuek9PajJKaTN0R2Zpc3laSVlaWkJidHBmSTNqZ29hQmw3WkpiQjY5czk0UHJCMFZUSi9uMFdXODJXTXp4MCszbkxsTHJHNkhtcTVYSElDT2oyTlZwNjlFRnpwKzV2b1hnMlU5NkwyTXE1WUp1aXRwOG5IOFp0MUdib1dyRjhpTDFxMVNIU3dWSC90QUx2T1pOeTMvS0p2ZnZJUlo1dmxuVThvMjZGcnUzRU5ublhjbzJRNUgwN29iNnRKM1QxekhVeHlqYm1ieTE3MVN2enpIWWZJZHJQWjR5dE14Z2R2Mkt3aUJOVkQ2YzZHa1RHV2o2b2ZQVnJUVWoxZUUwVm8rSC80V2lvNlB5b0JBb3p3OStTcFVUQ2pON21WUHIxNGZBRG8rdFlLcTNUMDFwVGNPMXpyY1U3R1dYRm11Z1U0ZDBub2s2Z2JvQXA4aVB4YzMxUHM2bXRlTE9sUXlacmRLSndUSjR3M1IzWTg2RTR2ZDRXbVdGZXhvclF4cE41aGM0enVOTlVWT3FTM0dtNmYzYWI5VTRISkNQdDIvdmM2MDJtSFVjWTZhUE5pbmdLYXdhbXlkREtNNk9MWFdIR3BPeTBVTWNJNGNQdW5URjB5aXVOM3JGVGdEUmtPazl3RGF2S3NCRlpBVjRKNmdLYmRsdXU1K1Myd0lOTnlHMGRaN1piTk1TeHBHanJ1Vm44NVozV09yb1UwVXpubkpDcTNmOTdiWmYrM1c1WnBFdTc4c28xN3A3MStDenFORS96L2w3TFJpT1NPczkyRnNuL0tmaytnY2hvYVYzZjdpSHJyOUhJRVVrMzJoNVdtVHJvbmNOTUxBSzVNU01UcGw1ZGtkaDdVRlVDVk5aNVVFdUN5cXpUanpCTFowL3plbkVFbWNEbzJKS3l5Q21jWVJML3BiUFdQYXA3TmVnN2VhUk03RTZrRzNSNmhFeVh3STZZQTZxUklwQUtieXFXalBzeVRhdjl0ZlFmVERTMjgyU2hROHVUMHlwVDZ6NVBUQ1dFRUVKdUJJTmFNcDhyZXhWN05DR0VFRUlJSVlRUThySHdwRmhDQ0NHRUVFTElIZURVNUtOaDh4SXlDUTRtUWdpNU43VFRoQkJDQ0hrbzRJbXBLZjM1TC82RzlaSDAvTlI1MXE0cmdJb2MvS3d4YzZPWUpyMmJxclYreVY5Mi8vdzJrZGpkSkxKVEEva2dPdm9TQWJuQXFFUkVlcnNOaFhhUWJlUmJBN3EvWENzdjJMSGZ5WVhSaEhSWndxS3NHSVM5M2pEWjZWeEhLN2NLN3QwQmRtUi9RRDFmTEhmZk5wKy9PK2hpUE1ia2VsMEkyYTNvby9Dc0pKcS9JYU4wNklDNjdmaldVRVVwdjY2NktKLzB6bUtma0xvU2Q1OUFJSDBPM0svVGpPd0pWYWZwR0d6b1l5OFp4M2NNT05lVnlUclZ4VXZmZy9jVVBmTy80ODd1YlIxelRrejlsWFo5UHptenY1N3h2T2krek5yOWxQeVpRMFRuS0NMR1c2RENPNG5oWFF5eEZyT1g0WlJ0NlhHT0tPaDhTbDYzWkFBeHpqSmZqK2orSUpCaGErV0pObXVkRkl3ajVEcWt0WDY1eTVyOVhaZUxsYmxacGp1TXRRR09Sem0zUC9jcFNYUHR0ZVlqV241SXl4SmQ5YmRVZVF2dUVaQkJoTW0wNWs2LzhkUkxXcy9ZU1Zocm9pM2U4dmp1SzQyY1lnZmhvdmNUVUpncnVUSzB1d0puZUw5WjBaNmVpWWptUjlMSzlLamY3V212M3JydFhZclE4c3IwVWQyR2pOYUpETkVUVWhGR2gwekQ2NmpwRUs0d0ZkN25Idmtwclg4T2ovQ0pxUWNCNHZPTThkcjNlc0ZuWm1oRGJzbHEyM0NYY2J1QnVMcWVvUVM1OXM0NHVzNy9UNWR3RXZhSm0xakFjVHhwOHpjdk9DVi8vNldmaEpxYjhpd1ozZ3JoRmIwTDhzOU93M3J4aC9WYzJQeW9ONmhGMDdkS2crcnlXM1krZ2ZsOUdNczU5Z1N0cU96a3lCcDlUa3ZuakNCZ29PNDdsbXVnKzRSNDlNNkh0WHVEUlZneFI1MXBHWHZqU3RSeXR1TUlUbDF1UysrNmExTHlzU0V2QjQzc21qS1U5bTJ0OFh2eHM3Y3NLYTlyOXdoWlJ2NzlSeHNuOHRkdFY3elMrTmp4Z0Jvb3hMQXhzR2d5STFhMVpKN0Jwb3UvTmlWa05UU2VoRHlQQzhmdHpNQ0NrTytFanBjUVFnZ2hoQkJ5UXpoVklkTmhweUtMK05hdTlXM1B6ZWY5REYzcHhtVWdoQkJDQ0NFRWdzRXJJWVRjRVZwblFnZ2hoQkNDOGpveHRiV2Z5ODkxbnBqNkliUitmWDZ5K3EwSTJ2WFVtVzRLeUhZZlNVa1RLSnluWXNhdUtKSlQ2NUNzQmRrc2tPajAyTUJKZGJ4aVorOFpHMEQ3V3F4MHlVanZiV3VDN0I5bllaU3ROQnEyM3VLcGZmU1JVWVpJQjlDMmRlbHRwVnJuU0NkOGxlSHdXR0lyckJzWmswZ0xyQXBsc0IxekgyaDZWMnovK0NoTzNLZHF4SEF2cm11NWMvY00vMlRmUVgxRXkzZWdPMEI3MjI0bEk3K1VOVHM0bU8wTFJiSlR6ZmZLL2JsNjJuVVJoKzc3ODRkNkFtTzlNNTkyTzZmTzB6LzA1OFZHa0w1RGYveEUxUHZFQmovTWlxdTg2ek4xdCtTaHVqK0J4aGpxbFpqN1pCWWhvODRmSDY5ZU8wYUNnRkdmNk1VMnFHNkVFK09wVDZMVnJGYmFETWlxWk1xZGp3dHEzaXlaeVhTSlhhZlRyRGt3TktmbTBXMFNtYmFuRUMyZHJhTmpMUjJ0TW5RSEVwMStSaXRMYnhuTTU0ckVlSzEzVmhwUmU2eGZiOFZWVzU3ZlVyY0hiS1NMalVZYlNJM08xbmtLSzhLbTBRYy9JNVNicVdOMkdOMjYzd3BwU2lQdkdYWGFTNCtaaXNpSUV0VXBRYzJ5bFYyNmlHU3JibHZiR05wajkwVE5YbnJ0bnBiZktsT0x5TXpVR2tvak1sY3pkVmg3SWNDWnRxTzNBMGRzaHpQdVNEK3pZNTBaWGM1emlUT1k1WjVHeXVhVkFaNFdBMU1VZDhveWNZelo1dWxYeVg1ZGRydDJsRk5mSC9VRlBlM2RLdHR4SG1TVmJmWW9hMkFNbnZkekdKVnNuWVNybjBxTHhoZG9oSkdNZEpvMkMwK20xYkxidi84SHlwRnB6blpVczV6OGpCbnhqUGJWOGlDOXl5cUQzUnVicWlPMkVSQkp2b0FaUTZpK1g4dnl1dlVDMENLczhHUXJIM2RXckJmVlNTYlJjai9JUkNFNlRzblhjWmd2eVQ4Y3crUkZLWTJzaEl4VHpmTmE2OUM1bmYzVVZ4b0V3SnRzRTRoWkt4RXpkV3JOeWwrYkVrSUlJWVI4Tkl6bUNTR0VrS3ZJZE1PRUVFTElkMENuVHdnaE5qU1JoQkJDQ0NHRUVFSUlJY053aWVWRFljTVNRZ2doNU9IOCtmbkgrbjM0U2J1YmtiWDhiY1o2WTdSU1hUK3hDSkhydmVsT3A2N2JRVEd0enh2b3JrZUlEdkl3MklCejZMR0JrK3ArWlB6T3BPeitrZ1pzOWo1dDFuWFU2aVVubmFlajNpN0gwN0VxRnVwcCtkNzZRV1NOcGp1ZjBubHZKdmxDM1YyczJKNkpmcWlQZ3cwQ0dtVlJYUmZEaHU2dDFONDNXQ2NzWnJoelJVZHdidHp2dGRNNWtIYUZ6Vnk4WGVXcFkzT0ZNclJkcnpOQ3pSTVp5KzRmSlcvcTFhcGVyU0ljTStWeE4vdFBtVUhPZm83WjR6akNkem5Wc3VCNTU1eStPaW9EOVNtSWpaL1JUMGQwajVSeGh1d3ZRSzVGUktyRmE4NXQ5OWpYTHNoWmZJWmtCM25ycW9yZ3Fsb1NScFRZOWQ1MDBUejFEMVM5OU0wNDQyUi9vZW5yTFFPY3IyZkc3MFZEbGh6dk9KQ2ZucndmcnZvV3Z2N1QvYVFvQlIvc295dEgzdlhIY3VZVTVFN01MT09xNlVBSjVGbmtqMDZoeDB6MXBwc3BTMThDR2tiR0cyOWQxVzcySzdCV2tLUkhxTzhoOGtiZWpzeXkyN1h1WGcrSFhsL0oxRldjSzhhV3B5UGF1YTJ5Y1hwMEt0KzZtak5yQ0sxOE13bVgwVWhZejNmaGVlK0M3L1Q4WGkvQjlHMVFYeENaazBmWW5xY29PckpJZVFydFFqakV5dWlweUIweWRWWUhkV1VnVGJpU0p6QXJrcGl4NXU5ZDk4NWhrbmx5NEhwOXY1ZVg3Rm5EYzZJTkpROWd4aEJDNzUvQWxVWDByTnJJa0xyVGRJbDBnTHFmM2tCU3BxWDkvanJVMDFMLzNVaE94dGMvaTlmNENHbFNkdi84STllbnFLYXhLSHJGS3cyZXBBclNOWjhuTmRIWVRxNFY5VlI5enp1TlArMms1UEdVNnQ5Vks1TmdFVGJWMXIya3BMdFZMN1FLRlRHV3pvTWh6ODNSK1lVZ0RYN0xRWE5UV2g1M2NmMzFxc3JCNjVxTzR3K1B0bjlyNXpCU0d2Uytsc2J6Qmw0NkxZdjFvOVRld1dJOUZ6cEFyYS9Qb0RLczlLQlhHQTdxenpBeXVmcS8vU0ozUzFNQVdiM2wvZGc1a0ZVdEhVUHRtWEIyKzBzK2ZDckNONVRUTzRMbEpiMk9heTN2dERxMjlTSVl5ZHNxUXcrZWx6ZWVPeGY5OXBha09hR292cmtENlViYm9DWExTeGVSdVFwUnQvTHU2M2JQN3pQeUsvUDJZN3JENTFlNllwV3B1cE9ydnlMakZHM1Z6MmZGazN2MmFJWXVNT1piaW10Y1h2K0tOSytQN3pFa0pTS2hiUlovT0FQeG9BdXFPdWY1TENQZ0dRZTFXcUsyVWN1bmZaWVVKMDlwcEVQTDBOSWRsZjNoMUgyaFZTMlI2aEpwcy9HNVdPUFFtUmRreTZ4cHVxcS9keSsrYy81UlUzUmwrYVhrT0xUMnZoSml4Rm5Qa21PZG1qb3FjMStweDgrYTdGNjdwUmNpWVRHNmxxOUsxK1dHTmZ1TTJCWlVXU1hyWDkzSytkSGZ6L21RUTlYWTRSSU96U24rNk8zT3MrVDhFekZqYURsdTlsYkJhVFNVUTZkRlBVdURNK3VsZHhocmNucnlyWloxWlJtc3VrMUN0bVcyZWlacFNCZ1l5UitJUHc0L1NuMzkyNG9Oa090UzVKYTJ0ZXlCcnFoNHd6cncrRXZObVZhMWlFNjBMS29mU3UwNjltVGVtak1LTzdOekVaVkg5Ym1LM25HcnlVa3BOazdSK3lObG1HV1hSamdzY1YvUVdhTDE0UG1ubGtuSnBwZVE5NHNwNHlkZCs3UE1WL3RiSzI5cFhQbDN0V2QrLzg1Ynl5Ni84NXREdXIyTzdIU0k5dGpTNnpxNzN0RURuVGdrSUYwclg1M1hhMkhyK3Q5Ly8yUElHcGtnemJKTUhqTXMxMmhVcDQyaW10Ym84dHJQUXRHSmRpbkdMTStrZDNMaVRSU21PbXpuOHdWY0VESXNBWjMzdHVLTFd0YU1XSTkwTUR0bzMvRGNFSGs4M3Y2b01vdzI1V3d5T3U4VGNtQmlwMEhYbTEwNXIzOVhyOU44TkdoY2ljajRVbnBEZHkvOWFKb2UzVnJlTFgvKzcvLzVYMGpPbi8vNlR5SVBSUWFZRjFqRTFsTEw3VURXZU9Sc1RGNExxa0NYN2pRWjVFdGdnNCtoamVzTERGUFVIS05Mem9oTk9kN3JYWDFBWDJTMHZrYWhYUjhvd3ZIdGswZzdhTFNIaUxYS2FZUlZyaTlyMURlZXphUE1NRHBNazBoSFh4UEFxT1FTVEg4aXhiRFA5VXYySW54RC9NZXBvNTFweEVjZ3IxV2lza1plc0s5QzZPeFN6ZGRKRWVTUGVlcHJkNEF0U2U2TytZTzRYYUowaWtsdEx2VCsvZkhjblFaM0NOUUhJbk0wQys5YktsYWU2MktmMjZBdEJFU3FIS1VoVTU1c1ZnNS9ZRVhSZm5ONWtDMWt6dnF0NkNPd0txaStkMlpGbURxZk5nSHNqVjNIWCtFVjExYTZDMVRtcDlIYWp6N1YwM3ZCcldGbDlzTzYyelB5d2xBeU1ZNXdWVmh4aHFQQ3M2RGV2UWhlSkt1dm1KMUxLNksvWWhYbkkxYU96clF4NkRjNWF6aGRJb211c0pmREhMVEhnTi9vaHpFYmtSQWcrdVk5OHJoM00wOC83ZjNqbWVSNmhyVUJWMFpmM1cwNnpDdDNHNTNZM0xPOWJ0ZUt1cmI3ZEZEOWZXQjhMU0xldms3NkdldVNrU1ZoY2g1UER0b3Y3RU4zc1BCM0cwS3Ryc1RoL2pDUWdKRjhETmE3T2FpNW5UQWlFbDBTc3BUYy9IZ3Ftb2xsbU96QUNybU1NMmI1bXEvNGs4am4wN01RdTdBSUkva3Q0ejMxc2ZLa05LM3MwbG1LNzVXalJiajZ4U1E1a1o0MVl5dk5OMU43V0d1Z1JkZDFBNnExSWhRbi9XeCtkYTZPK2tyU245QzZYcGZKVy9KeXZ1bGFmek1XTm82RERXeUNoSFV6ZEhzNmpJNXNuZVp5NnJlRzllYy94NXhoZGY4NFV6cWp5MFVEaTYveVA4REQ5ZFRING1EdWVNcFBlZis3M2N1SGdzczh4NzhpSmJDeHZHUjlEM3pCNnBaaHBhMWQ4VFZDNzdsbmRoclVENmRHdXNVZCtRcVVadmNPTGp1VDhSclAxZjkvYlVNazc1NVAvTHFzTnZ2ZTBLN1BLQS82WEt0aTJBanRNdVM4djYrbHRyN0lubC9WVUV5WmUyNzF3OUtoSDZHTkJsWnFMUnZ5VUQ4YThiY2plVDZNVm9pRGdnN3pXb2NVa1IyUm5hWkVUc0ZiM2Yzd3BkRER0RDYvcmo4c2pxZ2ZYUDVLOS9aTVhJc3dSVVhYSWc1L0FDN1JtamM0NmQvWnRJRzZKYWxQcU5jR1dUWTBXUE9vS3Mya2VESWJGdzVqek1vYzBEbnFuZEtFTXFqNVU0cE5sNnd1Y2lmek0yTjRSblZKdkRwRnA0Y1IyVjY2Rmw1ZlF1czBVdmZhTktGbnlSdlIwOHVpdm1URjhxdklobTU1SDMxTXE4amVtNHVWS3pDYWwva1cxRk1QdmM4YXN4c0lzV3NGdkkrSEVlVEduTkgxWmpEYlhubTZKSWlkaG9lU1NLaStCbGJHVnRHVUdaV1N6VEswVzF3M1MvWDh3Y1k3elhPZjltaEtpbEtpM01qdmE5aWt5T2ZDbmdkbGUrNm96TU5VdSt5bDFoZVBjVWtXcVlwUnJraXRSb2xHS2pMdnpBQVRjYWhQY0ZBakZ0bDd2bWhFYVZtMlZwNWFWeXRJS0tBYzVaNW1QTHlzRFhIa1N4Z3hWek5sVE1iMjlUclJwWWlJYkU5V3hJcDVvYzdNNWlRUHhmSUZaRG5vZUE3TGZiV2hPeTlDMWpNTTJlYjlSSWpENkxRbkdmbUYvWXFZcytoYWhKYW1UdHNLcXpsR0JLeVFOMmU5YjVESU5hUVpvUUR5VG9NL1RQMDJWdmZray9qMFdMbTFkT1c5Vy8rQTVpVi9zVHE1MThEc0FHMGVaRGlROFZ5Y3oraTlOZFJoK0NMdGIyUDVHakF5a2lJVCthNVZxc2dycEVjUkdSY2o3ekkvbnJ0RlhOWnJCNjhIYjgrUkhka3pSa0oyWkZzdi9oRld0RVVKWHBmM2U0STRTMlFSSW1jODcranpqYVo1SnRab3VPcjNKL05xZXNUcjNhRzl6eWdEYXA5bWx1VktHemdidll3N3l4K3UwdUxjVDc1T0tYSDJqK0dHNVBYNlh6bWVlM3o5R1pId0Y4MHRrQ1o0S0xNdDQrZEdFRVRGSFJkeThNeWNnNzNrdnNWL3hvcTZaNzJ2aUZKZ1ZqVEJtYmIzaTl6YWptOTk3aXU0WVYzZk5jUkJiYUgzTTR5UlZTcVVBbDVyWFYvSnBaNnhCRCtqY2tiS0lLOW44TG9sZy9iemtaeTVDbjAzbWJOMW9VT21OTWFMdFpyUld4YmtqalpEMlpjQks4WElqejNudCs5ZTR0NEhudUg5QUhLVnQ0QXlkOThoOEZqdGdVZmxhRitBc0J3UldnYnZuUjJKYzRmNlkvdDlIVGN4MDBNeVRvaWppNk55eGJRaE9Ub0pPWTNQV1BwK0hLdXFYSHYxYkczaWNqQ1pORVRrS1VpN05iSFBjc1p6SXJRNWIxYXZPRmhFdmpHRWdzajVZeGVIRWNuSDB2cjVkVXBMbXg2MU5jZ3kyckppWHZFdGptM25Fcm1lS3RvRVVjM1Ird0hVNjhvejNxZ1E0TTBXa0tlei9wSEF3alBMSGkzei9TTzdKMXEzakdFRzcxdlhTdktYK3B3eXFxY1BsZDk3cGRZaENlb3kweUV2ZnJhV1JkSzJkRVplbW5sZW9LcW5meCtMbzd2T2g1UzNaNkNVVis3OCtyUjlydS9HOFBPZUVQUThFZCtZa0RlTzdaREQvajNtZ0R5bnNvMjczMC9ITHgzOEJpVEhMdUo5bGMvaUtOc09lancvbEp3eWpGUnNyd3daeExWa2IrazdkV3IyM0F3c2NwcDdyT2ZkYktsVnAzMFUrY2ZyOXd1MTZKd3g0K2lkQWhmMVc1d1hydWJiYXE4MUc0blVROXdtL05OUThNaDlzM25lRi9peVRGZjJJbG9tTTljSmQyVVJ6dDJ5cDBNbnBlNDFIbjFrejF3bThvMk9udmFPb3NVQUgwN3ZZeUpUN2I4WXpZWjB3VU4zTmJwYTY3UlRhd3FlRmIrWldycXZQQ25WZWtCa1BLTnBTNkJTdGZJVnkwNm5xdDJLVTdiM2plU0QyZ1NuODdUV2tJb21wMDRqeTIxMVVIbFowWFZJK0xKQjc2U3lJNlB6bVgyNkxPcTY2ZC9LcjRSL21vMHVZcnFiMUJKZWRiR1ZjMUMwMlVka2VmUThYKzlVc2xWR0t5MnFQN3BrT0pNUlhjaVFRZHJJYS84Vi9SbjFxNjIyS2NhOTBmNmNBVjJ0RUQ0RnJrZkdTVzUrZEs5TDBTUE5LaCsvcExZY3RJdFoxMHBEdDlWRlZxNWVvU1lEblVWNGRYZW1TV29TYmNpWkljOHNuL2VGMDZGVlhPazZXNHl1c0tBMjFNcHptL0dLTXVJTVh1dEo4SFJKWEkreUg3NC9MWm9yWmZWYVZUWjZhSjlQMEh0UE5CVHdxTi9SMmlaUFAwRVZQUW4xZC9yVlhpdmZ5YzQvT3VzNTFNLzF2VXhMVndMTDJ2THRQaU5lSDlVMnl4SFZlV28wQjlValc5T3p3akpGMXlLMmEzTGVqN1JGNURsa3VWcTZOZG5SU0hyN3FBd0liOTdxQmJGZWRaQjdFcDMzclF5bzBNa0l5a1Z4TkJyRDFlbDdhVlhWeXFVSUtXT0YxU1lUaUxvTW1iZDA1aVZMbUJFbDFmT2c5NDlUdDgrVmZLKzVENitxNVAxRUNNaEloMFpqMFFrZzQ0SytNUFVIUVZxZ1FrUHlqOWx4VnN1WFpPZHpqOHhVM2F2VHliUi8ydUk1dkQ2V0M1dVhOaWJBYXdSSGxyakl3Mms1WnBybGRaeFl0ek1Yb3J6cnYvZTJCN3lEQmJiS01xbHNwNDhSUnMva0EwQVdJT2wvQm1sVmNnbGU5M1JnNks2dk4vQVlXWjcwbnJQM2RZcjMxblUxcGZNK1dNWjN0WWowemFxYy9meDNNd3lMeTZOMjFaSCtHRlgrQ3pJNm94ckw3ZHJ6U3I2dExnYnQwUlcyMVIwQXJ3U0dlNjNIa0RZRjM4blFCQ0M2cCtLVlpjWTNTTHl2TTh6aVRuUFREK0dFS3JWT3FYbEhqZm5ZOVdmN3FVczRiRFZOUGh0OU1QMSsrWHE4TDh3Y3FxdXNOS0lUU3NpaFF6NkZPL2ZuTTk4WFBXQk1uMTBkczNUTmlOeWo2U0k2ejZqVE12cEE2SDJMbmtVV2J5cG12ZjdpZEdnYWQ1MVBYTEhDOG9TNTFReDdGSlU5UzY2K3RGVEVqMFhLNGY3TWttaG1hdmFiRy9sTW1EVHZ1cEc2Rk53TW52Uk80MXp6M05MV3VwNEMxMXYzcmU5cHpLNkJLeDNlSFozdHdsN0cySUpzeEY4TXJxUDNsVVlXMXhiRzBTdmY1RHh4U05LTWZBbHM2RnN3eGY3STk5M2xhRElKSVRxOUljVlhtZEM1eXhyMFArbXpYdVcwbXZSUGFzS2U4TkZZRVVqME85OUJsYTNQeVZDOXNFaEhablI3cjhBRGIvMFlPSDR3ZGNQS2I4cldNd2RVQmpuU3NubHljRmwxT1dDUVBKc1hGWjFEK2ZQaGszeE50ay9uclFTT0dNdW9OekRLa2tYKytuUUw5MVE0cTdhczU3WStXekpLOHIrdDBPc3NjcUFzVW5WZFZ4SFoyblZyMEl4NXFoeE1FNmdGT01YSFJzQXpBaW9HSW0zUTRQWndRMDdack9zdHBaYk45SFArNU42K0xvRUhIdk5pZE9RNXZWSm9NbHQ1V2tGQmJ4bVFtaGdkUklhdTNOQUJuNVNLUHNmSzUrMXB6MUgwNTNsZnJXK0xNS01ZN3ZLZHBlei90WWc5WFg3L3YrZExUdWdPOW5QeCtzdzhhNExyU2s0Nm1lY3E1K2RGUFZiNk96cnJmZG1hVnRvd1cralQvWHBFdTcvTFZvMGZLcjJpWDN0OWJhYk9DeFlGRHpvSUJCTGlPVlZxSGM1WlJQNUQ2eXMrVU42cWRSUnRlbGpkcjNNZVRrWVJ5aU1ucUJ5VmlFb2JPYTIwQ09ldjZheURBdlRVNU1pcHk5NFA1YjM1Zm9tdVJUVHVXZlhnbFJHcEYvZjQzYVRMVWp0c1NuZ3NvTW1RT2ZSMUxGbXp5S21uMWtwUm5VZU5NeGNTalRaa1BqVVBLZ2l4Y2E0eUVEU2tPelNzK0ZlVEsrOUh5M2xpZTV2MExsTjY5elFkdmZsSHNBYmZnRWs4c1BXeHFLNlIwQWdONlVaMFYybUtmbmxIVkNYU0JOSk9lY054UlZWYnV0QjBCYmlPbXFtb0xqVHYwaGtBR0NMcG1WUFhORW5WMlJvekt5by9OOUtTMDdoaWJLRTZaNFE0ZDZDN2pudW1lM1gyMmlrc3FzeVM5R0c3WGU4MWEvcVYwc3lqbTYrZXRjNmtycG1WUnRxU1NsZVkrSlAvbU81UXIzOVBScTBNZG41OTF1Wkx0U3o1SEhKNm5LRDYrYW5kTEQ3SGliU0YxYXUyZjZPek5FOTNkblFnTW5xUUE3UytGc0VhSTBnUTN4dWtvMldJVEFqejRQVkdFS0VWQzYyZStsOUxYbExrRXpJRGIzalg1cXF6MzgxY2lwam4rMzJpU3kwUkN5bnpvbVhnMEYrSVo0ZUxrYzY3anl6a2tPbElXOUZhaWtocGNMNWF2YkxabWN5ODE1R0VMbXZwa04yRW5BYml3THdPN0lDRXd4NGNFd2JSaWlucGF5dHo5UnJoekdyMVpzbjFkVG5qM3Zoamk4Nk56K1FqNkptUmtLV3dTYjZjelVKbjQzTU5POGRYZ0s0cldKOFIyWHNlNXV1OUNvcC91L3doZE1abFE4MTduMWlRRVdrSDZNUWNHUzRmNzMvTzd1dVdzKzk5cmRGTE1hNlczUmNiNGp0L1IxNDZuOTI1a0RwR3l6VHVnZkZzcFgxLzJOYlBUQmROVzZlZnNRd2YxWW1SWmF5ZXFzK0wyTmZLV0oxY2N6THFyTEYybGE0cm5WL3ZHTG9qKzdLWkwrRW1qaVh2dEllM0YrN1NlYWUrRm5VQ2xpRkxhYnpQUmRhVDd6UEhlQVRCNmpwbE9seVZwNERwVU1xM25sYktVMXJKSkhwZXFuOVMxRUhJNlh5SjZXNjlzbHFwODA2Z1B6UG9tUzJNMnRXUi9LdHRlbGxadUJMUU9Ucjk4ZVNSVzhKbVhzLzlWbkRIOHlFeXpucnUxaXBPdjJjKzRaMEdJRFUzNzZKUyt0UGxVNytJNDBVUmRRdXZLc01WMGR5VnRFZlB1V1VnaE94d3YrdVZwcG1ybVZPUlhxOXpSMHZnVlQyYW50eWNiM1A5TndHMUhWUHNFd2NzZVNxOXRpbjdZY1FvVjg0ZUhrUDBxMzFmYkpkbXIyNUVkYy8rNGFvbXJ4NHpmL3pzSEY0ZnljMmJWZHFxUzRzYkRkNUs4bWVZczE5OGtjOGhPNS8vd3Y0eWg4M0ZMZjY5aExaTGhGY1VORjVMUUhydE54UFdxeGNkcTFTOUlVdkVxRVpyUWhPQmZodlhNdFE1K0ZuK3ZhVnAzWStXU2Y2dHBSVnBzcmhtZmRHMVdWZHJsMDYySDhvY2ExanZCNjJlVkdiMEhSQjhqTjJJbWRXalZZQW0rN3dtR2FDT1BEdHRuR2tpOC81NlVlNGxJdzhNbHI0QVYzNnVsdmUvMlF4UXRuR2JkM2swYWZIUjBldG5Ja1Ivd05QcnFiYzhpTFVRc3IweEpSTjBkZDlIRDl6VHlOYnFTcXFyZkwrVCs4OXBiK1gzRUxYWGRid243Vk5FbWplTFB0YUtRMnVlMDlxb1RZbXVoTTV5anIyeXZPZnlZdmFaWmRGa3plMGhPNG41MkcvZnQ3YXhsQng1cjhjOW5FeW4zWGlQMzdwT3kwSFdsckFVeHk1THdUTHVMa3JBbE9YMUtKSDJiY1ViSlpBZXhZdXJKc1JkMzRKY1ZBaFVsM1V5bFhsZ2FLUXBzcEsvb2FOS3JjdlJ1bUYwZktDbmxrWk9LL1h5bUtlVEpreUgxaGpXS2EzYTUxcFc4V0s1UUgxbW80SE5JMEdsU25HaHBLUGNtdFlSb1VWSnUxZW01NE03ZExIek9LNVBodVMvai8rSzNjbzYrNWFkejhrWjk0Zmt3RGd1NkxLUWhoZEdlTEs4N3QzcURwdnVXZUVnMHF4NmVJR0hlc1g1ck1uV1pFWGFDRTBiQ1Q5NmRVVHlSWi9Ua3gzcFd6SVBxc3RMMzlMdDlXZjBlVHhrL0ZGZG0yM1pyQ0o3NmVxMEkrWkprem1TZnlYYXlsS05aem9pM2JxWGtKbHlRaDFYT0tKa2xETXJqMXpHakpYUjZDb1Zlai9xam9yeldaT3R5V25kSDJGSWRqUmVsTmVWVUwrVnJZZHMxUHJvUm9IMVVrQzlEdDFhVzhuT081eWVNSEU3T1RWS2Eyd1p6UU9WNWVkekViS3hsczNUSTVvUlpBdEhKMXJSKzlwc2N1NUkrS0dXR1oxc3lIelJvQjE1N2kwOVdyYW9SZTZSR2VSUWxIcjlSazdvMDVnT2NpOWFhdzZ0NjZqenp3MFpMVG1JTEMvdzhxNEJySXhsYWgyUkt1NlZHYWxxUkg2a0xPUWlldGRJVzQzR0JuMDgzaXV2ZmVMOVI4L2NJbEVVSVNFaWl5emxtS1M1cnBIN2ZHMlBuOTUwZStIVDF4QmRWQ0tYWTY4WS9kTHpmcVhWOUgvdk5YNlk2b2ttajJiMjJoSTVEVGJibDhFR244dG0rM3JYOWllb1hrRWtFTGhmbHhxSVJ0OHpBQ1Y4T3UxQlc2RWJtWUgrbzdoemlZemZXNXZ0RlN0SkgxRXhHOUpKTE9CVWs2R3Y4dXo3cy8xdGpmM1hHa3BJMDVHVkQ5M1R1VnB2MHJLVHZoZlVJMGQxS1N0MThwcTdRajJyTERPNXY5SFFmY1BzY3NzdjFrUnlGaWo5YzE4eXpIWkFNOXR1UkZidmVKMlYvaXhaUjVGWnUvQjJSS0J1MDlUdVBWL2UvV0ZsM2xRUDF2bjc0OTZ6L3Z0YzVIVkhsbnUvOXcxQUJtU2hieHU4ZkMyZEJNSUtWMDVtdHJVaU4rYTA0M2VMY1oxRUtLMGIrZkJuTXcvSE1WRzVpUjg2alN1ZlYrcU92dE9ZVWU0VGxzb2tLOVNOekh1dm1GR2lPbnJMdHJLc2ticlc5dHNJS1NGa01aR3VGbG41amF6WFJTakJ6NmljbWR6WnBzNURydi80dXJPeUJteTl3YkNaMVFNaU9tYWl5RzR1VjVYZk5FMDUzbXhuUnRSeGJORVlJeEZLejFlc2F4bkkrN0ZSdVZlQWx1SGg2NU9IeHd3RzcxeHkrVnhHWHlNVklBMHFLM3AvQXMrT0k5WnhCK3RNQ09ua3dlRUtJVER5cXhONXpheVdkSUpPb1pGMERFcW0wRnFKaUs4cHpVUDhNSlZmQ3ZvcW90djNqS3hwZ2R5eTl5RS9DZmUrTytQVjZmYlJzQlNsdExOeTFING9yWWFOamwveVMxWSs5OVJsd1c3bmhpcExsQldmb1Y4RjdnUFZpdVpyR2NuZWNDZnJsLzRaU1c4cVlwVXZPbmhhTGRqN3JTRDBwVmdHeTlEZzhOanl4ZDFJTHh2elRLMWRiT3ZUVkZ1U2kvTFhMRDdTNzFyZHhmTS9TTHJITWpnZFEwek55ZlZtKzZOU2ZjNVYrdjExN1VlcHY0K2ord3o3dmlabEZXZ0gzMVk4aXZoY3l3QnRiRmRBQnZxTzRMeGlpczZsV0hYcmxhdW5qdnRrSWEyK2hTRzlVVVE5MnZRVSs3dUs5dVRweSs5eFdkN1hXdlRWOEJsOXl0TnhoMzR0bWJISTB2dGNVYU5SSnVyMitORmQvK0J6ZHpCZm5mSlZCTGZmNXFOTWpZT2xMK20xczZaaEI5VExJM2JJOHpjNzdTSmZWRThVcEU5RTg2RitrNFRSbkZUWjMvcDNHNWxLVnVsTWl5R2FTcDJDUzRMTzBSekgxb25IOGtHMVV6MFBwNVB1ZFRaMVdGZ25pU0xwVzJYVE9BUU9KU2JyRUc3SmhtN3BGcklQUDA3TmVycWpJUEd4RlYrM2JJSm1Xd3pkSmRqNU5obGF4d1pQUEMzRldyL1pmMnAxMjE5WnYvZDNlWUp1UiswVzVlaUZpcEczcE9UYWpMZFlwTXdOdTdXN3ZpSlk3WlZaSEhsZTk0aE9DNUV5RkNPZmRqL1laOHd5SlVWSFNWaGJXT1dOVGdOVFVJY1hYa2ZMME92enZIYTF5aUxYa0xJaHV6aWZOVXJIZmN3VW1yUzZhWEtLZ2FicjdVb3lYeEV5a1NxVlpmRjBvZWxsbmxaemoyRDZna2s2a1pBbkQvYXg3cW1Nek52eGdLRlRTNzZBR1daOWhveVc3Smx5ZTh0cW1mYVJjblNOVC9GNVJkMGtRMGVQTzlaT1dYN0xiY1dWVG1WbjhWZHJrMDd0Uk5SaVd0R1VSbW8xZy9jdERmOEhwb3VVOVJKVHQwMUowMDhIcUgyMlJqejBiMjJPakFaY2NhM0hlMTVlU1RUeXNQSnJOVHJqdVZvQk1oSjRhNEZ4SzExTGxxVmI2a2lncmdMbVE4cGxQUi9xSmJaSlBoQzhvMTBpZytuSmZlbUpoVWNEaVI3emRpSTljVWRVdHFjVHVXOVpINHVJN0RxUHVrNHAwbWpYeVdTa1c0bzJLQklpc0FGdml4ZEZvR3NwUFdzUlhsY2paSmpScVFxUUJ2Vy9NMTRGZUxNQThnSU5zT29wNkpkWHBqVTc3b2tqdDgvV3JOZGl4anNOZWUyUG40VjhMTE5tTk44R3VpNDV3TnVKR2NiWG05K1REMkZpbnlMMzRYdWFkWHZTYkh3K3V5eWZvT083a1QzcGJENTYzRVllN2lQaXhRdVdDLzZ1Q09hVGRicm9kbm4vWTlTK0JpMUJuWmlVYU4xWitUVXJnbjZOQWEyUGlLVWFIRFJXZDI0VzRRNER0YmR1WjViOWpIcTQ0cm1rWkV6MldBbnVVSmQzZEVBenl0UXJZMFo5cmFyVEg3bnZGMlp5Z2FQSFZZSnYzbW92ZEZCZFFKSGRKNmg2WDVScXJmU3NzbjJyNDVJemRYMGhodTgvWTc2MDRnQk5PMndwYWZ6WENoL00xOVROczFmVGV0M2JxRTZFeU96SXUrL3E1RkNlenhXZGk1d1AyczR6bDk4L3ZHOVpVV3JQRzQxVnMvNFJuUkVmZ01yb25RVWhHY3RvSlk2RUNJT1Z5UitrN3JseUZXUkU5cXFWbHg0WlBXVWNMZjhLYzk5dE16clRqTXhSZit1aExTRHZVdi9tcnVOcHVRNDdVcmUrS3k1Z3VqcTFsdlo4UXliTHJPNkhkSGl3bFFzZXZlK0haa1FCMFRYQjNsNGxld0FhNVh4cVFQaHB6L1hKYlVWVXl1THJhQmxtVEpSTzRJejRFdm5TdnJ4LzFhajFkTTljV2lDRTZMZzJZdVphaWxUS3dVMUlOeHcrcVc5YUhGMXcveEo2UTNUdi90Vy8wdmhqMzdyUkRJR3NCZjJsK2dJZUZlOUVYdnh1akZxSVZ4cGtreHZ5b1VTM01DQVlTSjBPMmtadklTZFNsT2dYQ1lxVHBrQzV2WXFKbE1qNkxDbEdXWkx4ZVV1ZU1iRVFVbmR4N3ZlODdvdDZQNjhNcmJSVzFsZTY3QzJSQ2wzcXRseGJyeHIxU3UyZW1SU05aL0Y0ZjN1bDc3Z3d6cndGOWZPZlhnZTUrbjg3emZIcXp5Z3I2dlZqN3RpalJleG1LMy9FTm03WHMwamJTaCtSYmVXSnBxOTFHRHF6OS95eUNFOGJmRE9NeHFpWDJNYU9Yc2ZXS1kvYlorM0FOcG4rY0dENWxqNVpSZEw4YngvNS9UV3FLL3JHSFp6Q3B6cW1aejdYZGlMYnYxS2JYenhyNS8rWDVSMnFIc2VwNUQvL0w4MTIvNjJ5U201TndjZHIxbm93K2VDSWR0aDZPT2xhbGUwOWVUUmZvR0dKRHJvdW1YNURBTXNQYldoZlM2ei9PQndDMlpDMVM1L3M5TVZTM2pyVnRMNm54ZFZXM3NNdnptVmhpc2dQK0Z2UEY2TS9GUFdDaEo4UHh6VFdFVUV0SFVkanFZcHZ5amlVb2JUVDJRSi81U2lYZDNMZngzYW1mUjc0U0ZFZ1huNG5CY3YvTGtKNWZiVHM4VkZYcTl2S3g5VEdMNG8xcEpwNWNydnJIU2pCNjdJZ0hjdFpZZDJJQTVjMkJYVjlYbGRyeWVpcE80K29pMFdEbTVFeVJXV2lvYzI4d095b2EwUzJITWlXYk91K2wwOHh1MjRvWnNueTBIUkcrbGV5VnplUzhUbUo5QzJaVmpxdjJWcVA0RlV0bWpmYWhYSkRScFNvK1lxYWpKSG5mT2NEd3F5d3JHUVVSaFN5K1VvRFZwcklGOUVURW5oZEt0cmw3c2dLTnp5VDkvVEJLQ0FhYmlCNWovZXRrMU5UVTNjMmFsV3VGRWtwUldqYnA1T3AxM0gwTC9xNnN6ck5UNy9yZUx1MCtXZSt0YlhsYnUyd0Z0YVF2Yit2MTM0czVFRkdlRXF1UTNMWHpFWjZKZHJpZFcveDFpbGxlaXV0eFlqVjhPclNTb2ZJek1IN1hpU0ZSS2U5ZFdpbHo4RjdDZStlNUg3YzJRRzNUSVJreEJFdklsSWtiMDZLNUV1S3Z0R2xDQzB2WXUxUUM0N0tKQjFFM2FqOGpEUUtHKzUwdERXVTF1ZVE0TlNYT2IveWVWblI2SVdRWVZyVEkyM1FwTmhzcC9WNWhJOGJFNmhCaXNad1ZucHZLa3JDdEZ4RHorc2dqWjR1OGllUnp5Y3lFU1E0bTJFK29XNDVUL2hDcENPV0Uwc3RQY0dSNC9mRThkeERLeDRuZjZHak80MExUcXU1USt1MjVtSWNqdzZzb0F1SXJFTFhhQzliaTlyL3g1b1ZHZFU5UzdLOXBVS2VjTWFMODJqNm9OVTUvR2dnUFpRWlJtTlVobFAzVjhTTjcxT1hhOVdsOCtYRmxZYjVEazdoVG81cFpsayt3T0gyaksyRDZRVHFRYVRaL2RoY0ZFVlRNVTdyUVZGdDBTOWRhVStXVXRlWG1CcGY5VHQrWmlENERVRERkb2JQdExxeHZQOVVMcGhyWDhvam5uZDkrUTdMa2gwcW8xK3QxYnpRUjFycnMrUDFxL21XNTJXNy90QWEwTE81UVgzZnJjbG4yVXprQzM5bzgwYS9YRGlTdC92NUp6cWJFaXowbEQzYlBJZExQb3FlTVhYYVdGckFpcFdJTTlCczVNaTdQTTlXNXNabmRKMzIyQTkrcm1DbVpiOStkYzhZUGxhcXYydHl1MmRIZjcxajNXL0tHSGwvdFAyNzZyMURSQWZxa0t4MHVWRUc5QXRKcURQOHR1QWRaZVVJQnV1YnpmSXM3bW53ZjNsZ0lOSHovYnVST09KVG9PbDRLR3k0VTdsNjNwZVJVSStRdXlDbkM0MDFiKy9iRGFTRFZURWM4bEtTZkRUOFllcW5VNjhkZWQ4MmlNeTRMcUwxNC92bDhaUG0zYkp6M3l1UWwwN2NwMzMrRXJSeGkzWncyYWNlTUs0dncxdUhuMVJuaUozYXJrZFZudE84M2t1R1hxdlVja1R5Y3dHdXQ4clptcDVFbHdWNlgya2l1a1phVlB1U2VhT08zNm82bm5mYTZYdHRnMVYvK2szaGphS29UdS82TVVVN0ZhNlJYTWtGMFpSNUl0RDVhRHQzbDlmL2YzYjIvc1U2T1hWRSsrKy9YanYwQnRROUR0MnhtV1pnNVgzOUc5R2hwZE5rR05ldEl5ZlViK2JraVRiY3c2dlRqZnRiUjdXMWN6dXRLZXZRclBsMUhhaUhZazhUdHI5NlJtdGsrcEE3ZGVEYW8zbVIyR2NtcUsxWXFkTjd6cGxsV2Z1OHhWS0pJTVpPNVBRZGE5NlZ4VjgvSnpLVWZVYWxEQ0c3bWc5L2dCV0IyazRyblc0MWppQjJPOElaNC9LTGthYWhnWFhRWkhnMEM1M3ZBMGRUYXIvd3RtUW9udzhuckdpbnhhc25oemFld2pvaFZiSWlUcEtWanFTTjNvL21Pd1lrMjQwVXhqekZWRVFXV1NsVGFka3k1WDVCNXcvdkRPSzZMR00rcUhSRnUxV25sMUZ6R2JKTGpGaGJyU3ovZVgzK1Axa05TYXh2Vkk0Um5yRTRMbkRtcVhoRG9FdGU2QkJ3N05jT2J4RXBPdXlRcVNjeWRTN0pEeU5taC9zdGVkNVV1elR5ZURKbmc1UXBHdnBJbWRyejEyRmNTMGFkdjc3dTlSM1VmM2NBV3VXdXgvUFNXK1o2bE5adzlzcGc0VFdSMXdWR3VOcE1IMmE3V2ZjZGgyWFZDUVdQRGxkVlFGcGpPdTlBeEN5ZnhSM3JlcFhyckprUnVTTmhCSkovSlBTSm91cFVZakZ0THVxZG5OcWxPLzNhNDVaOWh1TnBRMGNFMURma2hhT25DQjNJU2FuL3JsZnJlcktOMWFsek9kNzNRdG8rRHA0cGVMOVhaMHVIVE5mYmpobE1NN3VmRk9jenF0T3pobWlFMlRNaDZsMkwyTzRWcFZ3eitrNnJETmd0NkQ1NUZyUFhJcVJNVDNiTFJNNTNReVlqRm5QVUVxNktENzJsaUpSc2k2dDVHcG5lV3RaWVpiVklCNmg3WW1OOURSa01UZVdyQzg5T3NRdVJhU0NkeVhCVzlielFtcHV2UWc0dGpoV0JOMjFxeGFCRUpUS2JiZDN2WWNVS3dIOFNJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hBUG0vLytmL0V6OTQxWCt1L09lLytKUGxqd0RkeXRCTE81bklqK2RQSS9yemNtMEhFdkFCMEgzYzBCMFdMNjAzTWg5Z2R4czJPb2hYbDYxeFBNa3dXVVdJN0FVNXZtTnVwRlAxK245dE44alc1NWJPenIxbnJPMjFvVGFNN3BhNTNVTWNyYmVWV2ZSK0FuU0t2TytxdHJiTTZ2RkUwUjR0ODJHRERmV0ZhTnFXamd0RG83V2dRK3FNd09NV1FkOENUTVBjNDRobUZTWTM3L1pKUm5jcFR1SzZkczlMNThrOHN3TWpkc3RyWDB1bWxSYXNoNUZBWTRoWmRSbTlmN2V5NU9icHB6bHlRcXFRQytsVzdzLzFaZDZPN2VNYTVuT0hXWFdrSDBkMW8zSFVHUTUzVE1mK0ZMbjlXTnAyZlQwOFZmZVlTcnVxN2lxeGRSd2NkRXljTnovUzBxZlVQMGRKeW4ydERCckZ1VDhLVWdaeUZxV3p1ZVVwa0tVVnlsWHA2Z1FsTWlCM2VSdjVvbVlwY2h5WGVtcHJJNjkxZjBRbmltbVhBQis1MjVZNFlLY096eVgvRU50emF6cFEzYVl1UTJjU0h4RnpmSmpQaVg3NytteDN1ZklxYXQ2TFNmNWpSazhmUFR5dDR5S2E0eGZFUERoWEZxb3BSSHoyOHN3SXJ6ejMyNUtINm83S2lOYkRES0xob3hkMmVPRklUYlNkejZqN1VkbVIvajdTLzI2SVlXM0QrU0ptT1NsNUVLd204S0psNzdNbEt6WFNKU0JmSzZMMzh0YnBlcnZjaks0YW11Vm14NGM0WVVUb2hGV3RRYUxweWFYTU1OOW42dXdkVTNWK1M3ZGxLMVlTRGJQQ1lZY3g1clE1cDJlWGp6RjhHOFF2ZWZZWjk0MzdITzNuaU5Icm43YzhtRW5VNi9aUUQ4WWtCWmtmZVgxQnprRXNQeVRMSFBSUXhuV3ZSNC8wSnJRTXlkRFpTMTJHL3lqWEVKQTZSbnNaR3VWRTY3ckc2ejJXN3VUSVE5SjZXTStYOWN1SGZNa2VSSllLOHBsNGpqZ1o5MWNRZDViZEtpUTlTMG1ldGRMeTM0MFJxMHpUY0NLZWEvUEd6a3ozUTFUUUtvOUVkT2dTYWFSTjgwdHdjZkpHSXlOQ2hrRUdnQkhDKy9POHRrcEVsY3hEWGlDQmhKZjN5MEY5QkpMZmtvSE9maU15NjNSSStNRVRVd2toaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDRVQrNy8vNTM4WVBiMzkvMDhvVFU3K0E2QVpnSjREc2xoamRsV2lZeU5aQjFzL1AwYTM2eXY2eUpoSXRDdmt5MlBoam9JTk15V050VWlXelJIWk0ydTcvbjVKZXl4T3hsZU8yWXVVZVNhaHN4Vmh1OUI3MzhDdGdyOE84bi9ReVFiSWplWG9SdXQ1YnlIcXFlNTV2ZEg4WFcxTzlrMjNwMnN0UFM1ZFN0SnlQTTdIQnVPTjliVVlWZnl0Ri9LRWRjMk9kNER4M0NJWHBVVm5NSzZEOWJxYU43amJkczBlVVI5UVhvRFlTU1I4c2czbGErSXJPTkxLM2FsUkhFcnJPOEtINzU1UERHcElBVm4ydU0veFZJVEpadnRBcXpPemF5SzdmOVNYOGdNcm84OC9qZVh0MHpiUWxLM1dkWFM4dFhmcjkwQ2syVXg5ajM3LzNwemY4WHU4Mm8yWU0wRE1qUkgyZnBDVlQzdmRra2NmUWFGWjVNcW8xYXQ5ckVTS2tsVHAycXJJeHJYakxhUGZmZ3N4VlBRZWJEMzgwZFZiSzB6U2l4MXhhTXFCQXdtcGdNNFA0SElsRjBmUmJOcWZ6NmIxRno3dkxYOHZRUDlyQlcrdjVIUnVZRTdUV2p4eW12YXg1OVNLMUkvYmNMcHQxSXFvc1UyOVo5NFhaTW5mZXZ4SjBTdHNqYzJUNnE4bjBRZ05VVnBTZWtLVWxKeklWOVo0Yk5aMm96QkZkTW4weWREOEV4L3VHbGljem9NZVNGYVVWTFJld0hGS09kdC9TUGROMElHblI5R2ZpbnB6YXlGY0R5YWppNG1iNllIajViVVJNNVNyOUVkZHdKMWFGRVVEb0N1dHFUdEVDY2xUWndQU3BkZGhmMU42MThtWWp0N1kybXBWZXBkZlBhODMzZGRkcmk2VGMzOVpuc2ZMaXlMTHBhWTUvSVd2RldUUnNNZTRYcGVILzNxdXZlN2I5MkQ5a25VY0NVVFRJUTFzU0JYRThWdG9lSzlLS2RpSkVJNCtJbFlqSTF2SWxKWDl2TzBiYitjUkF3alBRWlgwUnlNVm83VGNhUkVnWnJiNkV6SDh2N0dNUkQ0RElRQzBySXE5MzZReXBjdSs2Slp0Y0RCdmhja2JIcHdTeUdjNThxT25xczErbWxSRXNJUWVzVGlZK3Z5OHJIZHQ2UjJXcFNrSkZCQzljL25wRzMya1ErSjJHbDk4WlVxNE1aTlZqaEswY1BER1ZrTlhRMEJMeVBHNjhLRWJJczdpeVIzTTBrUStBM1ppUXg1TTVqZ2toaEJCQzVuQ0h3T3BiWWp2R3NKL050N2J2bWMvTk1YUTZiRjVDQ0NIa1BPZ0xDU0dFa091Z0h5YUVSS0ROSUlRUUlsbmxHNEFUVTM5dS8va3Yvb2IxSTBCKzJqLzdaOUFBNkMrM2tRMitvdmZEelBqWk9MaUxRT1M1VnZ5Q25WeEV6L1phYlB3K0l0dUlUVkNCamx0dlBJL3NjRGFPdGZlR0xBMHFSNVBsYmRYWUtvT3laWTdjTm5YSGlwMDJXMmxuN0tuVjI2dFNPcHlVYXQwUGNhNEhpbW1hT3pwVzdQVjZLZDV3M3U2TjdMQ2FBQjNmUUlra2tOdURwU0Q3aHZWMmhDN0tYNmd0TDQ3dWRnNGtpbzlvUjMySmRrK1QxNUl4bzBOUHNoYWhjWnM3N2Z4VG1XdVJpekZNMVRERHNZbnYzZUJWNGJ1RUlyK2VEaHRKMGliczh5Szc0MzhmbzMyb3gxYU14bzFYMEx0Tm90R2YxYkVtVDBsNDlWZGo3QnhPMmpCVXFzTzIrdEZUUVk3cTZMR3IwQndGalR4ckdWNUFwc2xHK3h6cWw3RVlncHdBRU5vVks1eEtmdnFzNUdsR2VwWXY5TGFBTnZJM3lTL3RicmhvakdQMHVKNVZOc0lEanVua3ZHS2l2ZktPMVBTdUQ1WE5taStWZHZvRmRxb0ltZGxRYVlmbTlrQWREZDJiSzJlNXZ6djhrelZ6R21UT1hWNy9qa3o3b2pycis1b083N2tqZGl2NjNPajlsbXlVNlBOR1FoWkpWRWRFSnlvemVuOUVCMW9Qa2FWZ0w4ODZFeGdHclE0djM1WjNnWWNOWTF0eHZ3bWFkanF0ZWI3ZUdXcFBXY3hob1BnU3l5KzUvbXBndlBhZXhucmxHUHAySWk0aGc5YzkxOTNqaHFKaFI1MnVWUmFyVEMzZGtieklmUVQ0ZVJWYjBFb25NYWNvZFY2UkJGMzdiTHZobk5vbmk3WnJ3QXRoL3dPV3NWV1dsV3U4SzhQTTFvazRsbzlBT05iNWpKNXU0UVZlYUZCWG5NK2FEay9ubVE0TXRXZzlNbERMN0ZuTDFMaVBsZ21SNFhtZVhocnQ2ajNlWVIwbUgvT1I1NEYyNjU0aFU2Y1p2Vjh6WUo1NjR5dXBPcUpqTktZN1k0aDV6U3Z4TENRNW1WWm9rQkx1K3NseVJxTEozbmc2SStGVloxOWdGeUxMQVJ5Um5NOXI5eEVWWjd6UytGaDZZem5rUGczTlA2THhKT292WmxSdmRNM1FlcWZ4Ri83YWxId0Z0R3VFa0tkQnUvV3BzR1VKSVlRUVFnaUp3aWlhRUJLRFZtTTVQQlorT2F6aUQ0ZnRTd2doaEJCQ0JtQTRTUWdoaEJEeVFUQzRJNFFRUXNqREVTZW0ybHZvOE1UVUR3UFpZYVdIM20wOUJPaXZybS9KekUzVmdOMGkwYjMweUFjd3Nwa2dPOE9la2EzTkJ1dlMyZ3lrZ0hsa1B1UytMWGRrYTVLZWZkYWlXNnRvTXJSMFJVOW01a0gyUkVhMm00b3kyb25RclFvbGpmU213ODFPK3A1OUJKSDBudXhmbVdmNFBtK0U5R3c0ZVF0YTI5Y2tjVS9MTjVOUDkxTllkOGF1VDZZMHIrUm1VWkF1NUd2VjlocE5BVzNlNTlUUWhkNUgvUkpDOS82SG1NNlF1YzJwNjFTcWdaYmZ5MW8xR1kzU3AxUHZ0ZkkweCtyNjN4eVRIOHNiU1QwMVBIYzMvWmxqcDZVRGVmS0l2SlRPN1lNdFRuSUdUWjJMN2RZcnJUNTJuTnhsUy8vcXR5OFpReWU1NWQ1OGh0THdVVURiQjZ6ZTlta2pZODVLTzRwWEZuSUhpbmNERGJlMnk0cFR0SHRBRm5tTGV2dnRqN2I3dVU2UzlSTldzekhmWDJsR28vR1V0QW5acU16Y3F1Uk9aaHh6aVo0UUt6R1A1VzNZcDVZWktVQ1VBNS9TS200aEUveVVta1V2QjF1ZTIwVUtzT1FRM3RydmRuUm5TZkdhUU9wR3BtNHJRN1FyUWgra0REV1dQZmJTOStCUEdOcjNaK0w1SXkvdnlucUl5a0pzaTlldVNVa1hzVnMzcFRkNlJDSmMxUHVnemQwYXBrZ2VMUi9hblpFeUZPZjZDTU5EQ3ZBSjJpbDVJeWQ3V3hUVTd3QmhTbzk1c2hpdDQ2Y3owL1hQY3UySW5qUkoxNm93SXRDdDFUeXBrUjRaU29mNzF0SkpRNmFMVVFGZW4wSjlRbVN0ZE5UdDl2ckUxVVQ3TlJMQzlHS2RvR3JiL215VXBTaDNyZEZUMzBkR1VVdUdCMUtHbGk2cnA4dDA5YjN0dVlweGZWVFhqQjRkbmFUMFdKWFI2QTdSdldoMEgxUUNSckcrZldKUnlTSm1CU0NleWZENlNtUnljMWVuOThLTEozczlBdks0dmMwWkJmRVFaQktvYXhnTkhaSWhpdzE2R3EycTdqR1JoL3RaejFNQzdlMTFoNXViWi9JRXdQRDR2VDZROVB1cTZHelBhRm9pZW1ZSE1pOEJvVjk2b3oxbTVEVlJkdkplVWRXUnNjUmZteEpDQ0NIa3kvaTJxY09WejN1K2JrNE1DWmtMeHhRaFkzQU1FVUlJSVdkQ3ovdlIzT0VJVVhheDlYelhNaGI3MUtmRDlpV0VFRUlJbVFyRHF6TmdMWDhGYkdaQ0NDR0VFRUlJSVJONW5aanE3OW5BRTFNL2xCazdKeTNrakoyQXduZy9YZS9aZkszcy92a2RrY3J1a2RhR09lZ3VUZVRCZUEwdTB4Q2ZDd2ROWlB4NnV4S2h1MlZvMkkvdDdmb29yNk5FOXBOenR0Q0JkdkRMcWU5VXVJU1Z3WlVWMllKeUpVWTdXY2RaSEU1cE9meHhHdFp1TG1lV1pHd3MzWmhXOS9ZZWlJSEdIQ0piMkkycXFocnMzMmxUYWE5NVJuUEdaU0RQMzdQanM1Wit1NFpZbFJtNkxORGFkbnhoYy93YXZxLzN5QW1UR1FFbzZQUERNbGYwOEQxUTczMjcxZno2UEtNY3Y4OXpsaG1XTmlQQjJudWlVMFRtcHptZ0dmMytUanBqZTFNT0hlQ01adFBHb0drcWRkOXdURHU2eDJackhwU0ErMVlhTDQrVjM0dERldnp4MnRpR09EU2FBaHVkeW5VaDB6cWxCQm5YVTA1L3pNNllLWVl5OUxpZW9XRWVmTUFWSjZWYU9zWXFQWVVxcE9kb1RTMVBNVCswbEl2MHFMMUM3RytiQXQzUlpYYUg3TTRBYnA1VWwyS3JWMTVYVXU5SFhtcklOQ2x3ZndXb2JmQ210R2V4YWoyblZmZVJjQU5wNzhqMTN1ZEpodXlrNk9pUjFiUEU0S1dUNlZ0cEhnQmluUzFHbTMzVTVjK0lvbHRFbncvdFVpUE1HbW9oblU0WUlSL1FUSC80bzZjd2h0QUhqOEdyUU54VVNuR1RpY3ErMmkyMzRpNk5NOHFMMnVIUlZaRDZqL2QwNEpCQWxFVk1FdzZmRFYxWUhiZWZDQTFsMjFwamFLZTAvcXpMK3JLanZpMTZJaXd5YmxPd0REc1psWkpkSGYrL0cvVjZuanhkSjI2R1ozakgwVFUwcE9kcW56VlpxRTRVcStlUGNyWUZSZ1BwbnFnTzFSK3pJc2Q3MnYxZWhQSFViczFzYmpLSFNMQ2p0ZDlaUTg3cTN0cjlPczJDUGhlMWpORTRJdElVVnd3dDd6bGJGb2NtNEVLOE1TVFRyWElWeEFTSkhsZVo0ZFk2ZkE0RzZld3E1REtNUVhRNE9iV1JWYVpEKzNPdjZmeEtIemthN0h6Sk80MFJSbWZGSTlXR051Y0ltdzcrMnBRUVFnaTVJZDhUZjMzcjFKZFRma0lJSVlRUVFnZ2hoQkJDeU1sY3VTejVMVXVpWFBvbGhCQkNDQ0dFRUVJSUlTaGNTeUtFRUVMSXc4bi8vVC8vbjdMdjJDRlordk5makh3ZVRXUXpMdlNuenpOL0tpMkk3aldtNVVNM2xJRUw0MjFXbG9SeWFPdS9seWl4SzJUUExoRGtDK25aS1ltTXM3aE9JK0puN3VpMmZzKzJuaDBuL2YxYzlleU5MWE96dUEvcjZMMWZwMEhUamU2TjBzaC9hT1lPUjJUcWl1N3I0dTFMcFBmYy9VN0JZeVdJNHUyaitqaVRHNm42T2cxOVMwWFFka1lNOVVuSTNiZC9yMGRrakpmaVNPODJXeTJaVW5adldhejdIcDRWOGZKRXlpVFNldHZML3hQVll4VHV4Q3cvWk4zUHIwK0dIekoycW15ZWVOVjVjcG5lYzdEZDg4MmlLTEw3cEp6VlgwYjNkUE5zVExRc21xd2tycC9CL2NldFova2dWL211YW4wTXlSTlNtNmNXTytQVWxDVUxjekNoY3B0UDBGNkhmS0pGcncvc0FTMFR1UVdpdVR5cmhWaktlb3E5dTU3MTd2ODdodmFac2ppeG9UbCtlNmZZUFZOUVUzWlZDSE83NnVvZWVtcXJsRkVHSm1mb0theFFQQUxxaXA0UVd6cG0xYU94YkdzYjV0YUxodElRL1M0Q09xcjJ4Ums1ZmRqQ1cvN1JRRTlyN1FsaExadUFDeGpJTzZwcnhIWllmYWRtSktTZFNWUm5KT1ROd1AyV0xMUk5Ja3oxQ1dENjdOeEh5dktCSVpmMTJOcjlERnl2NzYzb09paGVHYXowVnBxSXg0eXVkclRTb09tR2hpUG9mK3IwLzNUMitoT2tNbzNyVmhnUnFRZTBDRTlpNVBtUjlEVXptbjBsa1M2V0VqNU9FZHZoNlp4SmJ6L09oejkrS0ViSUx0SG5tTXI5Tk05bEluNm92ZzlNRzZyN1luNE1nSjZnaXN0THJ6SWNyMm5YSTNWc0xwV0phYkZaTWpGUjB0NWx5YnJJNG9tS2NmMmdTeTIxOThUUkVZejJtcEZhdDRoR0dxM3JFYXZ2Y1lVWEhMVmdQZTBxWlhSaUZpSFFmbDdnVEs1alJoZXo3cU9CeE16NU1Cck1kT0Q1WTZzSUxUbFd1cWhWSG5uYzNqaTVkeG1IM0pSWnJwOU1aeVFDOHVZSmJ2Nkd3WkpmaS9WMEprTVV1eG81Ry9NMVlWcG5DbEhmL3hXTUJoNExZNzA3WTludkdiUEQzdmNKclg2OWF1eTBkUEhFVlBJVlhHTHpHSzBSUWpxZzZUaURLMnVaTGJ3YTFqQWhjK0JZSW1RT21ZT0prQ2x3S0JIeVlEaUFGL0tsbFh0RmdIV0ZTbzZkNytCYjJwbjltUkJDQ0NHRURNQndrcXlEdllzUVFzaU5vRnNpazJCWElvUVFjamI1di8vbmY3WDlIcFA4ZmU2Zi8rSnZXRCtLa1MyREZvTDhndnUyREcxcjhrcGVkaDhoVmVTRFFUYnF1M0M4ZmhTOTJ4bHBlVHZicEtjSXlHWjVIdjdtSjlZRFdxVkFpVGlpNkY1MlcvTFdGbEhvTHFZclFMWXdYRlVHbzI2dDdZaW5iRHMrRjJUUHo3TjRyT2tkMlJZU3pkTVR6S3p0T3ZjQzhmSFRsT1RYcCtOdTBuV3FjUTEzYno3RTdzcDBNNk55YnhkcW1XNndOdFhIcU1wUWVzcU9CRDJqSFhwRmI1bzd5TXJoajZUdjNIZjZnS2pIOVdybHEyS1pLNnpKV2JGZnJXTnQ5UDVNc3VtbnRNRld4T0pKbHRkQmRwTC9ucnd3Y2pUZElYNk90RFBhcmoxOXlmTS8zajY5MXVma1hDZFB4dDJCMHdtWGtLbTRQRzNxY05wSksweVM5eXRiMEJ6SDRmWGF3THpZT3VwcmFHNDlHZTlrMFhmOWVEYWw0MW1PRFc3ck90UWxxTE4xRXFxSzA1RURGRkVFMlkxSHVoSjhRS3dwY0Y4bVNVZE53MlZCRCszZFp3SUxjYWUxaUJuaDVCWGhNeHJTcDRDT1dhRnFKT1RKSGRkUjJmWDlwS1N6d3FpV1BFUTJhcExtbWJGVGNlT002bSswZWRIdUdsbmRhSUYwcmY4MDBxS3ladzJwR2JnbVkySElnL3JDa1RKWUo0eVE2MWpwaG1hRkVWZUdBRkpHYnlpQTZPNVpBYTZYbzlFWStKOE9RR2hPeVR4UnBZZVkrOTAvdVg5NmFheUYrMDVRUmZ0OW4yeDVSY3Vmczc0dVo0VmRWcWZTYkwwRWpTUHlrbmNhYUlBcHJ5Zmpma3UyOWhuQlc3K1RPa2VJalI2ZGFBQzlVb2RWNTZpVlJPbHBWME5sVDdjMUJ5WjVKTDFCUUowL2RjcUlCbDZlZVJyb2k2UFZJR1ZaekxEU1BmUld0WmN1S2VscEVpNEFEYXpSaFE0MjRpVjB6OGtHMXRlam0xb3VNTCtFOUlGTXlYTHpzaXM2S1NwYWVhRDFqVThuR25CczBKakFlTFArVnI2VXpxbnFHZkVrZjIxS0NDR0VFSEk2ak1ZSklZU1FqNGF1bmhCQ0NEbWZLNCtZNVBHV1pCRmYxN1d1ZU41dkhiNDBXK3RnM1JKQ0NDRS8wQ2N1aDFWTVBvTTc5R1NPSmtJSUlZUVFRZ2docEpjLyt1VlZPMUdSMjlENnFmV0p6Ui9acisweVdqOHpuMVdISEhKRVl4dW5XWHl1WWQrWlE4L1dSVGV3b1ROVWxsMG53M0w4NE85RnF0OXJkV2hQWjRCeW93WkswVEtjc1NPb282dU05YW9abEVscFNJQ2VDcDA1MUI3Vm9PQStSRWl5YWMrTmxXbldhYWw3elNQN01rWDlrSmEvMXEyVnBmZEpFZG05TE83d3Rac3Rvem9qQTMzMHVWYlV5eUsvSk92WTJMVnZObkxFbE9xdm5paXJ2eFFqOTJmbkc0SFJ4RDBvWWtpVnZiK3k3Rmo1VGQvRGJzcGR5dGpZS1NPVDliUEhqT29rTG1RMEZpQ2poRVA2cWd2OTdmcnkxSlA2Vkt0aU5LODhYQmdheDFaWFFXMUJlTjBIelBDVVh3MTY2eVRRNDA2eUdhMjZWZThCRnRvNkNmYVlzSkVPM1JlNUtOZCtpNUM5b2xrYWdLNkV5bnFYc05qMzBPdWpaWWtKSFV4M3hWckVqSHE0SW54ZUVkTFBXMlFZVHp2YWwrUjlaRmwxOXZNalc4QS9PSXdhV1RJN1kzV2pCVEp2dUhJSXJjQjkza1dGejYwNEVyeU9vSjIrU0o3SDJXSEVsU0hBREJrajlRWGJRRFIyOWRKbElWdjR3SmFiUm1jRnFQdE5sZXFDMXdSRTcvb1dLbjFjd2xIR3RxYW1wemZrYVBPbVVqV3JhRytacnZxbk1ZZUtqUFJWMWdPVjZ3V2FhSytNWE4vdVJTS3hGUTV5ZGZUVDh4MllLSkY2c3RvVk5ZTGJBQWc4VjZzck1lWjVQbGV1Wjh3ZXZoRkhiR1NkV1l5L1JDemtRUEZkUnIyVXg4T1hGcDdQaXNVRmNqcmRVUVRZL21xMGdTaVY4eWhDN29EVkdZMTVmc1JQelY2UC9TcmZHQTA0ZUhKcW1PSjg3czAzczhwbmpLRS83ZVRJcXhYeThZZzFqanVvNmluUzlNZFlVQisweWVSQWEzR3dwdytlT0o0Zmh4VXNvZmR2QkZMVS9RdXpWdmplKytCU3BxWXJhdlhBOU5DUFVyM0JNTU1qelI2d0l3TTR4MjRYSThHN0NOY09nTDgvVkZqN2d2WkxlSkJkdXhlTEsycmFGQ3lMVCtKTDB5bXVlbjRZZ2ZpaFdUck9BSzBoejJmMHlEU3lQblpjM3p0b3JYK0FVM2JkK0tmUzRTamk5YzJaSXZ4cXJoVlU5K1dJMFJhZzVBTHRYbEp2RkpFckhTTnQwanVUcDRQNkZ1b1k3LzNqMUpiSkJMdUdOZForN3UzbEhNWk8xbVB5SXI5Rko3OFI5NzR2UHUrMXB6NlBiQkdwR05Uclc1Kzk2eWhueEFJa0N0U1RLaC80YnIzNmhlRTJmTXZ4K3IvTHBWTTMwbFhrdUMxUkpRR2lQMHExS2tES1FlYmNNMlZwc3V0ODhuTkVUanVCK0Z3YVNaek9Fd2JRTGUrLzYxeVg1TWQrcjNUbGVNMGpqejcrN09wcnFmbzBjMjQxTU5Md1dsMjBnblR2ODBwVzZrTFgzZThROWw4NVplblYvVEI2VnVWSFY5a2pvTTA1T3pvZWllQ2pIdTB4YnpRRyszZDNTUFJCVTVNcnpkT29yay9CRzdlZUxaU1VobXp2czhmb2VKMFJaM3JqZnFkQ3ZMYTAwbTNybWpQZUtkWjFHakVWTTh1Z1NkZGFiWTdPMzByVzE5VDBocGZyY0pGeExYK1V1djJiNnd1dC9JT3I0R2xHZmIxQmd0N29uTGtYcTJ4V1Q1NFJEYzJJSkhySkhXa2kwV2tMcEU0djhIYm9VaSs1RDE3UUhsMkxxR1d0V0l2UUFwSFUrSndHZElIMFdHV1pmcllWOXBydHJOak5ra1V1cEhlQ2dONG5wOUs3dHVLK1Arc0lTNHhYR3V3eVpCN3dDekk3M2RzSEd2UDhNOElJamdteUNqUjBYeEFPVHdlWlJUcy9USDNDWTVMbG5OZ05Ja3M1cTJTZkwreHlOZVJKakhZS2RxcCtGdGJkYk5GeXZkQk9zNFU5TTBMcnlCUjJWR2ZIZERuMHJZTUlwZk5lRHlQeXdEb3YzbzFjL1h1TlFkbGVwVjdGekFWbzhsU0EvbDhRUzJ6bDFTNjBYbUxHZFZqdnNMWi9DNXh2eHN0aCtYeTlTNkxGK2R3cWcxYW1pSzRFeUJpVitXM2N0ejRPdmJYcXh0RXYraFJyTi9teTA3RFRYWThZcTZlMUxFWVAxMjRHOFFsam85YytJYkkrQzluWGlua1VUb3JKYlo3TVozL2NmUm11SEs4aDhyQmpQMmIxa1FKZW15Rjc5aHlTRWZZVkhOeE5zSDhmSWpudnpXQ2EwQ09ob0xVZ0N5S1RLTHQvMUxKQVlqb0t0ZUs0c0tndU5CLzB5NUxHOHd6OU1xVk1TcFBodmhQcERsN1Zsc2xtL0l6Vm5JdjNNcHNQUGtIZUl5Y09QY1BnekxwY3FldE83elI2cCtabkxnR1RmeUFyUmluTmp5S1gyOGpYdndPZXNUc2RrdjVXYnpTcUVLRG5SMjh5RE9uNjRkeUthZENKckpvTnJvUmhoSjZ1cCt2TnRBMXUza2tONSs3eGxac2ZkWmx5clNuMVU4dUtoSHFyMWxaYjcwdG5QSGR4NXJzRjJpaTZKZjhIYTAyaG5ydmc1UjlyNFRHOEVlczVGVGxiRzNsdmhxNUhadWQrRDNldzVGcGJvSFhia3RGYmpoVFV2UURyOGNsOW1SRzBkNjc1ZGpxTk9XV1p5SXdSZG1ZOGZXYnNSbTdJRGNjUTZhZU9za0pSVldsK0RQTnhHMGlTajZWVWc4YjZycE4xZlZvWkVrMHNXY09kM2plY3dldUhxZG9DQjJlbEh3KzZIblpCRWVRdndKRmZXUytqcFR3NmRKRDFQeVNka2lXWWpUeVJWZ05mT2tnK2xJN3gyRU5yT2JxQTE2MzdXc0I4blBCR2ZYeDJ0RVorUU9TbFhSaC93RFAva3pwQ2lJZ0RyOHN2bHo0YWVhR2pPRHduNk5HdTIwanI0NXJIMnJNMXRvamdqa05uS21BUEdPNG9rVjZIS1VObWVkSG0rOTE5dTRmWjBheFcrbEZmWjhuT2pvd1ZBd0JwSFVQM3JLM3JoNWpyS3pBZGMvcFlGcDkyWDBTeWZxY1FmZGtiTGtkcS9EaFZyMnRyMS9oaXBPdjc0bFEwYXIwU2RFd2xJTjJkZUo0alBrU1ZRSmpaYzNyYzMxTWJ6QitGSzdLbmNqaUJjRk5xMlVhMEVKWi9RaXBtbGIveUdQSFRaRFpvbEtuMlVqRHpRVWFIMG4vamQzL2hPS2EyUENVbGQvdG9xL0RXanlrbi9WaiswWGgxZG1od3VkWWcvbmpmYnJUckpxZitWVW1keGROMUNISWF1cU4yVitnNFdHT3dDNmthREIrSFhvL01WQTZmcTh3bEpiZVBENTNtT3RzTnJYU0JVZGxKcEVlbTlhanVTRmxXTVRBMVBjaUl5SXpxV0FHcWM3UzlQNXdjVEJPeDF0NlFtZEY5dGZSUkhhdTQxRVFZeXQwUVFxVGRybXNoZ0pVWDhVZWhRK0cxc3RtM3drUk41Qk5DempQTitJcCtqc3BjK1p4TGxpSlMyNFplWXFkNjQ4Y3FuaHF0cTVIOHZhSGVqRk5Nc3lON0t4SGFqK1dWRldYekJzM1A5TjFleTliS3RQWkw5dTZNNmZYdmlOZlBnZXNqbzlTYkdmYm1QUnZQY2xuM3Q1RnBXY0ZXdTNwbFNFNzZ5RnJ2MkZwRUs2bWFEakZZNUQ3MEJqMnpIRHc2aExUN1VUMkJwRWozUjBkelQyelVrMmVVYUt4S0hzcUtpUTZCR0ZsTDB1eFM3VzY5YU5JdFczUVJMZm0yanBEbFdPL1BHcUc3MXRjamMrNWdrVlJkSENzR28xT1pMOFNMV1pIOEtlRitDVnVYMGluRy9aN3kvOEY2QllmYlI4SUF0by9OV21Ubi9nQTkyZG1jWHdEU3Q5Z1JIa2RySFcrMmptczkrUVRqQ0t0cWZadmd4YVBIeW9XdE9YeFN5VHhPN0ZHcXpvOHl0eXNlaHY1b0V2Tjcrb2hQc0NhaTh6aDdaSHMxNFMwem4xSFdxTTdjeVByRWdUbGpaclRXeUZrdkZNNUVmOW1obHdiL2N0SEkwMFMrakhFMVpWS2F1L0c4TWgvNnNmY2RzSlE2VFVTQnl0QWY5cFl1M1cwcjRubmczb3E1MG9KZGFUVkpsTjdZc2FlVjc5VXJ3Q2RuZDM0NDkxZzF1NW9aODhSYndLWThEOVkxT1psUHQ5YWY4dnB2eFlIdW93ZlFsNTRwMmdtVi9RbnRMWm14aXJjNjN3eVpLNTl6WlAzOTAxYmpWTVJ2c2hEWmFKMzIxbjFzT3JpeU5VWmxUeXhiY0prcTU4WTdqZjkzNGZ3cDl4a1cybHNqUk5MMTZKdGhYVGdKNk9ORzMrUm1FejZMcXgzNXFsY2FBOHoyZUNOVzk0a3hPeUZFcHdRL0kvZG1YWGNUU0VOR1gwOXVpTm0vbFVYZlZkM1lrOHVoMHlBYTJ5Mk1CWjlBNUZzNHMrTEpLNnBhZTc0L2lYd242RHFYbDNZU2xnMnl2Z0t1Z1h4bmNScm96OHFqM3dVVTZWZHN6Qjh0R3JrWnFQZGdRL2VoMVJmNjNWK2p6aEdSYUxQKzMwRCs5WUVIV29xNlJyd1hHZEk3QkY1ODdGNWlGU1ZQQVhWNlJEMVZTOWVNWlEyUDBpN0MrM3FqZzhQZjFwaGppTFRXMi9yUzFxTnd6ZU5HMFlzdkxnaWo0a1FNd3FvQTY5UDkxQ0dJMjY1cmFaUFRxZkpleGk1akgxck80dHpYNWVCbHdMdk9lby8xUTZuKzdmbTZTUzBEU2F2cGJxV0xEZzZqejAzaFRNdm0rZndWdW1PeVcyUEZEQnNOMGR1WGJzclFqNGIzUHBITVlMUTJyWGd6YWpQdU10TS96L2tmWWp0amtMMVBtT2dZTytZN3UzOG5NYjdLOEpLTC9UaDFZdDIzVG4rRWRHc1pyRDZGV2pEMGZnOW4rWHhpa1E5Ly9LQjF1YUtrYTA3RzlJOURGdEtmTTB0cFJiLzh6bzVvTFU3aGN0cnIySFRtL1dkTDUrR1lTM0F4dUtWanRJd3RtY1ZwY0l1Q2ZHUENTTHZaUm5kaDNIak9scTdtUGNWbW1tc24rL3U1YkxkbFQxYzBTOU52UE83UXFhUWVkZkcxY1cxbE04cUVkT1AzYzZQUEV6RVd5SkNJNlBia3RtempMRmNYMFYzZmEzMzJRT3E4dHo5NjB6NHJYY3hweEhSNWRWeUF0QjZvV1VKRHV3OGhNbHk4TkdqVGVCRkUvVGM2ZEx3b1JlcUtSdTR6dTBIdlVDcURNczRtNURzclgxZ1dqVG12TDBYTnRKWS9kY3JvMWIxQ3AyZWVaL1RmWGxiMGU5UWRyY1J6dDExMW5sL3BaWnk0eVhMaVIrKzZCV0tuVUpHUjAwMHpLQ1BXYi9XVFFqMi9pYmFqWjQ5Ky92aWRyS2pqMWRnbzJnM0huY1VJclIxbEZqOStXR0ZOb3ZUcUtNbTNrbFlMSjNIZGtoMHBpMVdHVWE5VlFIM2E5WkVKSWxwbnFJN1doTkJLNDExM2VyaXhGdkdydGh6WFNveVB3R0FpczFnZFNGd1JSR3hsdUVwM0VLOEpvbk13eEpkR2xocTBOR2N1UlpBRmpEUzBsWmQyK3hHZ3B2RVE0MFludXBJcTJDOVpUOFl1UkthRGh2QXYxRDVaWFN6VnZIREYyVG4waXc2elk3dm9GUFFEMEY1enRlTE0yZnBhbE1IN252Ni8rZi9FSnZ1RWtBTXJKOW5DS0d1cWVwWXh5UWNnSGZab3h5Q1BoczNkWUhubGZHSDBmQkZQcWVWSGpjY3JDL3Z0aG1zTDZyTDQvRER1V2VRWnkwZ3JwdUtvekU1clovMllZUXF6VjUxNjdxL3NiVEhaY3ZpZXFkdVRNZE9VTUw0Y1lXUnlOdXZWOGt6TzdWVnFQL1l2alBQdlY2anFEWkdzSFBPTjZIeVRsYTR6YzhWbmRqdWlYMTBsWHdYUTdDTTk4WFRmZE1WMFgvNGkvcUh6QkJ5bmtyZTZNTDd3dkVKbHBUeGQwd25Pb2U1YTNqS3poUm01QTlYMlVkMzZjN3NKR1dGRm4yQS9XOGJLWWR6NmlZUDNVd1Ryczd3ZWpjVG5ya1RNcDV6dEpKREdMN3QvdWpyTWl0WEdXZm12V0ludytuVTAzeG1zMEQweWJsZjlPQUcxUVJFZDBYeldkNnl6OC9sK2pJMlN5NmVEeFZsMzdqWFlSZnhodk5NWTg4MVh2dE80MHROR3l1S05xcFMrWUZIaVF6SFdNemlmdUpaVmdVUWdsalUvUjNWdVpPZitSWlFKMTN0alZVSjJvR09VZkJTUnI0REI4OEdpNjFDVlYvMk8zWS9jRVcvZXYvWGpYUFZqK3Q4VDZmMTZTblF2bmc5bTFucFZBVCtmV2NWSWFPT2NtTW9oL1JYY1lPQ2pMODFrdWhhbjl0eHRxUFNPZEJrODFnOWFkRlZlVWNnSFkzMXJLS1hZSUNFeG91OGNYcUJONHEzZmFkZlBiVzdMd0hrV1NVdG5XU3FwQTN6Qzk0OXg2andwNlMvRWVyL0cwWHB1UzJZMjBubDFHR2xacXk2bFl6S0tjSGhjY2FHczdIV1lqRHlROXd4bVRDUnVRMC96eWk1SVA2U1RnV3VlYVp4RXl4b2JsbU4zLzc2Z013b1B4SzlGN1hiTFR2ZGk2TVNPOXlNcXVBRnJSampWaGQvZlV1emI1TDFMdmhGK2pKeWtpdllzdXpmblhSbmoybXQ2K3ppZHlUT1oxMjY3ZnF5SVcvVWREbWdsMWNKOGZPV0crZ09yaVBKb2pIN0ZXQnFwVEhJMm85SFRlT1phak80ekQ2aHhjNzAya0FiY1VQNlY1MDMzZTA0NmxUb09Pc1cxWENtdDVkcEhzb3Y3Umd1UEhNbHBIcFZweUc1U1BhODJ0elIxUm0xbVhYZFdHdkI2TWU0YmNsdGRFdDN2QUc1dUM4MGRwVi8vVjFMSERLWFZoU0lMb1Z0aDZ1dmVPSTZtYittZUFlcjJpdkVabldxT1BHZjB1YjI2MTlKNVM2RkZ5V1BKYXFXTHB1a2hHbTYxOHFJeWlxUDdRNGsrWHROVkdHa2pYY25xeHJQWlRPVi9xcy8xdjBoK2o5eVpaMlExd0hWSERiL1Z1dy9GVzZZb0M2S1RVNWI3RURHelhqNnZIMy9hS3czcmVXYy9welZjQ255eGttV05TMmZxVXRKKzJ0QVZ3MXBsNmtqOW85dldQcnRjNVhDbkdQZmlZYWE4V3o5WFZqWDZPaFN4UCtrT2hTMy8xc05WSCs5TnVhWmkxM1lzLzBoZU5QLy92Zjc5ajVFSERUemxLQ29KajdCU1VDY2lBOFY3cm9nTWIvVG5ZSHFadHlTL3p0RHI2UDBxRFdPZHowY2J0aWdSSjZFNTNKYnVoZk5hTGNacGhmcXpmRWRMQndvNmVsdVdJOHJUWTkzSGc2NlJXbXRuVmdQMnVDVXlGY3RVeWpROTlnbUo1TEpUTUhSNWtsMklUTWQ3cHdGME92bktkYlNmZWpPYTFqaitXdEJwSUpyL3c5SGN1T1VEckx4SnlEaVRpRi9TZkZDZHovbGhLa1BTandYcDhUZHMvcEg1OUpObytlQUhOaHVaRGVxeFNKeUZkYnVKUHR1R1hkZFYwT2sySWMvbW8zcDFBYTVGUDVQYklmM1JXZjVwdkd1TUxJMXF5MGhYUDNuME9wZ3V2KzdSN1hiUVYyR0hNZlg2SXVWK3NUUXFPMTZXV1JyS1VNZForWHFYM0orQmRyUE04WWxkb1J6K2VIMWNVWVpUandDS2ZsMWkxcXRJdnJiNUNwUndhdFZYQzgvbGd0V2J3MG1wRjR5aHI5M2daUDB6WDlDanVnc3hNbzM0K2dpdXQ2R2ZOdXh1MGFFdmhITnRNcG1lSVlVdXgvWjAxVjVaOEdwVzZidUhDZC85OHlZUzNweCtXaXQ1TXpQK2VPSXJqZDR5UmV6SFRGc2h5ekM0b3UzbWwrdXQxanVPbWZ4ZEk4Mk51MWVTbDVlaHJIbDcwbnlsb2VnOFBlYjhqQldOTnRiN01hM0Z2UjR3YXczeFcyRzlrWW1jRWR6MHZvUmMwTlZYem9kYWNEbUFFT0toZlNzSnlpZmZUVHZwdDY4RW1lL1dHV2FRQjFDY2UxZDBZdzZkQ3RxU0VNajZwSFg5RStMTGVrWGhqMzZMZkFVempjYWtyb1A4OHJ1MmQ4Vkp1d1FrZ3BRVDdNTmJzTDdyMnVrN2RYcU8zaThpTzUvbGRYWU9IRzM3Q3UyNmw2K1JwS2JFUkRUVHhaczdNaVgyT2huQzVpeXNTa1hMVVBUTFVGNVJGTGdza2RyV25sUHpXSmFNeUlCRlE5aWM5aW9MS05aNmJnM3BtS0t2emt1N0tNa09OKzRZd1Q3Qy9MYTYrV2lsempOVW40Rm41azZ1ajFsaEJCSzdyOGQ3R3MzR1ppT3RKMXRlNy9FTm5pN1U3Z0srVUtyMEpoQ1JVN0pjWlZlQ2xtWEVVTzExSEhxaHVDQVA5anBvS0Z1KzE5ZUtnbTJ3MmpmV3A5ZVYyN1R6eGgyakFFbVA4ME50UmpKa3I5QlpwMnZwanJFNzBPODlSckpZQU5uOWM4enJoYnA1LzJjUk1ROTJPS0FZbjJLZy85YTRZWis3cWltYTJRdnVQSHJhSDQwcXlCMnhRbFIwcGw2cW00ZXhsWXpNbnJuS0hZUEZtbktINWRTRlFWWm1pbjQ1VmJleVVadldTYW1ISUVMNVlCMG4xanFGdFhWOXA2SVYrUmVqWEkzODBaTmtXenF5MFptOHdNc3FyRHhlVGNyZEo5WmxtODE3SEQwbHBhNURhZC81alR5aGcyK2RMbFRMMkMyWlZkY2pPclhyMm8rRGlseENVM1REbjcwcFdRTHV0NGFCcDZ0VnJxaGIxZ0Q2ems3SHlCUzBkSlREZXQ3amtQRHoxNThsSStFbzhuemEvU3orN3FrZmRDbmlTK2tadHZKZXRGc2p3eGpGMDlFQzdlb3lMUnF6V2VubHZkTDRqTWlZVGUwelZ2MWdkTmZIQW5aNlJqMmdkVDVDVkdiVUZVYnU1NDdydGF6bW5NU1JoWUtPNDhoeldQZlJQaFFkNXpQbzZkOXVtQ1hqUW1OcTB2b2h1WGRpU2diS0ZpVWFMaVN6RFB0YVJmS1ZwcXpTMENYejU5Zi9kZDFiMmJRMVg2dGQzOWRmRXd1emZ6cVRtcXgwdG1NZjJEOXZOa3Q1aG1lNlFuZHY0Rm5uUis5cExWN1NXSVF4Q2pJSjB6NGpsanVCYVN4WkxSMWJ1NkV5TlJsMU9tY3R3aXhEbWo4bkpmMzBEaFV0SHhyMFBDV1FXS3dhWFlyWTBub3hIWUszYkJMSml6WjNLMy85YnlzOVRjT0ZJR3R0NUJSNm9naU5HVkhVSVZyVDVsVk9DQmUxQ1lUQUdCMzRjRGt3c2E3ZlhaV1U0TTNtdkxIVWlySnBaaHZVTm9ZVnRPUE1rSGRsU0Qvek9UWlpmMzdEVi9hYXIyVkdqenA1UW5scGo0MitPWm1wK3VWNDFTOXdKUExSc0lISkVxNk1BV2Jvdk5JYk1IWTZtM3FlYzVFYkR2RVJadnR1bFVwdXk3MjdTZXR0cTNhOVRvKzhZRWF1ZS9kU2Y3N0kyelhsUjE3enh2a1RqVVZQTy81bHBmKy9aejNlNzhlb05TdktObHRtajd6QUNuM1gvUmw1MXZTTFhQOFJIYWFkNXJuTEZJb3YweFV3blkxbVc2d3ZXVVdYaUZHN3BmbkFWbHFONHR5MzhuQnVkV2VzRmpxc0tMVENybEd5cC94RCtOcFRTeThBcnV2c2ZGNmc4a1NrNVc5TkUzbzl2L1pPNDRtekIzSUQ3clFVekRXejVWaXUzN3IvRkVhN1RTdGk5eUx4eUtwVjc0ckpUTkNwMU1pUFZrdnJRUnVkN0FrckVUMHlWNncwek1pcnlVRm0wTE9KakNIdi9xS1Y0dTYwMFh5cjZucGtWVFlhSnZTc1h2UXpzOGF1SGRtNytuSTNRUzd1N1d3S2Y2ZEthN2hySUZlQ24xZlJtaEUrSVFxN2N1SndBZS9IQlJmTHVPeDBEVE1kOCtwQTRveFhHZ3Y2NGF3NURETDMvQ1FyODZuTDdJVDBNdHRVenN6YmpKODl3MFhJU1lUN3QzQkVyZC9Ja0F2eHZwdjRwT2tpV2NycnhGU3JKN0NIZkR3dEw1Q0JOSXRwRmFGbDU1WVhlWE9HMHBoYUw2TXRJOXdRYjk1VEh0UlNlZGZsVkJLRURYa2VyZkc3OG8yc0VPR3AvRCtSN2orTjlKNXQvTHNUcXZOYVNKSFVRMnNHYksxQ0lxdVdYaHI5bzYzYmthT204YTViejRXK1lvMTBMdkJySjluSUZ6cHF3OUVCVTVwWFcxK0ExcTdiRXRlZ0xVeC9sTm4rK0FjOENYQm9ub0ZsaldjV1pjMVlIUEZENkp1eExOTFBlSUtXeFpvd2NVaEtjcVNxL3FYYlZ2YlNEZWo5a2RYWkZ2OUllMHF0dHpONjR0V3ZJTndmOXpablB2eFZxdi8zY21ZNzlUcW93VEdueWlxZDkxY3cyNTZ0MVpuQkM5dVBwZVZoZDZHSVZYU1pYSDJlMGtMb01YR0hnczBtYWhWbTlabUlRNHFrSnl2b21mMW1JNC8zb3JCWTRZZGhqdCtuRlZjbCtGbkgrSDBELy81OEtJUVkxTmFKbTlZVXZvWDB5WWNqZnF3YUUyVnBuVnBxVlNZYVNIZ25wemFSZnRXcHBHaFpaYjd0eEZoNUR5bXJlVXgyOFQ4WHIvZGI3V1lrMzZwYzVOdlZwTFU4SXg3WGZTeXJDQjFWZHRpRk9oM0xoc3EyTUUrOTg2cmVhc1plV3VzYm5teWdTM1dWUThQU0VaR0xQZzk2dlFWYWwxSFptdG1PeXVpeDhiVnU3YmtzSnhndEE3cEUvaVhrZ1RTZTk0ME1WMnV0eklnaXVobGQ1WXJvSHpHaFVWMDltS2RwZy9tR1hta2NoS2IyRkdXZzRWYlY1U3dYdVlyUjUrNnBjcWx6ZHQzUEhGTXIycy9TNFlHV0FaMU5hSm15OThDT0lTOHBOVGR3Ly90djY1MzVXY2pIOUZ5L1hPLzZ1WkxWejk3Y3ZGVHBwVXd0cDNXL21Ebnc2MUtXMXY2SGU0MzhQN3BHQTZUSXFJdGFFeXRhc01vY0NWUjdBOFZSaXpVaWU0YUY4K3FvVmJmSXBLc2tQNEpNRFIxV3ZpSjBXRHJSVVpYYnlYYVBZYTNQeEVTVGljeFlRNmhsUmN4U2oveVUrZ0tKQzVqOStGSzJSV3U2TUV0M2F5bkN3dXRpTFRrMEJSZWdqZWVhcU1zbnA5RXk0NzEyNmVBcVdxODBaS1k2bmJ5ZTJJWElRdENGV1AzalhvenhLcTYzS0QyZ000MlBZelMrbkRIdGV4Q2phL29ia2RtL2xuKzJUby9JN1BoUE8vbERaaHFrbjVXenRFOW5xN3NUaGtaNTZkRlVvZXYyaEJDQWg5bEVMWTZQMm9TUHN4VTBpb3M1eWZFQlhEbGNaUWdndjYveU9DS0ZIdjEyQXNmaTVZeUVzTkVYSC9kQlBuRUIwOG4wSTdWV0U0bnFnMFNLV083VVV0R3lvT3NZTTlIbHR2M1JwTEljdHIrME5mUnFMTXBmNDV6Wng4YWZmSDBacmhoelY3Um5UR2R6MTh2RHNtU3g3MGVSb2h4WkpXb3pXK2xML1lmMmJhQlo3U1o5SCtJa1Z1aHVsWUVMazk5QzVJc3d1M1NLZ1dqNlByN0N1SUNCU3I5azIyUFBIcDY0Nkg5VFprWG1yWGNheTdpaTZlN1VYYTV3cTdTNzYvaHVVM1FLZDZoaUdSTjU2OHhhT2t1bTlUbkNHU2FsZDNrcXVsZkgxY3hzbHhWeVpsREFhOGg5Yjc1dzVTdU5tV09xdDM1RzhxQnpzUkVPeXptak9DRTZZaFBQc3ZkOWVwRFJNeXRLYjkrMy9NeVUrak9LbEowbHBIM3pqMXE5RWVzUi9XeGRsN1U4VXJ1SXpxdWluVHRFV25mZ1JtdWZiSTVyZUZJZ1VjQTBOMWppWC9XRFVNbE5IcGNRY2lNaTMxS1paaXVzNllJUlZ0TGxrenV5Y2xaRUpoS2Q1bjdaeGdxam9YelB0M1ZrbGQ2aGl1V3oxT1A0ajU2RklmUlhJWHZyRFdsc0F2TG1rdUo3MzIvM0NpVWZ4SWxjQzZEU1UwRStqTjRHWnNld2lRWkx2Uy9OaGNxSUdNdDBvSzg3WXFBaFRDVGthVTAxZXNyd3VsOFVyL0N1M0FMS2poaG1MWDJMM3BWZnExTzI4bGhZNVMxR3NvWnorL2NyQWlOL1V4ZmkxZXVudHV2WTJpSDRETGdBYlVEL01vK0ZkUm1OSjYzODdWRnM1ejIzZTlUMjNOS2VsWFFwK1UrV25jK2xjUytLVVpiY1NxdWsvM2M3cDN2OUtMVm1SY2RmMyt1c0dpOHlRWTlyYjZSQjRrbnBUOHN0NnJhbkFucEI0eEZQeHFjNXRqTWNOcTdEL1ZIcTY3TWNVK1pwY21ZQzNRUTJ4NDZweTliUjVCQS8xMzVIS0QzRTVPQzh5RlJhVWx2R2pQN1FVNFpSSDBsNmlkWjhQYW9qdlNXMjN2SHlWN2xVeXFyNS9mdGkvZWZQNTcrbnF4WjVmMWNRSTQ3UzVQNElsQUxVWkUwZGxvMlFzaldUT1N0ZTY1SlR6ZnViY3ZJdXVWazVCNXRaUGJCcXpJdHRyR1hkV2UzYXROdmwrSG1YT2UrS2NpeURvY05CY3gyeTZxeFFIWHFzWGtyczgwRm42LzdMZjJmUFBjalAwWEFSTVZEZWMzcTAycjAxWmRUSzVQVWhyMnlXUFBsM1Q3OUErL2VJKy9aQ2RNbmcyRlB6b3VWWDdiTzRaNEdXMnpCQjc3N0RVQW5HTWgzZThPMHhJZDc5bm01ZWQ0RUNwclBTWEkxMWdIMnZMUFcwN2FodFRYNW9ZNjZ0aUpBSFhURzBvcWM3dE5GZEdUSDFkOVlaYmZlQmJ0Nk5aME9odkZrUDQzT1BVRk9KZDF1dmJYbUNhS1FJMXVtbDllZTlUcjJseWk1OXV5eDFWU0grU1FzaldwL1Q0Zk94eklkeUdaTVZzMW0zYVpVelRUUUZWcDBuTDdXZVp3WFF0UTdQbS9jTUVxMHNNd1BLSGhtamJZWkdWTVdSVVpUUFVRc2IwV21Wd1J1WldiK2RuR3hhR3BrZm5XdVIrOUhqL00yZ3RrTldqV0tmRDdJN2lSUnRsb1dVMXlVekhuZUdGWk5wUEZOZ3BTTTN3d3Iydk01QmUvMUkwTmNzc08vWERKUUlJd2c1SFd2ZTE3NjlTOU1MNnZNNFBsS0NwOVpvdWpwOUN1YjVJTkRIYjhXVks2b09LVTlTeXVMZDEwS1g3ZC8vSkVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdERWlhbmVGaHprb3huWjRHc3kzbzU5Mm41bUh0Ti9WWTdzTGhaVmFxVFBqdXFXZU81ODlBSEV0dXo4b1loL0pld1lQdWoyWXAwZ082cjE3bXBhTnkreXB5UFdIYndIdHl4MGN2SkZjTXFnSGhNaHJPUnVHNnFVaGcyMCtid2pXMXhackJpNFFyZDFJb3g1ckVmcitWRUQ1UFhTWXFiSzZkd05keEQvcSsyN210TE56YTdXN0sxbTZYbVlHOFdadDZKVkx4ZlVVYXRmMTR3VTdmcW05Mnh4S3c4cUEvRU5ubCswZ2pwRWR6bGUzaUVuRzVyL1JNcG15QnVpMThCRVprUXpMUE4rVi96ZnE3cnFkeFZiOHoyUjhYRHcxeXRCRVRld252bktPNkdkanFjQldMWG9SYkhKK0x6Q2E2NmNFSjJ4R3VIcEdJMHZvN29pOHRwbGF2c2IwWXZGSUNtZXZXcmNMMysxMUNjeGJucXJ4OXRaVWpHTzMyTktuT0Q0UHUxQ1psUks0Rjk3RmFiVW56VThYeUxUMVUrRytpR1BXZkpLUng2eW1neW1RWHA3UHZ5bDI0S1NTbEp2TkFxdythZGkyWjJNcnFva2NWOHBpK1Y4WlZZWlgzbk9mZ1Eva0loZGw1UUZjWllhTnRmck5YbWZWanZWdENqNVVrcnFxYXgxK2tPNnQ1SzBNL3J2ajQwT1lMVi8wcFBWS244T0d6cks5cnFNYkRick90UzgxUURPNHZyaDBWdGlqRExWaEx0OFo5ZFNzYVprdmFDaHJwWm11MmFaSWE5OE1ZT3JnOWFsbDg2empTTmw4bXh0dE40UVhjVko3MTJMNkI2OS9xRjQzam1TMTJ2T1ZuckxaRmpkMnBLRm1yRm84OWNteEpPTjNQZE1wSG1TTnhwR3BQa2M2bDc2VEhHOWRhQzlQTFZrRjBaVWxWME1IVjdaVmhEUmtUdlRqZlNwSGwzMTUrUDhJSTR4d3c0ejRtNWE4cEM2UmtJRnpVNGdidHU2NXJsYjc3cDZmd3VyWmN4cFBHQ2U0UHZrdkRDTDY2aTlsbEwzS3l1bHFUTzlkV1gxZmhIM3JiSWVyOWZYMmowYkRYazBuZGt5L2tVK3gxNkdXYmxpYlR1SE9wSFVaaW56YUkybWlBeGtCS08xNytHTmVLUU1Wam8wK3RIS2d3N1VVVy9SeWp2YUg3UzgxdWNTVExmZEt3a3Z2OUJSak91ZUdKbGxiN2oyb3F6RkJ6S2ZrZTRwODNtQmxNeVRnOWVSTWxqWG9xWmhBRzlVb3RhcUZac2grYjM1VlV0WENjclZaSHZQYjZVak4wRzZDcS96a05QeElqb2tFdGpkTC92NzlSL21mQ2sxbElocmg2L0RTbDJFekFhTWNaQlhkbDVJaW9aVDZDd2lOL0orUEZvbElFRkVOTUQ2TWxwOVUxWmpDZVN0OHlOTjRFMFhyTHplR2xra3Z1U0pxWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hCRUtjbUZyL25sYitMcGQ3SjN3TjZFK2VGNnIyZnBVOUluc2FrU0ZoMWFIekdmbUZlL1M1VG14T01wdldkbHMwMGV1UUEzSFNJRUkyc212bFNjbmZLUzJ5eTVwZkJ0UXl0N1plbE9tOS9UdzZLL3NncHRwaXl0ejljY2JlT3BFZFZldjA2QmFFU0JtOXVqWStGeTFQRkc5dmxHaVB0Y3Z5RzZtZTY4MTZUTzBqL0szbFgzb0tqM1puOHNNTjZnUHAxK2h1WXQ2dWdkdTFzY2UyZkliblM1SnpQZUtmRUJsSmthSDVTRSttSlUrbUwrMWtUWkhSRm9rWWpmRVc5NWxSL2poWmZOTE9hWlBOYVhvOHQwajFOcGs1V2J2VHY1UHM3cFhYOWJ6N2ZDUy8vbDhPTWpWWnJWNGNudmk2MTU4T09HN2Y5MG9qN3l3S2VDMXlQMGIyN21hNzMveWVvUHJxcis4aGt0L1p0ZnMvdDRveDVuUjdsY1V4TzlhSmpBV3hwZVUzdmJqb1hJdjBvYVNrbmRGMlVUOGJaWlljTW9OUUdCRk1KLzJNdWRObTFxOXJDdC9qOG5Ca1pCRjVhbjlxQ0dzVjZuMno3WG5idXNEZ1lKZW0wcW1hRExBVmtHTXRMZG5XaVRsUzlqdWZ0TWRHT2szWGIrSUVjV2hmYTczRHEvdnFRckZzM3BiRTZzRzZqbExpTm5UMDhCS2tlWC9YVm83WDMyRm5PaVlvenVjaElpNXVWNGlPKzk1d3R2Skd5bVpWc3FjamVuK21MS2Y3cTJhdk4veWZNZjF0bGJNVlpubEx3OUd5dFdRU0NMUzZ0T1pIcTk3cW1zaHFqV1g1ay9FNUJlOGpiUGI1LzZyUG11eEkxME9XSTdTbENQVEFkZVJrMVZ6OVlaMW1HZ29oUENwWjBzOVpKNHhZSW5wY0JGcmNYcGZZMG9YT0RudDFhaTdDa3owN2pPaVJGeDIvcURzYURTR1FQTkgrMU1ycnlZTEtWRTJEdERoeXBtL01SN1VRWHBIMDUveForNjNUN052LzV3b2FSdnlXcFRSMDF1bHFYWnUva2lYTXFreEpGdHIwS2FhUVVjMEgxWDd2T2lTalROcURXVFF6SXlBajJTck1iNjNyTXFXc1NNU1JoUjU1SHlVNnVLeXlaQ0FQU3FTQnJiemU2TWpnOVF6b1FtVmIrV2ZVM2FTMWlFUDZkQXltZUZMcWVscUxMaW41WGFkbE9tUWFWTGVsSTVMR20ydlg2UUlnbzE3NmZxODYwTkVkSGFGYm50eVFiWGtFejZxaCtsc3lPYm9mUXQxZ0k3YUNMTWN6MHhCRzRzTkpxUVB0anBwOGRpVXlqZDRGQ2NVWmJ1c0gyY2d6MnIrUjlhcXZJeG9uV3BWSW8rS0NodE9XQy9CV0dMUjc2T2NWOE1SVVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJBQzhjZStOYkpIQzNrMDNpL2JGM2FKeUVaUVNmbmJrejJsNkhJTEpFdVpsVWRMVnpBeExWYnZja3B1QURJQXVBUEZHTWpHalRPM05Cc0UyWlhKMjJIREo3cW5UTy8xRmw0ZThjUkZ1V2R1Vi9lNlVieUduYkhOQzFxWDZBNnJXeHBrYnhPbmc4b3RodzdIWHlSYjV1SGtGRFNRYU5jbHNydExycDcvQ3YrV085S2NHRmJoUkxwMWI0RWorYVlGYlEvZzVsT3UwV0oxV0NPQW1mN0Z5ejhpRTdYUE1oMjZIU1pxMTVYa1dlbzBiSC8ycmljQXVkMm4wRGsxc0dwRlBZanVIbjEvcGZ4dVk1b1ZuZi91eXVacnRZOUMwODJtWk81dnZ1OVp4Y3lqZmRiSkwwbHo2dTZYM3ZhZWxkK1RVWUxYTFYwem54T05KNlAzdmJKWVl3eVJXZUM3V2FROTlMbnQ1SWJOSHVWaXlEeVc3ZmZrbm53ODVmUWxMNWQ2L0hvRGRKL1gzcmxlL3QzQWphOGphSFpXV291ay9KMlVmTW5JWitrYjljM2tLcnc1VERMdVczSjB5eUh1Q2lXdEF5Wi9UdTR1cXI1Uy82RjEveG81Zm1VRzlZRjFleFNlQmg5T2QwMTZoaUxTOUpoeDkraE5SYWkwUTVxOTFPempZUzFoczlQeXZoSVU3ZHlNdEZOT0FMU1ZhYWRiWE84K2dsU0p0S3dUWWdYeVJPOGl5dGZUbkZHMGtONnFnc01wY2RhUU1JWXZvbHRMVXhCWE9WSkpzeXE0NWVLdDYyaDQxQmVjNit6R1V1b1BteU50MGF1elRMaHVUNERhZWIyNjlud0llazlENmlZaDJtdkYyR2VaTHhucFUwT1hsMmZtc0U2S0xPa3B2ZlJhT3FRczBlN3FIZEN1K29iTkYxaGhsaEYyTkdYdUVsUXlxMHVsdXErYXJlejNvUjVXbVVoTDEwaWZRNTgvMHJmUU1ubGpKdUoyZSt0Z3BPNHNXZWpLQ3FwYnF3ZlBKYUt5SXYzZDB5bW5BOWJCZmFaYlZtTFptZTJ6MDZWZUsycWFiVzVxM2QvK2txZVpwbmYrL1Y4WkNMU0ttcmNjZFAxK3R0RFRGVTEzMlpjOEM4TU1uL1FrRTJScndtR1Z0eVNyL1BoMWhKYkg5U3hjU3VPOUV5a3JHdTNJOUtpdUFxUTVBN1I5dlRwdlBZL25tYjNuejQ0dTJZY2lpT2RGMWlKMkt2TjRFVWcvdllGSnEzdGJwbENtUTNYMFRGcGE1bVRVL0hXcXJvdUFwSTg4YmkwN1lwMTc3MXU2RWV2RTRYMXpXbU9rTmJteE9qWWJmRG1vellIR2RkN1BpZDdOS0YyN2RQbFdDSkNTZWVGZnFLN2NZcGNoeStsZDJOaXlUdWlrcU8vL212R0FHS3BXb05FeUpsOXFWRUsyWCtUeGlNN3lSMERqU3dsU0pwNllTcjRLQmxpRWtCQTBHb1FRUWdnaFpBQ0drNFFRUXNnRjBBR3ZKMzliSmJOVEVVSUlJWVFRUWdnaG53dm4vWVFRUWk2RWJvZ1FRZ2doSjdFcTdQaHoveDJ3eUduMDdwaTBBTy9IOWVndVI5RTBFRDJiNmZYZUJ4NlVvL09MUUhaQzgzWk1JampvRmhTZGRWdUwxVVFqTzhIMTdNZ1czeFN4MThvZ0hiWVh4eUZsNjBPVnpqcWx3L1Z4Nkg1NXlQTkdkM05Gc0ZyYzBXMTFpSHJMcnU0eVdOZmJNczJpT09tTGVoWFQ2ZUh0RklPTVd5VHRaY2h1bTQzcjZEQklhVTQzL2dhUXJybzRCcmVzbHJkeFZnTFQxbm51M2NSSTVVYzhjTnp6WWd4MGlBSmFKUGRZaTFZWlpDL3lkTTZvRjdRdTBIU3Q1eXNpVlc1ckFoL3ZlS0JYZm4zV1loZ2xmNlgzdDVWZU1wem45azVVMVQ3cEpZak16bnZhWFk2cFhtWllyRjZMMW9yOVJ2dng2Q0pFalRlTzUyTDJCckhMYTUyNEdMSHNvVDlMODVXcWNiV2Q4cUNNclZ4bEx2S1VWck9ZRWZ1c3pSdEtzbytLMVBLM0tFYmFWcC96MW9sSHkwU2VUTlFLWU10VzIxeTg3SzluVGNiK05KcHMyZUd3bXdISHdlNlludVM3aVBxUDdTUVl1ZVcxOWVQT0FsN2I2VHdFRWxnNjdUcDZSTm03YkExWi8vNDFydTh6SmNnbUh0cFg2TmpsVDNiK0pQSy8wN1E2RG1oM3M0Z1FpNTVicllVcy9aWElBNGJ1TFE3TjliNlJzUFZJcThxMysxbi9qQnl5Tzh6SUZDVVplYVZNWkRwVTU3WGNjWXVSZXJHbW9sYVo2dXNwK2MvZjBobkZkZzc2OVpicDZKMnFlRHBXaERZTWw2YVRnNSt0NjRvWGNrRzZIcEl1T2JwYjN1cHdlbUNKNno2WUszbWhITTFva3VsVE9weWFCOVdoRWtab3ZoQTVpYnRXRGsyck5wOEdobVN6M1pZR0VpKzA4b2xtZzJTaE9rYnpJMm10OFh0R1c2Q3VJRklQeWxCNlg3ZnlhUGM5MTlHYTViZlN0ajU3K1pIcjhyU2V0eTVsM05kbFNFbzZkRjhjMUg1SDJPYWlrbnB1cXQzUGlwdzZYeTNKK29UNnRDTCtrcnJrRkZVMmdxNnpLTmVPZVk5bFFvTzhDTDBXTGRMRHJRbEROdEpZdW1kYkxuVVVpVFRlQUVGN0ZXb0pva1NmSFkwa3ZQYVc5MXBXTW1vVmtZa2dLaU03NlhMN3NqeUtIalVjNUY0ZzNSazFLNGZnUHZXVkFRRTFrVTcyMXFpZFRjUkxqUTZmYU16WEs0ZGNUR1R0TERmdWJmYzlGME9XTUxJMEtpbldCU2NzbHE3ZG1pY2R5SGowUVVpWVZselJpbE0wT1ZXNkdYdmZvdVBXaXpjK2xoSklNK3AvV3BYOVFaVWM4UVdvWGJaY3c4cHFRMWNVa0RFazRZbXBoQkJDeUEzaEJKSE00N3Q2RThjT0lYUGhtQ0tFRUVJSUlZUVFRajZJYjUzb2M0R0RFRUlJT1owcjNPKzM2Q1NFRUVMSWQ4RjQ0MHRnUXhOQ25nTHRGU0ZFa1AvN2YvNjMzbWN1V2I4Si8vTmZ0Q0FmQ2ZLcjlBZHR0eFA5TlhvMFR4aHZVN1dlbjVNbmZET0JCelVkbVFVYmZSMG5ibEVHYnBUazVrUDJhUnhuMW5ZbkkxdjJHVFcxRTVuVFlXdmQwcElwR1dsZ083N0NkTS9RcGFWVE9KeXNZdFF4ZExvSldvYStPaTJCZkxhbXNZRTdveFllQ2JKam45ZTlyOWorOG80Z3U0cWR4TWkwd050SjZSN04yZXE0MnVjNmoyTVR6ZXZ5dnNZa24rZkpsaWQ4dGJKYnAyMU5QODRJd2R2akxpbjNSOXNYTFlOZGdxT0UvRXBUL01UN2pIYjZYU3hUNExMWXFrUVpuYlNscVEwZE0xYjZtUXhPdnQ5NWVweGRTMTRrUFNJckdXVTVZMmFBMmo1cnZ0Q3VXK1RFaWQrbmZmVmo4M1RUdmU2aW5aS2FxLzZ0Mk03ZkU0REVtTWxHdkt6YTBQejdUMWRjN1kweHlRdy81SUdXaFR5Um5pZ0VsUm1oUGlGVkcxSmFEbDJidVA1K1FNU2VXWEhGSzkxQjFjRjQrQ3FTSXFNbkR2Tk9SbjNyRm1YcmFoeERGN29GY211OVJsVHhvWURtdHVGR3p6MDhKK0RqRDJVQThVSldlVnRXZzZKclNtaGV1eUY1cjFXR0JkTUVzM3YzaHVpSW9iTGFjOVM5UnFjb0xWMWVLRGV5cGpJalBFYktZTkdxaDRpTzFNZ1RlWDdydmtYVFBvRXl5T1VnM1I5cFhxVFp2WldsR1RPMW1VUEkwNTJ0TUdwL09hWUxESFc4TUVLR0JLWlpib1FkOHI0YlJqZ2diaW1hMTVNNTRpS2laVXFOc3VUZzU5Nnk5THBDeEgzTmNQVWFFZDJJN2NpZFpmTDZ6a3gzWmsyVElvejJtUmxZSjZQKzN0Ly9aYVhOb3JaTGw2NjgwOURkZnVhNjFZQmgzamk4YzM3ZmFHVHFiV2x2dEl4NnhSVEkzMlBCc3lLanA2elJIb0JhbDFsRTZ4S1YxOU11TWwvRXk3WFNMNUQ1Zmt4bm5ZTmNDOXE5VVhObDBUTjVRZWUvNkVRSnVlNDh4d3FyakZhZDkzZ3JRT2QvS1ppdVRrdFRjSE5RMTg2R3ZCMm94MWZ0VVc2djhjc0JiSWJQTGVWQ0tic1FPWTNnUW9ZTWFRK3ZLaHVpTGRYUk9JTGpJL1V2bXRYM3lSczB4aHVOZVdzZHVVTlg2N3BHNzFUbEx6d3hsUkJDQ0NFM2dGRXJJWVFRUWdnaFpNOFZzd1RPVEFnaGZkQjZMT2NPVlh4aUdmSU5udmNPWlNBZkJ2c1UrU0RZblFraHhHZkdUODhJK1U3T2pEUTRVZ2toaEJCQ0NDR0VFREtHT0RIMWZUbkozNS96eE5RdndGdHJHdG11S0ZnRTcxZlc2QVl5cHl5ZlJiYWFsSUJiVTFvSEhGblp5QmZEempBZlpOczA1SDZuV2tTRnZMNWlCdzRicnpUMXRkYjFtV1hZWkF0ZDZna2NTUGxIc1o0ZlNaL0F2TXJ6enR4cDFOeXVLS0pqZEw4aXZaM0wxTGJxSXpKZUh3blN0ZEFIOW5ZQi9WWldETjlPVnZUbmV6ZnZ6TDFVMFIydlZ3eWkxTkNkbkxReTY4cGdKOXJCVi9ybE1abVJUWW03bWl2VmJ2Zm5qNEllSWFKMHZRTDZiS3gyMExoanhzemUwNkdsMDNUT0tBUEtGV09sem9mb1J1ckJhOWRXM3BiTzBPaFIwMjN4bnp3aDlYZkh6WDI2dEpzRzZDZWx5bE9JZjN2TXZ0eWxrbFByTms5UVBRd1ZPU2RwUE8vaDFJb2VINEQ2SDBMR0taUFNXQ0FueHRUMy9kUEFJNU1UMUU2SjI5N1cxMWE2S2RQNTRQd2RPYzMwbUNrSkkydmtzWHhIZGtRcnN1dnN4dytLSE11V1dqcWR6d0hWSGhIdml6SjBpcW1odkJnNjN2Y0xYb2JXU2JEZFpmNm5ERXpiYXQvNnVpYlR1NTZVKzlFd3VmZHpNblFnWmZHSTFIRlVoaWM3MnI2U252SGJNODV6SWc4RDZZclIyVkNQaWVnQktaTk1pOHdhRGpKcnR3c3VSYWc2QWcvcytnSlJ5ZGFoNlZub2JwM0E0SmFwSTQrVkx4Qk5Yc2JNNS9YU1d1bDczZkNJaTJ1VlI5UGh6UnFpMTdVeVJKNFhjVVBGa1ZGZmo4aHdFUTkrc0VzMzhLSFp1Tkx6N2pGUGtOR1d1VitiMnFmemVyUmNVOXN1RDB3ZzNIV3Q1QWw0L1JzTmFqVm1CSlJXWGk4L2FpVnUwT0hoU0tKcnhCdHlSd0pxdE4wOHk2ekpRNjNlU05taWl3emlzbFdFa3B3RTZSN2RqZndRTlJHUllNY0tNSHJMZ2t5TTBLQm1BdEhIMC9LbjVGZHBiM3dWS1VOU2RMVFN6b2h0eVEyWUVlcDQ3b2djR0RXTk0zVjdheXRXc3lLdk5Ib2pIRUttNGNTc3ByODExdXNzRlN0ZWFYQ2NBUFF1T0g4b1BiNWl0UDlLWmxTOUZYYk1YTDNnaWFtRUVFTElEV0VBL0ttd1pRa2hoSkJ2NEZLUHozQ0RrQ0Ztdkh3a2hGekZMYi9aL09GYzhNQ01kVTdqVkovSWRpV0VFRUlJK1R3WTR4RkNDQ0dFRUVJSUlZUVFjam1ybCtueWYvL1AveWZlTGV2YjNQejVMLzZHOWVOeGQ5czZIMi9EcUJhOXZ6YWZTbVFucStyK1lWZUljc3pXMmpDSFg2TDhVSG8yOENQckdERlFrMFhmeTN6M2JKY1gzVUcwY3p1eDB0cnZvMWYzakE3Z2JDRzB0SVdsNDNIdWgzYzNYZFVML2QxYjl5ZmxIRk9zd091WlhwcmJROSt5bmh0MG9obmk3eDJ6SXhHMFo1ZGJNaE9ZeDh0dmdmcU03VjdCVlE2ZGl0MEx1bCt0dko2VSswamNzV3FRZVQwNXZ5VHZKM2J1b1dLUXU4M3BlSnBZMmY0N2lFd0gwUi9ob1JUQXliY0pPSmE2ZE10MENVamZXZ0dvODBiSFZFc0h5b29ZVlpkb2Fub24yS2Y0ZldyRE5qaW5sKzUzdGRVWGJQelRpQnQxTDA1cDNWM2ZGUVQxUjFFUS8rWFpZZktOb040VzgwUDl0RHgvMFpTOXh0YlJOdlRFSFVrYWliUnp2dFk0enVoYVJIMHZwU2xIVEI1VTYzWk4xV2x0N2YyMlk4RVdiWjdLazMvLzBjcHd5RktPK1hicHZQc0pkNEdXQ2JTYU03QzIvNzZlN2ViK0p3Tm9ybGErbG81azZkNTBpTTh5UWZGaTNOUit2cDZ1RkFJTDJZOTRZVlZyR0Z1NmtUeXRkTjYweUxvKzB1L1J0RFBHRXBwL3hUajIwaVZETjNrMDBaV0ZPay9QTU5YU3JUUi9zZ3c5T2c4bUJQUkx6ZkFpZGM1QUxUOGpYYjMwUzFKUTBmTkc2eVdsZnZQam1XbVpwcmNzbG13cnZTVnpaTVdocFFONTdoVzZVVkJYTDRtMEJXb2pJaTZ3RlJJZ2xHQjZsYWd4QkVXT3RQZG9mNVdsaVBtTTExclM2MHBPZXFuUXZvYTE2MmpnWllnTUdRL0hhWFFGZFhWNlM5WXFlaTFWVXU3M2p1QXBJelRJVEowcnZWNVVkMzI5cGpqWHJYeGF1a250MUN0bVFWSElRbVlHTjJndzUrWFQ3c243NEJCYXRjU0FwdE5BTE1Jc0VLK1Z3ZXNjemc4RmJlRDZPcmtGdlV2QTN1ZW04RHltaTVBaG9sT3pPbCtOTlEzc1VCbjErU1B4d1VmUkU5dWhNcjdjMlBUNGhsNGRvM21qS3hGMW5rZ1orR3RUUWdnaGhCQ3lpT3RtSDVuTExJUVFRZ2doaEJCQ1R1T0NPV2krd2J5WFUyOUNuZ3ZITHlHRUVFTElZMkVvUndnaGhId1g5UDBmRGh1WUVFSmNhQ29KbWNPcXNmVG41NTh6ZGcwamorUEVickZpUDdkVGUvVmZaVWpoUy9CK2FXZkxpbXFPNWcrbTFlQ1JiVDVJREsrT0o5WTVLc3F6bWNYTkhiRzJZOW93MlMzNVNCa2t4bURaYmZXeHNDSERSRnQrb1c2M3FpTmxXRmVucFNGNzIyOTRuMzZtYnFrcm51K3hqRzdoUThZNG9lNnZhTjU3ZEttb1A0cW1uUm10bCtEMVFKTHloQjZBYk9ON2hZOC8rcDNjdU4rK0dsVnQrSEpZMTZjYTl1amtlMWJhVmVsSCszV1BqaWpyKzlJaFZEMVVTOWtsYUpib01IYU9xYlhwZ3hzdUh4VWx1QXk3NnhtUWhleFpXSnpQQ1pDQmdPVHpkSk83MG10QjZqSFUyN09pT25mWGkzN0hmWjUzWVoxU2Ewc1A3K1N0OGEwb1UwOHdtT25Ma0xKMHBPMk5IM3Z5RmRDRzlGVGJCY3N5WnY4dGM2NjM3cmNPcWxWbGVOZDlsK3B5eWxSazFwQWFEY3NpdUpWdjNOdmFVelBFaUl4ZW9uWFkrMDdEQzRsNnloQzliL2tBOGloNnVsSjBCU242Um1PRXFFNFUxYVNBaFcybDYzM2VxTThvVnNVbzQzalVITTFLMjRQbkdxSjV0UHRudUk2VmJkQkw3M3dJU2RkYi9wYUxyMlVqSVVFdFUvczh3N2FJNVJvbEFhNWtscTBjazFHYyt6OWs4NDVNdDcrTytBVGNIeFUzVFppdzhYQW1NN21WZWJRd0srajJZT0t6TmtMcnRLMzdLeEJPY2JtdXEvTDM5ckVaZFdQVnNkVTN4UDFpV0dadjZiYzVkNW41ZkdRS000ZjdMSE9GM2hzVTNadDI5bEtFTjZSR0dJa3JyVGlTby9kaFhCRzZrQ24wTkIwYXMvY0lMNzI2Q0VFWmpTTkVSeXhHeUp1VnJKNW9FZ1I5bjlRcjQ0dEJxK1dxdGY4clpyOS8yRnZJbSt4Y1oxZlJxVmZ4SjBWMUdhbnpsNlhLMWVmQ052cDgwRWpNKzBJRnVSMnJtbWJmWlg0TlZuMmFwRFk1WGQ5VldsUGl5RktnbGM0WUxIOE5iTEh5cEY4RFBOV2czbUZBT25YYTAvRHZpRm1HenRGUUdtM3Ywa3lWcWxTckZsbGFyd1ZIZVV5NFpma2g2MXNLV0xNU2paUHJxR1dWdFRRSWlMVytIdVRKUGJ3bjNhd0ZVZ05XdzF1RERFUjFsYjBUaU5ienpsaE9HZVhLTXVSM3ZQWFQ2a1padkxuMyszTitTLzBuODZMSGl0ZW9OeWJPdEE1M2NEZ3p5MkMxUnRSK3Rjcmt0WGowZVJDdmdud2hCMUFCaGJxZTdhdmVncFRpMW14K2pkTlNJamIrdHpRMlZhVHB6VkhNNTVjTFZ2SXp3cXhvdDBjM3VUT1J5S1ljcnRUZGRodVplZmQ1S3NOZFR1dTNjbUcydXF5V3dSbkhjaUNQREpWOCtFUGNyM1FzSSsvK09mNGl4UHJzVWR2R05DWXFzUDQraTU2SVlOWXlWVXZPZTZsTVhrK3gyVkpQV2VXVVJDN2J2V1hLakxMZHJmdXEwdFMzYk9YSjdnbHgwVTRSbFYzYmtHaG8xOU5STlprenBwb2JTUG05NnpOdGcweExIZy9hbENOdk5KQjBrOTFPaU9qczRJeFovR0hxTnJyK0xNS0lrcFRQd1RLaXFxK2k5Vnd6bm5lbUdad1J5aUd4Q3hMYnpHeFhkQldnTjR5SWhnUXBCZW9ZaU8yeU5rN0xzUXhuME51ZU1sMFdLZVFjTlJKV3lmbHZ4RXUwK2c3U2oyRm1URGhNSXlGa1o2TzBkVWVGbE0wSU5KMk91eHhqaldHSE5vS3QvS01venZMQW5hSUZUM2RTeXBEVG5IYnZmVDZramdkcHFWaWtrbFRNTmlXOWdjZk10WWc2TFpwZXl3Y1VZZFpTUkk4TUw0WkFMR01CcjN2bHNIejhGUmFWQUZ6cDhzZ3lWalJydGdaMDBCaWlyelFJV1VMUHdrWHlwNXlOTjdCdVVXYkdFUi9GeVB1a1dnYU56VlNpTTlJenFoaGQ0NDd3NTVwRkZuSUxySmxUY1Q2ZndLTjZaRDJFWnEwaEFSVlFidEJPNUdKbXZWRWtPaWVPc2Q1bTlJcDRuTmR1blNiRExtQU4zaE43aGhSSjEva2twYmMxMEZmQVVDRXFtYk1JMWtjNS9CRkkwL3NpQnJzL3M2YWpJSzhGZTNYZjFteExZNEVPRWZxaE9CZlhtUXhwWjNQZTQyazJWQnVwMXVmVjVacVZEa252eUNxakZ1dTZTRUxuZXNOVERsODcycTdEQXZhOGZqaUNOTlhLWGh5djJhczg5ZFc2VXJBTVBXV2JKV3ZBZG5RN2ZVOW4xNmpCTkV1elpmNHdQeDh5V1JhdmhHMW9kRFcvMHU0bWF5MFZ0NnpEaWpYaGxvOGduMFQvbDJxS0llL3VNVVExSHBIdWZSZ0t3YmpNTXhuSWNrZ0daYStrZUJlS25hbTBoR1pGVkd0VnJCYVk5eDliakxwWEkzL0UrczQ2ckxaNVlsMTFyK1U1dXQxUkk0MzMyVlYrNk85cFBqMnV6UW96Vms2NmtUSWc2YzQweHpOMFIwTFhpUDN1QWZVUjVKR2daZ2pOTjVwMkJ0NzNJbHZYRC9UWXl1U1V5Yk1SeHVlaUNhdlQ1SEh6RXpFOXZUSm45SWVvVzEwdHAwZUhkYjhBYWREcnE4T0l5UHVqMlgxclpFajJ4SGFhMFZpeDhxQ1dKY1h3NjNxZkFtbkgwcERXMXJYSjNzK2NUM21qTVdNbnhMQ0lrVGxxYjNsYmptcDFEMFhYUkpHZkpGbGZ3UjVsWnE4Nlk4UjdJRjRpNm5uUmthKzFwOVd1azdDS3NOM2pIT1VjWm5mOTFmUGpIaVk2OVJXeDc2aHVhemtXV1laRnI2Y0ZzbVo3QkJMZ0RpNlBUR2QwYVZDOURxN3haMHNnK0VxRGRvQXM1VVNiTjJPTjZLdVpWU0ZuTGVoOE9GWThlV1hWUnNkWXhMLzgrYzNDM3ZOVjFPc2ZhSStKck1vSHUxUU9YcmZTWE5hTDVacFN2ZGFVRWw0d2F4MlJ3NU5ZWk9Neis4dzh2UFg5d2JvdURWVzl0SXVZZDlkOU81dUQ5NHVUTnZKMHZWUG1pQVBhWnU4ekJrMzBkZVRLQVl1Mml5akRVaHZpQ1VmS25KV1V4VXk5QWkzdTBGeS9UT1BKdTZYWmxnK0l4b0FwM2ZTQmJveG5PdEcwZy9SYTZjaUU5ZnpKTmpKUzBkbElqMTlDdmt6ZzVXOTlsdGNMVUFZbnE5eTVQSHhDSDZEekZzd3dXTC9QNmZWelBYZmVaWkEvZEd0WGNVN3loM05ZYkFlVzZTM3pMdTNvOVNuUFdJNThUZGpTYmVsRVl4NzBlU0s2UjlEczFkbGZCOUIxSG10c0d6dnlqWjFUdDZWS29welM4TTVWanVQNmQ3am1WNUxvUWs5U21yWFZ0eUw5dlhVZG1jLzFXREJOVGtwekxSSjVBbDRQS3NaMVc5NXJqQTNZbjc4eWZvWllwd3pQWll4MDd5ei9LTHQvOW5KRjdXWkQyRnRVN3dMMFJBNXhwS0ZUWFl1SitKM0FBangwMUpNUTNicWZuTFFndWFHekFQbUs1UUtUZnQrU3BaNmdtbUpZQnlGTldXbzdFM1JvZUJWMHh0TG95REJHdzBnMDNMaGlyV2pHWWtUdWxPbnBZZ2owS0RLWVptVFlSanhiVkljNTZ6VVNITzYvL2l5S0g5S2UrOS8xazhLSVZvaHc4RFBSTWdYR0tUcTdUMGE2QlNGRWR4L2I4czVZWVpqWkRhejV4S3d1ZGxZNDBySVZXdVRhSTMrVFpkMmJJYXVWdmt1Si9CaWNNSzR3T1QweWoyR0QzdUt6KysyKzcreDFIcXRNcjhROE1rL2FwUlZ6VnpmOXJoQkd1alNSRWV0WXl6aXp0K2t0YmFkYnpXcHJzdVh4Smt4Um1YVStST2NzejJQbGsrMnA2Wktpc2k3S05KNUdlcGxVNjJMTkRHUXBLN3EzSjIrVkl6M0pMTFZHVUdRcHdzb2pxMGNiS3FOTEJ6SjkxRnVkNVFFSXlJb3g1ZWtpeTRrdWxjNmFCemRsQWNyWVJjaHRFYTh1MzVjRFU5RFp6Smd0ZmkwME5sTm9UY2xHWDAxRy9CTzYxajB5UnY2MFJYRDRmU3pXRzZVV2tlN3dqVjFuNHVUN1BTRnRMaEFSb2tDelBaY1R4dCtKNjNZcTYzU2psYmU0a25kMnRKcjUxS3VMOHhTUUM3bGlMTW11MU5NVFBzNXMwdy8xY2JVeldJVDVEalgxUEs3MXlzWmpxOXk3Mk9yb2szdXZ5YXgwOWEyZ1RqVDkwaFhETXdaRWRFTGNscUgzdExGSjl0OHF6am1xZTZ6dTd2TkRWRWxaZkw4bnIyVmJSc3VpdmVxZTBWK2p6UDQ2M2N5MDRzdHdvYW1IeU9za2Y4ZDZ3NmRNcDBCVnJHcGZ5eWRxRTZSUnY1a0IzWGZ5ejZRSDYydDJDSStPSWo2MTI3WURqNXZwR3NsN2Y5dHpwK2xoMS9pZVdNWFQ2NEZ1Wnh6WnZsZDAyR2dmTzhOazNHM3BnVXpCKzdMSERGWjBtL2RHQVlxdWY5ZUJNVnNjMldsQWRncksvaEg4cThROVNkVWpVT0ZYcmtSNE1xOThGL0dVV0Q2NHdqQk15eVZPV0ZFd2RTSjV4OWJscitNSzE2cUZPbm9xVkZxY0Zldk1ROGxIM3kva0hxVlJaclhKU0hDTDVvdjA2dDUyOTZ6RHlQMG5jdVVzKytSZjhaSFBZOFdycmJObERCRDVhcGMxVGJqSk45Y0lzY25PWjdLVXMrZU5UVm1XNFJMWDJVWElFMWd4TzVvTngxS0Z0OTdLeWhwbVZWaDl0eG44bjJjdFBaS3BvRy9VTHVnaWtTSkVKNUpMMldiRVZxRzhCOU1ldE9pN1JjZ2R6YTljU2lNM3h2cnRBdkd4ak1xQ3VyUk1SOCtyaEtoT0hOVGF6dnhXRUZvaldwNjBYNkU4N002YVgvZTk1MExLZ01wQXIxdjBlRWRMaGx5K0ZkZXRvemFnN1l1czNvV1dxWFc5S0gvOVRmbWo4NG9ReHZ0eDZnM0Nxbk9ndnhsSGZqdkVHaEluMXJXbktqS3FNNURQazRHUndXdDNZVVVVWDM5YlQ3Lzg4emtmcy8zTDAxRWU2N2dsTzhPbXJETjlLLzhaTXlOZFJ4YjN2ZEllSWdqRmFaUmlxTGErMzNOSXVIM2FsNktuaHQ0bjBMa1NMTzhYalhKUmEySDFBMVFHS2xORDgvNGp0Qlpxa0RvdjRPZG9tVXBBVncvWTgvM1dUbW1rK3Yxckc0VTUvMzR1ZG5aZDVwYlhzWEhIVXg0ajlWSzlTU3hGdjY2SjZtcUszajZHa3NGN3JRaWEzSVZXMTlMbVBWb0k2M0dVN1V2d2U2czNXSUtvRDE0YWlUVGRJcDM4eFlnNkI2L1NxSzd1RUVrb01wU2ltTmZUY2U2ZmxQSzE3R0dSZndnN2xxbzFoU0lYdlJYZExmY2pFMWtuakJSTlFObW50K0t0Z3d3bFhRTFNLYmZyNXRNZTAxcCtRVVB1NXZMTjYvbDJKODAxNnJybk5OWlVFdlpPSXp2eTBHRWJDVTA5Vm9SUjBUNDBPbDNTN2lWUmx0eElsNVIwWWdqdDBsdGpKaHM2dmVkQzBsbW12aTZqdko2QXNtanBTOEw2VWJTdmtkdWhtVUtKMTh3RlRLZmw4UmlNYUpxNnRVaGQ2bTZaR05QTTlmZ1FRMGNTZnNVNnNmdXRTNVFCZFJXQkdkeFExQm5WaVRKcmh0NGp3NXMzUk9TdFhPV3dkRmozb3pKTDR6T1N2NlkzeE5GQ1lzLzFqM0NJNmVTNGxIRmgzdDgvWEsvRXpCd2ZtOHdhMVBVajdTcFBOVDNhMkcxOXE1aXlMVm45R01GOThmS1U3dHQ2Qms4cEt0VHF1VE1zbGxlVzBUYUpqam9rTW9sU3FuLy9mL2JPTFZ0U0hlZlc5aDQ1cXYvOXE0ZHFSNTJIOHZrek00aGxoR1JOK1FJRU1iOGF0VmNDdG1SOGtXUkRtTnh4WFV2Ym85ODZqMDVTVUxsU2xwd295R09rVE41MVRhYWpxeGpqMHpxZmRUR0hvaTNwUTJRNnM5WUZwTXlSb0JiVjBTRzZKNmFMV21WUGR3TFBhNHg2NXNoOW91VW5Kekl5T2ZFNnJIVk1odW1ONENMbXVWNjNrR3ZmTXVIaHVxWWs2Y3E4T1FvaHA0TGFRbU5LNm9sR2ZEeTZyb09HMFI5THRDSThXYU1Cenhjd1VxWFJHQmFoT0RxdGRDdjR4VjVFRG5qcksrUTAzazN4V3ZmYlJxdGN2cXJURXJLREhlTmptT21ORVROK1hkZVFsdXhDVlI4WEFwMVViMGdaVHFtNzl2MStTdk45ZEZnVkNUVG9iK1p5WVFkZllhVnJXY2ZiMHJYMTMzN1BxUFB1T1Byb1oyV1U3c2tUTTRYV0JHSm1TdzkvcmlLc3NQUGFHZnIzMTYreS8rWHdndE40dlpSTDJ6V2E1MHdqdWxJWE9rNUw4QmlSTVZOMnIyNzB1a3lYeGRuU1B4YkxTWDBwSTJXUUx5Mmw5bkZYSWFUL1dtWEZ1Qjc5eVl6MGlsa1c1ZFFlZE9JeWhxcTdMc01LcnJxM211MU45bnhpUVM2OGIrMTlvMTF4UG13QndZd2dsRG8rZTlaZzhxMXVhS1k5azNLOE4wVS9yRitUNzhUcXJrL3V4dksrb3FiUmplMG0yTnB1R1dKSzB6TDlvL2Z0blI5TnV5TC9DcGs5THp4OTBrcUV0M284OC8wTmRBVVlLY01uOHJrMnQ3ZkhyMFRvUkhlWnNlaHFtT0F6RFZmV3JHQzJSL2FzMFZVQTNTdEc4c2pMRTZ2WENxOWdScFIzdzRuUnV3amJjMEpPeG01QmRHaU5EUDhiQkFHOU1SNTZiZU5ibG5jNGloL0N0NjVIWHN5cU9kbEdSaEpVRThUZDRlc2Y1ZzlVUlpqOHVmTWtRc2hTWmkxRlJGNUxvakdDUWRjNG4xS2x2Lzcra1ZFUG82Q3Z4UHE1ZGZUOEFyd0JWNUkvT0tjWHN5VlExazJ3cnRUa1pYK3RQdWJvSldRaDFvQmFZQnNIVGNjQmUwSXFyUVlDWW9tUmRGb2FOTnhxUFNReDVMMjNuekprV2d2eEJiMmZ1cFZhbmFVWWViVGoxTGhlSE5rZVBZK3pEUm5tWnk2aU92cVhtLzkrdWUzOTdhdmRlUzEvUkRONTBYcCt0aEdKaVNMWHZXZDNUMEl6RWJKdVRyeG56L3BHcHd0V3Z2M05vZloyTnBFeVJQQTZxdWZUUEI5aHBWUEswR3pReG4xRFg4bjJRT3NCalg0aTBaSGxmeVV6ZE90R01WdDVLMWY2NTlBcWdxSVNNWUd0cU9QbmZINmRIemN1K3krcFlqbjJwWXEwYXkxanRHK2lPbHUyb2FlUGFYbGIrVWJzVTcrRmpzdnVhVWRFeDQrOHczTzR2RCt2UGFmYnp2OWN5L3QrbjZ2emxiM0xyOWoyMEhwaS9sRGtWdyt0OGQwQ2RRbmUrU2tzRlc3b0luZkZpd21SdkdYSjlmeitiOW41M2MwZmpmYmZESjFTT2J4SlVCd1ZXYysvay9HU2MzQjl3dEM0WnJsaHFJcTRYTVM4Ly9DVlZkVEk3V09mSnVyNlRKV3h2QTMyL3BJWlVBa1poODgxSmJ0Y1hzZTAwamwyTzJ0NlpQRTgxVTdWUTAxVmxISm94OGI5eU80ZCt1S3BjZnlucTJuWExTSkd4R29uT2FaYWdVVHJXT2F2WlZ1NkxaMVJzbk50SHdTMTgzampJUVBYRG5iS3lPdU5KYTllV25XTmh1VFJ2dVpST3ZLUVcrS0Y1aHRvdCsyUmx4Tm9Vb3d3NGhCbUdMYW9WRzdhMG1tZHlGNFlZdmlyS1V0TlNaY0pwVTNPZlRieTFmUVVYMFIyNm5YRWhIcXV4U3RESlB5Sm1reFUxd2h1eUF2S0tNNzFsa3pyZWttMlM5U09JMlJBdDFhR2xpeFl0MkZydkhPNzgwYWhEalpEWEd1MVJYVDhIc2RPZnAwdnUzUVN4QjdMdEY0YmFMSXZJMktZczFIcm5sUDRTU2d1YURXRXRHeEpmZy92cmQyV2JFc0hhaldTazA3VDdSMG5veXd0dEI0NllxRm1VcHpqbnZiMTBvNU94amFya01XMTJscUFWc0VjTTRwSzViS2U5Y3IySkNyUlFDUGlESHNEU2t2M1JCYUtobTk3aFd5dm1WQlBvYVZGNmMxSEJoaHBhRFNJSmRPWlZ2V3ZkczREazFBekJCZDlLSXRycmJrSUljdHhCdEhCQkVaaVZ3RTZDL0RtNWlUQXJFV2tMMlZsckh1R1RuVGxBZUgxdzFSMHVKSkhFKzBHMzk1TkZrNFVDcGhHZTdqQjBVdklNK2h4N2dVODkyTTF2aWh5bExjN3pWaGVXWThYNkgzZkxtY2ROZWhqMG8vRVc4WHZ2WEZrNGVHYlZoQWVacGF4SmtJZmRIL0M0eFJyV2N4NzNTc0RzbENkRm9DRlF0OXFuMHJ2QUI5NTRXQlVOdks0c1BkNkkxdEgxOGVtcXZQYXQ0VDdMZm9VSEpIVlM2UTl0VUR5YkFjMjhqSlY2enhpcjBaMVhTR3prVS9hTm5OeHBhMjdpT3ZINDRSVGpENjEzQTRqQnVZVC9ERDVObFpZMmFPa0wrenpoL2NvdHpjc2tnamRKOWFOKzVWVU1WR2lLUW96OGlGYUxRS3FtZFVjVmxjYjRvN0RlRVY1N25DZlYrcWZHY3FPOG9YTDdlUUdnRXNSeFRqZmVyYXM1ZkZXdWM1RzdnY0M3elZheTVpY2JrVEdhTjJpN3haWWFPMTd4U3BHTHhGWHNQcVJCckxpMjd0Q1ZwdzhrZFVybEpGNDhnOERlZGU2MXVKZXZkYXRuelNLSW10UHBSZ2QzSHYrOFBvTHY3MC84dFIxdE43UVp6dXRZeXM5dWc2SGpPUU9wOWZORlY3K0U3bmVhcEFQcDhlc29lWm90c204U1ZjZmlka2kzR0hKZ1h3NGRBKzNZTlk0UmpkcHpOc3g4dmgzMEhDeGk1RTdRRi81SUJqOHVNeGNRKzNscmpQUVg4ZWxTdmFtcitlS24yNDd5TmpMV21DWDE1YlRlak1qS2RjbTFXMzlvTkJhR3JWRzh3MmJsNnpBR2hqc0FIR3N1a1JYdVRycU9vUFhJNktQTmlFYjUzdVpFZWFnSGJkVkE5cU12dnI3KzZGWDBkSmJyOWRGSHVkYnRka2JpdWJnZWEwTTZQMko2N0txNisyS3piNWZ2UWtTK2x3R2h1N2p5dXQ0LytVcjZ3Y3lLMDNmSXhkNldnR1h2RTdHc2VMS0cvcHV4NElBZUoxcmhKV2pFWlV0by9UNnZKWE8wK1haOHhhTm1RTFNlT2JYeFEvLzZDaExmVDRxNjE3c2EvanZmUjZlSVlnVDd6eXRuZW1saXo1MEFkM3ZadWZZU3Y5VHhQdzYxbVRuVk1MdFhrc2ZUWGVGem0yOGFyUHhYa2J1TjdvU1l1bHFyU3BFeStMRjZwRXl0OHNpKzJrZEUvNDlLbWJHWXAwWDFYQklaOWpDL0RwZmdCZjVmcWN0OG11SUJlbFQ2QWhHaWVqOFhMdE0xb010aGU3SHBSZmhZTDM1dUxwUmxQUDFkZnNxcHNQSHNISHVqY2wwVlV4UWYyMUdDK1c4cjlFVVExZXJrbVU1YXAydHpJY3Y1SWpqUTdwS1liSFdWUEkrajFYWVE5MjFrOGVwTWhhalhzb3hxU2NLZWlGRlVlSHAwS3BlYXdibzNmR1hQOHpPZlhxZXZ3RGwzWlZOMDZGMEhWMWdkZDNyQzFHRFZCdzVMZDJqOC8xV3VHVzVjem0wdlB1VythenJTRDZwMDhyanlZeWtzM1I2N1dhQnBwTmxJQitKWTU1VkhPL1VITGFSOHJUeVNMTU1mN0JkblBObVpwNk0zZlZnQ0xIbE1hZEpJdDF2ME45UWpYeEo5UXhtemNCbjRzbjJYSWFWWjJWWkVWMldHN2JTOWJZTE10UHVrVnRUdTM0amVuNm4yLzcrSTg3MTBMMXZsdFZwY3Z0MFVhNUZWYUhYVyswK0s0eEF3ekNNNktqcURUZ05XaDNjY2dJbEdoUnVhVXJqR01uZndyTVcyckhNTjhNaVd5UFhzaXFvaFVhUXdUTjZ2ek5BTEhaS1l4TWxUNmMzVXIxb0x5bjVFU3ZSdUc5ckFjQmFpeURQWUlZcFdhbnpCdjBOOVFpcjQyVEVnbGhFckZUVTB0TWtMR0MwTXlFdXhGcXZRd05PTWd3YVJmUjBoMTN6aWZpNWx2T1BzODZCZEljekl6anlwUWg3WlQzRDBiTDlTU1pDM1RPNUlzeDZERFFlM2JSaTFkNlZDSXZSVUtXSXYxYTZDTCtPQ3hxRWtDNjJvYlRZSUhzUElLUHB5SWZTMjlmWUFjN2pCSHNRQVFscXZvSkhqSUVyT3RmMUhWcTZXZXY0YWg1bFpxM25uaW5OdTFINnBTL2xwTUQ1Z0thek5SL3VMVi9yMGREc3FCMWRIakNzSm1JOHJSOFVkSld2OTM3dmJ5ejJOVngyNTMzT3V6KzhaeUV2Zll6MjA5NTBaOHRDWlVaMUZ2QWNtcmMzZlc5ZHJSclBLMnhNSmJwMEppaUhmL3c5Q3J5ZGVVaGJPdHV4UkYrTVNzcDVLOGdEeThDbkVTVE5tWU1GUnpFa0kzcjlYcnpHcEJjdW56b0J2c3RzK3lvbXpGMEdzMThCTkUwWXZJNm1pYVM3SlZlMi9VcmRkK3pYMzI2dXlEQWZIK0YyOXYvVzBBblBGcXFYMUxUekVSbHdldSs4VVNaRXhpcEdubW5NaUo4OW1hUHBSdlBNbG5kR0diUVhmODkwUzYwVmJ6S1g2MzNGcXBhTkdHcnIvR1p3VTZjQThKa0dCTHBHWnVXUkQwUzFNa1JuUkpiMWlEejU3cDJGZVlzTHQxaDhtSUFYdWF5NEg2blRhazlDWHF3STVxSkVkTXB1M05tdFIyNXo5RW56RTU1bzBKSThoSkhRaGl4bjFWc0t6YmxhNzRLQVl4UVloWkNWOU03SW51Q1BINHZXS0o0UllZT2FhR01FcVVxWjlsT3IrTmZmUDR4eVNOS2pJQTNaMnhkMm5ZOGJXRllkeXJWSm1hNFlZa1QrNk9SYUVVR2VRTS83byt3STgzREdMM3dOU09xWjRaSDAyVXlWbmZPb1pXNDltdldNWmV2aGgwY3RveVN6dHR6dGUxQm5WMStYdWxQakdLRlZINzNUdkNndjNhVlJsd2VWVnJqOFRwQWduVXE2REI1ZlplcGFZKzFqemEvMnU0VVpCcXUzREU4bmNwOFhkQzVVVmF0b1A4MFpEV0pHYVFWUVhpZnp5aEFwbzN4NloxM3Z0NVUvNTBHcm1lczhTanJyamNEYkdyaVdvVUlLMjM5anh4b1dPck9qeWJxK0N5Tnk2djlNUVl1ZSswYkh6a2g1clRIak9hUm9QSEpHaDQ3R1JGdWVuakwxMXNNTTNYVitUNGRNRzVQNFk3WHk2N2pzanRNN25SaUh4ZE1pK3hwUU52bmwxS1l6Tk1ieG9XeWpQbER6QlpveUx4MGhOdG01RXZ2Q05xNHo1dWxuUmJGQzNzNVViR08vbmtNZnM3aExMdlhKN0Jpc3cxZEtEd24yMXlQaitmQ3Jrank0THFBWHJibm1rRi9uRDY0c1N5R1ZqT3I4UVVlU2hSVEtVcU56T1hXSHVMd1NQQmFudlIvNFRQM0J6MVlkd3VHaVB6SUtmZEV1S3NNTGJTTElvV0VORmFSOUxienlXV1d3ZE04UHI3QWxUK3U4Wjlzc1dkRTZqYlM3TjAxQVlRajBWU0RMbXIycldORVZveW1teGh0anluVk5ScWxDbm13bVBKK0RQM3BmMlAwNXV0cml1M1FoNnFqRFNlK1p2L3BjZmR6VDdoR1VTSGFwSGpDYURzdUlsR09tcS9UeXoyemZERjV2dVdFdHJYYThGRU5aZHFZb2tiSVZWV2x4MDZIMWhlU3hkQjM3QVdxWTk1SjYvSkJyRENNV3J1VWNkcWRsdzFweXZIclllUnlaMlRoR0E5SW9XMW0wdGJNWm8wdjIxNXl3KzE4QmFubEdkZlJNRUdYZDlzalF5bEtuYmZWSEsxOTl2TW5Jamk0QWMvMGptSzlETmJrUlp6cHNWRmZMSko3SXFoaXZWUTFJMVl6cWtMSTRmRzlBZEszTXkxZm50U1lNNkRvbHVUV2FuVklqUEdOZUpNTm1zMHNCZHBoZGgweWpHTWZnWXBqWDMyZEUrSVpxbWxLa2tyWEthY1Y4WjhhcU53VHM5dXExTTBGaldEVHNpSXlsWDEvYk80aE43OE5nc2d4a1l0cDduWHdnY3NGbk8xZkRodjg0MEVVMGhQNkFmV1lZWk4zUm1hSFdxd3lIb3N3c2c0ekFPYlgvWnF4RnBvL0hlaDVhcy9KR3Y4bW5hYytpSDhTMXQ2TjFaUGt5UWJTempTeGo5VHl4Nk5HUkc4ZFd0bTJGMExsK2EwWXM4bjN1VDI4eEdkdk1LVy9raDBObHVDNGpaUzZUem52eVo0N2pXZWw3ODdUeXphajczdndqS3h1anVnVXIvQzE4Qy9tVlZyRlR4WHV5RTFXZUEyazFuMkhKR0tYVFB4SHk0b3dvQ2dLWko2M1FHVGsvcENzZmRTeXI1TllhMGlmRW50L0JTczlnNlZyT0ZlNW5SYmYyYk5GTWUzVUh0eDB0QThNTTBza1ZydjRVd0FkSVRYTTEwWTZoeTB4eTM0eER0dGVKMG9pWFZxME1vZkhwVmJPZ3MvenFtYlArTkVIWGlqS05MaldjR1c4OWp6VzliRTViOUwzUk0rU0h5b1NaYzNGUE9McDY2RjB6aXI1MmlaYWxkZHhMNUprVStuQ1dWdU42YmhRMXNqdDhObmRjQnBObTY2SSt0cXBxSGpubkk1L0ZZeGNmN3MyS2VhTVpnUmVuZVoyUTd0QTkyRmZJQTZEWk93RndEZmhOYTZyS3FlY2ZlbFphWnEwemZ3cS85Tk1QZnlPYWZBeklyN0V2SDRUV096UFd0ZFo1TDU5SVdnYXVrdytuOWI1V1NtejhNNUNHYVVLZFg5bDh2M2RydFI5N3RZN2JVcU9sYUIvTFNnOXM2K0lWeFh5YndaQzNTeGlOdk5IT0U2M3JrdndieU1FeXlMYzlHdkxOTDdpdERLL3o2OGN4NVhXMHY1OHJ4aFRpbjFQNlFEUGRPeDN3dWh6OTFwR29LVG1CR2FydU1hT1VMelJzZjdOeWZTVnlyaDJ4R3RFeUZxR2p2bDlQVndEVEIwUm5KVllackppZ3BTTTMwcWNVdjgvKyt2bHB2Znc2THJ2enRvWnNwRXkrNjkrK3NsWjA2ZEpuSW5lbHJSUmh0WUhHUEdkN2JFOW50UCt1S0lPVzUrNlJ4a3huci9XNmVuVHJNbzlqYXovMmhCRHQwQm82NzdoNCs0cGNjV1pScFpaOHVKMzZ6ZWdpem10bE5leDNjYTRmRXlhOVVBV1FNZW9ycGE2SWJuSjM5cU1WOVJDNlA1cGh6YkxScDRxclJiTUl4VktpcE5YT0c3cHlLOFpKUjV1aHJVVmtUNGNVQnRTdTlWVU95eDY1WDBnVmF3cnFHb3k0djlydTF2TFJiWlhOSW1uMVVFU2UzTTdpblFkZFljU2pGNlByb08rQWg1WjFyRFJXMTVveFlPc3kxTEo2WEZzeXlvUzZHYzhrekhCWDBUcnp5bEMzVzFhT3RUeWVqbGIvTFVrZFFvZFl4OUxoalNrRXIrMlRvd005VDc2ZVdkR3ZISW9GU0ZzWFF2MUFuWk8vZHFXN0V4ckcrSTNldi91UjhXQUlzZVZwK3E5TmxuVSt0L05PY0Y4UTJpcFZTYnJaMHR6WFdlWFVXTG1xTTdNTnJMcExLYjd5VXVmcHRRTlcreUk2UjVqVmg5d1F2bFhaaGpMM0IrYXQ4ampwVVZsMlA5N1hWQlpYNi9VZnEyK2hvWTQzRC80NXFsZVZ6clJZRHRselRLT2pLTEptMU4zREcvbDY2N3JIV2lDUlFYMy9YZ0RkYTdFU1dLYmUvT2lFSGZVNG5oeVpwelZwY1NNSjQ3cEdxejFLUUhhd0hYT3JIRFA2QkFuaGRiSFpUajlObEtmSkJhKzE0akNOa2VKcXVwQ2xpQmFqMVlkYUVvUmU3MGxPd0J2SGlGdVhhZEZqTWcwMDBoc3gzMXE0ckVWMGFJVDB2cGFOODRsZGhuUXlzR1pvaWJKT1pLZi96b2dqdlBNY0o2bmRucTJwcHlibmk1Z1owbHROTUdPYW9EVkxaUFlyODZEZG9jYjRZZXJNMlFvaER3ZU5WazlXelZIOGNOakFwR0pHOFB5VlhVbyswMW9tL0N3dWRFZ1hzdDMxVmZNZDVPVVJtZjRqa1pQUDNxZjhyV2VKOUcyUHBuK2N6bHdpMGpweTVIRlVUeGxtVzZpZXNqaHZBbTBjM2c1TUFSV3pyRjZ2SE11cDl4aXUxRmtHSk05Z2ZZUzZVbkd1YWk5Withd0puNjV3QUQwdmtseFJoanZJakRMYTd6ZThaVk9BZzhuMGxuazFHVVdJMHBkcjVROVVTMUhzZGJOcXFySVZlV3dzY1p0dmZWdStJbnVGU0g0ZGovcGw2WDhaQkg0N1ZvK2EyU3ZHWmQyZ24rYmhCSk1LTWFrZS9td1JudGZxZ1BrT08yUlcrVXdkcjc5ZnZ6NTVaWmM2MDczVzd2eHVNTHdnSDR3NnJFYVhWcEFsbGUydms3WU1UaGZrajlLOEg1MXUxT21HaHJld1hXZVppc2h2QnU1b3ZqNmx6RnJYbitFYXZaZTFQSHAwZXpycm1mVlpMdm1NZVBKYXl1RW9WMGRXWGE4TE82TEdQSnB1QWFZUG1MR3VicDN2N1pTbDh4cVNQanZuUFZtZnZtWjJ4NG5DSGVyeVRJdDlwaTV5b05kOFg0RlYxbzZ1Zzk3MnJLZjlyV01yUFVjRUlXUmp4aHl0Slh1YU1FSldNekZrcEw5OUdKeE83RGpqdllXbnVJWmZpUkNKdFU3bTVTbU40OG0waW5qSmtwSlVhcnd6cU9aclhRZDBlZyt6Y3JCSTVBT1FZMDFqNVJ0OUpNYk5CdDE4YzQza2pyNEFiajJvR1kxMmxjRmpmakxDYXJpSU5kM3VHNVdkSEYxSWZyUkZuVEprdEl6cDU2MFE5RE1kWWVmWU1taEZUYUdsWEVHcC9scXRKTk4rSk5xTmVsMXRSano1eldpKy9zSk8xZXZLWkQ1dnJLeTlKYXNqaitEbGI5MzVHVFFHVmVtb2JYT2JmTTIvcG1SL1FYVlhrT1FvQmRPOWxTcnlyZmFPdmlBU2lhRCtYcmVpQnZuMXhyekw5L3UvZjg5cnYydjc4NVY3cFAwc0Z5OTAvK2hNNHJ5ZXUzNFJTNzhPRk9LUWZtVDBhOUZ0TFhQbTJJdk92cTN6M25GOVRwT0hFSTIzdG5OSVAwZmJPUkxUV1hsMTVGaUtZZldaenBwKzJjSmkvSGcwOUVXNzNSZFVvNWsxeWxHbTJiZnNlcGxQZG83SjNlbXhESmIva1NuVkx4d3Jza3BveEtKcFd6RkJCdExYNlZDYmI4VnExYldjRkJtdDhlcjRvOFBtSkZyeVlzdXVQNmxaLzZwRWt5MnAwNW1icEFnZGxvMTRsOXVyYTNrNUs4bGxEQ3Z1THduUkhpVit1ZjRnTG5EM1pramVhZ3F2ZVVwN2VGYUZkYTQzcUt0VUxZOTNYMmpaa2kwYlNodVZyYVd0RzFLZXI0OVQ4azBHb3M4ckErcnFHOFAva0s0QWViVjBGbDZaV21YUlpHbURLWU82bzIxQWlFSFVkRWdPMDRPaVg2dnpoOHgzN1FKMy96aG1ibjBjejUzOUM3dGUvOEF0OHVQVWxpNzNDNHpWaFp4aWJpd2E0YUhtYkFZRGJ0bDFTejN5dlB6UnVxL3oxYUE2U3RxN0FDL2ZLanpaYUJoVzgwL1M3OU55ejhrcDI3c01Zcnp1WkZtZDNBanRUVHZsaE95YTJGWTRVRUFaa2VzOVlZUmQxL24xMzlMTWZ3NmVCZE95Z0laNkNxMlJPbUk5ME5GZk9xN1B3ckpjTFdiM0hxM25TMTBGT085TmhGcjZOYXgrRzdHYTFpU3R2cTdwUU5PVmhpNVJYbk45b3V5UEpWN1IxSEpxQW1BaEpNSm9nQm05SGlFYXpFNVUxWnZmWW1ZczF4cTlzMENIN1ZsZWxnd1NjWVgxK2FSYzk4WSttVVpqbWVNUDBmbVNQTjlVWWhTbUpFZTR1T3pSaXVBSWNZazZJVFJzRG9pUmp6QjZUU1Q3djZBM01PdVptcElEMnJycnlQb1ZDdXFPV2pwSG12dWZSQWdoaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDSUQ0WXFxMVkxSkovTGt6YWY1NlBycjFJa2hrY3ladnQ0VGw1TUExZE9lY3h1WGRidUdObTE2d3dSVzVtdGJtZGoyN01CR2Q2TlpsdlZ2UktrVEhLMnArTkJ2cG15TnYrMXVrZ3J5MDBkMHRvNDFqcEMweWpVYTBZV2NPTGtSMzFQc0YweUZWUGYxTHFVWlpSRnJ0Q3psblI2dUlhVVY3OWEwWjhTSG9qYmNxVDE1M1lwK1BKckkxMGdsNDFqbTZpNkIxZk5SNDFOby9oaHhmQUlINnJ4bjd2NktlT2dHNnRid3ZuNkhla3JFYjgzczNOTlIrRjZjcUl2V0UxSEdkUnAwNUpaMkkzK21oOWMyM1ltZ3UrdVhxdUtEZE9MOThaVkdFT0tXejhOTkc2eTdxVUx6MlIzU01SQXRlWCtyVkZlblhjcjlJcXl4ZTJiVHJYbDFxWlVNWWRXZy9aYlJuSm5yLzN2NGNQVUUrNURlbkJxL1BmT1N5SDU5MkxaUmR2cVBwTEh2WnBSSGtsUHA4cXFvaTY5ZTFVaDF1TENldFJvNy9Ic1hTUVo1QWRzN3JWazEzYmhuSy9aT2lKTngzL1h5WlBEdGx5TlZSL2ErV0h0VHZlTWZpZEJiajNmSVI2aEFyZHBZNm5heHExYUJ0OXFrY1plUXFzUlVmYXA5RnE4OXJGTlMvV0Rhd25md2czelJUMG9acXNsSU1wUnExTkMzTEtidElFbFg3VGlkMUtVMjErNWgyT2FaOVh4TEgyYWtQeE5valhXR25ZbDRZRWM4VEJRbk5QSjFvYU91bGo3aDZyNDZRdXBOVFdpMlVUY2t2djlYSEVKUGJ1amNFMUFRUjBvblZ4ZERoVzE4MGg2V2NOaFExdTFvNGJ4WGx0dy9RaHZQaHZvd1FJUXY3cjMwOC9aMVdUSk5NMzdIVmgrazBwV0E5Q1JMeEZWQkZNdEszMG5xVXdldXlESzIyOWtLZmpxcDI1YUxtTjJxbVIwT0lXc2FNTUNMcWJxRzRxaVB0Yi80UjV3NzlBTGhoYit5b2lwTWZ3c3Q3YXM4eHgyUjQ5WmNQUjdxRnJ1ZVpSMTBSSytHQjFybzNVcjJScjZnc1NwNXRYcmliYUd5WDVRUWhVZy9GS2tUQ1pTRFhvMVk1WXRuUk90K0M1WWhYUVNjT3ZiVGs5YlpCajM3TFFubldWTHNlcVY4RXBPNnI0RVZiV3psTThOTmVwdWtVUlBBVGJ2N1ovWVhzNk8xS0cyaWdWVjlIZGFLbU1tS0dxc05pSksyVFc2UGFLMUtMMFI3ZDhrTFpTWWZJa25MUWZCeXBId1E2WVdpTUliSWVPZitmYlRxMXhJYUhoME00R1ZacjZiMGxYMEttTVJoSGVMTWpMVzJxOHJUaURGUk9MZThyNkpuV3llczBMRTFHNHNQZU5ORzFRaGwrYU91dzZIcGxwRHZ3aTZtRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVFRaS8vcy8vdy82RWZtdmYvSG56MTlIWkt1Q2sya1ZKYWVMaW9yc2J1TVZ6TmpnVHU1b2pzcTdVWk9SczRsc0hualpvUGt3ckRwRjB4VS8rU3h6NjVtakF1V2U3ZmRicFVJZGpuWGRraWZURlB2eU8xazJpbFQ2ZEtuSFducFBKcEozeFVBV2RiNjdMYkVUN2k1UFpBL0RzWEpiSmZEU25JWFh1MjhZWnZtMEtqMTZ3ejFENmx1SjFObkp6Q3BDMjFPTStpZlBPMnJwN05MZ1pGQ21KUnZWUFRIWU0zZHJsdWxRM3hieGdhYXlOSTdYRnJOMFNPcmV1OWQxYk8yOHkzRUlRenlWalhTV3JtTXBWK0E1aVZZL2p6cUJxQU9LakU4cnZhVWplajBCc21YK21UcTlHTmF6V3pOdDVmN1lHa1BKNk1kSS8vNmRwa0NmQVZFV1pxcnpwU0I5U3BGWkduWHJWZjFCUmNOSE5xc1dhVjlDY0t3ZWhWZ0R4RmZhUTZOdEkwdnFHS2NIV25IRWlHK1E2UVRhMTJkZ1hjWjhQaHNDVlYwNXFZR0l0VUJkV3VtU3NyYlM4TU90Wm0zYXlMTFhiWVlFUmRlSkx2TTBaYWM0WUZjcVFkbTVrYzljMWhFNjBlNTdxUHB5TEVlTktYWWs5SXVFbGFqckcybm5sczVXbjBMdmE0Yjc3cFdGOUowbzBiSkU2cGFRazRrTzM1NG80NTNPQ1NNZ3M5V1lONmhES3JkMXZjOUxOVVlDOWY2dCswcHRlbDFCSzUxTVh3Yk85MGFWSS9US0hnbDU0UDZiTUpjbzZYSDltbTVFRmxxbVpPU1hlWHJ1dDFkWEJDOGNDY25LdXF3TjY1RnJ0UDIzTkszeGFsMlI2NjhKMUkxcWFlbkF2QURLU3V0aHFiUjY5RHRCNHhxYWJ0UnlXYlI2ZU8vb1FYWEo4L0lhMHBOSHJVVXlkR2lqYW9XdVVkQ3hNekxHZXIxQmo3Y1g2eC9TT0pxR1dVeSt5VFZFZ3AyVXNLNmpwZS9SaVpZbGtrZm1VM3g0eTZLaUtsRXJqdWhFZFVXcU90b0VzK05JY2xQWVNCK0JGM1ZOMVdHRlZ5S2g1ZHJSdFFWQ1RnWHMxMXEySHRFYlovamRqeWNTZUNGVFVCcWJLVVNuQ3hHNUxaQ1phVlJIWkV6eGk2bUVFRUlJSVlRUVFnZ2hoQkJDQ0puT3VjK3MrSVRzZkM2bzh5dWFtVjNyUEw2bHJ0bW5DQ0dFRUVJSUliZUVreFZDQ0xHZ2hTU0VFRUplMENrU1FnVFZGMVBidjVIOTlTLytodlZybUxFRjVTTFZNaDNDNklaUllkRGRCcEE4enZaTTBLYjUyMDRxSllWVmtBZlJzeTB0K1V0MHE5ekphcy9PTzUrUkxWU3NQYUM4ZEZ2YXNtK25ac1Y0RFRuVDZhRjdpdlR1Z1RXeEJ6VDdlYjJGbHhKT3VrU2RZcHQ5cmV3YnZPek8vK3hTZkFaZUwzNkUyZFc2NUV3YitlMytDWTNOazBpM29NNmlSZkhrdERndlJ1M3hVNmg5UnZaMFEyMS9wRXpvUHE2RzdNTnV5ejAyM3VEUFo1bTBDNHNEcTMwaEhCM3J5MURDRjM3STFTN1l4V3JQVnh1MnpiTnVzTmY0U0t0T1I3eGlid3lFdEc5cnZFWjBlRmpqdE9kNk5KWk5Udm90RDJLdm9pczRyWGIzdHRxMEpHWnh2ZXpPVzE5TU5VdFFBdTM4WG5QWjE4ZnhJNEdOdXZ5cnREck9mVjJ0OWFrNnRGOGV1aExhem9URXJKS1Z0MjBoc3BLdjdLNGZQZUFzTVB1RSs0bzZmVXA5ZmtuZ2hhZzV1QmF4dTkxb0hKbU9NdDV5VWdwOXZsT2U5ejRMNS9tODNzK3ZJZWpoVlV5SEUrS1ludjdnZC9EcjhKZFRqWEloelp5UG9lcE90cW5DNk5kWlhrZldJbHJEZGdXOTRXWkxGaExTOWQ2UFY1ZFdlcGtHcVdOVWwyWFhrcE51U3pzamxDVmtNZExkUnI2TTdVVVJoeTl0RktBTXl2bThsUzBaRjVYemgvRERHWE5OditUWWZtL0Z3VE9SaUxtT21NUmVlbWY3V3Y1a3lFTHpvclA0YUNTYkF1azkxK0NaNzVFVkZTU3NrUEpHa1RwbXVLa1ZNNU5Ebmh3YnYwbm82TzE3MjdYamZOR2VFV2JqakZ3ejhteEhjV1dPakdBa3FMRkVnRWIva0w2eGxtVEd6MFp3YjNaWU5LRHNDZXFrck40UjNaS2RRSjNlK2FqY0hobmVmVjhGTW9wNlBGWWtiMHRtcXovMFJBSEdmY21BNnEwYUhhOUNQTCtjZWcyZVdRYk5kak4vU3FHdU5lejBVVFBkVUlrV29TZXU5SHE0MU8zZEZocHZ0blRNYW1ieU1OaXd0eUlhUlU3VmJTZy8yQTR3VkdQWElzdG9PZUJXSHFOLzEwUm1JclBqaUs4Yk01RnByNVdYUUNCeDQ2ak1hTDRsZml6MXcxK2JrcStBdHBNUThtblFiaEV5Q2tjUklZU1FMNFV1a0pBaE9JUUlJV1BRaXBESnNFczlHN1l2SWVUbWZPMUxYWVE4Z0c4ZHQ3UlhoSHdpVjQ3Y0MzWFRZQkV5aFN1R0VvY3ZJYVFIMmc3eUNOaVJDU0VHK2QvLythK3hoZG4rSisyLy9rVkxRZ3dXN2dRVjNYa1MyY2RzT1pFdGtxekNPVnRCcVJzUFZycE91MWR5TGNpMlBscGF5ZUE0L1Rxc3Vnb2FtNUc5UGEzcnlaQjlUZk8yOTYyTjdYV0h2dnJRMkdHek9LcE5ScmVRR2RrbmNPSU9uTk5RZHN5dEw1VkdIcE94Y3NvZGtjLzhHbXFFU2FiakhrUU1tRXkzWXRQYWIyVkZIUWRWUjBOWk5IUlpld3VSQU1ySzJ6czNqdmkrVmg0dC80eXRjdzMvQTM4NVVQTU5Zdkl5YlE5WnRDNW54QnV4OG1vOURHM0Y3Vi9JVHYzNkNTWHhZYmY3dGc3cmVveW9kWmpaajdWOGRWNTBIOFVVa0MxbEpVY21HdXRaY2pWWnlaQ0pIa3VaamJoYVBkOHFnNVpYMDVtY01tbWFpaUVOVE4rNG5UOXhaY3YrR1R2Umx3TFVzZm5aT0ZPWjFMS1hZNG9JK0x5d2VSNzFpZVJiUUx2VnNVY2QvWkZ2K2ZkZlRKVmZUYzZPai91NUxrdWxwMDdOZEJHL1lvakt5aDAzaDNYUXp4NHFQU05La3ZsVlV5OE55czVHMXVjZDNkWnRXN1FDcTFZWnRDeWR6ZjNPMitoQzFwZFA1Y2RwcmZ2MVhGbnBMZk1mNGJzL2R0bGVCMTdYYVZZMTJyNnQ0ZGlUcm9YbkNpTWhuQ1Z6UkllbUt4QWFUSFAxclFuU2xXVWdaRFlqdmtDUjFiVGZucHFPc3BnK0FaMG5nT1BiOVFVRHR0UDdXSmhuK250TVpFdGVTMlprZFNPaW83NGVuZTFyUk8vVGlpYVIrL1c2VU1RbG9wRjZjbVNOaGh2YitSbG13ZU5zVitkK0tiVTZYOU83Y3FhV29YbWxOTm94cHJWZHQxNXZXd2s2bXVSNW1hekRNSnVURURsQlNBT01Xby9TbVE3UjNSdk10OHBmNitnWjBWS0haNWtsSTFZRUdiRlJvdTJhak9zOU9pMDgzY1lseU9rYndVd0puaWZuNGpuNTBTQ2daMmdoWmRJQVRNWXNqOWRqSVZjejRoRVFHZlYxOGhDaTRZYkgyY0g4dzBITjd5bFJoSnczYlgrM2RYUlVqZ0c3RGprVlpVcFpHbXYvSzBMVjNsbkNZMEhqeFdpd2s1VDBOREpOSXFHN0YwK082SXpHcnBKb0NLUEJMNllTc2hvYVpFSUlJVy9vRkZhVFdjZUVFRUlJSVdRQ2pDb0pJZVJtOEtWTFFrZ1BOQjNrZ2JCYkUwSUlJWVFRUXNqNWNDNUdDQ0dFdktCVEpJUUl4QmRURDVmVDl2dlhYLy9pYjFpL0htUzdvaHNXNGNMaS9oRGMzbFBkVlZ4aTdLaFNpeld5cVdsdVVVOWtQbXpRK1p4Z0MyZVB6LzBYUnVRWEpVSERCRiszMG05NWtDMVc1UFZKMjdyc1ZCdmxSNzV3WkY3UHFXL2ZFM1Fmcmp0WTZtM2Jyak8yZDR6ZDc3NUc5M1Y4ZG8wMU5vUjZGak51ZE1hV1FkL0dqV0x5RGE4b0t6ZU10V25aV2UwNkVrR1A2dmJLSk5Ob1pVRDk5QXpkd3VibkdUNUF5TzcyZVlqdlhMa2RzYmZQbU82SHNwQnRmc0d0TWM3L2ZJRWdHWnBrckNNL1hWQ2xXZk9GY1hRc2piWUw2alJxU3VBNkVxUE9LQU5hbGhINzVOa01LejJpcTNmZU1ITzhpckZqcG1xbHk2cGR5M25MWTNBWXAwV2t0K3ZjL1ppMDNHSTBXL1k0T1lYYmhGbm5FZDlBeUJobzZCcXhBRkdMY1l5aVBOc3h3MStocFhHdXE4UFVpVU5NODV6YkNRNTJCL1NOUGNzYk96MnRNaWlnbjg0VTl0bTNuWWJJNGx5djB3U2JOeW1IK2ZDUHBEYnZRYlJ3RlNIeXp4ODFycFE2RERIeW1ZWmFkVG5aWCtUYkNmdEpyK21vNWUzT1IwUDQ1S1RYUUhYZGlZakw5MEk0WkVsMDlQNU5PeWF1eXpTSVBZcUdyb1IwMGp1VWtuTCtmZDBJZ21BM3BQZ0srT3ZaempnL2ZMakxjcjh0SDVpUDhqUmR2Y01ZY1EzV2VUUTZSRUloeEd5MThzMG9BNm9UeWFjUmRRbXR1dTQxNTFZYXBHeWVEbG5HVm50WmZjelNoYlp6RDE3ZGVrdkJyWGpUWGVkSVFrYVZMQ1Y3MWE0bjNQRDZUbkt1dC9MMTlxa2pQUzN0OVNhWjNEUFVTYjh1WlZndkpPM3lXdGV0WG9kNHJwYUYxcFNqT2tlSWxra3JDOUtPaUE1TFYvUjZoSmwxMi9LR1NGQS9nMVlaTk5DK3BxUkhKOEl6bXNrcXczemgzMEdQbVJxUjJaTk81a0VDU2M4QkE2S1I0NGpLQ1ZPU0xwbG5FNDB6eU1uMGptdFVOam1WbGMyNXlVL0pHY2RXT0oweG1ldzJwSnVvTS9RNmRNQmhaVUMwbGljU1o5VG5hOW5vUFAvclFLYzRTRm9hSnBVWjhXZEhpTjZVaFF4blMvZElNL1BYcG9RUVFnaTVBZDhXdFRKS1h3L3JtQkJDeUpkRFYwZ0lJWVI4Q1JjNmZjWWI2N21panJsTVJ3Z2hoQkJDUm1CODlSM2M4VmMvdDRXREFvTVRZRUlJSVJkQ2wwQUlJYmVFNXBtUU9hd2VTNjh2cHZxL04vLzFMdzdycndmWTZHdldWaU1qT3lUZGl1aU9FMVorVVFHUjNTUElsekN3UVI4QmlXNjRDZFo1ejhZanFmTzYxTEhBZkFPTTdITHB4U0pCNjdnclN2WkY3QkwwN09lalhkZGs5NlliQWZXMFd6Mk43R09VZ2pyYlhOT1AyeUN0L2xnejdHM2JndzRKQmpzK0Y5WkJ4QkpxK2VxOFhyb1UxaFhkdnlteUUzSmtQMWQwdnlsUFY3UXNyYnhlZXFkMjM2cHorL3JVUGNCbVdzM2VDR3VHejk5TDhDU2FYM0xiYmJLZHF5b3Y3YUtKdk1vaGlINmZ2OHRicHNZODdmVXBYUTdxSEhyaXF0bU9aM0pNK3o3djVkWFNJMldJMWkwNlFkSjBXVEwxZEQrU3N6aGZySVNOL3JxL3ovemF4cmJVbDNleTl2T0g5eGVRdHkrdFFwK0RNN0M2L2FGcXZjRExramxRdG1HczhVeWV4SWpGSElzaTl1Tjc3dHhMNjY4OXRyRW5mZFFQK1pIR25rYVFvTVY5MmhiZmJqaGxyQ1dvNThYOUhyNzBrNUtxMFB2ODBzeG5Hc0VsbEJtZDBMdU40UyttOXVaVHNEN0c1QzRsL1VuVVBzNkdMbE9lQlJwZUttVllndGR2VjVhaFY3Ym4waEdYM3p0OTc2bUhNOXFSRUFReHJwdER4YkRQcFpWZVNSRHhEZTRYVklVOUR0dmgwankweTZSa0duSDlCeDBKWDRuUWlFU0YwZlFUd2doVmRpUVVpcXlJSXJwYlJOc3Z1cExVMGhsTjN4dHV0QmhwOStHUXpyRVp6ZFhvSEhQOVZpV09qdU1XYzBPZVdXdGxQUmk2elFtQm9UUDBDZHc2VDg5b1ErNi8xVExJV21oMEhvem9TSTRzcTFmSjY1RWU3ZFhwU3U4d0NsSTIxQnZPSER2V2VFVzlYM0owVzU0STRGMkU2RVJZSk8veU9HUTVLN3ZZYkozSWtNc3gxVzRzNEtUejhrWHllbmkzRzRtYlBSMFdITVVmUW0vSFpnT2ZDaHB0b0hKNjVzRzVjdUhRbXJnaG05MkZuRVkwbEsvU0hxYVdSZ2pycVVkbW10NTQ1Smg1TVdNNnhjcWNSdTlxQnlwM1JxeHF5ZTZCWDB3bGhCQkNDQ0dMT1crMndua1JJWVFRUWdnaGhId3JuQkYrQjJ4bnNnaDJMVUlJSVlRUVFnZ2haOEU1S0NFZkI0Y3RJWVFRUWdnaE9xOHZwcjRQcTB2NzM5RHlpNmxmeEl4Tnh4WVIzZG5nUmtYZk0ybW5xd0tNWHUyNmxZWThpTWpPWnBKWjJ5WjhPMkFkenR5eElyTGY1bnpwSTF0K29TVkh0L0NMSUxmdHNaSUZkNW8xZGZYczZ0cTdnK3JNdmZ1S1hRUnpHL1ZSblpveVQwZXVjcFhxYkQ2Y213bXlhMU1yejhjeVkzc3FaT3RKb29QVzBZS1lIclhPMmpGcW5kQXVOWjlXYVVaa3pacFB6OTdTckNpaVJicWV6eTd0dHNsdjFRUGF3aXRiZmpTTzJPZlQ3M2F2STlxS2J6K210TVhCRFI4RzJSYkRiSCtLa0oxRW1ZNCswLzhpNm13bXhIWnZ2TW0zUlk5M3QyUjRzVjRMWjl5NmpyYVZWOVBsWGRka1JXTjRMVjNMR3lBMkpCc2EvUHZaYTFERzJIdE1iRW5FOXAvdjAvdXlIS2NQRVcrSXpuc0M3YitMc3dLK2JwbjVYZUVqeVZYTURPbGxsNHZJL3V1dmpsZngrZURLZU9PT3VoRC9wTlQ2SWM0b1Nod3BaRnFmMEh5TFZuUjY3dU5RWEtGak5JeEFYS0xuQ2x2TjNESjl4VDRGeDQ5QVZiYytoRlJhNGNZaHcvNTZjY29seTVDU3lHZGNyeWs5ZGQvcmJnQTNPOHlvamhWdUZhM2pNMEhIVW5UTUVYSmoxT0Z0Mkc4SkdnRzRRcENGTzNGOGNNZEdHRkVhTnQ5U0xlbVpEZWZHK2RFUVFzcjAwcVpHV2VwejBaVUlTM2Z2U29SV2xwNjZSOHVFbHNHNjNrcURja2Yzakl6ZjNuNDhBKy9McWNXcDFKNSs3dmNWZlQ3b3JkdnFhVDFRb3praUM4MHVEUEc3Q0VWUHB4cnExQ2hiaEZhUWp1Sk4xaUtXT0tvRE9WOWZ1L1BFWWN0YkRMbmI5Um5NYW05RWhoT1k3TTdKODVhc1pKUmg5Z0pBYWhqTDdmcktQa1ZPd3d1Z1pyb0kxRHlkWWJaQWVrWnRCbVgxak5wYVZrK3NpcGFGUElUb21OT3VrV2tndHFNNTl4YVBOS3gwVGQxR0llUjh5VnhEVWNRUWNocWQwNThyK3l2SGlrRlBzTVBLM09GVklWTEZxSTRrWkhsTjRjMUFJMnZBTTJOVmZqR1ZFRUlJdVJHTTdaN090MDNEcnJ2ZnpORkVDQ0hrVzZFTEpJUVFjZ1BvanI0RnR2UVR5ZCsyZkVVSUlSL0d0NWhLdWdSQ0NDR0VFRUlJSVlROEJhNXpFRUlJZVRLLzlvZlc3Mk4vbjZkTC9EcEdmc0k5cURMUzJ5NG9aaHkwa0NXUXBKRzI5V3YzajZndk1vK2VCbWNud2Vpb0o4MmI1clRXeS9ZM1oyVGZZWTNXbmJYT3A5Uy9FMlVINkZmZ3lrcXJXb0xIUFRKNk1lVHNtbmRWM2NUei85N3hPQnRYVnZHMW13YjEzcmkzaFJEeGlYYm5FL3g2MUNNZ3ZnKzNMRFAzYmRya1JPMWFkbVMxZko3TTcrMmxhcVh6a0Rwa2E0eklWdWoybXlkMDJLazZqM24xVmk5cTZ1S0p6ZUtFMGx6RkRTUGE5M2ZNZmtVYlNNNHNnelhtRU10bDVZM3FqRkozaEpseDJGbmpzN2ZlV2pMa1ZheXMyamc5eUxLKzhsZEtJMWRTdjNBY1oyS2I3SklHdHI3MFBtZlN6ZXFaTURtVG1hM1pzbTcraUNpaDgxcks4N2lSdjMwUDg3NWFiOHVVbDBYNnpiYStQNWtXMkZwNXBnc2NwY2RVTGk2bldhVEtCVml1eW8wdkRXWFE2dFhvTTQyZWFaQVd3czEwUDVIMjE4cGlwYXRCeXh2dGd6ZnFzMTE0VTNFdkhTRWZ5dWhVWThwd2RzSUlxSXlsTXRONW43Zitpc2dzczIzRnJNZ01leGJlMDdLZU5kTXJURG5Zdk5Oa2ZTb3JacjB6NjM0MnVRcmwwWkJIZ3ZadmROWGRPaE81SG11L005ZnB2T3pTTUh2cHhYR3pjb3RUTWJPZWFjaTgwbHJLNjZPTTlSVS9uK2NGVnFEcDF1N2pLb3MxSys4S3p6VHJmWldGN1d1dFc3Y3pWZi9tUk9sVVpqbm9sV3RtSTRIbUpERGZIb3VYUjczektxOURIa1RVRGRIOExxWHppVWJqUlBQMG05eTY4QXF6WnM0V0NGa0dQdG5lcGJNZS81RUxvWDhhWnRVcWdTWWpXdjJsODlwcVhqOU0xVUpvOHJYSWRVSjBQVVhLV05DbGVvcnlFVmhyczRMSS9YSlVmemxlbndMN0hKbkFxNjVMOWFBKzYwbXNyQWZRWlcwdmJwelQvRGw0VFh1ZG9MZkR0dklCRDFoS2RTMkxoaG9hUkUrd3dFQXdBRWZETXcyT1hiZXRudldUTzcvU3pHbWZrYm5aUjV2aDFvMUhiMnhrVWt0ZjloZHJ1QzZzbDk3cFFldjRYc3dzSGVLQnJaVzlIajJvOTFlc1pVNktqT1N2R05ZcmpPOGZGYXdtMHRGNy9YSy9yL2Rhc3lleUFWVzduR0U2ai80MlYvOXQrV0d2SDQrVUdoMWo3VWhpbjI2V3pobUxMcU1PZFdhUGlJN1BHYnE4Vk1jWWNKL1RxTXVBUGN2Q2xqYXplbFdlcFFCcHA0MjVpeldFaXFYa2F1NGREWkFZK0xyR3ZxTnFVZEVzYkg5N3RBbm5zVEo0UDhQTFc2b242RWFmVXBzTm0vZm5QWEhSaFhaVnAzUGVPbzY0eUxJL05KTWovcWVXUFNPRWQ1cTlwMWVnVVlsc2JsZG9Fb1dKVE1GbXVhdVc3bk5Db2lPdGVvaWVQNE9JYm9ZWjVJa285dnMzUmZpS3lJemJrajJkaG5MNW85VHRML3JqMU95b3lLQ01uaG0yVjJWb09JS3VSQ0RNV0dGb3BhdGxXbVdicWZOS3ZENFhxYk9ldkxOeGJZUVJUOHBRdjJqWERGM1doWkcrNCtvWVRKL2RxMmUzbmhiTWFzbGtnT3lVc3pYLzBxNXBQM1FkanJlODlmY2tycmVzcFRjcFM0MzBTTHYyZUFtUE15Y25pUFdaZFYrZkJ1bzVrVWhEbnV2Rk1aYmRySGcyU2NLTVBzcVpTZU94d3Z0RWxhYm5rWWMxd3RBNGE0WDE3U0VhQVl6RzlPUml2SWxQZEduL0xoMlpUQ1hMZzZLbktZZkUxZlhnSXcxQ3Vva3VSaUJob2hkSEJKZ1ZSNUFCV0tuTHNGWjFWcXd3dGNiU1dhdFp2L1lMTjJjdm9wR1BvTWVhRDNZbFZPVmplaTE0RTRnRGxzdXhITlZmeG9xWHI4Z1V0dkU0MDVSNmF5QkkzblBwWFcwcHdmUGJ0ZHkrWGh2SjhPY2dVbHQyNlB3WlJIWExCNHppN1JZbENTeHJLTDNkVHJ2bVRIcnJ6Mzd4R0JuWHlPT3BqNk4xNDlHaHRHS29mVHNmVWkvcllsWWtHRHJMSTF0b2R6eXJCclFCMnZKTEhhdExyVjJZbC9XL2tmcGFVU2hNNXF5ZU51TzN2dEZldXM4YmU5eGFGQWwvLzl1bmZVNzZTQTJnSysxbFFBZWFyeFUveStqSGtvSHFINlhIRnNxOGxreFBweWJUeS9tN1IwYWlPRi9lbnhJVW9PK29iM2pJWk5rZS9HN1JTa1BYS2tiNklIa1MvdnpvdEU3WnNDem5sVUhUM2o2ZUtkczdQNHNCVzRwODNXUDdaUW9vMHBYZCtoSTBVb1hJN1hvdkx5RVRvR0N6V2N0YTd5TElGd21yTW5USG1sN3pKb2VzVjIxWDlhRDMwTE5BT3d0TDkwaFpSdDF2WGlCVHltSm9RTWdRTzlOaExObS9qOU1BSjRjUitmQ1BuME50elhEV1RCZVY1UzE5bzgva1pxOUVXUGxxWnBsdlJPYktsWWhlMlNQUFl0RThJOE5pMFpDYW90dUxDUS85SXVzeXVrTDMxTSs1NGNZVkxUaHJiVlFtSzQ0TXcwRFh4MHVaL0V6REJGa0QzdjcyV3BlVzdKYkhtWG1mVjFxZks1aHh2OVlFSDgyTHRPdnIrTFRtT1gwZ0U0MDdPVDJ4ZG5RZzZOTmI2em5oZFI0aDg2cGxuSTNSWVRvU041TWJNR1A5N2FxT1RNS0V4M3RqWGxScW9VRDdlMnNPN0VLa200WHg1aXpSYUJ5eCtwRUdFYkJ5aHpsek5sNEd6ODlvN2wvN1EyMFMrbTBMRk9TTnRiN1NzKzR5cU5MTDh6RzkxSW9hQjBUc1hpS3B4R1lqL2NMbUkzY2tnMm5ZSWVKMGpHZlVZWHZqZEhRYzkrWEx6bkZFYXdaMW9OZXR4dEJtOXFMMkR0dUtpMk1ybjFtT1NCeUZMaVVnWldsTnV5S0F2VXU3bkJXSE5FVW4zdVBybEg5Ylg4ODc4d3M1cytkZEgrT24wZUU2MDVCWlErcmJncHNiVHZhakx0R0tXWHNzWnI4LzBud0V5b1NnM24yYzVmbmQxbklBSW50R1BmVGd2Y29tMDgwYzJMMStONnFqSEtSbDUzNmtYMEsrQUtWOVVlUnc0YmNFcDJyejRVTGFsU1hDNy91WUUyZEc4eUxXSStxUWtMSGg2VzdsazdvUW5VQnNhNTVIeHg1Q2RGYmpuZmZzVkV0R2NVclFMcXY5NDlTaXlIcGRlWTJ4OTdIeElsOStwU3ZhbDA5UlBHUGdmbDBRNk1kdU56N1RSNUJQWjJaMGtjMnpwYWw3SFZaODVjVVgxckVsSDdHSjJuR1BydTB3NGlzczNlSTRDOTNaS0tQOExOcEJ0WE85RWhVR2NTWGU3WTZBaGhGRzFlV2U1UmNoOHZjL2FqZGwvWWJYZEVlbExkOWNPakt1NythSHNwdUtmNWozamJUUmJOY1drWmVkWSsvOFRLSTZycGg2RS9Ja0l1NWErSWdzajZVbzRWWWpPZy83NGFCVHNlMVErSW9rVlpSR2R0QzF6ekloMGZYSUdTdUhVVk9JcmtSc2FhTllFVzJ2SExRN1MyYXM0aVJBeHAxQjJ6RlMxM1dlMW16Qnc3UXBTcHFhVnVnZVhVbEN5NnFQYTJ1T3RvS2cwWnhTbHNHUmpEVHdXM1lyS0VkSGZIMitPT2s4MlloVmpmYTJ5RFhVUWtmeXRhemtqRUI2SlArSXgrblZKZkhXV0t6MFVuWlBzT1BjdDV0TXRsOXBuTzgxbWozdCt3bGU4a09aMUxYYzlCSFRFQTBrSm5TUEZTcEdZL0tOeURLY2xjK3JVbzZ3aDlFN2JxUFhTRGZJT05jaUFZM28zTXdTOVBiNFJhem5WUGFiM1lGY3h1aWlFckJPTURKNzBGUWc0NWNJV3NZeHNxUnd4bFR3NWxoRFptUW9vVHE5NnpOMXo1VDVLeEVTNVliR3hwdmZQNW45UW52Yk1ST2lkZ2gya3JYTWVHWUFxRWdKZjl6eGZKc1pmU0RXd3drTmUwZk0yMTVaRjMxMWZWWHJsTVhYYjRmVlBDdHV0QVRQazl1eVdlbUlmNXJ6UUFkZHNrSWZibytVQnJWdDF2TEdDRmZPR083Z1AxRmpjcWFoQ3VxeUJrOU9xYmVPWjJ6V1VHN3BCWHZiRlgzODNKcUY5L1QxanBmQ3V1V01ndHBLQ2JMYVBjY2IvUDNoNlUvNnZ6K2VMa3FKNnZPbHZxQTBiN3NNNVpBdUtlbWQrcmZ5ZWwzdElOYnpkV2ZiNHp2NEFMSVNLOGFieFhVOTZBeXRuekErdHJjbWNtcitVSFJBOVBGOFRsTStIWDgxVnZPZXVFRFgzV1F6dTJXK0pob2tGN0hhS1JEeWFVUU1YTlFZZ3RPcVA3N0F5enZMVUtOdmRHcm5KOXVPMXN4TVU0M0lHQzFINVBiUThzdjBjdFVDV1FudHBaYnYzZWNadmw3ZXIzZjhTVVRMUHVVK2IxeGhldjgrZTYwYnViNnFBaXZMaGM2YnZIUzdvcDYwMXAza0cvdUl6RHZQSEhxZkswakxUZVp6cGpITDRIbE9tQjdEMlFzZU56TVZVZXU5OGdrOElVT3c4ejJLcFhQU1l1dmN2YlpCeUNmU3NXN0g3djRCdEY3U2pMN0UrU1dzWEN0K0t2eGhLdkZCMTB2a2s0YU9rWWRPUUxWaTNOSUdvak5tN1drTmNMMjgvck5icHF6U2xnR1Y1RVBoQlBrOFZyNUk4RUtPVSsrNEpVTTdYeUR0bzVUR09mUU9lOWp1TUNvTGZRbStKUDhobVBYS2dQZHd6YUxuMVlHb2d5bCtzbmRWNVBZdHYvTmtjUnpwd1FsT3MxZmRsajNqeHplNjNMb005clg2K2tmN1lXMXk2ZzFqNUlZOUE4V0o3MTltbU1wQmxhdjhrNllUQjVsSlJPMHBPcUpSdE1FVGxkWDdWbmxrMG1ib2FMM1JmbENoL1ppZ2RkOW9pMGZTeTFmUGVyRmVzU3R3RHF2VWgyTng0djNseFNwbHNaUzlyMlpWeGlZOG02WGN6aDUxSGxWbXg2ZGFkNHpHSjVKSWU4OW82NWJ1bHZPTHlFWFNSc1pRQXMvTE5JanRRK1JFc093eWNuNS8vZjIxNGZmWm4vT3l0ckFmcC83SXNHN3JKeVRlajYxRGJ4YzJzMWlmcG92ODhNcnRjbDVidFB4UUwxZm9KSGZFWHdKdCs1ZTJCeWhHRDlyYnNaOHZlSmV1TXV6bEhrdGhsUTVMSzJXWGdQenRQdDFJd3RHRjJodkxIcWQwakFkUlgyL0plZDFYVWE1dDhhVDhmS2RWM0d6b0txbWRmOHZTYXBLZVpyWHlaa09ubDg4cGcvWFYwL3JmclNyUVB2UmRyREtKKzVWVmIvWVN5eFVDT2c0NmMycVg5ZW1zY0ttb1MwZkRURUtlaG1lM3RmUUp6OVB3dm9jeWVDc3IwdldWMHVIYVhycThkSlpwT0h3dFlhSHQrSi9JYnEzaTFEaVJ5b0hzSEtNUlVXUlc3NVdsRlVIS3VrQmwxakphT3VXTTNldS9VUDhHcjF2SW1hZDNQS0pyaE9oTVJNdHJtU016TEpZeG0wai9QdGJTRldGTGdxRzVqQU9sYlJnWkQ5SFFKUkxLOUpXaWdPbTh0QkhkaWh6NHk2Z2lmVmVaZXEyTXZGYUE4MWE2VDZEbEZiYS9WMW9teVdnOVIvb1VPQUhzOHJ6ZXFHOU4xaHY1UGNPMlpkRW0yVy9SOHRqU1pVeTZGMWswRWdRMVg2MzhxWkcyZFYwemtRaU96dFpJNjdYQ1VTK2p4Y3RvR1dhTkNPMitlNjBWUitrRjlJUTJPWGllTEdNa01wVXl6dFM1Yy9XQWZVYWpGSFpCTWcwdjNnRFFYaGZXUlBYTUJxeno5TE1PYUR4cFhkT21wRWplQnhQMUNXZzFyVmpOUU1vYW5acU04Q3VGbm5vVFlsQ2NZekpFZVJsOHplYlhQcUUrNzhwTTVGR2dVUmo1ZXM0Zis3MUxreWZ4VWNhd3RmeDZNamUwTFZ0UHUwdlJvbys1UGhJdEVMR2VWRVFhaGtIS3h6TmpMSG9MVDNNNzNWSDZmT1JMQlRNZTR5SGt1RzZ6YXEySDMwb2E2L2lnSkMyNnZvRzhGQlI1RE5xYmQ0eWZyejdHY2trWnY4RVh4TXFFTkdpZFc4Yzk3WGRuSnhLeFQ2MXhLNituaE52RTFvczJyYnBzbGRtUzZXR3RjaVBuUGJ4MDNncDdSQWVldDJnMnN1ZnpkZkxGcCtLMWo3V2FsSVdzM0ZKVzVkV3VJNCtFZXV1YWtEMW5SUkUrN00vVGVac0tVYmNydnRKSzFtR1krN2YzMWR6UWdDcENDRG1WcU9FWlhZclEwczRxdzRxOHlQVCtJdVFNZW1hUklqTlE3ZnlLNnZIdXQ3VUtrQWZQZXpwWGRnZHJKYlJuWllIRVVQY24vQnJPbTRVdWs2bjlJbm5hZ0VYV0RpMHJ1ZjN0Zlo3aVdUQXJEMUlScUpPVFpaZk1zSTVJSFVka3pXajQxUmIvTGpvOTFWd1RmVHlyRmphOFFHdEVWNkE3ams1RmV1R0lJY1BROUg0MFBiYkdlNUllelIrOWZsQ3FoUURzbCtUVFVLWmVYRk81SWRHQUxSdHBhYS9lek9qblo2MFUzYTJwd0MrbTBodVNpdGFhbmJjRzZGei82SjdXV2s5RTM5Tno1S3NQY2VRaWZ4SHY3eFJkTlNFd2ZFcjNGemx1dlhFdXowOVFhZEgzQTROZWk5dnpDTnFLWnEzS3lhRHVhR1dMK3kvVnVZektRaHJVdTEvVUdSVGpYT3VoRlNJamNsMVJZK1V0b2loRlhDaFN5SHpEY3VjNDRyRit1UFZXVFVyMnM5RGlwQ000WGgxUEpEdXE2dU9TK290U0dqcldzVkpEcWY1YVBzeXlZRE1zV3c0ZVQ2aUx3eVNsTjZDTTlBRHRCWlhVeUkvSzF0SjVyeFRxa2xGTjJ6K3NLR0pmdGNaVGFVdjUrM1pXZXMxZVl5L1RiV01HYVZmUElVbFdPS0plV1ZZK2FUTmExNk5FWW5aTGwzZS9TTm5xKzdMdXQyVTd0N1A3ODhVNEwzUDl6SkRzdWp6Y25mWEZpZGY1ZDYzSVVGbCtLWFU3Vm45b05XdDhhbldvNmFqU2FidjdkK3RlZFYva3Jsaldlbjl0aHIxdGFmNDV0citNQ252a1J2cG9mL2JXQTVCNjZTMjNwN3VsWjdOWDF0cEpjbVFZTmxQai9ZVlU1L3BiaGREaDNWNnJXVGUzVTV3OHlkRGg1UnZwOXFJS1pieVl4WktML0hxVjVyYXM1aWh1L0xpWCtVNm0zYTlSSjNYNTViTFJKcnNZNlhkSnZmWnVHU1F5QnV1VGZBdmFGR3lXM05RcCsxVW14UFFoNTNlaUsyRTdueUYwYStucmROSk90MEtBMlZXY3dmT3RXVkpVZG9Ub3FvVzhYc0Rya2Z2MTJrREtsbCtsOWJCMFJvZ01tUXpxWEZtR1VSazlzd092SFdVY2FmV1ZsbnlVTEtZUGg0OEJna3NPWHI4c3puRUNqdTM3TzdQRlBSa2RsbDNiNU9kUGxtS2treE9LbFBiclZ1a1lsTzh5cUlVQTBpUkhWblFrei9BbzJucGtqOWY0cDhvai82SVQxcXZvdVY5RW5nUlpqMmpsNzlFWnRjRFdlblJqQWNDY1UrZjl0Y05jMnltYitabnB1L1FiRW1LR2k1aWswM3NVNFBuYk0ySjVEV3NVRnVONkJFMTJTWTNoYlJ5VG05RGJHVkQzNVRWOEswZ2xRNkNSWU04OHVBc3JiTlRDNTZMTWs1VGsyakVoWVdaT1RVVkg5Y1lodW82RkVKMVpmdTNZUVN0WFRuZnJ2SFgrV2RQQ0Q2WjNDRVhTUjZ1NE5NNWw1M3F2emdqZ0QxUEpWMlBOcGxwcGU2OEh1WlhOczU1MlRGWWg2VjFXSTEvR3pKVVg4bEhzbSs4RVErWFMrL2g5QVhKaGdKQkJ0Tjc5RlYwTHVmSFpBY3VTMVVKeUJlYzBJN0xxMzlPcFdzdGFjc1haODcvb0k2ekljb0czaXBSQVdVWjY2MkY1anN4YVpxSVpIclIrSW5KYmVVOHlUTHN1TmZaVTdmd3hHRTAzNmxDOE1XUHBSTVlNZXQxS2o4Uy9zM1VqWlVBZjMvWFdlVkt1ZTdKNzJ0SFgyTDVTZEJYT2o3TGtWMUVQWDBsTjI0dEkxWDN2am50b1BiTFU2dFpLcDhuczVjdWZVbndwSzFjY1JpSzFPS3Z1NGtONU4rekppOTVQNXBQdWQxSlplNk1JN3p3aGhDeGpsZUZ4NURianFiSlBONVhvMU5OYXhyTFNvMldvZjl0UnhzSVBiNWFrcUxTSzR0NnVscjlPdndLMGlyMzdiY1haSzJhRm81SDJHWFZMRE1ER2UvK21jVUVqUlZiYis1bmhBQzZVVWVRL2pGclN2cEJhQzFFcldScHE3WHBEWnlnZE9vTUlQdE1JeVlrK2J4aWg5U3puVElzM3NqNzV5ZENya0FYTURyQ1E0UmswbFpiTEdIbFNaK0ZOSndoNU5Pem95L0JzRVJMaERhTW9NZmNrcmlmblJsNUNMbUZnMnRFVEU3RHJMeUxTR0swcEtIa3o4cVpicjY1UEh4K3ZINmF5VjVGNzR3MjQyL1RhN0J4N00yM2ppVlkyZE8wMnJKZlpncFZpcUNhZkF1cU52RDVKYkt4QjRoa21JNThWMnlsSnc4M1VIcytqb1VzT25yZlNSbW9BcmVRV1JpMGV0Z0VzK3ZYM1phdHNwYUVyRzllemMzd29iTElaV2NIV3lpRGtxcGVOMVcrM0tDc05qMzQvMnhkeXNraFhGcFRGcUpYbnMySlc1RlhtdHdZdm5nbTVnTjZtR0d1NlhQMjNsdFh5S1Y0bFJRTXE3NmxpdmFTMndvYW5nTXl0TElDdWpOWlRDZVR4WktXalRGUzMrd3BkQm1TczRmZ1Z4N1kva3VGSXprZC85Ujd5LzNldGlKN2YvQkpKM3V1Y2NmKy83MjlmQm5tL2RrNHZ4Zm5JTW1sajVwVEhWNVB3WW5iTlR0WG5rM0YrMVppeXl0QXJ6ZTZMOGlWR0xmZU1LUEU5ZnF1QitXZmNGcW1yY2V4T0Y1QzZqN1pqQXM5YjF5OE1TTWd0aUVZUmRpeFgxTHhvQktESnlJZjU0ZEhQMW5sL3J1K2wvRDNUYXlYc096OFNuUkFWOExyZkNqKzhnNUtrSTJRY1BzY2s4c3RqNi82MG9DWjcva2V1M3lRY0w2eVhLcE9oMmp2MjVHdTZTbXFMdE5ZZGU3cG8zdjM1a1NXdUY2dGJXRTN4R2pMbGxlZndFWEZWbVM1TG5yWjJsMGZLUlFnaFEwVGROT0w2UlZMenV0QmR0T3ZWQmV0NmNXUzAzREhzWnhwMldyWC9yNm5LKzBOOUpjRkxUb0VxM2pWZlNmaXNxU1d2emp1VEdlNnJkYi95dXBVL0pYelZ6cUtuYm1lRWRCYm9mVVhranRibGpENGtaeXhvYUpxTTlMc1lzQWdkUmx3b0g3MFdvUnljWGFqck9kYXhKMHRLdlRZMFhHazFMSldXQVcrVUpXczllalBVKzBORHFTMGJZaE9PV3ZZSWtmU1dGVVVuZXRHUlg1SnZ1YlV5emtKKzhkWFMxWE5kczFBOTdkdXlGcGJPMXJFR2FqVmxla1YzRWNjSEZXSjhtc1kxa2JQb0RTeFg2NXlsSzBCVTVjQTBhQm1XQmJIU2FuTVd5M0o0bHQyelh1Um1vQk9ENkVTUkROTmpTMlpYdnpWUGt0UnpvQ3pYUkJ5alNodEJ1cG5oY0wzdzNzcGloSzY5cWxxUnU4d2ZYU2NncVQwZFFxWkpaSmlWVmF1dFJrUmkyQmxsQTcrWWlpeDBrTWR6NVN6UjRZSzU5eTJReTVFamZHUDlrZlM5ZytkTURCZWEwenJ2K2hsTnVxSUdGblJvZDliUEdJbVFaYURQYU1sdDhTd2tZclZIcjJNUDhLTzJ2QmpIV2VpYzRSL1E1V2N2blN4YlM0Yk00NldiUWVTbEREUnZWTmNLdkg1UW5OeWxrYnNjZTlySnNiMzhJVTg1dFc1bkUrbGI4Z1drV1E1clpnTkdYNENTMTdSbGZHdjFZVWFaMFRxTnlLdkoxWC9sZVcyY2pwZWhGTlNtL2ttZGpxditlYUNxVzQ5alp2a25RczVudG1YdzQweU9sOHZRZnIzNHlYeENWMXBZdnJvNVowVVJZVGtjeW9TUTJmaUJSQ3o5U3QzeWNnSE00dGxMSitKNDlmSUdPdnVkalRZajA0NWxudnA4ZEFWenhXb2xpYkd5em1ldXBOeVpPZS8rMzZtR1Zyd3Q3S1JIczJVbHI1V3VPRHJoWnhvZU01NXBvTFRlMHZXUTk5MWFuMnZwMU03M2VJR3IrRFp2Zzk2dlliRS9mYjNqcVVSTTdhcEhPcjFwTG1aMG5lZU9JNEx4TkNIWHMzS0pwUmU1UitmRzIxWllyeVVSOGtrNFR2QlRaeXhmaXhmVVBIMXg2U1k4UFo0RWY1aEt2aHE1YmliUFN5WWFKbVI1OGRZTDd0N1RJeTlkUzk0VzNJcjNkR29SMXZLbEpaSThpSWpuWWtBUm8rY1pTaDE1MSt2TXFhMWlack9nelR4UGQybG96K0t2ek9PVm9sVzZERnhYZEdWeHZVU21UY1VwaTNkZjJTa2pnbGJIUGF2WFJwNE1sTWx5U0M2ZWJPMzZzVDNLcnE2VGtxYytLcWJrMlh5dDN6V0dtam1rNklkd3ZEanhUT2NDNEttelhyenlMR2JzTnVSeW1LWlZuaDlseGdzUXY0bldnTFY2WkIwSG9vTWN5YVBKdU90QW56azR0UHY4YVJOWVUrVjM2eFl0eWlESmF0NmlLTW1HcXZ5U3ZmbkdYR21lUlFhdlIyTWZTUW5JN25WRW1zM3dESE55MHNrMFZzelRqb1hHUUdSYlpSdTExR2lkK2pHKzFXL2JyWjJObzd4TEs3LzJZYjAwZFB4U2FxT3QvbFNwdlArQVgzcFh0VEFJNzBLV2RQZ1UzZUhUZEo1d3FTc1Iwb1czSkpyRkdTdmRHRDFTWjVWRTFvQzNUaURUdEs1Ym5MVVdVZVU1ZkJrMTZkY2xSVW5qdnB3cGRTWU14RzE3NGJJWFJpRE41Ym5iWWw5MmRhVmo5UlhyL3BMb1lhMHdzaGlxRVplM0xSa1YvWGlYVHN1ZkROMm13a1FJSWMvQkNnVTJsK2tzcTIvWDYyVEZVYldiQjVWakJIUHdKU0lFTUpJZGRSVkZ1WkNKZ3JyYUFxVEp3V1B2dkpYR21nMG1KVTFMVG1ya0s4bGZ2VWlnRHJRZVZ0S2pzemVhYnNsTG9NeG9EQ05sdDNScDdkRUlJdytnWlRFdnl0aFFHYi9aRUdiVlU3U1BJZVA1U0t0V28yaHJaWkZvZG1aWkJrWG1WbTgxN2d1dTlFalBic21JcG8rY2o2YnB3ZldLZ2ZNclFkY2FldEo0cTBLb0ZZMzBxZDc3OGZwQnJWTXI5eTZpMm1leFpJZC9wTnE2L3l1ODlJT1pZYTZqUVVFS3BFZWJPK3ZKeTRuZHhhdksyVjQ2S2d0ZFBmVjBqWGdoY2dNV2hHamtQbWdSZkVyOXpWM1B1ZDh5czVGUVhQZHNEaUV3b3dzY2diUldmN2Y2ODRnZlRxQk16LzgrRG5RNjVFMUJJK2ZKVkZUZmtlWlRuT01WSWMrdnRrcENHdHl3dTF5eExIYzJsa0h5RE1qSU1pOTVFR3g0NGpDdmkyeVdLUnZITTVrb0YzMU9jbXR1WHNlTGROOHBCcWpMUXJQcndBbzZqeXVIY1lPWno5M2FXSDVvbGZXSVZIaWtERjdVYjUzcjRQMkRBbUFHVWVUOWFzdjVWMW5xR1M5U2pPb2E2K21IM3BUeHZNZXJTQithalRjYjdTbkRyREVUTll6U3kwZnl5M3J3enRmWGVtV2pJUGMxOGtodTA5SFMzVlAybnZ2VzdOTnNIVnIremF4V2NrcXZiY2p0eTI4eWtFYlUvU1BtUStTSklHdWZaQlVuVENMT0RCTjdYYzRabkZFdTVOM2FxS3NFMklsc1RBLzRUSU1RUWhSNlkvUk9vN2t6ejU1dTFFQnJVNW5XMGxHSC8wRm5iaEVWbzdQQktFaElOUE0rdFNkNEVhTDEwOU84WjdjQndwM0R5U1dJRzY3M2tmbnpCZVlMSzZQUFpLeGNDNDRhN0FYUmJlbVVhWDN5U1Uvc0hQZWV0OUpHTEpYbG9DTHJzU2l6TFZUZG8wZnZtMXpIbFcwd0VFaVJOaXRkeDJqNkRLVE5NWkc5YVZma0o0U1FYbVpINE1XNWxwc25VdCtrbTVBYjQ3MVJNanNpWllSYjBUc2w5OVpsQ1psQTljTlVyV2ZTRzVKQkJydVE5VHlyUGk4ZEdhclNrdDJOOVFDdFIzbHBuLzdqMUxjYnJkYUlSKzVsZW4wUThpMTRpM3NGU091STdCK2ZaMGFRMnJSQ20yVWplYjFqbWErVnB0WmRVdjhyYm1pNkZsRVprUjl2ckpyV2FUcU00OE4yNkZrLzc4cDlDNml1ZTNXUUR6bjA0L3c2TGtMS2ZDL294VEFTUnVMSmYzRENxY21lWUJ5NXUzYVR1clNhV1R1ZVUxd3ZPQitWczdHTDJ0T1l6R2orRTJjRWgrVDFTeE5iR3ZsanAraHN6YU00TWtyaldFdXZ5VVRxSlhaZldmZ2h6My85L3NmN1d0WTk0ejVEU3VhWFU0M2oxWkZpakZiTUY1VXhPaVk4aDlRYTU5SDdRR3pHTEpzU3ZhK2l5RUJrb3N6cGdkbVpQK2cvelA2Skk0OWpxeWovR3FYOCthcHEwV0preld5bDVBZVVoM1JSR3hyd1YzTWRNM2tvTFl1QjVObm4zTS9hTUc4clBlM1ArYjNPWXVadlhiZTBibEt4ODhrNUgwM1QwbWxHR0lDTXVoaWxjVG03MlhYZGVmL1AzenFLbUxSa0pXMTk3TmxJN1F2V3RkbUxOSTJuUzU1dlZYMXhaQ1JIdGlKeWQ5NVlvdEhTRlpuR1NtdDFMVm1ZZk5SaGxzTWIySWJNN0NRcmxoeE41NXd3aEJEeWRLenBrWlVPZGQvZ0ZBMHhXOFZSQWVXcjNPOXVmdVRZU3VsTExCZFJuNUN5MzdkN2dsMUdYSGcwQXB0RmRvNTdJdFQ2V0xyeE9pd2FyWHF0Tzg5eXU5R2hoY2hLanN5V1RpMHNISW40cmJUSVNoSXFjMmpHVXZSNE1xTzJRUnhMM1ZZK0pHMzAvQmpJV3VGcVhkWjFaeElpbjltYUU0UTBVSGxSaXdVNndZT2xLcUFNaEtFYkZsZ1dQRkxHZjlJY0N6M1RhcDZCTWZFN1hFZlRvN282SnFPSDYxdXkxbVI5QytoeVRJWkxCcytSYnF6Z0pobm5Sd0sxcUlOT2piSXNBUFdBcU0vM2ppTlk4VVkwRGltTzdBTGs1UWg4Q0dnUXpnYS9GYU5tdURlZkZybkpFM0w5QTdWSDdHS2tHeStPUUp4Z293T2EvYjdpZjYrLy80ZzhVbndybkxMR3dzdzQ0cU9KTHZSc0RXYWRKeVozbm1GN0t5dEp1VzZ0SU0zZ24wUUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnakE2NHVwclIyaCtETm9Fc0Rhc3FDVlhra25mNFh0N1hTSTdGeUtiUEl3QkRKVWVuYTRNdEpaSDZETFJoNTBNeC95VU5BTkp3bk9qRUVGMWozYVBNY2QzN0lwNDdnYmhyWC9oWGMrR2RjOVd2dkpvYnRodHRKNDViSDJ5OXN1V3p2RlJuZnMxQVpmdEVYbGNZOUhXK1FGc3pnb2dLTnloUmx0OGs3VDJxdXdMZGxPZDU0UmpHajZTTk5zQlhGZWQwYUN1ZDQ0NnFuTU1KVW5vdTNDMUxLUUdVamJwdVZuZXVrcG5XYTdXM3UrV1ZpKzB0c3F0elc0Y3JMTGxSclYxdklwcjMvbmwwL1k3Y0NPMU04TU8yM2ROMnBra1A2Q1RuemJjVlUyN3Y5d05oOGxIQStrcXFJZVp4SGpGR3VYL0NwN3J1NTN6SHg0WThoS2o0RHVueGl4S3EzeVJSWUFzbE1XNzV3bE0xSjJMM2FmRWFHZ01UMGlEODNiYmwvdGE0ZDVGeG1XWk5lcDEzZms1ZjFZK2lmblhhNzZDNmxGeXRtWnJXeXJMTVpXdWttbVN5QktHUTZJUWpBZUl3QVp1bWFQMC9TNk1odXB5L295YXVuUzdmbTBKSzVINHo4djVxdlRGT2M4UWpIVW9QNER0ZU9ndmxMWjZ5MW1pYXF3UUNZbDFubTArNklUb0lCTGZMc2RSV1FyZlRQTit6K3BMWHdnakRDZmFWajM2YlJ6RWY4b29udThyL2VHS1lRUXNvSGF1bWdZMFpxQ3lFdkNWNWptT1dLbnBVekxMNEUrNzdBVXNkbGxaeW96ZzU3VkhFbHYrZEJJVUpaQld4cjNtcS9IaGRWVFRyREx3WEpyZWxZNVVCMW8xSW1VWWNWdzlvYU9GMWFoWVdZTGRQYWdwVTlLM214ZGVGMnN4N3NWeTQyR1lQY0oyZXBScEJGZHFJbXNTNkpsRWZNbFQ4ejdlckZWaDcvZUdPM2gxZ1NvY1gvZU13MVZub2MxZ3NPanhFay9RN1pWbHpOSFMzVGVQMnJwSTdxaTZWcDZndDdnRU13RXg1cUcvSkp4TnpPOSs1ZGlkZWVJMmJkTWlYWmRrK0V0NzZYa2w5SFRYYWRUYUkxcXRDcTgyNXdKNGxXUWZGYWFWa3pueWVSSWZCaldPR1NEM3dva09oaVpKNFhTaTVCV2hoSHNNbVE2WGh6aE9mTFdzeXRMbDhENk11cU1jT3FNV2RBdHNXSzdqZDVBUy9Ock5GQk5SbUpheXcrZFVlWGVOR0NGYm40eGxSQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRVFPUi8vK2Yvdlg0UTI5cENKNmRmLytMUG9JbkEyM1FMMlpVSlZKSG5pMTZIVmk5bmJBbDFITGFxcmpOM3B5SWZ3SzBIMDgxQk4vMjAwZytva2lyL1o1eEg1SnpmN0ZZcHREVFIzVUMzYzU2RGtua2E2ZHdkS21mc1h4emRIbEc3SnErZjFMSTdsVlZaUWp0N1JucHNESCtZNXRmeDNMb0MzREhVK2g5dGx0RnRmU0piVWRibm83S2VCR2krelBRTDZiV0VQNXUybGVyOE5qNzkvSDFsaVBnSzFNbWZNV2RHWjBoUmVjblBiMzFaRXhHSmx1T3dRM1RFejNwV0U3bmUwdVg1WTF1MjE1T0tsMUdxMnY1Uitkcy9INmxWbGU3clZKNjIwcGZoWGJwNzZObW5HTzN2TSs3SFcvaEEwaWRIUms1WU5ERExibGt5dlRMTm9JQzZJN0w2eXRZVHVSWkQ1L3U2VTZSeStFZnlxenJzRkR2NlVxOWo3VGVSNUxIc093VWFSY1c2U2s0eWZxeTFvZk85T2ZOQ2IrYVh3T3RXdW9qT2FMNmVBVHhyRW1MTmhJV2NwcnZOdW1yUEZhTE1hSXFlWmdabEZpdU1ib2xXeXFOOThRb095YjJCUFlIb3l0bmoxbGdJSVdzWk1ScTk3aGpKYjAyVHRPdnBtTlowaVlyUGdHL1g4QkZ5SG5UNHFCamdHejdSVHFOK0NhVTFIZlJrUjkwdk1oV1ZNcTN6MnpOSzYrc1lLNGxFcGIzdE5XTjFjaVRxOThyUXU2Smk5aGtudHZPK2xGcUFRdlQyMHhpakJ0cVRQV1ArdURHeW1HSVlZak81TVpGUXkrS1ZJVElDdGZSZUN6dnp4S1pzbVRiZWczQzgyVWlrdkJwakk2R1BWVHFEL2RydFE1SVo0eDIxSFlHeXlJYzM0U3BGKy9FVmZlVWhqQVFEV2lDRkJDQ29qa2dRMFdtV1IyOXZTdnd4QU9KVlcvbEdyUFRzWlVpeW1HaG93d2E5TFJHN0pmUElmTE04ZjFPNUVNSXVSYWFEeGpMSlNPZXQxeWx5ODJCSHRwWmpVK084WjVZZmI3WlJnOVZLVHdQVXhlZ1EwOUtNbHNGcTNraW9zd0orTVpVUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEVEa2YvL252d1habGVyWHYvZ2IxcStsWi9NdEM3K3JRU3JSWDVQUDJBOHRUTS91QWlNN1hvRkZpRzdzRmQxY2dkeUUzczN5Mk5EajlOU2hVZmV0WFMxYTU3ZHIvMVBTYXZKMVp1MHRnKzY5Z1ZqMDNuM21XcktOTFg1aDR4ZXhrdDYrZ1ZwNmpkSDdSblQyZG1SWmhKSDdHK2VucHZMcnVMeU85OWV2Z09aV01ERisvSG8rS0pqcktkSzYyeHZaR216RmZtdWpmbmhrbjFvVW93eWxzUVAwTGw5U3luUkdSMFgyeDZ4QmVsM01RRm4reVVKTDkrZHJjUEt6SmlLWDJ1N1c1N1RFWjB5ME12MzlBbDFwbERPNWQ3Sm5SaXhucGZNaWFBOXZETTBjVTcwMnBGV0dxTXd6Yk1RS1cybnBURTFkZHYvVzVPU2RwRmxXeWcyVGtlNnM1VVBTSVRxN09hT2R5Uk9KZHI5K0x6eEtKSTVBSnpsbzJsNlF2Vk8xOUpJZVh4SFZ1Y0RmOW9RYmtXWkdkTGFxSVFOeUVGVkM5dUg4ZHRtN3J3bk5QTnFyeS9zL3lmMGkzeWpuMlE1Q3lOY1RuYUl1V0N1VnZrSDl5a0VTcmtCeHh5MWZncTVpV2U2bTU0bkdDS3ZqeUUxMjZ3dWlMVGY4WkQvbGhWdG9GTm1qbzc3ZXdnc2pGd3hUTlgrTFVQVDhTZ0N2MWtRcXY4cTg0Z3NxMTJLdHVVWHlJdXZMNlBYSzRCN1c0UnRsczR4L1B2ekRvTWRDUjljclF6M2EwRFUwQ3hHeUl0Y1IyWG1pVEptdmdEcGxYclMrNm5Ub2Q3R1JlYjZWeDlMdldhN29XQnNva3l0YWFkL3NwWTJPR1V0T0pBOFpwcmVxZTRhUWxtWWsyQUdMa0RxSzRzWVpScm9Jb3habEpEMTZmK1FDSXVGWGF6S21NY3Rja3pCbzlDeUplRWFyeThqcmtXWldYNVZKN0Nya0JFYW1uREtOY25ybVRLMW4xaUR6RWtGazJzUktoSWhVYVZMU0lDc3FWelRGU3AzOHRTa2hoQkR5RUQ0elh2eldLUGRwSVNVaGhCQkNDQ0dFRUVJNDl5YUVFRUxJRStFVGpmTmdORW1tdzA1RkNDR0VFRUlJSVlRUVFnaFp5SysvZjNwM0R5TmZ3WXl0UmJROGdNcklqaU8zNmNXUmhmMmVqZHNBTVNOMEZvSGNCVy9iSGpic09MMGJNMjVwaXBNbTRXWWt1a3RUVWY1MVRKMTNaNHVwZFhSckZXUnZLRXNINnBnMGVVVWtmeDFuUXpmMGlZbGFaM0hLcFIxN0E5VEwzOUtOZ3BiSk9DKy8zTmE4SlcrL3NSYllmVzZwNUpkU3p6S0dIUnRMUGQ5Y3oreWV2VHl0Y3IzaGVjUDc3Q2tTYWhsamtyTHhieXVQdDU5clJIZWRWeXNUdXE5YzcvVUptTzRaQ0lZT083aWpXd05iaGJEU0l1MXQrVmZaRnExQlZRSzZiVm5XRjFTMXJ6ditPWmYzZWZkZlZLMjlYMG5XbDFLUGZxZmZhQnpOVVJibjhTajFpQmRBQS8wTzBxbTF1MWJ1MW5YVW0rZEdPaS9XMFdKY1RiZEh4THFPN2lVcjAwWHRWS1JNZXQwWE0yMDU5UDM5RjFSajA3M2Q5ZGRZeThJMkhqOVVVYzlQY2wwMHZ3c1Z0SkJsWHdEckJ2dk5RRHJGLzVCSFlIbmJIM1NmMkpMbDRWdmxMT1FXNDd3bENiRlRYdHdSalcwUTN6RnpMY0l5VEo0TUZIVGRSMEhHT2xFUlBlYkxDeU1pTXJUbUJIalhmTkd6SFQ2SVpNZ3REUmVCdUpWZFdaS1ZJYW4zVlpEcGtGeVdTMDdadkRJUlFzaHNMSU5rMmJOb0dJRXNSWGhUc29ZeDNKWnBOQnRlR2pLOHJ5QWVsaUtrSEhsK0FsNVRyTkNGVHRrMDBGazVPdjA3Z3hsMXJOMmZGbVdPdEZkMFpTaTZxaE9SSGNVcVN5VGZJYThSTDFwQ0R1RzFVWmhTS2Z1ZFZudWNhdG9DWGVSSnpCakJkVnBrTHVhZFI2NFhQWW14OW10ZU4zVVYrekRYLzFCN21TSExDdks5NnhGNlIzd3lqcE54dlhYZlVkbHlyYm5IWW5qOXQ1V3ZwSjgxWmlzUTBlNEpuWFVoWTBMcTdyWElJNVk2S1dWS2pUS0owL0w2dTZpUi9pekdGR3drZThlUU9yQkpGQ3Q0a2RkNzZRMm82bXVHNlk4V1MvWVliMnFDZUFndFgzMGNLVmZVQzN2eUluQUUzUkN2SVdlc0FjK1FTVUtnMFVkcW5EL0llSzJEUkhXM2lENTZSVzBsSVdHaVU4NUdKelRDQzFjMEd0RnJjUVl5eTRuRUcxK0hOMlVsM1VTZVNTTDllSFhmYmMza1Y4TXZwaEpDQ0NHRWtEVmNPQVBrNUpNUVFzaTNRaDlJeUJnY1E0U1F6NE9XaXhCQ0NDR0VmQ2FNWko5SlpzTVM4c0Z3QUo4SDY1cVFFVGlDQ0NHRWtPK0N2cCtRZTVQLy9aLy9WaitHdFhmRSt2VXZEdWV2QjkwdFllSFBxMGRFajI1S05SVzBJSzJmMlJ1N3QzajMyYlBiRkhrQXlHNFl0eG9rSDB4cnU1ZmdWaFRlN2k2UkhhQjZXVzh6ckFyUzBpQjc2bVRnT0NuNXRPdGFVczhaam5xcXFJem93TzF0MFlCRDZyWWw1L2EyczRudTVQWVlrRzJBa1BSYkh2cXBmazZvdXpQRERYWUZpNEJ2ZzJXQU8wV2I0bW9mWVV4aVhCMFJLNXJCODU0bDd0R0JYZis1dTcwT3VGOHJ0L0huSzQvU0g4dTB1eUxtM1hYNWRUanRTM1h5NjZ6OWNZaGtSdndVbFJueHhGNThXWitmaWRmSFdublEvYWlsVEcyTW9ESkdiRTN1dU83TGxtT3RoSFRxNldiSGNKQ0ZRZU9wR1NiUm9nUnRmd0owa3E4RVhlZlFaL3M1V1Y5UzFidTU3dE5hdm00OVBiSE5hbnJYSW1vS2VGNGN5eml4eC9aN24yRUtpZ3U1K0JIN3JPV1o2SVpidTc3TEhkeFZlWXBNVjdkb1hxdG5hVXRzYXBrYUtyenpDSFJMaER3WXd5NU5HZlJYR2c5dkttcVU2MkE3UmZxaEdibHc2VkYzak02MEk2czVXbjZOV2QxaGxxd1Z6SDU2ZE1iOW90RmtWR2JIMEduSzAwRDZieSs5SzZGZFNwS3ViRGNPbFVldHBaSVIxcjJVbFhNd0w0aWZ1VDVwNmR4T3l6bVdETXFMbmo0cDEwTnpzNWFGbmprSjgwYVRNMEVLbFduVFZWNy9YakdTVytWcGVjY3JSMWUwWFJGNlBkVUc0aVhRdFgwdFgrTjA2ZWdUT1RvbTdtVk52NUllQjR6S1RBM1pubTZ2RE9LOEY2TnIyVmZUNDUxSGw4NUdkY3p3ZU9SRXZNbW5kbDVlOThJTGNobUlpZFR5RERVM2FwZnR3emUwSFdRNUl3czhTaHlCek5qUTY1NnN3QkQ3WGhpSW5JWlgxVE9tQTZodU5NK01PSG9FZmpHVmZCVzB2NFFRY2pldXRNejBDb1FRUWdnaGhCQkNDQ0dFRUVJSUlYZUZUM0lJSVlUd25RSkNDQ0dFRUVJSUlZU1ErL0tMQ3lnRXh2djVOYnBWd1lUTjVMU2llSnRSVFZBN0QrdG45T2IyNFFweVU4TWs5dGJMK2ladG5rcnlVTGhMeGp5OE9rUTNEZDNTRmorWmQ5NHF3dGpHZmVYMTMyaG44ZmJXMEs1N3UxdEdMVmFrRWF4a25yVWNzYUxXL1ZvNlc4ZmUxa1pTVCs5OU9UdTNaaWtqNHFHbGptU1V5VXRuNlQ3bXZlSUxPYkptWit4bTh4R01iQUVuYjl6cXJ0YjFiOE83L3d1Q1A4MFNJSzZ3dGVPb2R6NWVxak5acVR1eXJ4eTZkNTNsbjR6YVY0dVFHL0kxVVpaeDhIcENuVitUMGZLWm5nNk5scy95ZFZsZlNvVTMydHgyTjY1VWxmelhIeC9HbFBINWt1M3JxdFp1bjduczIrbDMrdnFycWtXNXo5YVg3REFpTTMycmY3ZlMxV205dnVRUlNZODR2VHJkbHJiSFR2Uk0vQTZyQ2NrdWs1VmYwNGxPbkN6ZFNFemZscDJOOC9KYUFXVDA5dXo2UzhZNTU4WUhLSXBTbnB5YWhiRG1MUFVXNkhXU2xqTTkzS0NRZmZpU1JzTEJUQ1A1RXRBeFZkUnphenFSbkI5bVlUMks2WWVLYzV4U085STlHODhuSW42NDVUTmFPaDE3cGFZSGRXVGp2dEF2a1hoaGhwZTJsZDVLMTZyU3FDNmpxN1UrZ0ZTSGhhV1NrMFU2cThlNFpWRjBKbU5hb1BVb2ZmenZ4VmdSWFFTNkpVSWV6Sm51MTV2K0ZEQjl5LzFhc2tDeW9YdW5NaWYzYTl1N29wVDlYL2tWSnVRMm0yV3QwbnN5UE5rcm14OTExOTZxUlFIeTlzeE5vL2Z1NllwT0ExdjVyRzZlQm5RamNVUlJ6bXR5Wkw3Nk9ESjhyZjdhS3FOMlhzTUtJNjJJM2RWaHhaUGxLRWVOSnhNZUZwL0RxSFZvNWJlaTJLak1IZ3ZsNUpGcndVV2NmNHNSRFpzMUhadHpLTHFNWTBhanJOR2VqYVN6OGxrajFldWRWanRiMTdTOEVSM3ROYzJmOUtqc0VUeUx2TEY5OTZTbjMxcjBXdUxrNUt2bFcrUFU2MnRHM1IrTXJoaHprR3dQTkJxWTBlZklIN3pnUjdzK2N5aG9PbHBteVpIeHA3ZDNOSGxrWlJDVkpVRkh2YVZMV3psRXkyQlZyYlVhS1k4NWlqNk1rVEVhZGI5bnVPc3ZwY2M4VzNZTHRobHlIcVM1ZXVzODJCYzhUMC9JTUphenM4aDQrcWhwUlBKWjZ4cFd1bWhVL0JobVRaT1NrbzhHNkE5SVNENERKTlJ2eGF3OW5OWEUvR0lxSVUrR3pvSVFRc2liSzUzQ21icnAvQWdoaEh3MzlJU0VFRUxJRmRBREUwSUlJWVRNaE5IVnM3bWlmZG1uQ0NHRUhLRjNJSVFRUWdnaGhCQkNSc24vL3M5L3F4L1AycnMyL2ZvWGY4TktCTWdXalpORW96L1lYL1hyOUJEYUxnTFJIUXBhVkRmYXMrZWF1WXNMa0pjOEFEYndmR2JVcVdMQXp0aHJjbzdVSGd1Tjd0N1lzOGNPa3NkellIWFNpQUczUE5Hb2h6clRRZy9xMmpXRmNkOUxieU8vVkJUbDdNbEZDZXA4bkIrMmhuSFBCc2RlZmdZeE9vajVPam1BbnJreEpiNHoxSW90dnJ4OTJGQ2RpRCtLK3NTV2JHdkdFUFhMQlVzZUlxZTlDczlhSWtwNzRvaGVYVnFlSG9OWHF2LytQcXY3dFNHVXVhUUgraVhVbzBucGRRSWpuanU2TFNCcUxCRjZ4eXRLWk44OHo0Yk1zSTJqOTR1c2FIam5MVzhRMDF3VTJaNkwvREZYWlgraXlwOFVHZllYVkZ0dFl0UjFKQWFDRjQwTWxhVXpIZmxpc0VBejJtWGExcXZ0cjdLUkUvTnh1VXAvL0plV0l3a3Rub1pZZXBsMzFVUkpXOC9wajNHd3RKMmdiaW15bkpYQXRHTnVhVTc0NGVRdjBlbEJoMXRDUVR5OWRsMUxnMVk5M1JNaHBNbUt1RnBMbjhDOG96bzZ3d2k1dEwvN2l2WXJuU3RhTHU4ay9SZ3RHcEluTXZ1TjZoNlIwWktOUkZjejZ6Q2F6eXBEOVBvSU05c2dHaTJQRGltTDFxcEdkSFduSjN4RWRabm5NeVlmU1BvRmVDMW5yWVY3enhjV2pEYnQ1YUdNOXVSdXBZb3NiNjdwVFZMaytmODU2VHdpRXlSVTU2Z2xqK2F0OC85UE9UY0t1bWc0VS9hSy9LajF0Tkp2YThPR25OM1lTb1lNVkZjQzh0RUNUOFZ6dkpHMUZsU1hCV0NXRUV1YWtoL2JSVlI3T2taNkpGcVZscFh1ZWFRUlhhY2lENkcxUmtwT1pWWVVNWlJmaE1lNXBhaHhLckxXemE1R3BoTmRaREJFUk5hdndGbndsSFU2WWpBekVDTWhvalBRa1hBanNrcHdSUmZncjAwSklZU1FHOEs0Y0NXczNmTmdYUk5DQ0NHRWtNK0VrU3dobzF3eGlyNTE1Tkppa2Ntd1N4RkNDQ0dFVElYaEZTR0VFRUxJR2hobmtXbXdNeEZDQ0NHRWRQTnJmL2o3ZDdQMTc5Y1g3TGhHUGgrMFc1elFoVFlWdDVvVHJDNlVzbk50aXFnc29kT0VrRE1vemNOUmNaT0licVVpamVFTTQ0anNvVFBKQUJmTnlpSm96dStlTFhxNnJsTnVvMEJuNzdpV1NEK3NnRllLSzY5TjZidzJtVm1xU3ZEOE5UTUdWR2Ryd2pSYVk4Z3UzbFlaQjNWM3pRTzNTVTUwZCtxb2p0NnRpdEgwTVprL2tZM2x2eWFNbkdnSU4xQ08wbkVsVW9xNW9QSGFTdHZSRzErbllENmtIRGw0ZmxSZmpXV2ZaQm5tTFRKSkRURmZnYldiMmFQK2ZDVzEvUG43OTNpYmVuVDRxMGgxOU1aVnM0Y2UrU0xXZEo3MlNDbGdkQlV2Vzh3bjk4UWJLK3BydHYvdHNjZVJ0WlNiWUMzcnRKclZ1ODBlbCsvSm1ERmRrTWZGT0cvUkdXZGFubjRtZEYrRWtCQXI0dXJlOUNlRUVRZnovVExNTzFkUWhMM3UxREhDNk8zM2xtRms1UWdCRFNOR3AyWXo3Z01OY1ZZeU8rUTVRNmVVZ2F5czNHV0ZxRW1ya09XMXZwRnVGZGxmQ0RpQ2kzc2luUjdaYms1QXY1Qm1ycy90c1hwMGNhNXIrVmVBUEU5WjhXeGoxRnA0NjdBanpQYkFNMlgwckVWNEUvOE9IUVdwbzVsdFFndDhDMllIWHByNU5iclFMRXRZRE5XZUo1amRBNjkrcElFc0VaS0hjSEs0Uld6dUVFWE1LQVM3RkxrY2E5b1E2SnlXci9kbWJoRjVrYkxRLzNZUW5UNlNibm9mTDZ4ZXQ3eGk3UHc2UHNsR3BoS0VwR1BYYWFYeDBqV3lqYVlkOEszOVpQRFlXMWd3WGpqWkdhYjhzNTVWWHNkMUl2b1VzZ01adHlTR00xNFBhU2ZZd3BIbTB5WUlmZkp5UjVxekxGSWtwSElHeFdaVVMyVEdaamsvMVBoYnNuTkRwc2ZvYXhobkdnMDB3Q2l1aEFSSStwcyt2OUtkYnh3ZmE1WjdobnZVSUVYc0w3bTBmdnBIY3pzZnFtTysvMEg4VzlRUFNXYXNFRVZuU3JQa2lpVDF3L2Z0RGFVRDRxVHBmM3Q3azdiZTBaS0Q0dlhnMXRKc012Tkt2NFRlZmYydmNzaXgxNTB6MXNkS3diUnFwZlBMalJxbW1WWUNjUjRMeDhZdzBmNmJuWFRXMlBET3QyUkhhSlhQV3FkRThtT2E5M2VUKzF4a2pwY2haemtlZjBxaEQ3bTgrd01FdDM2Njl2RHRrMG5JQUJGUGoxakMyTFJpNW53UXRidVJPNVl5ckh5bzcvUHlKU1Y5ci8yTjZoeGdOUHkyMHJUQ1NLdFpSNGpLd01KTE5VOVd6cGRHdWlMT0gwSjQvYlJaQktScUNTRmtDcjBHYXJac1ZKYVVsNTFqcjB5R3I5alozOXJtaTJXYzM4ZVdEN0NtUTVicTBRaENrOUc3WW9CRVV6MXlheUxOR08xS1Z2cUIwQ0FjUFVaa2UrbDdwN3N6VjNXaVdHWFdqck9SWjhTRWpJYU5oNWdRYlhCcnFhaWtuaVdTRHlYcUxPcDhrNmxmRnBMbmYyT3Q3WVlOdE96SmlBVkRadS9Ka0ZXdkFGd3h3alY2N2dlUldTYko4dlJFMDBaMXo3Um9vNVBzU0NRaDh6azYwZHNzVnJzaVhpTEsxeGpmY1dZR09hTk1NQm5tSTlkSmpEeVo2WTFUN3ZaSXd3aDVPT3J1eklyT1JKYlRPeDlPalh6TG9raEhVTlNzRTNJSzNscGhoNmd6OEo0akVYSTJpUCtwMHlKcndhTjRQdlRzc1ZOOU1WVU9ZVUpBV3FObHNFZlBXSlQveU43c1BNR29sMkgvTFBJbmV5bVlvNW44WVVKUVNVQks1elhCdktZNkd1S2NXdVlaN1N6T1d3MDdiY2xKWTZWYlFUUzhjd3d5ZkczR2RTdlB5bFd6b0x4MzU4cmRJckFNbU5BQ25sLzVnMVJ2Uk5GUFY3QXl4bGhoWWlZaHB3czFuOUhzZHd5a1ZwUnBRbXNVNXcya0l2OWh4QkZUT3NZZFpraFlIRkdjTXlIUCtLY05nSlNpQ2JZZm9NWituRk9jcXpNTVUrL2ptMmhNYThtWXNjQXhNbDU3ZGFKWXkvbmFqR0gyMkVGZVhVRExnQzRCNTdCR1MrWkJ3L2F5a2JDQjhoMmtYWmdjcldLMENicUdsdFBYU3ZDWWtDQ1JibXYxMW50M3c5NzVmdXZZT3ovck91SUxyNGlYSFoyeml0UUtJNzBtOGQ1MzFYUzFyZ2N3M05KT1J3R1h5TnlpYk9GbDhGM2lHYzgwNkg0SUlSQVJZM0ZId3hJdEUraXZjblhOOVBBRlZHWDVIWkhPaWlJaTd0cHpzMTNUb1RUSERYdjNHVGxHZGFIbkxYcmk2aG1SYlcvNjFtdy9Ha2VNVXNCek0zVm9mUXlaSDJWRU9Gb0lMYjZNRHVTUFo0V1Y2QlZaWXVmSGxBWFBXK21RVGxTYzYxbzY3Umd0Ri9yT3dGbXJFUzFydDVyUi9yMGlyOVYzNUhrMENvaE8xdXZMZ0k2eWxVbXp4TmI1V1doajZhc01kSnRva0ZNR1pIbU1tczRVTDhJTUM3bXFoNkdqOTB3ZERIa2V5c1QxVnpLUDJmWU1XWHRZRUpsRGJvWTJoSnpLeEk0ZWpRRm1tTmlWVVRNaFBmU3N1N2FlZzE0UlI2OGVTNy9zV3liRUlJUG5abzhla0kvcXhkYTZHWkpWM0tnMUlXN21Uei9yWnBHbE92SlE2QUxtTWpLKzB5eHNRNHpxR0xjTjF0VGVTOWNxalhVY1dVbk9NVlZ1d3BIQjQ4bEFmbEF4T29BSE9xeVVrZHVYZjBUUDBJbHg1UmRSSmVmZDlSY3o4bGJTazdoWmNPZkdwcSsvUFl2SVd2N1BqMjAvY0ZsdG0xaDRQMDdWV3NYYndiMi9VQWwvNEQ5RGQ4d2Z6K21ubFU0dDlEdWhLL21SbmxmWGlPSDIyaStLWlRXa2JobG5JVEZydEF3V0szUmE1ZkE2ejRxNmo2YWQ5Zmdpd3hycjQyS21hT2Mvdk12eU1wSEY2bUlwMmQzZEd6ckZLRkJMOWk3amhMNzIrUTZZbkl4dGpmVTVuTjViYzNPdTF6c2YxUFBsOTMvTG9WUWo5QXllMFFHSDVOZnM4R3EvZEVPOHlVYTBPaXg3alY1dllUU3JETThQWVhmVnJIRFBRaE1LMlpxTFF6MCt1b0xtdWo1Q0NQbk55dGdWOVJVWGhCRlpwRmM5ZkU3NkIvakVQeng3N0RFanVoaWRMbzNJTGs2NkVYclhTbnVpU1U5bmRGV25OSTU3eTR0R3JqMXhoRldtbFNZaU9XWHcrbGh6dFVvWnZ6MWpMRWRpM3Q0QmZDa3pXdGpxZFZFcllRWGlnYWpXQy9oRERYb1FuckI2R3VrSXFFWDJya2Z2RC9WRVNMcWV1dlh3N3N2elVIZmw2bGthWWhXZHV2WjI0OWpTRkVUMkxDQXZRV3FpQVZja0VKbmR6UnZObUkza0tGN3ZzSHBVVHcvcnNXS3JMWWJWdk5wOWNTUjlFRlpuU3NwNThpaThpTzZNS0tRVkxkSXJrN3ZUQ21tMEdPQWZrYjluaHVLRlVSd3pnbWdNUzhMTW5GbHI4YVFXUjYrY210U3M5a08vZnRRUU1vRHNxZHBzalN6RmF3SkNYTmhwNW5LTG1XUStGQ1RhelBPN3hjb3AvdkYrWWJxZkZYSEpnR0NnajU4Znk0b2Jacno1WmVpR3VqaXBQNDl1aDNROTJ5K3QvaFM5NVIvbE1rdWExR0RJc29xaUc1YURwTDJpNXlrNnM1OXVaazliRncxWjdaVWIybWUxQ2FKN05RT3g3WFJkM3RKbFN2MHZnQ0dzZVlOajVjekVJaVBWZ25iam5vY041c3RRazJxQzhSaFpUT3RoVGU5UXNmTkp1K2l0cll6WXZiUHMvVjM0NFB1ZFVXelA3RTU4Nm03dUdUTlJoMHREdGhmSlJTbmdPVUlJK2NNTUExRW1uWThZdzlGcGJ6bXEzdG5qN2ZkUnIyVWVOVy9uSXJjV1hUMHhDdnIyeUU2MjZ4M2FPVHZIbjRwVnQwdEN2Y2QxN0pWT29ETmY2Y2p6dnZ5Nm5zRkdpcVlQc1dKdGNCV29oZExXaWo5OVFIeWJ0em9KYTc1L1NsWGYwUU0vak1nQzVLckZDS1ZaVFZXZ3VlcDV6UEFFckJpMlBpWVBwaldldCt2a280a3N2OWZwM2FiWEVnYmNMYnNXdVR0SUNPT1owSmx3ekNpTVZENm5CeEN6VjR4YTYzWlBXV0hZK0tXZlB0TnNrSTlIdmcwa1J4TVN4QmZzY2paVWErYytzaGRiOWFHZEw4ZC9XazFRLzZOOFhLV1FLVmhQM0t4RlVmYVRPTTQ0ZmFjNW9XNnpjWVNwUmtPY0hvTWxGOEVsdlc5UXlPVkNlVjJlVDBZYVM2YVdEcm1HNnJUeWxXQStLYU1BTXFWczVNR2JKY2Z3d0pZelA4RWgvYWd1citOOVlieVdtMUZDVk5aTW5iY0d1ZEdvcmZ5YXluUHd6TmFGOVlTRUd3dzlvcXhZa3BnZ004dmxrOXhJbDVLNWMzdVpiYUhsdy9qdFhLOXMxRkRwNlZDZmdPVDdvMkhuOG8yeWxmcDZPdFR4MjBjcTFZRGNiWG5Mc0ZQMnRaNDV3MDNZVExpM3RqM2RFVWJHMW9xeDNxdnJ6TExVOUxSQk5pVDk5Sm10ejIrdGpQWkxzMmU5eGxiUlQ3c3lpM1doRnVwMTY2RW1zbTBBSVdkZ2RYY3I3ZDREbE1QNVBUL1hVNHA2WmptWHJHMkpMSlVtTXpLL0x5azJDSzlZaTVCV1U4WlhNay9Ma0pWR1BrMm1WZDYreTY0cXBKbXpvN3ZWb2IwQXkydEdyOHFyTXRRL1RpMktEcXNvNkxnc1hzaGZwMVgrWFpScnZhMlB1a3hDQ0RtTnFFSFQzRzZ2VGlPdlptK3pQTEVkdnNvZ2JmWEJKV2I5dWhVQnFMcFRlMVl2ajVHNHNaZW83dFo5U3BrcFlYN1hjL25KU1NkbFc5RW5BckpLSnlPNzNyQ3A5L3pFS0xJcmptako3SW1lSTJSTllZcUhrd2VCeUFCK0JKRVdiMFhPWjBXZVFWM1pHbzB0SzZWZG4xQ1dwUmJiT3U2UjBVclhzdUN0ZkNuMVdlSXltTjVMcDgzTHp5QnEzUzNETkZKMjBLQWRpcGI5N0Z0WDBkTFV6MlhjaGVNZW96dGpUQkEzc0pLTXhQQmVVTkJqZGtTK250aEc1cDJGNTMyUVBNbVFFYldZVzVwV0RFcytpSlVoQURrZGRENkl6ZyticHRRUUFrZDRnYkNLWFk0c0F4MGNhQ2NFRmxtOCtBSWR4L1cvVzJIMFZ4T3B6QlpYVHdNL21PZ2FtK2FYdEpsYWFlUkpqazRrVFhScU1vTi9FaUZSYXN2L205YWFEN0l1TnREcnY4WTJGdXlTOVJDdi9yODhieDJUaDJBMU5CdjgwZHlqZVhQdytBd0FuVFNPRHQ5UkdTdnYwdXBTN0dvVnJJZzFYRml2bGdjWWZXVGNmMHRYZHJJN2R2RGUyclR5aVJiT3l1eWt2UDUvS2pNbnA3UFREYktyOHRoOWx0Zi8zc2RsZjR4SXJHVlpWMzQwbGFZRWY3S0NUbVk4ajRzR2ZUTXMxa3k4ZXJHT1oraTRFK2o5N2ROZDBacC94bFJSeHBRd2tkaVhWQjNicVZWTFNkNkpUdEJ4U0VndjdmN1RNNTduV2NhVlZ1VGI0OVFMTFBXVkx2N0UyNzFpczBwUFpUYitibmxia1p5WGpoQkNib05ucUZyVDRKSEFCY2liV3llc01rMHVnMVdFTTl6ejA5NHh1SU0vdktJTTN4b0huTnAveTVYS3oyRFdtakFTemM0aTBBaWw3UCtQWlhLT1crbVFhTjFiKzBYb3JXTTBuK1dSZWdaQWJ6blBnak9xSWFMVkYxb01Kc3NaV1h5WXZjdysyM1hrbzRvUmlpTDZLYjJZVnBDUSt6SFRQRU9QVFRzTXdUdUxmRFVtRWZJQXFuNnR4UURrWlBwZWpiSFBzeUhERk9QLzhyb25RM0xGR3ZocW5iOFNJVE9ZMUZPTElRN2RqS29ZLzc0dDhvYTloNU9OVTFsc0Y1RzNvS0RzRThzUDVDQ3FDZm5EMXNmSUh1dUJYR21rQmV2U1NvS08yNUk4OHh5Sk9IUHd2SGROdTQ0YXhlemsxNjRsVUhiU1pacGJmaXR5L2hqZ3lNcUZkOS9vekdLVDBWcDY4ZTRmNmRCV1J6YnV1OVZNeThtdi93cG5LTTYzaHV2Y2t0aXh6dGVhMThpUVZMcWNteDZWL1FSazU5STYyWVYxMGJMS1dQUFBtaHJYOWdDVmVhYnVXYnBRWm5RSzdYN0U4ZHMzSmlOZCtPbDlPcFlCb1M0cnFudUd4ZDdyMnZyenp4ZTk5K2xLUU1kNzZPZTh6K2U0K2tNb1V4ZXhITXU0SlluY2ZUYnZCKzNua1hFNkM2QS9YMGFQL1RwRHgxM3JTNCs3b25kVnhCazBxajZVNWY4RzI5OXhXdW5RVEdYcUFKbEcvQm5BVmZ2bXJLZVRNbHRwbW1VNG83K1NUOGFhRjJXUktqZDg0MmpQeWlHL1cxNjl1WTRqdEhueU1kOVArbFk2TFU4eWRGbDBybmZJSUVCTjR4MTdNMTd2dXBZMkNpSzdVdzA2b2U5eGlkSGJCYWNSV2Z5amZnOTk1d0pLMWFyRzB0YzdiVnVsQ3VvKzZ1TXVYd2l3VWpZaDVBdnBOU3BSZHoxRGx6enR4UCtSelF5czMxUVVwMGgxMU9HNXowZ1VvVjB2ald2eU9pS2pkYjVWZFY2MW9sRmpxMndsOVhjeEpBOVNMNjEyS2dHZGFOZ2wrNUxWdDFxNjBUN1ZhaU8wdlR3ZHMrUzErbjFPUWFYYnRkeTRac244YUZxOU5BZlBqK2h2bFNHSjlaNzZjalVSOE1UdktFNlpXbFlUdFdTZTdsYUhxOU8xNkMyREpnTTkzeUpTRHJRZVp0SmFFdzh2Q2dhUWx0c2l1aFl4c2QyMWliUzhYa1MrTE1yd0xsNDJaQ0dSVSt2OG80enZPZlIyblcyb1JJWnBaN2ZVc2lHZW9TUWpReHEzem9ySTd0NkhORUZPOGZ0UFRocXJETllvU3lrOU45UjVHcEZKYUgwdDBzQTB1OVBwalo1SFBmNGY4eTJFREVWNGVmZG5meTJ4eTVBVEdBbC9rekdtakRnQ1piQklPeGtjUXkvUTZRRWlneXdCV2MySXJvWFA0TXhtTjM2WU92TjJ5RmRRajViZWlKR0VRSDFJY2ZLeHFiNEV0S0U5cjBodVRRSFAvZkIwZ3ozeC9pTEc4NXZIQ21NQUUrOEZDd0pRSnAwbkgwVXh6NHc4Nm9vKzJKKzEzTldqZXpXeVROdTUramlKOHdxL0g3N25vZVY2OWRCTzd6MSs3TkE5bkM0aVk0WGhLa051K1BpVlZIdjA5Y3Fzci93bE12NFFaZ1Fpc205RmpsY3l5Nm5Oc0dlemJPSVZiSDBrcTJmL012aW8wSGhaS2IrTzlSSklHVWlDWkNleXpQZDdrNEJzNndpWS9tWSs3RTRKQVlqMW80Z242TEdzczZ3eCtRRDdZSm14cDVtMUc1cHJaQnozUFBQZytDV0VUQ1UrUVQ1UGw4eUh2TTNTZXorZC91Tk9qeEh1VkpZWmZNSXNiRVg1NUdzcVdnaDNkVHVmMlM1TFFqeEw0R09uL3hHamlieDYyS01mV0xnNUZHV2xRYitqNWU1MVNJT09iS211TXl4VzlKYzRuMExVR0oxNDMveEM2cjFBRmhGNjg0N0lyck9KZk0xOUprdjFwL1VvTjNXVW8vcDM5Q1g3cUo1V21IRWxUNXN2ZkIyUGpGT2Z3NVZqeS9xbzArenV3dTVIUG9FQ3BqbWpQOVB2TnJEaXpBeW1wMEU2QmVUNTVwT2JRdnd3VlZ0ODRCQW5BamtpdEhlck83dU9KUnA1WnFiSnVtM3ZSU05aN2NhenNaNXNWTmFoVGpta3Z3dHY5dlRFOWVhekdCbkhuYUNpWWlyMVRqS3gySUxTMEcxaHBVTWFZZk1HcFhIOTl4OURWdGRucGgxZFUxdFFlcnRpbk85dDBZNjNWYXdpd1NCbHpjRDEzeWxLZFpTTUh4eFl1YytOSTY3UWVYdnE0WWo0SzY4U24xN0oxdjE1SmpJWitSYXdVa1hjOTJtVG1ETzRVcmZGNE9CNDMwN0JINjRmL090Mi9FNGdoSHZLbThwUzdONUc2aU8ycHJMQ0xPV1hUcmNxUlFqMDB4UXZIMXBOSFA5ODViR3NxR3N0L3gvdHFSOXZWVUdlOS9KdDQ5UTdYZ2xhOTYzaldkekZpV0wzbDgxWEdmU3o1UkF0bG9PTUl2NjZaVkRzWXJQMGxZS2M5eGxLcjFuYUYyaE85ejNZYlVRNUlUOTR5MVY3a0RsME1ZNWEzcVZuVVBYYVFjdnZJT2RSbmFNMk9yb1dvZW5PZ2VQWlBuU0J6VUhkYTI5MWFIbXQ2OUVxM2s0YnpibFRrZEV4WTh2dzZJM0lWeklhdVJKQ2JzaU1LZVVuWUJrd2I5b3IwcWtmMkpQSGRkaGZqcUpOMXdoTUY3YmJpRDdSc0hRajBWVXI3NHpwVmdsZWI2VkJsN3ExL0xKT1BSbTkwYVlYNmJWMHBtQ1pJdktpancrOC9veGdoWFNvYksvdmVHaGpaemllUXFZbTA1UmR5U3puMFRPLzhZTDdIcG1HaXVITXNwY2hGZzJSMjR2WGJxamxxK3Y0VGpPRXMyWkVMWHE5UXdUVTZ5VWpuYmZXNEVVaXJUS0pkTmFYVTdXZzV5Q2lOWmJxdnhhZVp5UGRlR2I0REozeWZOcGZsMTN1WUkyVndLYVZCeWxLSzYyR1pWSHJhd2l0Y3JiaUtqU09pc2FJa1RLUUc2Sk5UcVE1OWlaTzJUa21seE8xWXdVUkFrN0dJOU1sUXBiakxTNVphR3VEMlU0Mk1rT041SlBqbGY1M0VGWmNHTlExOUU0ZldtTXBPaXUyMGx3VnUvN2FEMkZsdGtLSVJTdVNZdGVaZzJGOXRFQlpXNzZxejlPM2tCMEZQRWZHR1luSUJ6RW4xYzBjZjFuWEhiWlNmYWhWNGpqQmlIZStXM0ZHRDJWWGVsRUcwa1NuTHQ5YTZUY3l1U3ROUTF6dUNuK0VSdDZmYWlTTiszdFhwWnlGS0Evb3pUZmpWei8xYmExN3pPUU9heXFWVHFCN0gwcjg1d2ZHTXMycWwxRE9iSXVSdk5iTElsWTZiK1hmTzVhc3NCbVd6cFp0dk1wdXRlN2ZxenZFTHN2WEpkQ0FvdDkveUJyZWFheUtVQXFvcXpUS3BuVmZOYThuTzVpUGtNbEVMT0VkdkhFL1Z3VHZWK2k4Zys0TGtMZDdwdXV2WlN1SGQxdXRHL2UydUE1Q3lJUDRsb0U5YWVvdDNjMmRQUElYUlFlUDVJeVZ6enRGc01oS01Ma3pNM3ZycUlGZThBTEhJYkNPTFBTMFJwcTIzajZ5UG1mSlJQSzFRTlpkVjNPR1ZTUjc3akM3ZmJWN2JsMG5sMU9DeHl0MEJxN0xSNnlqUy9lUjIwTTl3aWZqclkzZGJlMk1PS0NORlhrOFNHNURUMU9aTnJQenZiT1MyMTJNdG9KOEpQbStwcEJqcXNINjExdStqak9tQldkeGRyUC8rbEVyRjNZWWFaRUE1aHQxU3JwQTEvSmUyL3g0MEhja2xXT3p5c3ZQM0Vxcko3UU9IMWZYM3c2RGl2bWd6MWFLT0ZjZkIvRnNvVmFrdmExb1BjVEprR3k4Nkw0dSs5aGlwbVd5WkFVamNmbkZ0MFBlNkhLdXFxU1JEbDF1OW1TUHQvZ2hiUmIvZ0QveGhBUVN4VGkvbHpFU1I4ejJmOTVQVkx4MEg0OTFvOTRVWkdSb2ZYc3dJLzJRVmg5Qmt4ZEZhNzVlQy9sVC9QSEMvblMxcVA5QktVQ2VSWlUrUk5RaVpTTnAvZktJZlBNZE1RWU5tcC9jOEhwWGJwelg4dVFPV2VqMU90MlBEczlYdENRV1MvVDJqNFB3MXROdDUvZ3RPU2Z0UjZ0enpTOVMxNzF5TlZxT3FUZUdSZkVlZWM5QXRvNm1VOU5Wbk91cldhT3pxUFhRbmhlNU9GK09saHFMSVVMOVNyRWxPeEptanc0WnoxU2lNUjRoTC94b0krL1M2cHNsRkRPL0prdktPSDRadVRUUFM2bTlVYTJOWEVTS3l0YmsxTWN0blo3TUxhMjNGdUhGZkhLeW91VzVpQmt1cjNYNzJ1MjJKazVlTXpyVnAzMGx3MnVsNUtoRXIwdTlLRWprWjdralRRYmRFQ0ZmakJkb1JHVlpvWUNtd3c5eTlQTTlaWWprdDA1WmZrbGNmdDhlNkNNalRkQVRSV2pwazNNZXlldlJzMUtveVloRVZWWUlrRVE2Syt3b0hUcVNjZDJMSWVTNXlISzAxODZhckZvbkVzcDU5NFAweGRiMHVsVUdid2dqTXRFOExxaGRhaFVLVGZ1UnpIQWlxTEVIMHYxWkxKSW55Lzc2bjFQRkVJbU1xanB0YSsxUVMyZGRUMm5jMlhsbDZORnB6WFc5c3ZTUU8yVE5ER0pxZVhlZEdVVU1EM3ErNWRXMG1URTRScXd2cDJyajBmVDJxQmNrSDBGcm5qQXc1QTdyT1lDNW5XbTFkcnFydjZnMVJ1UEtGdWpVS3Bxdk5jSzgwY2ZSZVVOYW5hb2tmWUlrODFySE5Ndkw4YXA4SkFMWDVHcnAwR2JXWGcrMTV0enNNbVNZWHFjZWRaNTVuM3psYk1FTFpSNi94TEFDYngwbk1yVW1LcjByRENOanlaT0YrTW9yUTVoZit1bTdMa2FRMjRKMkdYYXRKVmpMczYxakR6WVZJWVBjSkpEYkZ5TW5yMkNSNVh5TU8wU3pBMHV3N3FvbUkzWVNvMmV5OEFpUUdRK0RtYlZjYUs3dVppV3Y2UnJScGVnemw5eDZIOUUxcnBmRFB4TDIxcUxUT3MwbnIzVW4xMkllTk1xWjBVUFdUSkQ3SXBvMVBUNTN4Sk05V243K3pvOVNNVGwrL0R3UGRJek1MSXZubUpFMm1JRjFYNmp0akN5dC91ajYrWEgxZVo1SzdWRi92bFNjZDRkcW5WOFpPSTZZVU1aa1pJRGZZelNEWXhSOUtRay83OWtIcmdVOGtqTmNmdzdxL09LdUZuMTlOM3FORVBKd1pocUFlQ0J4UHRFM3RPc3BCK0w3Vms4TEp4TjE1eXREZ0ROZVVqMTNaaHZqalB1L0Fxdk9yMWhKV3FvVEZmeTRtUFZtQnMvYi9CZTliaTIvWlhtaWRSeE5Gd1d4R3BHMVFKVGVVWVE4UitINndUMDRvUjJ5TmVFbmoyWFdmTUI0RkJCNUMzNVZUN09ldU5LeWtZK0M1dmlXckZoU09hMlowWVZyUWo0QW1zY1BKZHB3dEZOaG9tLytuVm5GZDQzSGY3VXZNeUlqRFNJdndnVzdrdlpzVElyVDBudm5ia04wcHdMZ2hxT2pWZjNJSC9rZVd1T1hwcjhQeEJDMXhyWXhybEZWclhUN0lBUU5SM3JESmZSQmtYYmRzLzdKT2UvSmF0V2NIQlJGdjV3MDQxbUVEblIxT05xU0NOYkR1dWlLeUF3aklIUWp6dHVWbzkySFgrYzljY1Jxb3IzZ3NXZ1ZrWjNqaUt5ZThueDZvMFIvdDRPWXJjbEZpYWo3eDdtT2h0UFhvZ1VFZDFrZW1GRlQ0bjdNSndnbDJUOU9sVDRqTWxteDNxUzBBcTJvRjBCNjFaaWhzcjdnRnRZMGNKdjVWZWZiVnhybGNTMDBUN2VWMGJmYkluVTlBMVFXR3J0Nnh4WmFQKzhGalFXdE1UVVQ2NzRRMittTnp5d2svT2pheGwzOWd6ZXNXK2ZHa1QyTE1vZm5Oc1kyRzFsYTByMmliYlpUaUlpYTB1MDRwWE1kN1VyWjVFTFFoclhUYVY4NGxlZks0ZnJQV2QvUHR2eHlNVXFiZ3phamRGeTM1cjhXTTJJYVZLYVVaY24yMW5tOCtmNUY5S3IyYmlGMzZJeUdEWVlqcWtPNnpkM0kxU3lwWXRRY1I2UHUxVVNqU1VMSUErbVozcVB4ZEoyK3BTUGlZNktQTkhyU1dVc3FscWhCOTR3c0JXdlg2Nzh0V1VtUkU2M3kxbkVSZjczODZMV2Vza2lzYUVyNmZDdHZxd3dsZU55UzVaMlBobE9sa1hjMHVpeE9HUXFRcHBhanBkUFNhTHFiWlg4MTlQRDlvWU1KdWFHUEFqV21QVEt0WTNUVUlhcHlhcTZoSDBUS2lZS1owR0YxUkowN2RmOVA1RWM3cWVZTW80dGlrZms5U3JRTUVkQWdaOFVZOFVCMWVaNnBQaGZWRmJ6ZjdIbEJ6V05GUEdtTHh4bm1lYURkSEpHVE9tV2h3YzdydkxiRWI4bnF2YjJlWHFMRk5wRlllOGJVeFVzcmo2MTRhblRFa1l0QUoyZTk1aGlaaEpMVE9UWHlNWlNwZTA2SWRHWDdEL3NNbVlWbG41RDB5UGtKb0g0MVVuenJQSDA0aUxjVVFWeEcvWTdtQ3F3d295VWpKYXhNcmVXNmttSmgwaXgrSFl0VGMrYkNBdmxZSXV0VjdGSjlTR3ZGdWlTOXNOOThCYTNISWQvZEJiWWE2QWl4T0hadVFEUk12eGRsOFByamtTOUIxWno1SEp4ai9XTzRkMU9OTGpPY2lSWWRSR3RYUGdsdHZBeHorSEdxc1hSWUltV0tXdGpvL1ZsTE5TM0RoY3J5enY5Y1hkOXI5bVg0ODRQVXJLZVpQLzZpTDVwRVpQYlczTjNpakxPdDNrRGNQRTNYL05uTDltTzJQSFJmbzMxcnorOGZnWmZhTmlLM0hURWxxQW5zVFRjVHhtRmtnQm5UaVFqc3JxdmgwOUpWUk56TktMMlBORmFWamVPV0VOTDFKdFJzNHhHZC9zcnAwb3lsQ0dlSjVhMVNMdDhndnhFS3VuRHR0bFp4eCtkamR5elRVMkYwT1FFdHVIc0VkNHc4QTliQi9WS3FkU0ozNnA1aHVWdGxRTllqWnp6VHNHUWlaZXAwZXBlQzFPc1R1UE45bnZHY2tON3V3QjBDcmVCYWYwSHpwWG0zRjdWcUs1OGVuVG1LdjhVeUV2TEp6RFRqcFRkQmNCMkhkb1U4bVR2MGI0NnhCdDR2R2xsNTAvRmV6N0dXK0dlWDRVNU4reXVwdjVFbEpJaTFQdWVsSzdnNElOdm5JUTEvQytrY3RIV3I2dmo5b1kzeWMvem5rRU9jU0dqNjUyQUZjaTAzQ3o0cjBsN1I5bFRweXZYSEpwcHNxYldZcGRLTTAzYSt2cVpWUlBUTkNjU0pvQS9NNUxFUm1iOHZJMjk3QkZlVkF5M1p6cWZwOE9xNGRNZ09VRHVnZzRvUkhYUEM2Q3ROSHRvREgwY0cwNHgwaStoUStoYTArdERNMFFuMWhiNkVYS2Y5bjNIZE9yYmt5R3RyYmpkM1hwdVJmb1RJbzBZd243WTd0UHdxb0NhcVdEb0RBM3pYd0pIMURrOVg5cFFwc2xKcVJXZzkwMEZidHpnMlhmMStZcGhGK3QyWFVvTmh4UEVMZHJNTmRHdEpEVnhzTURsenpFWFI2dlFNN3FDcjF6NjFVaDdUOXZUYW1iV1RGWnZZN01FOVE4b3hHZDE0cHRJenU0elh2b0RZdkQ4RFVxd3ZuLzUwcWIyc0FwWWg5cVAxY3NoYmR1ZTl1QW0xTHNYNGQ0UlpheEZiMnRaYWd5VUxsZjNob0xkZ3VmWldXSWsyb3loRGVjZDRTUld0dFNicTh5SXhMUGhJWTNmK0xPaU9DUGtnN2p4Z2V3Mlg5UndwT2NlSThRVHJTbE10ZjVTNkxmZGJId05EZllsM203VmZRaU9VU05YTHFrTzdVemJLWkZWNXRFeWFEQXZVVDdmeWF2N1lTNi9wbkJHZFJsZmpJcXQwNkgxNTdZYlV3MGk3dEdSN1pkaGR0SVFhaGN2UlNpNnByNU4vQlZFSGxYZC85RTRwMHZ3NVgrbnd2cFFxaFp0TGJ5T2p5VW9YdGVSSlNZZE9sRkNRc21pekZ1dXZsazkrclRWYVBzUkRJUjdXdWk2OVFFKzdqSUxPQ0xWOFdsbTB2bWFsUVdWNzNtQTdMTDdJdzRtY3hzb0FLeVNTcUxtS21xOE9SdDdoSEIxSk0wQmw5VlNsWmEwc1MrbnBzSmJPTnRrY1FSOUNOT1p0NVVmZExua0VYbVRyMlFDejYrWGpkZG9UTXAxZTJ6ZGcxeVl2TzBMNVdtT0hTeEVOZXFiY3JNUWRYaHc5TWkySStodUwwcEhHaXAvUDRKOUVDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlRUDczZi82ci9CajIrQnZaWC8vaWIxaUp3OHlOelJ3VkoyeE9kUTNPRFlaMldCRUo1QzViMXU1YnZUdGJrSnZpN1haS3pnT3hrY0RZai9KWFZhbTZRbmFLaE80RzZXeTEyN3poNkg1VHM3WnFDZXpuTTJYc29BMk5lcldSUFlTaU40VHVIRnZhNmxxaUxuRG1kNG9qUm1yK0VTRGJEVm5wUEpOeTRlNm10Nkp6K0o3SmlpS3N2YTFWL21rbDFtRHA4Y3Zaa2UzSWxEdTZ5M090ODZiY1NJRGxnY1pBbHV4NDc3UHZNcit1RitVYWR0ZjdGTFcyZlIyL3p4cWZQU2xWVzlScFNySHI0MGRqTVVxMDNkOWIyaTUvdUc5QlcxMG44THgyelN0VEt4OVpnemRlZTZWVy9WMzBVenlNS0dwK2phMG4xVit6UTBLa0xoTnBLYmRrZkgyd1NzN0dEdUZ0bjlpUzA1SWxWei82K1BGNTBuYm9aVGh6VUtHVGNIVGVMNW14RmhFbE1nRzhnR2dSb2xVK2tSN1hvS1hUWk03b3paWU1kRFV5R2RjSklSOUV4SmlzM05JOHFpc2lweVl5RlVWazFOZDd5aHYwUTU0OVJ2TDF1ajdVL2FJclk1R1ZCYXNNVVQrSzFFUHZVeVQwdnVVNTdYeTBQbHBwb3ZUMk1TMy9hQlE1MnVkbXlQYnkvNUV4YWh2UEhNaGZnNmowdytlVk9xTDBlaTBYV1hlM3J1Y3pHZysxTmtrNWpxN0RidWYvQjZZcnFUMENyK3JvMFFVNjc5aVNNU080cWVWNU9udGxvVFBCcEtTenZLQWx3eHM3SXAwMjVySVZXZlJpOWRGUjcwSGVqTVRYWGhjRGRSL1cvdVg1WTVaOStuUjh2aEMxRE1oVUpScG1qT2pVMGlLeG5aWlBLMU5xNU9lb3VoRzlMZ0FkdDRnTWNobTlFWTZGYXRjY0YvOCtMWlI2WVRSdENvRVpDYU1uTFhSWVh3Q085T1BvREthVmhuU0NCajFFN2Q4emg2QzhObk1zUmRKZDBRWDRhMU5DQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFQUx4K21LcXY1L05yMy94cDlQa2hiY1pWMDEwcTZSZ0VXb1IxdldQeHFsVGFLOUFZK2lXeGdadURaWGthYXpZMGUzYmlkUVpPTGg2ZHVHTjBPb0d1TXdaVzYxNFc1d2hXeE5HZGpNTjdCZFNrQzJ4WmxuTFNFdTM5bFpCdG42TDdDdG1FZXpJVSttcjg4aHVpR2REcy9zaU1yUjZURVhyL05PWU1jd1hFeW5TalBIN3QwdEY5cU9LTWtQMkRMOTZGc0g3VmJmck5lNFg3cmM5UVcxMGoxeGtBcHhTUlBmV0Q2TmZnMHROemUxOTE0b1IwMnpudDYraWFsOUV0YjZZK21PbTBmakRJdEtPMGZiVjh2V3cwbmFzWUtVdDhjYkdxUDBia1RFR3NxdDRLMDlxNVBkMEZVWDV3VlNLNndkaDZEUXBLZWxXTUd1YVJENlUwUTZ3NzlDeEdiZytBdjBkUm9XUFZITDgvVEpxejV4Ym5yZnllM0ZHckNZd1pxMUZ5SE15ZlgzOUUzenBSRDRnakpnUk5TZERodGRMUjZwbk5PS0xSSk9Fa0VtY01jaE9XUEpXODlWRTFpTjdwNzlhdWpxdHQzVzdPRzdOU1hwQmk3SkNSelMvSmdPTjZIcWFWN3V1Y2Nic1BoazZVTjA5OTRXQ2xsRzdGdFV4dXc5ZEZnS3VzbU5hR2dJeTRKaXlNTkR5dUQ2L28reisySjkyNmxsM3RhNXI2V1p6aDJoOWhXV2VOYi92MWIxeDlnd0pYV09JTEladWw2bzhwZU01QXR5OFBWN0E4MjZ6dU13VFhVOTBTTTFjVE5BUGJSSGkwVjJydXlLamRhVFY2MUhSYStrOGkyR043cG1QTkR3TGtvSTZ5VTF4ekxnSkcvNVNaa1U4WGMwc3d1aC9ETHRydlI1Nk9LL3BJS1FIZEZGSnd3dUxBNTB6Tjg2UCtOOUlYbUxndGUrS0tlckQ2WjB1OUs2RUlENERIVE5XL0h5MVgrSVhVd2toaEJEeXBUQUtKNFFRUWdnaGhPemhMSUdRMlhCVXJlZktPbWI3RWtJSUlZUVFja3NZcWhOQ3V1QWFBeUdFRUVJSUlZUVFRbUw4YWwvZWZqdGJFaWYvNUkzM00rMk5ldXNraXdsYm45US84dmQrK1QxanA1V3BlRnREeVdOUnA4YnB2UXBuVnkzclM2bUliUExCM0g1d2ZERGU3algxZWN1QUdZdzJrN2RUUndIVDdsTms4WGNFZE4rOFZqNTB5eDlyaTVpaVgzK3JNTGJBK25PdXZMSzFkc0ZFV2pIUzBxWHp2R3czcno0MDZqaXhBM083UjNUZkZ6U05MVE95TzlOc1UwbXpLL0IyL0dwdGs5bGJtZC9TQ0JsTWMySjlhTTA0VTZaRTkzRXI1N2ZmTm5jZTJVTFlpU05nOXpTeXp4NjZiYUJucUdLUjFENzMxaXYzWmZtNS9mdzZSaUkwT2VIYmhHd3hqTGh3bUIrK3lxSzQ2ZmUxMS8rMkhVWDN6WlNWc3ZURUdVaTZ5SDV5bm15MEg5OTFmRnYzOFltMnpvdmZrVFJZMlZaRTZ0S2lJTDEzbHo4M3JsdER5QXJ0cmJUSVhCVnBCazluY3E1Wk9rK01TY2dabkxtU1llWE5JbGUvbjkyK2xGcTY1K0pIaWZ2cmlHVXF4ckZuSkx6NzYya3JyeXplZlg4Wk0yNDdHcm9ZMldjVVFZSzRvZFhNZENWMFI0UXM1b3hCMW1Pd1pGNXIyaCtScGFYVDhxRmhCUGhJNDNBZG5EYm5obytKcnNaYnh5dVlzVHBscFltdU9FVEtFbTJ1WGxyZDE5TVY3ZVpJR2F3aGdjcWVhVUs4TW5oRHF3WnROOHNVVEczMzNnRWJ2Zjd4M0hReFFuNFI5YzgvODJ1YVdKTDl5U2E1QnB6MGRIaEJBdGRYV1RDTkVTYy9TdlQrV21YUzV2M29VMnN2VFpSZVdkN3psWkVWVi9SOFEwZXArNlhTZHJuNlIxRUNzNUpGT3YyNXlsSDBqR2NYczNpOEliZUpkdXRXckM1Ull1Zy9YY2g0Uk9jaW5ndG96K2cyaTlGN1c0N3FydGdtcDFBMW1WT1hsWTgwdkhqcmkwZklaNEpPREhvbmMrUVVrUEdkMHRnVGpXeWxGK0d5OWU2OERMZXRjSnBkaVF3VFdhZjBaRVJrRHFocnFVSWo5UlV6bXEvRGEzY2FLSmRaL2E4Vm51UkdPbzNvR3dYMStUczBQYitZU3I0SzJsbENDQ0hYUWs5RUNDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVBMitVM0E2bVhWT1NBOVhqaHlPV2tJSUlZUVFRdTVEOWNWVTdmZTYvQzA2R1FEZG9hYUJ0MXVrc2w4WmZId0o3cTVwSWwzSHRoQnk4MFJ2cDZmSXZuWGVUbGZreHNnK3BXMlRvS1hmMHJMaDQwUTJoeXg5b3ZvNTdzbFJEdGR5OVY5TmQzVGZYNW1udGVlVkpRUGRqN2hWNlFXVWJkRGFNcXQ0ZXhSNis1bEUweU1EMVRvZnNmNFczaDVtWG5hbm5zd3ZxdlpRcXYvNnV6WFpFdVpEdi9zQ3NZM0dacllIR1RJL2ZkaGZrTjNWYnREcDBKMVZXNkdOcEhUcVdvL2xJN1hqTytCTlpscjNVMTlxN1VvdFJZbGRxWThKR2tLOE1xRytFTjJ2TnhsbHd2MncvUHJhajJhN3AyWWx2aXFha0VOc3Q5OE90QlhpU0lwb2wvdzZaOGVMbGtHMjJxUVZ1OGw0YTNTczlNU1hzOFpuN3oxb1pmRmt6S292aEZVNjhxUTBkdXBqYjZqN3RSeERPbEhMWWxLT003U0QvZlFLbzhvRno2TXlSeHhwcjA3eXhVaDdYTXpyZTB1NVQ0ZDM3OW9DZUtOMlg3YklWMWpuZ1E3d2pjaGFoSXczMEFrRWFnVTluVjhDRXJwYUU2SU9rS3hXTkNiVHBHUVhjVlpaTkJDZFNDK2xDeUxrWVZpMjBwdWFSaGFWUER3NzNUSmdXVWtYa2UyVkNUbnZ5SjdscGJYWi8raHRvZm12V0ltTE5MTzhocTVhZWF0MU0zd2VXbGRJMTRvT0VYUVZKQUlTNlNQbnJiZ3BBM205MEc4cXZRc2JqMlhXcUlnOGFRUVdaSXVjYzFYSDFsZFNEMldxZFhybFErYUgzaHBweENKcDF4TllCalJ0TDE1N1JuVkVaU0dXRzUzbjk4eUVZczgwWWdHR3pCdEo1NlgxVU1iZm42OFBTNVd2NjhVSkhMTWhWL1VHcXpuem1jYkQ4THB4SzUwdzA4VmVwbFJsd0YwdCs4VnFGUzBaYVJLUUhnR1YyV01wMERRekxRVzVJZFlqQVRTZ3BpazhEZFNrMXF4OG92Rk9YL1doTGpzbjdIWkxKN3NZNlFJTjVWckhWcWd1cDU1R3NscE1OQzVBWkxab1JkRWNVeUFNZnNKNFE4cWlkRnhIeDlUTVJ4cWEvanJQU3ZqRlZFS2VDRDB5SVlTUU4zUUtoSkRQZ2xhTGtERTRoZ2laQThjU0laL0lsU1AzVzYwR3JlV1RPYk4xMlpNSUlZUVFRZ2doUkhMRlRJbXpNMElJSVRlQ2Jva1FRbzdRTmhKQ2JzanJpNm5BSGhQb3o0RUpRWDVHRHY1VTIwdldzOVBLTGZDMnZXemRXSlhYK2pLcUduT1VwS295a29Xdmtac1RDVVRGem01ZHU4TjlNOGdnQXR2RE13M1JxdjlKbnh0cDhpdU5SM0ZLbFpUcmRScWtFbWJzMllmcURIWmc5V3VleGs2Yng4eHBiSCtVR2Z1TFdYaTlyTFVkcENmYWtHVjltcTMwN09LcXBVdG0yaXZObDdjYkZXSit2NGJvTmx3WmxQUE5GZXlaSVMvZEJQVVdFZXZUeXBlYzlONjFjOUJxb2dCcHJnTGR2OHVoQUZzRVozRzlXRkZSVTVGekx0cXJXak9vc2Q2MGZVMHRBMlg3SGF2VlgxOHJJbDIyQnU2ckRnOGZuOTFpUCtGM3NRK1cvN1JiTGxzTVdaZGxseW9kdng3bjFYMHRKVG5uckh3dFQxc2ZKK1BZT3o5Q3I4dzcyWVc3Z2NiVHFLUU1TMEw4Vm12bnhXSktOQXNYWTlaVUtCSkF0MjU0QnBHeWtCc1FYZVU5K2hXWjl5aHA3NE8yRWZ3L2tUSTdaU21xWkV0R25jWlBYdzZwVjNSZzFBZktza1NpZEE5THR5VXY0dHNmVEE1YzY2eU8xbnpKTTlOZXowckdkWm1tcDllMy9HczByN3hHTjBJU3VUK0lnUnBaQUxMY1RXUnAzOHJqR1UxRVJuUlNncDZ2alNDb0krcCtQUEZJMVk5R0VTTVJSRy9lcUc3dEhrZFhMYXc2dFB5aGRhMmxJMEkwcjNYZk05cDFOaXNpMXFuM04yb2p0WFRhZlA4cnNDeVZOODhWNmQ0ZCttZHRWUmNER3Vxc2xRdWRleWZsR0czZ2FDU05XcXBXUHE5REowRFhhcEJaQzlxWDBIbDlUM3BVUnBxZ1MydTM0bHkzWkczcFc5ZGJWR05LZTkvamNGc2lUVWJxYlRSaXV2TXpqUS9EaSswdHZLRVlrWkYzZjk3L01FVUdtaTNhSTlEck1pMHlXaTFHcksrM1VobGJaU1lmQzJvU3JYVGtOR2FNZDYrNUk4Mzg3aUlpMDIvWFhpS0ZsYUdBdE91RXJNQUtxVDB5THM2Nkhsbkwwdko1NjNiZWpKVW9vSXVmREg1Z29qTnZkQVk2RW1jbnAweldkVzlkK2V6dXdDK21Fa0lJSVlTY0RtY0FoSkFQZ2VhS0VJSkFXMEVJSVlRUVFnZ2hoQkF5REpkWXlIVFlxY2lqWUlkK0poZTJhMmFmSW9RUVFyNEplbjVDNXNDeFJNZ1lUeHhEcnkrbWVuc0YwM3lRQVBWUHc3M053c0NmbFhzLytJK0Evbko5Q2Q1R1pkWjJFY2JQOC9QMkg3R0ozbTRuQ3FFemw3WnE4bkRRTFVsazJwR3RHYjZWVnQxcWFZc3ZRcDdIOTZ2MDk3WEJQYjIzNzV5V3p0dDdBNVVwejN0N0FLN3NuTUNnY05VN1JoNWk2enl0bUswTTZKNVloOFdSclg2RjFoU1dNUGJwSXNOeU5WNkk5TFcwdHZGQjg2THg1emVqMVVWa00rSkJ0VkoxRXVjMXE0YnVUdFhDQzJudXdSMDc2S1RCVTFyQlR0YlRaaXRvZlNkTU50azVkMlVjb1dzb3hwVXNVdVhYMmFJWVNiZlU3OXZlMzJmT3VwZXNteTFYV3pzWHNZczQ4blU1bng0bmtJMS9sMGE2K3JpM2Z5TVdyWmNWc3IvRitZM2RwNng1clFlaVBRbnBXYzFaVUc2a0d3MXFXMTBzR2s5NURsdkxPd3RFM21jNC95OEIzZGR6VDZ0cm9jMmJEVjIrMzgydnE3YVArL3NsOHpydi9zdm05cGRTVjhZYnFPL3MxZTNGV0pHeWFPa3MzMDVtZ3ZnOEswOTJ6aU1yVHNvampSMHJWdjRpVVNXU25oQnlJcTNBR1RGZ1dqNUxyaGZJRitmWWMxMFJ3OVk3VFkyNFplVHhRb2VxTkhnOUQ4aU1wdE1JVmdlY1QzdUZJbG9IdlhYdlRRT1JNa1c3KzRwSTdvN1I0VzBqMW1pSUhtM1FTSWYrS0hvaVRSbmRPakxnVHpUbGwyaWprdmNMdDN1VmVXU09WdXRDVnNjUU9ScVJEaE4xK2l1ai81NCtra0I5VmwrUytYTHd1Q2FuNUQ1WDZiazNaRkd3TjNoTFZYNHBUOU9qNVZHdXQ4YWlaZk9nTWloeWQ4M3FCWUpJSk5GSzk0VTBtcmxwbmxIekZsblFNUElXWTFqSzdtQVZUVU9MNFdhNDVaNW5HcXVSVGNEZS8wVlliaWs3eCtSMFJpS2s0cHlmRVgyOVpScDJ1SUQyV1pQRFBTN0lLU0MyRUNTeU5Lck5VTFI0WXlUKzRCQjZFWjJLMFJkT0ExM1M5L0o1TTIwMGJTdS9OOTI1dWh2d2k2bUVFRUlJSVkrR3N3NUN5R2RCcTBVSUllUU8wQjhSUXZxZzlTQ0VFRUlJSVo4RkkxaEN5UDJocFRvUDFqVWhoSkFiUWJkRUNDRzNnbWFaRUdMeDYrZWZ6dTVWaGFhRUJQRTJZZE91Z1Q4Qlg3SDMzS2xZdTI0aDI3dFlkVmJ0bHJEYm9GTHU1cElNM1lHS2lXN01RRzRFdXNOYmZaNk5IU095RGJHV3BvRzJJMDByKzg4WFBINy8vKzlYTzRxUWd1NzI4YU9yeDRBcmhtcUluajEydkowenZkb1VXMlRsRHVONTBKbmF1c3g4MmpiRVdocTBUVnJIVmo1RWg4QVYzVk9YZlgzcURtWnQwQnc4RDNTWHc1R2RvU0piakQ0SnBHNVBvdVVpclhOZWMvMERwcE5sWUhpRDRQbUtJSzB2WTFzK29LRCt5V05rSUZoNVVaOG9nMnY5eXZHcWQ3NDB0QjNyNjdDazg0NXBraTVkM2RSNzI5cjVsZlgvMnZUM2wxUDNYNDJ6MjZoT1Y0bEpSd010bzEyWlRyc21RZHMzMnA4alplamxJaU5OMUpxUFJNZklNYW9ieW9lYTZaSndFeDQxczhpV3Fsb2V4Q3pQY05ibzFJdUJ3UTBwUXluK2R2dk43K0Q1a3BxalAzVnBEc3o2dkJkSERNekZEem85WnZnaHp4cG00emhpc01nSUk3VnJ0YVkzSnJWanF6ZEhlemhTSm5TbGpCQnlJeUpMM0VVNTcrVWJUWVBndVVBa3I3V3M0RDBvbXJTY283SEtTMnUzZHdXOXVsZXRSUHhtdEJuemhEVG9reXQ1dnBXWExLUjNQdXgxTnRtd2oydmNub2d4T1A5eDdiYW81SHBkdlY3VHpZalFYa2MwWTI1Mlp1Y1llZDV0WGV1ZHJjeWNXZlE2OTVIN1MrRDFIaERETkh2V0p2TDhIays3c1pURm1Dc2lXNVd1S1Y4R1pnSm9PSHp5TTQyTGlacG4xR1Fta1I1QmUzelkwRjJNNGV4WnNaYjZMUjlxS1hwMElSYWtwUU94MnEzeUkyVjlhRzhuTThZcCtUalFxYzFVblVvSVVaZWxQaDZObXNtWE1PSnd2VFhRWU9lTHpCTEw0REU2VS91Q2lOV25kSjZuOFptTzE0OWI2WHRuMGpNZmFhQ3Y0NnlBWDB3bGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJK1hxdWVNUDVBcDJaYjNJVFFnZ2hoQkJDQ0NHalZGOU1YYkhiRmZsYVp2eDBtNFQ0dlV1THR0ZTgrd3Y5anJaZzh6MlFyYk5ZT3krVHVRVHIxdHZJRDVkeGJHaS8yV2R0clRLeUI3UWx3OW95dk42UlVxdTl5SjU2eGRHOWdzZ2VRWjZNYUxySWZZRnByU3Fmd3VjYkttNWVaSkFiNTN1N04vbEw3N2FpazVtbE1tTEYyQ1d1WUtrVEFIUWoxOUZkeGlXMVFXckZFYjY4bVgzejk1Zlpzb2oxb0h6bEoxcUVkWW10UWd1b0xYYS9WbXpueFhUUmRrWFRhUk1uOGtTODJjRXFuYTJaVEVqUUprUUtXK1dBWitTOXdsRXpPUGdZb21QQ1dnMUFLQUZOSlNBMWRuNjdkbWJ3YnEyeFdLeFlSS1NmL1RaVzkyYnZIQ0hrSWR4cGdLTkxFVkdaa2RnK3NyeHhzODhSTUJKNEZtelBEOGV5Sld6WURrUmx5czh2TmFlRnlzWHNuc0RMMGt6anBUdVRGUTcyamtUdjgwa0xkRFBlSlVHeWxQYnhGRnJyT1h5bWNRdWl6ZDVhYjdmU29zZWVMb09lNmNGTVJxM1Y2UFA5b2VjbjVMUG9IYThiTkgybmNWVUU4WnVSWmg0TkJlaGxDVXp2bW1EcitEZmFvN3JPTDZoNnM4U1ZFVHZIRXJrSzVHbDM5THlNVmMvczF6bDRmamEvMGtHdFo3a0ljZkRlVjVrY2hYN2taRFB5cnZOdm5HRzVCY2lhWTg3RytuWXkwcVd5KzBPK0NjL0RjbVZuRGd2cnNQVXp4cCtGeWVNUEZiYnJZMFVERFJaMFBqVmtJZW4zZCt6VnlENnZRd2JUbEZibUZaMWc5UUQxMnRmUmpWUTVWRDF6NzNObGk4d0FtZmc4RXZUNW1aZS9xNDg5a05tbWRnS1J5YmYxT05hNkhvR2hUWlJvTFd0KzJSSnRURnJrVHRWRktZdmFrRVhYRVhxeWdCZ05wQmNCOTE5SjIzSWc1MjJOK3grbjlvRE9JeUZacjdMWTkyV1YxWXZ0Wk4zT0dORkllNDNWTGZsTXZQR1pqT3N5cmJkbzNRcWJEMlhRWGc1dENSc1pJbGRPWmI0MWhpTUhmdnNUN1llZy9oT05mU2ZLUnNyV2owd3QzYTMwdXN4Yy9UY0JNdkU0b2xXYUgxa0k2Q3BScTJ3alphYWZ2UnJMdDgxb0dUUnlRM3V0RjBYT2dHNklrTVZFQmxrMHBvMEU2MUdkcU93ZUk0STgwaWdCWFlpeHZKSDdaU1NnYytkNnlaM1h5RWxFN1JDNkpQcDRaaGp3QlpHazkyWEg0UzgvWHVVY2VoZXVvak9IdTh3VTBQdWROWUJuQkVXcm1iSCtNY0JoSWJiM0dZSDM3T0txKy94eWp6d3JkcSthcis0aVE4L1JPcHBHZXl3UW1SNjA1Q1JRZG5KazlscXQ2UE1XUXRnUnptUGw4bzJXSDlXMXBWdlZGV1JJWU5sS1FtQm1UazN5bUlyV3F3VTF5SHNNbm13RWpxVVg2THNUWkJodHhoYkp0NktadkhpNHBYdkZVM3VZVjc5OS9URDFqQmNneU5mUU1vcUR6clNBNXo2VzRod2IxN1lxVjQwa1dFSGxVUlZKUXBpZFIwbEhjRTR3V0o3SjJGNmN0SDZZVUp0ckpCTG93MW9XelIzYWtPblNTUjBhdE05NHB0SDBxd2RvMXczLzBCdkY5K2dLNUw2VFdYdDhqT09CREYvNm9UV01yZ29QcUp3eHd4eFpzMk9YV28zUjB1b1BSSTNXc0o1RU5yTmFzbWI2NGZ2M250Slp4aFYzWnYwb3B4d2FPTnJnVnB3cDAybkhQUlpvbHVVaVQySld4TjRWQ2xsREtJbnphbWJuL0ptc200eVNCNkw5UURUNm90TVJYMExVcnhabjBPSFNadmlkS3lKbDFPOGl2cCtjQWJKRzZMa2RoTWpMUkNQWFowSTNSTWhpVms2OVo3a1piZTFzbGtHTDVKbHRIR2N1MEJGQzdzdUtSNU5mWVR0Nm5kRENsNld5WE9qcGVkYnVLZ0Zseis0QXZlVmR1ZUMxY2xheUtwQzQ4d0lnd2tYbFZOKytGMlhKMWpPTTBXY2FWanJ0bU04MHVwazU1QXFlTkVScEhoNnU5ZjUwT3NxS01BSk4zN0pvN05Ya3pheDVQM0c1ODNwc0pFb201SExXdkpEVE9od204a1kyZXIyV1hlZmgrRTJmTTMxN0FMMTlialJXUjJSN1Q5WTkzYWN2L2I4SzlxdWRTaXlhZVQvREpXUkRycmUyMWw5UEtzTFQ4WnkrdFhzTGY1RDY1ZFJ2SExXMlVXTS82V2ZrYmEyUnZHOFIyYm51aWM5R2tVYjIxNGlHTzVHS3NLd2gycEVqRHhGa1Z2RkRtL0EyaVRQMkVvb09XUFIrMGZMTE92LzlwOWpKOS84STZCcGpSazNQd251TTlWVkVWakRxOUY3YTAyWllIMHdyQmtocFNZZEVtd1Y5c01aUVpRVXpmem9zVHp0eGhQa2pLNUh2MFBBandhd1gyL1Q0UW93c2RPUU8zeGpXTFB6d3p4ZFNTeVBML3NkQUI4Ly9GckxQNS8yWUI2OWhKYzV3cGMyeUVuTGlSTDZGYkJ5djhEdlJVQWdTSklWbDRIeEV0aWJMMDNVR3ZkTS84aEhFdjE2Ni85ZFBUczgvYmVtTG0rWkhtdlhTSURwcDZSbVlscXlreUVSMVcybXNkS09EaWY3MURsd3dMWFJadVdiU0Y3blRkUkRpY3VkQk11TlpEWm9mWFlCdXlUemhrUWJkTHlFUHhMSXY1bnByd3VSSWVRemhHemdWODdNUW0zQ1JtaU5DR2lFNlA5VHlwRTdkUGZSRzZTdnBEU0I2Nmg3VmVjZUFhK1IrVitweSt0VHlGK240VE9NanNSNVZUdWdXUFM3Z25UZGhyYnJpbWNacTZ4eDlwTUZlL2NXYzZXN0lhZlErMFVoR3ZxYU5sSytiRkN3ZElkM2M0S0hHeU5LaGxER3FXNTVQNGpwOXZBSXJaQ2t6K3B6czV6UDdjWFIxb05aOVJkZHhmcGpLeUkxMGdxeXRrR1cwNG8rUjRJSThFTGx5cFVGWE1NYk5vMlUyNzJTUU1kVU5wMTVuc2JLbTBZbjIxNE1zcGhUam1KVkt5QTNvdGFTdkFWdHk4M0xzSW1vRVpnVERLMTVXdUpqS0hudGZxQ3VIZHNmdW96U1gwT1N5MmVwNFNKUE5CUTV5RGxwdjd4YTBDZkhTV01jV2tZZG5WNXF5VWROUHZnSi91dUg3bkhsZDZNcjVmbFQzQ245TS8zb1hodnpQQnpIUzQrZzZDSEZZTlVobXVJcWVzdlhlejR4NGxERXRJZVNPbkxFODk3R0FCam44KzhZWjBhdjM0QXhkUkVKL0ZrWEl0M0xGTXcwUGp0TXdaZmRuaGVncGViMmVoVHdtdUF2MEtHUVo3RndmUmU4eVNNanJScFd3LzVDN01CQmVXcThGM0tsN2Y4dXpxUzVrZzlFK1RXZFczN3RpOWlmMVhkMHR4QTlUbmFITlVVOFFSdDdaTkY1d0sxZ3lOUStTTnBKdUtUMkZNSVp0Qm1XTzdNWkZIb0xzUTVZcjRBOTlZdFJqcnhVTXR0eHUwYk5GN1pzcHYvcjNzZG12aUdDOWgyTVpURmV6M1ZuckJ3OTFYdSsrdCswUmk2L1NUSkNjTXJRb0xXVU4yVmIrR2IzSnF1TmlKOThsOHh5VUkwOFhDcVZxVVFmdFo1ZzdUZGZYVDdxdDN6WnBma3VtUWVWRzhqMFZKS0Erc1FqUjV0bXUvL1A2K3o4bFRkRDlrbUY2WGt3eEJqSnN1SzFlaEJpUFlKa09hWkRBT1NMemg3Ym1YS1dMZkRkdW4vOFFXUndta24vLzJmeVNhbjU5dWE1c0V2TkJXN3NNcmZnTGt6V2V6N29lNlRQa3ljaGVPanRPMUN5bnBlTjkzdXVTbGhtK2l4TkVZN3BWRStJRTZDWVQ4Q28zV3ZsRmxkQU9hVEhaZWttc3VlWDIxVlkwV2tXUXM5Q1dmOXlYNWllUGxOZEtueFJkRnBZVjlNcGs1ZCtnYjcwajNrclpMTE9MclBKWXZmb2ZjWXpJR2kwVElhU1QwWFU3TCszZEI2NzNTTVBLNHkwMWVOY0pJZDlMNlR4dkxVWWd5M1dQeEpyVGJOY2lEc2hhKzI2OHFIT2JUelJwOTFrL2piRVduM3AxYVIxeXhObGZXWThqNWU1ZGF4aDlwb0VzMUVYTEpIVkUwcmZ5TjY2L2k5NVk3OGo1Ny9YM0N6bGlQR2IwR1ErZmFYd1VNNVlwVWJPVUhkR3l1MmE4U0hVUklvOEFSbnFEZDh2bzBuNUxic3VqRlBBY29wTmNTTlMxdFBLaXk4K1JaWGJTUlUrejlrYlR5ZENsUFZ1MVpKaFBLc1FKNjUxZFFzTDBQR0NKaG9HZ1RSdzF3ejM1a0NVS09mdjdlck05T20waUx0Rm5sSkZZdC9lcHZrVUI4dDlwelB6NnFWNjZVRElKcTBzaG5na2NhZXl4T0o3Qm9kOGkwTHF6bFk0OGh0NUE1MnRBb2plT2tibjhYdVhacmZ6MFRuRUhpcEN1aXpma3BQdnIwWjZISXFzWExWaXhmM2w0SjVQck5aeERuTUhLTlliV2p4cWt6dEZnZHNiQVdHT1Fja2NlVDJkckFjMzdRVTl4NjFxWFhoUko5ZldmY3pQN2tyVjBhT25rbWhrNUI4Z2RJM01TSzQ5MUhHVm16REJxSXE4b0M3a05LNnh6dEJ2OC9EaDFCWndKRW9JUUdTV3pad3VFRUpDUndUWHBtZktsQTN6MkcxdVJSZU9lK1FNaGhFaStkbG1zZEY0THBQYzI3dDNTSEk2VGZYM2FtdmJaVHlubEEwQkNCampWYnQzUlNQS1pSamRsVWhvdHZkRWNCWXpaVzYyS3JtOTh3dlNBUGZmaDNPRUZMSElLczVaelVLWTI3eWNiVVVLQzNPR1pDUExtMTllQnZodEJ1OVJOMUUvUk5lQzh2cGdLL0Q2WDcwS1FDSzJ0UjdRMVJiQnYxY2xMUTZUMlMzQk54bTJ3Q21sZGo0aTE4blpVQk0zQUEyazFhUFFaeGkwSDF3MEpQRmZ4dkxQMVdyMlUwYktSbm5adnQ0OTRjN2NxQU5uakNrWHVvVk9majhwcXBOL3RubG4wSXBoNFpVSEtHdjBoaUNjblVqK3lqbEVuTDg0ZmRpQ3RMaGN4MWR4Mkx6WExnR0hkclZaaXJmUWpaZzZJdXFGelgybHFQWk1SelMrdmZiUC91dWorRVlzUmxlVnR4bEtTdmJCRlpoSWRvRnUyelNkNDZjUnhrU2VCRmpVNzNhem9aeVNBM3VLd2NyaUszcVZYMm1LZEVIWGIrbEtxekx2L2NpcGVOdm5sMUovcnJaRzdDazNuV2JySjFaVEd1ZXljNzVtcHlPUFdVaHFrb3pXZHNweWQ1emc5azVpTTY4blJOV0lpZTlPdEFOSDk5WUZHOU5FT2tyWmVyN0R6SDcvTUhidU9JSCtjbWxYdnJlZE1ianB2dmpzcmdwYnlyT3V0UEY3RWdjajJacjcweDJjVDlVczlyc0VpMnV2UkZjWE4zMGI5dGliclN2ZER5Q01JVDFvbjZrUjA1TUhyUGJSaWRrNVZDU0dqZU1HZGRYNmJrdERtSERrOHMwVHp2ZjRXUlY3Tkpudjc4YW42ZkxTNnJpcEo0UG0zMHVxdjVYQ3NlVjR2clhsZnRINW5ST25TSVVmbXRXZ1plZ01KZE9ZVEtZdkZpcldJMGVBcDhHekdYWTU2UDlUWUg4dnJHK1lZazBaeXhUcUdOUXR0Nlh5UTBVYUhWQUxTOVJiQjZDWXlUZkdHWkVRbmVDNHFveGR2MWM2elBoSExZVlVqUTVHSGdJNkxXWS9yMlhFK21qeDR2UVkxMFcrYms0M3ppWkFndmVHek1mMXI2ckNPTy9CbVJhTm1PSGZrSVM5bVRIdUppbGUxTTZxK2Q1V2pOLy9aL05vZnR0d3RoenFad01SSitHL3FKWlZ2dDdIZUtKMVI5ZlJqRDBSN0l4WkpwOEVPMHNlRkJteEU5Y2hybS9lSkt5YVdnWTVvSWQ4VmgycUxXVi9mdFdRWFdHRzRPSDR2c1dNelBZTDNXRmJxa3UvMGtiT3duaDQ1eWFGM1g0SXRXUTcvTUk2dDg1SFpWNVFQN0pWZEE3bTgvcHVWczV2UXMrS0FZTjhraitRdUliMFgrc0JsN0hGMlVXV1JDcHNwYTBhK0dmUzhTVU1lUmZmNGJFcEVmTkRUL0pTM0lFbS9UREFLY0c3ay9RL2tQQ0Zra0pXRGEyYnNPZ3Bpc0dyNC9JRVFRdTVINlRUTVZqNzVRN250VjA3eStHOWltZGs1M3ZCKzVhRVdyQ0VIU1kvOHBFQmJEZU04Y0J6V1k1TzhvbTdPZnFhUmhlNEhncTYvSWkrUVRqYmJ6VFRGdUE0MkUwTi9Rc2luTU1OZXpYZzdZenBCdTAzSUorQ05WM1ozOHUyTXZxNXk1YXJHWGNidnI1OWJ0eGFUWHVmckd1THNoL1NnL2ZpdHN5OVpPME9WMVArZTI2WGQybnZSdWxWZlpmK2VvYnVzSzNieTRyQW1zRWZpZys5eHZHZEFNcDB4WG1mdStOU0tBTFRqTW1YbWJlVWREZTI4YzBnWkRLdVl2WHhKcVV6VUkxbVdlR1RBV1ozS1MrZkppL3l5cjJBeURqdVFKbHQycVdVaFhsOG5POGN0empLRHJRajlxNUJCVHFSQ0dPVEU4WnpDZ3JyMHhpTm9TVXprczBncGk5M2pUQUsxYmI0ZmsvZm4zdzE4ZGt0NlA1Nkk1dE5CNXE1SGpYL1BGRStvcU9QYzhSS0dueWRYLzIyV2FwZmVQemVDSGVYYWFjZzNFWjJwV0g1S3V5NGpXQzJpcmMzYlAxSkdUOWZNeVRNYVIrVmJ1cFRtbU5mZUdPNk9vTk1zMHNEclhIb0hLTXBJc1VQWHZNdnpjN3pQUDBvWldvdUl6SzB0R2IzNWpXQWdSRFprb1RvakE1MSsrU3E4bmlMUEJ4OXBkUEUvUTBkeXlyYWRLMGJhVlM2UWtLL2d6RUhVTytXT3hxTFc5UEJxd3hCMWlYU2hoSHdubmwzMmJHVTAxQ2NWaHFOQ1ByVlhJMytNS21YVmNySldoajlDMGh4YWkwaWpuU01yc3VvNjFIUjRDelBlc1ZjZWJlVU9sV1VObnBrem9wNzh5UFA3a3NiWElrYm83YmNkWmJLZWFaanZnbGoxMTVxVm52bE1ZOFpZZkFpV0tSbEFOZCs1VWpHd3lCQ3hHQjVvRDhDZTZHSFBOQ0l5VXNKWGdsdFZ5dERreStoMVMrd290MmFTZVo3U3ZLYnJmM0h3K094VHBKZWVUbSs5VEJBTlZSMmJtSUVpZU9kenNBaXQyTWNLbzc0RzdZWmJGVUs3MUEzNkNrMjBpa3Z5VnpWUUhhanB1RnMzK0lYZDhveHdnQkFTQmx4RHluaFNqbVp5aEozaUdrNk9DS0x2VW54R3Q3alpRanU2dXZxUjNLeXUvL0Q4R0pYbVdTSFM3S3pBUGg0MnREamJuWUczdElpeXFMWjdkNmJ2THN1SVA1eFZseEVkWS9sYXJlYi8wTFJVLzBYeXRlcG54aklnQWxkdnliVXNzWlNSUmFNTmJIaXY0YzZPbVVIRFphQVBJOCt5NHMvc0NyM3pmdnBPc3VlT0swaS8rZXcxVUVKdXpKbHI0bWZGcVBMdGtabTZhSFFJSVN0aGFINVBvdXZYM2x2djhzZXBzY0tBNXlmL3VzdlUyYnBYZG1oQ1NKREo1c295dFhsQ0dXWVcxYk9td2QrbzNBcnBqZWdadmhRMi9HTVl0WDNvajl5N2hLSkNQc21Ja3U5Z29DK09kdWZSTjZleUl1dXJmVDd5SUZ4TFQzc1VadVVqalc5Zi92K2xuelorVnMySEplUWlQTHZac3h2VExVQWNReXVpTHZ2RHcvVXEvL3RRSE5lN2VkWFhJNnhjamlhTFljT3RaOFNBeWZIYWlSWkllUzkxMnNWYStRTUt5MkszU2xkUzI5TFB0bEJHMlhhVkdYMGc2QzJkSUxMa2ZSWlFWa1MzbDllcjY2SWZacUdyMVBLVWZKRE9QdTkvdktQOE9uK2VzYngxM0hJWG9zUGFNeTFsUVBaVHViQWpXdUd4VjZUc0hMZGdzNTlKTUk3d2ZuV0MrTnMvZm5rN2lQaU1LeDdSN25XMnZQSFdiKzB4OFRkRnNWUzhqNDM3citlYS81ZW1hSFZ0UFpSL3lUem0wZXZVSHQ5YTFLcGRuOEVaN1VzK0djc2lSQ3pFU0NUZU9nOHhlNmhFQzM4MjJvUVhuVmJWZUhrWXZIZGc5V3pydXAzU3UyN1A1N0NHYTZjcWJ4M2FmTkgvYW10TW02WTdIakVqNmFKeFQzYnlSeGJGNkl2dmdOWWlQU1lPZktTaFh2ZnkxMzg5ZmNuUnRjSTFFRUplOUJxUjZKSjRDcVNQbG1Qa2NjTkkzSXpxSUlTUTMwUkNidTNZa3NQd2ZCenZTNmtqbjEzS28wNndGZVdPZG9aSWVxdURSanQyRk8zKzBjR0N5aTROWFZFWmtieWVITytkQW91Vmk0SFdpcXVsRWh4YjZqTU5NSTk4b1M3VW51ak1kNVF2TmRROVhjNXBra09YYWVnWXJmV0Q2TnhPbDJSNmthWlUxMWRZNjZnVlFsZGgwZnRySFpPSFl6VzRGeXF3bzN3VXM1WllJall3djVSYWRvbGZSaVhMNkprV1JHVkdyd2RWUlo3b0lUR0U5N1R6cStrSjdvaEoxTi8weUU4cGhhY28wVHhhL3J2eHEzMDVZa1lJY1pBellyS0UyaCtoeGpTbHNTWmhjMzR3a1U1Q1BoWnJZdkM4NXZmdWRFVXM4NUw3OVQ1dVlkMWV5TytYaVBOSlphQXBWcGcxRlNtQjgyeUl4OUI2d01WbXZvS29UVGRhOFAxU1FJOVJpTFo4NUljaGtUemorYkZZYnRKTU1QOU5FOWwzWTk2R0RpZXVwQk55UTViNXE1VnpsN3ZFVjczbWVZV3JJTGRsUnZORnBocStwRy8yYS9UcGQySGxDdG9WdE9KbDlMejN2aHNoeENENnhyTGtyQWVjVVZtcjQ3K2VSeHF0UlRCQ0NDRW5JZ3l5dDVqcVhkZCtmTHJ6RFRNZW5HWGoydE9keVpuMytPM3ovUXY0UGJZdSsxVUpuMmtzcHljZWo1cmpFa2dicERpUFA5L0grME5kMWxFTUlZUjhGR2U5VWJCRUtTR3JvWE1uditIdk82WVFmY3pRK3p2eTZBKzRuOGd2ZXhHRVBaa3NBTjBZck96K21KdVJGVUQwclh1eXQzdFBxL0RGUHZWblZHL3ZiQnVpVzNKU0l3OHR3d09KTm5DdjF5VjdFQU5tSVJjbm5hU3R4eDNvMHZpOFptNkZYc1hSaWl5Lzl0NnAxT0hsTDhkL3Y5dlJrMUhBODE1OXROSjYxM3Zmc05IeWczVXJpNURsaFZhbUxjLzJxNWplOHJlTHBLZTVqNUg3cXJsbXBJdkpiaGsxTGRzMStyTy9hSFZmd09NSnpMQ0lHcHN2WkRQM01McFVzcHVscE9Xb3Y2QkVqSXBuUEpKeEhTcFVWOTZmRXRnOTM1c0g0Mk1tRzRjL09YTlZ0MDE1UlpmOVU1YjlzVnNXK0JvaDh4a0pMNkxVc2pxaTdWaFpVS2ZvQ1cyWk4yVGx2Y2VVTG94RFlOMWtBZWc4dVVWKzVlaWJMeDYvc0hvc1E3MXhVYWxHNjk4dnA5WnBTMGkzZncxSmo4N2prVUdrV1Q4a1hkUlAwNi9mRWZkNWdwTnZwSmVqbzZBM0VsOXB4dnNpZmtLK2lGN1gzbU00b3JwbXhIclJ1Tms3NzEwamhKQ05xSzE3UE1FWGttQ1pxU1BmbGozd1lML20vZU82c2xmOVhtWi8vME5US29VbHA1REpVQkpnNWVJSktqdFNocGJUSGxtd2l1aXlkS0wzaWFidlNZdnFRTmNpRU1DMGNnUFR3ekpIMmFkQnhwNzFhMEh6T0FXdU02ajdKdXJmUlBkWVEyVGtJTXZ1cVhGOXhGcGJ1cjBSaE1qVjVKQXZRb1piM3ZzcDVORjRFZTVJZDNqbjdlMUw3SU9rbDJpSWo4Z0lEb3FSTVdTWlpaVFdXMWRmWWVKSEE3REllZkxHbXQxck1lMnNPQlNOemIzaGpCS1pGNXpCUDRrUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJDQVgzLy8xTDgzcjM5L1RzZ0Excy9NQTNreWVIMUZyNzNGYmt5UmplNnlTRjcwckhLM0Y3bnhtN1poNDZ5OUFza0hnUFM1Vm9kb1hmOTJXbHR2Z0R0OXZUZDJMSHJ5cElpSjdnZWFEekordnY0aDA2WldZYzI5T0RSSGtFR1o2TDQ5eUQ0bjlYbE5kZ0xMcEdRNzdGN3JOZlNzL1U5YWVkQzlDcjM5alJDallOUjFwTGtzU2srZDJGZzk2Z296aGxSUHEvVWVaM3BSazFKZkM4YVpSRERUNTA4WVRHZ1k3SG1HMWhnaXM3QUdhR3ZneWpUZ0ZtOXlCMnl0eFl1UXVmbGliY3V6bEpTTzRjVUNWdmxhUFF3MVZQdENIYi9jOXZkYzYwdHcrWFdqeFpCcEY5R1lHQnFSWmQ2bGVXa3NkUm5TL3RxZnYvSzhWdmJJV0ozaEhCQlo1SnVKdXJTZUhjMlRra2V6TGt0REhjdEdlc2VJNll0ZTg2WWlFZWVmZ1dPa2ZGOGJSSnd4UTBMbjRNWE05VFBqOXNvcC9helVLTS9YeDMvOWI3MUdrZ0Yvb2ZueStyelU3VW1MRFI3dnVEajVrM0dNcEtFdmZTS1cyZldPa1Y3cnBmVjY1eitnbkUxV2p5dG95VXVnVEVJZVFUUytpZzZtVmo0WkpQZUZFVWQ1TTl4d2IreXE1Yy9HZWUyNmRrd0krUTQ4ZTF5Zi95cFdQTlR3OHNnMFF0Wmh1dVE0Z3lMT05RTk4xTUZFSTIrUHh2MmF1dEZWTTAxSGJMNC9SbDN1bmdXc25uUm92NHdHV2toQTVlV05QZE93WjBnajZ4a0c4cGxHZWVXclgzb3puM3RvWlZSa1ovVCtVWkRBT1RvT3Y4VFF0N29GMnExRityZElJNC8zZnVXV1p2ZCtwU1BMWEVFTE5PTm95L2VNdUovMVYvMVlnbHFubVNPSVBKUXZNM1YzcG1lNUI0a0FXbEdsZFp3RE1pMmFJUUloWitBOXN0UFM5bDcvLyt5OVdaYmt1cEd1Qyt3VnEycis0OU5EbldsY1BRaFhHUm4wQUkzV0E2Q1R6di9UMHM0ZzBSS053Y3hBQjBrUk00ZTcxOUsyMG44c0VVVUxUTWRyM1c5eHVIVDl2MDFKRTYyVGROOWFiNjgrWi9ERlZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRLTCs2Ly8rYlIweDlmM2ZyLy9wZnNQcStRVTNBQjZDQjU1WjJmVGM4aENCeUFHTnlnTkduanQ1OWh6NE5Md25xbXJIRklFWUU5dk5lMXFHTjU4WmVZMlJQZjhqVTh2c2FhYmRTWnMwU2o5Wm1wTEg0UlBWMmJxUU1zWHJudWJJazBzbnBlZktqTUswNmZkdHJxMXJHZnQ2NnY2NXBLL1h0S0hubVFNT1RISmdIZW0xUW5ROGhaUGFScE5XM3JUYVlYS1doQVNyR2VuaGFCRlNXY0l4eG1KYUw5N1JGQlZRdmp6cGQxRjlxZlpySFAxSzZlOEowV1RkWmU3WDdsaHA3WXVwbEVaS096NTE1dXhVQU5iZ1ZUTWlzM2VVdE9TSUdJN1pBL3ZQYUFDdC9oR3huUEZ2bk5uUjd5eHpDZEVIc1Q2RFlPZHpITGJTR3RqWStQcHExSzJOeXp2SHE4MWFkbjF6WGtmcnd1RVZHdUFUaUd4cG5JVzF0RVUwZU8rTTh0UUJnTk81Z2g0eFl4bUtPbks4RXppU0YwMFhyUk9YbjVXblZqWUE0RE94NUpSbmU5REtHemlKTkxhekUraCtaeVZscUxMK0hiWllkckdUa0JibUNDdVZHK3Q1b3dwR1pOSDNvdVc1bWhrS1Z2SzVwYmx6M05RZ043WWltYmxUK3d4SUdwWVJDOUE3ZjRIS0NVTXRoVmQwYkJoRHlUc1N1YmpiOVgrTThKVk5rOTBOOWFURHpMa1JtU1hERXBXV2Znd3VSWGFycnIvUG9ibVNwRFQwOVVMcHk2anVqNlVEY0NhRHZrR3ZHckxDUGN1bEIwNUdUUk9ReHBveks1dmU2MW00T3ZoaUtnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNQR1ZPb0xrekVPM3dETm9zV0RQK1lUWllYckdDVkZtNFJUdVFibEdhWG8yaC9nMDd5Qm5IaklHRnRPUEIybHMwZnZvL0RFOHAzc1o4MVRxa3V3cEdkSWhPNWs4V3Vwb2I2bFU2ZXdSenhOYng0eHI1MmxKK1hYeHZFZitjVGNQcDNwNlc3MDU3M0hoMlRNS1BmUmxKRVpRRTlxME1ZdmcwTmRTdnpQdC9zczliVDcvN05vNGNpclZvL0FjbCtjVmhtalVXMkZKYSt2RUtFN1ZxVW81WUNiYVpKUjZRN2d2blhodDZoQmJ4S2JudGNNNjgwd2FUWmxSeE5kQlA1R3cvYVQ2KytYVXhzVGdjcUJmS3oxZTd5Ny9OdE5QVzlYLzZpejdnL3piOXMreDZPOWswc3pjdCszdms1VGRkV0ZxajFrS3JvSzFEbW1NNm90OVB0eDl0V0Nhb0JhZkFibFNLWTAyeUl6R3RvNjN6SnFnbnJxdGZONXBXR2R5WmpvaGFHdXI4WnRnRnRTeVg5bm9XdGZZWEhMenNlM0s0T3R5akpmNXV1cmZwK0swV1MrVzk0aHZUVDQ5dGZzdFN4WThDYzNMSjRtK3FFaWNJWVdxRUY2Y1pWZ1dEQUNYWXVYQTFDWjJYN2JYb1NQcHFwbTZXQk9ZUzgrVm5WbDJMZWp6ZXBkUUxLMEFQSU9XQ1BlYVdqUSs1SXBCcHJGL0VML3VhRnhYclR6dnJvYmwwNWJ5MHhiQldZTmxKQjlyWWM1WUNwVE1CTXpHejlZejJpY1pLODJUTmd2MUtYQmxNdmZwWHM3aFdpcW5pL082YlB4UXFsemFQc0NhVzlqVHVBUkVWTkN2NUwyaTBhRmtaVXVIV2pzV0tVSkZQeEg1WHJmMHJqN0g3TVh3WXNUMUV2WGZTR1ZHcFRYVWxac3k0cmpUNG1YTEFDbEd0YXVSOUpMcytJZUVlMlJFL3lwaUswWDhNaXJrRFRnZHp5VHBCM3Rpa0lvcXJ4RE9NZW9pOVZxb29NaU5qVWFiaG1XSmVuWFhHZVBadTZVaGhZOXNwNndFWDB3RkFBQUF3RU9CMWc3V2dKRUZBQUFBQUFBQUFCdG5Xa2l3eHM0RGJRMEFBQUFBQUFBQTRDeGdnejREOURNQUFBQUExZ0F0QXdBQXdKWDR4SFhwYTMrcG5abFR4NC9CQU05RU8zVE5lUVREeUtFMzBTSXZPYnk1US9IcEVWaE5lRTU2NEdMWlh4Y21PNjc0eUptUUVCVTNKbklhTXpyWWh5WURLY1l4R05iNWk1a3U4VlNKSzF0SzB3NHB0UnhwcmxrSm5Ua0hzQnJ4aWpNOXZjOEZDMGN4VWdFdGt1MWhMdDJNUExnNFhCbkIwZVU2bXJJNTY4Q0ZIOU5YSVZ3YjcvMFhjYml2M1l5ZUVPV05PM0lhMWNkZ05ab2xNdmdPUnNORzE2MCtUVkpjVldkMXRLS3NVNnEyT0NOMkJaZ0ZhN1VRaFB2Y1d0RitlblpuSDNGUzBxdEhDTWNWbS9YMlRCNmhMRUcvcUVVL0U3bVp4K1gxT1ZqdHNhL0RLMlZ0djhHdENYT3FzbXRpL2VtdjQ1ZFRHeHZlWERNMHFyc1ZJYy9SZk1CVDhGZzFubXR2R1pGMUtiMkd6UnorTXh4MjBXa1pNUmVzK2xobGU4TWozRUw1OEs2WkkzbFpnMGRYMXF0UzF1L1EycTUvMWh1aExsV3dCejIwZzQxWlhmRitWMUFwL0pnRFRYdThYOWd5M0g2TWtIRHd0cElsSldrOExnemNCY25qSm9uNi9qN0ZZOTlwMU9RMVY5ZVJtUUxBUjlNbTNkZkNwV1hERWliNVRRMis3RWpkb2t0a1R3MkVBd0NlaVdRbWdUZERoSFlUcnFVdnBkSjhkbXVNeHcvTkxTRFJCWXJUaUxONC9RQWplZExKa0xVVXZKNjdpRE9xVDZlRmorQXRjMGJaVnR0YmRhQmhtdksyWFpLNUl0YUZ6aVZ1LzZqeFdWVGovWTJpNzUvRTVocjJORnhJVFJtZFNsMThTZHhLcjZOSVE2OVozVnIzZjJaTUc4L2pWdWM5aVN2dGFWamREVDZVNXJ5bjNkL0FZSm1PVjR2d3lncE5FL0RXSWFLNTFlNFBUbTQzNlVZMUNvZUFBck94Tmg0QzlyNDFwMllndVVpNTYxTFcxK2UyZVB2WEkyc2dqOUpJNDltS1g3cDAzSDBQczdZMHFuSDlObjRhRlY5TUJZOEFjaGdBY0J2ZUlMQWdJeitkZC9Zd1JoY0F0d2ZUR0FBQUFEZ05MTHNBek9FNWN3bFNBd0FBQUFBQUFBQUFXQXRzYndBQWtJQ0VCQUFBQUo0SmRBQUFjbnp5M1BtU0g2OGVML0ZUZHBCaDV2Rk01TFlINnd5MVN5TDl4RjA3dXJ0MGh5YjJoeWthUDZ2My9JS2Z5eUlTSDl5WXpERW4zcU1ibm9KMTVOMTJqenNHUThycTU0L2E3S3hwRVZJNEY1OWpYamRtRm9jbzJnQ21jVGhCcThVenBHRGowaEplWHlDenp2aUt0TG8xbUx3VE4xSjJNK3BndGYxMlNSYW00am02MGhvYk9ZR2t4ZnI5Nm82V2VueW1XQWNrUmZnb01jenBRdGs4T0t4aCt3UThKM0pKQzhxQ052T3VSODJaRHN5QU1VUmM4YmMwRTNybmRXeXhVTXcrOHU4L21XTjczVkpVRTFEZU04MzRkTkthVUVrZTNCZFVtM090UEo2QzJ2WTN2aVBWNzFKbzJrTzg3VmFUeGtwbHc0K3RVRW0zU2VmR1JWWk5LM3ptQ2d5ZWhEVExQYlBlMHBTM3VQK1FNR3Z0VzZMS1dJVm80WFM2cnRBalBNZTFXZzIreFN0RnJ0TTc5Y1JUT25wbW9kNUc3K09YNHU4b3VZUHBsMUxsbk8zbk9aWlVtVnhhc2I1OFN1dlVoUHMwM3kyV0xEVktzU2NWbFV5ZWZzMnVxMWIvZXUrRE8zRFVJL2YzalMyTjE3VzJSSGpYVnk4ajJ1TTdsd0FBaHBrNW9MMDJ0clZVV0pzYVdsb3B2dGRwcE5VaDZlSVc2eFJGcWlNQTRGbDQ1cjRrcDZCNm53Zjk4cUwwWlZUeFM2cXZoRC8vek5RNHBVV1Foa3QyWWdackFkYzhYTnJBWGRrdXMrTCtZZFJhb1hrMUk3d3ZLNklrZVpVY3krS3pGQzhOd2MvUmdsWmFPL3pSUmZVS3h5MExNbThQNlN6bGpKdGpYbVcwT1BNc1RCbmV1QmRteHBUcHU2OFR2VkszVXZGTXhUUW52bDhpWCtnK3E3ZXp2ZDRDYWEyOCtqejdjR3QyYy80ZEtVK2F4a0l5eWNDSElLa2ZORXp5Q3pSSFhoZ3d3M2kxQ0V0VzBEaWM5aEc5dGxibFhWeGpQYW1XVUR3a0tBRE14Yk9JVmwrNGQ5aEsxb0puZU0vV0l4NUxSRmhLYXgvV3ZHRUVDelRjdEprdThhNnpVdnpMZC90UGhmSEZWQUErRVN3OEFBQUFMc1hURmlZc3hBQUFBQjRHbGo0QUFBQWlaeTRTNzF5UXNCZ0NNQUptRUFBQUFBQUFBRURtcVJZRExDVUFBQUFQQjBzaEFBQUFBTUF0cVAvNnYzOExQOExkLzl6NjYzK2c0WUZKdEpKRytuVzVkVWFjRmU3TmF6bVpCNVR3bmhoa1ZFWEs2cTN0Qk01SE9wVktDdk9FUHczUHFTWTBub1N6YlVlYWZsMjNaUVlUamVmSmk0WmJRcEdtOFo1cllxd3diVVpMWnNybThzZ01McTF2RnEwT0k0djY1Q0p6STI1TStJMkloby9FYW5RcERsaURWMWYxVElQZ2ZQWkc5WjRrRmFrS1ZKb0wwVHpya1lSMzROTHdsZWYwZXVzUXkyV2ZZeFhTK012Kys1M1VSbThmTG11dDNWZFEvMTUveHlIOVJ1Ly9Yck81bG5QSWx2bU91b0lya1ZrQ0M1TW1vMVY3TmZhaWhMc3pueFdQeHMzb2VoNlRKV3MzUk1Yd3pNYTNUTkJMS0NJcnRhSjVlUitiOEdlZEVmTDJ6Q1V2dXpXei9LN0R2MTl0cmFSc2p4VGhKdGdNN2RXcnRHdGxlMzByMW4xd1oyYXNoWDNhZ1MyTmRCMW1XQk1BWElxc0xyU3lqQm0rcEZsMU9UUHZyQ3VDS3h2TEp3QWd1bVhYeDMyOERKbXdFTkV2bzRiRFNSR1ZCa2gxa3pLTDJHWm1KWVM4UnhhaTZKNjdCblpNZFN4bldYYU1jVVNVbVNUMFUyYnN2b0ZTdHZTVllpNkpLVHlsKzVZU2R3WWpjK3FDaThNTWQxWlNkNWMrZEwzUm1PNnRTaFU0dko2eXV5emJXVytsbE9icXp3dWNyTERyb2RNdXh4S2RNOXc1WHBrNW81dTVMNkx1dm54OStHTmk0UUQwUkdYaUFwWE9PMzlYQWxjRXVjNjhVd0M1TkkzUkxZMlplT3R5dCs3SEYxUEJJM2lzWE1hQ0JNRDl3THdGeThEZ1dnMWFHQUFBd09QQllnakFGRENWQUxnem1NRUFqSUFaQkFBQUFBQUFBSkNCeFFCbWd6RUZ3QXd3a3dBQUFBQUFBUER6aWZyemwrK3NpdmIzNzVGVFRjQnptWEdBTzRuT1pTMmR4bVJsZmFuaFhKMzNSNDZaeWdXcmNhT25DSUFQNFZhVDZ3Sm9XZ1E5dmNhYVZNMmZqUlE5ZXVLVlZFYThtMnN5akNzdG9wcjFOVzlLWHRLVEpjdm1zbE9QV09USXREcnRZVzlQV2M4ZFNSdkU4NWlIYnFobHhsZHBxMUNvZmdqUjN5L2hIT09NMWFldmliWGVjdGVsZkpqNHJaUGk5RVNtRkpRY25XYmNqOHhuSjk2emlyVmlvaElTUTJBV2x2WG1vSG9OSmxxa3N2YWJ0aFkzb0RXOXdMdE9jMFRUMnZIcEY5cWFrZWIxbEYyMFZyczJxTDg1OS84Y2N5amRsMUtya0tZZXlxSjUrTkRHbGlTUTZtQ1pvK25BcDZJdGdaSXU1OVhBSS9hZWxaZUoxeURNS0tEU05JeW1wMGpUV3VzRUxXNXh4TXNvRVY0bFBtUDJMU2Q3aHFoSFRsc2Q2K25JTFhSdnExbkR0VExwKzVpNnVkQ3RlK1ZvSVZyWDloZFUvOTZscGVZd2xSNmw3S3JrTTFJSDhBbThjVXRESk9zRjY1RkV2dGZ2cXBWMXV2Z0d6eU9xMDh3b3c3dW5JVTJpcUk3b2NleElabURVRnhoMXkvZEl6KzFOajZVVGdNL0VraXV6VkhmdStyRjREWGlsYzdMN2tZZFA4YjBDaFB0c0pzVzMrTkZ3cjdiZXArdlRVcDk0TGZGRmZ3YWoybk5HK1pFOGVaSDBvMlZxOFhwYThKcm1NZUtMaU5iWEVmL3cyY3BvLy9kenlsczI5ZFI2dlVqV2ZRMXBycXplMHhoTk84aUlMOVRJcys5eWo4aXVRcE42MGpicG9ocHhLaFBHSnhleEpJVjNSRW5wTk1sSFo0b1g3NmdHTnlmamk1QUdWWGF3Z1RCZXJYSWpZNnBZZVV1dW9uL0l0U3ZQWG8zd3FOa0FyR0xGNWdhM01ET1gxcDVHTVlyZ3F1TFZQN0RtRTZMamdGc3JvVGhOUTFJM3JQaXpMSzhtL00zRmJ3dnJ0Qko4TVJVQUFBQzRJbEFrRjRMR0JRQUFBQUFBQUFBQXp1RjhHN3kreGU2SHJ3RUFBQUFBQUFBQXdCTjRxdjBMdS8relFmOENBTUNsZ0ZnR0FBQUFBTGdWWDNKUS94djVuOS9YNGdRU2tFSDdTWGx5VEhuT2Evc0lyQ05uSEdsR1R0bXk4dkNHZzV1RERqNkhSUTZWbHJ3Lzg0U3JkWEMxelVxczdKbCtUcmExc0E3a0VUc0RyS3huVWhsRHg2Zk5lazUvUGkyUlpoWVF4ei9RdVpROUNxaE5pdk5Fdk8weW9mMjhCK1pxT2k5M1lKeDE2aFdZRGRjTEp4Yko5dmptNTdET0d5dk9jRytjU0R3Zm52SHNyMWs3WnQ2RkhzcXVmNWZqV3YzNldCUHZWQ0YyTmE2TGtuNGxCK1VPUElqTW5QT3VhWTlobG1rMkkrOFY0dHRiMXNjT0JFdEdqalI2YkFhMmNDUHY0K3V1N2JFT3pLVy93cURCR2doa0pteHBURVhUSHExMG1mRHFpUHQ0SFFCOEpyTW5sOWNNOU9UbHhUT0JSOHZVek44K0RwWlpBRDZickt5dzBrRjJUQ0NwcVZXbDhkc01CNGpuMnpSY3ZLaDJ6bTFvYS9XL3k2QWJ0YjFIdm9hNUlzMUs1OW1zK0JOd0Z5bThKRmVac0IwWkJaTXRoQW5Ebm9aYWhVWHBvNitPaEY4MWNReVoxdjlSbFhEaC9nd2ZpdFRMWHZWRHUvY0dTUUErSFF5cTIzSG1qc2JROFBDcUFBQmNoZWpyU0FFOWc0WjczWkw5L21oVWoyaUpzaC9MTzgyRGh4TzF3RWU2NTB4ci81MElQMHl0eHJVUURFVVJTRWh2aEo4d1pqNXFlQVo5Uk9velk5NENEM1RlUnBRZ2pDMC8xYmp2YkV0dGY1SjJINGVuR005MmxUZXZPTllPN0lwUzZSTU5QR0ZZTTQyVUpmVnd0TDdTODFJc0Q4NUkrL3o4VVp0ZFZMb1FYNmJiVjNiR1hqWWVIMFBKRnYxTWVvOUgxdHFERHBUSEVoRVIwUkFjMkNNenFUcXJKSlVGUm5tREY0M3R2THI3Wjk3aEJscWgxanBhamZ1UnRhTHUxcXY2TThJYkU3UFArM2V0STdHcVp3MnNQM0g3ZSsyUUI0MHZOZjBXdlRXYTF5YjBwZXZmdktVNjJ2R2l6RmlRd0Njd3cxcndMb21YR0drckRFS3JBYndtU2lIeDNvVlg1N21Dd25FVXZGYUNuMys5U3Q5c0dSbFRJS1hhMHErcE51WXZLYTlDMXR1MURDclFvWEpLb0N4UC8ySnRCTC9NbEFRUkU3UVA1N1RIUHMvSU1pU0ZXM1VBNE9QSUtySFdaSXFZZ1Y2OE91eU12Rm93dnBRZXBpWUFuMG5Xdnk2cDdHQWRuTDBzSHN4WGZYbE1NWitpUHRIUmhkTXFLN05nWGNFaG91RnRZeHErd2h2WXg0K1drY1hyN2ZUR3M4cHFTcDdDL2RmY290SEluR09IWjFReEhGWG1OR1gySVhzYVp3MTNKdjUyc09vb2RLdkx6TE5yNnRld0pIbU16Sml0QnlWcFhjcStsMWRJa0tpazVOSUQ0T0xxYWdONEVkbGxzRFNBakl3UWw1dnM4Z3ZBRmRBbWtaR3NGUCtlaHFWSGpPeWZBQVpyQzNhVk9YQnpab3cxNzNpbWpJN3Z5RGFLdFJaZWZUZ0lQMHlsSTlzd1NpRlJnSWR0UnA4OEt6NXVlQVllU0YyL01HK0JoY2N5dE9JREdjNFBYYnByQng0bHBKRzQzaW9WSWQyeHpQMmROdVFtS0dacCsvc1VTM1VjcVlOMExTUVJINzhHcWhoNWxsblBuWGhlTTQ5Z3NycFNtTVR5bnZQQ2NhNU5xZG9VbVo4ZmpTYllwTDFQZUVIR3NVUzdwMjB2TUdDOVJXS29uSWsxY1FleWxCYmtaWWFRUjFMUGRHTTFwZ2EvUDVacHprbG5sYno3d2V1aFNjbU4vN2J0VGt5M21DQStkbzIwR2tyWFovTE9zc0dWT1ZGN1BuZTk4b3JuTXhwZ3dkSXhGYS9PczhMVUNLYy9ZMDJjV1VZelF5T3VsWXk5ZDk2UFV2K1dwbC9QeXRkYjlzajZlN1dKQ3M3bXpOSGJZMGtqemVjaWxXbTVJclo3R08zZzBseEJENG1XNFptd25ueTA4SkdKTzZzOVlHb0M4Tmw0RkFrdHZoUUhNbU1kL2ErYS92emIvenJwMWZhZDc3Ukhzcm1IMWgxdWNhVDN1ZXRvR2YzQ1MrOUxkWWprZjJXaWJYbW1NK3dNVmpxMkpLdk0ydmdkd05yVGNHODJlOEdleG9Femhyc2tiaWRObmZDWmZ0Mndia21aTC9rYStudFdiNjZVSE5ac3RWUWJxQzRQeDJQWFE4ZTlIYzE1ajd1L3drMUZWZlZ2TUtiQTNaRFU1MkN5aklicm5aZFpWZS9SMDlIVGFQQVJIMWl4VmtqaHM1bzlzcVhobmJmUzlWVWdQMHpsZmlXak5FWFdEZ2ZQSlRvREFtUE1ldkhvbHNQVisxc3NMazNiWHhZanF4bnRJMGtNaUlvYm9uVVdsSjE1Y011dUZiK1UwR1N5bEpwMTNYbUdabHlkOXpZU1FqUWFYKzFQNzQ5U1I2U21WeEpiWmN4YUZSeGxSTDZNV3ZzMm5QR2NOSjJjdHoyWDZrL0tlYXRkZGRiQlk3eDhGTksrOXdvbHhwTnV0T3c3VW8zNzFzSVRYTWN5MEtwNDEwTG9xemZuc0VZMGVlMDRuS3B0amJhSWQ5QVRiNFNtNVB5M0RuWXRLbnZWbUxwOS96aDFkOHE0N2p0NmZXMDF2RnRQNjNJTTI2NnJHSDRtN3l3YnZKc1p2VDliaDh1NGtLWVhQaUlxUjAyVUdTWm90QkZuTkhyVVpGblNzZDdHSDhtekN1RkZpQmQ1MFA1Z0JxNmtPYlphSTNuU0w1VzNRNnhJMmJubjlxWHg5bDlra21FTkJESVR0alNtSXJrUXVIZ2MwV1dKYXNrbFVEY0FsbkhtSkp1Ulh5bjZ4SlVjT1lPdWZVR1JHTlB4dlBlamNRQUExOGJlVVBwTDF2NHRKSHlHUFF4a3VCK255cTVScGYra2dCRU51aGlGUndjR042aXFjdCtxV3htc1czUWg5azZ1d3NRYlZXcXNQZW9aQ3BrMWhqSmx6VzVqQ1NVKzk0VmlMUjZ0Q3UxWDlzdXArcDVHWHBIMGhGblhaM0tqeGNJNzNMbWt0YmgrVENvT1BjOXdzSndOSk53ck1hTkZ0MFFlSTlKb1ZGS0NEeVV6WHpWVkpxSjJnT25NMEZpMHZHZmtTMVVBN1R3WVNWMEE0RzJNYkFkMmw1NnRkdW42UDRYTlZzMWJLc1BMU3RseVc3eU5EYVp6aGs1cldZRXpQUVZYZ3Z3d1ZSSlZFQVhnVFdEbzNZb1d2QTh1REVUL2VXeHRmVE5Gc3JGMytvYzQ0NEd1MEhDa0RseC9TbnQzQUNUZ2h0QWpoNVEybDdMZWp3eVl6NWVGVzVVaWV4NWdKcDdGYjZUMXU5NStGZlh6UjFWNldEeW1XTm8xcytxUUlTcklKSVhDMlBGTzFZRzAzUzVMZmlWcVJRKzM2K0FYeUppdkFCeUp6NlFKaFdRS2JjbjdscmpXOHZBeTBvaXpsNEpzdkNYY3gybXhxcGJheWxhbmxIcWxOb2JqQW53ZW12dVZjK05sa0t3SXpDaHdDYzU0eTJMVVR6ZERyNHcrcDFlZnRIeiswVEsyUExVMDkxQzlBQUFaWnN4dnFtaEFac3hIKzBVVERmT3VSODNyK0lpOG5acjF1MnMva2ZMODNNbkRLWjZxSUpndzUrUGQwd0RBeVVUYnhoVExvekRpUExNREdZbVBtUVV1amJRTVE2ZDlETFBFNjJ1NC9HVG9lUmZvbUJpQW04Q01WNjhLazMxOU1qU25RQjVzSEwyVnpKYkdGYjBjVitQbmg2bWVseHJMOGFVakFONEU5eTRhWjd3M0VpZFR4bHVHZThRVFFmM096Z29mbms5NVlNbTFqWmNxUGh4MDhIbEllenFHdFNDOUN4ejVtWUszaTZVcTdiLytNZHQ2NTZSOVllNTU0bGtiWjAxSnk4WHYwd2tkOCtjK3QzZFhXL2VqbWNJMHJ2VzJ0eWFKWjVtZVdwbVVyTEFnWlZSeTNacVN4c3JURzk4Znp5NTVIMlBGRjFSLzgrN0xQZDUvak9pMlpHYzBuTVp0Z2Z1Zmpyd0k3UEcwVGJEOW1sR1VWZ1dydWtXSkMyWlRqZnVlaWNuQkxMU1Y1dDNIVTZyZ2lNb244Z2dMNzNONUo1dDBydy9sdzdkMWlaWWtheEN0ejFTME9SdHpZWDA1TmY1bFZTYVBndmtMcm9XbWowbWF1NloyU0huMTRjV0lOd1d2MFBDWUxOYjlhRjFHaU9hbG1ZVjluSGNMSnJNTzVNRmZsMXFEUkcwcjc5cG4yWEQ2ckdyZHdtUlovZmFMVzd3Tnh6OTUyNlh4UXVNM1ZYdjlUYlg5dCszaXlxdTNWUXViS3VScitRb3NuUTk4TXQ3UlFNTzAwV3hoalVSTEk2ZldoS2NlbHF0QmltUFZSY29MZ0ZNWmNRV2ZyUU5GSm14RXZiRHk2dE8xN3Y2c3BZN0xHd0J3UDd5R1BJMmYyZE9BckxndTRqcmszZGYyYXJOYytJaG0yWmZOMllGYXVsTDhOcWtuZnJUK0k1dFVuTUlnOVEwWGYwUVI4aXBTbnAweEtYOHBmbFpnMFhnZWk3QWFXVlloYTVLM3RKK2dmWG1WM251OXI5RmQ3d3N0UWlFa0hFSjRHRytUTWwzai9USnFINy9IblpZcnUrZ1M0aFU5T0VTc0w1aHhqS2dSWER3YWx0blRLRVpaNE1Qd0xxMzlQV25BZ3RQSStrSXphYVIwM203bjZrRGRKdFZUNkxiOHQ4Sy9VZ0xBTzFrNEZpMmRRTkk3UnZZMEpObngyQ2xubVJrZ3pSbGJHck82cnpudVdYUG5Fbk5KYVpDdlk0aTBRbU1GQmhPQmNNM2hsWUpGbnJWUm9YUndtaWpYNEFPaCt3NVlDZ0RoWG5JZ0lFUm5GemxGbUdJU1BnMXRMZmM2OGg2QnBkeFlqbkEwNW1QQTNQbEV1SVYybyszK21RdDkrOVM3dUdkZFJKNlhRNko2UWpORDY2c011eEV6V3BiVlNpTjUyQ25nQ2dmbk1uTmtTYzduSWx5L25aSGRaaXVmVVVZRmtXZjM0QjNNRXNpWGdsOXBORTNnaXNTYnVncHAzK0RmQUNESk8wYXJWeTV3TDFkWWRiVTJpYms0WERoc1UzQkpJcitINks5WEtMdGFHU3ZlQUptVmRyUnVkMU51QUFEbkF2bndJY3p3SFRjajdhaFd5Mm5LV1RSL3JPZmVPNWxwemJ6ejJhSmx6NmpuaFFVVzNkckJMMVBlaTllNXpkeVhmbGdhdmUvbVo4elVLZ2UveWlyM0p6b2pNSU9BR3d5V1MrTVZ5OTQ4dERjcXBoSjRON055OXpFdXdRT0lXR2JnamFCRFFweXhwZkVKdXYxVWxBYjgybDhHdDBMUjBpQ0Q5a0thdHZJbGk2bkd0WlgrTFdTT28ySnVxY0t6N3Y0NTVET2hDOENuZ0IrbnZoOURjR2xkb20xTE5YOFJoM2pIL09vaGZlYmxMajUzcVJZWnlTU3RDdktUNmZjZHY0VHJCVzBUNHFoMTFOSklQUnJKTXh0L0t6T3dPM0JJejhUYmRnUzRwbTlXWGJqN2ZSbjY2bmJjaHQzR2RTdFdTVVhOT1k0a2RrZkU4Y2pNK1dnOGpZbTE3eTl2YUljcVhEZnlyNFUxcDdhOE1UL2V4Y2pnaXY0b05Tc051ZEhINlFPY2htWGxtV1dyUTN4MWtIVzR4c2Jod2wvVTM1K3c4bFF1ZXZjU1FMd2QxczNYekFvTG5vaGtGUnoxU1JtcVRXZlh1RDQvS2QyME9UTmpldHhwaWtXV0RJOUpGdW1FaUVNejNNSE51Tzd5M1FWSEdrU3pYYlZyRGJyZXRwKzdNUTlIMjZYN3ZaN1J6VGFONUxldnc3RzBZN3JmZGRuaGoyQ3ZhZjYwTHp4NGZTYmVkT0FUT0dNZHlvelNhSjR4VDFJZWFKM2dFa1NXWVExdVFJOHMrVm9aR1VlT3RWeDU4K1RVRFM5WmxRY0E4RmxJVG9PSWJJUktmVDYxKzhQenF5WnJUVFN4Tk1YSVlqaXlBRWNIV2FhTUp2dzl5NExvOCt2TEdGbVlSL3diTTUvSlExOG5TUUNWb2lzNWtoZlVnK2FQY0NoV0IvZkc5ZzVCNWUrL3NsUENLL2xEZkp6VmV6c1JzajRZRVAyaTZtL0NuMy9iL3ZKNHdkL1dSdmRJYjNHenVDbmhVbnJMejVIWjA3REFhSDBvMGxJSmJvMms4VWozZTgwMk93VENhalR6cXNpckRwWVFCR0EySXd2dnBDS2w4RFAxaUk5ZEFpd3owRktzS1AyTElsZzNXU0xXdkVabVN5TzdrKzUvaStISVRIdGlLc0lEZlAwK2N2V25BbUFFT3NzNE1QVDIwQ2xxdENFWGJPMmpRdWNHWWVBNGVDUVJtZUdWUS9PUjFMbVpYRW43NzEwNEh5Uzl3MDI4N3ZuZjBiS1NocTVwN29DUWVaa0RmQ3o5UEVaM3orSWR5cUMzeklUa1RnME1yMFJlcVJXZG9YRjF6OG51NUxmdXY3OVVRV05zWFl4VUhaYUNGUmFBRk53N2FwWWo2bzVrM3kzTWlKYUllRi9WcG1LK1oxcEk3N04ranV1YVArNUsxcFVWYld1c21VQkgydEs0K3NnNTA1OEoyeFM4blR1YXB0cTFGVDlhaHZSMnVaVU9BQURBWjlFT2Z5d20rdTdlMWZhSHM2ODBmOWcrTjdnTzI1NEczQmpBaXlLS0d2MkZWU3VISHpsbHBGbFcra0Z5QWdDeXZHdFBZK1p5elBxYW1RZURDZ0F1ellKTms4aitKaGhreEdlOFNqaCtPSGZiMG5nYVAxOU10UnhiRllNZXpHWFdUOWFGck4veHJ0WnlySmY4eUxWNDhvVHhhN0xqMTJ2RUl1RGdBR0FHbklJcEhibFJqUHNrdUNqUnZFclYvT1Uvb2xGTERlSmg5dGw4bmxiVTZyTHFGM0pWdVc3Rjd0bVJZd3Y2T0MxUmhoRC9sYXdsbWpnNWFVZ3NyWWdtM0YvQjQwNlJ5bUlkWHhUTkt6TUZuNjRRalUyOXFVWFM4TkxGUS9ldVltdmRxMEVOSkZKSDljYzJ6S1VZMzNyK2tSRVVHWVYvdnA3bUw0dithTFNTdjM1ejZyOGoxLzA0OVJYOGQ3MXVmQ0c3NkM4YnN3bjM5OGwyZFNpMERreFJ2cWZINmdybUlGa3FJMnVIZHhtdHh2Vmw4TDVIT2N1Y2lHQUpqWm1OR3Mwcm8rVDBZYWNwTHRUMjVPN1RNTTgxbHo2NnE5ZGNzYlk3K2xkTGFhMk9qZHluKy8yYWFTUHByVEtPSFYvRitFRWIyMjMzZTlyYTY4Zkpob05QZ0J0UmRKM001bG02dktVeXViVGVXZVBUdXZYN1dWZEVOaTBBTzZJNkRyY1VaUExNT0Z1a090RDdFV2Jrd2VXbHFUcFNPdW01c0JRQ0FEaTh5b0NtYUlFWW9tTlN1TCtMVTNRL2hsV20yK0NQa0Yxd01tVm1CdXhvM2w0dm1XWC9lc3JlNHMveFJjd3BpejcvR1paRDl2azgvVTdmTVhEbVhhdnZmbVAyaGFxM3piM1dwMFZFZ2JUNDhEME42ekU4Tmt1MFNJZW83K085cXNKc1ZZbkRzdVRJU3VWSXM4eHNVc3VjRy9VSGdZdmozUW9ZRVozUWVVOW5wbXVGb3hPaGFUaXp5SXI3NmNzcHVEQ2ViY0hreEJoMXkyWllvSm85RDY3alpnakhEMGRTRFNMN2hYMmNtWE5ISzlPeXJEK3QyNzk4VFlzUkR5WXo0cU5qMklSRUpkY2dnVExkSjNjYnVCT1lWT3VnQXV5aXpKdi9OM25nYVhUUCthZzU5Q245ZTYyeHl0Vm05Z3VXajZkTnVnLys4c1lwSkJXdHpSbm91bGt5blR4ekYwbnE3YmJ2OE84VHNSUGxIUVlDSFVVMWtuZ2hMYWl5Vys0NVoxdjluRGJPKzA1YnFBYVJXRzMzVjhWOEJaZmxLdHJrcGVmSUZmV3NtV1ZIODRxKzl4aEpPOHlUYlBtOTk0THpPLzllYjRkRDFGMTRLUmZ2emwxSm5uN0YvaERJOFdralo4V0xGOUJsd1RTeUMwOTJRWXBNY0d2eXZHTWlSSitiL3A3Qjgvd3ozUjhBQUxEeHRLM1dGVWkvUm1vVEZ5VHZyM1hVeE41Q0tORmZnSXdNSml4MjkrUHBmWVdYbnk3RnFMalRrZ3lLK3NiOXVyTC9VV29mdC92NzdqTXNxbUpBK2dPVGlQdFplaWtLbk1ZSzF4SVhkMVQ3RE85b2ZKS2dCcDlKWW1KQW83MHBNMzh4K1NDODJ3bFc4MUhWZmdadzBmM3k1WTdKTGN3WS9DQkQ1bWZtanQxKzZZY2F0eDZtbkpNNktrMDNoNGp3UmxTTjVOV2x3ZlIvSUZIRFg5cGtBVWVrdHJYbSs4QjZYSTJzclhRajNmbjdCUkZhcXJVengzbCs4N1h3WVFoWE5WNzFCVGQzQUJNZTdiSHFEQmNXRFJicGh5M1JkSFNCSW5WUlh4VHlMbzdldHUzVHQrUzdXWE9GWHQ4amtzN1RYNWNDc1dzT2I2MmhaaWs3Nkl4OWV3KzBneVRGUEdrb05SQzNqdzlWaHBKZGg4ZTBDRDR2S2gyN01uNStPUG4zZHV2V2w2cG56V1JsUi9aaTZUelJ2RnAzeGE4SzIycm0rU3JjYnlwK2ZhSDN0elk5UEZVelpxRzA5UDltVUhUazFSSHpGcHlGcFczM1lkWjk3N2lOak85WktvMnJvTlY1UnhwTUZGaVR1SnFRR2U3b3lBTTFvMHp2Q0taRkcvYWhYcWdLWFFPM1BGb1hvN0NsYmF2cWIzeEJpeWpITDVIcjY2MXZQWTdZcmR4OUMrcGJzRmIvNGd6bjRxNFVFdUNxaE5ScklXMXpwdkhNcEtnRWliZ1F1TFF0Y04zZjk1WUJ3QlJHQnQwN1JIdEUyZWJTelhKSGNLWm9MZlBMQkFCOFB0SzJwM2NQQTZ6RCt6bTlmU0p5blYwRXJOMktkMjVldFM3TlA5MDlMbS92dGJmY1BxM1hVaWpCc21kcTZkcEVIdlgrWmZmaWFkcm1URVBUOWZGRzlqU2NHN2plTHh5SERpYU5XcXdqYlM2RlAweVF6eEpmZlphVkY5UFNmVTkrZjFBL21zMTBHK2ZWekhycElrUWxpU1JCSTFMS2t2amdZVmg3TnRUOVRPTnlJbkdHMmdCVUpFM0FxMzJNdXBBNGwwbzBuOUNPQnJmK1pBb0hZQlRQbUJ0UnNZc3NocVZpckx5MFBZM0JxbjQrSHFGcGJSUUJsbG5yMFhZOXkwS0xXcEtXdnUyZHoxZmpud0xBbVl6NE5ibnJwekZSc293MDVaTzdBSFEwOG44cEhMeWRyQk56VmJkS3IyWGVpNVlLQWhHdTA1RHZIcDJTQVlTaFJyRFdKU20rRkRZRHJJVzN3TE5Oakc2TWN2YmtVbmFwc3FmY3Y0clFoRXR6MUVYTjNMaHZqYjRhdk8rbnBaNXJzTXhHU3F6VzdxUDBWbkpqV2k0emt6SHp3ZjI1eENoZVZRa3MwTy9sQWZveS9kRm9aQ1cwSHV2YXcxZDZDOGdiRG9ET1ZVYU90ZDhmMWN5bHZLcVF0MVFuTEczZ05rUjhjRnk2YkprVWJ1S09UbUNyREFBQUFNK21oUU82OExNc3hTdG9sbDRmK0ptOG8xd29EM3ZxWUxpQzlNUFZVL0h1YVR6UXA3SmdLa2cvU3UzL2plYlhuR0xyWUhZWXp5ZVpLcXVBMXc3Y0FyaVozNEwxMW9PVkxsdm14Z29YaXptVU1NYkFRNWpsRW9WNG5vQ244U1hoQ0phUmZjTVArUG15ejQxZ1pnYjhKaUNETnBNYnVUL3c3akNsT3VMY0N1bmRXeW1lOWNDQk5xOGwxbjZEM1FudUJqcDhQaE5scGZaaUZRM1gwbHRWeU1sYzYyWEhac1N6aUFqSmFvVFRmT3Z4MWk1SThZWWZxdEpJSmxaZE9henppYndXajlYMkxWRG1pSEFJcG5rZFl5bWxsL0t6Ni9qM1M3OXRsNktGOHNpMWc2V2hNNk1RVUtROXY1SDFDbXVlem9MMjhZNXp5YnFWVm9JUjNSYkRRRUtTVUpKRUcwWFJJL29kWkduOURiTTlWeFB1bDZLUHVsTEcxM29QMWJqZTMvK3R3ZTlmdjJPOXBweldyeEpKMjlNRHpCdFZJN3JvZjM2Y3F2KzJXQnBqbzJDbEJURkdOUFpDMGxwNVpUZVEya0I0R20wcXpacStNeGZrbFlzOWJlUm8zbXA4a25tNFE1M3JFaXU0clk2MEhCdEdtV0phL3pvcjE2RCtYRGVseEVieW9IVTRQay9ieGFNMTVNdWtYMXh0N25iby80MTZiRFM4WGlLSjVvd0hua3BVVzg3RzY4dWlLdWYyYjBZYWVhbENYVWJ6VzdKbWcvbU1EdlJNM2xwOFQ1bXo2c2JsSVMxWFJZaFA0MWdUMXlzUVNyR1hTSStxZzZVUUFNQ1JsVWVTaWwrRWEzQU4yUDd1RnFyYVJ5eS9rU3VYVVNtK0JjaFRLUzVOTmVKbk9IT3htNmtKYzhyRWRyOG85ek9LUkZIU2VPeCtxUTdlZEgxNVc3aFcveFcraUM3TUxJckVhOEx6SHZaNk9uL1ZuLzlQK1VIcVNCNVJuMG9MM3BlSUtLc25NTWtBZmcwSHk3bGRtT1d6Q201TXkrVXBkY1dQK0dCRmZ4ZWVJZVBua1BLSTVqMXpUd044T0Y1NzM1dXVEK3U1bURqN0ZEVFo0UkN4S1Eyb3o3c1hrZEo5c1E2T3dpcFhLQnNCZ01sRUZ2RklQQzIrb1B0a1ZhOXFoSEZXaEZYbTQ2YWNkeTBzVER6SXB5R2lVN0IwOGZ0MWFSYlU3SlgwWmNtaWx1NWZGckx1ZmgxRHNyczVBQmg0aGhLRzJuS2FjVjBEYWFObGdadVRkYUpoSUh3a0kwN0x6NEpNREk4NlJjUERqWmFkakNPOG8wekNCVlJTK3VQVWM4cTBXOTlhMngrTHRYazBJMi9BY3dHUnNRTE1OUzluK2hZU0E2MGQvdmpKeWlzc1BHVjZOYVdNSzhtamFIQlVvdzQwbmxhbWIyWEtQSjByZXpIU3pESG1XWUVCdUFhZXVmWTJkeHlkU3R6VW1sVzVTTjVSTWUxTnJ6R3FTSGplRGZURUhhRkJMbTVrOXd2bElYV0Z0a1gvZ3VjZ0xSbXpab0NVMTZoNFhyWmVnelhNMUNORzh4alZmV2FVbFlubnFmZU1oWml5MHEyUk5wUUJBQUNjU2pNRVB2Vno3QlB2L2lsMWhoUEJ1aC9OWitPcEM5STc3VjkxOEN6aWl2Yit5dWQvcW4valluc2FrL1JtVnpia3NkdW9DRzNCSUtYcHZhN3ZPNDlZbURaZ090aWlYVUpXTEkrSVZNN3ROS1FKalJZS3dCMHdmNm45Kytjc2JSclRaQUtSenJEa0ZEcEVwUm5YMlR6UjVIUDRPaTczSEZYWEJLVDNHd0dnVk9OK0U2NE5QTzltM1Zwb2NBOUk1MlRXYjRkNUN6ejA3N2s3bGd3MkxkQ2g4N20vWjdWNUlFc3JydGUyU1lycnlVakMwUk0rNm8zdTgrbGJvK2x6by8yaytaNUxwQzdzMTJkSzRWczcrNGExdDhlYWNPL00xWlNwYXozODhjdDJDcW9VcnRMTXU3L1Q4TytQVTVzemp6SCtEaHJ2MDF4cmZyNkJrZlhIRWgzQWh5YW1ORnR5b00ybGNSNlJtTlVJQnhtOGl1THMvQTFTblZwMy85aDVlUFFQYStSSzE1eFMzc2R0aDVqRktMR0k5MzlUdEo5Lzl3YzBTSHBCaytlLzBXM1ZNM0ZmRWFRNjZHTXZ0amFlcWZlQVQwTWJheGxOZkZiWmIwR2JwcG9kSE0xWHl6dEtwaEVGa1RpOWJEWjhVbStMTmlsWDFyYnVaRWUwdFFaeVdHWDZMQ0g2ZGRMZnI1Z1dOZDArZEIvYjlxVnNaWGphMW9LMmcrUTBvdTNRSFBHOFNydjl4QUJzYUZzWVdYTXdrc1lTcDMwY3p2VWQxZUFsVFZXekVyUTRBRXhscGFMb25kQ3o2NkF0eE5Jazg2b2RrZnNBQVBDSHFHd2JrVlBnZlZTeTZOV29NOEt6cStITkkxckdtY3hjVEZjOEIvVnZVTHphdW1TYmUvd2VVWXNvNmt1SjdKUlpTQmFTNVlzZ2FYWUdZZjN4UVRXK1NwS2ZpbDV2OGFyeS9zYWhmcFRWYzBXcnc4eTVjdDhGeE9XV1pOSTBZb1J6NmIxZlRzMmd2cjdDeFJQSVNBSzYra2hxaE5lUDRTbXpHSGxaOThITkdWMUtJbUFRTGVkTWJiSmZqWHMzanFVOWlmbVJCRTJLd3hVS3dHeThBOWVLcHkzUXdmSHJqUzVwejF3VkNoTXV4ZUhDUDNZS2V2ZjFDeE9QazFPUVd3ZG1ya2NjczV2Y3F5NVpMc0hiZEQ5NXNIOEtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEcjU4dnlVMmZuZTcrdUFvOEJ5Q1AyMlhEZy9ZcnFXNHQ0TjdHSHJBbS9NQk0rZS9WZUZVTVMrclR5d0FGd01kblNOeXhJVnhmSVkwWHlNeTB5SjZacXZuZXlQNWN6NjhSOHZRTUN0dGxDWmNTNjF0bk81cDVxOWg5WEQ0dkRFbGZ2UllQRy9aVFluZmZpN3JQc3BrOWlkRE5STDIyOGJOVEoxRlRtdXBCcVVVOTZtWUg0dlZFSTl0bUJQUWhyOTBmR3NRYTN4WEk1eTd4bUZqNzhSYW56M3BIR2wyNDQ4cVVQUVA3YWpOV3RhY0EreVIzTlZ4Zjc5TzhmQkM4amg5OTkrVk8zNVZqc2xYV0o0YitiTDU4YUJ6YmUzL3FkKzNiZXB0bnlNUTlXQVZ6YmllQVowWkhpM2NLd2xLV1RnL05MT0ltN0tTSG1FdCtwbEZYU3FyRlY5ZFBKMUEwMmpwckRBcm5Ecnd2cTg5bVc1NWV4dTkvOXQ3ZHE2MHhtbHBzMWdkeU50eFhndXVDbVhxM2NyWmszMVovdWVYNTdYVnh0WWswdUpLOTZ3eUFkQTlVcXZXSHU5OHB2RTFMSkdmblNITDFsOXdIN1RsZGpaZWQyMTBFbkZ4NjJENEZtZkVjZU14c2JreXZmbDY0MGZ6QndEY0g4c1kzNUNjMmQ3TkhqQVBkVStqYS9nL2R2Tm1POU92UFVxS3I0azBFR2k0bGthSzY3VUROVy9TNklLOGdsRUZLckxnUi9jcU1uNFByOUNJNUNtRnovWUdldHFwZGxHN01xbWYzL3BrSmcydlh2K0hwdyt0ZnZPR1MzUGxnVDZWNExDV1BvUXJoZmYzTm5ITURRM3VmclBzSXY3eVVPNFdxZTlKYlRseEZPbEt2elZ0eGsvQnhjdndvYU1XakdKdFltSGdYSXFvRmhHVmIzMGFyendTeTJna0hsMHp0djlFSGdyakVaeEZaSDk3VWxGZThSdXhORDFwaTFLbmo4VzNKUzBMUk1naWt6TzNOQ3c4bm9pc0IrVlRoZ0srbUFvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZ4OGZmOVhQQzBDUDhVR0U3RU9ZK1B1R3o5bDUwN1gxckswVHBSeUZIa3VVcHRacHlad0RXSThpSHB5T1hQSTQ4cFRCY0FGaVN3SGw1ZzhIMEwwQUU0akdTY3poU3pNYm95SUdIc28wRFA5Tklua3VTL2w2VG1MWkdRQVN5dE4yMGY1YzkzS3dCeXhucnNvZFlnK2QrUk1SdWxhcW9zRktidE56TXRON2Y3N20vNXY5elVTcys3dUhVdk10QzFYbnlhR1NDVkJIUC9nYVJpUHdvZ0dsYkZFRFkyM3hVMjBxYlZTZU5ZdjdYemlVbnduWFlIWlJKVE9QcjZnUjFRUzNxUzAzSDBsWG1qcDgrZ2ZWbHByL1M3dThOOHZ0RFVqWnIrQ1ZTWk80cmxxWldQL25sWmRkOWRzclpxdkR2STZITzBEQUh4WWg1M1MreU41ZXN2MG1CeW5yRzFWK0xzSUZabHhiS1Qzd2JoR2k2QjFFbDBiVmpUMm9ZeFpoVVFhSkRyS3JQaVJzcU8yWjl2ZDllcVBYRzVTeVVjVlliL3VTdGRGV0o5eldOTEN1Zy9BT1l4c2FYajlsalROakJtV3FadkhQbzNtQ1c2TTFLRm5kbkIwRVJ6SjI2UC9GV2NjcnhwaHhjOU9LazRaa0o0VHl5d0F6MGFUUDVyc0tFbzZtaS9rekZ5YU0wTGQvdlBUa2FsKzhHaXhtdFZwcFpQQ1BQZEg0L1oxa0JieUdZTjNWSGtac1JneTFraTBQck9zbHo0L1Q1eVJNcmxua01veHNxQ2Z5alEvYzNuSXdBalg0bENpZXpEUkRWSlAzSnNJZk1zWE9tbFl2NFpEVnc0ZEd0SlFrWWJZNFl1cU5KOSsyNUZKTCsxVVpub3VZeVpKNzRsa2ZSSGVlbnRYS1FEQXZaRGNPdEtxbEpWYnpSbFB1MllUMTJ3R0FDeENHdGphZ3B4VUpMS1dHNWZlbzBkQUZ5aCtoVW96OXpXNUJVVE90cGk5Wlk1dWFkd2RmREVWUElySHlHd3NUZ0NBMndIQkJlNVB4VGdHQUFBQUFBQUFBQUFBQ0FPUENnQUFBQUFlQVpRZUFJQUxDQXNBUUJ4SURnREFYWUM4QXVEK1lCNERBQ2hmZjQ4TzRuNWVUOC94S2ZaeEY5YkJZT0RaWkw1azRCeFRucE5Zb292Z0pZYXhZMXErN210cEdLeVR3Q1JHemc0RUg0cDBKQktZaC9lSXVtYmZsbFo4S1UzMHpNOHhWV0RHeVpUUm82K3laM3h4NlpRemdYYWQ4Ti93MnVTcW1FY2phYTJiUFNrMGN6eVRWVWFmVjFQeWxySnArK2kxdnlqN0JhdFpkYkQ2MmRQVzlmQlhVOHBzWnR0RlpzbldobGJiL3Q3TmxuUnJ2TjFheVAwWlBMYlJDWlo0NW9ieFlGdEZaMUlrN1ZPNzhjZ1p5dDVvM3M3MGxZa3JHVVkwZkxjRzdRS0t2TmJSdjczcnJWaUpvaHVDdi9uWlgyYWpKZGgxK0kwUlBTOXVPMmFhSER0Tll6ZWFybngvUmJWZjh2OGtsVzNXeHZ4VmYvNWJ5WDJoamdBTW9pMXowaWlUWnJXMURua1BWTDNrZWlhSkx3NnZDaS9wZk5INmNQZWpockVXMTR0TGNhbGRQTVlHVFg5QjFaR3VWaWE2ZDIzVXl0SnMxbWFrdFd6UGJVMW9KTlYrclpTb1AzRWJhNE1kN2NVK1QydnQ1TmJoV3ZnNnRZUHZRV3V6VXZ4cm5jZS9ZZlVqMWxNd0I2LzBHdkZXZVhHSjQ1TExIelBtSVZpdTNSWEttbmZnZXBmbkNKN2xXa3NuS2JWU2ZDMFB5eTJycVJ0Y21aN3RCZ0RBczVHTWNLcTZiMFRsTStTT254RWZBVTNmNzFmMmZtSEpvWlB1SjQ5TlppRXRaTkdOTXM5RFNIVWJWWFlpM2pTdjkwd3JnOTZqSFp0OW5xZ1BYYnNuS1hkUkc5MXEyK3FvaytTWW8vR2tzdVE5amVoK2d2aVp5eXFWNWNIN25GSTZUMXd0YlovK1pqNFlTMndaVThkNmQ3RjZiQnhocUgzdkt6RkJZcFpPMjJTSzZGZUs4aEpOa3gzTjB1d0ZEOGFyWG1RR05sQ0p5QXpOUk9Id2R0ZklhcFRWZEE5WWZwOCtEaGVQaGdPd2t0RkpWL3c3ZGw1bTdtbGdLdjNnTlNQUVlHRWlPbXdtVDIxdXJkelN1RFFKaFFOZlRBVUFBQUFlRHZUY2QvQzBWc2NvV3dmYUZnQUFBQURnVTRCbUJ6NkxkNHhvMk5vQUFBQUFBQUNBQ3dMVkhYd2tHTmlmQ2Z3NUFBQUFBRGdIYUFBQUFBREE1L0FsQnpGTHZ2V0xWNXh1QXJKSXB3UTBQZDd1MStYR0VTcmU4OW9pUC9BK2pjd3hGNlE5RGdjRkMyMHAvWEtmT3d1d01IRUJ3SUJZZ0hXYW1IVUNPSlBVT2tHSHlrYXJhbVBkYmgyZlp1RTk3ZFB6eE5IN1RtbkpucXpyT2JxTHU3WUdSQVJyQWZZczBOcW9haVc5d3JLUDJYN0RVb05QYWx0UFp0SnowdEQ5RjNUV3pKSGovY2pCYnBmVWRXWVFQVjNzakNOSG4wcmdwQ1R4Mmtsa1BIdG11SmJuVE9sN0w2NjhIZUNVZnBvS0lCN0RYUGZ4RDUvdFZOS0kwTkdWV1NNOU9rdi9mZERHeHZaL1FiU3hzYmowZjZkeEUrUFVuN1p1cEwxZUI1ci8zUCtOdDFlYit1cytQYTl2N0pGYjFyTjRYSGtPZ0t1aGFjL1pkU09xdTFVamJNTHlPODZLUlRXU3gyajV6Y2piV3A2MDhJakp3bjA1Z3MyN0Z0ZlhVMzhGc2gyM0w1dXR1L1FnaDBLTjhFam5lRzNyYlgzYXI4YytxM0J2K1hFaFBkYVh5NDlmT0xkSzJwZTV4ZkJKR1k4T3dZVmJVa1hMUzErZkFhQlk2NUozVGRUaWFXVm9HcUExZ3pKNDA3NWxyWDRLVVVVclExU0p5emdqdUlHdE9Ub2lBOXFyTUhyalNXVnJmV0dwRVNQcFBQYzkrV0twQXdEOGdaUGh0dHNLYXZNS2h0ZjJ6VGZjMk51L0Y0MjViK1Q1d21zM2UrSjRGM3RQdnR3aTNaaDRYcXlCVCtORUprTFdwNkQxUmZRWnZRNmRJc1R6RU0zTFk1TnpZUjZMaVBpaVdtRGMwbjBWMWgvUjVEeTlYMDROSzRGY1hXZ2FyMC9Gd3IrblllZFJoTHBvY1JiZ3RRUDYrS1VjSHQvcWRwZHJrOFNyem5XWGZuUlhyQU5KS28yV0RGNlRLeExmS2l0cUZwMDRxc0RWaU01emlUZUpxVTlrWk5mRXV1L1ZyalN0eE9yZTE3Ni9FYTkxOFhjM1BJbTRpbURjZ1F5ZVRRc3J2QlRaNTh0dHF3a1R6V3RCMHF6L2NhYnpNRXNyL2hnc005QXI2UG8wNEp2c2xrWjJmekJqTGRKdzY1Nld4eVZKS0J6NFlpb0Fud3dXS2dBQUFHL2xtUXRSeFFJTVFBNU1IUUJ1RDZZeEFBQmNGVWpvendiOUN6NEhqR1lBQUFBQUFBQUFlQ3BQc1FoaCtRSUFiZ2JFRnBnTWhoVDRLRENnQVFEZ20vcXYvL3YzejI5VTlaKzFmdjNQUC9vdjlBSHdvcDNTdTNoTWFVWGZBdWwwaElFMnpmeVNmOVpCU09CRGtNYWFkVFFGa01sTXpENStzSzA5WjE5RzhwQ1lMenNpRFZWTFRsaEc3a3VDdVF2bmpuS3NRcDdOMDZGV21YMjgyWk9RYTlQVkUxMW93MWV3RVI0cFo0ZStHalkxajhaY2Vjcm1ZM3JXNWFqbytIaThBc29USDJ2YlhEekt1WFB5ekZxSHBEa21oWUViTTZ5emV0WkE3YjVXaVNLRVJ3UVVuOWR2anBVSjVlL1FyNEhQOHF4elgwaE41dFQ5N1d1SDR6cGRDODBKZ0JHMG1TK0ZyeTc3NDhhM0ppS3JFcjh3OGF6R3NZNTlIV25jYUI2Ull6NnBmUlQ2bWtVdy91R3JGN1NTenJYdTlYeXp0THN0M3JFcytvM1RLdHpmd3J6M1BTcXVwMHpwK2Z6cnNuZWdldGYxK2JvQUFCWXoxNjdSdGREUzNLWDRHbDVUQks2SUNVUUh3RXhId0tDL3c4eDd4bk5KSnFySDdJMldKY1dqUkhRN3J4bEk0MGYxU1FBQXNMQmtaVlNSZ0N6eTArKzFxdnVJUC85YTVsS2xGeG5mYnpFeUg5bTg4ZzQyOWNHVXZMMzNhOGtyTmRyQ203WDNNMGpQTzRwM3NHMWhJL3NMMGZBWlpZNzZJcGc4RGxPSHBLMDUzLy8rM2lnekJiUTNMK201UG1PUm9OMXF1Z1NaN3VXR2h2YmxWUHFSM1VNTEMrRjlIQzh6cEZTZjE2eDhlbWFvTGdCOFkrMmowUHRjR0poR2RLV1A1RnVLVDhPMXVqZXE2ZFRESHdZWWErQk1zcjVUU21MY1dwYkh6T0dmM2RQNFdLeTE3N05VOTBzUnRWQzNPTnE2RXkzYktpc2FmbmtjeGcyK21Bb2VCV1E3QUFBY2dXdzhrM2UyOWtONnVtSkVBd0FBQUFBQUFNQmZZSU1DQUFBQUFBQUFBQUJnQlROL3lBbDQzdUZiZ1Q4SEFBQUFBT2NBclFOOEZCalFBSUNIVS8vMS8zNittUHJ5Ri9HL3gvMzYzK28vVVpUTENnQ095R0ZwU2p6dEYrM1dhUkMzd1BzVGZjZFArNzBITWxodGl1a05Ya1JQOVZoeEhCUDRpN01OVnpiMWpETSsxNWJhaDVkeWpZRm5TT1RRNThPc1UxMGpaNWYxOTYwOFY3WmpZdkYzNTVVNVVYYi9kWnBqaTY5b0R6bFBUZWZSY3V2ajNWSTM4aEE1RXNraUsxSSt0bkVIc1hUYnpNQ09SWE9sOXg1c0JqNkVsajNKZStSOHRleDZIS2QxcTlUZjY3cTdsdUwzNVZmMS9wSHNYR2xpazJvemxBZnpGWnpGaU5veGV3NXhaVnBXd3EwWUZaRURla1lLcjFOdFJsM29GMUl6NmIvcjRNbWovdjdUaGlyOTgyL0M3alhMOWlycGxiM2RuRFBYMDczN0dLV1VwWU5PS2pOTGZQMEZJTUlLc2N4N2M5WjZ0VExXQTdnUXd0S1FVdUptY2VaQW5xS0hPTk43M00ycnl3UUFnSGNSZFJFQ0c2K05MVjBYY3I4STRXWWxOTHcrNEd5WkVadHRoVk1sN1FYdTBxOVdyRWFJZXZ1OHZvaitIaGQvSmpQSG5EZVBxZ2Q1aHUzd0YxUHBmUzVzTmZDcFJLSHV5WkM3VXNtVDlUM1FNbWhDYVVpVjkvUm1WRko2VFMrUE9ZelIrM0FzZll0eVJYSDhZY3gwcmF4Z3RIdXJGZENNaUJocllDV3ovTEFiRThmenpPSHV0VlFlTzhXOEx4UkNCaTFqcHBVYmpUZHpTK1BUaGdpK21BckFKNE5GRFFBQUFEaU55dndGQUVpQUtRVEE3Y0MwQlFBQUFBQUFkd1c2TEFBQUFBQUFBQUFBQUFBQUFuQ2VBUUFBQUFCTTRaUFZxaS83Wjd2YkVlRTFmcmdhQUJaVnVCNFlTOTZEQnJ4RnpmaFZmUnJ0QktGa2hhUW1ML1RVc2VLckZxWTltTEkyWUNEcFdFZlhCZkVrbTlFbG00emdSRmxPakVsQ1VST1NWY2pISy8yNXRGcWFTSGdWc2haTy8yeVp5ZVFkSk00dnlBeGhyYWhTZUpNdis1TlI2ZEdXWEo2SElxSjErWHV2L3NScHBURXQxSDZ1SzBrMU1xdmtlbFpIdnRhcFBSOHJnaVBEMkRycUt6TlV0UHRQUXhGOVo5aVltblQySE82cG5SRExwVU8zajdEcUdEbHRFRzYzaFdPWXVTejJDWTNySXF4UlFsejF2dWMwZFY3Zm9PdlNjYnp1MTY5cTF1MVhuMnFIc3ZaNWUrY0dld0oyZDYrOWpOWmpXbnJpOWN1VlZYZ3dYOEZzTXVPZTJrc1VTMkprTFJxdURwZkdhd1phNlQxNVcyYVJCOG53bFF6a0VVRkZ2NURhQm5zemt0NGF3THVJaFZrTFI1M0N6VmlieVNKU0NoT2ZsTm1zdFpLVXY0dEg3VU4reHJiRXpLMWl1dHFGZTVEYVhodVV0ZmduR3dBNXF2UGVIN3hpT21MV2o2NkRrYldmRWwzYnkwQlpnREREbitNUjZUTUd4TkVFTytiZGdtWFQ1NTh4bUZZTVNNM3M1ZjZXYUVaY3lhVEdFZ2dBOENKdFJXcmhWbnJnSTJCQ2ZwT3h4U3NYeWFPQmpsVEdXc3dsemRncXc2TkJTd3Z3RnVaMkNCaG81V2hwTWdxV3gwTW5rZFhTTGY4Nmw3K2wvRmdXa1pTMzV4a3NRWlpWa0xvOHF2QjhqVHpIRmkvOGhWVC9uc1l4YkJVZkl1QWRVMm0zUnpNZ0hpVFhZZVNWbVg3by9JbFAwN3d1YVJtbHNEZTQyU2k1ZWxlaUxWMFp5U2pseTVsSE1KRWVUbk9HVytvSUJ0QTBSclV3RG8vV3BLV2o5enh1S1ZwZUpYOUlyMjJ3aWZzTU1OYkFTbVpOUUV0MmJtSEtlQjRkNnJPM3dVdDVvTTRRWFNNbDh3K1lXRnNhRVEvTFNoM1hYT09FNjl2ejA2ajRZaW9BQUFBQUhzWTcxVHBZRk11cFQydGpqQ2tBQUFBQUFBQUEyUE1PT3dtMkdRQUFBQUFBQUFDQUo0Qzk5dlZjNFRuaDV3QUFBQURBV3FCdEFIQmZNSDhCQUpTdi9hVjJCazdCOFRkZ1BkN1RBd2pTbVlUV21XNGVWcHd3TTBUMDFNZEpTRzBNZ092MEZyQ0dDN1Z4Yzl6elYxYzdLb2FMWitWVmcya2lkZURTZUhIR0gvcnFUZmFZblVqdnpUNEt5bUJia0dxWHBqbnpiTkgrMStQMGErT3h4ZFpQMEZhYWEzUkRIUDlnRFdONnhDbFlnMWRwbjRUbk1QcVB0UnR1emVqYTV6bURUUEIzME9zcTNpanVBV3l1UDF6ZUVlaEkxa2EyVlJQK1hMbEtZa21wLzhSc0pGNFRESVhqNmRsLzQ1bk54Y2pwcUxxRStRcnV5S2lrNlBPUXJpOU5wTEx2ZWpCTk9mY3VCZDc0MzNIZTJJTWgyMHJUdEtJajJoUGZXaVNxa0tyOWhGWXVGN1BNdlgyNDViVmQrL01wdTVUYzJyeVBLK2M5UzYrSU1FTlNnU2VUSFhsbjRCM2RrWDJVS3ovdngzT0dVcFROYzBiZG9uckhtVVIxdW5Fek53YU1SUURBTE9nR0VoYjk4OURhT3J1dVZucER1eDVseEU1ZVVSZnRlYzlZbUZjKzM4dzhyWEVSMlZlSVdCVGNkZGFleit3NkI3Nk50TlB0Nm8rL2hzU3YyYnB6ZGRMaWNKWHE0MVZuK29jSWQ4YzBtZTZtSkYwUnlUKzhYL1FUM3hwK25wM0hkK0NkcmZTK3Q5NW5tV0xnaGtTMkNQNkFRWFJwWm9yeDZXNHBqQ0h3SkU1Y2VLM1hLS1g3bUlwbGpXa0tWRWJXRmk0c010V3V2cVZ4Q1g0YTZldHdoNlh5L2lZbW1wa1ZBQjRTWTRsekFLeWEwSjdwTUsyZ25xWlVRcXFVbElmUXhyWEk0VjZYTDBRQkFKT1IvUGtMSjVra08yY1dHWmVsRVluTzdmaHk3dUhSellXSkxWS0ZHMDNyZU85aXNLV3JSdUV6bEQxdnowcDVPY3J3TGtnblVMOS9nTk82Njc4MEpmN2ZjR3VNNmYzY3VwZVFaUldBTCtzTkl1VzllQitRc3d6UHJzT1Q0TVQwcEd5emFTeXBKS1ZEdDg3RVdwOHRQR3UvVllWdC9WWEtlTDAwMFY4cjhhTjFTRkdOYXl1VnRENzliY3ZXeFRqbVVidVUrUWxkcWVwanhPWGlZVjZDZDdQS0IvV0gwWEU5UTRPL0JGbFRUc3ZMdWg5VkVyd20yaW9PUytDMlRna1ZvUUtZdm9WRjc0ZmZOT3ZXaGtOWlhSU3VUb1VKSDIzVFE1bnpWbzlhYXJjZTh1Ri9ROXZ1dXJ4cThLdGZVRnR6cTJjdDNIcXQxV25MMFlwaDNRUGdIRWE4VisvUUJhVVo1SzBEZFVXVU1yZit0MXJqNzBxMmthc3ovQjBET3JMdVdxYjNxQU9TbXlSUlJweEZBQUF3d2lJZk9GQ0l0ckUzL29DNzJWOW9OZEpFQ3MvNWl1MnlaeXpNZmI1Ym5sSlp0TXhaWlVsbGU1amxvWk9lYTBTeGpPNDllK3FVZEx4SlZkb05vZEZ4NmxVdytWMTBDT2dFQ1oxZTJzdnB3Nyt6SEhVL0ttWFIrK1kySUUzdkNCdTF2VE16VFZvWm92WHdsSTBaQXI3eERyTGswZ0ZrUEpyTVNONlcyNGNyVzJLS3Vtd0JvUVRlU1hiU3pOaS9Ya1MwaWpPdHdvOGhZK2FES1l4TXVWVmJOSSthSTBRbWZva2h1L3NFcVlXaFJJS0hjUHBRMS95SHpZaGozRy9rdWpMcG9nWURSQUVBMStjSzg3Uk5pQkZqRTVyYUpzL0tUU2RubWhhTTcxb01yRHdqcG1VMnpzd3k0bEhYMGRTUmRZeWQ2YU5tbGxuWldNMVZ3c2V0MnlQT25Zd2xPVFBlcDhJUDBGOG1XT0dhRkk5MjA4ZlBrWTlHV2hNVnYwYjRYUWRHOGpadEZiQTgweHJXeUo3bnd0TFhwOSt5amorUzRkTE9kQnJGbmhQekZkeUpVY2xnaGRkRW1sdmdlZWxobG82V0ZWdmE5VHV3M3VTaTRWTDhrVThmUlBPVXZuSmErK3RrZlF5YnV3MTJXbXdJdHA4MGxRbjdHMExYd2hiSS9mZS9BTndIYmYyeTNtdDc1M2dmS1h1Vkt3S2N4S3dPdWFJTzhZZW92alRUSE15bW5mWGJGUUFBQUorUDEwZE1YY0pEYThYSVhxczN2dmFDa1JXUGU4QVpEKzdadkd1THl2VGM1KzdOVkFwOCs3OXJrWDZNS2JWMXhMdEk0alVwckU2WVE2UXM4YjYraXg3TEs4SzBCN3dlaWVhSXVpV2o0ZDY0L1k5VFY4eTAwVHl6STAyN2pxYXZ4alVBSmw2OUNvUTVXMlBRc0xwNVJJTjc1ZjNPQndUQUl1b3I5WVpiQy9OQ1p1Z2hFUDBDWHRNY25JcDNuVnE5cGZHSncrQnJmMG1OOFhvTUx1VzltZzM0YktweGYyRHNaUS90S2M1MGIyUGdQU3dQbkdHRE5SSHNXRGh2Z1JQUEhwSS9PRlVVMTkzNUh3ZEo1NWg0NDN2aVJ0TjZKQituUjBWYVc2aUw5cVVZc3l6cCthSVRWT3Joa2VmTjBMV0Z1Z3NSN2RmeGVzdU8rdnBUd21nZmFHVnVQeGFLdlhqOFdESHRHYzZaUElDT3RIKzlXTEdVSkNOWGhhYmNCMmN6TWpBTXZ3WWJ2eFN6cDJzMXl0SXNKVzhkb3F5enpvNWYzZjR0Ni9kcmNOdjkzMVJjMng5YmVGL25LajZDcDIxOUJOVmxBS1l4MDhjVVhaZTJtYU5aQ2FYb2E5OGwxa0xMQ0pYU1NFdkJESVBZczJrNDJ6eGlkZGl1a05TZytzbDA1QWVubkJCdkswWk1LK0tYTkNvdGt6Ulc4am1yY05menc5Q2pyVWJESlR1UnkwdGFkN253SHF4MjRINWtOYjZWNjlWTWJYdVI1eEJjamFpYk5oc3ZncVRrRlhJL211Y012VXJpeklHK3hxd0dBSHdxV0pBL0E2c2ZWWi9ETENlRHhNaFBpMllOVU00Zk84blBIaUs2U00rdWc2Y2RXakE4d21oZWtUMk5iSC9UYTZ1T1AyVnlUVHNNcllQMGZCNXZxSlMzQlZmMnMvQit0WFFrL3orOHNncmtTZE8rZXVpQ1hUVlRta1Y5L2pDUHdIUXdxTUxNbGdFWi82TjBQL0ptcHVnaUV3SXNyUXFBajhMakc2M0hKSkU1dUVLR2ZMd2VNYnFKNHkwRG1LemUwc2hZYkRQZi9jblc0ZXA4SGJ0c3ROa0JHR0NtQlBsa0preEw2eDA2elVCQWR3QVd5MWNMTHNNS2Zaa0RzaUtJSlpqRHpKeU1WQ2ZFUkw4TytiN0FITzFBWTRBRUdEWlhadE4yUnRZcm90dzI4dU1XVnFHYVhPYmh2cFcyQ3ZjNWZQWGN2cEJhMVcyb1VjK3M5Tnh5UDJaTEFPQXFuR0dUV1J1L3BkaitubHZNbmFndnd0UDQzZ2R2eVRCUHVDZityR1ZuaERNSFNkWm1UdFp4cEhtbEY3M2tEU3U5dE1nOEJnQ2NpM2NPUmpUMW1VQkd2SUdzNG1YZGo4YnhsUDFPUFNLNldBSUF3TjJCZkR1SFVUdlpYY2laK2I1RGs1enA0MTZoaUFEZ3dkclRxTTc0MFRKUEVVU1hSZnJ4NmV4ejdGNitzb0NqZmRTTU9yTlhuejJLQUFCWDJuYXB5ZkJVb2RIMGxwb01RUXJ1RE1idmU4aStMT0VWaXVoWE42dTNOSzdRRlo4NEhMb3ZwblltVGYzbjU5Wi9TcEYrZHI4bEFXQWxFOGFhNWI3TnJpT25ZbW40V3h4T2FqWmYxczBSUjRvWDhQTUFBRWJ3eUFJdVRYUGZOb3V3NXZwY0ZXRzJwdTVSTFdlcXRONFZpRndmR2pIeXRyTzJ3ZUpKSjlUcDlYZDExTVVhWFMxWWh6NS9vUzNFTmRCNnJqa2p0UVZDSTEvRzZWTkZrSHBiS3Z2alZQdVorNGhlSlNjam44RXZFeXgvUzhwdGNUaEo0bDNiaXBBTzV2RlZNUVlUL2VwYWRRNitQN3ZuMFIrblRoMGtYS0ZOS050ZllGVi9ERlBWSEgvWEYvNjZNZm1vZGRuOUZyaExvenpPUVJVZ2JZNzVDYzVDMDJRTENiTm1STllHcTBLYzZQcDNXYlNGMmF0SFJIVzNFWDJTeTh2anY2dmtEL2J0cmZiejNGNmxsVW52b1JwMStCdXArTHlMelZtR1pKTnFSZFNmS05ab2IrNGEydk9QZmtGVnN2UzBHVXJqa091ZjU3SjcyU3FqSHZQOXZ2UklMaWt2NzMwQWNuaTlPS0lJVmRJTlNpMVgvT3lNOEpaOVcxZEUxajZhYWxlZHlNeDZSNWY4SzdUWmpEcDROaWtCQUdBV3MyUm5aRXNTY3N5UFp5M3MvUVBVdHFhSlhXM3YwUnhYTGRDakdtV21EdGt5b3g0c0QxbC9Sd1R1ZVdPZWdYMjhqSFVpWVRtcXZKWlN4QmNSN1g5UEdhUWZ2eTliZDh2WlJ0VzdBZXg1aHRHOExFOHMyTWgrS2RXelpmY2FXWUs5VUlYdHBSRXBOOXE3bGlUc3d5UCtpTWp6M2Mya0JoZEEyb1FhWFVMQXg3TEpmby9hcnQwUER5bHVpd1hqRXF6R1d0eTlBMzNpV0kzb0VEUytaWUU5Vm8rUVRCYXNpZFBKZUE2eVpVVHJJSFc3TkplS2tBOE52elhrNGI2T29aTFRCYk1Fbk1pZ1JEbkRQZmxFb3JvVGVEZ1lHSThpN1JTWXlpYjlxL1A2SFRqS3Z2VGNPYlA5akxLdTBKMC9YRTN2aUw1Vy9EaHhQV1BQTnhzUC9PV0s0dm1IZmo2aisrOEtIVXlUQjlkdUo5dnBQbXIwajlFWGlxU1J5cjFNRVIzSm5ycjl0bW5zU1hUdjdQWlRudTBIck51bVZVMm9UNWlYNEdwY3hSSzVwWWZYSzU0aTc0OXhTNFduRGpQd0Nxd1ZPbXVXZHNMSWFkeU5ZSm5MaGI5UGVmV3N2djZxMXVsZmxQQlhRbnFTMjBrUkFKYVMwYmpQam5jNXNoVy82d092MUNORzQ1L1JwalBxa0gxdUxGa0FnQlZRVTBDelJXOXBoRitjOUZyNDg0ZjNOMmE3NjlrTDZrcUQzNHBmSGZHaUF4Y0xyODZkQk1HS2VuSjdHbHo0WFlHZ3Q4ajZ0YVIwNWhiZEt5SlpBcFIwM25OcjBkTUFnRHN5UzVzTTVmT3VQWTNvTC9VQnVCbXpweFkwMlFEYXordkFWR1o1WUs1c2dYN3l2UHY2ZnJ6djF1OWVhbXcvLy9ZWXhwd1pCNEJWQ05MRGVpRkE4aTNmQXFwQXQrSi9zZTNuZ1d0amI0dHBSbDZDOHJZeFJNbk5pYjRraW80ZXg3dDNOTUI3dWtuZC9UT293V3R2M2pOYVFxcExZeThQSG5ETHM3NWJETHlxdFhjSHRyL2ZuSFVvSkE5allXTERwYngrd3NUcWUxMWwwaGpUKzN1L0RQOTlibTlPTGR3K1ZwaE5GY3JHdXF2QU9TeTFLWVZHMUtGdDJmOWJoT3RpaENmYVBPS2NpTVFmVFFkbTB2azFEai9lRExwMnJDK3E5bXVOZE94eW1NakU0QVNWRk05R1cvbjNPZjIycWZRRlZHa3RsSnZtSjJZak9sRXA1Z3NCNXNmeDZ1NmYzMkJNVkxBSWE5WlNJa05SMWkvamVYd1UwWWZTbG9hUnhWelNGOTNwaVN4OFlUandXQ0dZckl4cWd6SnZiSm5oL1gzdk5sTGZDYzJ1cjFZSEM5TG0wdnIxOTE0VnJLbERwaVMwdmRMdklmZWw3aWZ4WTFpNlFUUGlXV0VBbkVmV3M1VFpIL0l1RFpYODdaVnlHbDdmVW1hNUdsMm1QZ2JONEprUlA4T0kvdEhuRVJsa1pVS1pWdDVTR1RPZWwrWUZBQUJuNDNVMVdsdVNrR1BYWjlmWFpJL1M1Q3hGWWxTSjZJbjYwL2VXczY4TTcrUngrQVhVK3N4S1kybnBuaks5Zmh2SjUyL1o3NWF3b2ZlMXZJcVN4Z054eU8rSy9QSGp2UFlCdk05ajFjMktuM2x1cVF6SmYvVU1nVjVOLzlVNWVWanBYMjdKNzRpLy83N0tMajR5dldxWk82TytDQnFYazVUSldRdUFqTEVIQzg1amhRdkpxMFhRK0ZwZGh1V1FwWDVoU3dPOEEwbUZ6MDdJeWw5bUxFMXZIdHg4dC9TSXFQdjhvM21PMm44S1oyeHBXR3NldlM5WitTTmVnSXhINUZZUTQrVHI5UmNiYzlBS0JNQmlocUdDWVRxRmxUYWp0NHZRbFRjbjQvY0ZiMlhHU28vdUJFOWttenQzTnhRd2Z4VkdQUzlnejBOTVN3eUxETE90RUNxaEZ3MitSc282N0hCdjRWTUtLcnA3aks1SUsxZW8yYzkzekxXL1Bqam9mdDViMGRKS3ViZHAvUUZQTTdnM0h6dUtJdyttTFEyalM4Yklzbk1GNTFsa1dWYnJVYzlSakc3bzBCRE5DaWlTQUV6bG5ldGR2eFJFTFpPVnJnaUltUitpRFhHWGhydUtIa0ZOVXluZURNNHlnd0VBQU55VFdiWjUxUUtqbWExaWhqT0NhcTFWaUZzbmxnMGV3V0dJL055bzcxRGVvRENPTXVQQVR5dVA0VElVdHlRT0xBVUEzSjBaWWl6cWIxd3RPbDJycy9mWC9nRGNHS2dwNEdtY3NhV2hMUjluTEIwZVQ4dW44Zlg5cUdLdlZmYlBGNDM4QzhBbzFta25BcnZYWXdYZlp6WFNPb3U2SHYwRGFKVWZlY0FtWjltVWF5NStLUkFaandFZGZoNUoyZGxITFVJV005QlVDRitLTTM4eUwrMDRlaHJaSzVDNStOeDlLUTlQQjN1OU1sYVBhK0hXV1l4V0hobEZzdW0zRG85Rmo3MzB1dGlxa0hrN3hLRFBWMTgvZ1BGaXJaeWVuSHlUSG1MNWh4VUhLSGlQSFh0eTQyL0RtUk1KVFlqZmgwMXN1K29zMGdwSHQxNlZ4WHJFNFNVS05xQ3dMMWUwRlRvTlY0ZTRTNHQreWUwNHJsczM5cXM0bmJrOGZ1ZEtaYTlmZGZocEwrMHB3aC9IRzVpZ2UxbVJiMXNBL2pDaThjMWFiOVM1VlM2OG5ubDFOMmw2U2cvTVhWdU5vTWJiWHF3clRoVitzMVdJc2lOOU5tQmtJSWlmbDZZSWtwMnRVMWRmK2hWeHRSakpMaVRCTFdQMzFtUGQrbWl2WUY3QnJGSStZbmxsdHpiK3ZaYnFWTng1RnBJbmpYWDhlbXNqZFNpSDJ2MytsN0ZxRCszUzM1ek1MSUVHSG9kbGd6VWxEWVdLYWYrczlNZnJ5K2lYSWNsNnlFNE5US21iTWJQRE5NZUdkRDliZGtSUjdBZDhuMzRMMCs1WG93NWFtYlJzci82NGFMa0RBTndjVFluUXdzRmE2SG9rMmY5Y09pbHNGNC9ZdlV2WGlNeGd5bnFQb3ZmN3NCNXV3ZlhrRldWN3puZE1OS21Ob3hhRDVTMm5mMGVnU296VnYwVUkxKzVUWDRIWCs2L2NQK3dQZG1IVXB4VENxL1I1NG5yTHNLNW5NRXRaZFR4L2N2ck8rdXBwSkUvWDhLakh5NWJJYTBTcWVkVUlTN0o0VENDckRPOElnbm4wNFZoTGZsUWQ2Y0hnV2M2VXJTc2xqVmNUNU83L1I0blBIVGJkczFNSkduT2ZGbXFOdFZZd0RzRjZ2Qk5zUkpGUXN2UmsxNUxoVWV1UXkvTmpwNkJYV0U3c2I1QWphZ1ZyUzRla3U0OXNhWHpVSE9rYmdqVDBsOCtEQjhDYmNBcnJiUlJYa21aM0h3d1J0VVU1c1BZQ2NCSVhFSHlhL1AwTVdTQTkzY1NHRnpYWWQzVHdoVmRUTFBZaWtRMk1qeVpqSFdiTHlJWS9CZTk4dmNsZ1JiZCtHSytYanFvZXJycW15S2c0ZlpCb1Z0dm9xbkQrZ3F1WFJPc3l2Mjd0VUJzb0hDRFBESi9LckRwODlNWVF2ZllhcFRNYWhmNFlJcXNmUnU5NzRnNDc5SXlSMDc5bGNDWG5ZYm9kOXM4YjZWWXR4emxwcW5nL2wxOHVyelJRb01HRDZHWEdxaDFZVEttYk1XT056K2JsTGNQelc0d28wYklqazhSNlhwaHZBSUFyQXRrMEIwN0I0b3kya0IxWVRuTGdaQXVRSHZEZGl5Y1czalU4cEQwM245S1NMNmcrM2FmdmVQNmtPRnJ4NVZGdm5tbzg3OXB3QS9CR0VBRGdEeVB1bk5FMFErNGNSK0xxakdjWFZpQzhBQURuZ1pkeEw0ZTNTNmg1TVB2MWtFZWgvSFRpNi9YWGFtNXE2SUhGZUg5dTd2Z3B1NVZWaVdlcFZ1bHlXRCs2OEZaY2lXK2RaZ01lam5jU1huNHlYUmhybmlzblVYaXpscTRwSHMzQjgvN3ZYSnBSQ3kzYys5YU8xc2hlZlVwcTdWb09SZkEzU0JwUGg5TThNb3RFSy96elMyK0FyMERJbXg2amRqalplTHN1QnRuKy9nMlhpcWhpQ2ZYbi9zaWJYODFWRmdRd3VBUmVzU3hkTzRkdkpsbFdxb01SN3RqSzNYcDRXSmFNTlRBc2hqUHRNNzlOZjU5cVc3UDI5NzBiVi9KYXFGL0xPYlp5ZU9YL3NPYlg3ci82U204RHFRRDhjSnF5SkNHOGMyZ0dIem1LYXpDc0JlSmJ5djB1WHR1YlRMV1AzSmo4REJzMG9zeVluNU5PanFLZFhkWHN1Rm84OTZjVVBIV1ZPdGF3dFVOMmMzdDl5YnQvcmtxL0NQdjkyTzFvengyK210NTJKUlRWRG53bElyWHJmNVRhZHZmNWRQb2FXSGF4dnArNGVPcXhUd1hBT1hqSGNXSGlHUnA2WEVVUHdKWGRMeFVmZzlYSUkvbVdaTjdST2lYMkpKY1JFY2Zldk94RllEN2V2Y3BzSFVicWpHVU1BTkNqcTlNd3l1K0FhSXVYRXY4Q2FpM3h0K1NwNGhGZHpFTU9BQ1llMndCQ09vOU5IaG1vWnlwSlBTdVVOYS9Qd0JzL0VvOTYycjBlODJiRWE0NnlwS3lsUFhaTFlYYU1IeHJWT2l5VXp1c1FWeEc4bkl5STluZUdPWG1KdzJBa3IxRVhZcCtHcXhJVmpZSDhSbGFBL3I2V2wwY3F0MkNaVm5yUGFJaXVBdUFHWkFjWkYrOWR5ejRROGJoZXFuRk44OHFXM2ZPcVQrWGx1YVd4aGlzQndKVnd5a3B0RGdWVkZ6ZGVxN0RIcStVSHJJSDNrMmtJYjU1Z21CbDZ0SlJHdW83bXZYK2o0SU82UDlMNGdySHh4YWVjb1hvQU1KRUxHRGFYRWg2ck5JOVNoaDRVOWlmWUlYbTVNRkErR2tzbldTbSs1Rkl2am1XWlhXck8zRUdWbmxtL3ozSzlRL3dTcEhYcVhFSDFiRGd2K0VsRlpjQ3dtTUVueU5WNnZHenFqVi9NUWVSeDEwWW56YXkzZTZ0eWxjVitYbjdFMUJKOXE2QUY3d1B3NlRUaitxT1JmaVcwaFpWaUN3MXJ4NTE3VHpSTDVpMmpXY3dzKzQ2RHJEbnVlZDdwWlM0ejYrZytLN29XNXRlNitDR0UyQ2NDSUlLMjdId003MXlIWnFXOVVpZk5MRHU0VGsybEJhK3R2TGkzUjZKNkNKWXdBQUM0TCtFMXpUREd4TFVoc3pqT1VpU3NYNDVVUjVtU3c4SzdDRmFsVENuK3gybTNEOEQ3azVURm0zYVA0dWpIK2IxL2ZXWit3TUxLSzFOVzAvTEMvajhBNElQeGFLR0RXeHBqQkg2VTZrMFB3S2RnV1g5V1dyd2RPMERVTDUwSk4zMFBRR0xXT2lWWllHQUFSNE4rOGFtQ21Wa3Y3VmhoQUVoNHh0YUpXYjV0R0hQdkhudGZjbk5XdW5yU0REYUFkS0FTQUhBQ0RpTHRMUVhhVkpxZlVsYVpkM3ZPOWZsS1FqSzZJVGZUUmVPMVJHYmthY1ViVWJuNzBkR0t2NDFtV0ZxMGJPNStSM2d1Y0FtOC9WSi8vdHZZR3NtNW5DbjgvcFlsZmFWVi8zcnJqZkVPdVJGQkZUa3hpQXQ3OGhyb0ZiOVdldUU5a3o0S2xWclpwdmRVR2FvTlIrdit2YURycDFaZnVEU1A2WTBsQTRCYmMyZitpRlhic1BvdEs5dDczcldSeHVlZnNwWjlacjVhSGFKekcySjE3b3NXNEpsRS9CL1ZFYzdsRVZaMW1maTErS3lsajhQYlFkbU9iUDExTzhianNNd2x0WE9FaXIyKzd0bCtyNzh2aFd0dnZscWNmajNkUGIrd0NnaGZGZzJWNlkxL2VGN2FxTDZ5UGJFcWlXM1pZTWRTam4rSnBieldMV3NRU1ZLa09PSmZVSGNEanlSalByYmc5VWhaUmNrckpqdjgrVnJ4cGJLWDJLeXJET0dWQ3NyTXZFZWRESkZCMG5QVzRLckc5U2llWmFrNjAyRFpBZ0JFaU1veXpVNkUvTW1SV1kvZENwWmw5MmFROXFDajZiMkxPT3RzU0NJTllPayt0d0JiZVk3Z2ZiWlpYcklJMGJwVjhxK21TR1dmMjFzSHlTTFFrUFpEcUYvZThFVTB3UUgvQ2o5bWZmQmJtVGg4SjlNd25sZkZxOHhlbnlXaWRSV3RHMG9MbXR6clZiV3VOenkrQ0U0QzB2MXZMcTBrT2FHK2dBUFNZTEhpMGZzWVhNT2NvZUdNbHUxOVUyRVg5MGR3aFljS3RqVEFsWWlhWnBQSHBHYXBSWFdCVnV4SCtWZzlJdHVQZDlDREgwWjEzdFBJemdNdDdxM215T2hyR3Y4Tis2Y0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGc0T3QxTkJEN0MxYm5UOEh4eTIrUXhmdno4Y3pSejhid2xVNkZ1Q1RhMFJTMXhJNnVJRVRQMGg4Qm91SmhXQWR1Umc4QkJmWWhpdEx4Tmc2OEoxeU5IbFlicTFyMDNCQkxXSExuQkZwbFNFOCs4ZmliNnN3amRmU2tOVWl5engyaENtVm42UHFSUGVtTTVPMlZPK2FYYy9wN1VrYnRVRk90Q3IvWEkyTkpUMXZKWDl2WGVYNi8yck5QL1hGZlNyWGdwb2QyUEtsMm9IRDB5Q1J2MkpNWjFDT3FFRy9rSktxSS9ZQnU1UmhwL1NpUy9BNmtmWTA1a3A1VE42WTltdk9VOG9YSVgyNzdmZUJ0N2RwV2x6NzE3Mzg5V2tRMTZ2S2JUeU1CMzJLNTlmcEFWUXM5SE9DdVRGSjhMUldzSURLN0xSdHFvaVZ5UUZPRnRQRGJFelVQMVh6cVgwRnl5S3NyeEtORVZFbUFhZVhYZlR3ckRRMlBmRkZWK3J5MFdjL21pKy81a3FwVUIrdExzVkpkaU4xVSsvRGQvb25kRjAwb2kzNDV0UXBmLzZndmRZUmZQZHN4NnpKZmp6aFRkd01nQmhXeEVWc3RXOVpNNkxvZlhYOGo2N0xsSVoxSzFLZGlNZElBMVJIZTUySDZEbzF3bXBmbVE2THhMZWRoSDkvYmp0RkprWEhmV29QTHExOUZ5dVRTYVhsN3d3RUE0QThaV2RpbkEzbXM5WmVMNTEzYnBJalZTaGl4Yld2aEZ5YXZvbUhGMHdhWnRaRWlsYVhkcjhVZTJKR0ZPSk5IVklHTUtqdWV1Rkw4cUpMSzVTRXBValE4dWJlaGpzRnMza0pSVWo1Y09CZlZlMDlGRysvYzg0Nk0zMUdoUDJQdVRNQVNXOXR0d2FVMnNvZmllaTJqbE5Dck1mUzE1MHJTVFJyMXArS1ZWcEZaRFpVRmlFZ3lnZUpWWlREWWh2RnFMbHE4VVczSzBpcm8xcGNtcncveXFwRThyTXA0eHhUR0hsaUpwTEo3MG5IeEErTTFxc3Q0cXhhUkVWSEw4elo0L0JHZWZxL0IrK0NBTk1hcytOSTJTMUh5cTBJZU02ejl4L0xUR1BoaUtnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNQRjF2Q1g4VnJqL3RiOTF1Z2wrQWd5OFJNZVFkc3dMUFkzWUdJZmVYOU43NDUrQzU0VGtZTVVQdi9nbk42cVVxTWw1bFZnVndOTVlPWTRKNkRpUHpHcU9MR2hjNjFBWHp5azRWRXpiekRneXBncC9TelcyenZ5aThheDdIb3hqSUYvWnQvMTkxMUdVa1JOOXRmdGNIYlZSMFFKNVdRTlhPTVgxVUh4ai8veDdMYldkY0QwZ2ZDUjFXVDR4eDN2R3poYm1hZHQ5T1AwU0t2MUt6K1BJZEhPMHFjYUgwalBRUkVwRS9DcDVlMllTRjk2bmxhcUNicjR5RTNTSXFsZzNqWW5Ucjh1VmpMTFgrbE1tNFZtUGFaaFB4K0hXQnZrcnFzVjFQenRYdFBuN0hWWXJtYy9Idm5tVlRSNzNjTitCWDRjRlFFYWF2ZHg5YWRaNnRHWU5RYnRXMDkxNjdIdEZKaGR1cWR2VktyRHNqNERXT2xyS2g2NDV1L1dtR0VyTjlybUFka3pMNWVuK2VtbGgycVllMThLK2JNdU9sZXBTRTJ1NjlCa0g4WXV3KytoVnlKTmRsOGduR1JwNVhwclhmMzdLcG12cjlvWFY3UXVxZldsOVhLN3A0L05UZi82ZlFtUDNBVGdaWGFQbDQvWjR4UEdvU1NyVmc1dkhFcG15c212NlV2dDJWcVlqTGpPS0pVeTlDaGhYQjYraFpHRTVMaUlkYlNtWXhZZ3Y1ZWx0RjArNE5hRWprd2NBQUdhUU1FWEFaQ0xyYjMvTnh2TnFPNTVDMitBMVJhdWJ0VmhMV0xzYU5GNlUyWHY0bE5sYWEwU3g4bGdabmpLeStXaDVGaUZQcTcrOUhrblBaSEp5S1Byb3UvY250aFJHU2ZtOUlwcUZlbUs5TGJ0Z1lWVU83a21oQ3E5d3daMTNpTmZsVDRmYVNudlhkTThLWlkvNElpVFRVeXJES3pFQWVJSEI5SGFzRmREanJ2Sm9FWjZWbjVidGNlTlVSamlHaG9uMG9CaHI0QjFJQzI4ZlhzbzhuM0FaSCtvemRSL3A4VDJ5NE5aNHpYZ3dEYSsrTEdGdEgybVdtSlNYZFQreXBmRVJROFpxNUlJdnBnSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDZjFYLy8zL3pYUHlWZGYvOHY4Vm5mMDU4a0FXR1JPUWV6dWM0ZndSMCtqdWpUWkk3TWRhVDBuNGxqcEFQakdjeXhFNmVKZ0VPV3hUalowSnVleXNNNmRqT1F0RWErMmN2VEdJZHpXZGZpOHJWV2pDT0VaU0o1dFJwN0JNbjhMSitGYWUwU1B4L2NPMU1HVk9aVnN2Ris5SjBRMUVqTDJGVk5mSHd5S2lGQlp0MlRtWTNtR0V0WThIMTQ5WWxESGpYVEZyTFVSdkJ0cmJaK1E3ZkE4andnUFRRZlM4cTVHRFZxWFV5M1NGOXhvcm4zT0VhM0N5a3VNUjA5ZEphZG9pNVVDNE0xWXM1bUxNenFNTTFiU0hEM3lZbmlGREF0cGlhd0tYNFQ2dU5OMUY2d1R0UEpDa292SDVXRjk1VlRMNjFWc3NIRzBNdWxYV2UzTStvckk0WWRvZWhuOHZLMWRXSFBVaWIvZHV1Zjc4L1hVMW80RDlhZ0plTFZUdmoxZVgyazljMkpqUFFaSlJzeERqNmhmSmM3N2VUdlZYQkRLMnY2WUlrcEhLK05SUEt6NlJBd0pxMUd6Um9xbnJsa1hhWWFzUThPYVBEUmU1SGxvL09oemh2VXhBQUJ3RWwxd3BiWEJTMVFCQVVjOFc1RWVGNms3Y3k4ZVJTUGk2ZkZva2xwZXE3UlhiOW9ya1ZVc1BYRXo4YTAwWEZ0bUxJWG9jMHQ0bEhaS1lCeFh4VGh4NWVrTnAvRzJ1QkRNSXRRMXR0QldwTVBBY2pzZWxtUFNkVnhlS2szT1MySzI2YWJobmZIU2FFNHRpUUJFOGJxZndYSkdOTG8rRDAxMldLdnU0WXZXSkIyWEp3MVBxKzRZYStES1JHV2xNdGxXRGZYb25vWjIvK09tWTNSUEEvTG9OTTVRUTdDbE1RNittQW9BQUFDQWI2QW9nWS9pY1FNYU14aUFFVENEQUpnRDVoSUFBQUNBMVJDQXU0TFpDd0FBQUFBQUFEanlEa3ZobmRZSkxDUHdlU3o4elMwQUFBQUF3S09BdFFBQWtLai8rcjkvQzdiWC92YlgvLzVqbjVocUhYc0JLdzlJZUU4bmpoNWd4M3k0SVBxTDlrdVRPVFRQbVdYa2pEa0FVbUFRbmNmRXR2Wm1sVG5SYnh6clBKN0lhcEE1SGo5N1JxRzNEc2F4a2JzMFdyNWMzak93amd4YUFUMWE4K2RmZXR6bDY0ZzJUeHR5R2RHdytITmRRZVJsMUttUFpvYWc4aHdqQnNhUWxGTkRkSEtpSVZxVTFaM2VnKzNBaDJNdUZTdVB6OVAwaTdrY1YzaEw3L0pqelRtWGhuZFk2dWtOcVV4NTV2LzlVbDJYcHBaeTJ0ZWx3TWNTc1JaVzBvc3BER3NHdDVqbUZBL3RLeENNbzVKa2xiSURkMThwcFhWaENqUk5VYUZNNjJ1bUVscDhLcThqZVhCNWV1TnhaU2VmOS9pVjArKzdyK3Q5bkgzakgvVEpRL3hkYU9FNjdiQmU3VXFZQkY4MEFKZEQxdXpXRFdQVmc2U0lwUkd2bmZhbG1PVjhpbE1wZS9TMTFYR1Jqcld1aTNGZks0UFNuUEd0U1dUbHg2V1Z5aWhDT0FBQXZKdW9MTlhTZ0hsWVc1Q245a0ZVczh6dVNYTnhlalMvczVUTzdmQlF5dWl2V3lKdkxaN1V0dDQyenlpcm8vdjczaklqVm9wVWgyaC9SdXBvMVVYeW1RalJDNVBzdTRpZ1Qya3FieE1hVHJKelNIbXV3YW5qZnJWaUFSNjdkK2NTN2UvVGVDVW1GV2FTa1VyUnZBRUlzV0k1QXN1WjRVTHlkdWRNbDVrNHREeGpycy9VcStvQ3NJTFZpa1RORjUyZEFwRjV1Nm9PdDRGcmtGTGlwalVRc1pxWWk5OHpveXVDMWpDNnZZYzBIcjZZQ2g0QmhBQUFBQUR3RHJBQ0F3QUFBQUFBQU1CZm5tb2ZuZm5jNzI5aldNRUFBQUFBQUFBQUFKN0JzK3o5OXdBdkF3QXp3RXdDWUJCTUlnQUFBQUI4TUZCMTV2RDEvVi8ySis1TUUyc25XMW04NitnaGNBOUdqbDVoeHUvM1NWbkN4d0NrNitnaHhXK2xLZmVzNDIyU0Q1STVPdytBSFhTTWpxd3BnR2VCNElwbTRWWFFHREdkcUxibitDeXBCS3VVRnJ3L0dyZG41R2lkMGVQdnJSTlZQV1Z2cThMSXliOWVtbjZnYnZUTHFPcXhuL1M1dEFYWHZ3RC9obzYwaTc0U1owUkQvZS8vMnFjTFptdHFqUXpqa2NPSHdSNUpURWxpcmZIQk5CcFhoQmFuSk5PaG02L01wRFBOdUlIUXBBakNlbXZLREc1ZG9YOW44ZWtiUjN1NjdsSnJPWGkxTHU5cGM2MHdFUStGVnpYemw4dXJWVDVkS1c4NUJSeDhQaDZMeEZwZlptalQxdHg5L1BDM0JGb2xOeW9YU1V2Y3hUbDh2Wk1VWW4zVmM4dWJ2VTJkbzFvZVREb2FYL3N5YkovR0kwQzlkVkNKYWxyTzU2ZWZaQ0R0MEpnOE52dHArOUpwSlY4T2tiNkVXc2xmVGEyYnNHWTM5ZktRVGh3R2pIQjVmWFFYZ0l2aFhVTzFOSklFbWJIT3ZzcFVNcWtsWG5qMTVGdkh3azNPRUFwZU4rWUlLNTdEYS9oRXd5MjNZMlBpY3ZGb1hsSVprWGhhSEdsQ2FoTzFUKytKQ3dBQVBWSHpnRXZmazFFNHdEcWt0ZW90L1pFZGFOS0M3RkYyM0I3VElONkZtOXNmdGVwVWpEeXQrbmlVSENsOUZPNDVaeEZSWWozOW9OMnZ6blEwRHUxZnFlMGRjTTc3M3M4eTVldW9XUUZ3ZFFHZW5VUCs1Nkwyb09RanFvSmJja056RVhwczBuMW11My9ZTXRpNmJXbUVvZFpuSDVGMDNQVUkxcXkxN3M4b0c2b0xNUEVPUE10ZkE4SjRUUmdyamtjRGtIeWpvN0l2c2FQaHp5eS81QUV3RDg4RWpQaGhsV3hvTW1uZW5zbmpSZjJsZkJHZkNiVkV2ZXZTeks2UTh2TGU1MFRBWXlBZEtIOHhGWk1HZ1B1RGVRd0FBQXdRam8vZ3JkMzhqc0l4cmdFQUFBQUFBTGdIME4wL2tZcCtCUUFBQUFBQUFBQUFGZ1BiZXoxb1l3QUFBQUFBQU54QWZRWUFnRy9xdi83di8vdjlvUzU3QlBiZkcxLy84NDk5MkpiRTJUL1JCNStQOVBQeXdGaGJjZExWY3FRanZLWDdmWnJvZ3dyeFBWVzRWWnVDOTRFQnNvNEZiZXM5ZmFzcDZUUnhsWk1obGtJU09Zc2srb1NSRTBhOU9JK0g5SDdseGxVR0tjdE01K25SYUYxYU1seExReUg5NWpuZTh5VG1scWkzMmZFa3JmcHpQNkpnUEpETUVHek8reURQWUZ1K295dlEvUm1rZFhmbG1XZUQyWEdJYW9Ra0xGWXcrWGxmdVdyRzZQN3FuVGE0OStONHU1TzlpOUd0OVMycUE3ZzVtamJ0ZGU5STk3UGZYK0RpWTJnblVVV2lLVldFVEFic3Y5N2VtU0d3SXA5SHNQS1FQc1ZBOGViWmxObDBLTFB1L2hFUjlrbEM1Z0Y1cnBiSTgrL1hXUHM4aS9CbDFmb0s1OHNTOGpmTll0clA1ZlBKdW5NZ1BDOUQxaC9wa2RKY0dhc1kzTXA1aFhtZlg4cmpPNXpLaW1Ja3VBclJCOVh5eWFUejVHSGRMMHg0MUt6TFBxOG5IMi9jOExvYlNBc0FBRE93akd6SW9ubXMwSitsTmIrUXNvYjYwZElnTmMycmxIRkZZa1I3SFNuVDIzaDNueXl6RGNFWkwxaEd5NkQzUFdVVUkyOWFsRkRXa201Zk5hWWlTdTJGU1lpVzJhNUNWNW5kSHhIWG9aY1JNNG1tazFRQWJ4NlpKczNPWXNxTWRnRGdCUWJSMjVteHdvL0twUkVxZCtORGxsOEFEa1RWZm1Hck1xR2hoK043eS9oWXZXS0dhVzdsQ2JubVJucGZaWFFMWnlZZnY2V3hZRTc4VXdBQUFBQUFBQUFBQUFBQUFESGdXQWFUZWNlUXdqQStrM2UyOXRONkdpTWJBQkFIa2dNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdKOHlVY04wVlBMUy94MHdKTk9Wd0lmak9jVWdlWUxvbGxJV1hwK0FKNDlVV1lxOUlCQ0N5dWU4OEZyczVOajZnTVZhV0plZnRMZGdNaXgrRUdpUzMzMHF6djZVUEFxSU5hRGFtZXJlUE9PS0VGUndTdWRNRXJLYXBISlFxK0ZNdGg4dExyMTl6eW44bnBHaEZSbTVHaVd4bDlXS1h5RllPR2Y5emhpckRGbzUza01qejFQVStQUGJwdElQNTZNVnpodDE1bGptaTc0MkxjbEtxYTNlMG9mZUx2Vkl4bkJiTHpycmdUWHM5SjFzQXo2bFRncDY4WmszWVN5clBCakpaakVFdEcyODVaVXhaSzJkYWFST0pFVm5wdStrYWRtS3NVUzFWMi93eUVFUUFLUGI4clM0S1g3a2JrbGFkeEZ1SmJ5dXJDRzUyVFNFM0FOMmZveWlLN09LaDVHVDdNNmp2R3BnUzNzc0U1VlB0eDdYWmc2Y0Y5QTVlSWY4aFR1YzdnL21TRFpmYVFSbTNBY01Xcy8xcFNsOWx1RmZlYmJHbGxKMjNKZldIMmxySC96YWJ1eDlkTXNUUzVMcWRWUC9JQU80UlVHZHhjTzBYcERKN2c4M0xwR3ZWclc4TzdUenFnUHJVT2ZkeVUzUnFiWUxEMWl5QjNaMy9kVXBoaVY0ZUpJOGFJUEtzR3QzVmI2cUZKbjFXbm1KcHhWbHZTODRnQVI0bk5wckVubE52SUFBQ0JKZEhHSFhKcFBadTJ2Umo2V0dWUWpoVW0wNERXOVAraVBWb2x1Vm1rVGdkTldXMGswc2hEK0h5VysxOHEyeW1nVHc3UDlFMUdZb21UN1cxUGFqVHFON0dsVUxwL2k4UE9zRXNCYXZqUG41V0lTVTJYRm5vYmxudXlia3V0eXEwNmN5NUhMbnZyUUluaWxPUzAzYWliM2VZK1lwRFJQQUhaa1ZKelI1UmV3V0txdDF1UlJGOUtaOHNEeVkxSmFGMVl0bmQ3clE0SUFCRmZHTWpXcUhYMld0YUNWSWVHVlRiZWNoaEhscmIrdjVRVzVsTVphNnlqU2NwTnBlbXRMeXlwclJoMHV3UUw5RDE5TUJRQUFBQUQ0YUs2ZytqN04rbnJIODhMQ0JXQUV6Q0FBQUFCWDRveDFDZThaZ1BWQXd3SUEzQU40Y1FBQUFBQUFBQUFBQURBVDJQMEFBQUFBQUFEY0EranVjL2c2M0huOTdEZHdGRXIyT0I4QW9nVEgxamFLSXdMajBvZGkwZ2VhZVdJUnllZjFvUUltanRTbW1Qb2dUSFNDZ2h3RHNzSjc2c2RJa2Y2cXJaUXkwam1JTTFlUXdmanVJeXo3MXMrMjJheXpranpoby9tL0o2dlJRcG80NXZqWVZtN1g1OEoxMUFSV0c3d0c2N0JPU1hRa0RTUUp4UU5YZ3E2SkV4WFA3UmhvOW9qblpGR3VRY1laaE9zVjZuMUwvdmtHYWozY0w2OXdIeTBaUjN0cStwVzR1cjVwQUxnY1VhdWhKdEptNDErUFNVK2ducUpxSGZ0ZmZHU1AzdlI4aWlCNjdVWFZzMXZzUGczanZnSnIxdE5wOXpQNU5PRkJoa2NRS2F1Ukw2ZnU1dWtmdGFQVW43cFVLUXV0c0o5L1QxZ2NvVGlEaTBEWE9HNWJKU281WnNDZHZMd0xiM0o4ei9VSVUvTHkrbGdzY1pRMUdEeU1QR2drN2NnZTNvbGlXOFN6RVppOWhxMEdBSGdYb2xPcGdIZmpYZnVsZDJWQ2E4czdPanlqSkhuVFNPRTFFYTR0NWpWUkZwZlBTSnlSOUptOTJQUWdNOHJLS0ZyV2ZRdk5FcExxWk9EcTFtNGZSZHRYV1VyeStVN2gzZ3F5NXBlcWpEZ3paMm5XRFhueTBCcTEwNk5TWE5xTGsvd2NNTGRBbVBPMm5CK0ROTSsxZVQyenJGWGE3a0VXL2R5UWhnNDd0S0w3WWhpWDRCT2c0MWt4QTBjdGtGWHovNk9YaWpQTlFUQ1Z6Rkl4cXNzRG1TOVdTcndFSDFGL3hIZ0ZnRFZVNDc1ajdJMnVCWmRiUzZweXZXQXVOcUdJNy91ZGlJQVlBRzdvL0lWall4NmFiSnpwMFNEWlpzSTJmRldpRCtiSjJmdkFXV1hHODBzb2FVZDBzQ00yYnpybmxjOGNNUEpLV0JKcG1uRWR6VE9LVVdhVjdrdHQ2S2x6N28yRkdpckRpK1d0YUdvcWVxYzllVFgzREdmUHNNaE11Mmk2cHpNNGhWWjI2eGxTNzdtTUtJc0x0Mk8xSFc2dEtKcnVNR2lzRjRib2R2TTUvRzNKOWxPRC9ZOVQvOTdqVWhUeHJ1Vjd0K3BDY2ExanRZVHI0UHF0RXdBbjRyRkVNbmxobUE5Q2JZL3ZmemhiWllPMHVHYm5zZVY0NmhSY0k3eDFpT2I1bmQza0VjYTlhZllxNnhYcDkvNldocnUyaXVxTDZIOFF5cTU4dW0xVis3cDJkVGk0eXY1N3YvOXg2aTZQN2puNWRhdjJXU3RVUFNqalc0SUNEUzZDSkhHbGx6YmZoYlhsYWswUkx0dzdUVXZKUGYrS3BjSXVsRnhiRHpqVEpUcERUbm5MOE1hWDhwalpKNVpKeXBYSlhkTTBrYklBQUlCamx2Nm8rdTBLdUNwTFhhTWpnMHN6b0RKNXRwSmYzRmNhV2J4SGRrNCtkNEVUSHBLeWFtbjNOQyt2RnMvRmpmUzdOclljd2xIY21oYlNiWVlEL1hIcXFVaHR6bkdqOGFsdWFoVFhjTERzTzZ0YjNXbFVQNWFlZDJTNFdIRWpwdVc3aUhZcnR5UzI0aHZ0QUJ6QW9Ga09wMFY0dE1oWjdxbWxMbi9GVWJsN2J1MkJ0Ynk0ZUFDY2lhVzZEMDVVS2ZuVjF2UkhUOE1sdm9oNzR4bjIyZlZIeTg4cTh4MTVnYi84L1dMcXEwVWJZNlVGWmc5NkJzeUdhdGYwL3NRc3JmaTNZMkxGdVJjMit2ZnJNUFdCQ3pyNWVzM0NHa1FZWkRxUkYvNmNjWnZ6ZnFScnBLMmFlZDI3azFCT29vTXZzb3FNdEpZUzMvc0ZtUmxsdWRQTTJJd2NyUU56TGVvUjNoRXV4ZkZ1RkhLT1FnaTB5Nkt0U3l1NkRVTWh4b2hkME1YeHFCOW5TbEp3RmhrZGdjSU53aTVQem1QVlNKa1JOWUpsNW5QMGVVWnE4UGRMYmZzZjVvelZZQVovOHp4cWx1WThoMDBMYnNpcThUclhObnN5aWgzSCtVT3NkRlpaYXNjRjE0eU1QZm5PWCs2TFgxQnRjancybjhLbjI3SXVmVXYrL3ZYNzlWSlAzclFvdTkxYU8vWmZwWlZpMDVWeDJxVDcyWElBbUF5blJWOXgrSTI2SXRSbHBzdHpwalVoMzh4bU5zaHM0MlNranQ2ME0rcHd4b0RtWE1FanZyUXgweFFBOEZSbXlqdm9vdmVDVzRlV0ZUQXI3Wm1EektyRGFLTnBQMVpzRThvYTFWTFB4S3ZFU0gyU3NVNW05V09mbHhhZUtFZHFsaW1mc1J4VkhHZnNxMXlRQ1NMR2RKbjloRWNPS0lyNnBieHV1NW1qLzVOR2dpUkpZRjQ5bU9RMnd3dGhHeHpNd1R0UFY3bXJhckhkTzlreTJDK25aaDhZNHc1Y0VVa21UdkpIYTliRE84RlNRUGhFaFhLQWthMkw3TlNaMmZTVHBpL28rUHI5YzNzYmozRUllSThVUW91RGQ2QytnQlhMcGhRTTR3M2FIcjJDa1hWc05DRnY4R0FtelY4UUlOam0wdTkvck1PcG1sQWtaNno0cTFRbnhmR2tPM05nMGxZVHJtdmIzejdrMFpTOGkxQkd0azVjWEc5ZTFuMHRQTEpKNThHcW0xVFdOcExualJQcnl6cFc2dktUV3JzUG05aUIxYTJTcDVhTHg0RTFieDVaMFZMa2JzeSs5RnVZOUI2cGpPRndOdDcxeW9LdUFVUzdlUVZwMnM4STc1Zm0xbzlTdlNMUXE5bUZOdC9JMStVa3pRZnpEOXlCbGVQV1dxZG1hTzZQeERKZFdPY2FhVDNUUkdFaXFNSlNXWWZjWDJsbDRvVS9KMDJmMHlqN0ZWNEsrWU5IMjlObzFzaTEyY2Y4YmRNL1h5ZHRrWFk0TEZCazNXcVM3Y2xjaFUzUy9WTjRQaVNiL21xNE9ZNkY4QXdRUU1DSlpJdEpjeXBoYXJKbHJoam1kRW1vVFU1VG1IazgyMEl4eVRiRUxJTkJTbGRLVHJtWjFiRWphQU82R2ZHNSt4R2p5M0x1VzhZWWx5Y0FBS3pFNC9NdkJYTHBIWXh1RXc0Vk10THgwa0tjTFhPRnB1azF5cXo0V2hvcGJmUjVJbjUwYjk0anhxZlZ2OTcwbnY2eDRvMlV3Y0ZNcHUraHBQc2krdWdwVHY5Q0tzY1Y2aUJ4WHQwa1A0LzExZEpWZGVIS090U2wzQnRMNmtiVFNYR0dsa29BZW94dGNEQVBybW5QY0RsbDVkSWhuaURIMlNHVEhVTVllK0JxUkdTaVpaSlVmOUxSSWtZdHpVY3VCWnpQRzM2aktYaWI4cXp4TGNYcjg4NWE0RS9rNjdlVnR6K28yWUxWSFZ3Y3pQU2xjSkpob3huWEV1aXloME5YYXlodDY3am9FdjYrN3RZa1dwU242VWpaNXgxcEk2dk1sY0xqL1A2bFg1ODd1MnpvL0IyUm9VWFhOSG9mWEpZUkNlSnhQRFFqTGNnaVRib3pvVXFzdG4wajlIaVRidHhQRnE5Y2pVZTFpRmxnM29KUFk0VXBqbm55ZzhmazVOenZwZGc3R28xazRIbGp3Vk9YTEpFZnNLVHluMkNqbktHUXRWSzRyNGxyOGJscitXbVBkMWUvSE5pL3BKZ3V5MnI3bVNvUEJCQ1l4WTNHMG1zcU5UbE12bkV5TXhTUGxnekw1dW5oS25zYXpiaVc3bHR5T0NxdnNjY0RBQUJnSlVQYnV5c013OWtHY1hTaDV0Slk0Wkx6d1hKR25PR3ZucmwvUDV2WjNyTjNQNk8zcmUrM1R3RUkwdFpVOEw0My9CUlcrSlEraUN0TFVuQXpNSWpleWhsYkd0TVFLbFVEY1FFQTEyTEZPd1MzUkdvSStNQ25nTjhaZlRaL3Y1aTYrM0hxUnZ2OWw0YWh0OEhGb1dzQnZjZkZuV2xYV1dWT0ovTEFGRWQ4N2hTYmpPUHA5SFlCMTRJT2dONHJKaWx0M0xJRWpuaGZKUEhFSmRHNDN4RnI4YVRpcjlOOTNpZVFmbVhXeDdlZXlySkdxdk9hbFAyNjNaajYwYktsVmM3cVdlbG5WbHk4NkdhbGQ1T1R5NXVydDJjQnk0ekE2S1p1YkpYall2Y3ZNL3UrbkpwMVMvS2xqMzIxOWNQSXJqOFpaUWVPQ3gvV3d1UVY0eVRLekRXS3F3cTY5NU9vK2oxVzM2cjdNSytNeU1nU04wNWxjQ0JIcjJZUTFTQThoSnZZTTNFeGljSEplRjhWektvZDNMVzFqRXIzN3pzOUlqWkpKRjN4dno5YWpieG9lQ01aN015enpsWmtqNmRPMmcwMThLdld3eWNYbUhEbTlqR2M1S0dteTJwYVJwczNMcDVlVnQzMUFVbldoZjkrblhTN2JxK1NXcDlQK1czU1p0WmdMeFdpc29Iclp0cWQzOWUwT0RZenRrcm5Db3QzbFBrcG5HRzhuRkdHVWphM3AyR3RnWmxoN1orL2ZGbmJ2UHlQZXlMLzFHbWhMNkxXUkpuVnVONllNU1lrUDQ0Z2w2ZnNuMVhsdmxRWEtTOXZtVVhJbThzak9oNjRQSGY2aGpNUDZkcUtEd0FBR2dNbW1wbUdMdkpnSGRrMUpaSTJqT1RwbUdGWVJBZHVkZVRGcFp0TnRyRzNkUC81K2ZlZm4zOGptckFWN24xMmFXSkhoQWJkaEpMaVNlazhhUXFUSnFKQVpoUXVVbFlqOTkwR1VPUFRMUUVDK21wVWh6M0krcFphUEs4WnZXOHQvVE5OYWMyMDBxNDlVODlhc1RCVEFFdGtvRnRMSGdiWjVjaTRyYnhRVFU3ODByVldtYWhURklBclFzZXgxK2wvd2tKdFdRbGVuY2RoTmR4N0taQ1VLRTljNnhxNDhlalJrYTZ4N25ONHQyYm9OVlFoQmRKeFh3V0FPeERVa3JkeC9oZ2hNR3BKbkZUa3lWVUVWeWZpSjhmZ3VRMlM3SDJEbUNyWFhnMHlkYnJDczNqckFEVThDNzZjK21hNEp1Z0ZXRlBTalpRSjNzYnE5UW5kQzNaRTM1c0JZVmFJYVFEQUw1aExTVVlVanVnN2l6T0o3ckpJYjVocGVadnhBamJLc2dFYXNKR3N0OHlzKzRHczkxUm52QzQvK2dKSjljZDE4NDZGR1lJcXp4bHQ5ODcrYVNmNkp5Y1hZazZsakV3SnB2bjlZZjMrV3VSczMvNDdiSzBXREo5ZFIyMUF6eXJMc3dSS1N6WGUxZ0FBbkVIQVhQZ0dNdWthWk5hSWFGK0hNajZibG9oelpqMjFuMEdCODBEYmcrdmlzU2VsSDZGdTk2bU5TZE5WVElFZC9XOWFJS1hCS1dDd25jS3RYTm1aeXNKWEQ4QXQrUGkzZ1NQK2RpNE4xc0FwUkxkVHJIam9sbXZ5eFVxVUdSdFJubndBc0xCK2J0N3NwRkpXMGFJanZHWG9id2FoZE15RmRTeFg1SUZiMlJXcFZha1VpQUpBaUdxeEdFQnptZFNlbW9JWGZXOVc4bWUxVk9sYXFWd2VVVFNoNlQwaXlWck1xcU44bXNSNkFkaDZTOG03YUdoNXpWSVFBd3VSbDlkakNUc2JCendLaDlUZit6eHFZcXh0WHl5dDM2a2o2YjJLMHI2ZnR6bzJKWTFkbHc5WTlWdjNyL2JqMUZMbVBLNmxTQUdlcUdlaHlaZVYvQ3NrTWFzdzR1ekFNSWh5UTllU3RJVHN3b1RudXBsb3RjeDJhOVU5OVVjQ21zTkFVcmVZYkFBWUpXSWxaTnczUmNsamhtcHpYdzB3YTVNTVBHa1Y4cXBPcWFtYXRwYmdxbnlaMGk4VEc2MURZUDIxYkZOYWh1c3RzOGJuZlZDa3BGbGpsTjJzMlZZRXBVMWI1R25NSnFTVTdjYkdwUHNiZHgvN3o5ZFhQVitjY0p2REVVYVZXWTlyWldiZTRINHM2TWZvRURNa2l5dE5kbHhIdkhYdVBPdWsrYS9sdVZweFhqbS96M1J2V3MvaGVVNXZXM3VmSzdEazc4cmtmR2tBQURDVHpQYVhaUGhLMXduekIwekNhdk5UMTV0UmIvK01kQkZGZ3NiMzVoVlJlcUxQbFZIV0pJVjV1NTlWbUVZVUxVa0w5M3J3dExLcWtjNDdLYkx4bFRTTi9DSHRZUnljREhxMjREMzAzZVJ4MTBseE0xOUkxZUtseWhnWVc5SnN6a2dJeWI5ZWhEUVJTYWpWeGJvSGdJaTFaTXp3SlFBM2t1elE0cGRTcHZvR3ZjeVdaenN3dHNDZDRPU285azZKb2RPODV2RkMvWG5Hbm9ibFVyazFVZk1KdnUrcFJMZVBabmdrTkk5REg5ZnJCZmdZWmlnV0pPMlhYdG9aS2d3QUEyQ1lMc01yVU5FRllBa1lWQjlQTHp2dTJkMWVpK01rdFJSelpqSlcvejdQMm56RUVOc0VVK0RkK0NFd2I5ZEErNUFvcXl0MTEweStHQVlmaENSRHJIZE1OQjQ2UU43cTExV0VCUHpOWUFWMzhhbEVYKzhEQ1pyek9ySmIwMmJkZDBqQXJCNGRHVVFqYWFlV1hidC9GMjdMdHUxSHFQc3lEby9oZkE0clh1cUxGS045c3JIQ1NRUUI5UmtzNnNmVDE5OVJlVFdSMFIrbGN1bWJlV015STJ1SE43NjBJWCtXejBnait1WkdIODk2MGNES3oyUHZBZ0RBRmFBcU94dzYxMkRVdVhCcVA2N3c5bzgyZ01USWd1eDlSYmtHNzVkeXpZbjNEb0Z3QnlFRUlmbXAvTEhmUEg2ZTJZY1hYYVVzQUlBRDZNdW44cTR0alZPNjk1STZQUUFuVS9OV1laZkYyM21VU3lYaVg0Zjhtc0pzN3dXMzlZR3VlaDkvZjVncStZVmFzR3NpL2lWc1ZvRUkxbTlEbW5KdFpEVWlnTHkvb244TDBrYXpkUEtSOXZLdHNkR2QyUWNISUFUV2pCeVNnQXEwcFNReTZMVVZyNHhYcFV0WG5XVm9FdHA2dXlpNkVkZUtYeEh5bXFCU1Bsd2QrelN0K00zWTZQTnJaOHJRT3RBMDBicDR3cDByOGFzS3BHMFBhMlIvYkpWVkg2UE1JSlg4MVg3K3Q0L1R2NFRNbFpNVmxITGRmMStFM3JmZGI4c2Jpc1JBMlc4aHFoaGVyUHJnQitwbElNb3FKN1dLRUoxbXk4VkQ5NE1YMWhLeFlkbHFOeDFVMFJWZHUvWnFWZEV5RGlvQVU5RDN5ZDZGSnZ5OXJKajhZREtTQnAreHNhUzh5NFM4dHZ4RzByK2ZNNS9BSzhHaWRlbHRGaS9OdUxidS80U3B4L3cySWlTVmZOanJ6Qzk5QlB2dUZTVEVyODQyUEN3V2hTd1MzUFcrMk0ybXE2UmRHdjBxN2F0T2hhbEc3ZklqUlpPcXpVQjdhVkg4K29WM2FtWE1leW44ak9sczFla2RSQlNxVE41YS81YUJ2R2NSSFd0RmpsLzdQOXBSWDZScG9ycHVjVlF2STQyLzAyZVdnaUJMeW5DNjhjVHdZc1NqY1JYNUhDWWpZNk56eDJ0UGV2T2JUWjEwSHdBQVZtTTVlNzNyRGJnV3cvMnpRbEdPcE8vTDl0U0ZlK0JvZk8xK0ZMcnAwb1Q3SS9sSDd0TndxVTIxUFhVdlhqK0c0Vk5odmQvZXNpM0JacVhUMmlFNGRxRDdyV2RFWERGWWZwNHRqaFllVGFmVnhadjNTbGVFVjJKb2RZaWFyOUc5WndEU1pId0lHSGh2UTNKalNmRXk3bmVyZXkyWktHMUpwZmJMTWRiQW5kbk1RcThTSUwyWElzU1BUQSt2aFpuWjA0aGFIcmZHdTVrejIvejlRRFM5MmJ2V3phUVoxOTc3M2kzWjJ4SlZMQ1NoMFYxLy9jYXdIRnVZVGVBQ2NMUFpLMEZBaXVqTXArc3dBQzR3V001aDRWS3U2ZDNjVmxXL0RSSVY0LzdoVXN2NndmVUdpNk85b2N6ZndndDB3alg4dHV6Nk5yWWNFMXhjNy8yUEppT3d3UHN3cGxJdGtHZ2d5b0JyeWZ1dXlzTmxTblpPWmpRK2ozOE5heUE0a3pNc2x4bGcvRitBZDlxRDNpK25IamlwdnRIM09tZVVNYnF6OVFxWDIxYnlvZEJON0prL0hwUHlhdTljSEtFMy9TVTdCak41MC90WE1KNVd6UE5KYlhpbWREN2pDek5ENXg5RTQzbnZleHA0bHB5U3hrV21rNlB0NDNtN0lUc0dvTXdCQUFDNEV0NTFTZHBrWGxKWUcwanJ6WE5VMGRLVUErL1BxckpLamJiREQzU3N3YnRpMTRybWgzNERleXk3TCtvZkVnODA0OUprN0wyVE9kUE9Cd0E4a3hXdXp1bk0zQk9BWUFVUDVNcFQ1YkZUY3NYZXg4TnBrK0xNVEFjVzRCQWFYN3Vma0RYdDEzNU1VUFk0RGVrZUFGRm12bkFqM004TTQrWER1eStnTXRkOW5LU2Z1MnBsT3RNMjQ3N1d0dUJCU1BzcEdCaHptV1JGUkdWaUw0cWtBMlNrN3A0akkyanVsb2ZiMnFqalNBcGFrY0RQQlErTmQ4YkU4YjRGZVlhVTc4dHlqQ0tyYXMxYXViaEUxbjA3eDJNT1RTaWgvZVJSaFJqUk5tK08xTFBIOTgyeGhob0ZhOWw1Y0dMYkVCSDBsRWNxS2l6K1E1SnJLd2RVbTAvQzRXbWgwU2tQTVlReXBta2o2YnhONUQ2NWtlZ0N5Z2ZxNUhtTHlRd1c0YlZBVnV5VldHcnk1NGl0NkJPTVBMbmlhV3hkdVBRWkFDbjlMbTJKVmEwS25ybEc2aUlkZmQwWXlYeDQ0MHhJYTlXSjFvSFNEbjl3Z2I0eXJCSHYrZlJvTGVTNUt3bmVqaDFxdTM5cC9OK3FiVzFiZDFHMkw2dTJMczlsZXVXblRQU0g2RmxnUHU0OURVRlVzbWwvUkdSenhKUHk3T3NnM2ljUjJwdkd2L3BWNVpsMWlyaHRxeVBjbTljV1hnTmxTZTNCWFVjVk55NHZLMXhhQXVIWEFnRGNsY2dXanBRV3JNT3JBM2o3b2pmcDB2MjN3bUNJUHFqWDYrSlJKS1I0WHF4ZERYcS9iM3hUUzEySTVYa2VlWm5ScXhoWjdhNEpxT2htbzFRWGoySkpKd3p0VnlrdjRYNjBxY0YwRHIzYzNSZzF2YkpmUWoza1FVUkpKai9MVk1uZ01mZWlhYXk4TE5QTFdobWtmTFU0NEdGWVN5S05SOEdndWlSUmpUWFRkWnU4OXU1Rm1wcUN0OUpEdWp3QWI0U2JGQjVmaEdVK0NjVm9VOFZybVVqNmlKWDJVVXVEWnBxTktOWmdSMlpMdytzNTBjWW9ZNW9NbFVYRFA0YUlXOHFJODJYbmtBREtBOGl5d3JQd2lXelM4YzN0RkpVWVhvVUlQQnhMOHdDM1lrUmN6ZXQyV0FyMzVncUtKY2JRT2k1dU9IaTlMUjV2RG5nVTBIcy9tYURNNnBjUTJMc3VSbGFHVVJ2MWNBOHFBQURmWUJwTXhpTmJJcnNxWHJ4dkVoelNLWkk1K2h4VytEc0hXNlROMnhaaFVZVi95cTYxZnY4NGxmcFdscFQ4anJaL3gxdUc3OHJyRTBCNy9DWFNEdStjVis4bzJ2c20yM0JCRStObTVKQzMvT3liZlZKOHVnaDQ5bEhlWVlQQzdnVUEzQUhJcUhPSXJwbWUzeEsyTXZpdXpKV016cEc0M2did05tNUxsSkh1aEllejFMSVBjcEVYejhDZUZneHU3cVJMT2MwZWZEaVl0UUNBSG8rbUo4cU1WZkxaVW5FZ3dBQlF1ZEphLzRqcDJwTDNJY3RDME5mbTZIRkpSYmtHOStKTER4YTBoS3BFTHo5Sk1ETEF1M0grdUUxYUp5NC9oRy8ybzFRQVhIZzJuUDZBQVJobnNNMmlwNEp3Y2QrTGRkN0pqTUhuWEhoTUlxMU5ua3QwOEZqMXQ5ckJxa05od3B1Umx4WFBFMmQ3NE1rbVN1Vk9mL1dlb2JOTGRPRFkwdnhZYk1venRQVHoxZTYvK3h6ZnkwV0ZPamVzVmdnMGFRcGRZVS82em5DMktkT21yZnplcTBJV3U3Z2w5d3BIa2FzQWJzT0FBTENPV1pPNCtXQ2hjOFo2Zks4V0VmVU43OUpYSVkybTRsQjFxKzVseDFBWkFEaUl6cUdBOVhEQUdxWVpUZjdlUko1UWFsM0p2eTdacEpZZDVhaFRMNGgyQXN2ellpdVR6L1kxVC9hekNlMDNibXQybmliTzV4ditkRU9zeUdOa3VrandtbUk5MkhlR3pWMFBkMTQvVHQxeXFkU3VFMHpUR1Y5TUhQNzZvWGZZdHFJM2piWk85M25NcU11N2licVc3dkpjbE5XR2tkQXVHWk43eE9NVWZVVHYxMm5xaEFJUG9yQVZ0UTZSTCtlb3NtTlhhSGtmRTVmZDRiSzg2WHBaR1pVVlozRTNXUVFBdUIvUnpjbkllaVF1c0dBYTBUV1I2eHU2bi9LV2ZyTTB5ZG1LaEtTUldvWlVLWEdIZEdISzBoUVBMbnpHOHd1RzdxNWNqWkd5VnltSVZiZ24reFNPZGFwQ1hVYjY0T2lQMk4wNEdBcEZpQS91RExVUHE5VDlqWS92dFJNeldOTFdJNDJsUEdkS2E2bnNxRS9CMDB5WWZzQ0ZaeEJpTUozR3FDdDAxS1hXSnVYUjEyVzNQMEdSVkRrQTdreDJYNndaNFZYT1loYVI3YlBIcXZzZUg5SUtwZkZCOUUzY3luelBDaGMvNmpsd1RNOTdrelZTQW56WlVVYlZJZ0Fta0prRVR4cTIyelJkSVFXclhpUUFROEFJWGNzRkp5cW5ZTkw3NTlUaUErQWFiMWtqcmxwa0xrcHIrZDJSOGNJTEJPSkYwSndPTStkYUM5NEhNUXc5ZVlVYXJRMFJkQ3Rnd2NDWVFrUThtL0ZxUGkyNkU3eWJsZHJrWXplanJnRDlhcW4xN3FrcnoyQjRzMGJYUmIyRmtsL1phaXYzb3l4eXpPNnlsTXRvQ3plUGhyOTJFYWxiUzk3M052dGRGdWpzRzBGM1kzVzloZnpwVExxTTFFcFdZbVJkbHVaMzlING83cWlvUE1NWDR3MmZ5ZWp2Smp3RGV1VDNFN1RmcEg2RUlRUUF1QktTYklReCsxbThyVC9QVWlROEMrNFpDL0NzU1hRbHI5SUNHejVkNWlLZkFnQWRsajFuSFZRVXpjK1R4dnF4NngzQkxBYVhoaTQxR0xDWEpydWw4VllpYXdQbmF5b0Y0eEpjRitwam1MRkhleUZnalJUZHJ3N1pOSVduYkg4K0hmNkhxZlNrcStpc0dqMWVBenlYakFEUHZqMUFmdmtkL2VYNzVZYTFwZXcwNFRxYUh4ZWwvbVRYOUNJTHVROGVUbVFQQThwZEhtN1RsV3Q3NmFValh6UnZkb2NxMEhkbnVMTHRXbGxvZzgzN0pxcVZyaFcvZFBPMlppbHNIU3BUcHZuRkdHdWowbE9uVnZTelpUeHRSTk55WlVkR2tUVVcyakhaOSsydTNmcnJYVkxwZVVrVnBMS0V0TWU3M0hQU05MVUwwY2F6VkFjYXZxOUZWV3AzRkJtMTVML1lla01rUFRNNmphUHhQWFVBZnVwUWNLci8wRzNnbTZqSzR1R0dnMHRhNFQzTlF4ODNxNHVhZXdNa1FqdjhjUXdVdjV5YXJTUUFCSzkyemRIUEwyME9ZVGhhWkZyZFMwc1UzY2g5MHNNN1c1SEo1R0QvV0hXMmhLQ2lLTCtxMXNYdnk0NThlcy9MUVRCYnRpYnhSb1FtaEpISEZ1dm4rYXJ3ZHAwNEovK2I3ajgvRWI2L21DcVVFV20ra1NhWHVudjA0N1doTm8vcVFGY1hjRm1kN3N6bmlvaEFMYjNtbDdUdUw2Q1NNcXN6M2NycXJjeTdNbTNybW5LR3pFakxsTjdkWmxhaVMrTzVUK084ZS81N256T0w1R0MzMmlWS05jcnM3OVA0QUFDUVJWTGRpM0N0aFZseUNYSnJQdEUyYjRsOFBxTGZydlNBWGdYTHd3d2x6T3R3alJvdC9YUE9VaGFsdGxOOEttRkJKYVd2dm5qZVptcWNVa2Q5UzN3UjRxT0JZU3l6cUFqaGJGNmpmcHhBM2pYcnZ5TFhFVzhzTlZHa1lScXRpOWR0RmJrUHdEUXM0VURqWWxCZWlsRVg4WlE2SFBZMCtQdS9FZXpiYXYyb2IyblJ1Z1JBQ21sUG95algwWGdrUERLZlowOFp6VHI2YVBVK3FoeGkvWFFUc1k2amVXYlRhdS9LVUQ1K0hxeFljNGtSOWs4QkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQVFmM1gvL3YzMzkrL2NzY1dkYmUrL3RmeGUxL3BwOEU0MVFMTUlub01WWk96cU1IN3QyWFNBMWluMm1qaEVBRWdoRFNZdVBzWVhEcVJpVHVwcUd6WHpPbGU2Wk1MV2lrMExIamtsNnVzTElZMFRSWGhQVk96Q0dWN1BuZmhQWi9KT2xKVlNwTXBTK0RRRE1KUmNLR3ljaVA0dHhVcXVUOXlQcDQzTFIvL2ZTSjI5bHdheEpLbE5BNkhSem1hZmJUWlUvRWVWK1ZvNjlIdU9HUDJnZzlsVkxIcTA5STgzNEIxZUhybWNUbU5nRXM3VFNRRVZJQlhYVENSd1NKVytLOHNLNkVKWmErb3k3bFlrbWRFVW1YclV2WmxlQnE1Y25rMEp0N204Mjk4MFkzRU85UkJTSytoMmxpWjlIMVlPZTVwTkJwcGk5amZUM2lGWDNrTDRZZWNKTHVPTDJPTDMrcSsxcTdtSW92aUZEVWkrVlVMT2NNdE04ZDl5UnkwRm4vdkEzdmNHbHlhWnVReGk2eGRPS05PN3pERjMyd0hIMFJrMCtOOHh4UHVGNUtYTm5lcU1HOTM0VVhKUXhEVGZSQjNZeWN5eVI4amM5MzZpUGJmQW9xU0FibjJpdkhJUEM1SzJrZzRGNWVyaThhTXNxVzBVbnJ2MHVjbDg3elpzZ0FBZ0NPeUZsZytmY2duSFcxOWl1clJYSGpQNWZ0a2x2S2FzRW5kalJtdG42V0kwVGdSSllER2s3eExFcG15VnVBVklsNGx0akR4bzIxc0taUWxXWGJ4Njh2Z2RESnV1V3pla2JJc0gxS05qcG5FV2hDVnppT21WeFNvSWVBME1rdUFsQlpNd1dPeWpHcVhnUlhlblpkN3R5eWlwbUNNZ1UrQ204aWxES3ZvbVduaW5ZYVdlMTJTVngvTFRPRUowa1MzanpMNmMzVGJxQXlVOVZFTUdFejRZaW9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSERSZlRGVmo3ajdZcXIwYzNxSnpPbDU0TmxZaDh2MUpNZFM1aHkreTZPZDNCQnAwOEdpSmJ4bkJZS0hFam1BRTh4aFlwdDZzL0tjYmhKSk04Nm9jSXdjRlR4Nm1xMXhubHBUMG54SE8zc1NSWStJV29pNDZNODRXdFE2aGp1V041OVRMVzFwdTlXZnNodTVjNnpUK3JwY0NFbXZzdFlyS1E1NEx3N1JLWDIxeHR1OWZYeE9NbHoxdEY1d0FSNXFJQ1UxbnFHeXpOTWZBNFZhWDhJQ1lEWlhFaFdSK1hzdWtYTXZaOWRTMXFEMSsxWTloSGhTRWZRRy9hSW9sNWRrRjJXK2R1cjlESUtWRi9kcEJ2RVRERUovZWovdjhJclhaY2VXUVl2eTF1MTRtZmtDQmNkK1k2ZXllVnBsZU9wQTF6eHpEWHluZldRdTloZGhoUmphOGkyVDhsNVZ4MHdaTjlqVGNIMkFJcXMvV3BVZ2hYcFUyak82OTFaRXhsakVSK1JaK3EyOVBDMHZMYjVHSmcwQUFGd0p5WGxValB2Z0dsZzYrKzM2TEtyVWJsaEcxVWllby9mN09qUnlYWVEwdENPM2YvOGgxeDRzaFN1VGp6Y3Y2emt0WXpPcldOTDhwWEN1RHNiOW1RNTM2ak1KZnc0VHZKUFJQUTNOaDhUNWpseVFZYnZJL04vaGRSM05xSXQzRnNORUF5YmVwZEU3d1Bzd01JV01yNURMSTZ0QjBESzgzYXY1RG5kL2VNWlV0RENNUVhCSHRISE02RUlqS3Zkc29IY3djUDFwWFFPVGlBbTZVbCtPN285RlBDYTNKcXB3ZVBlMENyNllDZ0FBQUFCd0l1OVVVOTlSTnF3eEFNRE5nTmdDQUVTQXpBRGd4anpGUG9LZ09oKzBPUUFBQUFBQUFBQUFBQUFBQUlBRndQME1Kb01oQmNBa01Ka0FBSGRoa2J5cS8vcS9memRQWVYvLzQ2aUI5eFRYbGNjYWdjL0c4OVAxU1dOc3hpRXZiMFA3S1g5elhpZUtrSXFLaG9PSDRUaEJCaVNKbk9ZeW9ZZ3RXMDg4TFZ4VEkveTVjTG5OS1dVZDNyTVloYnFISHNIYlU5a2U5WlR0eldObFg1RmpQZFZQeFZpbjFocGxrTGkrVTMya3I1Tm16KzN4dFIyZnMvV2wxSm1yKzQwTUJtOFRYMUhrUEkxRW00OTJrMGZGZ1huOGNLU2xYWXFuRVIxTUZ6REtaaHlrbWkwei9QalNDZUJkbVBuRnVVeWJRMGdBaGZSNG5sRG1DQmpXbEpFeitoMnQyYlNpeUExUmZublAzMmJ5Q1F2THNvOTNLTEpOU0NNbzU5b1hZcm04MitFUHJsSS9NZHJQVmUxdi83Y0lxMjQ4TFpEQ21tL1pyMTBNZmZXUk10TUV0OHJPNkV2UmRONjhQZE01YTB1T0xBNno5TW9aQzlTWkd3M1ZKMks4SDQrT3pKSE1CNnI5bVpkRCsyaEx3MHlXZnlHMkNQRkdPR1B1Nk01QVhTWHdMUk55M2dBQWNEVXNIV2ltemdsaXpQUmplWTJXcFgyM1V1dTVBbDdGMlNLamVGaDVyZXhZYjc5RytqK3FkR2IzM0wwN1NCcGVROGxqV0FiN0NiSjJHU3Z0UThuUFE4dXdYR3k3NExxLy8zSUZNdW0wdkRPczJudjFlR3V0TWl3ekQ0QkxnQUhwSXFwdEZHZDhLVzNrclN5dmRqRkM5VDVZUkZoaTdJRjNzMkpQby9KWmVQUUtJU3RYa1JHWlljVjdOSllnUmlOTnc5b2VYZTFCR1BFS1BJYUJ2VGg4TVJXQVR3U0xJQUFBQUFBQUFBQUFBQUFBQUFBQWdBdHNxNENQNEZOL2J3TUErRnl3QUFNQUFBQUFBQUFBQUFDRWdVc0ZBSEFsdnI3L3UvdWxkMk5PVFhkU2cvY0J5S0tOcWY1b2ljQUdySFU2bFhaNlJMQ28rWGlPQzdBcWFCMmQwWTYzRGtVTERXR0pnSkdEUnNBSGdEVmlIZjNrT2h4TFdJYndmcnRGUzJlZGRoSTV3NU9QR1FsZmRmb3BUYU9GZXp1bHhhSnJlYVJQV3QzU1JzNkZ0UEtVVmdQUEl1YzhPNGM5eHBNTDU0NGluYnRLVmVGNlg0cFVwcVRzMEg3MW5idjFHeXF2eVBScnFjY3ZxTTVvbisxNWJxUVJXS2VvRlNGOGkrTzVuejF5RmV5eEZpcm1maFhFYmZSUVNLMHE2SzZIWXcwbVNaeHpSQWZUd3NGbnpaa2loSTlxRVpHVDdheVRydFZ5TFRXajh2ZFRiUTRoQVJ6TU9yazlNb2VrT2xocDM3LzJTWFpEdGxZWmI2RWwvSnN6bm5SUEs0NGMxMXNNWmVjbHY1UnlyUDBEbXJZMXZpNURuMy80YVd0SkVOTUhxa0pkeWo3YVVhQVh1ZnhhMUdlb3d1eXByMDlUMEtKMDd3bnRWdlpycDY4eWZ2SVVxcWMxdmRoOVdhVGhyY1dsWktkeHhsMFQzVEFZc2MyNFBONGxOTE42cGZiOG5nWEpJK1lPOHFuSStXbmhYTmxFUkZobGFWK3hrZWFLOUFWUlVYeVYvWDBhenhMUHJEdUx0SFZMbHVINWlrK3orb2RXUXJvZVhhNW41T1ZWdEtSNFJZbnJLU3VDUjhZQ0FNQlZrQXhhNlQ1RkN1ZmtNSWd4NHNleWROcHFYQzlobGlLUnljZnlTRWFWMTZMRW42bEljTThibVZ3UjUzWVdiNTZqeGhtSFpSQmErVXRwSWhQQ0t5VHByY3BYcFNsSzdNelBYSUp2UkRNNGFSOUsrV2hZZXhyZVpkYVVUSXVHVDJQcTBNaDl5eFZSaW0yU2N2R2pNeDh6Q0V4alZCMEJZYUxheGdvTnlLdDEvRVBXQ0N0UFY5MmtCNVBpYVdrQnVBck51Tytad01Ja2tyWWVzOWFEVnJSbGFsdmhYTHlQbnE2Wmg0UDhHc1p5RVhubmhIYzhSOHJXNHBmeXdHWE1FaUkwSGhPT0w2WUNBT2FDaFJnQUFCUWdKTUZzM2ptbU1KN0JCNEhoRE1EdHdUUUdZSXpuekNGSUM3QUtqQzBBQUFBQUFBQUFBQUFBQUs0Q3ZIWGdJOEhBQnBQQVVBTGd2bUQrQWdDdVNQM1gvL3QzSzY5anRidWprTWl2V0wvK2x4RmpJd2QvQVpEQkduTUx4cGgwenFCMU1QSmIwQ28xOHhnZXFReURsUWRkZ3dlQWdaTG5CSUVWT1RDSWhrdFZrdlBTU3F1TzByUzhyTEptMUVIQ2U2cXA4emltNXNuRGU4eUpVVllvM2d6cEwrVXA1ZXM4ZlhqSzNNaWV2Y25IYlZOT1gvYXhiOUY5MlRWZEY0bFlPM3pNSWpBNjdFZnpBTDRsZ1Z3ZVRoOHVkdGFlK3dDOGVJT2RleVlqZHVEWnRyZkgvZzhsM2pMUXdpTjgwSklJNXJGQ214b2R0dmNicGlOMmtTZHZ6UjU2aDVBUTZ1RDlMTjRHKzVuT3lvZDdQdTlYdUxxUnZHbWUycldKVUJiM0ZkUHZwdlY2TXFUN1JYNDgwc1NIeHlxRnJkUGZlTzNua2kvakZEUFhrNzZVODEwUlhKbXJYQkdqZVk4eXc2WFV4ejNQRmFHWFBWTkVTbVZvOFFwakJ3cmliS1NxM3ErVHRvaGl6YmpLSW5xMTlid2FYdkVzZkRSNjNEVnE1U1BGOTVUTnhST1d5VFNTckFRQUFQQ0xkMnNPdklmb2x1c2xXS0Y0V25nVkRJL3RhUmxBMlgxd3JpeXVMaG42T2tyMUdQVm96VEpTdER4biszVTRyTEtNKzBHNzRYQ2ZyZEptS0VINFdtUk43RmQ2YXBzcVBpUTFqNENmcUJwMmIzRzRDbXMzL0ZaTDFsVnVxNHpwaVJrQlRrTmF1cjMzd1hJa2t5V2laWG5MV0tISkhtUytWNjNVNGdEd2dkQ2ZXeDNtSTVrN0dUR2QzUmFUN2o5bWlrYjN4Y0F3TTllK21lTTJXb2ZIRFllSmlzUS9aaUVBZ1B1Q2VRd0FBT0FTbkxrZ1hXSHh3d0lNQUFBQWdFVkF6UUFBM0laM0NDellnd0FBQUFBQUFBQUFBQUFBWEFWNHlnQUFBQUFBQUFEZzgvbjYrNC94ZTJMSlF2UmFqcXVQUGdMUFplVUozd0hlUHNTMUUyZXMrWnM5L2J3L3VEQ1FyQzl5eFJtQzRNWll4MlNBUEpaY0dEbFN4NGd1RldHZDhoT3JqSlZDTzNIVmM1U1hCNjZNU0pyKzM0eFUzRDQ5MEgzR29XNzNQZW05SjZzYWRYQ2RKUk05bmJjWmNiaCtMVVllVGIzOFRWNUp1T2RVNGhqNndZWFpmR1BwZnV1d0g4ZjE1eTQzcnNmVnEwaGJYbGhEaUI2UUxCME5KZVZyM2JQeUJrY0NhMkFsY2M1b1luVGpRL0hLa0Q1TUNyOGdsa2dzUWppWG5sczNQYzFnYVI5U3VhOHlOYmt0VkVEOEFwU25VQWtJQjhEZ3NXZzhhc1NNNFhYZklUcGkvM256NXZYcU9XVjRNZXlqdzNxVXJZT21ZSkU4bTVHMi8wUUQvVXhETTFZTzhWamlJb1FyQW40WGgxbVJ4RWxrMk1Ia012VEIxN0kxVC8zYlBOdTlWOVB1eTZRbm5EZWxxUS9sRkVFdHFTWDJGVVRLREJQYk8wd2xaU0JqbWhyZE9tWDZXc3JPQ2hHaGxiY3kzUitFcVRWZEJQWmwwUHRLc2g3NmxacW0xTm43SVdjcmpoaXVqVi9tT1NzbkJvVTU0UmFkeFg1T3N3MW1qQjBwcit3K3c0aTcyWXNsUTZ4MG5yZ0FBUENwWkdVdm1JT2txMXBtNzZYN2kxTWl1UHRibUtiQVNFYUh0UzlzMWFrdjIrdHI4SHBtTllJS2RDcmZTQnR3R1A2T2xJRWh0YTEzZ0Z0alJIcCtqd0VZVVZiLy9GT1BRY1VvMHFKYWZRWUJ2VUZucTRRNGlnVWJsT3NDeVRieitwdXE1TFpTdXJOL3JuZDlRRGNya2J3emkrdWJQZzFHTzFnQ3QxUklnNURENHd2RjRGMkNwblZZOGlxOVZwUjRudExYdEVYWk9LcXVBZkJoYkY5S2JZNTRwZVRNNU9TV2htbDVQa1pqdHg0YzhtczZYQk5IckhwTzFSbkJzdW8xeXh6aytLY0FBQUFBNE5sQW93SUFBQUFBQURjRnFpd0FjOEJjT2dPME1nQUFBQUFBQUFBQUFBQUFBQUFBZ21CN0FTd0NRd3VBKzRGNUM4QWNNSmZtOG5VOFdhVXhQek5PTmp0K1RRN2V3WXFmelJmZkwvaXRreWlXNFptaUY1aVBuc09ZK3ZETStaUGd4bmdQZHV6QllKaUhOYm1hZnR1YXQ1N2k0OHc0UG43MFRLQ1JNMU1pNThIMDhla3BwMzNZRnFTZG1hVGxLZFV0czlCWWRTakJPdlI1MG51bDZPZmJGQ1ZOZjVzY05lbzZQclE3bHJSWldrSXh3NXRyWElobjJybktvRzFlRDJkazlXVklOY3F1eUI5MjdGUU5YdFA3bmlrQzFzQU45LzY2aXhQUlZUbEd6aDRIRDBjN2hqbWJ4eHZGc0dlbDcrTlpJbEtieGtWSjU4VnQ5OWZkUHpFMVlwZXdCQW9GUUdiR1VCazlaWjdMcHpyTGU0K1lpcGFhcVYxejNvL1VoVXJGb09DUlByRlFPZnVBeTZNTDMreWhxUEE3REpvbVgvZjFiSjZ5NlhNSjloNDlydGg4YkU1d1Y3N3JoR09KTnl1cmJuYmdUMTJxOEdrSmRsUWNxdDkyc1Y5NTA3UldGOVg5bjMzVDBpOXZTRTNldks0SUdrZGEvTFU2ZTZlUUphQ2FrYWRVWnk2K1I4a3BSaGxXUCsyN08xZW1WTFlXajhzclU0YjB2Tkk0Nk5PVjRxdnZKR2hUVTUydmtvZzdDY0dJV1krWTFMNWd6SVZUMFNFV1VidDV2ZDBpRDJoMXI2ZnAzYXVwdDUrckVDNWRSNUE2V0FxbjQzaWtiQ3V0OS9rQkFPQ1RnY3k3RHBiRGpwaEgxOFdyMUdhTWtDM015bHN6VHFSOHBieTllWG9OSmV1K0ZjYlY0Ujl5UFhPZ1JBMEViOXYzWVZXSWI3V3BWbGEyRFVpWjFhbkU5K1cyUHBMZ2N3bGhLZFRQd0RMM3BUVGNxSGlGQzNhaFppOXFOaVFYNW4wMW9rcDFLTVhjMHZDYWZTVVJyNWE0SzZKbnBsU0d5Z0ttSS9uS3NnUFd1ZzlFSkUxT2FucFBQRXRHRmlPUFNEZDZ0U1NhT1pYOUJ6OGtCQ0Q0WktvZUpJbGxqKzdUeCtYdVI1QjBJV3ZKK0pocDYxVW9vNEpRVXlDQmk2eEh4ZFBjV1M4QXVyWERNa1lIOHNJWFV3RUFBQUR3RnlqU1lEb1BHMVQxYVpNSVFnTjhFQmpPQU53ZVRHTUFBQUJQQldzZ0FDQUNaQVlBQUFBQUFCampxUm9sTkdrQTdnWm1MUUFBQUFBK0dlZzZBSUFVaTRUSDErNlhxaTF5ZGxQSHlKRWNBSXpBSGZrdzhzdHRKWnVaSjBHZndwL0tWQ044Sk85ODhQUURLc0NIc3MxdnJDbTNZS0ZJR1lBT29zaWd5aWczczU1a2hwVDBuczFteGZlR1orcmd2YS9GeVFxSkJhT3VuYm42WmR2UXI5MzgrZHFPcmtaazJ6QnlKdEtOc0k0Vms0NUtvMkROT3c5bFNUaDgrWWFHbC9sQS93Vkw0QWJ4RFFaYlpxVlkvbGlkek9BT212LytaL1JRK2RFNEFGeVFuZHVaM0MvTWZlNzZlY3kwdmFSNFVYdFF5TXZjVitpTE04cU9WcUgvMUlQYkZoTUVkUXNVM2hnZncrNVRpR1dNMXYvWnhDK292cWdUUFJHa21WNVBtV2xxNlg3R1Z4MFZFaGxsWVo0cEhjdkhHNWJOMHhQdWphUEZ5N3B6UFBHaTRabTBJOCtWaUM1OXFXYVhWekNjemw5dDMweGFqOFd5U29KWmdrbktMK0piaVQ2d3hjbzlDNCtzQkFDQXB3SFplQjJrOVozVFAraGFTZnZ4cmYwNlNma0xwWldVNFdnRGNFcWVWRWEwRHBFNlJkdHF0bkk0SSsvb25tekcwVDVpQ0R2ekNqKyt0akhXL2ZHNGc1akhXYkduSWRsOXFUY2pCa1dmSkRFT2tRSXVzdWpvajRaeDRkS3N0R2FyRkw3U1BBVGdCVGVRTWVoT3BSblgzblRlTUUrZW8wTmd0MlVEQURpaStLT2pZbmxrM281dWFYejhORi8xZ0ZEeVRtWGxubFdrR3gvVjNUUG5Ec25yNi91LzM1T29DOW1jRERNTDFueGtBSGlwd3IwV3VKOHNjbUVSNi9CSVZjblg3SGt3cGdHYUVaMkxJemw5QUZnNmZvRVBvMDFIdThBcmFyeHg1ZFRlNjJ6K2tTY3BRaHByODQ4cml3aGljV0d5SlBDSVpJNjhEUmFwZ3pjOHM5aFowVGRkK0h4aFVvVzcyZzlCNjArcS9JOUY5KzJ6ZjNkQTEzYWc0aWVKV3RWZ0RSNHhXL3dTTWJ0ZU5TVVA2TWtQb3pydmU0eFQ1L2grSjk3SDhvU2Y4bGhPZWYxR05RS0FiNjQyM2FYZnhsaDY1TnJubUdVZlpleW1Oam5jWTRNSmNVVzVGdEJJNkMrc3FwU0hFNXBlL2NGclBlNXBORWVaM3FvZDlrZzZTNm4yYjE4eitWVmhJZDcrTVU0ejJHeTcxdVFmcDlMcTFhTEgyeUthbzc0ZHE4ODI5U3FIanJYNGUvTWVkVVc4aXlzWjJXY0lhbTF2SjVKMzFqM25pRjh0T3pIUkR2WG51YWQzZGVjaXMrYnBvZjdrY3NVd3RONXZQNVRwY1FsSzl5Mzd5THF2aFZ0cFpuRldPUUFBOEE1R3pTT3dEay9iYSt0cVp6WmRTcmQxTTNQd1NiYjFpSEhDTmY1TXBiMVRLTk5rRlM4cHpReURZYlRNdmwyOC9UcGFCMXErRmk3ZHI4enRxbFIxY3h3MFczbW5aWUFYcnhFa0ROOHpSR08wak9FOURTcjdCNWloSXF4cVkrN3hNQVBBYWZTRFgxdVd3REpHNU5Pb1hKcmxobFhENjFpNHl3OEh3THNaMllwVnhuVkdCWXJFRDI1cG1KYm43VGxqN1lNY1UxbWxzOCtjU3hFVEJkMzl3NFM1OWZXYldaV2RDNk9URnowR1ZpTkpxQVNSWkplMDZhTHRNTkp1azV4b3QyOXpzQTVKSzRpK2pBS09lTFc0Q1czNkRxY3dYM3AxeHN2bTc0a2JVWW84NW1IanZkOW10U0lia0NOeFpneXkwVHA0OCtqaVhVU1dOT1l2UHQ1b2hWdjMzMWplRUx1RWpGZUhpb1l6eEJIWU03bnRSdGEyU1NZTitIUThMMWxuNU5HYnNKeVYvZlhzT1VKZkg1cWhtK0lIcWVEZFpJYmdPNGJ0TEExK0R0bmF6UFJvWmNKbjFDdVNYcWpESmp4ZHV1OVBIcG12YjdSMi9DVVYzZFBZMWFVZDAzZEpnNFgvL3JuN1Ftb1Q5bE9jQy9GQVZ6VnZtMmZ6L3NIMWVPNk1KOGIxaGxzN2tsZmpTdlU2UTFEUEVtTXp4MVkwZmlDLzBQdmRXWnl1cllNSWNhWmo4M0ltTXVOSjcvZ2ZNaXErZkxUMXFRWExQQVBzcFFNQW5rUjJQYTdPK3lDUGQwdk84a2ZldGs5bUt1UXpGZXBaRzBrV1ZTbVQ0aGtJbnZ1ZXVvem1GUkVXV3YwejZVZWUyMnBMUVNpMklvVFRMQ01PSGVDbEhmNFF3a2Z6SDR5eml6ZGFxWWxEYVZSeWpzN3liTjZZU1dBcGtlVVdYSkt3WENiWE0rV0xxTUZaMnljWWMrQVRtTDJuVWZuYnM4SDBtNHh6Q3hmSXpQSjJlRjU5RzYyTGxSYmRQNWV2M1ZWMlI3UUc3d093QWlxaFBQR0xuT2FXdzVlVDBHL1FTcXpUMUtROW8xUlpwVUR4K2xSYTkyLzJHQXdNRGg2dGJaTVRkRVJtemxBd2VUaVh6VXJwemoySnB3N1NkWFJSbzIrTzBwZHd5d0JjblN3SmJDbUlLeVpvTk8rNlR4YXAwOUpQeFBDeDQydWVOYUhsdW1GOURUSTZyRGZSTUtQUlp5cGFUNEJwbjJxMG9hZTdNWWZBY21hcE5CZlNtNnN6enVxcWVzdWd2NDF5MXl2UzVoQW1ZQkJwQ0duM2U2VGZiS3pnUXVKb2tOR0ptOWZoeDh1VXluSlFyWUNtaDR2bUkzRXl2a3pxenJZK2ZONnorRGc0TUtXNnRHT2FYWjFhR2YybFdjMHU3RjB6ZEpsSmhhakJ1eno3UytYeHVDK3BibW1HMEZ3UFhsZkVHVk5uQk0rN3huZkZZNU5lVWNjWnJKUDEyQjZSUWVjUWpkY21qZXZlTmZ3UHVXZGxyYzF6VGtSdTk0ZmtnbmRNZWRJQ0FBQzRObG01emVuRlFHZldua1ovVGZPMnlyNEVYbTkvY2NUenBNOUFOL1lqSGgwYWJ0am1ZcGxXbldhVHpkTTdzS1g4SS92OFo3NGRNYW1OMjhLOEg0NzBKc1gyeDRyRExETjdsWkxOUnZOOHhhSHB2S0x5VFhobmt0ditMVDVXUzBUd2NEQ29MZ2VWR1pFdWlycTZ1ZlRzZmN1SHVOM3YvaDBlV2hpYjRKT0lMdnJkOWJmdmV5RExFVWF0bjhlZ05SUmsyUkNqcnFVK2o3TjVwQTZmN2JCQXVxL2ZtSmhkNEVaSW1uMVVXLzgwdHVlLytIVE9HR1pXWHVBRDZlZHpkRnhqWU9oY1VGWklXenR6Yy8xVVhVZDVybWx6QWJyaWpuNG42UU1GRG5wNklsN0IxdTlqejNxSkd4M3A0NlJwYkwyK0FjQVVubTRQVDhMYmhNdTFvNWxyQXdBM0FNUGN5OFZzczFuVnNYUll6byt4dWltYTh4NzlXbXMwVHk3TFB1cWtQTVhvRSsySE5zdXhRMzJDa1R5bCtGZXpqejdaemRJbXhiazU2anlXbm45MHZEc1pVaStWaE82UFNDZnlWaG1aUzFCQUFBRGdNNEF2UE03b0dpaTlwME50dHNzVHFlU3N6WnZaY2M4cTI3dkxJZjYwcmZqS2Z0cUVQdUY1bjlpc0p5TzVrS29VZUFKc2wzZGpZZmdBSWZEaWdxOWZBUUFXNEhYblJmS1lKWWEvZlhLQitDRjVsZjN4Q2dBUG9MNXh2RDk2cWtHSHZRd3p0M1FzejhKczhCcldHcjUrcmN6ZStpejdmMGRCejRGVmNKWjlOZUlueWZ4UVhISzVMcVU2N3pmanZsV0dGcS85UmlzRklnQU1ZUDA0Tlhyc0N3YmpMNU1FVkhNVzRSVXQ4NUZ5cFVMUUVwS1J0K3EyZ2VzVnRDTnF0Zko4clE4Zk5RTzI1NkhYV3h6NkEyRHUrYVgyME1yVTRtUldaT2NicXJYdzkvbTNrSDE1Q25YUVNxamRYKzM3Znp6YjEzV2FPYmFLR2w2VjJ0QzY5R21ha21lT0c1dCtrU2xudlhRUHpzUHFOOUpYaDYvWGtHbFBOM0lsVlFiZERKYndBVEtFMHlyNmE0Mm81dU5kNlVPdll4SFhXaCszdjk5OFNvQmRDUTNZUVkrRTA5Z3AxbjNQM01peWRpMjBKb3RrbTh5c3llZ0xtUkhiTTR2WGJtaStiRmhoYU5sYU5CNkY2WnZENEdtNklENWNDczlkSXlPZWhGV3ZMYmtsRjhwc2h6LytHK1cvdGxickxVR21ySGFzU25aMGgweVo2Z3NmK3JxajVHcm9yL3U4Wmt4dmp3alIzQUxSNTJYSEwwbEwwM3ZkWEZKNGhLaElIY0ZhSEtUKzFkSndlV2g1YSttOFpkQ2s5ZTg4a0R5R2xOYWwrNzUybGhtS1QzVFZSdThQOXFmNkVXbEpiZ21pVlZ3aGpIQVgxcGdDQUFBd1JsYVBzTFpYckhnZ2psZlg4YlQxV29QL3pWakdTZFR3OEphVnhXTm9STXBXSFFDVGFPVGZrVHhteExQYWdoSXh4amdoRnZCRlNINlBKaW43N1doczdMSlhsUFIzdm0xL1Uvb2ZmSHBtakdYUFpYd3MxYm1wWWZwM2FGSFZqa3VMaW1JdFMxcTRWWjR4azhUN0hyY01aZ3BJNGRYRFBJT1F4c1dndkJVenVzczdqTmp0bE1ac2JYaUZwamNjZ0RQSUtoS2E3QlNjK3BJZU5YTXFlTGMwc3RQMjlualgwV3g4RUNhalI5TjRLL0NLaEkrZk05WWVldFFOc3VYVmhYLzlXc1RVNFRHeGVUV0RGNEFSSk04R0hjNUZpQWNBdUQ3OUd1SmRDRXN5SGdEQVlMS09lSG5lOTd6dktmWDNlV2ZZSGNEZ1hWWTEwQm1aZklMSXFFSVF6R1F3QmEvOXE2VUhMelRuL3F5bVJaT0RKNktaOWVER1NFb09SM2hIeDhpWUsxdEtNdU1GYTIrNmFIc1ljWDduVG1YRDJldHF4Qk0ybTVxeUt5ZmFoMEthdG1JUmJKT3ZaOVRCdXYrT3NxVCtubG1IRlVTZmEyYmRySGs3YWR5ZTR1ZnhLSzBuOUd0emJsSkw4Y1RrVzdwSVkzcmxNZ0FBZ1BPQVhMNFdvM3Z0a2szMlVjN3ZOam5jZWhNd2twY1ZML3JyRmE3anZLK1NTbmw2aVRnWndGU2tUMmZpUjZrcHBNTnJaK1ZuM1gvUi9kQ285OHZ1ZXRYeUpXRUk3RUJ6Z09sZzJRTS9STmVLcWNObXRub0p3SjJoY3JucVViWDdtQ29uTUtwb281T21FeG4vVjNNaFlUaE1vUDc1WWVyM0gxMXp2bzd2bmF6NWpyd29DUUJGR3ByVW05S1V0QzJXdFJXMytZdUlWaW1IMTUrOVlqNlNNcU1INW5pcTlGRjdHY0NHZG5qMmRKdW5FOWszc283U0VlWjNFLzRld1JMNVk3bEs2ckFWcmduWlBxeVZlRTJsUnZmR2xlckN4UzhrM0lPMmdkcU1jQzU5QnVtNXJiSzhkZWpqTlRKM3RzMjVScTZsT3NiMGFYNmt0VU9ZcnhWem05cFVWRFFTWHRUckZYVzZJV3NFVnc2dHlhRlE3Ykg2elpqT3JZOUwrS2Y0dWdBcURBamhzWDl2Z0VmVHlXcFZHVVovbkhxWXg1M0s4SDNwa1NuMHdjMUNoUHN3cm9HQTFlMnp0R3BQbVJtZmtFd0xocS9RWlMyYlRMb3Z0WElSd2xjZzJjSE5Ucks3UVo2L3FRbkliV0tMYWNLeWJ2RUtXUk96TmpncHF3YVZlcm91YzBpTEFYMyt6dWFzWFp6VzJaN2IvZmJUNUZIcnYwbFZJdFVWVzNPR0VqdEQrWTArOEV5OFV5WlNoK2phZjBYdVZOY05ROXlvS0hPSVJCSDcxeHpHampLS1VJYm90c3BDeEZaclJ0bGNGcEplbktpbnF0TzQ1REtKbXgwSEFBQUE5bVRscW5kckRxekh1ejVUdjJTLzd0YnlzRDZiK2NEY3pzRlpqU250UmxvS0ZaZEdTK2ZKSzVwdTFMalVqREhLcUkrcFQxUDVNaVZIc3pjYm10KzM4NEE0cTE5UmZnd0g4VXVwVUppanJKcTEwa2R0bTdLcHdZcHBSK1VpTTJ0azVtdjVSSWkydWJmT0dQVmdLZForWUZQaWM5ZndjMHpIcStsWVRYNjJXa3gvRW5LTVVIUlZEN1lZdUNQWmNSclltdFN5T0d1YVJPVU5sZ0lDR21RYVdVdGNjaUc5aThjTkNXdFAzWXBQWldaMzc2dTRhNENaQ0c0QTlhWXNMQUl6d3NhelQvR0hURnZDMW5rZ2tmbU5BY0p6VVFGMmI1a3ExZjRDdTY1dkxQcitrSDU5elozelIrbzd1dkVFZFFxY1NVdUdnYVdnNmNFVXFHNkh0VCtNeHlhTjZxcnVMb0JqQVN6bWFpS2hCZStERCtLTXdjaVZzYXpNcmpCcEhjNDZQUnRYVnZmUGYyM1N4djZDdFBpZk45QXV6WHErRmN4ZWVFZmVTSXpHbi9sZThpeFc5OVVuc1hBL1NTdkROZHlOdXJXbTVEUDV1ZWpMejdzZnZqWW1icFh6bUZZZjZOUUFBQURBZkx6ck5iVVh1QmZhUDg3d24rWGhzT0puWG83d0trYVpuNWw5UWtkZVVYbTBKdEVid0pkU3ArQjIwd1NuVm5OTXpXOGIwZG8zeXZpeEx2QXJCMnVXWUpzTUFEQ2JyUHY1bmJMb2RRQUI1Ny9ic0g3MERBRDR4Zm9oZDRIK2NXa2czNVlSV1FNeFJ6NEl4U2o3c2srOWFQTkdBeTBMb3d5c1FIT3FUQ3dpRSs5VVEwUTZpc0JicVJFRzg1U3FEb0I0ekJRR2k1ODZHQjVvYTg0bTQ5U083ZUFNVmcxNUc1N053QzJlWmIyTUN0Nm1sRzFRbFd4Q1pVWFNlbzlPa2NvWWVYTlRhcHZvRG5vN3BwRTI0WnJWUDlaejIvMzc1MHM0clRSRmo4Z0tRVm1vZXRTcFhLbVp6ZTRQSXJKdWFVS3pPTzZYUkR6WWFIOHh4RmtsYmFrMjZZK1R2ekhaYTR4Mk4zZ1FtZ0tsQ2ZJTER5Sk9NMWlwUlhoUS9Hb20xZnJWNnk1eWlUM0VqUDZFUVBsb0pKSGdOYW1sZU5IMWlWTnB0UGpYSXpMWitsYnp0SHIydFFZTmE0ZlUvV3FjSTQ3ek9Tc041L0xKMXVXbkRyVzdibjNabGpNcDQ0MzRVZksydlpQWEw3VEt2bXdycjBOdzk1ekNBckw5T0hXekEvc3Zxdkx4U2M2MFdhUzY5RU5VZTRHbE1ET0VWRWw2eVZLY1dWMlpidDdoaXFCNXJSQnEwWTJJekxTVjdxKzBEODhzNnlTNHI5UjRWWE9hQnlXeSt2UjVVVnZVUlJVdUZmdVh5Z2I2WTlYZGwxTTlNa1NxbWlEUFVqSkRxZ1FBQUlBNG5DRGYxbmF2ejNyMFBwaEhWSy9VcnEzN1U3aURJamxpTUZpS3MvZjVvNTB3dzBDaTF5djdLWkozWk0vWTQ1bHV5ZXYrSHJrV20wekk4MkI4VnowWmhTcnpMTkx6UEp1TWE4SDhncDIzYktOZnRSK252cEpLZVFTNlY1SkNYdit4WjZaSWVVZmNHMUw2L25xZ0dRQVl4enNBdmZFd2dDK05SOE1ySmI3cVZrNndFZC8rSWM4N3FOTUFTRVRIcnpXcGxNbTI4M0dYYTB3ZFRGMkJNMHpRRDhkYWw3ajRVdmpxdVdLdG1SZ0daVnhXY2gzYytEUmZyOEtxbHZNazFMSUFXQXlreXh3V3pGKzRMa0Vhek91UHdpc0wwTzBKWlFxTmRpUGVxU3p2eTdac0V2Z25GVHpPTEt2eG1uRnQzYy9FUTRjdUlmS3FTSFJZQUNBeUtqTWVCdWRYbXlXRzNmWXVER0p3TW1jT09iaUVuOGJNbms2T25OWEdDcmNiTjdOczdrWFFYVk00WmxYMGJUcHJON0hJTDB4Rzd4K0tqQ3k4Wm1hTDRxL0t5Nk5JZUtaQVprUFJ1cDk5cml2YW5pc1hvSFlzS3IzbVhVRlhqN3dOM0xHOTNNYTkrTHpzcTZaV1k4TnhCUUFBNXdCakQ3eVZPeXoyMFRwcVJ1WlpobE5Fa1lvYW4wL2xqY0xTS3ZxZ3pBTXZHUWswOG1OVUxoOXBUK1A3L21hVEhSS1hqNStxTUFmQnJZRTR2aldwdGFGTXd2T3Ivc0lNc1pFWFdBQjRDSiswcGZIeFFHNE5FL1U4akc2VG52bG1BZWJXV3I2Ky85c2RvclViSEs4TnlJbmRnQjRGWitQMU5nZ2I3Wmw5K0V1dGE5NmpDb29SajR0cnhLdk9ob0FlQU1JRVg0d0JBZ2ZQZEpIM2poSnQzY3ZQVm1TRjlUMU9ZYXRFNmNIcHFwRE5ueXRMU3FzZE9WTEpQZVorNCtKYnp5VnRjSEpVb1c1Y1BLNU02M20xOW5FOHY1aVd1MS9KNVhiZDVTM3B4ZHluTWZZUlNGbE5xVUVUUXJjNHRUVFhnbTIxTFpkSHJLeUlHZ0VJa1Y4cjBuU2wyRk1OblJISEsrSUpuaStvV3QyOVlCa0dUMFphS290eVAyUDRUc1pyaW1wYVIwU0w0T0wzVHNxcXBPT1F5bTVHQWpXZXBEQmJLZzBBSFI2UklJVkhyQUlMYjlsemgvRXNhM09sZDNERmszdnQySXo5WjVWVmpXdXZBT3ZyRnEwWHRkMmsvck0wTUNuNy9nME82dkdvM1gydGJrS3drSzYxWDBXelZtNmxPcFFnWGtkMFhla3JoOXA5cm16VFhON3FGZWxxNzlTSkdLMlNrbDZLTGt5bEtjYWxqWlROS1NoY3VsTE9zUTlIeXByZHY5Ris5WllwMWQwcVEwaGk4UTdWYlJOYnI3S0RjNmxhZWRNMG5uRThnclMvVGNJQkFBQWtHREYvTkJXYjgyOUFYbCtmbVhybHg1TnRyR3FFelZCNkkvRTFJNFc3bGpoejBFUU1oU0xFcFhaK0puMS9IU21qeWtuVk1nUS93U3RhYytqN2xrRXJsUEV3TXJQYm5MM0VaM0x3clZCWEVvbmZkOGt1YWR2OTgvK3o5MlpabHVOSWxpM2d6MWJXL01lWCtSRTFqTXFQd0FzejA2c0tndEljUWNQMmJGOXVlb21lYUFRQ0FRbHUvTXZYUDducGNxNmxVTmpUc0pidDBwVGZncW9Ra1JHVmxiaGFMeDZSSElSTVI5T2JXNmhIVDJPV1NYQ0d1dXpKSnpSZXkyWkxvemNSUXE0SWFOTjJ0MDBueUZSMGRZVElpdWpZZi95VWdGYXVGSThNTVdOdTA5S3MweDNaUHZMV0NWcmVyd0p0UUc5eEJ2QnJGLzl6RWhZaGQwV3lxaUFURTd2OVpXQlRrQjJ0NXNGTzhqaDYxdy9uTWFJT0g4Q2p4c2dGNnZwQS9maUtQZXN6UGpVeHpIWDhBTzFEbWdqVWFkZlMwNkVYRGx3Mkp4bEdzN2loVHdHOGpKR2hIQmJQWDdLRDQ1eXNSdExsWmpNamZZNEZzZ1h0VlFldlJqWUxvZGJ3SENoTGNKZjRySStYYkw1eVdLMWR0SzhmaHIrY2VzVEE3M2tPV2JzZURZK21KZTFwOU5iaHpEb2V5V3QyWFk2MDYxdXducWdiMkMrVEhwYXVaWUtiaGVBeHd4eENQWUlRUW03RS9UWUUzd1h5WU85cUk4UHRtZEhCb3c5SGxFbnVIM0pIbkNONFF1ZlROR1lPcXFmaWp0NWlYN3NKT3VGTnNkMDVyTzg0RWpuQ3lDMmgzbndJczB6WDBSZFlaemF2S1plOWwxS3AyeFB5UTNBOFNCbzl4ZllDZWl1MWpmZWFOM25uTWN1NllWMnZZbUFYbnd6dzU4WFVuVERjSFprN0dVcGVzZ3JMYnRjNTYyZkhMM0xLeFlkVGhvQlhpS3hjRnlQT0pDandpVW45QUpiV1Q5dXdKRTZyY0pmbUw0Z2tPdEE0MXdKWmdYaHFNL29hWDV1WDFnaFN2S0lVcSt5TFVydC9aK0hsWmVXTmd2YUtiSlFCZmZTc3B3Y0thVWxQKzM2ZUJLNmZ3S3QzaHVBdnBmcWg5cldlcXhMKy9jOEdOWjFhWmN1YjBtUWpsZm1MdDJ5VUthVmJDUHRJaFZpM08zS3IxckFkVGZ1cFpNZGRlekRYOHV1c1owc2lFakxFQlR1VHR6VDFOSUU2VHUrWW1UbVBlVXZyM1FmWkVhTkRiM3R4dlVTK3NIUzVKUGhwS3hPclMxbmQrYnl1Tnp2bmlENk5wdUhwN2pNRTkyZ2F5TG9oR1dIUXRGcThOVll2bm5GSllmZWwxSTQwQmtCZlNzM05EN1FudFYvSnFNMEU5VHU0cFhKM2J6c2lST280MGpKZkM0L203WVVkV1MvTjFLKzhQWTFlRTh1TXNzd1VxZWc2T0ZxR2tYWkh3dGRwRDlSUHV3V3JmaEZIY2JjVDM2YXRqZFBkbUcvZHdmdHBaVUl0R3RUbWRQTGU1WkVJSVlTY3dpdzlRdHIwOExiSnRQbVdYSU5idE10TUpiMU9jMlRoWUtWYjB5NjZpaE5ueFg0YXN1RFQ4bHdGc2hnZDI2dkZ3c3lzRnpRdFRTaG0yNXNNMHpPU1VNblFQbXJncnNXYXd1UkE0YndSMDY3RmtLU3RZcFkwYm9YMDhySENlR3BIdEF5RURCUFp4SXpxeldRNUs4eXN0WHRvam1ubWlycHNKZTNuaGlMRTNYbDhybEZiUHlGWEpxcElhSEk0eTBsN0s3UDZXcE1keUU2enAyZTlGcThSb3BYVHMreDlPVFBteE5WazBJMU01cXVTLzBtRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRQS9QbzVLa040RDMvMGNDNkVucU9PQ05HUVRuYVovS3A3ZHE2dHc0emFPSWQwZDY4ZTBLTTVFTUFiTytKQWQvSWdrQ01zWmh4KytYYlFFOXJBY08ycFhCYWp6ZGZYek5HanZ0QlBFdFRoMGNwTGluc2JIaXhETHFvWGZsOFJkN1NGdmJNNGV3YnFqTW1yeHVwTjZHY3EydU5LRzNmbmt4TnlDNVZ2di96MXkvNXFLam9xdEQ2Njk5WFZpUHpWMjJjSzJtaS92QUdlYkxYaWpPWVo5U080L3Z5NVZOcTNQWUd5UGZuNHp5cTg5QlVoeVZrUzhoZXI0NHdvWHRKNmV3S0lkaUxka25WcTVLemlhV1hwT29qeEl4dGFWYzlEU3RoVHE3UnJDZzBDMHF1TlJidlcraTZwalZncFhGMFNyMlFqUXROYkI2NjBtdlhtWWExaDBiVFF2THl3SmVIS1duUjJjTXFLZnJKVXBDbHpPS2xzWG01eVVyS0szbjJwSElvVk1BTWpwbDFPSndQQnZsUjZETzZvS2FMOUxWMXZDaE1JSDBGTEcxR1U2bkNSdWQ4VGtWRTlZbVM5NjQwSnRDeVJ0cWo3aUNSYXZMU0RkWjNyZUszSktCbHhrekd1aTVqVjFnUlZvQ3kyY2FwckQrbkxxMVlTMG94WVdqMlpFRUxJdVhqNkJ6TG4xNU9CdFdHbzJVZzRKeHdQcW5kcWV1WGxtS0drZTJtT0tzYWFMVUlMVitmcjVZMjZKeUh0VDNocFlFYnFkZVlpcFMzUGFQdEdiUkZJMkpGRmltSXJLSTIvY3FtUDE4L0NZMlNRdmxNZ2ExOHZqU3gzMjk3YzdoTVdzS3UwNnlidFdrcG04NWlDNExGYlczWTB0elJxSXlPc0pTb3hyUGdEdDBYSVhMVHhydTMvV1ZNOTZRYlZaR2J0YUVqTG9HeUVROUNlTGNuS2VpcHJRckZIRlNMa0RxQ0toTGR2Sk9oTjdUak9kdkFsV3hwMU9sYmFqeDIycUowQ3RXc1JHSFI3TUFuaFJxdDdaRzNSeG1QVEsyaENKTEk0KzNMakYxTUpJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnakVyOS9IWld4ZVhDM0dFVWthSTY4UTgzUVhzb3BvdjNYNm9uUTRrWFk5bU5WY3ZFTVJ0V015dkJzeTNualhVQStlYUU2Ym8xZ2dNTkdUN0ltUEp6dWRvM1c4a3dvalRZS0dMWkNQZDlRUktnU0JZeitnOGlEaFVBSHUrRnVmSXRoNWFHV0podXNOZzRiM3pyLzA0bmxIS0FGbjdkUkh6bTJWNlNiSnlORXhjaXA1OHdzNUhySDMrSm9paGtwaTdPMlhVbkUxWXZRY281dVNuV3ROZUs2cXBwVnBQeGwwanBTOEZOSGdIVHJselFoc1JnS0RxandqcWc2U1JtZjBXWDA5dWphWHdrZTFpTzlyNytCN0s5UGtKWjVrVGpWR2tEc1FIYTVIYUhKejgraGRWYUxyd1lqUTlBYWtwdzFJOFZBTHBTZTVldHk5WTdXMSsvVVVLZ3NwalFLR1Evd2piU2JWZlU5YXdmcW9kY2ptbEdZdHE3N1ZvTXpvTW1KWEZ1RWUyanpLeHpHYXVPZmVTNDg1QWhGc2RaZUlta09zdEZHZEFjbHIxQlR4OFJzUlU1b1k5dEtKNU8xZGEzbWk5U09WcFRIaDdiN08wK2lSYmxhR2VOcWtnWWh2MEZ2Vm16UFFiYk9kWnFSWlIrVVVJWVNRaEN1UUZpTnFQMWtEckVnbzhiVHIyOUxUc1pFMHY3VWd4Yi9PTTdvcWk2ei9jL01YcFM2alZMN1dGbUNsSDcwL0t3emFUdEZGREFLNitJZ3NVbHE3aHJJZzJPM3JOd3NGTlZ5VFRoTDhoNzZpK2h6YWx2aitYZmIrU1FtYndEQ2x4TUovMHpUenQzTXhnKzh2aE9GZEZGSGhMYjNUUHFtTkc1S1dKeW1URTA3eXJ5VVVJYmRBbXRvOVhheFZJOWpwUXlCbVM2OEpVTnJtbGR3bC8vb2ExU3BUb3hxa1pKU2g3anVTNnNjK1JlNU1weUx4YlkvUGRwS1NqR2pEYUg2UjFVSWR0eGhoVjZ4cUw0bTIvSzM5eVJKUVhYN1czQ2xSZ21WSmp2c3I4TVpNQzZvREFKWFBMNllTUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkNJL0QvLyt0L3R3YmhGT29vbHBWLy9KL0FPYS9UMGpGZS9sa3dPUVRyKzVhQitkOW51M1hzRUJ4S3VEUThlMVlHZVpQQUpROUZCdmhrOWR1K3RXTEp4VXAySnAyOGwrL1NnZnd2aDBUeldFeEYrWG5oTkFJZlBQcFBwcXBpZU1tbjNPeXFwTTVCbVR2WlpkbTFhTFQzQ0l5ZjNTRk9UdnNHRmhmWW0zamExdmhsWHJ0bjg1VmZVVk5xNFJHQkV2MEw5eVR5VVE2b3JwMDJ3MWwxS3lodWRWSEhJTkc3VWlaQ1pYdkt2NDQ2Y25wZUQvdDNpR1JFV1VTZ2NDTWdza1JDTlAwUDFHUU9WRHBGU1dHdVVtbWl0Und4NEtGZE1FMTE3cGtBK25nYW05WU9aakthOW5TU2tkVmR1MGk2VHNrWlc0R2FrVDhTUlREMzMycS9IbUpRN3JxMjh2YktnOTJmWjdUeDZqdUhPam45dlhsS2FVV1ZPODA5S3VORzZsK0pFUlltRTB6OTNYK1h4d2t0WkszV1JxL1JiOXpydlVaR0lWTEZHZEVhY01Xc1JRZ2laUUdRSjBLc09rM0dpUzFLclhWRTk2dkhBS3lRaFhrcVlJb2txemtsSk16bituVXJmTHIyZU5PNm0xU0dMRENzODByNDVscFJiNWFQdEs2VXh1dUMvRnA0NFUxdTMyUmZzNmMyNzFsZUc1U2VQZi9MVzIycWErb3Q1dS9CVkhIVHBQVEpLUjVmM1huaENiZ2xxUTZMK2RRaFIrNVVXUHpwRFdzMFlub2ZZRDhoYjZUVkFnOTRqMjBaZUh1Z3FqMVBCQUt5WWJsQnJCMnBaNkJrNzBYVUNrc1pyOEdSak50enJPQjAyWDM0eGxaREZjRzRqaEJEeVhzNmNCVGtERTBJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFoNEFINFVpaEpBOUw1T05uQW9JSVVNc0VpTDV2Ly8xdjJYLzRtditPazdqNTBpTlgvOEZsS0Qzc0syN0hJQkc3c3NCZmN3NlBRMDVCZUEwVmg1OWx1eTBkeWVBRzFtaUp6Q1FsNEljS05yQ1RpVVRyUk9senExVFR0QWt0UytuOWpUM2VxTG5FS0huSHRWaHM1T1hJejNGSXpjL1VZdnRycFlUdlcva2ZrZlAya1RLZ3ZZZW9HUER6T3lwdVNwSzJiaVc1V1hZNTdLNlZWOEZJalJIRmNvY3lJdGdLTWRlU3FMVHEycnZuUEtldzZnSUNhSDA1KzdUZXIyNEFTSkZpTkk3WHlIci8rbmpFNm5yV3hranlKVkFUNkpIdjVFUVZUZE9HVk5tNmowQ3pUc3J0M1pIMDR6bTZmbEhoUWQ2M3drSTM2dlZlT2NUSjhCL1JHRnUvZEM4TkFGOFBzRlZjSGQ2RnJCMXd3MlEvS3FlY2NPanpZbWFkWkxnMzB0UGd4NWtXdWtxUTNRWXAwQThyMi8xVG41SkNkL0dEZlRuM2RqSWNyUklsbWZpVldYUGtvUVFRc2dKb0RvT3VTWnNxeFB3MXVhdGUrdlhzeUNLS0xPdG41UW5zdjVQZ2J5U2tkY0l2U3ZkTm8yWkN5VXBpNnhzTEdWbGpkTHM2L056YVRCV2EwYVhybldjeUNNVzZCcEdIVWxLcysvU3RJYnR3cTR5dWtaRGk5WWpoUWk1QlFlTzE3Y1NNZHZWWVhwM05NeXlmS2tBcFNQdUovNmZzbnptaEkxbjh1Y0M5alh5TktMOVdMR3phNnNqYjlYa3BUR0wxdzNYcUlKSmVSWW11aTZLN09WazBOMXJ0cDR0eVVkM2haWENKdExBZFp4aWZUR1ZCZ3RDQ0NHRWtFVWNxV2RkUWFlalhya2ExakFoOTJXbFFaS1FOOEE1a0JCQ0xONG1KVGtyRUVLSUJ5VWxJWVFRUWdnaEVVN1VvS204RTBJSUlZUVFRZ2doNUFiOCt2M1Ava0hZenRPMGVvNHRHbjNGbVJDTHlNRjFDN0tObnBTenRKdEhqOVlaT2NtOGRwZlNrazdwU2ZoNWpVbnhKeStrOThpb09pN1pnZ29rSjl6SWFVQm9zMFlPNU1CVDhjSWxKWHhra3ZIaVJrNnJ0ZHdidi96OWowOUJ5bERzL01MU0hKSHlHY2hYU2pQYVc2eU9YWld6SUdVY0hFd2IzL0lkSTV0NTF1NSsyaDdidkxXOHBEaWpZSG5ka25hb1dFTVRIVEphUEZCRWtIRktJM0kzMWZzZmgvemw0RW5GVFpyTzlTSHJDUElPMnM2RXFEQVNFenVqVjRTU2NDM0NXWm9PZ2FZNXZKNk4xSDhrc3dkUHR3UkhPNUV5dWdKQk5IVXRmODF0N2R5bnJSTldTQWZQWGNNYTBORjFUYTkwdEdvZFdlK1UxRituWlVLYXZldENxKzV6azQ2bnBIdHIxT1RFUThMcU1hM1kzbDFvSllpMGFMYzUyaXMwa3BqWEpGcVlpTkl3dWpickVaVGVNRVhUbEVTSzE5RG8vZmFBRHBXbytQdWtnWFJvejJ3WDdaY1Q2c3VUWHNVb3Y5WE1TTGZ1bGQ0YWtmUktSNWl6N29zUVFsNkZwbmVNNkFCa1BkN3lMNFBYcjhiYWk0c3NHTnBLbFJvbm9nQkhMRHBvdU0rYVYrb1FucEx1K1NONTE3OTdORGMwajRqR09XcUxBTExZeFpYSzhQdlAxMS8zUzZsV25hUDJpSHNQL29qNVFJb1g3WDNhaDI5VHRUOVlhbmVySUUwemErSFVNazVvT2tRU2FXdE9MMDNsZHRWMDBLVTVJWmNFN2ZpZU81bWk2Wnkxb3lHR0xiYS9SbTR5eXpzUEo2S2wwaEZ5WmJ3bG1hUCs3MlJEMC85UjJaS0FJdlRxazczNVB4cFVjYVE4NnlhNnl1Mk4vMG5EbW9ZOFMwTUtsQUZWdlc3SlRPRXlLNjlzZlRHVkVFSWljRkluaEJCQ3ZqaGpVdVJFVEFnaGhCQkMrcUUyU2RiQjNuVUhqdHkvSW9SY0EwcG5RZ2doaEJCQ0lsQ0RKb1FRUWdnaDVKSmNRRlhuYW9FUThuWisvWDdrNFBlWGo4UUhEOHIzUDJtWnlHd1BGOVA4Q2VsQk91WEZDb080TzhsSXVDZGFwd05BVDhScE9YQU1vdWYwSWFld2taZEFiWDRleU9Hc2tyc2pLNzJUd0ViR0xTS21mZGt3NnpUUTBKbG56cldHZEI1TUpHNFZYanQ1dFhpbjJBcHhWTkNKRmNuTFM3UDFhOC9XMGVKcktHV3RkZVBQWWNHLy95bkNPYUR0YWJYZlNlZTBUUnJyd2JtNTl1YksycjJZNmRjaDVCamJ2SXVTa2h5WGM3TkNWQy9yV1NlZG9uQytCS1V1eFZPOHFxR3pHYmM1eVI5ZFZ0SnFzMFpVSU9ySEpBUXlIWldnUDZLc2dWZ3pmbEw4TFBlSlJkdUJydnV0TW9USEx5bzBlbzRxdFB5amFaTExjMmF6emxndFNHbGk0YU5TNG95YVdwbVh0eTVBaElHRU5YblVZYVIwTE9ub2JTaG9hV1RsMmd2bmdSd3o3bDIzSUNzK2o4OWFNbGRYV2lnNUY5UXVxNkdPbEhiWm5PUldFSmZOdmRYUnBvV1liTHpGTnBwWEc2ODQ1VUhXZjlvd2paUXRZbUpKZ3A5blE3UkF5eGxkTzN0aFJ0dDBCS1J2S2Uzb3prb1p6d0psMWF4amRYVjAxaDI1dDFYM1JRZ2hqNkIzVVdiNW8vb0ZXWTgzMGFMWGp5T2l6SHFycWpaTk5KNmtXUGV1VTFIN0JwSitWSE1hVzd2K2JMeEs5eC9ORzlVczI3aW9MVUlMSzdramk4K3ZjR0Z6aEtjcG4yZUxPRk40V0NPcERoUFowdGk1Tnc3YWwxSi91MnVQQ3JRWjdXck9pbWZSMFl3amV4cWVsYTY5WFZSaW91NkVuQXFxUnFEQ3B2WWpJcWlHZ081b3RDSVQwVUk4T2RYbVUxSy9ETk9tZXZlajZXN0NpWkRyRUxGRm9LcTJNa0JMRGdVUGdhNFdrS21qMWFzNFpCWFEvVDVXb0l1bXk5ZitLZlZWYVc4emVPTVFGUjJQQWRVNzJ6akZ1YTVwOTV3N3VOWVhVem40Q1NHRWtGZkJxZjlJM2xiYjdGMkVrR3VUS2FZSUlZUVE4bWk0QmlXRUVFSUlJWVFRUXNqZDRYcWZrQmx3SkJGQ0NDR0VFRUxJaVN4ZWxPWC8vdGYvSzU5Y3RpL0NsdW8xNVp4Ky9kZkNrbGh2NHhJeWs0djFMZlFrTUlscFF3VkpCTTJzOTlpRVlqcDNNU01OY2lOR0JoT3hpWnpjcGtSRHp4bHR3MFJQUnh3am1xc1d2dzJMQ0VVdjdNenpZcHEwdEdQVVNtZkRmNGNkdWUrZXM2RWtmeStOU0RnRnREcnFIMld1UUpKN1h2N3lHNTFKN1g2TjNUNWVGaTREUU5CS0dobTJiSXd0NkNsck5WWFlzckF1MlV4a090YWl6RHBDVm5LZlJGU3YxUHhXY05zeDZNaXRLV29XdVNXV0NKQkFWeW9qM2VXWXJ1WVlyTnp3a3A4VjMwcGp4RHFZZ1RLaGFYdGxpUXIvVmZlYmpQaG9PN1p4ZTlvM3VtN1g4bXpkSmIrNXpGamxvMmxwSXcyTmZ6bThkUUlhLzVQR3pBcFkyMjFzVUgxeVJoNUp5YXNubjlIMmJOT1prUmFZMWNpc3RHSmNmcnJ6aWlwZERWVmRRZ2lwUUZWNGNnMTZ0K1ptNkZIa0MxU3BuN2tXamFicGhXdmRyVHhRZWpSTXk3NHhRMU9MMmlLa01EM3RXTWNWL0QrZjJKVGNOMWtwKy9zd1VhUC8vZkYzdmZmaE5iOU5PR0Q3UHl2N2hSbk5iT0o4UE52ME1ETXZUai9rbGJEanUvVGFxVHl0YXVhT1JtckNmZnpyT1FKVnRWMlZ2aWxVVWR4M2lTYkJuLzJQUElsZ2Y0NW84dEdoc2twdTNSNVV3VzdqUExaQ3JnVnFVaHBaRlEvUGdVNGVqK3NXUFdQbWpESTBlc2ExdnBqNmdVS0RrUHZDOFVzSTZZQ2lnNUErT0hZSUlZUVFRZ2doNUFOWFNJUVFRZ2doaEJCQ3lIUGh1cCtRRVRpQ0NDSGsybEJPRTBJSWVTdWNBKy9QcnovLy9qNldJK2ZtaGRhdmQ0OTdUdGlLdkg3TVV6aklrUngwL0pkMzBwcDNjazQwank1V1pGYUMvZ3ZiNHN4REFzZ0ZZQWZvWjlJUkloOXhteFYzS2NzbzEyM21xTkJFS3h2OTlzakFjVUhxY1o1SFRob3p2c015YStLYVFObjlHRW9xTy83dHI3SGM5R3U4aHZHeVVIUXJIQ0VrRDlUUlhrTno2dkZvbFU0NENKa1FERTE1aTlwM0ppSVZvVlBUbWNvbFJhVW1MQkMxTTNJOE1DRmZyQmdIazVha25ibHExMTc0U0Z3djNBb2xiclpDNlVua21YbEplUmNoampTQjllWVp2ZS9XUFJ0cG9qMDdNZ0hMYURuMmpER3JwNDJNMVZQbTB0RUs2SW1Ibm1vN2MrK2lkNCt1TG91WEZycEkwWlE1UkM5QjYyNFdNeVlmYS9pT0RXdVZrVmxwOXN4Ung0M2VLdHFsVm5LS1hDS0VrS3ZTTzBsRTVud3lqOTZscUhmTjlndXcwaDZBS3RCbzN0NUtzVjJjakNpM1BScVd0MGlaeVprYWMrc3N1R3VmMnhUVFF5MEEzcE1jengvNHZhMitDeGZvQnVMWFVtY1VSbXBtWmZnZXVkNko1cVdaQVdiWXRRaTVMTnI0WlFmL1p2Yk9odWZYazRmNkhIaVI0d3paMDR1U0o3S2w4YmxtSHlOUFJOcC9TRWxWSkFvNEJucUd5Z3E1OVFobUxRc2o0U25yWUZiMTI1bVBtNzNPbkhVWG9WQTNjUDc5WXVyM2N4d2w3VjVDell1YnhiTmpFYklDN1dFRzc4RUtFRW5ZV2M5a1NIRzBjQWtNSDhJYmUrMDR0YTY5UERSTFV1TWNBUzBDZVFuZStHWm5pVE1nd0x6bjBYcmlJZTU5elJ6TmRTUVAxQ0lVcGRIeUVFVkx6UklaTkxNazhNb0JHazFiTlJrbVBPclhqekwzZmtyMU45cFRjaE9qQ0w4K0lXVjN1U3gxREQvc05tMktaWkRWUTR5S0ZFWU8rbXZQRGhUVnV4czJMem1FR1ZiQ2lVVzRnaWxKRzNOb1dJM0R4bTFrSWo2cmtza3BaT2ZhTWVzc1ljNTY3MHhHUi9ZWk5iRFNlQnBkRjZOYVRyc2VqcWFKbEVXS1AvSndibkxDSFNPQW8vb2tVdk9QMGtFalhXMEcrQ0piRGorNlVWKzc5NHF2N0xoNUJvNFIvV1NrVFZhWUFHc1dEQXhwek0xc3RsSE9YSlAyYm1VUlFzaXJXTFhVYVBXSWlIcE1qZ044ZnVOOXpOU3daaU1OSnExczBUV3BOR0N6VTVZMi9FcDY4L0E2dHJhK0x4MXB6YkpGcE9RK3F6bmxXYzRWaTZwek9FSjhSYzNwTzFOQzVaQlhpUlJ0SFE4TTAyaHZYYVZDUktCNlFTNkpwMTlwZzRmNjh6Qm43bWkwNFRTL1NQTjJsenRQQ2tQSUhaa29POUdodE9xUnZxdXNRQS9qZFRmOFhMenR3WjQwZXJ2R0s5V3AyWUxKOHhlVW0xOS9Wcnp0UzZtbENyR3FWWXB6VGNoWkRQWkZ6YzR6a3RVaHcwTmJCTGNySXlsT2IxNE9pSXlrNkhncFduLzF3cE00bXRWbWdheEVXYU5DZUozS3N4UjZSQlNxa1R1eW51b3pOdFJLVDYwdW5nUk9JVmkyVDBmT3RjTWFkbGtGS0pNMURxa3N2bGd1eGhVUm1ma2dVSThmNmNkWUVNeDhUcnczTGlIRGFNL2xITlRwckhub0tDTHIva2lhV3RyZHpFaUl3dVNWYU10QXpaOVlqTmJXV1k5MlJkd2phWHE5YVVUTFFSOE83U0dTWjgvNmYrWmFjbDZhNkpTUDVuZzcyVEhhdkNobjdveDZ6N0hQVWt5S2tLWm12aUxEOURUYnF1ZWlSOExObUhXMGEwSUlJUld6aFNReTU1TmppYlRCcEgzZysxSkF0N09JYWxpamo0RFdhZFgrMGtORTBWZENqdGc3ajJpYW8wOG1lZmNOa2dXcmQvSHk2bUcyZ0Y1aDM1akhVZFk1Y1FRVjIzOGEyam9leUhURzNzWVIyOXB0bm9SY2p0NEhocWsvRDNPRWJVbHpSelVBcEhuWi9JUU1Na2toUVRUYmxhdkUxeTNIYWJ5L1BLc3RFVklhcElPakZtV0cvNjgvLytaS3V5MjE4U2ozYVR1UGV3S0JQSklaV3J4aVhSazFyUjVpNzQ5dVFCVEhQeVcvd0o0dHVzU3pKdVFQUGVPWm5VdW1WeloyQ0s3bjdXMEtHMFU3OS9wNjVwMjNHNERJeTZsU01sLys3WXVxMys1MVdsTGUyblViWjVUb0FPNllnTlEwYW9yK1VxcFdsKzNoTDRFdnErYk5yeUw0NTZaMHZST3pGR1licmk1TDJmamxKblpwWXZid1FvRnRpUkFyck1YemhPNjFRWjRkR0VoMlJKb1JNb1EzWlZndk5renNvRWVvckpwbUovbHJZYVJ3YmZpc3hPbXA2aUZqaEhmRFd2aVJkbjNoRlA5MFJyb0ZialBiNWxLY3NHV2p3ODdSVHNlSVNyRFo2NmpaYWRacGp3cUVCS1JSSnVUdFNYQlV3aU5wZSs3cldGbVNGVk9HcFVaTTdiRm9CVVRXWkdoZXN5dmY4cC9SYlQzL2FGM1dacWxzaE5QOExmYzdVZGZEUXRCeGlxNHhaOHp4cUpVcWdlSGJ1SWdNaWVyd00rNmZFRUpPWTNRYkJiVkxaeUJOY2p5ait0UnIyZzdWaG1vM0tid1ZkMVJKbjdtekVQVXZ3bld0MUordEhSMWhvRlR5VVBlQnRlaUFKdHI5SmRUb2dKY1dhYytrMTg2ZW0yYlhSblBXUklYeTdGc1gzdnljaFo5Wlh4L1ZTWGxadHZUYWRhdzBvbHNhVkMzSXBZZ2FWYlQ0bmh1NUpDTWEzdWRiWWhJbDdWV0NYT3owSU1ITnZrWHVCcUErZXdySWJwdzI3bGJTSDNkMDlZUHFQSjVLOTJyNzgrZ1NrM0x1TUdiMlYzUThraThpbFQrNlVSaWxmRjVNYlJNdlFzaVpJM1pVZUJBeWd4azd5ay9zeDlIaHpzbWNYSW5JbU9ROFJKYnlVWFl1TGlTTGMrMjVFNUsycXYwTTlZcWtmYVY2RCswaXNESE80NnM5Vnk2RDJiemtNS1NPM1BNTzBZTkFiMittbWpXdFNtK2lzcEw3Y0VSMzhwN2xrTUpxMStRSm9GdkNWK2Vld25pbVNlRnk1b2lyenBFUklYZ1YwTHJzMFRQdnhBRjk2dTRxM1VoelIzVnk5RjByN1pvUVFnaTVQTFQzZ0VSV0ltaWx6dEFrUmkyT1dyZ01YcWZxMm5xakliSVdmNmxHaFhhYnpBSGJTK24wTS8yTDQyOGxNSHUvQkUzdndDN0VLWVlRUW5TZzk1RzlaMGRtcVUzY0J5WjN4dXU3MnZaZzNpWXh3aFdHem11R2IyUzc5NDc3WkErRCt5VmtRelVXZjIzSDVkY1o4cmw1UlhaRkQwSk82YWpEb2U2RVhKRFJBNUlPb1M1TVNYS2hQYnV6eHdGUEdGRTB2SVJvMzJQSGlPT04xMEdCTlhJQUI2cENmTUpxWXF1WXFVZ2JhMVpwaWhBWHJhUm9wVXJueE5ScFNHV3B3OWJ1eXVibzdndXBTUWt2NGVXUlFIOHJYTzhtNTBpZVdyelBVWFpCQVFNRjM2KzJTL1Z2VmhORittdjlOeW54a1BzcVRjb0Z5dm5uR21tVGx3cHY1T1hVTm54S1dIWGxoQWxOZ21HSnZjWjRGcTNpSGtuS1ppVEw4VHFacG41TUJoVjNkZGhJVVNKYVQ1MFhHditRSllxbkNrcGh2TFM4eW96Y0dJWFZaVUc2anVUZW9SWHYwaG9KcVduUFNGd01YYXUxNDBocm1lamFKSUhoTGFLU2FjYUFIcEhFV2g3b2VpY3AxOG1KSHcwelM1Z2hTcjhXTHlYVUZ1SFZZalRYT2kxUFZpQmNTcGNkcmFRenVWclplMDFlMGZoWFo5RjlSSkpGeDJmUFRKQ2N0RFQrK2ZyN2J5ZGN6Nnc3eWlFNk95R0VIRTI3amZSQnUwWVhpT1FjcEkzUW5uMkYyM0wwQ2tLcVZHdkRKYVU1NWJNYVdndmZRMzEvT2ZWMUluUlhZd1l6REpSb0hsbDJSbXdScmprbWQvb3Z2TDl3dkhzTGsyanB1KzRXRkZmb3gzaDMvQ2Q4Nld3R29CZnZ3czJ5c3FMdWhGd1N6WGlpdVhzaVV6SzRFcE9SSFEwcnpaNzRrTjJxU1Z6THkrdENwVTRQTFJnaFo5TXpRRFZWMWJzT1pvMGtON3J5OEV3dXI1NEN2Q1YyN1gvazhwK0U1OW1SWFc0dGplZ3UvMk83eUl6SzFkS01OcWdoc0g1dC9SR2pFaUhrRlZ4SUhFUVdmTlE3aUFnN3hxTXBBYjkxWGFIWE5EVXo3NmZxY0dmY0c1cG4vdmx6VVBQZnBiVUxmTTMxaDhrcUpjaDc4cFNNY2VhVWtOaU01Q0NRZnY3UXppZzludFg2M3g3TDJFK0l3RlUwdXVQSEgzWFpkM0NIVmRqeFpYdXhLdEJQNy9PK1o2ZE5Ic1BkdTBmcENETnEvcUFjSTRROER1b0t6ME43SHhKOTZ2WDJmZUtNMlhxMnhvRVNXWnVPTkxDV1IrdnVQVDVLNXJDaVhrL2V4TG93cUozRE83TkJOSy9QV29SWXc1dW1Ta0x1emRNZi9WckFpajNhcFRPa2tQalFyRXliTUNGZFhHa2xRN0dmbkRmNmpYQ1VnY3VKenJOWGFoSjJpeFA0VDZYLzJqNFUvdmR2cnBxamZBVmNDcUpaYVNmTEVOTExDVkxIeTFKVGVFN3I3dlVzSVIxNWhzNGlFMjZBcGxFQ29WbUEyekRzVEQ3SWFSZlN0U080a0hYRWl1YnhtOTNMSFJGNHJiRDBoQ09xM0FSZWtGUnhhbFU5ZWhOcFlPbCtrWHJ3ZHNHbFBEelFkdlRLWUtYUjVtVWtBWlVoQVdYWTl1RGM1SjIvL0ZxOXZuOU1SWVNublF0MnNFNmhXTGJJanZ1SUF1a0pSODZaL1lCVEF0cGMyYmttNUJRc0k3QVZmbEN1N0I3b1NQcU1Qa3VEU0VLNnVZbUxjdXI0UlhUODBSdmp2UEZJdExGV0k2a2taM1dIZFhsTDBpYTZCUk9WVURQdXhHdEJyVXd6SCtPSXJ0V3k0Mit0VFpBMXBoVFA2dUZJcjdmUzBOeG5DTStZd0o2OVhCakplMlpaYmtXdFNFUjUyMEtBQzU4aEpCVlA4b3RnamR2ZWNmcnZKdTNjdUJOQ0NPbkVVN0dqNmZUYUM4ZzVSTzEyaitIS0t3ZHZSWVNza0tKN3p5aWV6YUsxaWthTXdlMzFFVWJFU05xV3JhRDQ0Yi8zMkR2YTgzZmMzM3Z6bi8zNXJOV1pVNGF3TGVMamRwd3RZaVk5MjZQdDNlN3VQaWZ4QzZYcUl4UktWWmNxVHQzakN6S3N5K2FQeTNjMGFmZ3F6WU5hNWJTOGVwaWxqaEJ5Q0wyaXNjZllhWldCcUJ5aFJZem1aVFhoVGlaKzlUbGtoMklYVDBxUWtLY0M5blZKNTF2Rkp5OVVKN1dHYlVuMnp2TnJwd2JOcmtFWmVEalJuZllSUnRONDdIZ0IxNlRmZm9FMWFQaUJPY250SzQxZlVrbU5OZW9hUnUwZGhQUndnejUzK0Zqc1lYRUIyd2QrS1NvSVJPbjBJK05jVkhDOXE5a25TTXRpZVNBTlRJbDlUL0FCaklaa0wxZ0FhbzJPcEVYbTBBNE1SUlQyU0VqdnNRSkNwaE9WTlVqSG50UmhWMmdaUFJwT3I5cDd5WEg3dWJIWDdtcVFwN0YrbkhIQXJPY09kY3gxcjlaS3ZRODZqc2E5RFJRZjVNWndCaVNFRUVJdXpsRlA0WklPU3ZCYVN5UHl1Z09TWGtyN0ozS2tGeVJMRThkTHM0N2Irck56L3J5OStQVkdaRDZ6VHU3VkhqMTJBMDgwYWkrT0ZpK3piTWVCYXJiVDRISEhrY1NSVHdnWjVYSFdlRDdzUWNoUzdqakVqbnk1OXZKdzZYZ1pEbm9VYklqWGRaZUwzdkN2N2VWUENUZmxQZk9JRVNwZjVNWm9MNU43MTFJYTA5RU1aWkpkMkR2bVlCSFNBNy9hSVJpRW1FaUR6RDBXOGFVWVJuUXhIT2duQlovMWNvMGxRK054TXhoUzYxUWFrZEo1TmVNZGQvTDVhNTJoOU9XT2JuSnRqZ05GNzZYM3JCenZ1SllWQTdWblJsYktrWk9jMXE0cDZqcE5UblY1ZWVldmY4dkcxKy9YU0Y1NzkrMzhYSVNTK0tudFkxQUFEK09Kcnc4alZjM21rcEdPcnRQRXNYTHE1UzdKUmtSRWlpRDVzY2xJTjMrRlBRYXFSazFBR2xwV0ZrZ1JJaHJPZGk2Y2p6ZHVsNHhyYmJHdDJRd3c5UVJ2SkhJcmVwcFY2N2ZScnBHYlg2MCthaS96WjNiRUVreHYxRW80VXR2ZWdLM2pJV1daaWJjR3k0cDdNdHhSQlRnNzE1WXdyTjJsY0pKU0tGRWMvemFjbFNlRzFyT2tjTWk4S2RsdDBTa0I0Vkc2N0FxbDRZaTB5YVB4cEZNeC9EeDNkUHhtMEQ4aTVSRjlPcVZyellpRUVMSWNUNGg1a3dLNUg1YmhpdnBqQitqNmRKVW1JYTNDTkRKNFhZQzR0VHV5Tm8zWVNCS1lWeTh6YkN6SkR0dCs3YlE0NGV1dzRqVnFpNmpEOXRvaXJEQUp6R005STYzWWEwR1p0VWYzc2Eza3J6VFI5TXhFbS9SSHNNcHRYV3RwSVdzd2plTjdGaUVkUktjUGRteVkzcGwvaGRZMXFtVkYrQzUzVXdIYW5EYzFjMEtPWm5SZ0lncUtvN0xPSERMUlJ5TWlVd0tIZGdYdEdwY0MzVmZ4MGtBc0NlaWNYb2RUNTgrbkVuMlVRdk5ISDczd0h1dEl1eGRUcFRDOWFoOGhoSXhSU3g5S0lUSkVBZHpZeVE1bGh0STNvOG5tTi90SGNtWEZmUVp0K2xxZUU3blUrSGlvYm5yNmFiZzRxTDBIb2F6dXUwOW1aSkVZM1N6UnJvbk14Ym8wbTQxME1hSmV2S0RUallqU0dYR1dWekZOZ1dTUUhyWERZNzlodHhkU3g2c3VSK3F5YjlXYm8vZTlvbzdneHhiVE90cUplYjBkQUhtZ01Mb2tRZDJqWVFnaE1nZFlEQStoWjM0ZmxSMDBoeEJDQ0hrTXI1dkVWdDZ3OU9pa0YwNjY3aVh5OUV6MGtVNzBVVTh5VEVZQ3JOYmk3N1ZTV0dWVE1PMGVLMFRKYW5sODRXYWxCQ0dFZVBRL2IyUmZ6MGh6TmZtTVRBbDVLQnhLRDRVTmV4bnUxQlN2V1lOY2JBMjRlVEZWTzROcjJVUHl5SWtGaEt3Q1BUSm5vRTlxV2FEaGw5SVdwdWVJTTdTdXZJb3c4ZzZmR2tmSWIzcjZOL2xMNzVRZkVHRGVJVGF6RDBnYUNTZkg3QTJqZFV6UFhhb1pMVXdiTG5qKzB1NzR6Nno0dHhHTG43WmFwcVRFNjlrcVFpZWdrUzBzTGUrMjdyNys1aXhmUzVOYktZRzhyQWw1bDNEQ1FOcmdiOTdaQ1JVRDJmQ21JUDltaGJEMEdwUnJOQXhuQ0pYS0xUdDEyb29EZEdaQjRJZ2lNS012cFVybmRIaHhCcGtwcnBBWGNxTHBwUlF6T1VqaStyRHgrOGxzVkkzUStnRUYwUzFCTmZuV3orcEtrVEZoeGJiR3lzLzFGWjRxSzhIcjFpK0Q0U3pRZGRMSW1pMWFwcVRraFFpaVdWWUdhNTB0aFpQeWlqTHkwbTFmbnNoZHRhKy9SdFA2NSt2dnY4SHdJM2x4T2lIRXBsZENqa2o4Tm82bkpwYWd2MFN2blFxdGg5TjBja0lJV1ltM2ZhUUpjcktPRmJaL3NvaDZmZjVCMjNoQk5RMThqMDVQeTRxTGxFRkR1bDhwVEVxNDBMRHlIck1XNmVrZ29FYlJyR1NsbEZXdEZtMDE3b1UxRXdXSXRsTTBIcFp5Ynd1bDFObExta3piNTlGMmR4dHRDaUh6ejFmd2l1UmVSMUc2VEFsVStaLzd3WU9ITFlpV2V5MEJwRjR0aFV0R09FSk9BWmtPSlZCek8rbm1hV295YXEvTFhnUkNub1FsU3p1M1BWZUs0MTRkWjZaRy94alFaeGhaV2FjUjNVK3lRSitNaUtwVnIra2VrbEJacmVBRUhobjU1K09iejJnU3JqSUpJUUFVRFNUTUVaTXRDZUZ0bzZ6SXkrSVozV05CYlhhUEhVcnFaMERCK1doSzg3L21aOFVsTWJKOG1VOFczMnhLc2hSVUVadlFFZSttZmN3U3BZZmVOMVU4Y2xQUURRMFM1Y2lhakQ1RWV5VHYydFNZZVhmZWtnTXBBOGN6SVVRaStueUtaU0tSd3JWdWhCQkN5Qkp1YVR4Nk13VzRqbWdhM2liT2h3eWtOWnZJVGo5YWxqTzFxaFB5cGhLNW83ZEt0QjRHOWJ3bVFIdElySnAyU2ZJSEZacGhxMXFNc2gvWFpmVXc3NENQL1JKQzdzVFZYMG8xS2M3L2hEd1pUZUhJam44YTFCczc2Qm5mSE1LSmxmQWdPQzI5bEVvZS8vcjc5OFNsSVhyOEJ5RkhrMEUvb0kraXAyT2dCeXN0SlhJd29lZXZwYVZWZ0pHbWRmWWp4UVRwUWpwcGhaMUpCeDIzMW1tUXlVN2FTOHE3YnVPZTA1eHRwNUxjVzM5dlZ2QTIrNndhOEFTek54TWg0YktTWjFieWJPTWx4NzhZWVpJVEp6TGhvTlJwQmpyNkxsd1RzR0FUYjZuK3pVMm1SYW1mN1BqYmViYjkyRTRqbGhjS2hiTklWS2l1TEFPYlNDZWJsNWdvTUpLTlZEMVZIWElZTTZkZE1DdFArNGhxRUZLYXJiK1hWZ3VpdzZLZ3RnUVlUWVdOWkJaVjljaXQ4VFQ4eUZqeFZpQWpHdjI4dVErNU16UzM2RG9RcVlIZU8wVmJyQTQzV3FPUmRhQW5XRFRRWGpOVEVrZjlyMDJ2TmVJVFR2dFNhby9Na09iaGt1NWV3NFNjZzZYeXRlNUhXSFhRUEZBWlZNdUdVUjFnNWN4UENDR25ZVzIyaytjaDdZT1RkSTJaT1dvOWtWWkNxTVhTMC9xOGNGSlplanRUNzc3dkRGdUVSTUh5YWo5cnFTcW5nQzJpN0g3c2kyQnlmVnZFSlczZkNtYTZBMVdaSFkvOGxmbXVCelpkTFdLdFM4MXZWRUo0SUhzYTBhcmlkRVJ1alNma1pteHFFSk16TkxsUnpjZjFISGpzakpCSGdDNUZFUGNjaXo2Q3Q0UHA2Vkh0YmlqSFBUbUN5SjRHb3Z1UHJ2c2tzNVdtUmgyMVRyd01SK3FWYUY2QStlblhKNXl0NjFEc2tSZWp2U2R5NEpBNE5Ec09kM0puaW5QZEc1YmNqbmMzNTZ4SHNHck9tQnc0SVVtTWJ2dXVvTjBXSndlQjdBWWVWUVp5QzloYzVEUTA0OVdGT3VYS3VUWHl3TDIzUkZsV3ppc3FHT1NXbk5tTmtERjBiODZzWFFxSU4zSkVpeGN3VE82TVN3aVJlYXBFbi9Yd05Sb2Z6WVB5aWhCeUtiaitmejZjZUJ5dVVFR1JNcFNndjNZOWM5QzNqNDZ5MDAzaElYTDVMcjNCSFZsZkFYSzI0MFBOdG1qaDhMdU1HUzdFc1ZEZElJVE01a29hWE9UZERjcEJRcTdCaWxVUk9RQXVOYWZUdXpUeEhsRmxVNUVQdno0L1BvcVErRkxxa1QyR3ZaTWNEWGhxeG82TzFjUEk4N2k5SjV2Qjd5cDRSM0FBYjdyRHM4M0NGeWpPZkRlRFhBak5Dc0NPMFk5bFNiSDhBMGxIdDg2S1U2UStvamZVQ3MrUFczM2RodTNOcTQxbnBkMjZneHVYNXFmN3JJbFAyb1Fzd2JKWTUzcDZ0SG0yYWFGdFlaVUZSVWs3TjlmZU1WMEZ6OEVyNStmcnBibUpXU2FPcXZaTHFiZ2FRUUU5blo0cW5mM3NBSnRWcG16K2lIeWZpRnprNnlZcE9ZM0VxaWZ2bzFmc1dKcGNxdnlPQWxudld4clp0TXhId3FGMmdUWk5TOFdsVUxzTXJmYllvOEZycTRYYVg4cHJ0Q3ZGdXBHM25wRFFwQWdxVlpBVnNCZFh5anVsdm9HcDVlSGhyWHRIMWw1ZXIvSENvK0VzZDAxU2F6MDNPV1ZCeTdpZXFIaXY0NHkwYWh0SGlyZHM3aVBrSlVqU1NycytRL2Vka2FjbG5ZOVdKYmttSjRRc1pZWUNObXY5VDY2Qk4vR3dIVUZHckJGb21yUHpSTmFrczdRU3pTYngyKzJmNm5jU3JwTnlqZVliWWFBZXRMR2tiYzVrME1hQWhqUGRVVnNMb3QxN2h0anJNMlFyek5zbXpjcENBdTU1Vm1HVXF0NTBvUkt3UHVhMHk3S2ttSDEyVkkySTlCSk9QK1JSZUpzYUgxRHhUTDd4ZGxPT0tzT00rSnFtOUFramFXNVdlRE1nSVU4Z0I5MC9OTHBjTVFaWDcwNmNwVlY3Y3NwYkJiMStpa0FWVDBSb2ttbjB6cjg5L1ZsVHE2S3IrTWQwQy9SeGpnNHp4eTRQTDIwdEx3MWhuUDZUQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJQWNqLy9hLy9MWC9mUHY1NWJmWDNGNDkrcnY0ZXovVHIveHowRG12dnNVeUVqREx5TnZua3JMMXduN0JUaXhnNVJHODJTcDE3aDE1WS9oUVpaRVBrSXhjRXd6dnByZWRVU0NOcVVwS3J3NS9Uakpaa2pwNkFpcDUybW93OHZiUThsREtYbFdmaVJNN3NYSFZlWHVSODBBeGNWM0hjSkVjVUQvUzA1VStvOHVXYW0xaGpTcERjNi9NbVR6SUlvdlFjb2NOeWJUWUhSR3gvZ2c3V05adUtYSUpvUi9SVW4wQzZQU3JyYXF3eVRGL25uMEdra2g5eHc2Um1wTGxSelJiTm82OHNxTFNZSVVXaVNsM1B1dERMdTNldEZtSFVZaGU1YjYvdWt1TWY2VFhvV3J6TnM5Zi9QRVo2d1JuekxwY3NoTXhoWkQ1ZWhhZEhKOEc5OWtmMEVDc05MNjFWVmt0Q0NJRVllY2pBVzVxUStjeGFBR3NVTUJ3QmlXZ1NQUnBIeEVyWWExMUIxNkl6T3MrSUVGbTk3N3VBck93TFo2VzlTeHMzMHA2ajdhdjVXMkV3a0J5c09HZnB6VDNsRnVNQlEraFBhd2VhKzlPRlNudWR4a0V0ZzBrSmg2ekZPUDJRUnpCcVRIajVRTGpiamdiYVhDUE52RnVLemQ1bUlPVEtvS3B0TXZ5em40V1UzRDlPVm5WOEs4c1IyNjhueDE2blIwVUVPV1hlRU5HZDloSk1RL0xQVG5raXUvdFVyeFJtS2xwZTJsNWVGZnhpS2lHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJZ2ZqMSs1Ky9MN0Qrdk01YU5xKzQ1cFR6Z2U4WHQyL3BublVzRm5rUEl5ZHdUTUk3UU1tTE42VkkwU000Um83L0FLbnZUenBKUWZLWC9BaUJENEZraC9IcFBWaFRHcWhWTU1OYkhjL0l1Tzl2MXQ1anhqVEpoWnhyRkQxN1U1T09rVFRxdE5MK21FNUxCL3p0VjBhT0tkSW00SWdFbDNwQlQ0c1h3RjNycWNYMmQ0OU1uU0Y0NUVuYysxcHAvZzYzamRlR1NtNDZlMzYremlyelUydDVFNTRvZUVkSldlNlJVenkxOENQRGxFRDExSjU0dkFLcU9tUXBFWlZBa3lsZVd0ckNyNk5qSTNya2JDd040bk9OYUlPM0c4ZldIUExJRzM0MzFwcE1XeDJsSmc2Ni9wUGlhMkpGSzR0UFJGQnB1YzFLTzVvV290UnBZVE1ZTHhsNXBHQWVXdmpJQk9QVmFYUXRqbG9ta3hOT3VyYnlRdU1jdzh3RFZ5TWpLUWZ6ako2b1N3aVJRWmY5UFRPakZoZE53enJaM3BLK2xuUzJacHMyblpSaWVzU0lGa0VJSVdFUW9hTXR6dHE0MTFCRDN3MmkxSG8yc3NlM1krOXFwR2NtUml3U005THgxcUJKY1p1eGJyYktrSVE0Vm1mempMOFdXc2RHMHdMOXY0c29DVWt2aWJ5TjIyN3V0R20zbXo2YktpNWJ0MTFaVUJ2RERGdEVUM3Z0U3pBalRoNzB0K0swOFhZOVRrazhlMFlITDg5UzFYQVd1aDdBVEh1SHQxZWh1VnNtL3B5b1FwQ2JFQms4cmQ1cytWdDV2SFJ3ek5yUmtMU1NJM1kwTk5BdkwycDViUEpUS2tKOWRvUjlpOXdaVGJGb3lXQWFnajZGN3JCcVJVRGphMmxhS3pNdjdkY05aNjJ5S05lbUU1bXZVSXRCR3o0NThkQThyYldhRlA3VklJb1RhT2JZeEpmU3RoYU1qZDgxdjVoS3dVTEkvZUM0SllRTVFCRkM1bkZtYjJKUEpvUVFRZ2laQ3RVclFzaHRlS2ZBb3BnbWhCQkNDTGt4Vk9ZSUllU2lVRUEvR2JZdUlZUVFRc2p6b0k1SHlCZ2NRL2NuLy9lLy90LzNlNjIvdjFoVXBHTUUvc092LzdwSWMvY2M5VVJJRCtnSkhSMUpSZVBWUkY5Z240NlZPWG9jd2dFM1FGRkJOblFjZGtrVVJvNm1CT3QrVmZOZzZhNCtVMlhrQ0JKUHlIN0NGQ0FOWjVLYjBnamVhYnpKTG9QWnFiek8xRHZRa1RxT3htbnVvejRPOWMrMWN1UnFHV21FYlo0L3JaMi9ycEc2dHM3eUtzNTFTbHJkalhVdEN2QXVKdXEwWkJGbC8zUGsxRHhwcEZ4eVhVR2V5UVExSkRRdEtkbjNhQmVyME1yZ2hmdUVqYnByYVIwTzJxNWVQSEpMdEdaZTBieHQxL0s2bUVSeFV6MWpkSG5yd2RUNHo4d1RTWHQwemVWSngramEyWktLS0VoN2orWVZYZDlmajhqOEUxVUJabkNGMFV2SUhVSEhUSytFWERrR2U2eFp0WHRLYzJZZHpaOXlpQkN5bEtnS1QrNUo3OUttSnk0SkVGMGZvcFpMTFo1WEZpdE56eDNwS043T1EzUmYyRXNiTFFNU0RkbDdEYWJ0N2ZQQ29OcHNTbmlmOGZLUTNDWC9mbWJxMmRGZVBMR1Y4ZG9RTXQ5OUdiVnkveDJ1U082cGlwUFZwS2VCcWhHY1NzanI2RjM0a3cyUnBjcXFQQkR0SkR2dUk3WXlqUnhWSXdsNUF0RUJDOGpaMGFFVVhVVkplYUk2TElkM0FLK1NXWm5UUWZ1MUZDK2xPZjA4bXRacngxWkU4ZkNXLzcxNUdaVit6UyttRWtJSUlZUThFcTZNam9OMWZSeEgxalhibFR3UWRtdENDQ0dFRUVJSUlRK0d5MTVDQ0NHRUVESUhhcGFFRUVJdUFLY2pRZ2doWDNCS0lJU1F2L3lxWDJmOWZEM3ArOHVwbjJPWThnWEU1b29qVXdqNURmcmhnWjdqYlp5a3ZheWtMTDNzb3llOGhiRk9KdkV5UmdxUGhET1NSVThySWkrRDJ2ODh2S01ucmNFSERrajA5Qk4wZk1ma1FHOW44WTdMczY1UjRTaUZiNDgxS1dDZVFhUlRYM2ZIZkdwbFVSTk44NG1lZWZVQi9hNkxoSFFrVE5IVHltWHIzdXJab2RONnQ5ZittQ21xenpabTI1ZXN5ZDY3M2hMdC9TT2hYMFAwcUtnMjdNcWpLZGxrT0VxZHFZZHVKeDF0eEhxam1aQXBTUElGMVIvYmVKYWJJc2Q2VDcrTXpFL2V5Ym5laVpxUm1iNEE3a2x3dndRWmRQZU9NVVVxbVZ5YWFITkZscGlTdTZUUnRuNWFlcldWUEk2dHE4Y3RkaU5ybE5FOHRmVWtva21NcnZNaTVmM2NIN3Aya2VKTDE1NkNIYmxITDYyZU5IdnpHTU5hVG1nMS9ZOFFOd295c3VvOHRKRkRDTEhKenZVSGJmNjBaSUVtcFdlUlFUOHBIRHE3V3ZxRmxpWUtWVnhDeUI4OElZa2FBTkN0RHlrc3VROXN4d1gwek1oUlN3VnFQYXpkTkhyWHExb1pFQUdFMWcyNnR0YnlyK041bXFhV2Q1czhFaC9NbzkyMDJXM2lGRG5aVGRFa0xiV2tlZmFJK2JhSS9mU0M1VEZEMTBWSDJuZWVUYWFsTFZCUkw3LzU1eXVOZnhjNVRhL1pOMzVWdWNUZTdEUkQ3NVN2aFIxUk55S2ptcEJiZ3k3OE9SaE1adXl5b0hrZ094cEkydG9NYllWRmJVdC93dVMvODhOR2paRFVJQzB6UXM1QUd6elJiVkJ2R2RUcVdWbk9zazZ1R1A1MTBoRmJ0K1hlcGpsVGczODh2Y3RLN1pxNFJLcTh0MWswOTVrV2xtaFpIazlFOFpDRVpDdTNwVFNURUErRVgwd2w1SUZ3RGlhRUVFTE81TWlabUxNK0lZUVFjaGFjaFErQWxVd2V4UmtkK20yRGlFTGphRmpqaEpBSWxCbUVFR0pBSVVrSUlZU1F4VkRkSUlRUVFnZ01GUWRDQ0hrV2krWDZyNzk1Wk9HbDJQd244NTZUUzZad1dzYmtkYURIaUIzUUo3Mlh6YjJUeTBxYVdFenZLSG9rSS9RSUV1TVVPU2tZRXFZOWQxTHpSdzV6SVE4Q0dVUUVZNEdDNG9tSW5wTlV0SGgrYzZPbFNjcDFKRzB2TG5xK2srVG41YTNVd2k0TDQ1alBYQ3VNOVJHamlqdU1WMWFwSHJ6anRaSnk3Ym0zYVVhT210SGNyZU5hMGJTTG1PTGVQWCs1eXBuOGxLUUFlYmF4NURCYTYzbGxhWE9nV0FaQWhhTjA2TElYdGdVVnlLT0MrMmtFSnFDTXJrM2FlR0R3enVRSjZjTTdGaSs2WGd5QWlxR1pKL1ZGeFBCbzJ0UFgvelBRSjM4YnFXSkdiNHp6eitsRVZ6aVNYODlwMDVFeXlOcXNMSUQ2dXBSMlpxNVdraGxTQkYyWGVyV0xyQUdzY01YSXEzVlBTbG1zTkQxUXF3SmFwdGF2R0hHOHNxQ1RZU1JQdE4zSGtITHh4aWU2UXJjb3dUelJYc3FwZ3BBWTF0aERackNJS1dKVUY0ak1KR2lhcU1Vd0VoNU5qM0tLa0pmUUxoOHNmOGs5S2Y3bnFJN3ZSV3UvU1B5VWZNVzZ6a3ZxRzJ6bkRucXRENUcwUGFSTkhLUXhyZlVpdXI2MzBwU3VQMmxJSGEvbmZpVjNMWjhlNitvbnFkd0VLM3UvVFhLQmZ0REdiNytvYW1yUVVVUDVpQzFDU3FPMmpMWFBqNWF2ZitVMEkySkxBMTB2N09JNW1SY3BqeUxuMy9MZGZFMmFId2ZwYTZoU2ZDMnZqWGRUM3JhYlJ0WkZWQ01JbVVRN21LUnI0b0pvQmtmdmFLQitVcHJvckp5VnVVSkxCOTRpSU9RTUJsVHZjTnJ0Mk1sK0ZJL29FRUxsVnF0VlMxcTJjUnZQQmpYeXA4WmRjcU1NSE9LSVBZMUlzOVo1anV3VFA3WmJlQUxJTTZFZ2xWckFheTh2QTM0eGxSQkNDQ0dFTElZcnhXZkQ5aVdFRUVJSUlZUVFRZ2doTXJRY0VVSklBQXBOUWdneG9KQWs5NGU5bUJCQ0NDSGtPVkMzSTRTUXYvejYrMmQ3TXRmUEM2OG5pc3ZJNjlPRXpDUnluUElpa0pmTTI1TUtwaGNQT1VSUGlyTVZKelk5Ujd3MVFkcGc2TXYvS3c5eklSZWs1elFJRWtNYWZOSGpUWVFrTFBlUjhlNFhLd2Zka1J4NjlTcGtZbXJQWDlMaVJrOVFiVTV6ZFUrR3pidW9lcGhXNkVlVVArOW9tRThZdEFOR2pvNkpvcVM5TzJwMUh2dlRpRXBUb3R5RTd6bW55SzRyWFkwb2NFNFV5MEc4VThhUzRvNklrbVRFaVlicm5CdHVqYVZYdHlnbkkrZWlSNUhjMFVQbHNoR09rR1dNcWxtL1VZK2gvZnBUUk9mdzRYSUkwYmlSOEgyejhFbEUxYzZvdXV6WklsTHlqMGIraEtXZ080eVJWWkcvOHRnMmZGRkMyZjV0bmlYazNvYUt1YVArYlRoQWtmaW1YbXRabXZaSUdYc0dPNEtuMUxiNVcrY1JXM0drUEwzeWpFeFlVV1hkY3o4WHp4SVJhWDNOMW92R205bXJDU0U2cUtUVjRsaTZnVGVPbytPMk5YY2s0em9wL2hHZGZiWW1RRGxGeUkyWVlWVDR4RWVGeGtpZVpCM1dFZ1JaVm5sTG1Eb2ZkTW4wR0VZTk9pTzd5bTNlM3VvbE9rQ1J0V2drenFpLzlYU1NGZS9mUnZ4b0did3dHUXluQkZNVjBNcWgvUVJtYmhKcDk4N2J6M2Z1cWlGaXowbEtnYU4xcXozQWtaU3lTZXY3TExyM2dJNWlyZXFLc3RXdXhjdEFIciticmZUY25MUDl2d3RibXE2UzlWNk1yb3VzcVVIRFc1c1I4a2g2OUdacmVpY3d5TkpsUCsvSTRUMVppTXJLS2MybzdFWERzN2ExcFdGR0pPVGlTQVBhOHRmQ0RZNEJUL05GNDBwcFNQcFdxMTlwOHVjMVJBVjI3ZGZHOC9vVTZhYnRyeTJvMnRUVEpLanBET2s2dDBSYmpFVnZHQkUydlF1L0FVSEdMNllTUXViQ3laOFFRc2dsNElSRUNMazRGRk9FRUlKRG1VbklJQnhFWkEzc1dZU1FDSlFaaEJCaVFDRkpDQ0dFSE01YnAxK3FIWVFRUWdnaGM2RitSY2dZcnpwNzdhSDgrdno0dWNlZjA2N0s5Njl0aUVQaEVVM2tMTFJqYkx6REF5ZjBXU1FyOU5TQTZXaWlRRHJ1d3p1eEluaVVRVVFLUlU5SmVOeXBDbVFMZWdLUEZaZWRBME02MmFzajZnam9TWnRybTlRN2ltUUU3V3lueUxtWXl1VG1mY1ZUK25KcTBjN1dIRDEzU2p2RjFUaHExRzFWNyt4UmJ3THp6cmJ5bElTMHIrUHY1SVM2YmFMKytRRWMyNXBWbDQ5Mlg1UjRXZkNYNmdLNFR6VVBtYlptS1hJSHNDbzVFa1pLRXgxaTFwQmlROHMwZGZWOUdhd2pWQXF6NnNtcFdGUHByTFJCSXZwbmV4cW05THNuYnk4ZDFCUXhtc2FwYUpYYitudnpWOFNZd25sb0NlMDgxTE5DMFpwejcxN0VORXFUNC9ITjNOdTVablJ3TGE2WDUwZ3RJWG1VUUR4dGtvaElPalJ0VkJKTFliM3dYdDZ0TzVybk5ZbmNsUmJlYTltVTlHVkZNdHdwNmdtWlE0OUVhbWNBYjQ2WDRsditTUDdXdFpYWHpOa1doWEtMa0J2VHEvNUxTcEFuY0tQaHlUVkFiUkdJZmIwTit4cEdaOGdaNjE1cjRFcGF6MHkwbFZGME5hYkZtd0hhZ2EweW8rWHFyZU95K2JQMSttek9WR1dvOTI3Yi9kdzJ6R0cyQ0MrT2xUY1MzMjZEcUM1ZjUyaUpRdE9xVStRMGxXQnFlY1F5YVdubnJYdHBidmk3YTdUK1gzNmI2NFJaeHREMVFPL1V3S21FdkpZZVkyRTc3V3JpbEd5SXFMSWFVUm1JemtOUyt0SG1MTHNmVFo2OVd4cFN1dXhyNUFsNGFyQVdEcURWcjNMenUwZitwR1EvNHVhVmdZQkVsVjZ5aEY3THdVeVZLQS82MzVZeTZCOVozdmNLc0lISzV4ZFRDWGtncHdoa0tnS0VFRUplRHlkRFFnZ2g1QTF3eGllRWtBaEhTazFLYUVJSUlZUVFRZ2doaEV3azA5WkFDQ0dFRUVJSUlZU1FoN0RJelBIbmk2a2x5U2ZIbHViWElmQUlBWElXUFlmRnBZR3dpMWhTaEZaSVNOY2ZrQ1BZMEVNRGdhUjYvVWZEa3h2RHpqRUdldXhKaC9vd28ybWk1NE9lZzZSNW9mSFF0RHByd2oxcUZEMWlKWEova2NsZ1lPS0F3aFhsR3BuY2V2MEJ2S1AzSm9GOVR5cDJ2OXJVYjZrQ0ZMc0hzR291akp5MHhJYitZZUppdjY3cTN0bUdrT1ZvazRJVmZsUUZtQkI5bGRqcU9jQnVaaDZIb3gwRkg0bmJlOHlwbEJaWmdtVkMwcGpSSk5ySi84YzI5Mmh1aXdUZVlXbXV6RU5TS0VmVzFqTyt4YmVxRHErdHhZMWFJbG9RTS9PUkk0TVFNazU5RUg2dk9lQnVzOVFvbEdlRXZBeEx1VUVVTGMvd1RxN0pBZHRKWkNWbnJrcG01YTBaNXFLRzJwbVduZ3Z0YWtndm9MYWZ2dXdXdUZLOHN3YTlacy9ZMzFPdkxoOUpJN28rR0hta3J3YnF4U1htdmxzSWFWMUtjazhZM240Q3FrWklQWkZxQkhrMDBRMUJZRHlUTFRQbWpHZ2VVWTVzVHZHcjNGYm1VdUVvb01uZHNSU1R6bjU5MUo3enJEdzRqTC9RS29MeTdkSjRsb2daelVjMUMyUjJwUy9pVjUzSFQxbnoxNytmeDlNdjBPU1JwOWtKT1pwRnp5RmwwRy9wTUdodHdOcDFXNmdEaW9UUUl6b1dOU2U1QW0xL3ZjWlRxOCtsVTFEMVR2SDNHdGN6VldyTk1wVVN2alhUVVpiZm0zTkZHMFE5ZVVSYVB0cWlXdHBvbnVnMkRwRG1ib0Y5dko3ZDZ2eGxTWjNIT2UxZ25MZGdkYzBqNWtRMnE0eGpkTXRmZGZhdHkzNzVXK2NFU0NvN0liZkgweXRCR2RPalp4NHB2bm8xbk5zeTZ3WW82QzZEdHZydzl0cnJzRkYvQkxTTC9OaU9VRDI1VjZwRTQwangwMkE2a2J5T3pFTnJMYzJnSS9XdW8rdklzMFo0OGUvRktqM1RlaWdJTWVjaDZiZHBFVUxtRXAzclI2MTFLK21abmVxNHFLVXRwVFJsYlVLVEN5RTNJREpRUnhaUTVKcTh6dUJ6SmxlWUZUMHRKem4rUis2VHRrVGZsdERDZmRKS0NldlFCKzlxU0JzdDBFdXBacUp0WkNXYzlLQlZGTlNhaHFTaCswWjAyZy9GdVVib25lcDZyRUc1MlhmUW5pdHo5K1l5NkZibDlaMW1zb25XQi9Ma1NFbUhqRFJDamdWOVFOUVNGdHAwOVBMQk1tdlcrakRERGxMNzEybU96NEJBL0dDbU8zbUxyUGNJdVRNTCsvR1pRNlJYUDM0dE01WXNaQXJJZXVLTVBZMDZuWWlsNGZhTWJENGg2YzBLMjhtdk9vZjZRZkR0ZlhJNVNsNkE5Z3dUTWdBWERkSlc3a2ltM29YeVFjNjBYWVNuanNJTUZocVpxTFJyaE9WMVNzN0Q2citrRDJUeEVLenJrY2R6cjltc3lJT3liZmc2RExvZElZVkZkVGhGMHhXUGNHdjgxTFMwc28xcTA5R3dWdmplUENkYUNjdTZYdnRUNDBWMFgxdm44ZFQ2eWtWY3ZLRlhoMEhkbzNtVE1DdEVBNXVEUEFaSjZRTTcrSlhYaDlLUzIrUDI0MXBUazczMjdXeC9janlTSGF1bFRIS2Z5OHBST0hwblIzYjRJL0xxR2RCV25JZ3hZdGI5cmJKR29PdjVZMEhHTlVwcDBwVDhFdWhPQ0RtSGtUMnJLNC96NHZoWnV2dVZ0UWhDeUlsRW45aWFrUTY1RGtjdFRVaTZ0aWFCYk5aRVdHbEZSTFM4WGkzd0FoUjdsM0ozS1RaWm04WUZIakNid3B3Vi84Z2R6aEtaa0YyeVlPNEZMVlE3Skw2dXBmTytDMWpWUGFPM3ZaWWVrYnFleFltUVFhTEd4WjVIdUx4d0QrWHNSMFptYUR3em0yMzNHSjFUT0ZXTm9DQW1UNlczZjJ2cXRSRkVDZGFOWnhNbUUzRDBaaktmcy9zdXVxZnhtakUyZXVPQXJJVGpMdUNYWmp6NkdlY0hOL1hJRVNtRXZJQ29hVGRpL25RVHFhOW5aSzY5K1ErazNSWkJ1cGFTMXZ6SmkvQTZEN0ZCRlptUEloR29hMVJrcENaY2JySnMvYlcwam4yZ3VYMWtxUWN2bmxiWlZ0NFRwS0g2NWRRMjcxMUVJYXhVSnF1TXExclN5ek1CN3AxMW01dUxFcmx2TzgrZUV1VS82NEpJWGx0M3pyOFhSMU9nVXVycFl2RndwQnZreTZrMTNwd29oV0V6a3VXTUdKYzFlUVdxRWRFeHRKS3N1STBVN2RManR5MmNwQzcycVRwakhMZEFlQjNSb2I2Mm1UL1dibVN0c1pxb1lwWEE4RDFwamVRUkhiQXo3MGRDRXlvZnYxWE16c01Ta3VmanJZcWpJeXhpejlIeVFsbmRBd2w1STZQajF4dVhrZkhlcTlKRlo2M1cybnEwTEptMVJVY0k2U1M2LzkzNklZWTZMODBNeGlQWHdudWd3WXFIaEhzMVp4aVRVRlphNEtPYVZGU3prdExWOXFDdCtMTUpHbjNiVDVzaGk5UTJxekRyKzk3ZXp2Vng3ODFaYjllUnU0bXVGNno0VWhvNUVIY1VkMStoZlVhbXFrcng2NnpDRUJxUkdOWm90TG8xMVFoeWEwYjFLVzhBRk9HYWc4WmtoZjNWV3c1NUlNMm1kcEdnR3RHbU42VlFoRndaYVNrR0xCTnljOTN6M0VidkVEbHlsWGo3WVN5MWJ6UitUVkd1T2I5T1Ircm5vL3NuMmpXYVJ0UVM4UWhHeDlCZDh2emlsNVg3eitQa0o1V09FSEpkVm9pR29ISWhHYzhzK3g5NU1hMWw0dE5aMnVzNkxCbmpRQTFSRXgzWjhEdXVtYTFTUkxub0NzeXN6THZlOTRsMXpZVTJXWTAxNTdIL1BRWkwxV21oL2t4dVJlU2hJU3Y4aFRyNGE4ZWFaMU9RRnZ5RVRFWHZWSndEeVpZekJkQTdoRi9QUTZyUmNjcHhUUWl4OEpZTjJyYUNGWGNscTJRbElXUVN0TEVTalY0QlB1TUp3TWR6eDFrUE5XUjZhY3p1RUphMk0vSndSYXRadGN6Y1V4L2tFa1h4TTEvNXlpdWFGOUtxWGhvZVhoNnR2eGQrQ1BURk4yMklJSnQyaStFVVFzZ1h2WEtlZ3dobWhwaWJ0YzA3MUd3MHJoQ3lCQTZ0bXpDcXhIKzR3VEx3NlZoVmpENkd4V2E2SUJjYlA3LysvdG11ZVBmcjN4Tkw3RmtXQ0ptTk5pR2UwT2Vzd3lMUVVibTAyTjZEb3BvRk1DblhIN2RBblhNZmhvUm8zOUNvaWJ6cFRINVlZT0h2bWZwTE1LMWppVzZUYVBGTHdqWEowUzJZci9BNXkwWDVEbGJTTm0xclVvamNaM3ZkT3hoSEp2RlpyM0IxbE1IZHhTdEtjcllHLzVOcy9ycjJ5MVNtbVhxM2FLY3lKY1dkNG5nQTY4MTlpY2lDdFdlSXNVRnRHdkZibE9zUFZoTWdlbkswNmFKeENKbEs1Q1ZHSXhqS0ZjVFY0MFhtNXdZMTNjZDdvZ2xWY1pGS3BIQTduR2d6enBtSHlsZGF1YnFhRFRweXZUVWJZa1JEOC9KcWIyUXRFMzAwTWZMSVloMis5Yk8wSDdSbEk3TUNXaFowL1IvTkEvVS9COCtjbnAxd1VqcEhyZys1UkNGa0hHUk5xb1h0ZlpoUTIxNGFTY3VTUzBrSU0xTjJ6REN4VUo0UmNoQ2VrcU81amVTVm1qeTFzcERqOEF5elVZRmU0eTNSeU1Gb0RScWRpV2MzWUtuK3RnOUFlTUxEMjhQOXBGbWNPTVZJbzFlN1FWRFNiRGRVZHVHUk1uM2RWMDVnbkpYM21acTBvNU9BN3I5dHZWSzUyMm0xL3FpNG1ySVhsUnQvSjlFL3ZUZ29qNzJQN3BhSWZQN0t1K3dLMWFUWlJGdWxRbnlLSklYaDlFSnVEVHBvTkowOUlzWTVXUDdRTytOSHEzcmx6Q3JSdTFlVlhROGxJMEtlUXJSUEswc1ZUVGRhd1lqOTFVdnpkVk5GejNKSVM0TXNZV1gxUnBxL0hpTUZTT014WXlyNjJBSzZXVldINzgyamRVOUtub0ZHK0NXbkl6VTVJUy9sUW91QjZLTHJ0dFFMZnpDSWRFM0lEdStaUHNTZDJBRGo5d2plcWNsb2FydDJQU1BML0xVRGs1VXlITUZyWnNmSFEzRzhtSGF4aUR3ajRlMkc5alFPRy9ReWpOcUhDU0hyNlIxM3R4cXZuL21HNXNkWFFNMmQzSnNqZTNCMnl2Qk1vYW5kWGZSeDc1UmlMVVc1Uk1nNFIwcklNNlNndHY4Kzg3NW5tRmdvendpNUNWd1lQWVBTNlNlRjg1N2sweVlpQWpCanNJM3VYcTFxd0ZxWW9IbWduYzU3cUNMeTBNV1ZlS3NSY24vZjI5YjZXWTNQMW0xblBrSHcvZDR4R0Q3WEJSa2xhb1M0UURmem5od2hoRFJvZzRaN1dEdDZIeUU1d2w1N3F0cmM4MFlOQlRVaDMvVGFScTgwZEY0NWpLUExZbklZUit4cGtCTzVxSDc2eXc5U2pCT3hEb0JHVm5JV2xpMjI1Mm1ZU1h5eVFrOFordUNabEtjVUgxMVpJa2NuR1FYK0dCdy9jclUydDFOVUVCR2VRblVzMHBoSEJCZVFqT1d2dVZ1eVlhb01ESk9kYXkrOFpoV054a1hDVzBHRit5aFNnL2UyQXRKSzJrUnNUVFNJdTVZZWtqZVlaMjZ1aTVIZjUwWGdYWktmWThQc2R2M0pDZS94ZWJNSmlkeG50STdqbysrblRCVGlYZFJDMFR2VlF4TWRQYzFIeTBhTVZrUWsrZnJiL1JPdGJNTnFZa0dhUWF3d2hGeVdYdFhueXo4WFBWZ3Q4cUxpVGtzemtnWnFpdWpOdzh2clVMVDVDRlZKUFRXeWRldHRGQ3N2QXFNdEQxczFJelhYU05WN3FzMVBIdVhyTDdZR0s2R0dqM2FTRXJ5Vy9LSnJrdFpmU3MrS3A2VVZrVkJSOTlvUDFWNDhBNlFYWHZMVGVqQzZ0dlR1WVdUZGZ4N28zWGhwbElTbjFkc0xQSGRDU0QvU2JHUkoxRGFNNWk1SjhSSW9Bd0pxdFpUa2xEWURwalJmZHllRVhBeFU5WlB3bEJsVTlidWVha2drb3N1bFNGOGlrMWd4VTBmM1A3MzFJR0l0ck4xN1FlSmFxN2QvcWpCU3V0N2F1Nk1OZGtwYk1jSVZPY3Z2WnZBc1ZwN0c2OWtpdERpZUxXSWZMNnQySzZsdGV1MFJlWk9YRjB2S3RiV29KTEFFbmloVTd5UXduTFV2YzdWYjc2VnhiNm03WFBuNjU4OGVuWlJuSFU1d1Q0cS9GcTRPVHpXQ1BCcDBpb2pxV1lnZkI4dDBvcHBON2IrNkxGSE56WnRoVGJXcEp4d2hWOE5TVHBCd1RyS2UzVFV5ZEFKcTRpNGZMUzJpMEZQWnBJdVp1L3BSZXByWFcxRnI0UjgvNWp4VEJCS250VzhnNFMzM2prci90UzhOSWVUcXZIMjBXZzhxVVlvUkdIYVdZemxRY0tFUFFWbnU5OENTaGlld0tjcU1Cai96M2k1UXIrMHUzZU5XVi8wM1JmRTlBZTM1OWlMNGo2WnZ1WkhUbU5uY2hCeUdaeDJOZEd4Mi9HOHVWeFV6ZFo4MkhlNFFYWWFyMjdVb0lvak5yTzI2U0Y0VVlCcmV2cHczbnJrclJzaGNXcW4xeERIV1N1VjMyS0VKSVZPSVBpbEpuZ3M2ZVpBRG1kRUlKWGp0eGZmU1FqU3Uzc2RFSXdJcitoZ3AxN2lyMFZza1d1OFpTSE1kM25yZmpiZ3lEbHE0QTAxSXRDQVJRdTdFcU9iU1BVZWN4ZE9OWllRY3pGRTdkSVRjZ1JtUFJpRjdxZVFtbkt4bi9QcWQrOC9KVnY5OG5hUjFJYzBuSzlkVXpzZ3FMdFRuckVXVWRYSlFTdkdGMmhTOEo0QzB3bm4rUWxqRXZpZEUyL2xUbEx3VWJmQVU0NXBzYWNjdE1xZzB3M3VSazBieFpLUzJHSjNidkdjdGVkRzh2UE9iUExPZms4L21VOVplcC9EYzY3eTFZMTFTd3NxSDVpV0J4cGtzS0xMbHB1UlY1TEorVHNqZHF6WmJmOHU5UU8wa0VhOWovTUFKQ3VjdUxEMXNsaEVjblFzU0VPNnRPS0lHcWJMdmp5c1hQNnRJRTZDam41Q2xvQXZCNEFMUVdoNUVaOEplWFpaanFpS3FUbHV5c3lRc1BVOG9zb0dtZzJyWG1zWmZnTGhhcmtWY0xTS2wrYVFpNjlOdEtIRG1idkxxa1FyYXVpbDZmNUc4dGJXWmwzWTBiMnVkaUNxV0djeHJSRFBxZFIvSjYwTUJ3eDFQeEJKeHBwamxFb1dRdVhoUzE3TkM5dWFKekh5OXVyZDBENzNiQ1Y0WlJtYmpVYk1PSWFTVDNtMklJb1M5bmtwSEVIb1ZTbFRvczE5Y2hONlpkcWIxcjkwQm55VThORzFIeTF1S201bzBMRG8xd3ZZemxsNjBqSlROYTljbXo0emVMMnFMc05MdzB1eDF4L1BTUzMyOExXSkZUdVg3bitwYXlqc0w4VkpWSnFHaVN1dlhwcG5rTkoxb2VoblNrYTFCeUFtc1d1d2lVeHZaTUdOSFEwcHpscVlVelNPcVJyU3lQNk5iSVpMcWR2eDBTa2lNbnMxWmI0a3kyTjhsVTBwUDNEcitqTjFlb2tCNWR4b3o1dWNWZVVsN0dsYmMyM1laejFZWWVUVENjdGZ5UmphT0ZuU09YN2txYWFmcGg1QjNZU2xNQncrV3h5azlrbjBib0tjZUtOZGVERG9oczVQY0JrOTBaQ0hNL09hVmNua3BZdVd5WHU3QTd3ZnJzenVhVnVhUGIzT1RBYVJLallxdmtZVWpSZVhwdEhzZTZCampXQ1NYQk4xNXVFRUhiclZKVFZ4YjEwU0JjdzhCd2VmRUszZXFubG4reW1oMXpVRzk1VDMxTVd2MGNRNGw1SDVjWWZhMWRQWlphK3VJZk9MNmdKQ0x3N1hvZTZEQmxaak1iT2labW9RWFQzdDdmdlIrTHZSRWNudGJYcEh5KzRUNkdXTHE4RHlSYnUxMVcrOWhZa0xJZmVENGRabHRpNGhvR2Q1aktsT2JiN1F3TFl0ZTBpTmtLUmV3YTJqMjJDT0xwYjFJUnd4bzd6aWRPellCeDliOStmWDVVYXAvZjA2K3lvMzdnVVRmOEQzeTFXN3lUbkl3eklTKzJKTmxPM1NpUTJrSUxiUElVVW1kQlJ1ZGtDaENYZ0p5Q29SbjZXQm4rUXRxTUpFRVUrMEhaSUVZdGJ6bTZEMkFKSWFXeTVWVTV1aWRJcnNyT2VpUFRBYWFQMnJaUXljZXRDd1M2UGs5WHNjSGQ3S1FvalVuQldlMWJCLy8zT1QwOTcrUFgvMEZxTzFoTnVqYmgzSEtkMTUxM3BqNEpnRWtjVlhTV25HVndiell3REo1OCtlYjcwTzZQOWVWV3gxMU8vcjNodHRObW9tUW15Qk5xVzNITHJFa1BsRTNLbXhPNGhlSVY0eVZiRndqUzVTV0VjM21WaUMyQ0ZEbEl1ZUJhdEVaRE5lR0diRnhTM3B6LzFNSldqaDBmWlNFY09nQ1hZcUx1SStHN1FsdnhZMnU4SHZYYWoxNGVhemdpRHpHUUtabHo3SlFYeU5MRjYvVnZiSndXaUJrRGpNc2hGcDZpRHVhZHFRTWtpNFNrVytyMWhGbmw0R1FWMk1KTkE2NDk5RGFwWHJhL3ZxcS9Rdm9tVFhSQm85b0hHMmNhTHhvK3RZdW5HYUpRZS9uSHpBY1FBbW0wVzZnZk5oY0syRjIvbDdmUUcwUlAzNS9hM3ErTFdKdng1SkxZTFc2enp5QjVUNWgwZXlQN2ZiQXN1eXVabGEybDlzZlcwcXpUWS9jOVovOUJDTnJkTzFDRllLUVRsQVRzRFNncVl1Rk9ISkhvMDJqcDZsNmR6U21kSXZlR3lia2FCQzdCcnBFQ1E2aUhQRDdSOGdtUXMvK0VZZXJRODl5bHd6UjA0K2phYVAwUEdHd2V5NHJqWlhoY3ZRK1NvTHFzcTIvVlptZXU1WlhCNzkrSHNxUlU0c2JId2g1S0NPNzRtUTVvL0tSVGZjU3BEY3pVblhORmNSOFRsWWtFTU5XRzI0T1Y5U2dGblh3WmJmNXRrSDVydnRGYkZPOS9pU0lOVGZPcERqWG5qc3hRU1dJTkR0TjNWUWg1RWlPVXJkT2tFdnRtRWJuUnRyN0NWa0R4OVNkb0VaekIyYXNma3Z3ZWlSdFFzaDdzZGJMNlB0SFYxcXlVTDRSY2xHb3dqNEgycndmUkFIZExQZmVjRWVsYmZIUmJsb0xKUVhXVEVaYmJhUkh6bHhEV3lBOVJ0T3J2M1h4bVJ2SGs0Zng3eGRYTi9mSUlVTElmV2luTlk3Zk1DTmFpdmZTRi9xczMyMTQzQTBSOG9WMDJra3lyZzI4OTErUEdEcWNHc2lkV0dtQzR1ci9obHprZFlWZjJ5WDl6NmxjUDI0bmRhN29xOXcwNXBLenVWZ2ZYUDVncXFWUWpqNDFpeDdNV09Ub0V0RWllbWxSNU53WW95K1pHaFUxclg3YTQwMDZpWW9LNU4zamNSbnByYTdyRzBmUGRrdGdlSzhNSTVZdHNNeWxEdHZHYlhBckd6MTJ5NXNjckRLaC9rbnd0K0lVSTQ5SUx5c0ptZ1RERTVGMmYvcDl0MTlPblhOaWI1MVgyVnlsalN0bjJjTkIrMVJVYUNMaE5iRVZTZU5GZkIvd0xZaXI3eEdkMC9aa2FFR0V0SEVRMkJUa2txQXFqak05YTRmSVdkZGFGaTNSTWRNdVRVYlhybldhandGUjNXcC9xNEZiMERRcERLZlJPMFlRT3crNkZQVzBaRXdYam83WXRqT2gwa1dhNUtPMWlIYmttUjErWmxybzJoazFQQ0tXQWsvd2FQVEdhK08zYVdqdTF3QzU2d0s2allJdVNTaldDVm1QSjQwMWVtWVFiWVpFOVFndnoxWm5yL09NTW5KL1NEaEN5QURlQUVYOVc2NnR5cEdaYUZ0WTVPYk0ydFJBTEJzSVBiYUlTRmpwWVlyV3lHYng3NisvLzZURHlNMlBJaGlCdjRPZ210Vk1XNFJsajdpQ0xjSktZK3Z1M1cwa3Q4KysxNmVuL0x2c3cyaHhoeWhHR3MwTnFyYU0zRnduWDJjZlZTTTRwUkFDNG9sakRpYVlYZzBIalY5ckdaSjdUNTQ5MkRQZjlwbU1qUU1LK3gyNU1scUh0OEo0Zzk3eDlvYVFaSWNkMXYrYy9EaEVLNkpHYjArSWttNUc5elMwdEx4NWVSYlJydlI0b2tKUWk5KzZsZVF2bmlWVGhPVWY0RURMRHlHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJdVRPL2t2aUZwSjkvZjVPdjlLbzZjaUlESVRPeCt0ekpRNk10aW5TS3djaXBDQ2JaS05Eb20veEkyR0lYUlN0U0d5ZFNaTzh3QVhJanRBTXBwZXRVaFNVNGxxeDBqai9wUFIzU3k3WnQzam1nNTdKSnVYdEhTS0dsN1R4Nnlnd0xDdkxjeEMxR0M2Z1RraWVScFRyVThHWTlUK3ByOFNYUWMwcTlQTnQ2YWlhNElzUnhUN1hSNnI2WUpaVktXTVR5OWdqRWJlcTV1ZDcybkp6bWZhR1ZkS0VkamVVSlptdElhVjFucHI3NEFqSWkyc3VQZVA0dFV1cXZySlpBZmM2Ykt3bFpqS1IrZ0ZOK3BKOXZwdGt5cGtWWTZYL2lXa3NUVHd2UnJwSDh0U25nVW5ocTh3ejEyTk8zeURUUTFVQ0w1MStIK2NrcmY3a1hKNXlYUjI3aUkyc1ZiVzJDaGtNNnNLZXJSMWZibGpCRjF3WG9Xck00WmZBb0UvTFdyaU41anFKWmU5dFpRWkxXMTlIZUlwYVMxUHh1NTBBdmpUYSs1bStWUVp0dkNTSGp4T1pwMmQrYjJTeFRBeXI1dmZoU3ZwWTdvcnVqV0RKVENxdkpWaTlOUW9oQTczYURwYWprZENXMWpVVHcybFVUL216dmc0aHE4NzFhQWhMR0V4NW9PcCs0RWMzQ3M3S2dncXRHV3FGbEpaemtGOUE4MmswTTZmcFBVa1ZPT2h2cDFnRTM0VVpYaEhiZGFMWW9PZTRhZTRUZkF2cys5bmV2dHZiVGRwUHp4bFZLVVNxUGFBc3YrM0IvL2piTnZrdlA4YmVvOTg4a20zL3JzTnVDRi9LMFJwTmx6ZkhVaUt6NEUvSmFVT09nTnoyOWhJaWNydU9ndG9qYUg5RXV2RHlpemVOcFFGSmUwcldVYUc0S2wxSEJMYVJGeUcyd0JsTlMzSUpMRjA4WENpVFZqWlp1U0ZZOEhhK2QyM0F2bjI5WE1zc1NvYmxKY1h1SjdBTy90b3RFOUFncmZvMDAvbnBNRVFPTnd5K21Fa0lJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFpRi95eVZmdFc4b2xuZlpPc25ja2dmVktOeUV6c0U1d3FQdmhDWDFST3RuZEMzc0kzdHZ5M3B2K0UrdlFhNVpJczFITVBKQWN1R1lINkVjNzdzVEJrMXVSa3pZL2J1ZVJEYmNTdk80QlBUTW5jclJiNVNlZVhxc2NJUnFXOWRZNVZFVnhsL3g3TWk4ZGZvUEtxeWlIY2pLUFhDMU5Ic1ZMOU9OcW5kSXJwNkhWZEJ2T3YxL3JYTjZpcGx5QUhNa2tJaFhhbzBoNW5Za051MFVaVXRMcHpKc2xTblZTTkhweU0xcjFiQ0p5R1hyVXJDYWNORDQwTFFNOWVUMDZOclNsU0VuOXB3ZjJqTk5iam1sVVRXN1ZTcXVDS09RT0IyMUdhNFh5RXlhTE9tVUpXb2V5NGw4Q0hlT25MR2plNExwQjlFUFhmVjdlbWorU1Z1dm4zYmRHY2VKbzY4TDZHcHdFb0RKa3cxMExGMEVxSzFyZTNqeVBBMTF4UnVhNE5tMnY5YlY0Q1A0Nm1CRFNnemNMSVl6T2ZGNlplckZrR0xyV1JzSkhMYVZJbW9TUUNrK045Tnl2cjZhUkNHV0NueWJrMlZjYUlyTmhKTXhJK0JwcnR3cFpQOWZoSStFczI0SVZCd2szZ3drZHZQNThwYlNwMFg0cDlUdnJyUGdqQWh5MXNMWnBZcXRSeVliMDh6VlNpWDNaZm5LUTgvelo3MjN6OFpEc0c2WHh5V0thSmRDdXJVWEZzblZ2cnB0bUZRcXg4ZS81Y3VyM2wxS2JxdjNPb3UyQzdRK2hTN1hsaDh1aUpFMElVZEFHQ3dlUFNFVHphZVd4NUYrbmFZaEV0d3lhSFNQYXZFZ1pwRFRON2pLNjNyTlVQZlpUY2hjaXdxTW8xMHAvOTRiQlAwcXlGdWdxeUpOdlZycTMxdFhRQ2tMVGtZaFdMaGxHYTFadlgwRUtOOXBNWjFnaWJvUDJTRUd2eVVpS3J5MnV0VFFYd0MrbUVrSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUWlQemYvL3JmNy9kaHR5L2pibC9ML2ZWZkYzcy9HWG56bDVBVlNJZkd0V2p1aTRvZ3VYc3NHekxJRy8yUnpLVlRBZ1lLM1h1NEFIazRQWDJNODQ2TUpoT1JjR0RTMmJsRzA2a1pUWE11VnpoYkNaU1dteStsTnRIcVkwQkxaRkMxWlVBa3RIZU9EM29PRDVKbmRDS0s5aWJuZnFVNjNoVzdOR0czWllqVXJGeStkU1BqQW1vV21haDNtVXlhRzE2RE1rSHRUbDV1MnE5TXJGTTJEN2tWMGNsT21hNGhEVVk3a0Y4cFN1OVlHdEdtdEhDdkhkYzlOODcxMytHQUt4STMvQXoySWtYLzZrWGFoQ25PdFpSNmRPMWk1Um1KMjV0bkc2WU4xMnRrR1RFZTF1NFNJNzFMYTBjVWJZSjZOOUVlT1h1OGM0MUp5RFdZcFRkYnJOSWplblQxTmk1cUdXMzlQMkY2Wmx2UG5SRGlFQjI0NUo2TWJCOVp5eVJDUW5nYktxTnIwOGlhdWplUENWaDcwWnM4aHhKTk16U3JmY21La1ZJV1NsQTIvblVhN1JkU2ZSM1A3eXVhdUxMQ1NVUjcwbEdpOGM5SGVKT1J1UkZ2RThWN1lDVlNwaVFYaDFNRUlRcW9YdVV0ZUQxZGpueXpja2ZEMDJ5c2NMMVlxanFjUUVwNkJiRC9rTGV3U0xuckVjK3pkVmhPRVJYb05yY0haZVIwMFBsM1psNWVub2lPZ0s2OFg5dFZSaFFyTFV3azNDVDR4VlJDeUZ5b1FCQkNDTmx4NU9UQWlZZ1FRZ2doaEJCeVJkNjZWdUVhalJCQ0NDR0VFRUlJSVJONGpZbUJ0aFJDQ0NHRUVFSlFxRDBUUXNqNS9Lb3Z0aS9GWnVIWGhmQk91eUZrTnNWd2E5OHVuOXdmMjFNQ3NwQlZPeVM4VTR1V0RKbmlYR3RFeG5OOXc4anhDVTVXV3ZJcG5qUjVDdWdSNWV3VU1xalMwRkdQa2RQWHJIR0xuTHgyYnZNZXFYbWhSN2twTlNKTlByVmpxZUtxUjRwNjlFam1qejk2UDBnUHlFNWVvemlEd2pwMUtoZEgveWlSbkw3REZDQ3RXS3A2UE9ta1lDMGxpdC9GWk9NNnF0dFp3MWNhbnB4amRaUjJ5VjQ0SjBta3F0a2M1SmI0eDhSdnJ4Vi9SQ05xVlJvdHkxNjgrUm9OU3lxMFJyRnNESjdhN1BXMVpLUk5STHhtY29idnBETGtyNytmdENOV3RkYUFoYTVCSW1zWHI2TzI4U0tyNURvOWRIMVVBRGV0cGJ4Qk5ST3RqaEVKcmhtRHJUaGVtajFFOHJ3ZWZXdlJiWmcyTGMrTTE3cHJhWTZXalJBeXpzaU1ZSjJ5YlZrS1IyZWZiT1NwNGRtOVBIWFNpcVBGMDlLMk5BZ3RMVUllaFNVOGFsQWxCVldmeVQzd0JEWVM5amZzQTVPNGtsYnV6Ynd6MDI1dERCcmVySTZHdC9LVXJnWHkxM2N5a1AzZ2VnKzVBQU5wbCtWSS9YdjJtaGk2bnBZMzE5dGZwWW1UbSt0dE94VWhkYlJVV2c5QzE4cmVWMXM5dmJydE9SbkpGT1RUamVvdTlPZExxY1h2aHA5d0xkN1crM2VlVXBwSU9rSjR4RHBGeUd1UnBxTzRLTVRjYjBwMENhT2xVVmV0bGhacWw1V3VKVm1YaFRKNDlDN1p1aGpaMHFBd0oxY2wra3lGdDB6STI4dWVjZXk1MTJsSFpWd0IvVnZkOXBXMDdheGRwOHBkZ3ZKdkdyUDNOS3kwVzZKakI3QVl3Q3JjNDRrMlpGVGZPTGlDK2NWVVFoN002d1EybFJoQzdnZkhMVm5HeXpvWHh4SWhwQU9LRGtJSU1hQ1FKSStDSFpvUVFzaTdPV01tNU94TENDR0VFRUxJUGFEdVRzZ040Y0I5Tkd4ZVFnZ2hoSkI3OGF0K2RUWUw2bHhKUCtkZFhZcFZ4OW9Tb3VFZHNTT2R5clFvYTgzZE9sbklPNlVJTGNmUWJhSEg0eUVuckhqSE1nRkpTMFdqQ0hrcFdzT3pJNHlqSFg4U2tKbm9LV3UxdTNXcXAzVm8zamt5NE16elg3d2E2RHdEcWoyS2RPT1hGdVJwdFRnU0xqbGxHc0U3VnF3TnAvaUx0ekwzMU42ZmszYUxrWEwrL3JlWUU3TWNiMFRRYXFLQ2MvZGlSbzd4dGRMVDVvUVplVHdaY01xUVRvVFdrdEt1ditNNy9vUmNHbTh4RFo0bVZ3SURvRTE2Vk85RXRCbHZ2YXVGSjE5WVJ6YWlSejMzNWtkVXZGTzEyM0FXdjIzZXBhUGlQM0hHbXIxM2hrWFdFV2hjTCsrZU1rYldWbEtaWnh0aUxNdUFONUF6VURiTGNOR3pkZzJ1c1lmeXZCN1c2YmpSNVlMWHVrZ2FkUndySHNVM0lXdnBtK1A3VFJHMXU1VStFczdLMDlOcHZIQzkrZGFnTXovbEhIa0VNd3haR2ZUM0Z2emtXcUNUUmgxK2RSNmtnMWtWM0NNc3RQV3RGUjRKSjFFNjNiMDh2WTVkZ0xEZ3VyWVVQSHhyZkZVM05jbzJLYzEwTW1VeVFNblZ2eisycFBiNXk5b3U5ZGRPWmRrZVNuT3Q1WndWOTVaUy9jcTdzSnIrV0pKVXhibEpjWnVEVkNLd3gyenkzc1RMY2pwdEY3RzZqTWQzMTJyeVVndG5nS2dSYlN0SDRoUHlHaUpUVmsvOGh6Smo1cHUxbzRINGEvTkdBY0tsaE8yaXRHR3R1YzhNa01CQ0VISW12ZjIzeHpDcnhOWDFTRG02cHhQMWpHY3QvT3RCbGtuV3RxNmx4RXJoeVJTaXE5c2pWOE10M25oRjR0Nis2NnpXSTBZMjJROW9CSDR4bFpBSHdqbWRFSEk3RGhSY2xKR0V6Q0Z6TkJGQ0NDR0VFRUpjemxnM2NLMUNDQ0hrZlBqUUV5R0VFRUlJR1lQMmpTZkNWaVdFRUVJSUlZUVE4alR5Ly96cmYvL3NpN1duYzdYOGYvOTFzV1Z4NUxnVFFsWVNPVDFDOHZmU0FMT092c2l1WFV0RVgrRGZaV29sN01YcnpEeDZ5a0pxc3JUOHlZTkJHcHp6elJ5UW85c25KbTI1MTFralllK05KLzI5bWxDa3FuVGNxSGFhclhyVUtESXp0Wk9DZDQ2clIwL0xXMGZLU0RNemVsU1VscGZqYjlheGZaWmgrOVdvUHAwQXZlK1k4dDR6QmltZUI5RVVTMFJlZTkxOWdtNjNpZCttK1VhVXVqZkhiMDdtNmRBait2TjNIb2xOUTI0R3FFYUlJcklaTE43cDY3UDF6UkZUUTBUYmVqMklpam9iTmdKRW43N1k5K1ZVSkUrOTJXWVpCNjB2YVVUenROSWNDZGVUUm1TZGxKMXd2VnBNNzFvdEdnZEpweWZQK3pIVEhvdXVOSkdWNnVpSUlvVE1CUm5mbWxYS0N4ZGx4a3dZbllXOGVKKzRQVE4rbjdXdUwyOUNEZ00xYmljZ25CV1AzSStvd0lvdVhaSVNIb2xERHVSSXcwNDA3NUd5elhwS0tMS3BZMmxjUUZueTEvY3ppcmVqbjcvMk84cyt2UFlKelIzNGdQNmJVMlFnbHk5ZnV5NUxZSjJmbmZEdDEwb3psSWVkbGhkZnoxTytUbzA3V0JpeCs3dmIzWVBoMjdqRmFQN2RDQ215UDZjQ1FpYUNQSytBRExvaEFmVk9QUFVaMVZ4bWFSdFdtbDdlSTNuTm1lUUl1VGpvVXNVanNDendaSU9XeklpTkZCM083dkxpS1l4c21MVnBrTXR5eGhvbGFwNTlOTkV4Rk4zWVhpQ2ZaOEF2cGhKQ0NDR0VrRVdjdVpRNEkrOFQ4c3hYV0s3UjJrQUlJWVFRTWhXcVY4dklyRnhDQ0NIa2xWQURJSVFRUWdpNU1WVG15R0xZeFFpNUlSeTRoQkJDdnVDVVFBZ2g1NVAvKzEvLzcvdGQyTCtueGd1QjBvbGZUUFhlN1BXTzRTSmtOdWd4NmxMNEE0bWVTdVM1VCtXVVRPVWlVSFM4SE84MGlCbEhnQkVaNURpeUlrZnhWQUlFVFh6ZnF6a2paN3FWb0hzS3hxL0s4QjBVMUIzTDdrZVQxNG96K3RGWmNHU2c5OGIxanNOUmdJSmhSNTJWb1RwZkt4d3BjaTlDOUdqa0NLUEQrUzN6c3lhK3RPRE5ZZUtSRTZON3FqYmFqSVNjVHRFdlVkMnpQWkY5NUlSMkx6L0VGSkVTeDJHWVNNTnpQWGdhOWpJOTlrWFUzT2kvKzJiRmpxb3NteGhlR2NBRnNCay9KWDg5T0dOOTFCdHVKQTFOdVd2cGtZcEpTYnRYMjBsTyt0RjQ3OEZyM1RaY2pUYUMvdDFjbzJWSVFCNVdPQzh0UXNnNGlNVndkQTNhTTU2anN5OHErN1I0U0o3UlE3amJQR2JVQXlHbjQzME93QnRFNUgxRWx5aXRPK25nYVpyMGlrME43NEVqejdhQVhyZk1FSXJJbnZKdmIrSExxYjJLMG9UeDJOcHpwSVBOU3ZXdkxocXlFS2NOdVcwLzNKN1ZzNHF1N1YrMVcyeGRQTm9iUnRMdzdPeGRkbmpsQnIvYnRTanV5YjRtaEN3ZytpeWZGZThCZUJvQUVqK2xPWE5DTk0rWmpNcmhLY3RBQ245eVIwWUhzREY0RUZsU0p6RmpDRGtyRGpWdk5MMVhZbTI1YXU3a0ZIb3NLNlByUE1TYU1UdlB4eE0xMTNpMjd4NG1DbVorTVpVUVFnZ2g1M09DeGtrbGx6eUtVem8wUnhFaGQrVVNIMXNtaEJCQ1hnc240bWZEOWwwTmE1Z1FRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnaTVCcjkrM2tXV3ZwYXF1WjhJZUxnYUlhZHlnLzVZZ3U1ZGlVYmY1RjlBNUdRRzhrSitwc0E0N0V4ajFFZWh0SFhwMU8zSUFSMGwrU2MwWFI5TjJIb2RHcW14NHNSQnp2My9YS0xIbHM2WUhLSXRpczZDWi9TVVludGw0N296cDd4emljUkczV01wVHJ4TmNpUXpoc3pvY09iOC9NMXZNWnVyMDV4TDVRN0ZULzJ3R2NqdGFCYU1yYXJhemtzU0JWU0ZWc0t4dHdCVzZtVW9VSmhZZzdYaFpkdTRuY0p2dGl1eDRxdzVSNVVYckNiV2NJU3kxMU0vM3Rva2cybGZmY0MvWTJYazNXVnZLMFpzdzJoUDRCUkJ5SFVZSFk4OThWZlBJcVVqeitnc3k2MTI4am9pZzhqNk1oT04xYytpVi9oNVFwVVlQRzNHV2FHSlJHYjE3UGhiMTcwcnBVaWVnWDNnZWxORGk3Sm9yTzF0Uk1VSmI2ZVR6YnFONVRXTHZrZGp6cC84UER0N2x4MWU2cTVHdHk1WnVWYVMwNUxpVkVGSUI5TDBnenowOVZEZGZkUVdNYXAxSU9HOStDdGtKTkxjZFI0amo0c1NjbXRtclg5YnQzek9Lbzk3T1F1UUtpc3kvNUxENkcyS21hOU05T3k1Y3Y1dEdOM2thZjFRWldnUnYvNytzWXhHSjNlQkRQcFQySkVyYzBJLzFiS011aCtLVkloRnlreDJyaWxTWGdRNnhiR1R6Q2NvZUNMQnBaY0hMcUxaVE1hVFpyM3VXamlnOW45dkdFWjJnTDZUamd3eWJYSllPWnQ1ZVNZbDd4bkNvNnJUa3V5M1pUYlJtcGVBcDFSUHRPNjFVeXJhVGRlMHUwWnZrMXdZcFB1alhZcno4QlpuUUh5TGpDSy9uRG94cTEwWXFramsxbFFEWlRjUEJWV2NPc2xQR3BKN1V2eG5NREwxdHpKajBkTDhmbWpxdDYzcTdPT3dNcnZCMUl1OGVhZ3ZON0ZXUFBDWG5UTDBqOGdSYWRIVFFhWDRrYng3MXd1UlBFYng2bUhHd21uSzRxdmlXU3NqNzdIa25yc2M3ZDF0R2JRNGtkNU5DSmxEenhoRHJYV29GVXRMSjBLdkZYWlVwNitKeXNpUjlRQmxJN2tWVWdkL2h0cEZMTkFsQ2hxUGZlWWtWbW5wdlJxSVpBZElTbG96akVvekRGVUlrUTdmTzdqcWZWQkQ4Nml6em1pZTU5c2lQcmFwMHJYcS9QR3QyZXVzZmg2cnhkVHVmT283SWZVdDV6N1FLZUZaVmgxQ0p0QTdYWWx6Z0JDR2RERnJYOUNiWmMrUWtWSWVHeldpUjRVajVNNmcyMlNhbnpHd1Bka1JYVVZFbUxVVCt6cXNpcE9Xbkp4cmw5SzcwNzVmSDhyaHBUQ2pSRlc3VjZ5THZJYjhNSHM4YVpWcktWd1RHK05YSW9URWFKOU9SYmpRUkZ5QzdvZGtidmt2S2hoMUl3SkJSZm9XV0RZZ3kzWjBmeUozcEpuMjBMUWlBNkhFeHM2VVkweVBJTHBVbWxuR3FrNURIYmtwZzFQWFdJbEhOUWs1bkxVV2k2cGRaQ0hSUmhoOTVrTktpNForaVBvRnVsa1BBQ0EyYVk1VDhpUTJlbVQrK1JzZFU5N01HWGxBL1VoVFJIR3VId21pYjgxNGpvM0NjaW15R2xHV3FCQXg3WHBsdzQ5S2hWRWRmMFllSzVXODJYWGZhaityMW9QYUN1bTVkQzE3T3ptaWR4TkM1akJ6dlBhbWM0UWVNZVBocTlFeTlJU2xiQ1NYWTViUW9BM3krUnhoWENFSHNHb21tdkVvYytTeFVNdmRDck9xZzNwUEgwL1lGU2hKeitQUGlac0pLNXFjV0tmN1BFcDNIOUkzMmN2dVZ4N0tVODZwVlAvR2FXM25SNjd6WnpCckcxUWJRVlF2Q1BsaTVuUkdYVzBhWjJnWm1uYmhFZDF0TU9Yd1VUZE95Sk9wQmxkMGZIcnhJbkQ0RHFLOWRGejcxK0dvM0M1aGxqVkRzMUljc2RmaDNjTXJ1azcwVWZOVmVSOWMyYi9hUEM5dmQ4K2dQMmNZc3BKWlJ3UmRBT1NrQXZqMm9rY3lIRkJuT2RsRlFlTlNwTHdZYjlPRG5XTStUdDE2aHpJbEkzcjBZTE5yTm0rdlpvWm90YVArVlkxbEo2eDNaS3JvM3p2aGVtYU4wUUVkV1RFTTVKV2QrdzhtZmJWRkh2SnlxaFdPUElUUmpzbjUrUnZ0QmJyYzFOR01SMng2MGlIa2tnampvbFZwUHROeGFmekxRZXRieVlhSUduWTVUZ0d5YyswOWJYVFBCY1l0OEpibUh0aHFLSCtGbmRkUSt5K24rakhTVnlscy8rU0VXOEVNYVJJZFZNa0lqMW9BMFBKNkFrQXJpOVc3UnRidnM5SzZGMUV6bkdaMjl0SXZUaGlLYTBMZXhRd0pPMXQyOU5qQXZUSlFOU1dQWW1SQmJBMGlKQzF5YjBhTks5RjRST0R1bGFkMW9wSDBVanBHa3hoWnUycVB0YmJCc3VybEo1M3RwWFozVmV0YTBGNS95cnNZOWF1YXVXbXYvUm8xYmx2NmF6dmF1a2hYbnRteFRnL1ArNGN5WUl1d2JPUlpDR3ZaMHR1MHRMUmJ1MzNFUHArcnJwYVFzalRYYmRUZUVVVEk2MEVOZTExenlqTkExL216dFlpWlZSNXAxdEc4SXphUjdrd0l1U0xSd1dPbGMwU2NRTElqVDRtaStqT3AwR3htbitzc2hDT24wUHVrY2tucm1zOGF0K3d5RlpGSEM0cmozc2ExeHUwQi9FTHlMRWVYaXBBNzhCbkFEeDhhYng3NTNFZDZPZHI0amxpWHllWHhIbWg4RmtkMFdzRFNnWTZob2czQ1dkYVVtL01TUFlTY2pMOVFuSlBIelBBVUR4dFdTRXhXTVhrMFg0UG1lNXB0RGU5NUcrN2JmWUFqcG5PTzJ4T2h2bllDMTZydzg4YmZpbm80c2tQZllmQ3NYSnZPZnRENW5zeGM5a2JNZVp3M0NiazJaOHdRVjVpVkVKbFlISGVxcGVUVmFJT0lkdmIzZ1NwN1ZBb1hjdmZLdmNPbUJyd1oyMXhyRDBka0lPNGtEcGJMMGRZWmYzZHFiMHZvN1NHb3UvWnMrZDU5d0JZUjZRNjlsUjVOSjVJSEllUWFVQy9mY2FZV0VRMlB2a2VSS3ZkYmlPUDJScnhyUXA1TSs2eEVSNytQckZRNHJFN21BaSs1a1I5bVd5SStZV1kycC9XME56a0o2Um0zaGZ6Ni9QaCs0TzV1aTI4YUM4aVpYR1RsWkprR3ZUV1FWc3lwRTRGWEY5N0NUWXN6b1k2UnJNZ0xpUndQd2s2RUVSRlV4VTdDaWk1dHRCUWhqWlRlMW1UWnVVWk1ncEc4U3ZLRitwZjc3cGhUcTBYYlBLd3kxQlRRUDNwdVR3bWtnYnBiWldqY3NuSWZ1Nk5rNWVoSnlia3RYMzFDYm52S2JvSHZFL0h2bTl3cGhoY2h6WVdvSW9td1dsOW14L2dtVno5K2l3WDAxR2h2dWlia3NlVE5ueitVU2libVdvVXAxVHphcWpScG4wN05DcjBVSGFlV09GOHRubTlQejF6SUNsMkNyTU5tS0U1TCt6VUw5T3NXZG02Zi9MdzAycncwN2R6VzJ0dFViWGYweVluSUdrM0xLeWxwSXU0bFllc2pOQy9VR0lFTTlIWVhaM1Q5bDR3ODNrM1VtaEh0b2NnY3VORUp3TFFJSWZPUXhuMTB2UFdvY0FtTWcxcENwWGhSMERpOU00ZzNLeFhudW9ZeWtTekhHcFFwNkVlMTYxbFlBaXF5cmVTNWt3bk0xS1R2YU5IeTF1Z2ZONlJEUi9kRk5VcFM4OWg4NWxLb2ErK3psdWFlWlhPZldYR0gwZGI3Q0QvdFVTQmJSRkg4UDZHeVVyNjlkWGovNVZTNUhUVzdsVzdQa3R6emQyc1hJUTBkMlo2eGMxVzZ3eVpzOXYyMU5PcHdMZEpIZXpmM1dZUzR3cDZBNEEyN0UwSkFQREdMaUc5UEhMOWtvQjVobit4ZDkzdFBDSDMrV2xiMkJPYWRrVXlURnhuTWpKQXJnVzVSSlNXY2xsNDJ3dVZZa20zU3lTbVNKaE9zMVpLV0IzVzJMN1FsS0JLbmpsY1NLL1ZBVnMzeE01dlRHN2VQQnpIbnRIZ04ycVBiUmgrTjBNSU44R3VUcG1YNHVRc1VlT1NGZkVicmpLNS9pU0hFY1V5dWhEZWgwd0NCTVZOUU9WblUxNUo3TXR6Wm5DY0FWem9uaGplQWlBcU8yNE5ZTFNTTDRUNUxxU1c3UVRXeXltZVZrdGRSajUydmgyU3laSGpYcmhjVmFYVTZIT3ZrS1Z6QnNvMlU0UjVqN2t4RG5aZjNpbkpGNzFlelJwQXJZejI4cExXbXRZUWhoSkFqUUczZlVkdWE1NTZTdi95aExDU0VYSmJWQXVxQS9jL25jc1NHd3hITXNyaVh6akMxTy9wQWc2Y3A5R2dTSURjWkwrdnRPWHN0YnIyNCtyeHMrM25CTlcxS012VjVNK1JtRnQzd0h6dCtpa014VGdpNU0wZG9RcWkyY1FsNTJsTWhOR3lRcDNEeUlGeWw3bE5YbTBDdlFWY3lSTk1PY2hpOVZnQTBUVGJqQkRnZXZ2bjF1emJ5bnlmczlwNC9Sb2tMSXgzRjRoMlRRTWdEa1lhQzVLNzVGOEZQeWdNYVN0NWI5bHJtMXJFSkxkRXhMZDJvNEQyYURTSEVJSVArQmZNT0hNWmt2cHhhVTV3OG4wTmtBMUtMbHgxL2hlelZ1aEt1SktVTTBnem1IZS9pTGRrc3Y5R3p2ZHF5aktEazVYMHB0WEczV21UdjExdW55UDBXT0tURS9jZXI5Z2kwZDBjejdseVJrdEhHOEFTMUo0Z1JBOVp6QmZNNnNuejUzVXl0dUMyaDVIN2lLV0haVk9TV0NQS29mU2wxMW1OaDBTTE5TSXNNMERhb1pkZVFyaVZ1YlpBNGIyTE9nRVhMdDRubHIrdjJRY0JpNWxrQ3MxNnVmcFd2MkhKcEV1aU8rS05wZXRjUlE1MjJOclBDaitZOVMySFUrbEpFMm5wbFFkMkpoTFdNaUs2YUVEeHJ4NHdlUmdpWmcyUlNhTjFiUDhzL01yTjhaajUwWmgrVkJWSSswak5Ca3IvSENqbEYyVWZDakJxUmtIVVZWVEFTWWNaeWdOeUFuaGxMMDBEUXRIdnpMRUgzRVZwTjRtTU1OZkpTVFJGRlRsNEtrNzJBU3Q2Z1J0WitEYlNJZHB6UGM1S2ViVWh6eDl0MS8weG1xZHlsOFB2NFdycFduckk3aG5iL05XNnI1YjlOdnRtamFxK2QrSC95S2MxMVZRRFg0cFV4RmNGYkp4QkNPa0YwZDFTY2FnT1ZBL2NQbHRiaExjRkdsMmdSb3RxUzkxZ0tCSHFET1hoTnlCbGswQjk5b0dHd1gxdDJ5WjZrWncwemJ6di9OVVNYcEpvaDJtcG9NaDF2endNSmx4TzJEbXI5UzlDOXp0c0w4eGpReHk0OGY3UmgwWGlSdENidzY4OURNVVdYR2NlcW1JVGNtTTlRa1FZVHdUaEJVZkZrT0p2eHBXaFBjbGpYaEpBVWtwcGwwUCt4bkw5cXgxdHhiVG1qTlVHeGZBR2ljMlVPcE9XNWs4T0lHSTNZWE9SUm5MemU1OXIwNXJBQlg4Kzg1bi9MTGwvMFBuT2FYemRhZXR4bFBacWpSQ2p5NEs4V0xwb3VJV1ErSzJYRkZXWmY2NkdSNlBPNlIwRFpSd2c1amRuSzJ1dWZXSDA2UFRQVzZNdzdNMDl0VTZibnljUWE2Nm5qRmJQOE1kcFdBZkxwM2I0dVRwNlJ0U1ZhaHR1K1REbjdPWnplSVpXTmEwTElOWm41bHROTEdEbElZTmFNZjFrUlM4TUZJVXVSMUsyVTR2SUFlWEdPd3psSXRNS2tGL0paNlplRjVxdVhZbTBnSGNpdno0OC9rOEJYb2ZZeTR3YmRVeHRKMHV2V2hLemlRaE93dGtjeU11bUViMFhMekNvY3N2bFRqTFM4c29EUjJtZU9reE9lUEJCcFBxbmQwY0hGVHVNVFBQM0RrMSt0aUxDYWdQdkowUTR0Q2V4SmsxOTd2S2tXWnVOdFNmRzJUTFc3ZHkxbW52ejdUc252VFVndkswMmVTYm4yVU82cmVPRS9PZjM5NysvMTl0UmUvVVJjdEUxc3R0dmMyL3Z1VlFXdXorak82MGhObkZCNzd4TzR4NkE4VFYrTDF0eDBsUUkydjliRGFyMlprTWV5blpqK29IMXRlSGRpZTVORU93WWxGVWpUQUZEdG9rZlRrZEs4Lzl5NkFGVGdhZSt5U1pXcXFhNkhyaTE3OVlqcjl4TDd3WXVvam1xblp2dkkvdm9YTmF3Mm1iMkNuYUhEcitnN3FMRlBHelNwY2Zla291UStXdGV6MitxOVdMcm9qTFFSRy9HTWZENXBFa0xXMEZydkpIK0x5RXgvaHRia1dRcWpNNkVXRG9YeWpBelJicjRXd3o4bFg1VWIyZElnMXlHcU1GbmhMU0ZKQVhZeVQ5V01WMWpUanJMUVpid00rWisvZjNkZk9SV01uQnYvejJWakJ5bVY0YlZrTVk3T2l2MHd6RDgzdG9qV3JyTzl6M3BsdVU5ZiszSnFQOTZrbW9ReWpGbHFrRzErTFkxZVBWdkxVN1BiZi95K3Y5YjZhWmJxT3UvNjY3Wk1WQ0VJbVlTM0o0SXNkRkYvc2h6RXhxRE5oSjZLZm1qem9rWVdRcTRJYWxQUnJwWDBkbCttRDFLUC9ROHI3SlRlTHFCbk1ub00zbExicXlncHJKY1hXYzZaVlYxQWQ2dExIV1hWdUR4elRCRjd2Ym5tQXVQeVYzM3hzeGlYcGdOQ1NCaEswMXZUU2tJMkovbkRxSUpBYmdHYjBjTjdQYUppcGxySmhsbk1kZFlBVmc5ak4zZ0liTWcxS0JzbW44MzJQRERFSXcvb0VuSjcyb2tvTWpFRjF3dC94bWFhUzdSSTVFQm9lWjhJcHJ0ZXZjclpIUWlKYy9TcWRkWTQ1WGduWkM1djNjWFdkQnVyUHJ3SFNOQm5scXd3aEZ5ZXdKWUdPWkdva0ltZUtNRDJ2d2hQbmsxbVd5RkdIZ0VmOGU4TjY2ZnplYTN6aDBaQTMyU2N4c1dWTElRK0w3RHVYMDRkcDJ4KzViVlZlK1N3ZHZKUzdlM1dXdzlVY2drNWwxWkVVbmUvTkk4Vm1kNWJOcHE3Rm82UUIxQW9pKy9GTEp0S3BNMHBBNWV6eXNLd29zazhrY0Z1OG54KzdaMSt6Z2pJVis0QzNwdS9OQnFRczVFaytBWDZaZlRFa2FFaWE0bWpKM0swZmlWTmY4TFd1OC9xa0R6eWRpNDBqaCtMZDBUU0F1N1JuRE5YY0doYVNGN0FJMG1mNDBYL0NGUG5pTkZkOHRKeHB0SVJYOWFFcTJYaVdRcWxRcFVtejk0MEl4M2J5MU5CbmR6Yk9rMUNmb2gxZGZzbFZUR3BDUU00Qis5Yi85clUwem53ZmozUlVKeTRrYUxtNW9mMjZVR3lSMm1ublJodXFoYXQyOGpTbTNvMHVUWFp1ZjVOcVdiSWRrejlCREg5MnpDbGRHc0FPMmFLek1qWWZ4V2VESlg2amFkRzk2aU53OXkxUll1eWdiS3Q1Rm45TjZadm9yTmdVZEpHUzFrQ2VYb2QxY3R6aFZUcE1SSzJhUGVER2huUWNNV0lveEVSRGdUaGlKb0RyQjFpK0ZQRU55RXZCTmwyOHVaK2IvWnB3ODBZMTdOblVjdUtOeHRybnd6VmVJNlVqWlRERjhJYWpGNERGZEE5MHVCVXdaNkQxTzZJUUNySmZ6akN5NVBjbkNQV3Z5dFdDS3RtM0pGTm56Ykl2N2RwcW5QQVh5MG1mMzE1ZGZQQ3ByYTNrV2JwVUw1ZEIzOUJ0SWhwMjNuYWNkcTgvMTdYZVJVeDNqN1B0SW1WcWhKb2NZdnE0dVJsMkx5MXNKdGNDaDcrRXpiZU9zbnNXMy9DTzBPQlV3QWhCOURxYWVqQU8ycGh2SmpSTmJlVmJrcTRGdEgxT01jQVBic2dvYnl0Q2xoVjZZU2NTV3Mwck4xVDBwY28xamFadFk1MmlxSWwyWE10NGQxbTYwNis4R1FqQ21YbEVucW5vVWpUamU1eVcrR0tjRjJIdVJVUlJRcEpxK2N4anBhTEM3aXZGMVByYnZCejU1UVpoSUJJeWxjdFJHNDRtRHIxeVVkQ1dVZ0lJWjJNR094dWVleldzMmJPSzlsYnJiSThaSy9oK1VRN2s5Zmc1RElnNDVPUXh6SngzWitWTkliVXFUUUc5MTRQZ0pVOGpTdnJndWp6MGRmbnlEVmFiMTVjRlpBWSsxMng4WjVPc1U3SU9heFVxNjVvcGZ6Yzc1RXpzMVNHa2Zpcm9Cd201QVZvQXozeTdoNjZTT01TNDJIMHZ2NHdFbWZHekxSU3kvbU45Y2EyZFYrNU8rM3ZGMUlCcFdiVzNYZTkwRGd4N1dpY29sejNpcVVsNHF4Z3dUWXZtYTRjaG1MbW16OWVNRUxJbWJ6WUpMeEtpNGpFZitSYXVxUTROQ29RTXBWZUhmYUs5dGpiZ3pSR0xRTVJCWm95Y3pxekhxL01RZmNWSEwySFFjN25sN1RkL3Z0a3NyOG5UVjFZWXJDWGtxdmh2WnlhMHR5MzU1VWl0Rm1OWkRtOW1ObkpDRlY0RnVBVmpaQnZ2RUcxZUp6Zkh1c0psbUNkelJRZDEyNjJtVXJQYUZySXNTMnRjN1JXa1dPM3RDTytXcnl6c1lyaTNnTzZuZVhsMmFiVG5oM1VVY2FNelhLYUhyR3Q2V0trZ1Bsc2M5QXNHdnY3OXUvaVNpUDRES215TWs4dzdkejhRSTlJTnNNOVpVTFZ4dTkxWmlCWHhUSEVtTFRzc1VZM0lVOGljaXE4R0I4TUUwa2UxVG9pYVJHRjdGejNwUEhodFFJVDdiRmZkbXhSUHkzZklTS3pyL2JsRFBTTEdqOWwySzlWOW5Oam0rWUtJNE8yL21uOXZmaXBpcSt0VFR4SjVXMS9TUktyS0dWQTgraFprMmorNk9PZ211U2xOQjBCNmYyOXJkKzY3WGZMeHJtT3hrL0k4Mm50V0tpVVRzbzE2bGZuTGJsYjhhUHl5NG83R3E0TjN6T3phLzdlREluS2VzclNtNEYyb3VMNDEyRjBaUjR2QTFXejZ4TnBUeWx1andKSkhzTEl6THFhbnJKRkxPOWEvRG92Zk9iOXlXbWJSeTVsYTh2NE5vN21aR2I1dWN5NThpNXltT3FYOVFWUnhGNGpGVW5mb3l5N3RIZGwzYVdkRzEra2JyTm9PL3J4dC9QY282ZWpsNkhYM3J4dDJOMTA3SFJKeVlhZXZ3cUQ2dWJhbDFRMWZ3UnYydUdVUWNpQm9Ibys2djl3dk9YUjZKS3NCTk9Nb21rNm12ejFybmNlbGhxRkZFWUxsNEJ3aEt3a3V1Nk5xcFc1K2R1UmRVcDl0bFpwWjg2enU3WnBlcmJmMXczYlhnR09iSlJSQmc2emFqaTM4WHJpZU9NMGt0YXQ4RXdwUFpzYVhsaHZVMHRLMTBvbkVtY2l2Mzd1dURLcXpOUWVDWGtMeUlCZFBMYjJvL2xtSEZqNEdSTW1JU0tjUTIwaXE5UHJaa0ZHQ0sveXJ6aXpQYnVYNGJVOTBpN3oyNVhqL2tvRTJwY05kMStxWnZZZUdHQXprMGN6Mk1GbnpJZ3JObEcwdlZlT1ozSWQ1TkdEUEZ0d0ZuWFp4c2NTTFZqSGdXNTVrMVdjdFFLZjhYQUY0azhJbWN2dDk4a3VCQ0oveTZCN1JFWlNucElwVURqY2c1NEIzeXNrS0Z3ZXhoMGFkSFQyRzdFdTRPR2pjL3hvdXRzd3NqYlhxMGRzWHhwRkpvSU1oMXdscnRhc2d3K1lCQzFEOWF4TzVZVC8vY3hyanBhQkVFSnV5Z3pSR25sWDh3aVcyWFVLa0JrZk9DVEVKVEpFT0tRdUN0b290S0Vkd3F5OVNQSXlOR1hwNU1jYWZ2M0pLLytUUG0ramx0MDVBNVF0aExoY2FKQ012aXgvT3JXd2pHcXhkUnp2R3NpK04ydnlFamc1OXVNSktuQlFaU084ZDVEWnlBTXd6OEl6VTJyQzFJdGY0NXpSbDVIZ3hTaGZVZHk5ZVBWMVR3L1F0UGlWeTBYdHZyM3dxWXFuTytleVBYZk1Oa0JuTXljcHhyNXNYdnUwN2xxYUJYQWRKZHIzWitUZWUzVGRDanI3YS9hRHdHbTNueVRzT1gzcVZEeDVlenpmVmRtMFUyNUVSVzdDYnhOcDV0dThEWWUrSEhSNjh4RFNTelVHMEMrbjdzSmxRUnd1ZWhQVUduUFdlQzNwSXFMMENTQkNFYVZITmI4RjQ0OU1mUHJyenpEVFZvaWxTYTFVNGZmdWZra1FyVGpEWWV1VTkxL2cwTVBxMTE0OGJaMlVCWDh2cjJnSHpjNjFGNmVrdUhFaEV0NnpNbWhwUkFlMkJwTDNzNEdXRnVtWTJuR3NISnd2Q2JrQTZLemlqVnZKMzdNSTlxcG9LODBicUh6S2pwczErNSs1L28vV0MrWDFpVmpxWkV0MFVHbmgzNms2UForUlp3bFdoU2NQWWVZc0VVMHJva1dNem41NDJYS1ZWWkdpRmlzaVVwYjJib3JncjlsU0lscWNIQ2NMVnFTNkJQdHB4YllaWVY5eDNjY3B3cm8vNzhKdjNZdlNub2dOcWJpdTJ6VEx6allraFRMeUV3Sjg5cE9LNEM3RmliaC83TzEvOHRnNEt1WDdwTldXSlJGQ3BxSk5kYjBMYVN1Tm15TlpvNUUxOTRmWnRnanJHbzBYSVhzZXFFcURURlFVL3VSSmFPcnlnWnNhN1JENlowSVd2WEVYM042enNDWVB5c0xUR2QwTEdJblRxMGM4cHR0NHNyTkhWMjJaOFd5UVpMVDRoRDFwUFArVENDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUFmanp4ZFJTN05kaWIzRmF3QUVuT1JBU3docFdCL1RMNkVHejJvRkNhSG9RM2lsVjNnbEVCWWlqaFMwSlRqcDZyeFF6TDhFN3VZTHpUaitqSjVnVk81b1ZMSG9nMVBPYXVWY2dlKzQxamZEL3JzUWlYKyt5a0k0L0hUMkR6MnZCeUN6Um5xVHI1ZVVkQStsTmRsWmVVdmdxVGEyT2xhTmk3Zk9FdGRONTI1SzBwL0wyalI2NTllVlRpTnNUZ1g5Q24zSCsyZ2hJMzdnWTVrbVRPWm1mRWN6T2ZiWnhaNXcrOVhKMkg2RlZybjhpZlAyMTlPcGdNN0ZweU8zSmdtclRqSjJpVE1QbUYxYkw1aytkbmVtZUhIZHJ6RW5MOVpGMU1sR0lxcG1TZXpMU2VDVG9nbEdMVmRMUGwxQi8zQ3g2OUViLzFOS2YzR1VOT20veWJyK3dVZFIxQXJxTzBNSlllR2tYNDFwTHl5dUxKK0hxTWtXTkNPajZjR1Q5MnhQMmpQU2VSMVJrb29mbHoxaDIzR2hGUjhocjBQYkh0SENlVzhRL2lqVHpSV2RoZEtaRDR5TzBzaThpZitzMGtQdEVMYVVGREU4VzBxTStTb3RWS3p5NUoxR0ZLVEtRMnkwY2JZbEJ5Qjk2WnF3V0xlNE1MYUl1WHhaRXFTMDAyejA3NmV1ZTdkYzdmMnlYZWZ0di9rcEgyUWJleC8vNGYrd2NHdnV5MTNZZHhQYWlUU0gyZm1kU1F1VkdIeXRHenZ2NFdXbUwvWmRXTGJaM1VKclFyY1hKUzBuNk91dit0K1gydzNjZEs4R0swNjNyclVGM2hKUjlITkc5Q3IveE0yNkZVd0VoSjlHenVmVlFYYTdkbTF1aFJiVDVqSVJCMk0rbzI3K1dpcDZVdUVQckJVbVJzUG9XSVZmRzJveEEralZxSEFYSVN0WmFWdEhkUVdzNGEzR0lBenIva2xQUStuZnRiNEhPclZJYzBvQUtzSnJabXhwUkcza0tocHNNdjVoS0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJZ2ZrbkhJL3ljSXBXYnI2bGVHTytrSE9UdFkwSm1JUFUxN3dUT0JmMHhldmdKNnI0RWEveDZEQlowMHpSNWUySWZjbGd2UmNtTEdPbW5CQU1WVktEc25DRUR2YXdXaXZHYm9wMVRKVGxuS0JpVWovY2x4bjNtZG5xaXV6V3o5Z2dJNUl4RFJKR1F5dVFNbXQxSk9sOE9SVDVYK1R0SWtVcmNuczY3TFd2WnBUWi8xR1N4Uk50Znh6UHpQbys4ajBrTEo2OHJ0dnpwNXNVT2N3cEhTdm56WnBTZE9CWk9sZjdya1V3MENjazVrcndGYmV4NFh5Tld4MXdINEhBVkpZNTFzcWkzTGs2Sll6Mk10MWl4VkVBcGpkT3hldFZxenNoVEtzVTIzL1lMSTlzR2xVWmJVZEt6UmhuYVNWQ0RaQ1M4Rk5hU1B0RlZkYzhheXl1M2xzZWxGRkRTQ1dvNitxZHg3Mmw5YlhSR3J4SE9rMnFFUEp2bzJGK3A4M3J5QzlIWm8rV0tocGRtWlZRVFFHZmpaT1NSbExnZWFMdjFhQjFFUWF0TVM1MnM0M3JxSm5rdXFES0grdGRoMnZEc1d3OW5sZ1p0N2RsWmVWdnVNMmVZZW0rdVZEbkplM043OXlSZS8zWDdpYk5OcDg1enZ3djQrVm5hNXc2elZyWmQxQ1I5WGJUczd1WUg5R3VrRVJGVGY0ZTJDR25KNFNYM3NpbEwzc1hLUm8veU5LYXRJTlAzWWpYeTVwZWtiMzVmTzdidGozdkVwdjNaMXQ5OVRkZDdwRURKeTQxSENKbFBkTHJ0MGUwa0FmVXd6cmdscTBvekdBNGxvZ0YxcStqb0Zva1dsbk1GdVJMZWRsblBVc1JUSzBFME1WMW5VNzdjb3F1bXlIU2l4V2x0cHBaOGV5VmF4V2pMWG5KSnREM0hLM0Q3YnVQSlVIU0RvU1RNOEdLbGdjYTdhS1VEWDB5bGxDSGtybkQwQm1CbEVVSUltY2FSazhwNUV4aW56cmZBbGlhRUVFSU9oOVB2dzJFREUwSUlJWVFRUWdnaGhKRHJRYXNWSVlRUVFnZ1o0UXg5a2pvc0lZU2N6Nis5VTlsOHJPWTJ3anJ5Q25qUEVRdUVvRVErRG5CQVgwUVBuVXBPdUNYMG5NZ1NQWFZMaWwvbG5iV3l5TUczY2NnN2lad2dROGJRQkJoWTF6bmdoemFmZGNBMytRMHlDU3BodE0rS3BlcElYZTJJdnFMbDVaVlBDeGR0MmNnczBYTmtYKzkxNDc0NzFqWnRyMnR5cnJ5TGV0SnRleEt3Zm02eDUvNDNOZm5vSUN3Vi8vemZ6OG5CUjR6Y2xkSmlwUVNxeTQyMXhZYnNwTzBldS94OXBIWThyeVhOT3J2ZHlrRjV4ZEJPbHk2YWlGRzZvTlVrb3lvOElYY0MvVExxZC9nNlRITFNiZ0ptS3pHQm5obWtuUmswL3pZUHpaOThnZG8vRVAvUXZKblQwR2Q1VlpEZU1UUHRtcmlWWnEvREZpaDhSSThzaGo1Y2pEemErN1diR2RYWnZIVURPbktsY05GMmJ1K29nTzRJM2xuSW5rRUhsc0pKVUdZVE9SZTBCU0tqeGRzZlExZm9LMWR3aEJBTWJUejJXQW96RUQ0SjRhUDI1NGlmcHF1UGZHakJ5ejhxZDdXNmpwVEJ1czhSR1d2ZGx6VGpSK3I2ZFl5cTdsU3AzZ2RxYktqREo4QlBXcXA0eWgxNUNMMnpIaEl1dXZaRzQxbDRzMTlwY3BMdnY2aFdoWSsvNk5uWWtQSTI1MTFXcmExbCswT3phNVpOSEx1Y2JSalVUdFBhZGF5NXZmNWlyTlYyV1F5L0Q1RU5iYWhVNVN0SmV6SkpFbWhlcVp3Z3BhN0RMUGovWExidERPOG5OV0dLa09hdTdpdDNPU0hIbnhCeUhOSjBZeTJVdEd0dllmalFBWS9hSXJRNEk3YUkycjNkLzZ1dkkxdFlCWFJIMHVwbVpFc0Q3YitFekFZZExNaGcwZ1ppSjRpYzZzMnlnT0gzS3hHZjF3NWJWQ0FqbFk4MkVEbU02SjdHakthelY4UDRmc3R0R0RVWkZTY3VzcWtScmNTTFZqcnd4VlJDQ0NHRUVFSUlJZS9pakpVckxWdUVFRUlJSVlRUVFnZ2hoQkJDQ0NGRTRtMzdTTnczSTRUY0JJb3JRZ2doaEpESFFOWHVBQjVZeWIvK25MMlY4NTh2SWYzbGMrN1gzLzkrWEM3T3l0ZXVlNDV4SWVTRDFCZWpmV2xDSHh4NVlYOGE2RWxZMXBFTzBjTUFnemVHaUE2S2dwZlRlNkl6Tzg0NG5lTWFPYlZKeXlxU3BwWFdmWnAvbGlLRkhDZlg1S1Y5Vm14emhLcVVWdG5HS2NpWjlkNkVoQ0NkRjlpZUk1aU02NlJjcjFBOG16U3o0cjRwVnRuRlRtTG9vcVhnNTdIUFZFMGpOMzZXZXFWOUFhdE1HYm5SRVQyakhlMFdXTU5vSHA5eDNaeGhsNXYwOCtlZnI3SFRVN1UzV0tyKzVib3pnWHVpZGU2SVZ6VjNLZGJvL2dxVENIa082cGRSaSt3dmpaVldwV2xubjV6c3NkV0ROVTVMd2pVV2p1ZUZhSTFna1Z1OStRNHRoSjc3aWMwaXN0NkkyYnh6RTM0T2U5MzJrOHZIdDg3enA2eDFxUFR0NW12SlNZaTVFbEZpS2VGUzhvL3BqUnd4Mmtxc0dlcytjamZRK1FweFI5WGphQjVlbWoybWNFS0lUZS9XVkJMQ2FSWkJLYzhlN1F0SlV5cVg1Qi9kVHRQUzljSnA0V2VEM21kRS9scDVKT0czRis4eFJFMmczbVRZWXFtTFZObmVoZGRuMEdWaEMvc1IrUWExVE9OQzcrK3F2bC95dCt0K0xaUk5iSmJlNS9tNTF2dy90c244WTRoVVp1TDhiWHVTSndOeGEzZFR0ci8vMnZWaEQzcC9SMWEydWJSbCtBbGRrdi8xMXRMa1ZSci9iZW9XeFJWcUdOcDliL0xhTk1qZWh2TGpyOVdtUGJsLytrTUJGOEsxYlh5YmttNW5EeGVORUxJZWJWeDZpN1dYamR2WmE5V2VQQ3pOS0xvTTlQSkE5aEUzank3MXJFR2xSSkY0STJvWUliTW96bldMdGxFb3hSK1VzNUVoRXJWSGVybzdJanZhdEY1UDFIYUNxUGJVc1plQjdLUkxlNVhSWmtUeTFvanFLcmZ0Smw2RnpMZ3gyWlRpTjZ4WEZtOU9PQWwrTVpVUVFnZ2hoRHlJTXpWc3JzYmZBZHVaRUVMSStYQTJJdVRPbkRHQzM3Sk9vblFraEJCeUhkNDI0eE5DQ0NHRUVOSURkVmhDQ0NHRUVFSUlJWWZEeGVoVTh2LzgzLy9kdkZ1cmZaSGgxMy9kdE9hako2bjBIRWxEU0pRVCtsbmZlWFkvWVE0dHN2Y0dQM0pDd2NoSlNGV2VyVXhFaWtESUg5aEo1dE5acCtDQm5HWllOSTM3Ti92czQ0NlFJMW1DNS9vVVpJWmFmYVI3VXNKYmFTY25qeFc5ckVsYlZRYStISlRqYTYwYXo4cjlXYWNzKyt4emlkeDNSTWZ4OC9id05DdXQwdEcwWi9TeE0xSHVPOUs4N3VjOGdmQklIa1dTVisrZXpJdlhyUTFuVFcvT1RWdTh1NGJKMjFGbkNHRXcvUms2d29DSmlzaVZzeERIY3crT0x1c3BOV2E2Q2VzWTlYSFU1V3F0T0tOMy9kUXh0b3JZNnE3YWRVdXQ2N1pmVHZHL3BPTGwrY2tqdVdsczd3dlJiZEIxa0tYVGpxNkVJMld6QmtOazdZbWtaNldObG9tY3lkaTZzQy84ekZVZjdkQ0VYQU5EVTNQZG83Tk1kcTVUSU0rUjdiRUludnl5NGh5NWprREw5QWxMdVdzdzJuQ1dqWWxxRnZrTnVqeUlMaGNJQVpsamlkaXU2M3ZDUzdhRkZzbGZzeTIwZDdZTHIzN2xVaDlrMnRjc3ZibCs3MTd2S09vemNVVG5pVm83ckRCLzI4S2lwN2ZZKzZCN1d4SjZSNUd5alFsTnp5NmRsWXVRdWRMeCtLU1Z0VG1DRUxJZWRVTzRDWWVPejV2cmRuUDBpTGh0c2M2ejErSWRLWU9ubW9mS05Hc1JQdHEzdUs0Z1o0SXJ6bnUvMWgrVnl3TklXZVEwcHBsSzZjK3d2ejVlUFl3YWgzdm5aM0lJdlZQaVNQUFpLMU4vai9VeFhRY3hGdFRoWnVndVh0bzNyVngrTWJXRkFwWVFRZ2doWkJKbktsWlU2c2dUWUQ4K0R0YjFZYkNxQ1NFRTRBUmhtZDhsb0RrZEVVSUlJWVFRUWdnaGhCQ1BNMnhJbVpZclFzamRvTmdpaEpCclFibE1DT21Bb29PTWtQL25YMysvbU9xZExuRFpMNlpHanI0ZVBWS0drRkc4NHdGUEtFTHJmaWc5OWRGN0xJU1NkWjFzSkh3UEZDa1BCLzI0Qnp2QU9EMm42Zm5Pb2F3Um50M2N5TGxVaUx1VXBuYkVic2NrNFg1R3JQZE1YU0d2WFp6VXhFV1UxVWdlQTcwcmRMSk90dXYrejVjbWZ4TDFTOVZURDNab2RIN3QrM3JyS0xQT3hhdzVVN0lFN3lkeWN0KzNmOGJHZTFhT1JpYmRhSWVodDZJVXF2cmdDZGlFUEJsMURTNk1qYXlNSGVsOVFXOTZyc09VTnAzR2ZSTTNIYmYrNWZKb0VFaW5xMnJaYXd3cGJZK1FhbkJFaTZONVlEYzgwNHlIZnUzQ3l4UFRhYjN6VFAxY2JQZWsrSStVQmZWdnc0eWtIY1hLaTV6TkRKdTNKRUY2ekhxelZvRmxVZHFFa1BYMG5Db2VzVTcyYWxWSDVwV2F0R1pyRVo2R29JVVpKZm9oQWlsK0pMeVU1MUpHTzljSHJZTnJuWXpjZ3hGRnhPdGI2SDRmK3d2cFpwMldqcThUdGgyNHdBOFh0Rmd6OVRiOGo0MndiTXBRNEFGWnFyUnlaWThVNnVIejFWVWhsVHJQbnpKSU9XZXhiUFdYVkNOMS9aUG5qOCtuTkhMZVNmVkhjclhpU3ZlZGs5WVdTaHUwdGRyWWdMK2RkelpndWIzNjltN0tkL3pxVWkzTHJseE85NVpzNHQ5N1U3c0VFeUhrYW1qNmYzTGNMODdzWlZMcmo2NlBreEhlcS9vZW92ZDlTTE9PYm1ra0lSd3dQeEZ5V1pEbFFpQVp6MmJvcFlISXA5WTlOZjdvc0NVVFlZVk94OU1CWnFTQnp2MjlkdmxYRVJWVXZYbDR5LzhId0MrbUVrSUlJZVJWY0MxMUJrZldPbHY0Y0ZqbFpEcnNWSVFRNGtGSlNjajllTy9YTGlpeENDR0V2QXZPZklRUVFnZ2hzNkZONVExUWp5YUVrR3RCdVV3SUlZUVFRbER5Ly96ZjMxOU16ZDhucFAxeHJON0svYmhlOW91cFVVYmVWaVlrd2tYN21uZEliUnRPd2p1RmFSbldhVVZSakJQNzJnOTFlUWZMZ0ZsUi9Md1ZOdng2d0RxT25KeFVndTdQWWZZUmhUM25WVFZLYU0zdVM0cm9NZHZSWS9Hc1dSRS8rM2dmZHlUY0NwcjdiSStoYlNaSjYyc0F1WEVwU2tqL1JPaFBuUG4xMFphMXpGQWt1bzlpSERsL2FrYmRyS2xqR0dSSTVkMlByN2dkNVo1K3V6M2o5dVE2NzZCb0RvWTQzOXlsSU01bk5pc2hkMEZiZ3lkbExacUFjRzM0NkJqeXRLZWVXVXE5ejhjeDR3NnR5YytjRkwreUxxYTNteWR5RXJScVBISTYzZVU2UU15Q3RkZmdadWlOK3pSTFdJZjRXNHFmZit1MFdrYk9YTzJOaXloM1ZueUxFZ2lMcERHU0Rya1RnT3E2Q1dlaDlXcnY5SEIwdFlqazlmejVsWkJuTW52TTlzNnlVY3ZvQ21iSzVkU1pscmVHMGVLMWFWanFzOGRVZWI1aWNwaWwybEg5ZWphcitsNE4ra0FEZVJISWZ1QTF0R1ZzSCt4dnlFOElLWTArVzRTYzV2ZlhUSGNHUjMxUS9ka20vQTVlZG1tMTdQY1R5azlDeVRjNWJmSk9mbXRiK05OUVhCdlMyeFVUaXBLTmFkL09tcWJoNVlRTHlTeGtKYmJCOXpZeGx2YnU2NmJOdFZnR3lRTlpFSE11SU9SNEJyYzB1RDdBaWUxbzZQRjdiSjRaRE9lRk56Tk1hWTdLMXZOWUR2c2R1U3JvaG9Jblc2VzRTWW1UWTBYb0FWMmhqY3F0Vnd6ejJjdmRJN1ptWDhMTXFhMDNyNWxOMU52Vlh0Tk5aajBxOUdENHhWUkNDQ0dFRUxJSXJrNEpJWVFRUWdqQk9VRi9wc3ArT08vOWNpb2g5NFdqbGhEU0EyVUhlUVRzeUlRUVFzZ3JvUXBBQ0lHZ3NIZ0ZiR1pDU0ErVUhZVGNENDViTXNLdnYzKzJyKzcrUHJHS0hZdVFRV2FmVWpFSVdoUXYzT2pKVEYyRnlFQ1kwVHdNdjVWWmtRZkRocC9Id09tWEJYUS84dlNhZDRJSTh1eEVqWjdQWjFFRy9HZjNrak43blpGM2tVNW8vaHNqNzl6amc3TXNyR1AvVU1RWmRZNUtGOCs5SjQ4Wm5DenQyczYwV20rZW52YlYydk1DZkxYbjdzRDFwTWdPNHlSdVFsNUxEb3JHUEg4TVJXYjBtVFBldmJpQkhpR3RuN1F2bkJibmVoZStZSGxmZ25IcmRsbHdROUUwUCtHejRaZlVFSGd1OCtMT1dwdGw1N3BObzBlQ29VY0NjNmZrU1l4bzh0R2VwcVhURTRaNk15SGtON05tV2RBcWV3Z2pzMjJ2YkN3RFpaaWxmVTFoMWVSUUwwWTVBUkdKbGNZSTlqbWlNckt2ZHh3NTFLR0w0VFAzZmtxSno3aGxZNmo4L256bTM3U2FyNkQrUkVocUZ0YnF2d1RjcGJUaSsvengraTNDTC9sYWk3OE5sM2RXNEJsMkRiOW1TdHIyMDZMa1hlQXFrc3VpeFRlL2x2cjUyMWZGaEpDVmxFbnV4R1RHR2hPdCtzZ3NOSzA1eit3WE5QR1RLNE9PRFZTbGI1Y2tKL1gvbGFhRDF2M0UyenlHVmZKVFd6NjhvbExuOERTVmh5cWN3OHBIaFI0eTNuNXBIbjlraW1YcElZVDRSSjl2T21DOFJSN3Jzc0ljS2hvUUphZXpEcjlzNWdIREtpRURjRjQ5RkcwVFMvTWp2MW1oNFk2bW1RR3ZMQXZ5N3diM051WjJFUlMvNGx4TGNYdmRrK0l2NVQwSmFWSnNzdHJwRWQ5eGtweWtHck4xUDNkVVVqeWZ3TDR6ZlRVQ2FrMXRnbDJ1QWIxZWRaOFpLZTkrL0tXMFB6NDZ1eVNPT1FHVEY2T3R3VC9xU1RzODZ1V3YrbUNXTXYzbWRwd3Fha1lPakVWMGp1d1o1cHgvTzBIVmEwTXVUNnY4UzhoM3FSQm9KVjF2Z3ZvOEhGaVVkY0pQaWZkUDZmMk9XNVJVMjdDcFNVMitUb1o3VkRwb2VHbWc4UmNhRDZHMHlkV0l0QmdpS3JWNU9xVmpKUWpWYWtMdWh6YmJldlNNOHhGcm81ZG1OSjZWem93NEs5WW9rUmtmdFhUT2tOdldQRFdhTnB5cDE0bXljMDJlRGRJWnZUNmxwWW1HSitSUS9uYm9mYmZHT3VxWS9QWm1CVFNYTHh1RFowc3NWWmovL1BoK3dmWHI1VlJyN3N4TjRwWXVoSnF2K2kwUjZ5MlhuajJuVGlzcjdhV0pTcjhVY2tqdFdhanliVU5DYkNvWnlNbk9NM3NLSmRwOU9SY1FjbCtXTGw3dXgraU9Sczk2T0FOaFVRNFJ4M05WSGtMdUFTb3JjZFZ0SHo1alJaakp5RTVrNitmbGNXdEd0bUtqZVdnRStncUpNVk1WNmhsRGRaaVJmWWZIc1ZKSDFlVHh3L2xsdll6MW1CZTFrS2Y2Q0RtVEMvVEpNaW5NTWhDRmUySzZGQlVFeGxzMWtYVjAxSFVKdWhNRXplTFJ1aU1tVHkzOS9jL2RibWwxV3U5M1B1R0dMUUcvZ3llbWNKaWVMSXZocDhVdG0yRFp5eUpjaitOY1hzY2hmOUYycVoxVHRxL0xLaGx4UEFYMU1OYmNmNTVUUWRJazVNVklMNy9zUEQ3WENxVkQ5Rmg3VjBxVW9YQ2pjWWlBdCtFdUdUaG1OZXdsR2xHYmtENSt2aEp4cGI2b2ZSWEYrbktxRnhkZkNVZmlyNVFPVW54RWsvQ0VaVzladVB2NlZzRHAxNHczRzg2ZGhEd1h6N1kySSswZS96UGx6aXd0UXJ0RzRvelNxNFlqY1phMGpaVVowamxYZG1SeVhkRE9xQmsrZXZvVyt4bzVsZTIrMkcvMlg2QmMxVDI5V1NIeU5IdTEvV0s4T2ZqM0hWVDlib3Bqa05UbVF1bTlrbHBFN0Y5cmxWL2V0UExNTzVjSXNWazhicE5CU3JDdGllaVhkUFdteVY5K245b2M3NjJsVjZHTW0vRUlJVS9BTXVtL0FIUkhJN0E5ZUNobzh3MnA3TDBxRDljTjVNN0UxRThzamQ4QS9mK3Fka21KZVJyc3hSalppbzNtRVhteG1VeGhabFBPWDNuaWViNWkzTjBoN1F2ekt6MGR5WExsV2FwUVd4MGhveHpZMXlJbksvMW1ocDdielVpOWVFZXN0QlZSL0tTa1o5OG9IZ2c1a0loR3E4eng3VHVMQVZHd1M5NExqMnlJUFFkSjBiTGNheHozNzhwV0dsU01tZytvL05tS0pOSWJiOVNyTHZBcDhqRTFvajRoV0E2eHhjdkZNOE92aUR0RHdUeDRRYlRaVVhHRXZqY25XSDFRRzBxYkYyRlQ4bmMwM2tIbzdodlJuYXA1ZHpNajVLYUtDWGt4V1hFcmFPQzBYN08yb3MrYmxoR043VWplcFVjamRNNUQwbHlhcTNRS0VMZGJsenRpN3JUeWlLNUoydGo1SzBZSnVmL2tXRForbGw2cGYwa2pqcS9EbnNIb3VxamwwNDVvZXUxbVFFcnhmbmtGeVVpdWhOYVRQUGVrK0svTW14QnlQWHBuRldtY3o5S2JyeWhEZXNya3lkc3IzT2NVT2I3eVJ0QzNmRnIxaXJ3YmIybUd1ck52dlo1Wk94cHp4T08rTkpLbFlSdkRlM0hRbnFrcys0QzIzdGZ5MUVydjJSQzFzbjI3L2lkQyszSnFidkxlWlpMU0xyeWVRNTNtVDdpOGlmSGprdFg0Y1Z1TDEzNHo3VGQ5bEtvTUg3YjFzTmN2dHVIMzhiZGh2VFl4M2IvNlJjaVVLQ1c2YjJiT0NZU3NKaklCZXhNdE9sNW5UUG8zQWwycnR2NFJVZGhXYVZiOHRmQ3RYekhpSmlOdW1Lank1dlVkejcrdVZFS2VpREttMmkzakk1K0VHdDJabXpIdGtDLzBoUU1aWk9aWVF1ZGgxTDhuejlvOXBkZW9iT1BNMk5SNENNOS9NZlV6YWloQXlaV2d0TWFJTGtJblpmbEJGQjFmWlRxaGFPUUpzTk1jU3FzQ3pCaTNaVktZNStBOVhVQUZqTndMaXVtVCtCWWxoc3lBMzBFd1pJKzFFVUg2c1o1TUtQdUhTUWdoRTRpOGw5WEJXZXRkeW9oWk9IcjQwZ1krY3cxd2ZMNmxlamp3YURpL2VuQXRTakJtMm94YVpxYkhjVTdJZTNtcmhUVWlsNzA2V2lGRG8rMUNreFI1SkNYZ3g4NU9Gak92aXhYQTVZZHNoQ3l1KytlNkdLVXBxcnRranlqSzRDdndVNUw2RSszbDYrL2ZUNmgrOHVwWlNXbXZ6clJoOXF1MWQraEY4MWVuV3IxTnFVdW5xTm1MczNKUlRnZ2hKek1pMXF5WFJFWkU1bVhtMHJNMklibHRRSjdBUXYwSjBkUlh3NkZLN3NUS2ZVQytSM3dqS0xpKzJieVl1bnZiK2ltZk0ybmZOUE9nc1lOY0Jjayt2TWdnZC9TbUxZeDFXcDRVcm5Panl6eUZxdFc0di83K2RxZTRJTzV4WXgvWVdlWVJxTXZjeEVFUEFOTDgzOXVNbHVuaE16RXB3cklyemNxLzY2dE55TVpxb0F3aGlwSkhjdHd0ZjdRYzJTbURramZhVkp1dzIzYjVQaW01dEZFajkxbjdqWXkyL1BXdnRtRnY1ZWpsR3pYRFJjTkxjVk9UUnVRQkFpU2NsZmVCMGk4cmtyaXJDTDBQUXFEdUl5eFM1aWZpU2ZQdjBtYzlicXJEbE9xdVVkMjhSL1FUY2pNc1NXc2QvWkdNZFdnN2RvWm1VNkVRTTRaazVINEpPQis3VDNnSmdkd0YwSWdncnZUNEpZTGN1VGNvenRZOXE5Y2YxNjE3TWZ4YWQ3MUVzbi83Slk1YytYeGkxaTVsVTI1UEE4NUJkejN2SkpUQ3hsdWJhR1d4eXBXQU9KRndrZlZoajM1UHJvUmwzZEN1MjdpUmthTDVjdzRraExSSU0yWHRWbCtqZU50bjBablBtaEY3WldQVXI4MnZwTGpsek12VDAzeEtPa1lqMEd3cWlwbldieFNKdHBPMW1XZ3FtMmRFSXU5ZzFxQ0xoR05mZXlRalhhbE80eWo5ZXRzTmo5ZnF1dzdMVW9zcDFIN08zejZicVNIWFgzSDkvU1hWZjVLVmVIeTRXck83Ti8vS05obzd0ejc3VFV2ZTlZZ2krcGV2LzM3Y3BJblhUdXZIR2lRTHgrL3ArVnRIMkg5WE55dEt6MGEvS0hYZVdjaXB1bmJNUHFyK0tEY3pJZVFJWms1ZDJrTFE0NlhqdnZlMkxaRVptL3QrNGhUQlhRcG5YV3RLSEZRbTFDQnJ4WTl3MUVLZUVBbHR3WU82VzVzYTJzQStFYlFZOHQ2cmJCdHQ0OXlTR1F2Zk5xMDBNVTNTeGN4bVJmUHFvVGpYcmZ1bHg5cE1leVFxbHkya05Bb1EvbUY2eWViRjFOMzlGOFdkRUhJTUJYUWowL25NQ2EwOVZySFBFdUp6b1lVZklmT1JwT1lzdnRMOXppTGJRUTloNVlDK29DVjB5ZTBlZjUvSVdtOXQ3clJ3aCtDYytTaWl6Y25tSjIrazFhYWt2VmpSWTJLZUd4YlpCR25tdURBclZKVkQxc0Z2MGJQMjk0bHVIcTNJMithcDdiRnkzVXV1d3VyVlB1STJtaVloNUJtME04NGJaeDl0MXRYV1RUT2Y1YkRrcTVRbkVtOTJXWmJQQVZSNUNBb1ZFakxJWGJ0UUVYNGRUWUh6ZGw2Ky9QTVYxRXJ3NTZ6R0xKMzMyOGJUWHR6OGUraFdxYTZmSldZKzkzY0lJeHVqbzVzNndzdEpvbTZuS1h1MTMwd2xqeEJDTHNDTVdhRG4vYlVlb0hSR2JpajZob3gyelplaHlSdlFER1hhUXdaNUc3Vk42aTZvejB6Y2xabVZQMmM1U0lnSXAwelN3eS9idTd4VEhyV2FPaUd6Y1k4U0F0UG82S01uWkRrUFM4TWNWYktFQ3RtOWhGcCszb2txZGxSQ1pMUkI5TFFkbGRWWTQ5K3JSMlhBb25zdnlIaC9ablBtU1dHazhKcHBWRGo3eW53cFZhajEzWmVldEJiMGRyaVFnWXVtbVJwM0tUN1NrWkdaS0hxZldyeVV2cjk0VmJaaGZpNkxtTkpQQ2ZOWGVPUStBNU8xR1Y4T254djMzaTMwZU5rOEs2SGszc2F2M1djb2xCNHJwWmt4aHNUcWFNWnpyeTZZbExRL3l0NXlSdnYzZXJ5ZXQvT29QUCswYXVPK3VVU3J1bjFvb1JYbmhEeUFETGlwODJyam9YNGh0UkV0MGxpeU5MZ1o0dmc2MHUzT3pMRGtTTks4N2doTjJsTWFzbXlMNEFIbklRV002cysxKzAvODZLcGcrN1VMcndRL1lTMjJYODNROWVmU3BGMDI3ZnpqOCtPZjBsakRlcnE3SlUya2NJRzF5RGRLLzNYVDhzcVdBdUhRdE1oVlFWdFpHbEVmRUlsVGg1c3hGMGFYUCsrMVh4RnlYelFOSnpMemFISW5hb25JUnRxb08rcnZ4V3ZyUUhMMzVGbFVEbS8xTEYyTGpLaTRVdG93WG1hOWpTUGxVYTBkUytzdnBVblY2RjFFVmZkaXhDV1B4bXYrbVhxeW43c1hHbHVyZjhLV0NXblB5TE4xSDgrci9Peno1V3pNZmZzOG95Mm9sV243TW1wdTRxekRhMWZjbnJQOVpjWDc1TG12ZzIxS2VhUHQ3UFBZcDJ2NXlybDRYOTNOVGQ2NzlTNnlBUDRhbG5tZnVGWThRc2pWYU1lNDVvK0d2Nmh1R0xXVm9UUGh5TTVPZlowNjBwSFMvYVJSbEx6YXNGSmN5VDlja01oNm9uWlBDYThFcmtQSWxaaGh2OUVHb0hFZHNWL05WTVcwZFdCMHl2RDhTSVUzVDdNaUwwV3ZmUmtOcjYvcjhUUXV6WWpBQWt3a3czaWJNbTI0cVlyV2VmejZQR011d2ZVK0lSZUdBM1F1emc1L1BTRnJ5akVoR3lRRlljWUNrMXdlTnVjcUJDRnR5dTQ4b1RHY3lTRnNtcjRxM24xK2NaUGI5ZGVPNFAwdTRjeThid1RTMTJiMlJRcnVNZkxtejY3OXBJMnphSld6aVFnQmNSYXJmejUrQUVRMUgvQXU1bVZ5Z2hQeUtPcUhKby9Hc2xPMVBHTWNTcnZxeGZBblpJeXI5YkFWKzVDY293bTVKMCt4Um5wODdqTUgzVk9hOTB6S2pIY2xidkVjU2JzQXpKd2ppRU9aRklZOEZ2UlppaFhkSlBycGhVajQwajBMek05VGZxRnhEdEllMnM5VWtZMHliY05HT2NlK1lscEJwM0tHRFVuU21iWms0eXFRaVhXTlpiMTE1eHhDQ0RtSlZmdlhzOTV0bURGcitYUERUeDVMbWIycHdibURFQkVPRFdKeUM4UGxQZWdaYXh5ZkwrUUZZKzNYSC9QT0gyMTErK1RvNWpLL1RPcHd0Sk1IazVYclMrMGhJU2NpZWFjSnpKenBxeFA4aWhXT0VJdlJOekxJSHUyMGtOcXRjbytNM3hGUjhreTBsYWpWc2RGalhMeHdTcno2MDJBWmpMUExPbS9URXN1azdhaDVabDlVZi9ZNjhvb1p1b0J1Z3Ivd3dwbkUvbTZLNHQ3R3NnYXlWVmNTWlpmNmp5dFdBaHhQTWFuREZURHVxUHVNTTdBMExGbGd4U2w0bk9nU3RFZHdvOG9kL0xuT1NDSGFzTkgrZlQ0WmVXKy9OR0dMSExjMDd0bzFJVTlFbS9sYy8xSkpqbmFzR0tJRTBRSm1iWENUV2N3MGRJQjZSTnVwMU03MmNSZVNVOVdqOWtuM0pvOTloRzI0cVQxUzFoZjk2L3dWMi85V3F2WVZEQ25jSjgzNnJ4UXlmWVg0R1o5bGs5Y2VUVGkwN20zNHBQaEw0Ync0czlhSFV0aGVmL1EreVpPeDV1R1ZQY0t5SlBTc0pscDNORHdoNUhxZ0Q0aGFGa1J0NWgreFJGaHlLd2w1SjdBTXljbXp4MTNUSWlLYXdXcXRRTFFFNXlUYlAwRGh2Yk9wSU5IQlN2cHVmNnBMN3lRNjZLaHdQSUl6bW5QdGpnYXlRMVNIVDFDNE1mQmM2aGNhMjYrV2l2WDFQU25JNmV6TlBGWEFyejBUN1RuQjNwY3I5MTlCOWROQnZ3ejc0NSsrL1BVVTIzQmw0N2ZYc0VwbGM2bHAzYlZ3VWh5VWZacEtuazE3NXlxK1Z4ZWJ2bUFvbUR1VllZV1NwMmFXQ0NGWG9YZXhkWFBxMnh1eDI0M1M3dDFaZVd2dTlkeVhVenNYMm1tZy9pRThKUzlxak9DY1FaNkV0WVhYMmVjMUZTNHAxMW84aERhUDZKNEdNV0NsM1FadHV2TGlyTEpGckxWeFhKQ29IcUg1YStIYThNYWFHbGJlYmo2K2Y5VVgzOHByMmRZSEh3SWxaQktXc2toOEZncGNiNzVZT3R1VGQvRHBRMXdZektldDF4Tmt4WHRCdGZjRmpmSjVVbWZrQUJVMktHbGdsN2d3S3hvSFRSUE8rMTBUdlh1M211NlQ3VFN0YTBMZWlEaVV2TUV4T0hpaW0reUV2STh6NS94dDNqOHlZbVY1UnUrWGhoQnlYWTR3MTBYZU1VS24rTnpwVHdoNURpdmwxMXUzTVRiUFJxUzVIR0h2V0prSDE0WGtENHR0RVlTVVRqOHM3ZWdMZ2VQTUdoTGFTNmsvL3RJY0FPWmVpampwOTMyODRnNnJrYjlhVGx6WGVacG1sUGRYVVVVQzdlRFpTWU9MVjBMSURZak82VmZTSStyMHBNZnFUbjBjOXFnNWdQTU51VHZTQUo3VXIxRU5uc1BvWXJRTm9oMFd3MFk3blo0NWx1YTFHM0pKUmVzY2Z0V0dsOTlzVGxiNWV0NmYwd29oaTJnVmdhai9BTnFKSkszL0tVVEVUVnRIdlFaUUpkNUcrb0dUeEtYcWtsd0x0RzlycDJXd00yM1JqblJMbGJzV3RhblQ2SHJzZlUyU0hUK3RFYXk0M2t5a2hhL0NaaS90dEExWDBKVzQ5ckp0cE1YUngwWFJOSXJpbmxKY2tZajBZRWtnYWZYejg2YzBKOXNVTGZ3bVJIdS9rZmFSVXJidmMyd2NyNWp0TlFIVzI0ZG1QTWFoMWRKTTB3azZ0cFF3V1drTDZZdHU5WkhQb1Z0d0FtK3FDVTI0cjMvM0VaVmYrOWpTZFQxSzFiaTVDUk1SOWRJMUlRL0VHbE9pbGxTcWNOWUFUUW43T0x6aWxYSWFPcWhPMDdhS0UrY2R3eDVjdElUQ0lIbjI2TEpWOUQvT0JZL1dmdkxwVzhXTDNzK25RMjh2WTlxY3B5KzM0ZkxYVmZtNnlrMm92eVBXS2tIdmwxSXhTcFdIUHIzdXY1OGFyWHRFUXFGcFNHbGE3bWo2RnVqNnp5c1RlVHJXU3F3bzRTTHBSdVpDUWdpSmdDNnhjekJlSFZlNzlzTFB0Q2hGK1djZ3IxbHJraFV5ZjJkamFkZDlYdWFTKzB6VjZ5QTRuOTZFOXl6d2J3TnFoZTU1VEtOTmIyUlhiSlFWWFcvLzFjNnhQUFkyaHEyNzlJWFF2M2E2b3FiUjdvdTFlM1IxT3IvNW5pdS9sdnVSRjFINzdCaCtxcW01YjhtbTR1Vlp6UFEvSVlvWk52OFlzRFp4dFNsVCszSnFIM0phMjk2M3oxTXJ5M2NzNVF1NjMwbDI3WmNwZlFidFNxWDZTL01MSWRlbm5mVDd6TzJ2dzdOS1czWklMUzEwUGFROWpaT2RzTkJPUU8raUxJTmhlaGZ6RXB4dnlKV0lqcDFXaGMyQ0g1REUyTnBsVzRRVnZIYXE2SkdsZFlPV2hEZHdEcnFUTUwxVDR5ZXV0bFRyQWRFbjJuQ2pzdUlRZWlxNUJQMUdHdExhakNucE5jTHUrNHVwOWJOQzMvVjUrVjVHeUUxNStjTDdidlNLUW9wUThnZFA0YkRpYU5la2kwK1ZVL1N1NEtUYVJjZkc4QmhpcjNraUZLMFBZemQzQ2pKcHRhV1VFRUlHZ0Y5K2lhd2p3RXcxVFU3S3FsZjlRdUpSbkpJWTU2L3VrQWM1anFaK1lIYmRtT0w2aUpBUlptendSdU56amlYaytkemk0UkhTVFY2cGZ0MU10V00vUDRFZVc0T1VCcGNScDdKaU8wMXJWc2krdFlnVk1tTDB5Q2NweFo5LzkrNVczcEo3UHFpV2YrZVpPWkNYYzlzNjlwNkI0NE1haER3SExqNWhaajc2MTRwUVQreWk2YlJBZTVXekhxVE5RcVpURGxGUTBpQ0V1SThZU0MrMWMvZ3NZdVRGdHhwRVJ2Wk9HZ1JtZEk3WDNObGtDemxTcDMzUmV2anJ4ZFN2VTdPcWwxTmZSZlFvR1M2dVNDOWFIN3FBc0dsMUQ2bW8wZ0wzZEx5NjlMVHBUN1RtaG9zVk5zMjlmNHFXaDlJMkxQS2tOdzE0ZlVqSE0ybUhkSUlEcmpoWlNWbDdQTDk1MGNuTU1tZlU3dDZxdU1oRkNGV3kxNExlUFpVSmNWWW9BZGx4RHo1YXNKRlR6c1JhL3VheEgydFppU1VKd1ZsV1phK3ZTVEd6VXJia3BLSFZiYkN1TjJtMTdrbnhYd2xhL3A2KzViVjNrMmI3QkY1QjZucWtQYW84eTBnOWVKUDlFVFBEbWp5UWtWVTBoeVp5dUtvSmVTamV3M3h0UVBQbDFVaW14ZGNlMGx0dGhrczRveUpyQVZ4c2J5dDZpN1ZBYWp1TXF0S0FrMEFSTTBsNndkcjVWMHpNdlA3SnFmakZVbkxTYUw5K0ViMHVHNytmVkQ5aHBUTC9wS0dWM2krMTdXZHBBMXBuOGNLTmtJUFhuanQ1SXBha21FVlczQW9ZUnlvanVpTDF5c1dwblpCbkVkVjQybmlXTE5Ia1VnTGlXcXl3cjYvWXYydlRqV295dmZYekoyNnYyZDJiTkpDOFUweXJSdXVscXg2Q2VhSnBJdlB4NCtkTHJhSFJkYURubnFyMHFHcGZobG45MjJ0V2VYdDh1NzQ5ZzU0eWFHdHR6Vi83bW1VWHhmS3FYaGo5L0NuTi9XVWxPWENTK1h5QjlVOTZlU3ZkVzV0RUM3YUc2YXNidng5bk1ad1ZyN2d1OGtRYmE5K2ZjaUV2R1dmRlJmdEM2bmVvc0JJaDU5WWt1bytDd2ptQWtHTkJKM3NrbkxUV2lJUi9HTjd0UytGVFo1dzZYdnZYQW1rZUtTL3BlaG0xb3VndFBuc0x4Ym1IWEFsUEdlMHhxaHpReDFIWlpSVlR1czVPZnE4ZXZ0SWtvUGxMMStUU1JQUUl4SlNtclhkVDQ2NWRhL2xLZVp3S0tqTzFNQ3MzTmVwcjlOR0loL0pQSW9RUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doQk9BWDhyV0QvS1MzZE5Ialhtc2l4ODBRZ29DY0dPcUZpeDYvNUNUdG5acmcrUjJLTkk2UjB3OEFOa2tLcHpIOWxwbGVQVVN6cG1oNU9OSnBHSzBmbVU4OVVFdmw5RGtZOW5PWXB6TUFvNGNJYXNWb2Y3OGI5Tng0NE5pWVhQM1lDT2pjTlBnbmFTL3ZLTjQ1MEhXWTNpTjIyclFpWjdqM0hLZVc5bm1KcC9ySWcrajdkTjdTbnRhYjVIQ2JVMzFYalpKdHVyWWFzZXFNYnFUOVAzWHVsV0RHc2FaYUhDL2VKSVVMWXVaWlhyMUZhTkoySncva2ZPM29lWUxYbnoxQ0pXeFBadmZtNFdENDd6dzQ2WklIWWEzTjFjQmxHNjRWWDkvQjJzbFFTVmpTbzl1dzBtR0FaQll6YTdYWVdiUjV1V3B5UUZEWFFoMHhyblRSNmxONTY3d0RxMVByMEVzdHhielRRYmY2Y1ZIYzIzUitycmU1NXlvZHRDcjNPdmcybnE0Skk0MFVXTWRCOGZDNzJvTjJLbTNOUnQ2RWQ0aXRaNTVQcVg4TzdPbmQwVFM4TW5IZUp1UWRlTFB0U0JxdGZ6UjhaSmwvaE9Vd3AyWWV5TEtLdTl2cWNRU3FGcjVPdXhRNXo5cDlrNWlpZHUyQ1pUbGEyVWZkdWFNV01HOCtjYXpQSWJTOFJxenVxL0FlU3dHWDVNZlRxOXlNcU9ZVHVGUWQzb0FadXd5OU94cGx0MTZXd3lVbmJ5MzliYmh0NmdXS2haWWhiOUxWOXNPa21GSVpJcklTWHY5M1Arelh0RkZ1Yy8xcCtmSnRwMmhqZXY1VzdyWDlZajlqbFYxN2J2M2JLOC9ta2t6ZmJLYTFMMEZ1VXRPdFJ6OXpkUllMcGRtTThuZVp0Z3BGMXV4MGJqL0kyNTlGOENwNmxHMmVSangwc1UwSW1jT0lEdWVGVmRZaTZ2V0ZpTXhIcUw3Ulc0WTZiYTFxVzdmUG1uVkdlUTV2cHBneUlNY2w1RTFreDkwUUhraFVLNXhYTEYzRHRlTWxJeDUzNmlxc0RaM2krQ1Bwa0c3UUtoNXBpdWc4UHpLZTJ6VHFNa2p1bHdLNWNTdE02VWl6T09Fb3dQakZWRUlJSVlUOC8reTlhYmJrckJHdUMrV3k1eisvNHgvWDAvQlp5OXhUdGJOQm9lZ0JOWm52NCtXdnRtZ0NSQk1FSVNVQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3TWR2VDZKMjZaODhKK0ZPalpEU0FIQVVrYU1Ma3ZQU2VhRHVpcUxud3gxTk5Yam9ZeVZoOUFDL3FoMkhGVHdtNGhhblNvQnhwRk1ncmJUQWovUElwYW9jOVYzcEg0MU50cHUzMm9uV01DTXNvaXZSVGlPVGJOenhYOXVUWXUxVmNPYjVQOTZ6ajZ5enY1U0JLMTU3ejZqM0hCbFUzbWxmWXR2K2xOM0duNzVjWDNPcENhVm9iV3NkOVNYaFM5K2ZORHhxUnZqck9HUE1SWTlseWh3NTZVMjMwcG9SVG5hbXZJK1U1aU04UTh4YmxkVEcyRHJUL01nMkhXTkdVNGJMcE90MTVjTzNtY2oxZFpzVWdEU1NSVU50MnAzTlNzSTNPQmZEM1ZkWEJUR3ZJaFYxcnRuUG1MSTltYlZkWXJJZFFRY0VMYXB4WlJUQlZoY3dxMklkRGR3Y2UwWTZPWnBhVW5sOW1hS0pxZDgxcVE5N2s1OHRsbHZhV3RhcVdIS2ZSMi9FSnBaU0NsK2FObk9qQzdGVkZnMS94bW5YbHF4aWhJTnZ4TktPZlJySmk1SFZ6dHB1UWNMV0JkdDRMWTd4c0dBZEJ1QkRzR3gyejl5Mzl2c1IvM2tSNUZ2cG92YlNTRm03c3BzdVMzcWU4RFF2cXlEUE5JRzFoVUNRL2FxRHRhZHpoSG10cTVIK3RTeFFta1lxSzdObVdlUGE2NVcyNWxDa2ZZNVllOWtQOGpIYktMSGZCQU5rdCs4djU2RHBDbXMzNFpGekJVYnR6cEV5aTFEMjlaOW9ORktYeW9aVCtIUk5sVTYvN21rOUY2dUNzMXZYajVXVi8vSlBQTjAwa2lQZDQyQ3YvUTZoTDJOL3g0Vk4rYmkvVnh2eWVPeU9KbzRPV2padmVjaDZRUjRIVlpSaUxMQ2tMdFZWMXRzZnRlbFBvckFyOFZzMW9ZMzNYM0QzMVhsVFdOU1FpR3lRWTAwSkFMZ2lWZmo3UmtUc0tHbWZOTElQa3VSWElWeVNtZDBQOTJWTVY4dmVoeHFGcVl3a0M0QlB3dnVvU2plQmJYbkZiN0o1V2VtLytQcnBQcXJRczJsQUNyOHZZb3RuRG1XN0xlTFgwdGIrMnkzSFdidkRrOGVyaHoyT2pTTGsvVkR3eFZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9EaTk5OGY0TmJ0Z1doL1R0dHFiWHZ5MmNjUk9XWnY5TWdaQUN5YWNHMmRpQnY1dFQyVFRDdktjMUxzNlVoSFJ4VWxQSGc2UXVYeVZpRjVzRkdnUXI2RTZveTNKcDJWNXB2eEtqQ2xIWnVWbDBScmgzelNhK3MwNW52alVjUTBiUlhTVzR2ZmdFVktUd0RlblFoczFZbkdjZWNYV2Zmak5TZ0hGbmV4Yk8vaTV6bkdsaVJyUXYzcEljemtyK2E2SDIweVI5cUR2Ni90YWRKV1NkWnhScEh6TGtmU1JQSWRvV2tpQ3BkclF5MmRPSWlFcXBENTdTRjdsTmtPNTl4SmhjOHdBdWF1UEphV2JrYWVUVzk3MVhNajRWSUZJbDBBd00zd1dGMXVEUkk4SnJFcVFyVXZvbkxYWEZIUzllZVR0ZkZtNFJrSVFyQmtQblBIZlVxTGdPaUlNUmFEU2dyYk9yVWYxMUVIRFYySXpBeWJLOTBTMElWSlg4N1lmLzJpTWVtMlk0aGFVYlZyZkU2SFdGK0syZC9YakRIb2RaSlk0ZFpnbzJtMGF3Qmt0Rk9EWjdqOHRIUmEyVnFhUHAxM1p6YkRFd0VBdUM3ZUZWSktYNHo4bVRTWlZaanFKY24vdnN2SG1JMWNQQlhDMlU5dVNPT0tmbytndUUyWXNTak10SFNzTnJiMm90SjYxT2YzTm9sM2ZaWHljbVY1MXp4YXRyVTlpclNaVmRiUWZUKzJTZHlIRXh0alZqZGFDV2NkYWR4TU8yTGsvbHZ3ZW1iWnZZeElmcW5NcUF5cGJ6eXlQR012MnlaZXo3aUg2SDNLKzErNlA1YlNjZGR2N2FLdEhiczJiZHQ5ZjNuNUFheVN0K2thSS91ZFRhaEZqZStQN1ZMcC9mQzk0TE1SYXRHK1Zsc0Q5ZTdyeFBsV0tpbUw5NmswOTlqWlg4dDVSSnBnU0hRajdsbXo3Zld1b0Q0WlY1Q3M5S1ZGa3hHeHkxY2NZUUNBZFdRTnNZZ3grNlhvYTVmZnJwU3VOVHRDcWt2RXI4akZxM1pFRk12SWl6Z1RBUGdrTkdlRU4vL2twRkc5bGRuUFB2TmxiL3RyaURSdTFwa0VUc2RhK3VoNlhFazhKeXM3UDZXMS8vYkRKV0w4ZU5QTXNJZS9iQjRxWDB5RlJnSUFBQURBQndJVEI0QTVuRHFYemlnY3l1TTQwTmFmREhvWEFBQUFBQUFBQUFBQU00R3ZBUUFBQUFDcnFMQTBBQUIzQTJvTEFBQ3V4WmZxWlN4SEFBRHdYZFQvODUvL3RzMUpYOElSbmIvLzlhRkxST1NYendDc3dudU0wY1N4R0QwNWlaN0tkTmxwSVozMllZWDMwQnZzOHRBUGNmVHBWcHdnQTc0SWJaSjV4aTJRNTdNU0w1NW9SdzhnRFJUSkZlMUovejFrajJXeUpvazJhWjRpeUVuQXpUclRNRnFuUGl5N0VFVldDKytLbkNsVGtlMUpSazViZmpmOTQ2VGcwR2NCb3ZmcGxVM3F5TVRRVTVuZk5mRWFiWlpGVlFRNVhGNHRyVmFIR1VUdXl5TnJwRzZrTHBtcElvNWI4c2ZRNXl5OGhkNmZpYjFwZjczRVNDY1c4cGxORDBEYWluaWxDK2xHZnU3dHZuenNyRU14NnFkVjVmNVRXcnREejBadzVQeExUN3FvN0dqWmpBM2tNb1VTTnNCT1JBMHVJa1lkMkxoUzZKYzN1SEM1aExwSmEzM1ZWSklSTzJCWEdsdVZoSHBzV2N1R2plNU5KSG1TZkU0V0FIUHhhdU0rdnBVeEx3Z25rN3YyNEYyRkFBREFZdVlqalNOdC9ZeVB3VFFqeVEySXJpU0hTVnVsUFppeFBWaTVGK1BTY1l5dVQxU09sczZ6L21veVpxNkZudlU1S252TTB5MmtxZnZuM0RQRzJCbFBORVprYS9tNXNtYmFXNk9Nam04dXI3VUQ4KzdrdURSU3VtTFVJWUs4TTZWN2ExKzlKUDJtNWJQYXZKQzZlTml2cThLZENvdmE2MWtjQ2Q4OUExRjhEMUhmd2x2Rzg3cVI2N0s1M3ViZDY4eTNsTGd2WlNYMFI2cldsMVI1Uit3KzlhNWZWUVg5TG4wVHYydGtiK3VYZ09JU3RJSTFlUUFBNXhGZEJEM3E1OE9SMTZXeC9SS1ZzYUo1TGRzdUxHemxCZ21BYjBIZXRHd1I1c3pPNUM5NlVSRi9IWmZmS3NNcWs0dnZaVTdWVTUrQXRrNTdHaGU2OVZKNGZTeGEzdjU2aFo4cmt1Y1dRMnJFTVd2TklXdExqVG0zNDFjQkFBQ1FCd3NMQUFDQVU3bkFRb1MxRUFCd2RhQ25BQUMzNGRzVUZubHg3cEFpejJ0amZHRURnTzlrL2F2UkFBQndEV0RwQUFBQUFBRE1BcFlWQUFBQUFNREhBUk1QQUJBQUt1TUEwTWhUcWYvK3ozL1o1K0wwc0s2UC9XTHFFK1ZnTURWTm53NXZHSUJSckRGbXBSc28wbk5vd0dYZ1RpaklIbDhhUGNiMW1ieXh3V3BWaXBFT2ZEbVIwMjZBVHVUb092NGcyZHpIOFlKRjAzVGYyK1haTTNaSWErOCthZTBSUVZwZDdYanZFV1pXdkhXLzF0bGxudU43SkdhTXRxNHNiVDBXaXRyZmZXWGpWODZJZHgza0U1VDlhamhxY0JSbitwa3lGaHFTdXpKbW5ta2VsUzNjWjJaS2lVVVFIV0ZkTCtYODFTT3JDVDAxRmszN2tlTWZBZmdDTW02cjExU3hNcE0wdTNrcTJBS25xTWlQWmJJdDUwN2ZzOHFPWUFhWGRidWVUMTI1djVCS2ZpQTdhYUJ1bHFXL2RYbmJucSt2bHp5L1pxTFlwaFkvWHpHSjdEcXBEZTZ0ZzNURUtDVmZGd0R1Z0ZkTmxVQTZyM2FXN0dRYXIybnYwVmxyaFFNQTdvdm1sYkhTUjNYQ1RDdFRNdmt5WDBiTmxQMVg5dk5hS2l2d0hDSjZqb3BsVldXdGY4L2FZS1ZOUG9LOTNOcGlyWVdVcUsyUUtkc1RYN3MvckRtaWpjR1JNVGI2UkdNR3M4dWFNZGRHeTE0NXBtaTY0a3cvVTBZbW43VXZybUpJNi83cnRkMXJWN2UyazFqSTNyb3FrbDUvMWJkL1lKOG1zVWdJWDA2dHBONHZQNEQyOG90d0IzS2JVeDhETDJYb1VZM2cxN0RTMC92VzhrdjkvSTR2UkFZTmQ0eW1oNjlvazhWOFJ0M0pGSjlSR2RsZllwcGNGemVrYkJLc2xnOEF1QWEreGUvTnhlZjNESHZKVThZTTIyaTBEaHlXN1I0dVpHVGpiOGt1aWp5c0hlQ1RrUjZUa2V1b2VwYklxTzJSWnhyUkpXT3Ezcm9TcTNTbWhuY2ZBRVN5YTd3bVQyUG0vTXo2WVc5SHhsbHFLYWFzdzRxVDZjM3pvZUNMcVUrZ2dBRUFFYUF6QUFBQWlKeXhTSnhRSnRaQ01CME1xbThBdlF3QUFHRFBsNndPV0FRQkFBQUFBSlpRWVdjQkFBQzRLWGRldytxWE9EcSs1VDRCQUFBQUFBQ1lDYXhvQUFENExuNXZMNnR3Q3RzSG94M1pFRDBtRUlEWmFNY0c5bWtXVHR1Umc3R1dVUjFoMGFQcWpTTmwvNnJHOWs1YSt6elByRUtaT0lnRXFPQzB5UGtramx4dGJadVZYbk9pT05HOUtvRVo0U1hiRWlSZjVWcGZrTjJzMDF1NVJVSHIwY2hFamh6Ym80MDREOVlJbGhaREtYMmk3UG80YmZvMXA4aXB4THNpSStlcEJldXlPNTI2djM0ckI5Lzg1VTlYYnFIenFEekhRSG9zTUcrYlRPaFBVVWJrR0NwdlhpbmVHS2VTQXVkRVJadWtTV1ZWUGw3RmE4UkxiWmlkQ3lQallDOHRHaDg5Wk96WnBPMnBVaFQ3dTNicFhCTVpnQS9BdStxWVdwaEpZQjJTTDZxK2pFcGtSRVEwNUpOenBuMTBQWDdtY1d4U2RySkhiTGFxeVBVd2FrYzhGVG9KN2dNYmw2Kzg3TW45d09ZR0xrbTNzd3Nxbjc4eVlRRmN1WWpzUnI5ZTRpeWJzenQ3bTdTeHRlUEhqdlNsRUs1VS9scVdMZWVWSEhGV0hRQzREcEZkdlVlV1pMcU83QWExbWRXTXVualR3OXdHNFBQd3JzWXRrTWU3UjhsWXFDOVp4cDVFdEZJQ2U1Zk4vcWpGNi9KTzhKYTNpZGI4SGN3TmNIMGc2WDdQN2tGYmo2S3lQSFdTOGt0MXM5SndaV3BrZDJURldSY3QzdHJ2N3JZMFVqckgrSlhHN1BNcncwM29vT2pPVTJ1bjJkN2tBNTVvaFBXVE5XNHpkZkxvVG1zc1dUS2o5eHZSSlZZZHlrQVpVcG4wMlF6ZE8rL0h6RFo4SzdHOGR0ZDhIUnBKWFZpcDFXajE5enpXZW9YVUlPaTNhTHVhMVUzZFh2R2JHK0cxZGlYeVpKOENrZjNLRVVmZW83UmR1bEswZWRyVTZ4OFp2dDFURlVxdFlsN3Z5RzVGOUkyWk11czJtaG9jWXVQWGZoSnRSSW5ROFNwOVB0NlNBd0E0RDZvMHJRVzVCT01uRTdWNXppelRxN1V6c25wNVdobFR1NmNaaFhtTk9TNjhqOE9hQWU2TzVsVGdObkhTWEtwOHNCZGFWUDkzZEsvdDhWc29WbTJJajFVQjJZYndLSHVhRGpiNFpaRG1Vc2JmSWVHZGUrYldMcEQyVkx5TldraThGUllwc3pqTHR1SytBSHd4RlFBd0ZkZzJBSURMQTBYMTRhQ0RQNXR2NjErTTU4OEcvUXNBQUFDY3h0ZDhWZ3YyQmdBQUFBREFWR0JlQVFBQUFBQUFBQUE0R0d4RkFmZ0FNSkVCQUFCOE1QWGYvL2t2K3p0Z2V0RGE3Mzk5K0lySS9mVGJlendFQUt1Sm5LaHlRQlVpQncwY2puVTZVM0hHazdTZUQzRkFOWUFodFBtTXdUV0h0djh6ZWlLd1E3U3BqaGVyNnk5azRQeWVOaklTcklWWU9OcnNYVGdqand1bmVhMTRLWTNHVENVam5BLzlPcHlYNzZQK0MxRzFhOHV4R3NXTWdlZzhMc1ZUdnlNVnVEVG1acFo5NUViSm1rT0Z4QmMrblhhQytKRUt1UW9HNVpCdXVDWk84MXBOYTJwT1pjS3lYM25Fd2dzK0RFUHp1YTJQWnhwemlrUWNBbVNDdjRLZmgrZHJhcm51ODIzaWkxNDBtTWtxTzBMcllHSHdSSXQ0L21GOVp1cHZHY0pzcWxKOElmRWxoUzliN2Y3N0owOWpVdFJPSmgvUFc5V1YxS2R0NUVuWG1veW5KRG1kWmRNQmNEK2l1MzBwM2x0T0w2c0ZyemxadmN6djJLa0FBS0pZMjRDSWZxS002TWIwNDFGU0tlOGVwVG1VcDJsdUNnM2sxYVdlK3gxNTFoRjlwakZqN1J0MXkwWEhuRWVXbE4rN0RaYml0VEs4WmE5WWI2dXdiVHJxaWNaVmJJam9lT2JTemJxZkk3M3YyVHFzTEN2eVJNNGJ2M285b3FYMytYKzk5dFNQVks5MWh5L2wrZnlzUlJhbUttbm82RXhtaWlxZStiMHZXL0pqMUowdlFpN3J4NS9SMUxwSnN2VDBmRTY5TG5aTTJVa3BocUhoTUNTYW8xOTNBOXpSNzVKeHN3dXZhdEhkZzk4Q0FMZzUzZzNEeGNuYU1LUDJSNC9YaHF0Q09KY25pclFTTE1Wak1IUHBvaHNtQUs2S05INDk2U2NXVGF0UWk4K21MeVhuUy9LQ2FTeVFYWDg5T3ZLVXhlQTdHZlhIcnFqRDdidmRhdFJpeEVjY2xSSEhGSlhENVFQNFl1b0xEQW9BQUFBQUFEQUVERW9BQUxna1VNOEFBQUF1eEpITEVwWkFBQUFBQUh3RHA5ZzhNTFFBQUFCOE9kKzNGTUtqQXdBQUFBQUE3Z0YrTHdVQUFPQm9mdmNYYmNieEJuZkhzd3FqbmNBVmFNYjFaUEZQdnNsUS9kTUc5ZkdIZFA1aEh3N1ZBSWJRQmhNRzF6amN3WjlsSHMvdWd4bHhCbHpyZTN0anBNeSs3RkxzaVR2aThtbUQ4YVB5RTdLOElwa05TSnRXbjdGMjg1NGNOMUxHV2xhVXZYb3NlbVE1NTVKM2N5dDE5R3lhZFQ4bEdYOHQzRlBmbXlDeHNEWWpIb0J2b2sxS3c1bzgwcUgvZ2tDUFdvNzZKVEc5VjdMWWptQ2RMSU5sYnJZRHdsY25tbk9mc05CSjdwZjgvR3BIVlZMbzl4TzFxMmw2UGYvb3FpOGRQVHBqSCtmc1p3QW1rN1g0TFNKYkZ1ZXk3Q3JqczNZcUFJQU1sczliaTErcFE3SzZidWMvc0RMV1I1YUVrcHptSDNsWFpkUFdJMnNESnpzcVkyYloyYkdRSGdjT1dkRjRtbTdtRTRDVjZ5MzlNTjRWMi9RSW9uVnB6ckFNVjJpM0t6L1I4SHkxYk9ZNHR1ckNsY0xQLzhmKzNsbzczTTgwdWk5YnRtWW9uZXlvcXFVSmFkc2pYcGJZaFBBaTVteE9HVko2TDVaY3VzNUsvY3hkNys2djZUVlJDVHRjdlo5dEVZeWJwKy9zTmJicVhoUUE0SE9ac1dHNEFMUDJGZDY0UG43MDY2WVU3YzJuL2Zxa3l6b0VXbmowQzM3Y3RYU2pBRnlSeUFTa0U1cUdUYUNmUXRuZHdDeWRnbW1zOENIcjc3ZVRuVU16dTlmN0pQNFpkdm1obFcxVXk2anpPU044WlhpMzRGL0k0NGVwVlhWeTFXOXBxT29NaCtNRkhBMTlSK3NrYnFrS2FqQytiZjdaUGVqbDhyeTZwNUhyd3FjclFqd0FyaWRxcFdEd1JDRVAxN3QvWG5HV0NlQnBjbzhaZ2E1YmhiUnpNQmFCcDVIYmhHdFhXZG1KTzdKYWVOeEhxNGtwcE92dkovZzJyVTZ2K2JzMXNxNkZadFlsYjBuVVFCa1JHYk93N212QzRCRnY5eEd4KzNFTUtmT1VFNXp1dCtnenk2MmFwazhYSHMzZWpGaDR3WWZpM2VhT3pybGQ1Z2x6Nm1WdVlYNG04R3BYSzY5bVoxaWpKak9LaE1IalhlSkZ4NzdoMEtGcEd1ZnBNY3F3S2tVZFFzOHlteTNvM1pLamEvNytmdXJmRjBqOThwNDJiM3U5WHFwZjV6aDZROEQwTXdDVG1mazR5ZXRac0s1SHRYVlI4dDF2aHdJQW1JRjM3MEd2ZCs3V0FlVmg2YWRkZXNPdDQ2blR4cVJqcnNPT0RPazZnRmZValBkaW9tM081ZVBDWjNpNjA3NmtSSmxIclgyWnVyM1NSK1pZdDQxcEhrZWV0dzdrZWtZL3IrQUtkWmlKOXlsQ0tmc3hKc1ZaY2pTWnE1OW8wRGhQZko4bU9zenBMcnZmRDl0cm83TzB4Q0paTjNuYlQ5WS9qempJNG1kN0k2eVVkRS9kakhqTmQ1QlhNbEgvQnBkL2k2ZGwrdWQrbVoyUlpSMFpzQXFhR2pOOHNEaW0yT2ZmZFN1THBxWHB0WFFBZ0h0aFBRcTRDSjQxMzZPbGcxcVlsVzNWaGNzZkNTOUdXZHlxUEZJR20rbElRMW03Z1NkWVpzQ2R1Y0Q0alZxa00zUWxGdzlLdm5GbmxBbkNjRGJBaU45eVpsZFl1MXV2SDhlekROOEs3eHlMM0xoWEprMzNjWTBiNSs4UFU2MlQxejcrWlRIUFlBVGdTRVoyeHd1NTVWVHdMZ3hNc0xpeE54YVBGZ3dId0EwR1VSenRnY25Db2p6aFlDYWNZdFlldjlNSGM4TDFGRys4ZDJSRVJzb1ZSbFd3RHNMTCtkZVpIMDFZKzcwMWpLYXJqalRlY0c5OE5tMG0vUkd5bmUxVXUzOTMwNjRKcXFKdDg1N0MvVllQMVg0V0dMNUw3Y2tnQUYvRTdOVktaTUxENlJFZkkrenFFV2ZSTERzaTB3dUxlcTRaYXo1OVFXNHpma25lVjlObVhoTGs0dXBHdExZem1kTSsxTWIyOXJkdjRienUzTk1zRFJnRjRGN01ubWNyZG9kWWh3RUFHdUtxUEVGNWhMMVlocW5qMlpQMEpsM0txcGpoVmw1RWM2WVo4WVJIOHE3MlVqWm5tRGZ2MWNwMDc3R0YzeG05QWhJZHZzTGVXTW5NL3J3QzJhY0lXZm5jRTdnbXBLWHBSK3MwUTZkazlGT2ZtOTd2Rko5M3drbjI5OTAreHQvQnp1dEhuRE9pN0lUdThuRHg3NVpwUTM0cm51WnVkVm1DaC8zUGVrZDZPRGphYXFLc0ZnMHZRdGxGUjNxdTlqY09maGNBYm92WGlEaDVtbnUxN2FnY1Q1Nmo3RUd2dlRXOWE0NDJlUGRtQkFDZmhUYXVIYTh5cm1DV1R2WG1nYVhZTWJ0eG42Q1JsMkg1T3pRa0cySkdkODN5YTMzYzBJazJqTWYreURZMjVtWDV2VHZRZlhOZEg5Y2ZiQUdPM05vOGZ4b0FmbVo2OFozRmVJdTZ4SlNZcU5pNXBuNjVvUmwvdFBVekpxZ0tFQ1l6RWNFYmoyZXVPdklxMmJLYkVFNEd5TExUMENXOEdFakhGVzNHVUExMmxpVFVTaWVsbVRIS1BEZWFoY2hLZkhIeVorL1JHTW4wa1hCbVIvbVQwNXZTbDNvRXhwQUlFMTBrWnZUM2tacHJzSDJxRU1aNWdZNXdETkROOWp1aXZDdFNFdkhYUXJXZmkvOXVySGNhTm5LcVhMYWEyWlc0WU1FR3QyWmsrRXEvKzI1MEh5ek5xVWM0ZlZlSk8vUy9sckw3NE9SVHptMThFYmNqYWwvT3NpTW05SkpVbGMyQ1UyTjVwL1B6b21qcnhyRzBGcHFXQURkM1hubnBsME8yYmZ6K1dnbFRQd2R5ZnE3c2Q0eXZyR3BjVzNDV1JsWVdBSFB3dk5QN0IzbldLdXR2aWRYQm8yTXNyVHhKYTArWEJRQzRMcHpOUTdHZW94VWhmcE8yTXZ1SFVxWWN0TDJSM1JUL0JPT0xjTWwvaTNhbDlYaVN2SjZsS0pxVkZWMlh0REswdk5tOXJDVjd0S3pEdGhWOW1jWWVtNXNIb1VjYTNYaTN4dGFIUHRFSTZTRXVQeGZua1JPVnJlVTUydDZ5OUZRcHZHMHJwYmZXQmd1UHpoeWh2MTlPUng1Ry8rTlVkeVhpTTVyM09YQTU2aTRmaDZka2Z1eThXMTN5VS9nOUVaNWQyVE0rMXNOMXA1aHBVVXpaN2g5M2t2NjJUdUZndjVDcVo3R0tCZ0RjaUtqSzkvamJMNFRYNXBsaEF4eHBYMVZuSFN4N2FyZ1NLeHEzSnVNQXVCdWVPZFRwMXFnL2ErYmV4c3ZJTXcwZ01PcU00UEtBNll6YUFFZk8xNGl2NVJaREorNisyTVpUUEE5SXJYbVlMZnNMK2YzOGcvTjNmUHlYVXY5dzVBNENnRkdndk9iamRLUlVKcW5YQndNVkEwTFFwMW9nRHpkeEp6RkRMTHAzRmdsanJnV3ZwYkNST29ETEUrblY4ZDVmT1lZdSt0VG9TS3dtYU1Id2JCMitqSkZSbmZIQnVzcktUQVZNSVFCOFpDYThNTC9hb0drSHZwUUx2eVJ6MTJWRW5sdjFFWGZvYXpFbnlBWmdMbWZvQTg4UEtyQWRBZ0RNWWtUSFVSMTVDVzlySFlyK0NHYjFRZGpkWHNaOVNpdnhQRTdJeWhMVHRkaTFLZHN4eVk2NEx5dmZ6TGFPbGoyU2ZyU2UyZnplOTZBelNQNWE2eWQ5M0dQdjBmV2lNSFdZaGRXR3ZuMytZazFVdFRLODRkSGU4RHhnOGNueTdZdjJvMmhPUC90S1Q0dldyaW5zUzVwc1FpUGVVWmRvR3JoYUFBQVg1eWgvbGxYVzBTeFh6N1BXbWFzMEdBQVhaOFllZEtGMWU0aDhVT0lEQVIyeWxFOWV3ajUrNkVCaFhZTDZmLzYvLzdiZTM4R2Z2bDdLUC83MUJiMDE0dUVkeVE5QUZ2cnUxNFF4R0JGeHBjMjNDZldIZTA4V2FicTR2OGtFOVhqbDAyekFEZkE4V2NPZ21VZmIvSlBObmdJNllCWjBVZFNTUHRLYVI0QTdaTzdXQ2tsWTFKYjJQUHJ1cjdXeXVmeFcrbXJVeVpCaFZZVWMvU2FwUEgxZVJHZFBiclp0Ny9yNUVyN245VjVQdWo2dFZLcVVyam5ESTYzcmVlMmlsRFZ0UGtzMmFZL05ad0tLejM0MlQ3WVcwbmx3RzlEM1d4MGtEWks1QTNGME14RnNrOEtPQW1CRDFLcElyUVJlazRleHU4V1BTa2Zyc0pRcjZ1V0lEU2hwNXFnZEVRMm5hYUplSjB1bUkxMWtyZGZzQ0MvY0o3eVVyNlkzWjVzOHY3elJISFdTdm1hNi83S0liazgya28vbW1vdGVsM2VjTm40dFdRQ2N5MHdOR1MwenMrdTNpS3hDQUlEdjQ2VWJncWJhaksyN1d4OE5tTStXRlhJSG92dkVHV1hOMkRYTVdHK3NmYkIzWFpiV3drTENhZHpNY2FLNko2dDZ1Y3NuZldEUHVzOVMrSHdhMWhNT0xqMVhoNGh0RXkzVHFrT0dWYnZpUGkxTm54M1BuclFjRVk5RGxJUzZWdmJCUERXd1Y1ZjIzbUo2dXE5L1hML2EzdU9EcUhKZE9ObjBmdmYzSjgybXRza2oxMnliamtwNlN1TnpGRkpHSXlucVE2YW45R2VPR0RQWHVoRG1sME84bXRieTAzRmw5OG1WTWc5dEVBREFFcUx1OWNLa3Y0QXUwUFltSHRzdUdzNmxrY29xQ1psU091OCs2QkNpUnFzbUJ3RGczaGhGOTJRUmRSMlI3VVZTRlpqNkJwbk9RS05PSWZJRTJoTmVpdTNIV2tIV24zVTdSZ3lyUGk3amFNYWNTL09iK2p1aUw0T0I4ak1nTVFqQjJXRGVIb3EyWGtXN0FsMEhXTGhCaHNGeVdVYjhjdWpXV1R4N1lZVlJwc2o4aUE0OHc1alZ5N3lTYWQzUGI4elhLQmNZVzFRMVNOZFVoSFp0aFZ2VisxQWtMVHpyMlpVRTVpVUExMkwzbTM3anhlMCtqN3VNQW5qT2RGQmV1T3pvMDlsRGlGZml6OHVsdFo1VCtYWUo1N2RrekZucEFRQTkyZ3dhWFYreFBnTUFaa0IxMUdxZkFvdmsyUGd3OHlMem5GTjRkM0phMlI2NXM4YUQ1dlAxbHVGdHY1VytzaFo0QTY0Wmpyc3puM0cxWUh4YkpDT1NQOFBLTWlXWDl3b2RTb2VTWmwvT1VwMGVuY0hQclZnTC9Obi8rdXM4MnFQdDlWOVhtVFVpTzRzMGlyU2Y0TXdlWmNldC9xY3Q4Y2ZjWHFCcytGQUFBQXdYVVEyamorMmo0ZEUwR2FKcnoxZXRVd0I4TVpuOTM5V2Vsc0dxZERETHVZREdEdE1TY1ZrN1lwWVBGWUM3VWYvOW4vOTI4ME0rbXVFZi95eWZqNlFKYUhqQXdhK21CMkNVRThaVzV2U0hTekdqa3BLT0lKZW15bmdrd0dFQXdNUmFkekNHOHBBSDd2UUFXUnB1ZlR4UEVQL0tvNldIR1hFRWc5cytsOEt1UWxuZXNyVlJNM29PMDVHalNTaFRhSWJHN2tqb2FkTmVJMzNOL2M2UlpoZ1JLVmxlR1NOSFJGa3lpeUpieTN2ay9UdGxOb2ZNaUJIblBmbEpsUGxaaTcxWE00WmZBTHphVUFMZ0pESXJvOWRHZGM5TGFpOExQMHpWNWk4T3paT1lhVWRreTU2NVRtWHZaNGJpRmpaK1F2UXVYSklaV2ZPZlJUenk3T2R0ZlZ6YmxiTy9rQnBkZ2FXeTk3TDdYUHBlaFM5RHJnc0E5OGRTSVo3MTE1UFdVNGNSVDRURUZUMFJBSUFiSUNnNHk0cFFQYWFHa3FNZmo5dDlUTTVUUnBIVFpqaENSMlk5cHRKOWMrSFpNcUpsZWF4TVNYWU5sT1V0dzd2R1Y2bHdaZHlMZFNIajEwcEg2NklOYUs5ZlFNSnE2eU44RVRPWXRkT016S0hzM09ISzZzTzVNajN5UEl3OHdjcWk2V052M3JmZUludnlRQ3RGdjVDNnovOHNVMHFnVFBTNis2TzdhdThzbFM5Ti9uSnNaWXZhcDVQS3RsMHFrZkZ1NndZK3Qxc3ZGMTZxakRKemR3clhhM0JNMEd6bTh5VCtraDlibFk4LzZYQTBBRUFDUzNseTZVdXhsT09ia1lWNElxTzNhWVgzY1ZhOHVhWUh5dlRtUFpYWXdnckFQY2xPYklxMVllTFNHaVljSi9xWmJ0Um5ZaEZwRnFnRWdjeURsS2h6QWFpczhMbU03VUZqWk8ySXl3eVBxQkhua1ZlS3o4aUxPcTZzZVVxQlRiVGpkd0h6K0RQQU1MakFERHpLYmFhaUJpNmtLWjd0aWdhZEFTd2lid2lBUTlHbXIrV2diSUY4NEdDR053dFE2bTZFU1hUbEZweTlUejRlR0I0dlJvMjZ5RUJZSWZPTDJiOUloS1lENERJNEo2UHIzYXVHK1EyQUREVmsrRld4RHRoOTl0eXJRaHJyS1RzQW9DZjcwc2hzMHI3dHdYZ0FBTkNvanZnNzY1a3p2SFRXTXcxcVZkSzBrVGEzZm96VWgybDFpSlJ0eFhQM0ZaVVplU1pFSTVxWnVNUXFFMFhxMkVRVklpL0VaWitIM1hWK2ErTTZrbThXbVhuTHlmRGt1WSsvZHFSMlY3d3o3eXpMYWp4ZWVmaFVTUXVsZnVlSi8zejBGTnhOei9seEJzZFNka0hlblFaSWZ3VlJDMTVpQWdEc21HQkh6cWhDS1hOc202d04rOVdhOGE3R09RQXI4ZXJGaEE3TldORm5BK3RSSWFORG85czVvREtqQzZ4d0tmN00rWXlkSFRnRDVvZXAzTFQ1a3VIcC9TbTc1bTNIQWdCVzhweUtDOGFadFFDMlFONUxUNFBNRFhiUm5vZVdPNVZCR3FZUndmaHlLbUR4REM3cktTSEcxQmJwQ2VtZmZ4cVRwdGdQWEdsVHUzUkNRZGZvUkxka1hNZHFEMUMxc2dKbC8zMDRWeHlNdXNhNU5IUVVXU3V4RlI5Ukd0RVJ6TXR1KzZELzE2VHZkdi81Y2xSN1NIaWVRczMzei9PMStMYVY3cTdMTzg2K3I2UVo0YXFCbkpxV0V0bWNGRUdHTjd3WVpZMW9zOUZGek1vdnBOc1lkWldFTjcwS3IvRElmUWQxd01zd0pPRlR1WTZoNERWdExCbWJsYUFHbSsvOFpnQmdHdFlLd2MxK3lib29qcnlST21Sd2YzU2FYR05hYXkyU3RXWkdiWWhuMmR6b2k5SUNaUWpaS25IUTFFTC80Tk85MHBOMG5lMHFPNDNxSTJuYkpIc1h2WFVPdFlBbjdsMnRtbXhXZnFhL2Z0ekszZTRtWDVlMlZLTUtNN1VFQU5mRysxN0ttWFdJYW5FdWo4ZEdpSG9TQUFBSHM5Sk5JSmltMUt5cUpONGxlbXMreVI4b3EzdytyVWk2VDdKMFg2WUpPWmt6dXNCNmpVSHk3dlZ4WG91Tmx2Ry80a1BiWFZoMUdHa2p5VlFYVGZnSjVWZ3lwWDYzN3RmNklKK1VSN3J2MVdqM2FiVlBLVG43dzFzR2w5NGoyOXA1YzNNcnl1eHgzek5UNVY5NWx4ZVpqeGI5RHBqYkR6ZVNTczYvcFpJSjNKVE0yNlNkNTZEeWQvcXVtelNMcEtKa2pienY3L0dSK3RPaTdWVjJGVmVEYlN0WFp4MzBNVWxYL2FLV0xlZVhTbjFhRXAwODZ2Uk1QOVRnL1RaN1diVHNJaFArVWlwVEJnQmdMVjQzdTJsUWt2aHFsSmtndWtKdzZUazdZNllkUTlIS2ZzWkhOWiswYi9UNDdhWnAyWmxHRVFDZlNHWk9SSlViRFg3dTYwdE9qRWRIckhMMVdib1NKSWc2T2tDWThaM3JPV1Y1N1FndTNZaFBhaHF6R3p4aUhEWGpPbU9jOWVrd0YzZjR2cGdLUXhTQTY3QjRQbVlYb20vVXIxN1hzMlZrNE5CQndETGlUY082emZOczA0bnpqWXJqdW8wcmNyV3o5RHVaMmJHUFh0dTlrYkpnRUluVVlQZ0k1eTlFVlhqUWVkWGxNYStlc2VpZkRuMHJpT05NQlkzRndjWE9KOVNwWnpRaEFOY2tNamRENzJGeCtiNGUyQnNzTTAzNVAvdUZtaGQwdTk0UjIyM2ZxSmlIQUZ3Zno0OC9ac21McEFFQUFBM0xsS3N3ZjkxSXp6U3UwSVNyMWlFcmoxZkc3SFJhMnVoOU5lTUZxcHFvdzZ6MEZ0cnpzaG50czZMZnRMeVo5K0l5NmJMOWxwM3JYcHR2UkpkSWRieVNudm9ocTBXODhqSnBWOHhNaTltOTh0UFQ5V045V2wxN3JScEMzcWE3M3FRQ0FId29NMytNOFllVmFxdi9mVUgvS3NIS2Q3MHNWVHhWWGNNNUI4Q3hPQ1p1QzhhZnNVK0N5WGdBVWYyTURya0ZXSGJCdDBKK21NcjhYdnJUWndlM2U3RitSbDZFYTA0bUFCazhZNnNxNFk0eEtQMXd2eW5aUDhxbThiNkIwL2k4WEZjTVRYMlMyZnRsR1BEaFRCbGNZSVAxV3o5aHpkZm1vK1lJc0J5V1hKSG9idTlxbzdtZ3JZVlVNUG8yeDR4TER3aWpSK05ZNlNpVzY5bURkM1JKWnlUTmVOMmhxVldUSGl5M2JyTFZwMUZUdHdzdnJhVmRJMk9DaDZ5ZjVqSWhtdHFXMFRhVU5pZEZpRitwWGJ3eU1tVmFlVHo5cUYwVFVjMUlROU96ZFJEU2JkUVRNZXJFazdDRkVVMC9mekNGODFhYWFDOWI4WnYxMVZLUkhsVUl3SWZodFVvMDNGTW5VNGkxOSs3VEVkVzU0WlQ1dTFKNVNMSXpMeXArZ3gzaDlXaTEvYUx4eXRyMGE5WjhGTW95bXJqU2RPUkk1SGNWSGZaeTNWNjNuUm54STZPMitpaGkyNitTN1ZxNWNTQjJ4N3VlamZsclRBTUI4QjF3MDB2U3hrVUlqKzR5aTFMbUxMUzYxUUx6RzRCTGtka25TeFBacVppcVVJZU14OWY2VWVxSUwwTEtNMktwUzJYMnVwMjJRelB5UnBHNlhPcldhTnQ1KzA1S083SmVSYnp5MWpEbThtVFNlZWpIc2VZR3pQd0lXOHVpemJub2pteUV6Qk1OTGQwTUxIdXNrSGd0emV5eW8vY2JtVk1lMmR6Y1lmMjFUdVN2ZXZacDF1S3BBNWVuS1RtZWUvTG52djE5UUd0N2hHL1ROMnN3TlVZL1ZMbDIvSFVUUXF1WWM1L3JKNlM5WXFpdm9STFp4YXpSTzQyMTgrRmxyZEVDbHFiSnpGQkxvMUNFVnZRcVAyM1JTRThxZWcrclp5Y0FZSWM1OTBrNlM3WGVhQnB6ZHNib2Zxa0tZYzBvc3lUSzVGWVdiUi9ZLzNzb2xqRUExUTgrRWJkOXBhUWJuQnRSL2RYbm9XUjFZTVFuUk9PaEdpYUN4andNeXcvcnljOWRSK2FGdDB4cmgzcDdMS2NmdmRZYzNGejhNMDV5eUhQWFhINmc4a3VML09QVTZnM2dqd1MrRW5BbnVQRzZ3TWdGZTZyd3I0ZU1IdjFvdlF2eWZQeWkvSGxJYXJ2L1A4aHlvaEdIZGZibTVHZWV4K0dHZWYySE0xdkJXWGJHbVBOMnNHYXJXOWRTMldDRDljS2ttQUVBY0MyOCtxMHA0ZC9ndXdTVE9YQlJ1UG42ODU1Yi9JdXIwalVXWGdCaTJITnFYVmtSb3V1dGxoN3JOZ0EzNGNRbHZRNG44SE9HVHZwMlBialNzeDlkcjJiVVljYWVsSjVqOTJuTUd2TlNXNTh4bHJqNFZjLytxTXpJKzNGU0hiTlU1NzhhK3pwY3diTnpSTS9KcVZLNEJ2Nk1wOUxlaHhxNU12REtub1RTSWxKVDAzQkpVUUVBd0VYeHJDUkhxYlVqMTZlUmQxS1gwTW9jRXdJQUVPSU8wMDNTVTdEbEZ3SDlPeFZzajc2TTZIbFFZQXEvK2VEMlhWL3FxOEg0bHBRRHdBeXNINlgyNmJnbkZHMHZwakRKdUNLYU0yMFYwbCtDbGs5REh3VHVER3loZ1ZMNkZCWVA4SERweVhZVHFPSVNUajhaT1dIS3E3WkJocWp4NVV6dlBrR1d2QzJpZHJBMDJCaFpwZ3hhR2NzNGxWYm82Q3M2bHVIaGtFbXI4Z3plZlBtcC9yMStuVE85Wk9MRWZ3a1Rxd1o5ZWI4eW9YTDZaNjVpNU9Malp6U1lOVDQ5V25GV3gwbmpXS01WVi90SncxcThmWkpZKzVycDY4dW9WdjgwUTlZdExPd3dsbmJ5NUdlN1Qrb0ttcmxQbTJsU1N5VUNjQkdrdWVXWmM4OWg3clVpdkZiSmJwL2NIR2FVazJNMTVjcFNMTm5lZFpwYmg2eXlSdS9MWStOYWRzVE10cFZHTXBOc2MwMEdxbWZoMGt5VVJoTjNaVkJiZ0U0UzhvV1ZqZGpuVjFmS3oxZGEyR0k3MGZUTHFlL2JlWWJYeC9VMi8vdnFmWk8yUlpheDRRRDRYcXdaRXAxSjJwbzQ2cWV5VktLa0lqMTJCeGRlQ2t4dkFFNUZtcURhcE5mU0dlbXJWUmNGYXZ0STJibXFSL3dSeFpIZTgvelVhakl0TDNkdDFjV2pweHU1amtLN3VUQmxjV2xIUElxZXNqd3lQUG1zZGJoNkYrQm5zcmEvZnRudXprVmZTcmRpN1p5eExudHNnbXlaVkhhMHJKWDNOU0szRkhsSU5TWnR6MGlkZmhFWlZhaURkdTFseHE2eFBscWtxZkY5bWZzZDd6RDFwdzdQZDBiZTIzcWhwZXI3enYvdXVCL1hUVlBJd1ViYWU0eXFFUDVPdnkyNjk5VnNRK1EyYjZMcy9wcExJeE5kL2J3bGFDc1FYUjBsbVZZOFRjN0psSHhHejZqS3lGREsyc2tsdnFhZkFWZHlqTXhVQU1DaFNBcjRnR2xzNmY1bXBEK0NHa2hqMVQ5Yjc5eWFlQ0pZQXNBbkUzVytjT0dUYkhpUC9jemw4ZXgvTFo5VHBHeW9CQUh2TnNGYVBPaFdERnlLbVYweWF2OVlmdWpMWXlrb2VqM2lMUFEyenUwYThUcjhGbU9zbFFyc3dRSUFyb0QzU2FZVHFBSUFUc1M3QVFHM0FOMTVZNTZMb2ZqMlp0MWZwNkVGU1N2eHpZM08vaTBiaGl2YUh5TjFhdVpHWWVVZGYvc214V2hiTFRxcXVPR1ltSTdtVjJLYm1YSHlZMzBGNEpxOGZyOWZTdmd3SnlrOTVqdmxESXZxeW5iSHducGQ0cFpKZngvMG1TWE1Pd0R1VGE4NWVnMGUyU1paMTFLWUp4NDZCZ0FBNW9QWEdYaW03SjRhZjFtN2kvNjNRUDIrV0JRcC9GWXA0NGIwck5rWnVCZFp2VTgwclBjMG8zQ1BjaVNpYldpMTE0aWJXVXB2MWMyNjN5cytaMW5IR1U5aG83UEtOMEpldW1GSVdWdGwxV0Rla1ZHVzBWZ2ZqTmxrZGQwRzZUbTROSjhSREFVQXdBVE90RDlXMlYyZzJJMkZ4Z1RnVFdSemVtRmdHaVlZM1pweXpoVjB4R0hBanZnQzBGbExJVDlNcFMrd2xNLzNWSnB2dGpKcHRWOWJmNDluRjl3ZGJSd0xTWHRhR2ZlSEJxb3dEKytwTmh4TmtDWEpmZ2FUQXdpbEtqMHZ2dXFMMVVBbThzd0grSWlzK1dUZVd2TTRXalNtZVFhdEZRK1lISnNmcFNwbDA0ZDVUVWkzUzlBdkl0eXJIQjVtdjhhaHliYk9XeEsyM3Evb3BreW90czFKL25oOUdjbzlMeU16VHAraDBzanpsZUF4SkRUbDcrMWZhWk9pcFpPT2lKSTRRb3NaWTJsaXYrNEhteUhiR254Y2MvZDVQWXNKcmRNVUEvR3pWaUJ1WkxRdVlIZTNsbXFOTkEwV2NuQXpQSmFBOUNxZGQ2M0xUQXVxRXJscnRxeGdZZXc5ZkkxUmJ0Mm9wUXl0ZFpocjNhdllFWnhkYmRXQnBLL0dES2hjbWNWb2NtR3pLZFNrdkd6ZnJTMWMyS0lySzdLMW1CMjVieldwam8yUldPa3J0YS9VK2pVQVFFUFNSbDR0cDJrejZmMEd5NHRoNGJVaElxeVFDY0Iwemh5bzBiSm51bDZrUEZGejB5aFQyeTlrcllwTWwwbDV2T0daTXIxcFBXVzA0TFZWbGplOGgxcnNYbFpPc2VvTkQxYml1YjYrMXR0V3dsOUdIU1d5SzdUQ2FYeFQ0czdBY3orWjl2Q09heTFmTFhPZUFIamp1REs5WmFYOFBDWFdUaU5QUGk3NVJJTzRCT2lYVWsxL1ZwZityNC9zblZQTzhueHVacVI5cDN2NEdJckVYbEwvdGRtbXlKWjZsSzVMWTJSNzBqSlFQSGtFRWMzYXJYRjUrdzV1UW5nWHR6dVZnUGlXSWhhRytxUFViaEJYU3h1ZXFla0IrRkkwUTRKYkZLbDZ2aERSL1JTWEpwTE9ReXQrTzNCMDY4M0pIZTZtbFVhYzE4Z0Q0QTVZY3lXek9iSEtTbFpscHZxMkxMam15RXY1U0d0d1JKZGFNZ3VSN1hsY0tqMjhBU2tpMDFpeU43eGRNTE9ydk1QeTQzWnEzaHVmMGJGYU9oRGlWd0VBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTURCNDR1cCt6TXA2K2FQRC83cHIzVnNvWlNHaTU5eGxDb0FFYXhqSXFVNDd0ckp6Q0Y3NnZDdnpqU2U0MkRJZkthSEcxcEZOZkVDZkRXZTlRbkVxSTR3T285Sk9NM21PVUJydGhueHZTWkVOYTVIOEp4eDJKVzMvd1FSSThwenRGVzBidFo1VEo3NzRPS2paZlg3aHFUQlFhcFdpV2grYlNTbkxML3liazk2bHZHYy9XYlBMSzhKWVV0N25reGRoYnJQbnVXWk0rNW00bDNZcExrVHJlT0V6Wmw0ZktrMHJydFRxc1d2cVhhRHZpa3loWEUveG5WV0RxOW0vQ1drNTdSU0lXa29yOFBHUjRmV1JtaTVVck1DNEVhYlF6VGN1N3FtcDBJbmdQdUE1QXgxMk55QkRpNWhqSHZQd3p5aXpMTnNDSzdzdm5ONlplOFp5WlpzVW9SYVpqRzJFNDIvTHAwZDBXZDdCVDlzeDkwWFYxcjNSZFNmKzZWMmNoRnVSUDRnTEkzUWJEYnVtcnZ4N0g0SWdNOUZzbUUxMjFiYWdWdjJkVFBLOXVTTG5nVHQwYnhSY3hxbU43Z0ZadzdVVVpQSE8zRTk4Wm9aNGFXNmdtYUlaZE5FUEtLNjFaVnI2aEtVV1NhV0VhMkQxd3NkODhMeWVQZW9WcHpXbjFiWjFYQWh2cjZHT3FFVHJBL1cwVEt0UGlEWnR6S0U2MWx3YzRwaTFTSDdSTU5UcitxTTU2NDk0MUliYzFZZFBMckVPL1k5NlMyay9wdXRkODU1b2tIM3kwMHV0MjduK1hzK2ttZFd6a25WWEw2STJ2MjNGZTl6TVNzZEYvL3o3R3BiL2FyZUJEOUNxM3NXL3FTK1BMdXZsZTRTUFA1Vi9EMjFqeTlFMlpQdzF1ZVZ5aGEwQkxjNHNFM2M3RGo0ZHdBNEgrcnlwdUdsaTQvS1c0eTFiNWk1cmx0N0U1b3VjL3RlbTl1S245cjAza2FNYk02cThEY0FkOEtyTTdPYk5hNE1aN1JYRFh2U1NVdUVsNmlmaDB2N0VXUWVhbGpPaUpHeDVZa0hTMmpPOEJYZEUzMFdGODEzR2FpempDSXBwR2FrazhxeTZnS21nQyttQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRjc5L2ZpajhQS25zeWZ1dm54UFhXL21xbndON2p5TE1IQk5SQW1rQWVKSTlKRkE3Z2NPUmhWSUxMeVo3MHNvcFJJNnNrSTZTNmZLMDdzU0cxd200ZlZ5ZmpSeGdhQjZtQ0lDRmRKSU95Q1BweXNnYVgrUVRhZnBEWHJKbUJMclpRL1pjTWFIak9XWC9DcWRacXJPVE1tZWFqUjRSWkpXamhWdDFzTEJPNjIxL285amx0bTZiK3M5cDA2MExhT1lSanBIMmtLMmFKcVRXMHRLdnViNnYzeWtiT3hZeXBVa0VGWmlMakxMVStza3p2cU4xR2FFS1JUUWhYSWpmcENVRCtlOXg2bzU4WGZKTldmRUVsOFF5emEzWkhjbjNtbW4wa1BCb29aNFRaQUc0T0pKdEdobmUwN1FPSTREYlN6ZG1tY3pzcVhmcU9NcWg4MTdhTVJSbk9DZUxwanRyblcyQnNpS0t1VGp6Um1SRXFjeWZuajVwbStDNlc2ajRPcjYreEVMM0xPMXRaLzYxbi9zOGo0dmRWNHFidHBPbDVYTHBhVDRBZ0lhMEhrdmhwZmp0WTIvWk14alplY09jQmtCQm0vaXkrMHFYWVR1eXR0ZGFIcWxPbHVLNndPbmtVbk53K2plU1J5UDdMSURqQ04zSmJMOUNkWkRXaHNoOVc4UGM2ODZSMG5pR0d0MXovbnBjLzY4UkdjN0ZzSksvT1pjaWxTbVZMYnJiK2VBWDN0MmlsdGN6RHlwejdjazNhdXR3ZGJCVUlKZTNUOC9OM3ovLy8xK1JxY1duL3JKMUs2UXVudjcyZWhROCtpcXJoN3gyNDRpT2xNdmVQcXQ1aDlPeWZ2N1NYZjAvejZpa05Mc3ZwVXAxc1o0MzlHR2Q5SGRFbFpQUnVwQ3k5OUw0OXVFclkybm9KNzhVV2R0YStmR1dQUk5TcHZRU2tCVGYrMnE0ZkgrZmo0cURpYy83V2lTS0Q5WS81ZlhwUlBvSEFHQVNYZVNpQnBPMkp6dGdlbHRGV3VHY0xKcHVwT21LSUpQbTRXUjU2OWpMdkxRR1hWRTVMQm5naWtTVWdCWk9KN2JteERkRUZVYUVrdjFsVlVmOUhoNmFzMDVIVytDWHhuS1VSUnN0c3NBQUZ5UGoyTHZqOU03ZmpJdmZ1M051UnZ6bGlUcUZ2RTVQYjBObzZXNWh6RjBUeHhkVDBhb0FBSnV2MVJSUWtRQUFBTURoMUlvRkdId1NHTThBQUFBQVdBdXNEUUR1QitZdEFPQjJRSEY5SkdkMks0WVV1Q0lZbHdEODRkdFdCOHg4QU1CTmdMb0NBQUFBQUFBQW5FVDk5My8rcjM1YzI0Ti8vUE9MZHk3UlgxM1R0RGd1QXF3bU1zYU00eUMwVXlLeUowRGRrc2l4RjBZZThmQUU2L0JFQUNSV0h1ZnlyUWdUVmZyQ2NlWjB2ZElWa1RsWkI4ekVPaWJTR0JDdk9HVlYzSFZnOWlnZHJVeHJaVjR4ZXJnNnpDNkxhYU5IMjYrZkQ2UEtVanBWV2s1YkhqbXlaWTNMYUlGNGIzK1BqSXZzZlJuemQ5bDhLUEppOFF3Yk1mTGNud084OTZveFdtdHVsTkp3TlZPZjhjZ2hCTUJGOEZnWHk4c2VNWG40eTUyZjQvcEVXMy9XZWp1U1AycEhyTjRKWmU5cnhTSWcyVkZGa0czRlA2NENWWGwreFlVTDcyWHRQKzdSTnVsbytDTlgwV3Y2bHQxbUQ3R2pGUlVBSjVQUlpqU3Y1T3N2UXJoMlNuUDJzT0taM0h2M0F6Nk8xZXVTeDBUSW1sMVdtUTRiZklkbFRsbjVMNHptSVp2bHplckRhTGdsb3doMU9sSlh6bWlYYUo1VDFnVHJzWUluTDAxdnpJMmQrOUdvaWxTRU5xMnBMRW1teHhhSVR2bG51djhKWlhoVmp5Y3RiUWR2VzJhSnFOSnN2MXJoczhrdU0xbGRHU2w3dnlUNm50bTg5OG54V3ZWN1oxZit5dGR0L3pYVFJGME1tWGt5bzB2U0VoRkdSMXRpTi9XM1NDYWYrV1ZVSXVlZHNQaXJJRGxSaFB1cHdqT3FORE8weUFjWWZRQjhHaGZZbTgyeUFTTDVaOXllWlQ5TEhMSXQ5aGpsV1prQWZDT1dvbG93UDd6N3ZtcklpT3o3cWV4by9GRjd6c01ZMFpsZTJaU3ZhZHpya1BWUFp1WldodEZkNzIyd0dqWGJFSDMrVXVZYWJ5Q000NHVwQUFBQUFBQUFnR3Z5WFRzaTdQL09BSzBPQUFBQUhNY1o2eTdXK2srbTFndjBMNFlZQUVOZ1pRQUFwTUJFQmdBQUVhakl6K2JNL3IzQ0Zod0FBQUFBQUFBQUFBRGdkc0NuY252cXYvL3ozK2I1TGZjLy9sWFduQXB3WmJ5blhweDU5Q2dBZjdCT0VaRFM5dkZ0RyswOWlDTnp3c29sOFJ3dEtpSG9ocFk5c0pEMEJRQTdNRGpPcDZtWFUwNUFCbWZpN01IR3BmZjJOSmRYSW5wRWtIVThZaEhxWUszK2dWTjZ3MmU3OFdYMnAwdFg1cStmbkkrVG44azZPMGJzR0tiOVhmcE80ZTdUYmt2MHRMWFZuMWFaZDlVMjBiRkZ3eVdaVFB6SWdkZlJ6NE5aQTdpU1A5cGQrNDluWkZUM3ZaZlp1OUQwWWhwcmFmaVlqUkg0QmhJYU1lcGFDQTkvN1dQVHV3OFMwREtGUFhaSVZVNWJHbWRZOWQ3S1JMU201U3lTOG5GeXZHbXZpTmRwNWgzQm1mYXc4dmppZXp2enp4ZFEzbHVUL2VUWjNRM2R4MWlmWFNxRkNaREczNTZtaHZybGhMbjdjQVZBNFloaC9kU1lwbXB3eEh1OEdCN3Q3Q2tMZ0NWSTdxdk1QbEdUT1lwbnN2VmxlazJoSXFUenBJM0t2aWxldjBZMXJudEc5MmJGU09jcGkwdG55WXFreXhDVnZVbnZ2RkczVzQ5VWhwclZxVzBDemVlY005RXBsclBzYlZsUGVad2RFWG1LWXFYVDhsbDU2Qml5NW1jRXlYN3F5ZXhJSTJWbmljd3Q2NzRpK2Z4NWEybERkM2dnTzkyZzk2aTloalNtaUxyekMwaHArM2dxYzk0WFZYK2tQa3Viays0cWtObTFlNVpUTi8rOGtGNFdlc1h2L2lqc0MwU2NrL1FTVFRoVGV3THd4VmpHdlpYWHMvODdnT2grZ3BKOW9xSGxmL0xMa1NiTFRGdHVtS2lCN2ZGdjBEeFVKbFErK0FZR2ZHVFIvV0JrVDFhWXZDdjNnNWp1RE5tSEdqUmUwc3RBSlByOGFNd1hvYWMvbzZ0T0hSNGppa3FUbWZHaFJoVVc1dGc4bEQ3QUYxTUJBQUFBQUFBQUFIdzU4RG9BQUFDNEVsLzNHT05Bc09ZREFJQVhhRXdBQm9GSkI4QnR3VlFDQUZ3ZDZLa2pPYk8xMGRNQUFBQUFBQUFBQUQ0WWJIcy9oc2NYVTErWDVmbnpWZnJENEgvODh3dDdYVHVSb0Nkemtnd0FSeEFZZzlIekM2TnBiNHR4TEJmWEhwYnFXSEZvQlBoU1pwNldCN1lZRTlkckloUkh2RmQzZ0F1eSs3UlhGeWQyckxUaVd1Y3FOVWM0RjYrVnNXSWx0ODZkOHRaQk1LemJ5TnpRWnBmVnBya3k5bmVybjFvOWx5TzBTK1JJdDZ4c1M4Ym9YQnFvbzNXQ1hXb0swZE8ybmZIVzhMN1pvdUx0OVJiSVp6WkRaUGpDcmdKZnhzcmhycW5PdE1YeitpSUZ5YnZrU0d4RGI4ZUVsZXNvbDZQdENNMlF6c3FPbm5QS2xSazl2dFpqREVRZHpmdzE5MldVditIS1dIeCtwWVdtb1Y5djJjMmhuVWhwcG5KbGJ2TTNKbjVUeG9xaEJzQVhZbW1yd29UMzhaNHA2TldZWndCVjhrVjRsOStJdkI1clh4aEoxNExYbk96cXVQWmdsZVYxTFdwcG8yWGZIRXNuV3VrOXpENDhmaVl6MXdEdjFKTHllY3hLYXFOUzEvNU9wbWQrTW9XcWU5THNsbVdRL2xhc0tzd2NRMGVXNVVYcVZ1K09UWkpubGNmSnlLakcwU1d2bDlQWElSby9rOGc4SGkyamtQMnh0RjhPeWQ3dHJac3ZIWE9IbTMwKzJmL3YvUUVSWTJCMElSNFp5WkhWa2h2aGtmczBSZy9yOEppMTBnb2plWmZjb1JVdDUrY3JPYm1mdXRLWUs0YnN5UXNYQUorR05UMW5HTmJSTWdhNGtvMG4yUkZaV1pGVjV4UkdIelAwWVFDQU9adTBMb3ZIN3o1ekNxNTJrWDRza1lWSzYwRFZxV1JjZzBzd09vZThPOVFubUs4VDhNeGZUU0dESmVDTHFRQUFrQUVMRXdBQWdFdndaUXNTMWw4QUFBRGdjTEQ4SHNtM3RqWkcyU2RUMGIwQTNBNU1Xd0FBdUNiZnBwK3hIcTNuVzl2NHlCL0FBZ0FBQUFBQUFBQUFSd09mQ2dBQWdLUDV2YjE4L3hTL3doMHJINC80cEpGLysxOWZjNGVpb1VuQmFnYkdXQ1duQjh3OGtlRmplRFpFTitlcmtPd3Z3aGNtWHRsSjVvWkdCbDY4SitrMDRXOWdJN1FsbmIvY3ZPVjBwcWRydk9lcWdndEFqMVBmUm03KzJSK0xMcDJNR3puZGw0NGFhNlUrWWxSSk1xTmxNSWJJYTBFdHJoSk4yYTY0NkpGSmVodS9yeHBUUWlYWFZKNjNMbFpMekxUdUxJMDF3c2c1WWhyTkVSWTgxM1YzQ2pXWHZNYU12T2lYVWwvNWlpS3pYSmJzQ1BJZVdCaWlHdUZZaU1FWDRqbmNjeFJycmtiSzJWa2hSOHpiU0NHdlpVWmFieHBONkJESVZvb3JWTW5yS2F1UmZLTjJCT2M4blVIRWpwQWN1QnlTamNzdS9rVjNEbnMzOUhwZHRpVzFUWEYvdnI2eSs2TEsveHVyMHRkYTZCZGkzdUV2QVNUZ0djamRUMkZsdUh0N3h0QUM0QXZodkFSY09FM3ZZYWEvYXZZMG5lV0pBRGVCNjNCOUdjcGptUWhlTTRKTDV6RWpwSEJxTGtidjN6THBJdTJZYmZQWmZYVVJvcmZsdFRvanNzN1FoZDQxZ2t0WG1ldE1XVVVJbDNaQmY2ZU81U1o4Skd4UzRkYjhwWThFcEJ1dGZQRG04UU1qUWl2YUlySVRuTG4yUjh2aTVIalNjZktxSUM4N2Q3SnpxeWJqUnV1UmU2SWhwNU5rYXZOYnloZHA2MUU3Y3ZkRlZHRWZuSlBkWDdXZDdxamt6bDhwMnJadUZPNTVVbnY1QkFSbEV0YklVU05pV3h1K0xIcjlQeU9kVlY0a241YWZpOWI4T0xSNCtxeW52Y1AvWHJadE9FM25HY0RlOFdpbEU3dDNmTHpMckpRTndBZXh3dEN3RnZ0cXBBdUtqdGlJMWtwQjAybXlQSFdaQmFkR0kzdVhxVWlWc0paeXlhaXpLaDgxRVFDNE9wenp3VE9oQitaQUU2cXdjbm8xNDFvaXVrZjdPRncyZWltcWo5Y3JXeG9BMEx0aHZQNUlHbDZFZUk1WjNSSzFiU0t5VGgweVZxTjZuTUdjeklnUzhqaEx2MDZwblkveXhWUm9PUUFBQUFBQUFPNEJiUGZQQnYxN0hHaHJBQUFBVitESTllaGIxNzR6N3Z1OHRwN3hzbTJXUTUvNXdKUURBQUJ3SmJBdUFRQVNRSFdBVHdEakdId21HTmtBQUFBQUFMY0hKaDBBQUZ3VDZPZmJVLy85bi8reTc0YlFIeW4vNDUvbzdSMlJJNEFBT0JMdVZCZlA2UUFUaTlXNDVWVHhubzZpNUxFT1BYbEZRb2VBS0o3ajQ0QVBZVzJuSjJqWDNSOThPbTh4ZjBEM1haSGd1WWVhVmIwN01kZDdGQ0ZIZHJId25veWNPZk9jQytka2wxeVptNjRncDBzSFA0ZjJQRW02OGNLTGZEOFJZMkNiMWxmRDJwVTAwcitSVWtjTmo1bWFLOXJHSlZHMjUvZ3RoMHhyQ2owdk1wL3FzNzZNV29XRjUwTVdrZEg5aEtXMVhkdWt5TDVwMW9sdU1BTEFSWWdNNXhsV3hDeGFZTjcyYXJTTkxMZU5DRDkxSG8rc2pWa1pNMjU0bGdNa1VwZHNXM25LbUdSbnBHM3lmYTVhMXZDZU8rL1MvbjZsVmFoeTI2U3QzWDh2dXZSaFhRWWZpS1Fib3FadEtmYlU4T3lvWjYwQVhEbFNIUUJnaVM3UEZNK2trZEpHRjJwcGNrWHlyRElPd0REUnZkaUl2cDZ4ZS9DV05aTXBPeERCWFZlbERTOHAwL1I0TjBadVVkYkdUdERNZnBHSXJyOWVELytLc2pVNTBiSkhaYzk2aWxJUytiajhXUm1XN05GNmZlVVRqVC83NEY2U01FZzhYMFRkeWQ3OGxURTR2SzBiTVhJTVpTbmluVjFhV1I5QUZSWVg2cmhrRi8zR3kzaUpJUDdKalFCU2hqbHpMZTBQQUJnaXVoQjUxUG1KMHpTcnJhT3JEeGMvZXR1WlZTaTdFcktDcE1KbllTMi9BSUF0M2cxdzFVVkVkSWQzcjVtMTZEUjlCVXN2Z2VXZ2kyN2RRSnBSSDRtV1g1dkhJOHp5dlJ6R3FBTjZabGxhUHE0T21HdW44cXNBQUFBQUFBQUFRSnB2MmRGaDU3b2V0REg0UURDc3dRZUI0UXptZzFFRkFBQUFBQUJBRkZqUkFOd1h6RjhBQUFBQWdQc0NXdzRBY0JlZ3J3QUFReHlwUktDd1BvYmZVc1R6QjhqbzZ3N3JtSWdQTzdBTjNKaitCSUhNRWVialNRK1JNeFZyZm50T1pRZ2VKZFBjZ1FDQTB3am9VRS9TNmhNRkxvZFRzVy9XQ3RLajRRN09IZ2VrMFlMWEdablJkTTc4Rzl0bXJGMzByNUhtNnZrMkFVYnExam9KbWY1ZjJYK3I4bWRrWmNzOGVHZWJIYWZ1VDIrUDZwaDdvNTN2M20rRGxxeTdFV2ZKNm1FTndHUzAxV2VGRmVHbGhTUGsrRFp0NmJ1U0hnNDZJMVFacTlLdmtoR1ZjMlpIclZ3VTNndlR6enh1WFdobFU1Y1NPTXkwU1VlTnZoZkZ2V21pTDVhWFh2cXdMb01iSTgxVzZib3c4WU83ZDFibUxGa0FUR2ZWOGh6WkwxcWZMTkEyd0pac2I1bmdkS3pUK0ZlNElxSnBWK1EvdWl4cFB4aDJ4OVh0ZFUzTXFkYkpzYjUwTW92UlhkK281M3NHWjlnUVJ6NUZXWlYvbGV4ZUwzM2RFNDM2M252VDhIMlpzVklyeWYzOHI2NXFabHJ4RWUvZ0tsK1UxOHQvSTB6ZnlqTU5zemhRR1RYYkp0RVZCMFlqQU5PWnZWaWVQRTJ6NjZwM2EycHRlMWVzUXBKdEUvV3hwUW8vQXEzeFAyalpCV0NZaEc4dDZ0Zng3aldiRUphWnJtZXFuOXR6NXNzU1lJUFhqckR5VTd3MndNd3lMVTVibHUvbTlBV1g0ZkhEVkg0YVZmUzJEK2xiNldnK2NDYldVOHhtaEpQcmlGdnkxa05mczlxajg1cklxVUxibWpLNmRMVStMcUZmZ01aSFRNYVRFRjRFcXVSRkEwMUgvcDJualJYRHFoaEQvWUpUU1d6dnpMVWlJdFA3Z05BYVJkSHJaNWhtU0JTSGpDaEc0d2xGdkorLy92elIycEd6eC9lVzREdVZWVGY2S2dlTjIwcUwxVTNMRnpVY1IvQWFWRkh0YU4zZkNFUzIrT1NKTGhaTzBaSG1rTUkvWk5HUVJyMDNieXZiSnRWTWUxVlFOazEyZUFOd0lTUkh1MWY3am1ockR0ZVVxaVN0NWU5ZzR2N2U5K0Z6MGxJYVdhMm81WnU5RG1mc2l5d0R6aFIzVzlQN25ZRTBxNHBRWm1iMWUrYjd1ZDZHL3JtZWVUOC9VbXQ5L2hpVk9yOTZlL3k5RXRNNjdFYVNaRVpGcGtGMmZjVzZETDZBckNmaUR5c2ZtSHUxOVV6TkNVNWdaVWRaZzhocndvd01NbXVwNTlKYk1xMjgyZlNZTEpmR08zU2tjSytuc0REcG81YjdLdThreC9Dd1BYS3hjSlRsVlJsUjlUV3lJenZUQTl5bjcrdVE4UzFvZHNRS3ovZU1kanZEbHZHMmJUSFM5ZkYzZktKUjYvWjVFdDJUMXJxVjVERTNmb1M4bndLOXloQnE4OXduUCtNcmlhVmx0eUxwak1oTXAzbG9pMGthU21vQnVWYmpIRkZHS2V5RC9XZjRwaXBOenIrSjlzN29WdDR2LzVBMmpmN3cxRXlmc1FJV3Rqa0FuNERYb2FIbEx5Vm03TkM0RS9CNjJaOUViWnpvcldrcmhOZWU1dUtrYXl2OFVLd2I5S1l2Skh6eHNndkFhVWliRFN1ZEZlNG9VcnEycW1JeE1sMHh6UWZJUHRRQXl4ajFSWEF5c203NHFPM3p6Q3Z0eEQrYTJmWXp1QVMvb2YwbTBKeGhBQnlKdFpHMHdzbTFadzM0aUdIdjhka0tOL295YUl6NGtZWnFIOUhJWURrWUovTXhkT1FtaW50MlZmWVBaN2xIZk53MU9BT3Y5L1lvV3ZCNlZMNFVwb1ZuMDQzbTZiT2ZNWHRXV0VlckxLNldpRnZScHRreE5GS1hsZU9XeVI5MW5nUkVZL3Z1UTF0bjAzQjlrQjJtV096QnhhRzJxMFowR21SZVJKZ21VL0hxTnk1K09iTmJxMDFLRThtWHNTK09ZTlNPeU80SHBFRVdtVlZlOU4zbE83UXlKWk5GVGZyaVJwUExic3FRcU4zOXVuWEprZWJvR1dVQWNGRTA3VFJ6YWlRZlNVekxEMDVtWmNjSXRsMG9IM2R0aFQreEpzL015WlV4SStCTCtBaW9uaDYxNkdjTXl4WGV2ZXgwRGxjaWs4ZDR3MTVVSVV5amMyMFM2Wk5zbTVZSjZTS01qcW5NYnZsb08ySkd1NTFodTJUYTlneVpWcjdSTGFSOXdPazJYbjNPKzRwb1JFTGJpZ29wdHlhV3ZXZkVvZFVVV1Uwb3kxY3J1WXlMTWZ3NTdaSkVXZDJENDdPWVArdGVZUXl1bEEzQURUakxrS2lHek1WVGN2YWFyNW5kbzE3MnFLM3dNZHBNVXM4ZS84WUJZd2lBMC9BcXNKdk5BWSt1aStoTXFBQUhvellBbU1ZcVgwU0dVZFB1ZHN2d0ZaeGltSHVYNUxjZVhiZC9mbnNuU2orSjk3UUwyZytjUldTY09rWDF0RUNSRTZzeW44aUtMcVVOM2hqWEh2UkFScWdPNEtJNjR6Q1k0bGlLSzZEWXNtYkVwWFhuMTVEWitnVjdUblFNVTNkUnk1Y2hGaW85cUp6SkROa1BHVlgzcHU5UHV0NWVyeUR5VXdYdXFrMXA4eXRwQzgrVGp0bmplUVdXNWxidTA3MytDdmN0Zmpic3V4Z3h1eVU3ZW5pa3RUTFBTTWNpRHk1TU5jS1AzTytMdXNCYWdPdm1uNSs2a2JCWCtETUwzWk5IMWZFaDg5cXp6bVpsM3NHT09OS0dMVWJaV3Bwc3VQZithZGplcnVwcjY5blJtTnZmbDEzTnhkRzVRMHFiYWVwWWR0YUtLWEpGWUVjQUJ1L2VOSkluT3RTMEthaTlZTGhxS0srVURSNTRHL2tNZzFHS24yRkdlTi9xcW9Vdksyc2FlTENNZG5BYitwOEdIZEY5dkZVWm55S2pGdnZmKyszM2JpM3dpTVpyc2djV29wZkk2RHp1T3ZEMVVUeW15Tlg5YTVuUEkvSTRWcXp4WjVpK3M1NW9TTFpRTDN0MHpoekJpbTFXNUQ1WDJYVHZyZXRqSDEzbFRlWmpSN3dKYlltSkhGdnErYktsZE9QaHo3am15SE1GdzRLTW9xWFBWV3JaRnRuWTZOY2ZUYXRUVURQamVSRUE5OE83eUZuMnBWZlZIcjF4Q0JLMUl4cHpUYmZXMlNhVzRqOFc3eDdHaWdQZ0xnVDMrMXoyUHpURGpPWjBTM1RQTXRzdnI4bVFyb0VENzBPTlZadFdFTjA5dWVXZDNWMGZOVCtseWc5c2c0ZkxCcWZ3MjUwU0NoT0FlNEs1ZXpqZVovMjdkUFg5NzlPbmpPNERRNnd5NXNDaC9seDAzUlVJOW5iRzJYQ0pqcjdvazRvUGdQUHpieCtnMUVrL1RyMEtYenFXUEE5MHBEelpjQ3dTS3B3NkhtNnlxZ2dIQUJ4Q0MwYXdYNmxwWmZ0eHlNZlMxYVM4WG02cEYrNitabitiM1dIZDc3cTJlSldzdmFOcVZDOWpMZ0VBcmsxa1hrc3FZdlh5Q2RNZG5BWVdQRENJdzd6NlhMS0tPNVB2aUlVSWdKdERkZEhuMlZmTmlCTW04cENpOXY2VXhwTTJtaTd5S3hXdHJNekRFRytlUk9NZU1TaWp6M1F5c3JMcDNHaU9IUURBTGJuNHhtSFVKN3p5dG02NzN4cmRMMEhsQThBeVlwNXBaaUttM0kzSnZyc0ZmVHVON2Z1Vjg3Wkh2U3pNVXdEbThKdi95YjdoZ0tBK3FtL0gwa1pTa3dLd0V1NUVqbEttalVYTE5kOFg2Y2x6ZWJTMjdINVEramRZK21XcWNDaGlaWFRJNjhlcDBCMGdnemI1OENaV0R1WVExT3lHWktjRGpQVG9yak9Zc05YY25Zejd2TFk4RDVFZXA3S2FFUzdsNCtLOFJBMk1TSHJ5NnhHeWtPNitpTHJQdFVtM2wvN01wNzFWYjlXdHBlSmJWL0t6SHRLUFUzL0NlMW5XQ3dNempiNlIrOHora3FjYTE5NzhWcnBuV3M3STQ5SmFza2l3VzQwUUdmMUM4L2VhM0Q5T3hQNExOeXFzVVNxbGNZKzRHaEF1RFNWSlhRTndVVFR0UG1NNHI5cWFpQjlxYkdWN0VOVGpPdlhFUVZ3eVpxekRsZ3phQzFwNmJxM1RGTlpNTzhMQ3NsV0xFRjZOT08xK1MwSzJsczZxNndqVlVROTZ0MVdWMUdpbTF4Q3FPMWw5L050dUprTzlNVFVTdGorU3oydzNYeVBkNVEyZnNmVXFpdXlaMHlVeUJXRkhnQUV5bW5KbTJlN3Rra0JtdFRyNlBtK0QxSmlScmJtMERFdnBvblh5MUdYVW5TVmRTMndXUldjZXEyeXVEQzArVWhhNE5kVzRqbHF5a1RTUmFmZzNYTEQ1aXBIdkdkZVVzaU95SW5WU2hVdGxWRjlkYW1jYlMyMXJWU0dyT2lObFJXUnA0VFBLaU80U1o1WTlJejExRlhxWEdlLzlSdVpRSks4bnZvK3JScG5SWlRaU3RvWDBEUFpWTm5tK0pPcXJ5dFdnYnE3S1JtWmo3dSs1cWQ3R1BGUHUwb21jYWIxTGFNNjA2Q3pUcUlaTTQxcDZNYWVOK0k0RTJSUTZpRGJwamZKMlZTSUQydFNpMGpWWGlMWGlhdmtCQUNLVzRTeWw4K1N2ekRVbmd4QzF2NHBTWkRTZVMyK1ZTZE5Tb2syc2tkV0ViaktONzMzVWtmVkZ0TEx3aGdHWVJGUlphSnR2Ymc3MDRkYW1KY25JbEl2Y05oZk95WkJ1OCt2VndZb3R6QlcyYlI5RVA0ZWk0MXViMXYwY1dyazBSaDVwbkRJZkpWdlVteSt4cFE1amJYODkrV0Q3ak9IWW0vaS9tTm9EaFFuQTljRThuY3RUZWE1WW1MRFpCeXV4bnMrQUtmUXZ1QU53TEYreWdDeFloLzg4L0s4bnRSOTFiSUFQUi9JR2UxaitKQXhNWTZTZkFiZ29WeHZXMGJwd0x3KzN4NytpWGVFdEJQUDlCbnpINHZrZXppZmM3MHBmMmJlQzlnUUhjZVQwbGQ2WEhDR3lER1BKL2tDOGcvZElmUXJkRFc3SWt2MWVrNFBQbmlhYlp6Z0hMUTVIM2pmTXlPOEEvVHlERVFWZy8rU2xxdW10c2pOdmNxNVFhSjVmdmRSaXYvVi9BVlkyMTR6dTFEakVNUXZIRGdDM1ljSjB0VmV4ZU42SWpFaTZqOU5PbWNZZlhjT3NaUm1xSDRDbDlEK2dnMy82Qmh6WlNSZmNOdDJGN0ZKSXI2WGRiU1ZwWjNiUkZSOXBmQTNZOXM1RCt6WDFJKzczTmtUSmdSVVNnUHZnZWRQRGVWS0JGaTI5VkdMdGpaMUZYNDhxWEpNYkViOENVYmJwTitJOERnSG9ZQkFsTTJadU8wSFB4L3ZqVlB5QTlVdXA1SThwNDhDN1k3TE9rYlR5UnM1WEs4NnlIRWZvMEhqeTVjZ3EzRll6SjlsYkR2MUM2WitUcmR2bXRHS3Z0Yk9yQlZzaURXdHNXdjdMcVpKcy8xTUZxNjA5WlVYamkxS205UVFtNmhISUhOOWxXYTBUNFlaU2t4TDJkV2w4dUhZYXR6WnRiN29HaldpckxDbVR5SEt0Y09uRGhRQndMQ05XaENZdk1sVkswVmZqMTdWUTJjcVpYOUZsUmlwOFY0aW1wMmV0djFJNmoxSVp0U05tS3E2c3N2VGMzeW83b2pyS2ptSzFzWFM5bDlDbjI0NDhha2ZYWFJwT3NzdUNyOHlkTTAwaDFwNUVoTDZnYWswcDczQWRHZFlyMW5EWUJlQWdza3RoSnY5b1dWVE9iTHYvOUdsMzVyN0F1OFJuL2N3anVqV3k3SG9IMmFnclF0cHJlL0xVWUw1WkV3ZDhQQ05EUmZKOGx1THo0a1hLNXJaUXZhMFhWVCt0azdNSlYvVE83aG1PY1FQZS9YQmtCOGJKYmtHWjBiSzBzdnQ4NG5iWG1XNmtUbGI2R1V2bDZCTU5yenpPQ3pDNnhHdStGRnJHbkNjYXNiVFdrai9xaWZDVThaTGQzdWs1WWJ2M04wUTlzTTI0YTlOZWZ6MzNzOGF1ZW4vZlJ5NzJtWkdRTlZiKzkvajNGNUdadVY5cEZrMGMyV0diMWRDV3IyaFAyVjNoVFpEVmRwSDdkRVBBNkFUQVpJYnYwR3RRYVNyVHUwZDJUbXRQbGNJcTBsbVdGZDdIalpZMTBuMkhJbTNHUE9tejVRQndkU0liUks5WmFHMklnenFVaXVIaVJwOVljbVZvWVZxNFZNYUl4ZjZSV0F1VVorRkNZeTVuNWhyUExjT3R6TzFHeTVkeTZwREpOdUlSQmxiMG1VM1VqZ1p6ZUxUeEwzZUd5MXZuQUlBWEU1V285VUFnYUpPRDhuYWQwLy9UTkFDY0FqY2dnY2lNSDVuU0p0ZDBBN2doVWdlSE9YT2xYVkcyNVVIOFRBdURkbjhWMHN3dmxRUFcyektzanMwMGZVU1hZUEVRa2JwbWlwb0dBQ3hsWk5WaTUvVnNMLzlPbWJRVGxBbTBGL2hEN2Y1N2ZhUjFGK3N4QU1kaVBRTTRza3dBTGcxZU1BSWZpT1NGWFQ2OHp6RDJwSDBnREU4d0FONlptTTgxbm1qd3U5SlhQNnNkZnVjZGJVUTVSdS94Q3UzU1hFSERSYVIrNkpxTEJnQWN3TmwySzBjMS9uVVdZVDBmWFgzclYxb3hMNk51UjM0WW9qbmE2ZjhCdURNWEhNUFlEMzRvSTg0eTZOdmx6SGpYUy91TjhSSHpHYm9EM0I0eWlYNnpvZXg1Q0k1aGY1c2paaVp6dXlOMndGY3d1bEoxNHpsNkZtS1ZSVzMrdlNYY1EwdmhCbmZ0WnVpSXY1cFdlbmNWZWdXQVM5Ri9BSWs3WFJkZlJRVXkxSEFrbDl5bnZxVFR0a1FiM2pzQU9adGZTeHNaMko2NmVGOHZlSmJkaGt2OG02NmJ2N3NhTmV0eGkyVDR4OXIrWjNmMS90RkEyN2xLaXFQTUlxU0x4SG43TlRKV3BQVGFuak5TZDZudFBVVHZOOWkvVlRoTHRoOVhablhiVmxZVERFelhhZHZsOWpia2l1cGJweitteTdSVUtIY05ld0hjR0d0bFdESE1hL0phL0ZGcUs5dDl2ZmJrZ2FyaG5YRHBpWDh2cTRsUk9iZzcxT3lJakswd282TGVOWjlMeitYeDJpWE5rU2ZxOGZMV3Z4blhuQ3hyQkV0MWxSMVZid250Y1YwMzE3U01SdkpwSlVtWTVvZFhPVER4dTcxMmRtaU1zTmljbkZMMnAvR3Q5MzBDa1ozVkgyYnNqcDNMNytkenhvM09mR2dqdVcxbTYrbVIvSkhsTkZxUDJla0JXRVJOeEZsVHhySnN0ZkJkbk9CQ0U3MmF0YkIxa2I1K0tINHBsZHNma3FnczJqMTRQWjRyMWx2djdrOHF3MU1Icm9rOU1tYmM5eG5tWXhYcWNFUTlXdkE2aTdZTU55TlBZdnVueW5UZEUxRUdsVGgyOXU1MXZyWWJ2VlMzcGYvVlcxU01zditQbVFUV0xKTFNSN1ZFRmNJVTVmZ0twL0UwbmZUbDFBaWpHc3VUMS9LZEdZWno1TlBkSWxMWmpTOWoxODhsR0E4QUNPTlJweG4zZXhXdW40WUVwOTZxa1ZjUmVUYldQbUdHTEs5ZGNxaUd6QmhGVVZNZ1dxYTB4QU53RjdKK3haMFRRUWczeEVUaklrVGRsQjRMMXFyYng2Z0RiZVBLcGZNMDBPekdnKzROTTdvN2x0QjJ2ZGx1OGc1QkxRL05lK2toTTlOaDZiRmRDcE1lYzJvZGtjbjA2TS9mWlNaWDJNR2NDUXgyY0VXeXE5TzN6MmNKeTVrMENKb2RETUZ0bmpHb2JnTzY2c3R4UDZpdzNFb3IrUXlsOHVmSHA3V2ViN1RIV3ZKdW00d3JiNHhXanVQQWZWdU9sQm5ONTMwUzkwR2NxcVhPVk04QTNJaVJGVUpTa2RZTHF6dnF1eUpSbmRGRzlQVHBlaGdieEMxSDJjL1BmMWZaUjc1K3JRTmxoMnN1UFVneXlyQ1NZdlFDY0E5bWFEdnZjK2NaUUxkOEVkaWJBWEJaaGg1cFdSdEZUOTdGUk8vcnZGM0RHajUxSjNxa0Ivd0szblp2SGE2ejNJWTlQbnp3WXdEWHFrWUw5eDM1OVFrWEY5R08yVmtXY1hSSmRZcStnVHJ6SWNpRkdGVjB6eE1hNnF4WG9nRUFIOFdBZS9rS2R0algrMTVtbnMzZ2piZkE4Z0xBeC9MVjA5dXJHNk9uR25obFFiY3VZYllkY1NlNzVIWkQ2Z29PTERDUHhHVDVyVHVIOEVqV0JUMnRTRXJqT1pvQ2dKbG9ZODRLYjdiSTBaZEJSdzVMT0JXcG9zNGJyMEwrSnFSVkQxV0VEZ0VXM0RqRWVCbm1PUys1UTFCZmNjVi8rRXNwOWg1WFV1bm96b3V6ZTM3NENCQVhQN3JTY2l1dmR3Zm45WnhZRDc5cDJaelJHNUVwcFcra0RDa3REU2NUa2l5Y1hIQnpuMWdzelRMTFM4VzN4N2JHcmVnbFZhRkc5WkhiMjhaYS9hMEgzUFRGZ2dqUnB5V2pMeTFFWCsrS2pQdUliR3Rza0tEWHNlcVJNVm02cWpWeVhUNkNrZEY5NnN0K2xyRE1ZZy9BeFduT2NNMTFWaFB5UnVHL2FqR3pnTWUvcVVJRVhiOWo1UTVDa21HdGtWeDR0QkZXMkJBK1cwM09WeE5sV1hZV1RWOFM2U1ViZmR2UDlFZXAxSjU4WCs5TEtFTFlwc1Rlem40T1gydmJVMGc2b2RrMjhaM1p6MjZmdExDTlVLa3l6dncwanlmOXpLM1pKL0F0OTMybWpSY3MyK04rcmlUZ09XOGowOUQwZFF0bFMzSWpRMm1YaDlSRjhrVGNkZ2g2dDcwUmVYMCt5N2liNFlydzVwZlNhV1ZZOGRvQ1pobXZWbGtBbkVSbUNtV21td296cHppVndLcVc2cXVMUjMvL0xjTlIrWmxyUVhRbkp0VmhwRTVXSFNLcWtMdlc4a3FxMDVLWnVXOTE3MExDdFh6RmtaN2ZnUlh2RTQwUUVlOXhkbnhZNVVYYmlJYUg5NGRNMlZYSTgwb25WTkt0QTVtRXN2NzVhVzFyN216VGN5bkYycFQ5dnQvQ01yU3k5QjREYjUxbWFqQkx0aEJ2K3RiNkxJMU01THAzUnZSbDdrUWFaV2dEbktaNUJ3aGx6T3JYQ0dlV0RjQUZvU293WTBqMDRacnhWSlN3aVl6YW1UM21taStFUzdLOS9tb3UvSkxhSyt1SExrbyt5eEFENEZ1WXRTSFNneStEdGMrVmxwbXZJYm9GSzB6NlNLUFI3UklJTVhuNlR2ZXBjWGxwZUVTMnNaczlkd2g1Rzh2enZNaktLMTFiSFdqWjAyQStEcDA2OTR1cEFJQnJvYTNVMFhBaWNvWHVYaVgzYkt3TlFCOU9mZDBBRE1OTnJLd1ZEeTRIdXZHR1dKdXFTNEpWZnpiZUYxVkt1ZW1RQ2ZQaFk0RWEwUDBBbUd5cmZ3c3pOTWpveTJnQWdCaWo4NWJid2tTdjFiak1nNmlSK0JsbFhKSXIyWGhuYm56UGJBTnFjS3lyeTZ1RjF4ZTErVEViMXVnUDRMdTNnNWRFMHBoSGROT0l0cDc1bzQ3djJIdFBSSnJIM0w2WGkxOVJkaEhLbmptUUxUODdkQnNBT3MvZjlwU0VucDJwbUE5YTlLaTZ3cU01QU1ZNFk1bmRsamxxTWM2MFhyMzVxaEV2a1htb2NVRkczZ3FldlVGb2pCRzdmRytNelRjQXdNK0ltanY3c2ZiSGFEcVBMd1ViQ2dER0NTZ042NGRqNE9MTWVsNFBQWHdJdzFzdWN1MmRwNWpQQURoeFROTGZjRVJNSlBNbUt4WXBzSnFhakZkT1BMRHNMSytQMXBQMzBuaFZaK0NtNnU2UGViTEJGeUN0US9oeDZuUjJUZDIxNWZPRldXL3paaDhKZ3J2eWZQdm0wZlAwODd2MFpiYlFRSkNPQWlwQ2VCWGlJMGd5UFhVWWZSMTBHOTUyWDBxdG0vQktUbnpvMC8rSmUxODJzWXlaWjJCNVRMVG1sTFhQNmNWcWE4VWdUS1hyMDNxeGpzQ0tjTVNMSWdMaU9oeXhsSm53T21DMDAzUVhXbmdrazBiVElGN05Obk0wczFnUERMVThNL3JpZ3YwSnZnT1BUY3V0TWswSjk1WXhES2RDS3pITEJEdmlaVys4STRpZ0lwZlZPd0NhMWxKQldEMHd1anVodEdUY0NGbGJsV3YwRlRaQmRlYUxPdXFrYTJuMmFOYzB0Z3JoV3l3em90Rk0zWDVZL0hJcUthUWExOCt3L21NbHRLS1M3dGdocmJ0MEs4UGx5MjFWOXF4WXI2TXlaNXJaR2I3QlZsblp0cGJNUkZuVktmdmx4dENUcVhuTnNsOFo5UFRaSGF3LzBXSkd0OXhhL3V6OVJScFIwTWM3V1ZFNWtuNlM4clRpMStWZUlrdnFhRmtBSElUWE5lR1NGYlFqcWlDamY0NnlzOXdGKzFLc0V5UC9iMWE2SGVobFZWNEc5ZkI2YjVjTDU5UVRVeVd6ck9Lc0UwM0hYVXRwbyt1cXQxMmFJMjl4bHVGSlM5Tjc3MnZFdlBMY3N5V0RxNFBMcFZEbTNHOUVCMmhvL1UzVFZDRnpaR21sdG1tbDRWVkl2M3QreEtkL1MvVzNVQlZEWnJVeUp6dWEzakxrdURpcEhhcHhMYVVmYUpkZFZzRWZON0o1S2QwZ2FuM21rZjdzWlQ2MGZ5c2xmbUs5ZHpWNHhvMFlySjZ4QXNDSGtOa1A5M2t6Um8vWGlPaGxPZkd1dnhsdEZsc1piYmRCeHIxaHlid0VtU1dEMnpBVVJnN1VNdmhHZ3I2SVY1cFdpdlpjcVpTNU9qS0tkOCttM1M2OVRTcmo0MVdHZDJIS09uaGEwZlV6dUJXWnJ2T2FjdDd5ajlBdFEwUXJPT09HdlBPUmhrdlg0QlIrRlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJ6OC92bEhPbHFXTUhMd0YvRDlHaHR0QzJiQ25kRGhQVEdteVNJc29DcWNDQ2QwL2x3VVBTczltQkVBRHU5UnVpQU9QVUdyTzMyN0JlZWxOem1uVzZYRDhjQ0ZrVDRGSkIzVHZrbGJqSTZXamdKcTVOOGlYRnZoa2JRakkxSTZONTVMOXk1cmYvSTFILzdLdlptM2pjVFZuWnkrTEQ4ZUF5dzdreVVsN3owR0xuTGNhL1Jjd0tySXM0NlFkUnFwWnRuZWR1QmtSNC9obWtBVnl0aFZvUnU0YkFMQ2h5d09sblo3aG5FakxIcVNiZ1IySm1sVE9qcmtNbnhJbjRQclFvZHRkSVh3cE0wTzQ4ekpzWnVFYWgzYU52eWxqdHRlc0M3SVBKMTNKNnNKQWRKblAxd05tTFVqc2tkODAzSTBtWm9kb2VWN2htbU5PK3YrT0xuaERoV3c1R2l5ajZPdjVhNDE2ajZkMlNYQ0xYRDc2ODBYamJ0bWJjSVFFVnMrc3c1SFRmZVphN3pGaUhNaGtyK1hrY2w3UmJRdDUycjdMRnZHQ25VdHlhYkxUMWxYOU4rNTdKQ1ZzU0ZxV2RNVkxpVGhVbHZUK0V6RkxOZEtkaDVyU3lDWFJpdlRxb09WM2dvSEFJVFFwdExMYlBJcVptS0h1U0F5Tmw4N3JJekthRUoyUlpmVTd0cGFFelJSa2hscFdmS2VuVXZXUkd1QnVPaHV4eXZYa3RjY2VhVTI5Y2dlYlN0dm5hUTAyckxybFJVSjl5Ni9VVFBDR3VkOUdBMzN5cGJ5YXZHMWExU1hPVkwxNjMyNE5uTzVta1ptZEdRa1cxU2hidGJNOWZvaVBMSm91a2o5TStrWnpOdXhOSGlrTEVOVFN5OEdWR05NUFJlbC91VUNibWh0L3ZBYXhGa0RtU3M4S3NzN0pnRzRJQU5xS1ozM2dLbml0UVVuYUdmUmpwRFE2c1pwTnMzRzhicWRwelM1cUs5SjRaRU5oZFpvSHJPakNMSUIrQVNpRzJiUHhIL2tiWlVOVnJQU2RGSHJXYm9OeThmQXFRSk8vbGZpTmYrampWOEV1VnI1MEwvVDhDNjNIamtjbm03TDduWm5wYnNNbHIweFl3dnV0V0V3eDQ0ak1RSHd4VlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0NpL3ZzLy8yVit4N3IvaWVzLy9sazl5Y0FmSXNjbEFuQVUwZU9vRXNkL2VrK2oraHFDcDBEUVV6OGJkQVdZalhaMEV0YW5LZlR6MXBySDBROGN3ZXk2RzR1T0lteVJZN2E4aTNwa3hmWXFDKzI0Uis3YWt0VVUyWStyNTRIQ1FyUGsxdFVqbGVPNzRvMHAwOTlpSTlvaTI3OGpzcTB5WjQrbHdxU1B5Z3plUDN2YjlSRnVuS1pOQjdaNCtyWldWaGtieGhkZWdDS21qTlRML3lQWFdobWFiRmZ6ZUllVWR5OW15UVZnSVpLbE0yTTR6bDU5VFYzaE1hL0NQaFV5a1pmdXhlcm1uekZuUWxicGo5aDJudlNjN0tpeTdNbmF5VkorS2Q0anF3Ums5SEl5OXgwcmVjVHFLbFllYXVJVUh6TjJLbW5oV3ZvVlUyZlZWbVNGNHI0Q00yeldWVzErWnRuZTQ5VDd0SVhrRWRyVzBnM1dGc1pEZUVvNXl2VDYzV2NNcVRUZXdrY1VzMFF6MGtkdElrOWFTOGJZc2dZQW1NQnVtME1qa3ZKZU1vbk8yRHhuMmYzaGw4MWxrOVNUeDdTYnRUT1p1UjFjdVY3TlVyOFJmNTBWdnBLWkhtRm1XTHZ6anJMS3d4ODFJYmc4WWRkS0VZUTZKdEZPeGxSN0l1dUp0aXhvVGthUHg4Q3l0S0RGeUs3N2wwUEdRWXc4VDZGdDlycHQ1N01jR3E3MnU3VG9pUUdDVENuZUswZExBd0J3WVMzKzJVWHhRR2JZSzladFcrbTVPQm92TlhVSmxuMEtXUk1BZ0c5SDI5aDc4bmcyS3c0eHM4bnNFamdaQTdkM2Y3VEZnb1lWUi95b25vWjVmUWlXU29nODZzcDJrM2Ureml6elVMeU42SjB6R2VkZ2NaYUp1YlllNzk2bTRJdXBBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREF5Vy8zejVXNWt3VXVjTkRaSmRFT0crTittbzkyQkVlZ2pjdEErT2JraHN3Qmc5K0VjQ3JBN21UaDFpWHY4bFRqTlBwTlVkYWhqMFk4K0hCd0dzODZTTnZXUVB0YWg3UnFSZlZwTWEydmlqRVlQQ2NIYlRxNFB6SDNlWUx1eUxscEkzaktHejFMc3lteStPTjMzbXRkMjF5THBUd1NOSzZOYVZsTFAyWCt2Ti8zZlZWeWI2MTR2cUZhU1doa1hOQTZjUEhiR3NXWjFYN051STVzeHJ4bDBMWU0za3NWeXFoYUdVSmVxU3RtSEpzbzhhRUxEZFVrejMvL0o2VFhacFM3aWFKSDkybkFBQUEzSTdLU3pIS2RhZk9WVThGcUdaVy9iRkk2K3NYcnVtRFM3amI2VktNOS9teWVuVVRkWm0wajUzeEthWjdwb20weDJuYWUwV1lwWU85WnF4eDdXOC9PMDZmVDZoSlpPRGhKRDd2Wk9QYlVVNG8wVHlkYlZmdWFhaWNnZTd2VnNyZG8rZ2g2MDhhR2hYYjB0ZFlPUmFpRGxyNHE2Ymt5SlRMMzZaR1pHV3lldmZjc1ZiM3lQcU5ZaTJFejBwYjlrdmE2RnJLTmFTWkR5NUU2N1BJeTRaRXZwRHFhWXc3YWZPNExIeGxMMWx5UnlySjBvTGVETTN1YnFCNEhBQnpHYXpwNjExc2pmVFVXanpxZy96UjcwekxOdkRLdDJ5eENPbzVaKzk4K1B5ZFhTaHZabS9mNXRQaElXVXZYMjY1c1Qza2VNMWtyUTdNanJMSG1iUWZQRmtjeTlieEk5MDNuRXIydVJyMktsb1lVcW42ZCtTV3MvandMNnZPMFBwb0luV3BmalBvMW9wdldIdStJSGpFc3ExQVh6bkRNakRKTG0xYkdpQmZLRWdjc0NhQ2JtUmJ3OWpjaVF5cWpTT21lNFZKNmVwSFJsbHpmU1BtcjhEY0FRTVNqUW84d2FnYXhiTmpJaWxFZDhaeE1pejZmSk4rU2VXbk41aDBua3RvRzRGdkpQTlBvbFVYbDl6Q1JJa2ZJV25pUlJ4cGZxeXE4aTBWejVoc0ZPbnNwMHJoM3VpUEY2MmdkdURKb2ZGSFNXZlU3QlVtSFduajBzM2M3SzhtUUZCM20yenFrUHFEUnpNS0tMNlplQVV3T0FBQUFBQUJ3Tzc3TWlLMW4zaTgyREFBQUFMNGJySVFBQUtCd2hwTEU5bWc5V1B3K0cvUXZBQUFBZ1NPWGlHOWJqbkMvSHc3c3F4T0F4Z0lBQUFBQUFNQUNsaXdBNERaQVlZRUI2ci8vODEvbHQ4anZzeHIrOFUvSFNQTWNtZk9KU0VkU1pQSUJjQmJCbzYvNlg3cDcxeUhyN01QYjR6M0tvdW5aTmlLcTd6QklBRUpZeDlyU05FQmtvd3NySDA2aDh6cDdDZzY2NkVNUUY4ZklTY2pSODVpa1N0QTgzcE9UTTNXSjNsOFQwcjNUN2t5WnkwK1M5MzFvMzBPbCtHOUxPb3QwcEdFa0s4NEt0L296VXlmcGZqeVdaalhpbzJYT1FEakJYWWgraDVPVHZpWFIyaFFxZ3V3TG94MSthU0hkL3YrRStDbk5ZaDUzYWZUL0ptMjVWVjk5SnVnRUR4a3J3cFBlSzdzSWRjbXVBQzdoZlFFank0OTUzRGpSVk8yQWRXbTZIV0hiZG5ZZE1uV3lPc0ZyNjJneVBHVkhzT29ncGMrWGJiVzRsTDRJSldzMWl1NGFVcm9sMjRTWkpvK1l4UmFSTFJsWHBwUXV1ODJiTWR4bjNIL1VXSXZVWlhSaGltNlhqaWk3Qk1xS3RybXhGZkZzVmR4MTROSUZaVXRmVHEzZEg1eWZiL2ZGMkdlQ0k1WmZHdTRwMjl1UHhWa1dBQUQ4SVd1WFhCalBQbkhVZ3VmSTdvcTRQSDM4REZOTktrTXF5MnZpY1BIbXRsY29LN01FWnRQMTZibXl0ZnZuekdrcDdTeEd6ZWZvZUkrWUcyNHlBOXJLVzJkczBtWnZrRExHWGpYaXZXVlRHZEd5TlE0MExMTk9CVGFjOUtlMGNURHJKUGpyYXNaWmFHa1JtbWUwcmJteXNGRUFnR1d5L3laajgxeVI2b3lQdXZFODdxdFR0Tk9zL1pGMzQ4Q2xoMW9HMzREWDVwdFkxQ3haSHV2S0k2ZkhVZ0ZMOW1oWFlmSXpqU1BHRkppSGR6ZHNkYnRWeGt6NzZ6WkR5V3BjajNHbXljMDRTYmw0TUpkUlcxWlprQnhmVEVYUExnTk5Dd0RJQU4wQndPMnBtTWZnbzhDQUJnQUE4RzFnN1FQZy9tQWVId1ZhR2dBUTRreWxBWVVGQUFCZkQ1YUM0OENTRHdBQUd0QlVBQUFBQUFBQUFBQytBR3gvUDRiNjcvLzhYL0tiVi81bngvLzRWN25mY1R4bllSMWtwbDFUN25vVUVyZ2VpNDdYaWg3ZVpPV3htSDB5eFJLaUJ4TVNuZENVQXhuL1h0TThwZVJPb0FmZncrcGppTUdMN0JkVSt6UlMwM05kNGVsT2ROM05NVHQ4WkNWZXNWTFB4SHZHVzB4ZWUweTJTazRwMXVkcGZlWFRaTCtKSHRPOEQ2MkdJZEhJWDgvMExhUkZTaGQzVkw5N1Q0RG0wcGN5NTh6K1dmZnJyVnVpek5kdGtQdWk0VE9Odnh1dCtkWVdtMHRIc1c3M2xQWFZNM3dwMlJQY1llVGRoUHRaYzFldTdiZ1YwVTlUdXU1SyticDBvZ25HYUM1SnNaVjkwbjJoeGhyWW1QQ2RMdkhhRVVmcWtzenh0dGxqUG5VN2JJMGRJY24yM2w4RzcvMXVVeGVoSmpOSFFYUmtoY3FPM2ZZK255ZXZaWkxUZEVWSXorWFI4bnZLME1yeTR2VXRXWFhJeU9iU1o4b2FxV05VcHRXdm5pMWF0Rit0ZEZ3WmcyVWZZY29lc3RvOHQxclA2MmZaQTRXTHkyeGZFSnRSU0RPcS9nRUF3Q0w2SE1tYmJxVnB1NUNvK2VpOVBjOXlPOXVjSERIaFZwWmRITElpOFdkaDlYTldYc1RPMHJ6dnk0azJnS1VqTXR2OUpUZWFIY2tlZVpMTTJhTkprNnZWWVliQ2ZzcDRmamZqZjBrNVhGVldQQ2NSTmltU3Y2MUo2U0tiTWU5enN4WE9pQXN2d0FDc1lxVWhrZlNwaUw2SU1sYVZqTXlaSm51MHpDaVgwV1plLzAxMlh3UzFEY0FQRWVWSTlQSHJuV3NtMlZYdzdvTWx2bHBWSk5kZk1UMlhEL3AzQ3RHdXljak15dEIyWW4xNEtYRi9sZVV6TzV6bzg4RlZIUlZwWk16QjgvRG95QWVPTDZhQzVXQ3lBQUFBQUFDQUZOOW1TSjUzdnhXZk9qNEF0REVBQUlCdjU4eTFFT3N3QUxjREt1T3pRZjkrQjJockFBQUFBQ3ppRW1ZR2JCMEFCc0VrQXVCMllOb2VCcG9hQUFBQUFHQXlNTERBQU1ZWFU5OC9mZjdIUDVtUmxqMWE1OVB4L0d3ZWdLdmpQUTNCMENCOVdQYTBDS0dvNjJFZE9FaHUwSFVRRm5NNElsUUtHTVp6QUNlWXdvd0RXcjBIZldYeWdSTjVEZzc2WTBleDQwYk9UUEllTiswOUFzeHpqcHgxOXBPVm5pdHJ6cmxUL0VISDJ5K2liazdMQzAybXpIM0daRFczakpHeXM2eTA1cnpqdFpCMEk1eXh3UlhLTktldFlHaHUwaFRkNEtTVFk4VnA0d2RiOVI3TmFkVW1jZUJtVjFZTnpObGs0ZE81cW1QblNqdENPSHBHbUttZFpabmJOYk5TVzZEd012bHdmZjFOenhoTkgxdDJoSGRONlBWM2VOaGV5WTZZb1plaTluTWhaV2JhdzF1bTJhRVRtQ1BUMmdWRXpJL1plSFlzZlh3cEUrcVZNVFN5M2F5Vk5icjFrSTdwSFJubUkyWFBacVk2eXc0dTcvWlhpNCtXR1NGcjJoajN0UmxTbFN4TDVOcVU2V3pibDZ1RnBLRmxVL0dGaWFkdUcybGJwTVZidmdYcHBQNGR3WFlJc1dMWkFRQWNnM1A3WU9hamNTUHJVTVNrLzJDOWt6SFBacW40VFBkRjg5SDhvMlpFcEYyODVyVEh0STJhMVpteW9tVjc0N2swWG1hYUVkUEo3SStpZVU5bDlBYVA4RVgwWWFNRURFMXhnNkNrLzF1RThFeUQrdEQyQW9xUmdKRXBRZTV6VnlldHpLcklrK0taTWxVWmtiSUJBQnNzdTdrdzhUVXVpb3YzYUNuTnpzallWNFdFZTZqT01xTDVLWmZWWHBIOWo1WWZnRy9CMmlDdGVLWlIxY3NkbHBVVnJXcUdpSXNjYWlTSXQzSFIyTXV4bW5pR2U3SVk0WnlNUHYwSWx4OHVxMjdZbWtNZUl4WE14K3V3N09NNWxNbjBWMlJ6ZlRFVlBRMEE4QU9OQVFBQUFBQUFBSkQ1dGgwRGRraWZDZm9WQUFDOFFHT0Nqd0lEK2pOQnZ3SUFBUGh5emx3S3NRd0RBQUFBQUFBQUFBQUFBQURBdmVtK21Lci81Sm45WWlyZ2laNlNNSElNSkFCSDArd29ETk1IM2hPeEJEMGhudVN1bk9BT3dCQVlSOHVJekZIUEtUMWNlZzd2T2FuZ0FraGZVSDNGZDM5YnA5YkloWFFDdEdzTzd1aWNrVG9jZ2M4aTJhNnJ0UXR2bS9EV1BFZjNSWTdGako1aldoOFNHZ25kOWtYYi9hV2RjNW9lVEFKYVdWemF5QW5mTXkzTjBmdGVhZTA2Wlh1VnY2dUppVUY1WTJPZW56bDZmemNqUERLRFpzOG90dEFvUy90ejJSMGZYTWJSWldmVzNmdnpubFBiKzUrcHpyeDFlTXJXeTQ1OThYaS9IcmROdUNoclV5bXZIU0hvN2FJNUNJUTdaajhieDVUMXFnS3hXYWQvVlp2RG81RTFtWndORzYxM3Rtd05yMjFqclVUbmM4aGFlTUd5VmFSaE95cXZSMUtTbWVFcW9kVmZtMXJlNlp4WkNyT3FZcVJkdk50aDc3YXdDUEdSc3IxakxMQWtzTEpHN3B0Wkt0eGZUdTNpZXhtdjZ4Smp5WEpsMUx2TmRMRkV4emNBQUl3eTZyWURHMFlzZU84UzRGbnlzOHRQY2RaQnl4ODE0YVQ0aUdrWHZkOWkxQ0ZEdGcrT21GSm1HUjZidlU4YnRhODV2QTdaRW9oMzN5Z25qRXM3b2h3em95bnFIWnZsaXlqRnYrbWNRSFlNdlc2SDJYek1SdksvRGEyRjBZMXZNUXJMVHFKTVdRQjhNRGUxY1VlWFkyMkZpSzRJMWtvWVhxNnZ5aXcvSlFEZ2gxbG1jeG5mRDgrMDZMMTRsNS9GbHZsNWpQWi9jOGo4K2taZWo3Y2JSL3haa294TVYybTZ3Vk9ISXRSRkM3L1ZrTXJPUzJ0TDZuVkY5SGt4RjljejZvb29yaSttZ3VWZ3NnQUFJa0JuQUFBQUFJZFRLeFpnQU80TDVpOEFkK2VjV1F6ZEFRQzRDV2VvcTI5VGtXZmU3N2VXL2VtZ2JRRUFBSUN2QkNZQUFBQUFBQUFBQUFBQXdMMkFQd2NBbTk4Ly82dzh4K0VMZWY2YWU0WVdhc1kxQUZraXA0QUV4aDBXMzBHYUhyNVRDZEFKSUF2R3pzZWdIU0tEYnY1Z3JOT0RwdU0xU3FzejNSSEV5MjdDd3RxYWQ1WkZadVBjdG1rcFRiQ3FmOXFrTkZ5NkdYVWVsYkZ5WEEvS2xvNXZVNHRzVTZ0d0pweHFiSk51eUpyRjM3a1BPbUt3M0dzZG1TZjNjNnk0a1RrNXV4VWk3cnFvN3BEU20zSTJsUnExTjRKczFvd3JPU01peDlSNlpVblhXVG5Sdk5vQ2JjbVcycU1xWlJ6SG90SHBoczdydzdkSlhxeGg3Y25MaFYvQkFQRXAxYnhzeStDU0J1SE1FM1d0NDVJejIrRFo2c2dyei9xVXhRaENIWjVmRDYxYTJVTGUzVllsOGt4RGtMR2MrcWlXZFl4M1QrSytBQUJnS1orekpiMEVNMThkaVpSSnNVeWFGWFh3M1BlTWR1RjlndnZybzVkV3k1UzlOQ05iNzluNStnNmUzcEVyYm5UbVRubTBjYW1CV1lSclNRYmRiUy95UlVSdjgxQS9WU0czT2Fzc3paTXgyaUJXK0F5WjJLeUFEOGJqYXpyRHNEQllxVG1zRmVFcjhmZ0lhYndHR2hXQXNlY0lpcWlNL3BwcDBXZjVPcXZyakcyVEJmUnltT3l1V1lzNzRxMEU2ZG9LOThZLytXamZrRGRmOXRVSXNKNU1mNU1GOS9kK0NlYVc1TGE5NUlRVk9kdFhFcDBRYUROd1ZRSmpzaHJYSSsvcWNHVmRmcnBFbjdRWk45UThvaDUvNEFlclFHWEcrTUM2Tlk3UWhoRVQ0dlZ5WDBGWDNKN00xempESFI5ZG1KNnNIRjNjUlBDK0ZtTzlzVG5qQ2NBUjVHYndtdjIzOWVac3RKNlJ0bzlhaUZkZmlMejlhdDJIczEwcWthTnQ4NjN3UHI3L1k2cUJ1YTcvYXRkbUl6OUtyZVJmVjFNZGdhUWl4ZjZrZmgxbHJJQ1RnR0dkWlc4SjFNZDFNL1BRU2RPSHQwNXFGZnBuYW05bGxVaG80MUJ5NXBaSGJ2OUh5eXc0N2tLYzhUUFczMW41dFRkbkxWdVd5aWhDT3EyTXRVVFd4dGxXaERTY1BmR0hQTktZMVJYV3ZLVnZoWlZBbmVqUXl6cG90V3NyUFkzemJCTXMyYzBaYnNuSzFDVTdyV25haUJyellyVjlObThmcjl4M3paWXhPQ0diMHRhY3JtaGFIZXJtbjNkdzVaTnpjVFRlUFQ1ck1Cd0E4QjFFZFloM2JZdTRZMms0RUZtOTdZdHVEMmVrODhpWlpXWjQwbnRjWnBsZFU3YnZyRDNMaWpJakhESnRaMjZ5c2gwWnZsSHBtZFVNZjhlTUJvbVc2WkhIWVcwNmxjNm9tby9JbVM3YjVEdmpQTkZXdTQyQ3NKbXVodDlkOVVab1dtRjBmTXdHaXp5NE1UUFhvYWVjVWNPQ0VLa2k1OGZvcThhRkZ5Rk5CbWxGaVBBeDdvMnNNUmRaZGdINFpDU3p5ZnZ3cHVxaVIvWmlNeGkxMkdjdlh4K04xOGwveFUwNUNIT0ZidEYyZVZ5OEZmN1ZlSTFXTkY0ZTA0ZENycU1MRDdQZy9uNlhHbmp5NEgzbkJyeWhUWXcyQWxlaEJjTkprbXJFVy9tejNHb0tIVkRadHZzREFJWFJIVEFJMFFiMHJKYXRkckxSblY5QTZDR0g5K1YxZWozVFdEMWlsVy9HdFpYK2grY1B2TS9EZHgrenZ2cW9NNnF3UnNiV3lPNzJpbVRiTEJyL1ROYmlJdHhGcjJqcmRmMzNaNjcwRDBhUDBHYkw3cVk1dzU1d055eCtaZ3BjQi9USkxHSmZZMjNrZXY5WGYzMlBYdExXZ2k2dWtqOUdsS1ZyclpobFI4elV5RWYxS0RYaSszQ0pTTjI4TXFWOCtWOFdXTXVSSjEyV3pJdGFzK1FlanZUb1JudWs4OFMzemREeFBOUGc0cXRSQitrbGdNeDlXVVRUYTRha1ZUZXA3Q3UrNU9CcDZ5emFmVGRTZEh2c3lXbGVieGtaaFB2MjFtRm5Yck9KZnNxNHBGNEJBSHdPb3pvenN3WkFzUjJHMTR5STVqdkQ3UERnM1pGNDJxVTVyajN0SUptMlVWTzFKc3IrR0dZNVpxMzl3bFRiTnVxUUhaVWRZYVhpaml3V2hpL0NmRERPL1NDVmRLQWxRbUtHNzl1NFBUNGhkeDB0Vk51TWF2bTBhMG8xeXZha0IrQkdySFpNV2thQll3cGxQY0hjdFpWK2xJeExUTHErdlhaeExuWHUrSlYrT2dDdVRtUnpsa2pxMmFQUnNGR3krdGViRHlxalErcGcrbWpXMHN2RlNBY3VRZFQyV2ZuNDY4dzZmQVNjSWdieldiVmhVQWI2NzEySWhHZDJTQzhjZkR2OUltZjVrTkNHNENnaVQxR1ljYnNaMWs3ZjZNZ2lHM0cvWGg2dlBtM0tkYkFvcUJTd3czcU9GTWtIUkRidmYzUFAyWHJxNWgvejJabTF0d1lmU09qSHFTTmtScEgxMEhMR3lMUitZRHNnK2JBZnArYmFnMy9HVllua1N0STJFajdTcnpQZUlNbHFLTWxvSGFtVDE4TVJIWE1uV0Y2UklxV0JYb1dBa1JQTjNjelZFYzl4VGwvamVJYjlYT3R6UXFxUjExY2R3M24vMFg3K20zYkZPSlRtc1hlZWZzcnVaTlo5bk5rZXg1WHRLVW5TeW1Ocm1GeGFMKzllOXZNRW5WRjNmN3d2RzVONVJLY2NmdnFIWjRjME92WXpCcmhVQittNk9PT2JJODBhTWlYUHNPaWlyckpzM1pZdzZoU05oRXZwTE9OR01uMHRVNzRWL3pEMkdGaWp3OW5iWHBIblhVOWE0UTFOS2Q4S1A5dm9lQmpOTTBMdkl5UGhyK1dHNXJIYU1uSVBTWitLK0VWVVN6MEh5a2lOVHdEQTkySVpRWDI2VXZ3T2praFowRk9uWTNVQnR3ek5OQ091aXJaZjZLZEVaSm5PbEUzTHBPbStkZ3A1OXlDRkNmZmE0RzRsZVRleUd3ZTZDOC9JNkpuZ2l4QWZoRE96US9RdDFhMnNJc2tjOEhOVksyTEdKcVdYb3ovVjRQTllkZktzRnJSc0t5K01BQUQrVXVYZzEwemsxRm9YRlJFZlhkbWlQdGRaelBBQm44cVpaZ1RVSy9oR0JuM2pXUjB6NDVHRzUxblZTdmZOUjZ1TTBVV3dsL0dKVzhNdlluUU9lZEpGbnoxSFpIOEUzdm1vcGVNYVdaTUhtK2c4b3E2SVVyYUhELzgvZnNsU0dXSFAvMHRZOGQ5S0ZmNEY0TVpzaGpQbS9YS3lUUXkxREV3eXUzTU1xc3VDcnZrQXVEbldsUERwaForRjErMTNZaFV1UWl1K3JkazdmU3ZRRFVkejBjRTBleUQ4ZVhuallvUHI0N2ZjZUJma3d6aHpBbjMzeXZEOHdhdEhaOXg2K3lPOVB4aTVxWkVHT0t6aHZBVjltckk4NzM2aTYrM1ZXeDV1RGdFODAxaUg5Nlg2dTdlNTkwMmFpZmRwenVmbisrdkNlK3dBQVBCMVJON3VBcmZpVzAyNWF2eGJoT3VaWlV2WFZqam84TnFScnN3ck9XTW4yUnp4bXZQSHV3T1duRW9yeWxJNDg1bkdWemdLc09FSElJVXlaWm96M2NRaTlUcUFHTE1hei84aUJ6b01nQUZHSDJGbThtTEtIa0QwcFRoUDNoR1pBSUIxSE9Hd0ErdGcrdXMzL3pOazQ3ZmJSalJna0NaUGMxNERzSXFNSW4rY1lGQ0Y4UDdTRXROai9lNzl0dEQ1N0htWTB2anIvb1QyeHFVRElFSS9KbUhVclllWng1dm9SM3lUVGxja3VzUTZXQWJxNGE1MEhVeVBsTEh5dkU3NmxSWWU2d0ZqWTlMMitibThub2ZnaGNuUDVlTkdzb1pVRjkvQ3UvMWEydGE0cVozc3BweWNYQjl0L2s0enc0algrb2U3OXBTNVZmUS9kK3Q5R3NLUnVVK3VIeUoxc01xVU5sUkZ5TGY2L3FYN2kycm9DUnZIVjVFa1RmV09OWTNrV0g5VmUrWnExVGFpdmVuMk5ZaU03MjEvMWtBcGRxeFM1UGFQc3ZlcWMrbEpRTXVNYnltUGQzNnRzRTZpclRoRFQ4L1UrVm8vckxidXZHVm4yYlpQSmRmTlVXYmJwYXBzZUs1MjF2elY4cjNyc05mSzIwblhTbWF0a0VpTWM3R0k5clkzYVRoM3ZmdGMzTUE2R3Y2U3FzZWV0UFNPMTY3MDJoR1dyT2JJSTVWbHIyUjJXWmFkYkRtcWZTVkxORWU2ekN6dTc4TFR3b0FRR1ZwU0htNTVLc1UvbkROMTZPVm5aR1hMMUdSRlZVczBqb3UzMG52clpPVWZrY0dwSGt2OUZGSzBzTnhJWDFUZGFTK2xIVmd6dWpERFdpakxpaGMxYWR2bTlWaDRjYTBNQVBocVJuWC8xbTA0dHd5UVp0WnlMSVZkalptbVhkWWs5ZTZhSW1WSDQyK0xkK1AzYW1SaTdVaHV5RW9LNlgwSnB6U21aTDE1OHBWaVc1Q1dMOEx5TVZscGlpTy9oTWVLTlVTM2dDL0NmS1poK1VFeVBtNGhhYlY4d1RUY3FodVhKa3RHVTFreVJobmRuQUlRSUt1V09UazloaTlpVnpUblU2bmJTNnVhbm5UVlV4Y2h2cGRkbmVrOGRSaGRmVzZEOXdHU0p6K0haMDhHd0NjUWZiZ1QxS1Y5Mmg3Tmt2VnVaYlE0NndrbEJTNFlnWkhGY0xSTU1JelZmVE50QnN1V2lTQzZMWXgwbHB6TFl5bERyNktiMGJHWWgvZEQ2Yk5mSlVQRU9BQUEzSThXdkxiQ2dZNzBycVp5amFZR1V4Z1pWTEFGWE95K3dMRFFrQ1krYm5CWFhoMUpCNCtEYWZOeTVoYmU0Z3hGc2kzelBYZjQrNnQxNW4zbjdyY2FFdnYvNnlucFg1L00rV1ByTW1WNlBHUytRVFNQRzlvUlVwV3ZZVTZkcjZjQXVBdWo3Z3hyM3A2aFVtVWM5bVMwc3RnSE9qbHlWemJ6RmU0NVlFOEtwb05CdFo2VlRxVjZZdEYxKzIvUHNpV3d5djlpdVFVQVRJRjdadHVVYXducjEzZFlmd0VBeThoWU8yZi9LSlhVSVp5dk9jSzFkaG0xRHEwNmNQR2F4UnpvaEplSXh4ODdrY3pDYzVWbkdsUEdXdkNYRndDQXk1RDJBeWd5b21yclNQOEEvQkFPVmpVU2xnQUFWS0krWEF0TXVZdmk2ZWhaZXZqSUJmWkw4TDVERVpVNUUzVDVCWUFDdmpiUzVrV1l3TncyNlBjN3FNOVY1ZHlseFAwbW1NMSswR2JnYkxTeFYwdm8zZmZkRDdFYUg5K1lZcmp3MjZNZHNjTTFRbU95Tkx1TG5pTFZxanhQZG9PdUFkcXhlaHdZTTJHOHYybmJ6Y3VFTXRSK1RvaXV1d3VWZnhtb0tkY3Y2T0R4SEwyb3BhZUZlcEJHbXZXTGlBalpTZEtuYjJ5Ti92dzQ5Yy9YVDE5ZlFYdE16TjJYVVYvenRmSHhLc3FlUzltVFZhYTJQem5hN2g2NDhMZjhzNkFEdHduaEV0Ylk0c2FGMU5aVzJWRXJsU3V6Q0dXc0dPK3R1TDVrdC90Q25XUllQdC9lZGhydkdyVzcvOE9ISDkrLyt4NnFKTDY5Y25QcFcrbEhWTnVWMURZeWRWbDhuYnVVcXVwbGREajMxUUJONWZ3TjV6WnI1bTZpZU81bW05NGpOMU5tZGs2TmxNbWxpOHEyYU1aMWxwRzZ1bmViem5SYmZQdmM1c3F6bjlkOS9rYm1xVDUvcWN4bXJnM2VmSDNhN0p5UzVORzBuSFBocVROSUh0RlowSHhWbWprTlhySnBuVElMazlSdlJRaG5kR3dZem9qblpGTXMrNFdXd1pVbHBiUEt5TnluWHFKMXQxYitRdVRRdjJmaWFmRmJFVzEwYnJpdUtpdURkeGhiWlBOcGRia0NNL3A3ZGxzRzVJbmRXL2wwVGFnTFYrU3Y2clNzeVAxVUkxNE5wL1d1YTYwdkFNQ0Z1T0xFclltNEs2NTFBQ3dHdzk3QXMwbno2aFR2RnAxTG4rNm9xSUxXMGtmOU9KWk16cmVrTmFiUGk2WmZTN1Rpdno5dlhUelIxZG5VVFRmbXFROHAwdTNzQTMyUE4wTDJVTDdqclRTV3ZKRkpvNldmTXJtY1pRR3dBRzZvYThQYW1ob2pQcU9xVnlVcDVvVzJNbmhsZWZMMzVYaWVhTGo4TGVWRE5JTjNhWXdBbFFrK0FVNXBTRW93WTZKb1JmYXZSbFNmTlUxbFdFUjNFWDBlSzkvSXN2TVZXT3M0bDRhbTg4Z0FVN0htek9pY3lxRHR6THpxU3BJcDVidjh2SmFNT3NzK3pyaFV0RVpac1NVRmZvSTZVdnNkeEhNby9lYWpKZ0VsRHNEbjRIM1hqU09ZUHVOUStWU2liZUZ0Nm9aR0JqM2F2TVl1K0RMOG1iZXY1Mmswcm9DUHA1K25sK3R3S0FqdzdaeG9XRFZuSGJ6dk4yVENOVDV3Z2ZJMDVXbnJkR2F2ZG8vQ0xzaGQxNzR6TjRMYnNtczV2alpTbVo2NlpGVmp1NFNIUTVpdk02ZHg5Q0hFRk5sM2Ntd2NQZEx2enhtOWkzMzFBODhiRy9BcjNwOHY3MGR4Q2F5ZXRUMFduczNqaVFjQVhKQTdURnpQTXgrczlRQUF5cGw2WVlydE92TUZsNnl5aitSYjVieHZFOUtNTG5hUC9DM1JvYXVhaGY1Nm9QWVJSeS91SzhxMEpoQVdmUUNpek5hVUk5clpXeGZ2VE1kV2dJREdBRURuSW85QjhSN2xCeEpkd0VxWHZnM0tBR21PZk9hQjdoMWs1RGRCczBFbm5rTnlFa25aL2x6LzFwTUlaSDZ5RHZRVEc3dy9yL2UwK1JXVUJMZ3YxWmxHR1dQVzF6aXJjZDBma3ZDUmNNZHUwUEMydFk5ck5XUlFrVVlmZUdTQUw4TnJYS3c0MXVhRDRRNTFhY2ExOXVYVTF2WXlaelkxdXUvaS9PM3dybmRlUjc3VmQvd2YzQjA0NCtpREdneVgwbkVqMjZ0b0lvOVJvbkhrKzJiQ0JOMS9LZFhUR2RHWlJtVzJSeWdmL3M1VlNhaDNRK0ZONjgzZnR4a1hIcFZwalFQdStDMktKQ3R6MzFZWmxHZ2JOMGQySVkwWGx3RVo1Y3dWaGM2RmJhajNTNm5WNkt1dDlxcWxzV05Pa3RHTWVBKzAzMGsvN2tTVDlKNyszbjF0OXhWUnhoNlhSemhqTEhuWHZqUEhlUWJ0dmp3Nk15ZS9QZjViU1lsY25rcithbVROODE1ejJHVkc3ejh5QjZRNUU3VWpNbU5PV0grcnNRWm1uUkhQZEZzbDZVUzZmODIrOE1qVTJsNnpJeXk1VkY0ejBtUTMxWm15aXJPTXFOSGd4MnZCZVdaR3RLelJkRjlIWkJpc0dqSVJuWkd0dzdyaGZqOUcyMkpoVzRvbXJPVCtVT3BpV1Q1UGZqMWsvRTlLL3pTenUvejlIOUFwQUFBWEhrT2sxMmtSTjE2VUp1UnRSandBNEhzSmI5SWVGaGMxb0tvaG40di9TSDJVOVVYUXZET2UrV2p4VmxuT3pxbS9IaUwrVjZaaCtiNWY2YWpQWFBBeGJkYkFLaFZDd29zUUwxWlN5Vk1OMmQ1d3pZZEVkMEt6SjlkNlh4TUFJczI0Zm1JTno2ekx0Y2d6TE9NYjFjb29pWHdSV2pBK2N4K1h3YnNFbGtROEFOK0NWLzgrOFNwRHc2emdQdTVSeTVERjZuNUN5YVY3bGgxNWNna1l1RWZYMGNieWJuL0FNcUs3MjVrMkJEZUV1SEQ2ZDUrR2l5dE1uTFVUdXl4Y3hUMnZDa21ONndIejhmb0lMZ2ZwUzZtY2V2NWxlLysyd2w5LzMzSW5jVEszMVVBQU1HampGem9pQlAyaG1ZVkhkYUFMd0RLc3dZWEJ0MkhsVXUrMDRQN2k3UkowM3gySTlQeXNzckx4OTZRZTJjUVRvUE1XOHhqc3dJQVlRdnVCRzVvV2dPTll2U3l2ZkIzcmVBTGFhYm9pYSt5ZnIrdExHQ296ZTlqN2RQMEk0R2dHSDhETjltSUEvQUY3Y0FEQU1tWTc5V2s2NlUwcnJNY0FnR25BU3NvUmVSdGs5UlBnaVl2QmtPRThleXhoYkFJQTF1RDVRZWZJYzMzdmp5V081UGJiQnV0SEdKNTRBTUNoak9qT21YVTRxcXl2Zyt0Z1RROTcwb0hEaWU1V0pZNThxcit5YkNDQVJyNEd6Z243OTdkT2JaKzE1L0hGMU1GdHk2MlB2VmxJNUNHT2RTcmdqRitWQXpBYnArcndyaDNXYVRYZTB6TXNtWmVoMTUyUEg2YytEdzcxWmkyZENEMEFBSEFXMG9FeTlJdW81SEtUWDR1WHdqeWJOcWlLSzZEMXJFVDFSVGVyVEkrOGtWVzhUSkQ3VEd0WkNWd2RySk9EbTVqMjUyTzAzTS9SMmlPK1BxNGUxeVIvYTE0M3BQVkwvejZQMTlPbWwreEw3WGxzTnI5VVg1bmU0eEpwLzNyYTJsdUhFYVJWZ1V2bktOTWFVdjErY3BaRHgvTmxWZkVMbTJLR3g3L3JWNlo5azIzbk1UL3pKVzJnaDFZU0x0L2R6UHUyeGd6cHYxY2xTUjlzbm94TEE4dGlacjg2TjBwc1BxME9uanJTWFdsbTdmYVdYVXRNZjBWa1cvRnRzRXk5TG5RKzhGZVVSdkxTMktaZTYxOVFyYnQ4dmFxVXZxb3NVY2xmZkhwTFJqVzBSV1JPT2ZxelBmNFRXU05jcGt3enF2alVQL1ZkQjdZTXV0NVlUdFdJWGVYRjJvMXhhM3EwTWEyZFlFUldsR2crcXA5aU9UenhVcXRZV3JxVnVPYWF1VXFCaWN5eVdjRkhzRE5WbmVrbGJXV3RGTTJRMVlkNzZzSGx0OUo3ODNENW9jOEFPSkJaMnliTHpUVWkweHZQK1k2d0hnUHdQWGhkU01WSXg4VlZJOTBsZGMwS3l5b2pjOVFuT0NOOWRFR3h5SFk4dDFETmdCdXd6WWpud3B0VHZsWVd6V1A1aUNTdlNjUkh0Z29ZRVdBU1hxZGdjYVNqR0ZOdGRJL095WWptc3pTbS9zUWpGKzV0NnVKSTk3SCtpZXlZQStBYnlEekNwQ0xvWTBHYVBxRmN2Ulp0SS84VzRkb1Q1N1hrNlcxOXZCVmxtYTZSTWRRM2NoT3VwWHhnQ2tjODA4anVTR2Z1aHF5ZDJLWFJHbGw2bGNUcUdLc0JMUmREYzZZRmE0aTZtcW9lektuZDN5VkNkcUI5Szg4T3hPUUJud0lkejVqN1k1RDIzTHhvMC96Mk1nRGcra1J0dWxHaUwvK0NHMEh0UzdwWXBManlLck9pWG1mZTczalpVU2RIK3pvcjRzdXRKa2xIY0RxRDR0VWh6ZEhHWDdEUVNENnpTOW53MkVBNHVQZWFNTTdSVnVxeC9Ga0RxNk9OTmZlZFd6V1djUTd2Q1UvM3h3MFBQOU0yTGQrNjlwL3BlRDZ1ekpWM2lIMHhBSjlIVkdkd052Mk14NkJSL1RLcWo2RFBBRGlCN01TejNscjArRzltYzZaWkNRQzRQbCtuSDFZb1g2K0ZPYU9oVnpweW5uS3oxdTdJejdTYUxqcUsrS08wK3ZQOEEwNTlBTDZhSy9uNnZYSzBWem1oVlJieDJZL1hBSWd6WWQ4dzZsT1ZYcEU1QTBsRmZMVk9qdnpxRjF5ZUk3b1A3c3BCcnZRNjBoaytiN0FuMmZiZVJ4cC8rTDAvTHFBVTlpZlBmWkxSbjdwL0U5bEpqVFlGVjBNNllVUWhxeXA2RFhUMFN4eExNSTdnWU5WRWZmL1RIZzJoMlFtVnFPMW1wR3VYYkNod1NXRGRUMk9uRTZzUVR1d3RlbDFwT3BxZmxJbnBmblcwMWJMNnNydzZ1dW41VkR5N1VXMi93SjJGNDBtbmxaTTUyeXBTaG1aeFZISlZIeWwvMHRFdm9yNitpbGJGbGZxVmtpK3JHWGs4MUUydWJkMDhiZVlwUjZxVEZIN2tTeHpSTkJHa2Nad3BWOXV1Yy9IUmNWRDQwMDVvUER1ZFNSbXE0ZWo4TlpIN3k2bXhjZTRmci9MY2tyNStTT2Q3UWt1TFAwNlZhNS9vWjRzcVhWTjlSZlIycWdxV0R0QmEwU083RVZtUi9DdDFSblErZTJSWTExN1ptVGEyOG1iSGFUTkRmNzRVMm5aeGUrM3JLN3VmeC9LWFRodkpVM2FsTm1jWm10dzVSTmNJemU0UWt0SjVhbTA2WHVtY3pvaG4yc2FNdGVwY1Y5VWhhTmxYVkpkWVFxMDZaZXhtQ2ErZG9lWDFraWxqcER4OXJmeURSK1BNMUhnZXRMcFpxMUIwbFFJQStKQnRnKzMxODI5T2gxajZxQmpwTEdic1ZBQUFINHhIU1dnS0taSXZ3d3daQUlCN2tuRmZhVzVYajR0SjRsQmRsUFZ6WGEwTWIxbE8zMHVvTENsWWU2Nmd5V3pNMkhvR1NINHJLb2FVdmZPSmszeU02SzJmU2h2UTJxNkVxMnlmTDVJMlUwYkViK1ZsMUtjRXdBSThMbUV1M1FSbTcrdEhacFozMjBEeCtHV2x0SmEyK2hoTjRYRUdBd0RlT0pYUTM4ZUZudlJWdldSVlByMjJwckhYMmlxT2RGRmQrRFc2MHBOZkMxOGhHMXdhNlgwckxYMHAvcUdpN1k0dCsraDJRK3JvaCt3Y25JTDJQTHdENDNqMXMrSG0wVVQ4SXZHL2gzcjBpQUVKQUxnR2RMVmZpTWVZK0NhMGd4bkRyd1NqY1lFWHk3TUlqdWN4ZjYxcFRCL1J6WGFLZzZNSVRMclRPL2l1Q2tLZlRWZWZPOWVlMXpBNHpvZHAvMmkzekJoazB3ZnE4V01yV3lLM2Zmck1XZkhwY3gyNmJEVlh0Vm12NEtQUGM5RjF1QzJPQitBQU1Fd0J1QWRucklRelh2NEVBSHd3TFJqK0JGdFNBTURkdU0xRHlTTXFHWDZUbzh6RCt3UEdra2duL0FRZ1hIM2lOWi95TWt4eEZmV0MvcHByeWJwN1JUOGRmWnNBQUJEbEtrdWQ5SjcvQ0NQUFJUOE9ZY2tEQUl5UjFWT2pGaTVZeEl5RlJ5UHl3eW80M20rRDV3ZWdxM1lza2x3TW9RbDRPdzFiMG1NWTlLbTBxaWZqb244WEZlUElDYkFPK2pOamVtMmxCMkFGenBWWFV6cGFlSjgvT3BRdlBRVzBJemI2ZU9VVWlNb2MrZE00V1ZMWnpaRVdnQWpNbUdUVFlMeVo3TDZJU2c1ejNTYmUvTFBSRFgxNjdibmFKcjhRRHM0a2FIQnZuT0YxSDhZV1FRZFp4c2ozUE1YdDAwblhHVHlXaEpmM2ZmUmZQTnM0T3Y2dXVUOXg5ZEYydTYranZkWmJvZXhYZk4yR05jM3E0VGNDOHRjYytUNnA1THFwWi9kUnFDSFJqSGhOSmozeXlrdFY1SG5EcmZ1ajZhejdqdHdEWFF5bHhURmJCbmUvd285U253WmtOU3huYVNIU0Zpanh5NmpHZldUS2NyZU5QcmVxME0reEdWTFZmUHZlcnQxLysva1luUmN6RU1hN05LVFlLcEtYaHBvMHRtaFp4aGhrODVaQUhvMkk3cUJ2Sm5sWjJaOWVmVTNEby9LMHRKSCtrNlgwa3Q3emNwc3UyL3ZOL1hUcW5jUEt2YjlyYVYydW9oVDZaZGc5elFpUFdPOTluc2c2NUhCR3FOYzBiNytCSVhxbWIxWHRWc1ExUVZOWVRialc4bXJoWXVVYzZhWCtrMlI1MFVacXRBeHZIZWZodGJvMHBORnMzYVdWYnFSc0FNQWFwTWRsUmJnZXNTT3NPa2hrNUhPck5DZHJ6UHJTeXdUZ0s5RW0xZXBKRWpIcG4vR1cwc3VXRFFBQUd0ckd5dEpkMDdhZU02MmdLSkd5dll2SERHc3Y2Ni8weU91Q1JOR2NsVzB0YnBXL2JGMzZhcFJuTmJINGpFNW9XL3FNWlBQOHBCaUZrTHFKOFgwNnphZnIyYmxZdnNHTXp6dHFHRmhsQTdBWXpSVmNTQnh4Q2UrK3pIZWpZWnVwcXRkRHJHa1EycFFjbkdhNUZMT2RLUUNBSDJhWXJrMFFhWms4SklObmFtYXRxTUlYdWJ1T1dHN1pkQjlIUmo5SHQxeGdHU3VmYVdSZG9OSDV6T1d4eXJ6RmZNMTBobVJQYytrS2swNHpKS1c4VmppSU1kUG1OWXA0L3FHOTEvR3JBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE0T0IzNkVSMytndm5GWWZFZlJ1WkE4dzBPUUJjQVBhQVFRY2p3L2hXVTBBNzlIRFNLUkRxUjZZQThPRDliSW5IakFBdWRpY1RDdVpYUDY4M2Y1ZTlySjdtREFNWEoyQzZpOGZKdGVpNWx0clJvMVlsc3NmbFVYbkZVU1lsZGhaV0pkY3ZLZlV0eS8vbDFDS1dzMDhzSVFscjdGV2RlSlRVenhmZDltV05rWlVWUGR0TU91SkxpL2ZJaUVLTzQ5M0pqaDVaWlkySFByN3AyVnZiaGxGZThjU2diQk1YZlc1UjQrcHdJUFlwbVB0NTcva3E0M2IwTlRZdWRyZlI0eUNGTWVmMVJhZ1FXV1lkN0ZiMnBSdEJ1dkdNcFdTMHNaaHVCWkg3c3ZDdTlSbTU1YlhDV0dWR05IZk0ycWliV1Z5RWNyd3pyZTFrTkRPdC9lVlVpalRXUE9sMU8yS2ZKOGpPOURQV0l5NlBXUWExdHhTSHg2N2pHaC94dW93cXdaSDJpNjc1TkY4TjVJa1NIV1BqakpRZ1dWbFBzbHBaMnNrVUlUMEE0SGk4dW1PRzlUV1MxMjlINk5jMGZPVmg4Z0I4RlNQYm5laVczQ3ZYS21POWVRWUFBRHphTmpINitSS1B6RTNFbVZhUHozK1ZZN1l2UXRzaFIyVTlrN1I5WFBTVGcrYm0rL0VkalQvK25XYkliTTdyS3ZoR3F5RXd0TTdPOUVaSTQweVNiVkdENFNQQU9BR0w4V3lZQmRjdlRadDk1S2l0UnJUSXlQTU1tcjRFODBycFp5L0xyY3d4QXc0bmFrWjQwanVYUGdDK2dvZ0pLenplbzJJYWxkVzI2YjFGMGpSY0daYTd4akpoclRMNzlKYmwvZkVxUmRvK2pXeGRxdkEzT0l3am5tbEV5Uzc5STJWY2N2aGxHdGxTc0I1M1JMUU1LZ09NNFYyZ0hPa3E2Wk9XR1BENFlpb0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIQlIvLzJmLzNMSHhlLzR4NytVbjd0bWZ6RU45a1NQQ1VCYmc2T2d4MnhOR0dzNDJadlE0dEgwUXlFalgwcjlpallHY2F4VEx6Qm8wb2luY1FrbmhqV2E4Wm01NmZLZnlWeGxGM0E3dEU3YjJaUEdzWEt1UXJMSEZVV00zT29zTzN2TVplUjhVMW9EOG9XejVpd2l0RUNQcmNneCs0cCtzUzFidHJkZlp4cVVrZU8zckxLT09LUHRTR29SdnlLMy9XT0wxNkJVdjFSWDVYQmF6bkp5WSt3OWpldmp1aWtsN0w5Nm1CbmxuckxtWTR4N3o0MmMwcThTWjg3enlEcVRrVDFETDJmcUtIWjhRdFlZa1huSlFiOHFudmxhYWYrMVUwNUdWbWZNNWNqMXpEa092THBFMHlHbTR5TngzNit2ZkhBVjNTUVU0b1cxVkwxaDd2cG9hSnRkbHl1NUlzNWU0UUFBZVRLMmVVUm1JZkt0TXIzV1ZUUWVnSy9Idi9uK1llVzJzRGpMME5KN1hhTUFBTENTcVB2OU1HWlpkV2RZWUpIRnd1dnJwSEs4Zmp0UFhXWjFyTU9uOHZkMmxVVlBlclloK1lxa1ozVE81NEpiSVpUb21QRDZZVFc4L2VjTjErVFhZTjVvV1FBWUNNUFk5YWhkVUkzVUZYeW1GOTJiYnFhV3RsWUNiY1g0cUsySmQ0bjB5QURnRzVuOStMdEhVSDZ2SXNsYVFMTnhJcmtpUjZvZXRlU0JnNGhldnNJajFpOUYyeTNOZWp2bkR0MTdTN2RITDY4VWYyZG9hUzM5N1RVc3dUV29tMy9DanpRNDhNVlVBQUFBQUFBQUFIQlNzVk1HWUJETW9ZK2tYcUZmTWJZQXVDL2ZNbitocHdBQUFBQUFBQUFBQUFBQUFBQUFBQUE0RWp5aEF3RGNCaWdzY0ZOK2IzL255cDJOMDk3UjNsODZqeHpzQm5LZ1RjRXNwT08zTEZWQjg5TThETlg1UVkydmhEa0dwSGJxV0dMa3k2bTdicTNsL0E4ZmdmT0JrYnVNYWtVODV6eWQxMzNhTHE0Wm4yRHc2TmJJQVRuZ2FCcHpzbS9oTy9ObGs5UEJNMk5DWjA4Q3RzN2k3T1ZMeGtneDh2WXlJdkZOaUd0aTN0ZFgwV3BqcTdUN2FwcDVmS3QxUm1rZnhpTjl5UzMyZFRuci9xMThwY3RQdzczOWF1RWRGek0zcGQ2aitxUittMWtYVGM2ejdPWnM1aVlNYzhPZzFNYXpHdmY2ajQxVWRtaWg4clpyRmE0YUNhOUVlbVBuVlRXdU9YTHpOWXJrdUNGdDdhbXdaa2cwcnF3b2tlTXdpNUkyRWgrQmJvQXQzVkNNZUMxZnR0N051S1psYytteWEwS3MvNlZlM2w1WGNjNDk0MzlrK2VaUzVndXFWRGZzWjVRdG82L2Y4VjlPMVNhMzVzang5cWVRdmpxcTlscTNTT0xkR21EWmRoNE01N1o1dXhFN2hNNGg2ZG9yMjR1MzM2L0ZUQzB1YWEzc2FCNlpVUUNBWTZEenRwQnJTK3RxS3lIbGx4RHYwUkdTZFpWY1pRRUFUN3lUd3BOT015UTBkNDkzRzFpTmRONXdBQUNZaGJSTlBzS2xuV0pXd1paL1RsUDZxOHJXOEM0SWt1VW8zQi83OEpuell6RFJadGtVS3FmelN6Y3RIeWtqOGt5akZ2NmF5aXhhdU5jS2oxanJVVU5DdW82R1M3dVdHcEJabkdVQk1BaDloUFc4MUZ6SW5TcUl2QmF4WXEvdDlRQjd5NnlGVjcrTnhOTndtcWEvdHJRMlY0ZGJrSFVDRnlZZlZCc0FiMFljbE1LajlVb2V3clErVFJjdVBSNnNScEdTTG93OEZSMTExMENsS0hoTjRGYm1MdEpBeGJ0VEdYMm1NV00rWkdWcnUzM0puanFVV1FWN1hRMlcvOGVEMXVGUWZ1ZmhmS2JSK3ZqQ3VGSVl0MURaaS9tTDQ0dXBHQkVBQUFBQUFBQUFjRHhuN3NXd0R6d090RFg0SUw1dU9IL0xEWjkvbi9oaStVclF0c2VETmw4TldoZ0FFQUU2QXdBQUFBQUFBQUFBQUo4Qy9Cd0FBQ0FESFFrQUFBQ3NvZjc3UC85dCt2R2Y1Vy9jUC83VkxjZmUweTg4cDJOWXY3YitOcnpIQktETndGVnAvaVRWQ05kK3FHOXhpNmxpSGExRFR5TW8yNU1IK3BQZnhOTjZxaXdMZ0JSWWx3NkRuZ1NXK1JMeVJrNUJkMzBVVGJIZEw5SFIwZlBrYUw0ZTcvRk0zcE9nYVQ2dTdPMlh6Q281RTJ0L056OS9OZW5VNWFhVlplRCtoRGwvbisrNlZoS2VPYlU1eXN6QkdEMlZ1ampTbjJsaFp0dldNNzZaZWNZWmpyUU91K09HR3gvZVp0ei9FV3puclJ5L2JVdjZ4Y1ZuL0l5NzNtdWhiWm1uSXFucGtVMVptc3hjODU1dldrajRpT3d5SUROYXBpZThyOFBNKzQzazQrb3czaTdTdWl2TjMzY3FlNDVWWnMxdm03V2Uxd1ZXK0RGZlB2Ym1tYkhtWjhaVUoxT2RRc1o2WkgzSjI0UFhudG9kdWIvNzQ1bXc2SGgwQnVDWXIwSFdjY29TQ1FCWVJ0VGxLY1Y3ZElQWG9qdVRPK2hoQU5LTURQQ28yUXdBQUVjeDI1VWtnZTF1Z0NPZWFWZ2RuSVhwNkUxUmdUSjNZNDN4NzFUbVBqeEZXSzdRdXNLWGxqVWt2QzlRWnJBYXdvUGw4OGFFQndZblB0TDQ2L290Y1VhZWFIaHYxK3RGOXFvM3FRenQ2UmdOajlibDlsZ2RiYWsvTFEwQTRJMURpVnFQNnNUSGdxUUliM1ZHL0pvamE4Skhxb3daaTZTV1BnUDA5S0ZFbjJsRXdtZDFYM1FIN3JHbmJrbDB2aFpIZXEvaGpMbDRTNnJSYjU3dWY0WTV2cGdLQUFEZ2ttQVJCd0FBQUU3Z2hBVzRucm5vdytCWXh4WGE5bHY2RitQNE84QjRCblA0M3Erend0NEFBQUFBQUFBQUFBQStEbXk1QVFBQW5BbldJUUFBQUFBQUFBRDRlQjVmVEgxZGRsSGJuekZ2dnBqS0ozR1dtTXozcVhpUDgvQWVKd0RBRWZUajFuRktndlR4TUVzOEkwcU12eVdaWTlkSXNtb2NSYUFkUE9tbENoODVBZUF2V0orVzA1SzZvaWpKMFUxZkFqMUc3aFZlVGlReW9LM3pQcm4wbkV6cmpOSElFVkZOa0xRdFkvZmxWTFhhOVpXMHBiNk1XaDlYYlJOTDY4aEw0cjhTeDZYa3BWazNHS3VOTDUyM2JDbVBaV21XWUQyaWRja2VEK2c5MDYwdzZRZkxGRStRVFJpWTVqR1lwSXlwK05yaENOTkduakhiK2Z3TzcvT3RjcW9JR3d1dXY5eGZjbWJ5U1RJUFk2UkhaNndubXR3VjU3YXUwRS9HSmpTVnZwclgyL1ZxTDJGYklsMGIrYmtWUTdjRmlyTXVNNW56TmZTc1RvbU1neG9NNytON21oRXYwSVFzRWJ1cjBqek9zc1hDK3ppcExUMHlPZGxhbWZjbnNudVlTUzliSEZJRkFIQVhJcDZGRmZzQnI3eVYyeU5ybFpYU1E5Y0JrWlVMOFNqUkxVdEd0cGVvT1FrQUFLdklHZ01mVC9TWnhzem5LVnhhbXQ0S3p6N1RVRHI0NVF1Mi9ETGttV1JvVEJGL2MvWDZqS0tMOTh6blNuMThWS2FuVEE2cHY1SStzNURmQ29CajJLa1FNaFRGMGE4TTUxcGlHdFA3Uk1QQ1UrYkl6TE5XSWF0ZVh6ZTdvYzRBT0I1RFVmMjhJOVVGSHpoUFBicmVtdzdxSlVqR1ZNM0tBR215cmw2dm5WV1lkRmEzV3JzZ3F5N1ozZUJoUkJ2ZGUwTXp0c0dZYzhlend0VmdsY1ZmaHZZUHY5eWxBQUFBK0Y2d0pBQUFBTGdFV0pDK0EvVHpaM05tLzJKc0FYQlh2dmNycGtmd3JYb1pZK29UUWE4Q0FBQUFBQUFBQUFCZ0x2QTJBQUFBQUFBc0FXWVdBQUJjRStobmtPRDN6ei9QbnpiVDM3UTZmMzV0SGRiRkZRRitpRTVjenkrZ3MwY1ZBT0NsS3VIOTJHdDY4cWg0VHFWSTE3ZWdHdGZDaVVHVkNhZW53TzFFRFRST2d6NEJITkpSTWhndjAxRVBsbVZPaG1SUGhTejdkSjV3ZE9kTmVjM1B5b2ViR2Y5bUxqRzhaK05veG16ay9FNVBYYTN6ZXp5V3hQTUxiWTFJTkpTZmNKdjEwU2ViTDZNKy9tNU0yWHlkR250ZGhmdWxkZGErcHRaL1dhNXhSaDJUUXlleWFiSEcwTW9GeHpxZlZrSXk1cVR4bmRrUWU4L3I5WnhzVGV2aUxGcGNKUHJqS3dXUjlNdWFsbUdaT25LdjZuTC94aGROd0tOb09wZTJjMU1LZjhabHZvWkl2NlM0LzFJcU4yODFYVGh5WmlGRk15UjJ5bzNQTjNPYXV0SG1vUlpPWldnT0xjL0dMWUkwZnpNNlZKSXRuUWVab1JuWG1mVE5kUzMxcmpXWHRQblpyNTlOMGFYUzExZGxuY0hKSE1PNnp6N2xzL1E5VWx0NzFnNHVYSkxqR1o5Rkw0TitnVjVLWjQzblYvS1duNjVOQ0JBM2EvSlkyb1ZYY2gxcWVrNC9qY3p2NnpGREUycjV0WHg5dk5mU3lxN0dBSUJqaVdoS3k1b2EyZUZGdkJaYXVBZXZ6cFRLZ0c0REpsY2FKSllMeVpwa0sva3NVdzBBY0NieUl3MDV2SlM0RWZCMWVpdXpDNDM2NlNMMTBDeEdyWE9xTTVqNklqcjVUNzk3NDNiRjFCZkJ5UkxLZGozU2FIemVkNExDWXJxS01nYUwxL2Nac2VKblRTelBPT0hDdVRnS2pCWXdGL0ZSbnVBU3BxckZOYTJybllTN2x0Skh2T3dVU1V0WFE3Wm41bFZudU9YUCtIZ3NCNGZuOFNoVUlRQjdQQTVLd1Z6OEc5eUZOMEhYLzI4YlBCWFAxTmZTZWVOQmgyZk1hUGxLTWovWTRiVS82UFRsZG9OUjJkWTJVWXBiOFV4alpKZTBsTmszMkl4MEViejJFNVRqUEdiMEc1bEUxdXVUM24yR1VvVDJ4VlNQT0FBQXVBNWY1endCQUFBQXZwWnZXUXpQdkU4WUhKOE4raGVzQW1Qck9ORFdBQUFBQUFBQUFBQUFBQUFBQUFDNEFYaWtBUUFBQUFBQUFBQWZTLzMzZi83citFMXRMZi80Vi9HRGt3bm1FMm5UV3RBSFlEMmVZeUtDNDFBN2RTeDc4a2Iyd0pWVENCNUZ3SjBtdCtKK3JZOVFnUy9ITXphd0xpMmwwVk5OU0Z0N3ZzUkE0Nk9uRjRHYjBNSVJaVHRxdU5HVVBXc3pjaFNsUlBUY1Q0OTF3RmtjaFVtL2xmSDZvQmY5SXFveTZmNmtiZXJSc0VKR01YM3NmTEdaWDNDVEdkRWUzcnlaTXJUeEdUSElycVFWcysyZ3pXc25HeEhWWHBnaTdMNzgzUFMwQzQxV2oyYnc4OUFWajl4VkNMZGxlUFNZbHIrVW5EN3V5cUQ5L3plTTZrQVNIcTdiQ0N0MXlZeThvMlN0dTJnWlUzZVlqMy96NDN3L2FpdUp0MlhyWDByZHovajlmSDNtM2NxenZxVDZqQnRaaDZ1cEt5THJWWFhFYzZ3WTc0Yk5KcW9yb1k2UzA0VFRXeFp2WTArSU53TksyUndKM2FlSnp1UExudU42Q0NNV24vZmcyQlYxQVFEY0I2L1Y2RTN2S2NlcjZXZjQ3YndyLzByckdYd1kwZTJDMTQwMXc3MUJHVEVrQUFEZ1RHWSswcUJ4WGhmaDF6RHFJeHhaRkFQNy9VMVJEdXZ1VlpSbFdSWmJsbFUzS2R2T2lGVjh4bFVUTnNPYTFXUks5eG1SRjJIbS9WZ1RIWURySUttQVhYaGluWXBxWTQrOHZncGNHZGxaRnQzUGwwQmR2RDZHMnhGOURQcWtCZU81TkFBQUg1enB5aWdxcnk2TitFUWxGWkYxSGNHNllwanRDNlRwd0RJOFhSRlpaaU11QnlzOFVoWVh6NVVocGJ2c2twODFZcU1HWldRQWVCdkdVcDdnR0p4dW05MjYvQXduNlRMejFmSEZWQUFBQUpma3lNVWJoZ0lBQUlDdjU4ekZFQXZ4Y1h4YlcyTnNmU2JvVnpDYmIxc0RzUllBQUFBQUFBQUFBQURnNW1DN0R6NFNER3dBQUFBQUFCQUhWaVFBOXdYejkwRFEyR0NBMzc2ZldQK0pkNHkwbWNjTmdSOHliWXArQUVmUXE0NFR4cHkzeUZ0TkIrM0luaWVkT3VhU3I3aGZmQzBWRElNeGRCamFSNEdrQTFIS1FEaTRPTHZUa3FNN3g4cGNjNHYveUk1VU9qTEp1MGZwODlCd0s1OEhhUjhVbkJWTTh0YU9tbkd0KysrZnV6blNnekJ5TDZzMGowY2JTbHhaRzBicmR0QTRHRFVrSS9rbkdhMld4cHpUY2pQcU9sdUhSSFhqZzQyaDBZUmtaODZkajl3NWRoeFI3elhyMG95MHpabU96OXVFTmRFbnF4a2g5QXVyV3l0cXJFM3QvRFA3N0tqakxTZllXNTY4WnRNSlIvUkxjaW9YS0FyL3lUQjkybkk3UGd0cnRic3VubDNDazlVclFLUXVBSURQWVlZR3pYcFVWdTRpdlBIUmRPQUxXT1ZhbWJIUWprellxSGtGQUFBcm1mbElBN3JOWUlFdndwMmVkcEwwaExjRy9LN05seXpNQkYrRTVzOFhEZVlWVm1nenJrZmxQWW42dmpCWndXZmpubW1KS2JuNmlZYW1wVWRsVzJtUEt1dlNSQjBYMVJtZi9VSVlBR0FMTTNla3I2VjZpYndWc2VyNUVWUkNSMlJCUWNOOURkWWJuQ3R0bUZFYjV6TEQ5SWhYdlNMVUU4b0VZemo3NVcreUJTODYvQkg1Ky8zbnByaDVKWlExb3IrT3lLZVdBVGlLcUdLU3h2R0I0L3Z5VThtem1IZmVwa3J5UFRkeTFiaTJxZ0JWQTl4Z3JiOEZWVkIrMGU2RE9mSmh2RG8wc3NXMlBQSmVXZEpvNmgrcFdMS09Hb2xjbllqcnBEcnJ3aTNJZjhMYURJUEtsNDc3SWM2ZjY4YjJhMU5seldWbEdkRUgvbEwrbG95ZlFXYkJsYXc2YTI0dDdQKy80MzJTckhDWlQ2SmwxOGQvSmQzWG1CejFFZFBZYTMvSjI3WS9iLzAxZGdoUjFWK2t6VWxrUFJLRkUwN2NmTzdJbE8yOXJ5Z3JqZmoxYlJ3dGdhNTc3VFducEIrbmNqS3kxTTFmdlI2ZzYyOTlhWnJWNjRsM0RTbU90SjQxd3lyVDJiclZtMzVCKzlWTW1aM2pwakVPSFpMc0xXS21ydmhNOUZWNGZqbmUwU3RaQ3BZTUFNQzFtTG5LY0N1Z3BpczBPWDNlTXl6YU02MW84Q0Zrbmc5eWJzZ1pnOUM3VURPbUd3QUEzQUx0a1FhWVNIWmhzanFGNjhBK2ZYT1ViWlFoUGgrYzZNL0pyS0dTQVYyamhzUk1DM3JWSkZKOFNXWWR2TVlNREJsd1BMMGJ0WG1HdVhPS1VmZnNFVTgwSkU5M1VhNW5JYzN5R1Z1VTIybUc2Q09OSnkwWXo2VUJBTHl4bENVSmVpVmpsT2lWcDVxMUxFRk5CRGhxMFFRN3J1QUd1RXNkYmprc3ozaEZjWFo2WUhOZ1Awc3V4RWkzUHRQKzNnWXZyRDBjblQ2aWZpUUF6aWJpYjIreDhLZm9TcTR6Ulhqakx3UDFKbWx2c0hEWE5OcDU0N0FQUUJxc1U0ZXhhK29CNVJnMUl0SE5IMGE2UStrS3pRbXRScUhhcUp2eFNDVkw5RTIwWUNOeUMzTDRLNDh4STZDeFlVMjk5a21aVGJhTVRMN1JOby9HejJEbWZWcHpiT0IrbXFPdEl2dUhHYlF4blVLL2V2Z00wMzdNRnA5alBqbHppY2llWEEvUE9Ja0xMZm9HeWdvZllYUkRQRHVQSi85Vnh0WXgwQitKUjNPUHBPSjBDSTJUcnRjUWRDYWs4L2ZLZnRXTGU0WnRacjQvbVJnUGpaVGR0TUlhU1VQQ2hjc2NaOXJQbjB0THB2R3NSZ0NBNzBEU0VWNnRIWDFjdUhLckJYMEdob2x1bTdUZlpRdytMM09uZzNrRkFMZ0RpeDlwQUkyVnp6U2lMNHVVV0x3WUxiMmhJOVdsMm1WRTFsTnhrejNMa0xnS252NGJlWVpEMitFdTdRSStnYmI3UTByd3dQbUQwek9lYUJoVmZhVlpNYlBvckxWOENSRmZ3KzJZOVFnREtoQ0FjeUFLcWdyUnE1bmxLZ0pPdU8wRDlQQmhqSXpqMGJseXBlN083THh2d1JFZFROTmJqZVF4bkVHTVdRdVN4emRZK2VCTUViLzVVaW9UTmdBVmpkWGJUK2JnTTdReE9CcnpaYi9IdjgwV1k0VkZEOEs2NVZUbzM5MmtOeHk4TVVtRnNLckRlSFB1akE5Y2dSdmlQV29HNDJndVVwc0svU0Y5UlhsRWQ2SmJyd3p4OERVOW1hOGpaKzBnSmVQV3MvV3ZSbmh6aGtzeXVLY1cvZU9mOGtxenMxZm9EeDFlY3k0d1N5cmQ5Vm4zbzk4Zjk4VkdTM1g4K2FzcE1ya2NjaDFxSWx5UzVhbkxHWTh1UGN6U2xxUFdybWVPV1dYM3NwSWkwbDROWVNFVGFXWC81VlJCdEhoLzJ6bkVmMzNZcTJHT1dIR1AzQkVKYmVZZFl0T3FPakt1VnpLNi9seUZxQ0V4UVZjWVJJZE81QXVwKzdMMjYraFArRlAyTmwwaEsraXhvelBUOWxNTnhTNVB4aWtjZmJMQmhaT3k2QmZxcFIrbGh0ZVhUZVlTYjU5SXZKUStNOHF1cUN1UFk4Wm9sdkpIZHlqZWVBREFkY2pNYzI1RmpNajJsQ0dWRldXOUJRZHVpK2M1NE15dHFtYmFaQWQ2ZHZJQkFNQWRpRDNTOEc4NVB4Ykw2cG0xYzdUU2EzWGdYaFk1QXZwOHF5clBxYnBCWmpZcGVlWlZTWm1jTDZhV3lUd0ZqaGdTMldkV3habC9wWi9ucXY1emNCbEdwa2pQd0R0dXUzd0QxR0p2WVVxeG4yaElWVm5oKzllYXl5cWpCcTl2VDdTRHBYZ0F2cDJrbnQ2OXp1UklLeFU5QTBzbGVQS1hZdXQrb01BMUdwekx0OFU3cDZMTDdZcTVaZTI0cERxc3NPVmM5SVZGWHBlTWhvL1V3WnNmYy96U3NLOUpLbjMyZE12OGlxenhSUFR2TW9QSXdNSWdCT0R6d0x5ZXk5T3FxK1I2TVY0WE9BQXFHQ2kzWklaakJWMS9BeTZsNksxdFBkeDhzMm1relNPUHMrODF2K25Zd2xpYXo0QmJidFpneW53RmRkS1BIcW1wUGhPc3BZZTdmQy9LL1RUdjNma3pzMmQ5cmZRYUR5eXZOSmRXT2ppays2ejhKZjF4NmxORUtST2JLL3FZYm1hWjM2ay96OVNZV3RuUk9rSHJBM0IvanRERXMzUk9wZ3dBM0NaTzFQOTR4S0N6M2tZQ0FBRHdoVnpoZ1psVnhwRUxsckpZTnFkZlovZmoxY3BlaXM0WXVFUVBBRVlRV016Rmh0anFyY2tSWGxuTkEvNzFUOVN1c0pRRDhNVjRMRms4K2Y4eXVJTXBlaHYvR2cvUmdSUHZNbnJuNVJaNmlvQ0crSHdtVDFodXlQemVyd2F0cEZlQXlDK2c0VlRpbVhIMEJ1Y3pSRnVEVldnbk5ramh6Um51S0lxSzhLUzlCZHd4SGIxNnB1bU1JMGVvbjUvOUNBaVJzWHRuRTNvRWFIQmpjZlJrRmJCaDl6enZEOTBjYjJxbWJmcVhMakNTMFFUb3hwc2hMWTRSbTMyWDBESk9yVUw3d3B0VGhsWWZTWFovTGVYalpEelQ5VEthVWdkZll6NS83UEw4a3VwN1BqUDVuZ3V3KzB0ZCtuMXZ2L0RXU0FyZlJtSC9sVGhhcHNkQWliNUNHelY2YU43TVJtcWxSV2taYzZObFN2Zkw3ZmU1T081YUN4ZmF1SFpsYUVXeitjcDczTk5qTXh0bnhCcHR4ZjBBaVUvNExJU0VQK2ZMWG05NVdsc3J5eitYY3FYRTBzMXc1SkQ3cVVFOTNwUzRNQ082bzgvalhUTThkY2pjazA4LzgvbTRNclYyb0dWSlJyeTE5bm52VzlONzBuM3plZG91Vmw4VDIrTi9mSzIyUDA2dFRONXQrdTFmVlVpbmtmMUJyUFQxMWkyV1hNdG1vK2xHNXBiazRMRElwS2xGTDdxcmQ5UHlKZXlJZmhQVlBPT1lCTyt5Y0dzZmtmTnF5a1I5TjRWbTh4K0hwS1dlMTFxOHBiMEtJOCtUcmsvTGxTZkZSOHNBQUZ3RGp5ZUMwNnF0NUt3aUxyNHdaUllsamNmeW00bWxFMms2Nk1BRG1HSEtlY3VRWkIvUjRkbkYvL29tRUFEZ1U3SDBjeEhpcGJUVUVQSG11eVdyckprcldDZ1pYNFRnUng4dW94SC9ldmM4b1A3cXdyWlpZakNXOUs1N3JmNmU0U3UzTEdmTGtKQjhLeVArZGs4K0RzdS9SOU5wc3NCWGtoaU92UnBxbWt4aHlyeUNCYmR1azlJemFXbDRIMy9rUHJnUHoycGx6dGRBNDc1Mjlsck9ZRXM5QXdCOGtMbTAwMnVhNzRYb2JJbVp1bm4wellnemR3RzNJR3JxZHR1SFMyeTF3SWFSbll4a2Q2MWNicTBoTlBNdGhrUGdLdHlVK0d4NHRBNFpZR2NkVDNZQ2QrSFZlSjNGZXJ5aUZhbDhNVFV4V2lLck5SWVpBRDREellNend3OE0zbGpPRlFYMi9jWWF6QU9BeGl4akZmaVowTVl6OXlzQXpPRUt5dU81NEZiaE9zK2ZINURVaysreGtyLzJQOFI1azljRmM5cHJqQ3ZVNFVpcysxM1FGdlNycGR5RFAyODNyRmlRcGkxbTN6YVdzcUNOd0JXNXp2ejEvbEREQTJ4MUw4WkNwUG16TWtVOWFaeHdaUng2SHQ1bTgzNFFYck5peG95ZnFUbncvaE1BWUFXWDJDWWRMQnNrT2NMNWUrUWIzdHI5WUxFRkFId3o2eDVwWEpCVkM4OFZMSm5Fdy9hMjBMdlVCTCtHMDkxaDc0aTdRY3FPWHl6dUFOd0JWcHNFL0s1SGJVMW11b0xCaVdoTEF4eXhBQ3lsYVJIOUt5T1lnNTlQZEVIRkFud1pacmlLdWEyYk4xOHBXS1lCR0diQ0Q1SFoxMWttOFpzL1kyZkIxUGZlQUhhQ1AxVGh1am5UZTM0OUQ4QXNKcWtNeDBFNll0RTByK2Jldml5Ukd4YkNLeWZMVXg0UjFaaDRxR2ZnQXJ1SFpWVHloK3BZcjd4S2FjcThaOEdrLzJ5a1JYU0t6Uzd0SzZMN0RlVjRubGRjMW5XaTdZTWtZNXlXMEVoczYvNzc4NlBQUXNyNm0yY3pRZnNIK3UwOVVYZVRubG1ZKzhKSUhTaFZ2YUsvcHJDKzM1WXhOS0tXaEhlTWFBUFpPd1lLa1JFdDAwTmZ2eG1idGVZTWU1YnBDVy9CK0M3czlhVlVjcDkwSEcvU2w3STljYjJVL1pPS2tZV29DZGRDLzFWaHJyR3ljdXhMYnNIMFAvTzFUWmxMVVJuYW5CTDZ6VXB1ZEVtT0djS2srY3FOODhKY2o2RE53OGFFTDJsRW95enIvcU9QSDdRd1hXWTE4amNsN3p0TkM0WHZTOS9lZjFWWDNENDkvVHZDckg3T3lQYlpTUGsxa3NzYkdWdWFUY2VNYTNQYUVubldFL1ZORloxbGlMZnJiV3VQWUs4dElOV2xYQUt1dHA2N3pOQ01hOHJGbWdvQXNJRElpamVxTXl4UHlwbTZadWFPamNxRURqMlJGWjNnZmFqbnpTZWw3YmNwbkFuSVhRTUF3Tm1jOTBoanJodnJFdlNMd1d5NVpWQzIxODhocGVzWE41TDM3MjAzUjlsR0VWTDZQaUY5Nk54ZmNGVzBxTVJYdzY3bFdVUENYWWxPanVRTGx2S1VMaThYTHVIWk9jenlPMGZ5U2VNVEFDZkNvN1kvUTZsWFU5elRsci9acldIdkhKTGNreHlLcFgydEtuZzB6Nno5dmxVMjE1WWZqM2FqTFpnZUFQQTI4Yko3RTVKMnhROVNNNWFmOVJ6Smt4NG9hQXN1dHdDdjJLcUJVL0M2WVZmZ0hVYXpkb3VITTJ0NzY1RXJ6VnRwV3dnbGVWM3E1aDk1R0NuanF3cXVJeW1yWnpqOExrZlFEMUJyQW1FaHlwRngrQUV3aTBVZWo2Zks4S29RVElFNXo1S2doc0UwWmpndmdKdjZjTzdYL3Bta00rOE0zUUUrQUhQQTFFQmFUMkZuanpoYWgrK1pBVkxyUit5dUdOQXVIMDNtM1lhc2pkQVc2bzdrZ0o4N1YyeGdSb0cxSFBYbzRMdlczRCtzV1YrdnpCWHZsSHFaRkx3YkpDdGQ5R1dacVFUdVYrSUdnL1hLSXcwQUFNNWtsUjVhSVJjNjh3S3M3SVNvYks4QjdUR3c0ZlFHQUh3YTMvdElRK0ZLbHNRc0o3aERadnEySTYvMFBnYmM2aWFlNEw2SWMyWC81Qkgxc2d3c0FQSjROVi8yOVdIUHk5SFJkMlNzZkdkb0RHN0o1NTdqZjlXc3RWNFl4YjRRZ0JEd3g0RVF6UkdHUWZYUm9Ic0J1QmlXZTJpQk8wZmFmL1NtK0c4NUs1ZE5JR0s0NDgyTU9YQS9jVWE3Z2pQZ0RNemtacjQ2d2lvcFN2SWZSRnpxa2ZSTHlIcmMvdUE4VGkzYlBwdThRbU5kb2czQitYZ0dtZmZYNVJoTWFhUlRUS1FtSFltSFNYZER4UFZaV0R4Y21hVzgwblVmcm8wOHoraXlGa0dMWnVTeDNucnJjelVTM2g2aG52dG8yNktldnpMZk5kM2pqK2ZSc2MyU3pmZG5YN082dVlQMmlxL2RmWXpOODVwSTA4aS8xdGpLMVBBNXhxSnRhTjJQWnpFYzFaeWV4WkxPb2RISHUzVCtQaStkWmJRdWZzclJtMEthNTl4UnI3bjhJMzN5azllcnRhd1paZjJ1cVhYLzNjWTJ0VlFmMnZoTmpxRkt4bXVqWlVuNXlJV203NlN2N3c0WmxsUkhjTmVjN05INXplR2RLOUUrNHRaamE2MjNpT2pVT1RMM2QxVWY0VTJweFhaMWs3NUNiTXVLaFcvWDEzY3BveXR0RDFmbitySktmbUlLK3pjdmpVOG5qUmN1UExwanNNWmljY1pyNDlwYXE3MDJMY24vdDRQSi9XckhRNjlRRnl3ZVcreitXSlpkZE4vTHBZK3V0dGFhTHBVTkFMZ2ZFUThFOTNjdm93bnh4VWp2MllsYXpKUVp0UUQ2Zk5HeUFDSGIrRjdaVDlxRXNqM3VIc0VkSWNvQ0FJQzc0MWtNUFZ0bnVwa3B5dlh0a0JhY1dZdGdEY1kxSloyMnl3eFNKUitwNEl0d3UxaklZdHUwd2NNVXpWMDNLdHNCbTdRNXd5SUZSSHhqM3Y0YkdYZGVJOGVxaTlkbzR2SUFNSWowU05MM3dNdTlUa24rdWhWNHRYMXhwTFAyKzVxRzZiZEVwWHpna3M0eDZvd0FBUGhKUGlha2orYnJ3cmtYMFpuRkVjZkpBZ3V3YkFCd0dOSGR4RXEvL0s4RlpYanZSNHEvTE5hTkZSSnZ2ZFlRMlFZWFFVWnhsZ1hpckppWTBwNXFRajlaM29oZjVTaFdhaXdBd0huY2ZFRzVwR3J5ZXBNU2JhKzlxT2ZKTzFzbStHQXlYbEVNcGhDWlIwd3pRVmQ5TW1jKzFqaDdaQitFZFp1ditQbnQ4QzVhbG4zRVE3M1BCSnB4aC9aZXpoRmxSZUxCZGJoRVgzMjY5anVqa2U4ekNldWkvbStrbFBueTIvSXlQTFVvcDlmaGhMS2ZOaHY5TndQMnhTbnVxclhSM1FCOER5djExQXhkTWxNZmpUeC9nRTRjWkdVRFdzNml4bHhMYjFkbjMrb0dBQURnNDBzZXMyeVp2V2h3QzFaai9wK1ZOWk1xRjJVVi9icVZObURFdGFJZUxHakZmend3YUFDWUFWVm4xcms1QUFBQTFnRC9IVkE1ODNWRHNHUGxmTTNzak1IQmVBOGd3SS9KejJYR2N4Uk45b01WQjBsd0luL3JUNUltcVl2K1Y5a1lxR01jY1RRQkFGRzhKNTFaK1lWMG1wYmkwa1E1ZlRwVlp4cEhRN3lDSjUrZTBMSjV3WGN6dXVaanpUTlIzd0ZpZE1idW8yS0NIT3NhWGZKaDBCT1Vmd0tMaitTeHBxNXpUYVZIU2xKWkVwNzAwVGZpcWhEYkhySDE4ZTgyL2VibklzOTVXZWpYMGg0eXlJN1FycUYxNWxlZjBtcTd0dG02ZWI1QVIwdWc4clN5K0R4V2VscFdNK3JqcWZ1TW83NDhobStrTHRFNmFKNEpXclpIVmluKytoTFptK2xONmkrZStDVXNWQzdhV0x4Wk5sOXBmZVJKYytmL1orOU1rMlJIa1hZTnA5SnEvd3ZzKzZPMjhiVlpjVHN6UXhISTVTT0R4dmRwNnpvcEJnY3hPSTVMZ2ZxTm5JL3VpTlYzU3dta2J4Mi9KTmdhQjZzd0tpT3YrMGlzanRUbVprYVNwMjVqZWoySy92RmczeDhYSDcwdmNlSUs0UnlqMm82dXMydjUycnBsZjdrNHErSFJMNml1VzJmN3hYS3ByRkxsMHRKOXBOYjE4SzZwR3BadThlVE4xYjhqK3Q2N1RuTnBhYnlXTHFXdFo5NmJUZ2p6RURFMzZuUnNBR2x6K3RWdzF2Ni9QcTBqZjRUMkdxSEpPWmszNnlJQUhnVzNLa256dW5XdWMxNEFiZ1dUVnNEQXlqaUVtYktITTBPeGp5Q3lKZE5NbzhoOTFiTFd6aUtmUEtzdFBUWlA2K0M1MUtBREFOeUNpSjVPcVgram9TM20wSUVuSmp2VE9CYllUSzQxVjRsS1NhSkRRbHZ6UzhRSTJOT0hXSXhycmk1Y21wTEcrRXlMa2s3eDU1aStNQWtybmVWREEwQm45VGlOUG1aWWtJWjZYc3VRa250SGYyUUdMY3o0WWhjbCtwVDM4VE94cFFHOGVhRG13Qk5vOFdNWml1cDkyU0o3TU42M0dKSWpuZGVhZWp4YW8wdU5uUTFaWUJxdDB6UWJjVE9lN3ZlVXhUMFBxY090OUtjZml0WVd0T1ZHTENQYkNyZlNZWDRmaHZtS1k5bW1GV1Z0czZqcE5MN0dxWThLYmZBZmFLQUFBQ1pCSHd4SEYwQkRMMlNtaUVkeVVFTkFiWU5tSk4wUXlRL2FhZEFaY01BOGhFdDJ0UGRSMGg2MGxHMU14Z2xiTXIwd0xwVCtRTGJIN0RqU2N2T1d2V3VqNzhqSjc4dnFucEZWSDk0TWZPWDNhSEd2cnhCY0ZleDJud0JubW85K3hXNGRrNDAwc3psaVRKL0VlK1NwQXJkNFdOY205UDZWOXNCZVcyV1BVYlRIYTdnQWdHTTVZbFhLUmwxcUhNK3FuODFaRzhKYnIyNjc0b1gwbko5N0FXVldtMldqYkE0NHVRRUFkeWNIdzIvRjNwN1lHVEtpTzhMcVYxeUZMSWJGK1ZPdTRpbEhDQ3VhL01vSTJPV3JxS01zN0NQOFI3VE1vNTl6d2ljTjJtbWU3Ylg2U3YxbFJOeXJHTzBuWitRdmFRQjRJZ2N1NjNEQjNCVFByM3UxOEo3ZkVvQnBTTGFTNDhreUFPQmtsSUNlL2s0NzRvdXBIdjN3OWZzUC9aazE1MHphaVprUHIrNkF0VWpUeFIxdENXWlRIejloamJuV296bFMrOHViVXBFZFZUbVdDZXFZZm5TSVhrT1BnQ1kwM1lEMWFRcGNrOUlQNFJScVJ4U1NUcmdHRHlROGIwY3RVTm9qSXM4Yi9yV01MT1FyUWw0cFhHTmRWbVorMlBtSkxaOGFWc2xLcmliZWQ4VDdQUUcrd1pjdnFXN25zMlh0MkgyVXEzYWdhbHpLa1JKWFJyMjM5T0x4WHJiS2ttUjR4b1pIZnNTeWJDM0RXd2Y2ZDhTbzgvb0RIQytyYk9aVTRRZlZwdW5LVnN5cWFwRUZpc3JLcjZDZXhVMllsMGxxbGZLS3oyeDRDNTZadkpReVBqemlrSWpValVRbnBaL2Z4b3BWTkMwcjB1WmVmUlNaKzFiNm5uSHB5Ui93U2lvaldyK3U4OWZ4Mm4zblFMMjB1R1dsTGRVVmpmMWMxWE53ZXlqRGV0N2FYeG1YMkE3U0xKUXFmVDNkSnRKR2RWbWU5RkU3b3FXZEltTWxLak9LZEovZSsxK1NsMDgyNzlHVE5HK29IWExudFZEa2lLNDRFZEp0UmJTeXBCbDc4VFMxWk5rQkFNNlBOSDh0VTlaYWphejBVbDFtckxERlVWYXZOWFZiM1dmZDRKRU40SEdIUlYwSDN2dXhCdHRTOW9oQkJnQUFvK25kemx0YlVFM2YzVjRYUnEyWjZNSnpWb3VEZEd6dGEyaDZpSnRYLzhSbGFFWkE5YXhyRlIzMWMyZyt4T0tyZzJtWWNHR3RGclBYcDFiU2VQOTY3dzRCUEkzb1k3TE5Jem1QTzMrbm9VVzNBNTRuSkNOV0JrOFRTSG0xUEppUkNtZ2NBSHdFelppTjdyVDJLRXUrckVhL1pXdnhvK0NzTEJxWEV1OUNndjRORXQwMmNmNDdzRHN0dTEzUEd3RTliOTVvYnlGNVpYbmZCS0t2cGUxQ3ovWTMyaERlY0U4NitOdHZnZlpiSU8zSHFaSDlFZWVScWZtVEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNKRC84ODkveVE5ZCtkKzkvdlczNCtmUDFxRmNhazJDNlo5RzlJZ090Q1hZRysxb0dVcUxqa2p4RTg5dWgzVTRKSGZ0RUxYNVFtb2xhcFBPSWJ1eGU4RmRPZkpvcklmQ3FtUG5KMkxvcVplYWFrRTNQZ0RQQ1VuZHdxWFJGVG1HU1R2N1RvdWZQM0wxdTh4VnVtMWRObDlZZEo5Y0hURU90bTBkK1pMalVzZmlhbVByVEVKS3orYlN5bWRwTUdzTXRaUjVKTmJFbGNZTXBlVytna3JqVEUwdEhnWHQzNVhZcDRxdDUxRExyTFhqdlp1elpLUkxScWs5TWd5OTVUMU5zUDZqOU5haERxUGhVcDdvZFErdFpYbnFJSzNEMGZYMkNOWnpTbHAvdGJWT1h0dDg4Ukl6V2tlcVM5OVhtbHZIVXFzem1KT3hCOVo0cHVrOGE2UFhkMDQzWDQxVk9NT1VPem5SWGg1SnE4Wkh0d0p3UC95N2gzM0tuTFViNXNyUzBrVmxUMmVtNlM2VjBadU95eVBsaTVhZG5PbVhQQkUzajFTblBVMUJBQUE0RzE3M25jZkZDd3g2L0J5U3RVUEM2WDdmdXdCdkh1cW1yVXhQL0NxTk1YZzJkWldySjZZVHgxNkxuM0xVUU80eDVtWlp0YjJXZHAzSGF0TVpXSDVvY0FYb08xL2l5SEtvcGExd08xcDc2aERSRkY3WktmVnBtTmJ0RVFkbTBJdWV4MDJqT2hhQXB5T1lPdGs3bHp6UHJIYWFsMUdMSFNoWWV0alQyR2prM2JGMkxxTmNEV2R4UlVUTmlGTU55Y2oyTVhwREhyM3NLU3ZpNDhkOHZ3VGMybDZLSHEvS2M2VEJGMU1CQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUNMcisvLzhMOW96NkVmYUwreThOZldyNmhMbW5OQzdCMnhqbEI2ZXZ1QWN5R055MEhqVmxJbm5pcGNFdWwwQ2dYcGdJcE1Fbkh0dE9tMllKa0EvTUNkeE1KTlZBeWNmVERzQ09sTHFaWTRjREc4UjBmUk5Lek5IdjNjZ1hkMDFYS3NzN3VpUjdkRkRCSHZjVko4dW16a0w4eEdLWHhhNit2NG9tM1h0RzBZSXEwaWY0R3RPTU80OEx3cGhiOU9SbmhvSUR2eVVqbVJNclY0UzZhRkoxLzBmcjNuNVRXV3ZScjJnZ3pwV0M2NlVDMXBJMS9IM0h3SnRURjhWWkgxRnhnL28zaVpuM3o5dGw4NVRPcTF6NHlLamlWdmYrdWw2cktDZFdCUC9aZVRyOE1Lbjgrc210Ni8vanhhZkhUOThjeXRpRDdTd2x2d3ltclZieTB5aXhyN0cxYXYwZXQxdUx6K3AxRWE3MXQza1g3cUlzZHZ5eTdDR0Yzcm8yelVNZ3QzMUdaSEpLTTBYM2dKaGt2d3JhbVg3UzByTXYvSk9rWFhPTXZFMlRRRGMxL2I0VHgyeWwwVXk1TDNqaVNhUjdQNHZKWXF4UnIxQUlEN29PbWVVYnJBcTk5YTlLQ1ZWN0o1TE1zM3BaUHB2Qm1WOFc2OVdyWUpyWXRjaTB1RjVwV2dBenBxamdFQXdCM3BkWGxEWnc3QTZ6UHpMTGcxVmFlWnZtcGg4UzlNbXAvMVY1T1pqVEpmNFpLUDIvUDExVTA2V2pjcG4zVXRoVWNNRGdscGtvMTRuaEtkb0p5UjEycXhSKzlIMm1Ha1pOZkpNdWFna002TTlOaXNHT3VOK0VRajgvRjF3R3E3d0F3dDd4TU5hWHRrN1pOSGFwS1JlMVNwL28rZFFhTnNHNmdnQU9Jc2l0cXAzQW94STFkeUpQbmd1dlNZaldBNkt6dXJJdnJzMGJPTG9HVnBRNk1rZStodzhtdTV5VkVIcWY1YS90TVJNU3k5Ymd1NlZmTTBFRGVZUFBNNzJ0RmdPTllyalpUYWxWU25pWHdsdGFXNzhjVlVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdJdi9ubi84cm50KzAvdlYzc29rY1IxU244UnpDQlhqUVB1QktHS2V2YWFleFpVVU1qZmNVZFVrYWJsdzdPMU5LbHhOVUM5Z1JETFpoYVBOWVBFbW8rR1RDUEhzWXAreGdiUkcwUnFwM1U2S1ZhZTJYaWl2VyttcVoraFcyemUyUW81QTJSeU41enhsTGJMcjloMEd2QmVJZER6UnVaSmw3MEZObTlDd3JheXkxYlBndGpQc0xpY3IyUWtmVHMyVktjNHdrcTBXUnNDek16MktlVWNoSi81UlN1dHEyZHl3TjdGZEt4S2g1aDVNMmsvcmVWUlhyL2tUTGlsd25FdDZDZHlkc2xkRnk5cVEzL295VzRycE8zRnpKaVg3cFdKOVQwaGVRczNzKzI3ckRncFpsZlpYWmt1WWJ4MUd2UXRUK2lPYU55RnZpaXBMV2l6Uy9KMUxJSDdteGJLMmJrMUNHMWUzUkplQU1hb0ZoOUcxcVpVZ3lQZjVMYTZkaTFlbWt6UThBVVBDdU9qUG10M2NYT01yQzdaVjFhcnhtU01zMlFoc2NyZmxhR0dGbUFRREFIYkZjS040Rk53bnBRVHJIWm5QVU13MytjdVhmckgwQ1pmTkhjaHNTMXI2ZmkvanhzeXRGbVhoMnhKWlFqOSt5bHRsanpVcitXSzl2bE5McU00c29FYXRNS1o3S2huRjNSVm84Ly9UeDJlYnhDdjNETThYeU9vcEdrMlJxR3FrSVN4WVhIOUVjbm5qTWpFWThIU3FsUTZNRE1BWHZxeEZVOTR0ZlVxMWxwOWpqZm10dGFMSHNZTmwwWWoxNkJhY2lPb2VzdVpPYzhiUEJVQlB3MmxWYWVqVHUrZkJ1bEpia0EvdlF1eS95OE9janlqdENBUUFBQUFEQTFjQitBZ0J3ZnFDcEFBQlg0YW42Q25vYUFBQUFBQUFBQUFBQUFBQ3dOMmZ3UytJMWJIQWpIakxFTUpNQUFPQ2NRRDhEQUFBQTkrUExkN1JCU1M1VHdIdlFXV0hpbG5EOFB0YkhpQVBPQU5pTEVneC9rWjNobXVxSUhnNXhhclFiejN5YVhLY2xXZFZ5Q2grOCtxT3MvZ0dBQit2UmJtVGhtbE1WMWdsbTczZ2Fuc0N0aVJ4WnQxc2x2R201Y09uTXI4VEVhNVpFeXlhRm56M3JMN1BSdS8zOVgxcUZiNCtyL2N4ak1wRTNWU1QzdlRHS3FIYkk3QjMwZlpHUmk2c3B3dCtXTEMyZDUxekVxRXdhN3VHTWk1Mm5qVFE4cTRLMDRYZENGNkRXWVZITHNzaUI0ejAxTVVMWXo0Z2pkY21xMDZTK3ptS3FldGI2N3RRcTArTmNvSFBJbXRlTmFGMndLZnAxdExka3ZEUnRYcmo3OCtpVWtaYVRwYStpNDFUcnM1Ujh1akZhUnN2NlFmTkp1dFFhcjNiWjBhK01TdW1MTUxla3I1bDY1bkVtZnhYR2pxaXZwUyt5RjBacWZvZC84a3AzVnVlejR6VTdTOHJySldJVDBsYTE3c09TU2UvUE05ODVRN3FCVE1yeW1qcVJzSkw0TWtiaVZaRXRxcU1ScTJoTjQwdmhyU010NHZ1czR6ek50VU5UQWdBbTBXTlZXaGFzbE43MHBOQnRFNUdqTGt1VkV1VjBaaFlxTTBTUGVjMklsa2JubHZ5aXlQYmVrTFJRdFNDVlBhcU1ucm9CQU1EVmlMaEdKWjBmZFV0TFcrN0wwYnJoaS9nV3BGMWJLeDRqZ25UVVR4VWNkWkQ4MFZ6ZVRIeWZvc3pFeTVCODNaYTdoeXM3RTZPdVRxZmk4MzNIWkx3TEQ1YmgyZkZIRGNUb3hOYndqbXZMVCtXUjczVWlnYlBEanBCTTFFRmVxd25wY1ZpSjdoUHkrazl1dnllSktzNzRubEhwMVJ6V2pNTE1DTkM3QjdYVUZBQ2dHOWJFVXpQOC9oTjVsYUkwWHJjK3lRTUQ2ZDJUUW85UGdXdktJdnlkakxRV2RkZEh1ckIxMTA5bGVPN3JWRU9yNWJsQ25iY1k4WnpzbmkxcmJvZ0hjL0FPZUlHSVM2bStabVhSZkVLNGh6OEpBQUF1em1QWFFoZ0JBQUFIVUJVQVhKa3p6R0JvRVFCNmVONE1PdUNPODVHdERCMDVIN1F4QUFBQUFBQUFBQUFBQUFEZ2ljQTNDZ2FESVFVQUFBQUFBQUFBWUFMNVAvLzhYK0dQZGEwcDZhKy9KK3hNUFllUmdSamE2YnhvVzNBMkJwNE9FVDBFNGpaRWp5cGdUa2V3VkVVMlpHd085VFNxQU1BSzNmeFloMk5Rc1hqbkx4ZGVKR0hHTVpFdzRSNUNseDNaZXFaZFZINWRScy9Kd0ZTV0ZCL0ZjOXpuSnkzM05UYnhTMmJTeWRlbDV4eWpUMGZ6dWlTLzRrYWVjZFo2SEZmTEtkUjdhaXJQMFdZang1aTNmMnVzaGRacFdPNnAvYlVxMXo5T3BFZCt0WnhVNzRFcGt4Mjk1dng4UlF0dFNiKzg2QnZWMFRIV3BpdmsrSnJnZkcxU0VjNSs5dkF6WnJqQ2FLRzljOGhWbWVydldUcERzeGg3ZEl0VzVteTBPcTNYVzNsVmt0YWZSV0loSmZybXN5eHZTM1FtOGVUTmxXNXZ0UGFmM3VaOHVDVkRvaGpwTFNXaXliS3VreEYrQUdKVE14SGUyNHdNZzFhVDVnalYwTWlJbFpGTHo1WEJkV2RyRTF2ZENnQzREbWVhdit4U0lKamlVV3RTM0hrMmJOVTJ3bWtCbGhuaE1UTzBNbDJPV0NXL2xYNlVDV0taT2pQS0JBQ0FPeU10ZnRiYUFCMTdNZkwyVXQyRE80MEF6dWp4K3JacDJaSWhzU2tqeTluVWNha2xsSndLOUhyR2J0c2p6MXYyYUpuaFJtYUlHRytSTW52cUJGb1o5cFJRZWJ4U3A5bW9sanBCV2N0eTEwdFJmVFRhd2p2eVJyZ3BXN2VEWUNDd2hRRG9RdnppTmFNa1JiK2RZV1pteHVSZGxabVV2TWwyTFhuY1hqUFdFVUF3SGJOTVBCcjdkRmhQc2EzdUhWSDJqQjBXbFh1cG9UZWlZYnoya2plZXlzYTgzcGZlRFNBWkQ5emVMYnFuU211UlEvWkorR0lxQUFBQUFNQUR3UDRCM0l0bmplam56ZCtuM0RFMDgzNDh0YTBmZHQ4WmN3b0FBTUJ4WUJVQ0FBQUFBQUFBaUdEREFBQUFBQUFBQURnVEIrNVJzRDBDQUFBQTdrZit6ei8vZGYzKzlxKy9VNXpJNGZpOUo4ZytEZTFJQSszSWtkRkhqUUNnTWVMQXZvYmlCb3E4SHM2REdMVXZwZ0p3R3J4ZmFjSDZ0Y0p6NkhJSmZpRkgrakpCeE5RREY2TGxhTHVoaFhxUFpZb3FpVWdkdUx5ZXpZbzFxZGJYL0YzeVgwN2RWTU90RTN2dVA3SENsL3JScnpqMk1VcVo5OGp4anJXZU1nY2ZnZVVxSTNwR3NQZTh2Qm4zYTh5aGQ3QlFGN1ZabE9OQWYvSVcvcm9Gb1N4TE02VGduR3JyNVo1NTYzRXFlSFpsUWFQT3N5UklZMFZLbGlMOTNEdU9lOWlqYks4VHlkUC9XdGt6am9Wc1M4L2ZiUjYwbm4wa3lxWHhkV2xkaFQ3NVI2N0xINmsrUEdPRHByTjBocmNzei9vVVBmZlJTaGV0ZDh0OWRrSS9nN0NLTTZwZ3FXc09yNHFnWlNTaHJKRW1YVkJHdE5kYjF1TW9ycVdRU1FzQXVEZWF5bXpWUjZPdENGVi9PVTN5RVZ1MEtYZ1hBZThhbUl4MEhwbWEyUldoSnk4QUFBQlpIMHZwdkdzRHVBbWs0MTNHam1Cb1NBZjFGY00vUng4WWk1L2RXdUlpZmcydno0WEtLb2E4SlYxaXJvMzdaV1ZKWmJmNlk1TlJWbVEzMytwRThhYm44b0N6RTNMVDBVZFV4alRleVBZK0ZqV2lJcHBqQnExUE5EQTdkcURWWFE4QWNPUDlVcXIxMm9WMUxuUmtmZUx5OXJpL2psNW5Ma0cwRVNObUpocjdkSGpuNDFYbTBDaFg5eUgwS01kZTJhMGRqUGs5QjYrTEllamU2T2tpcnluZVlxTGppNmtBZ051QXRSQUFBQUFBODRDbEFjRDEyZnVSOXhPQnJydzM2Rjh3R293cGNEOHdxZ0VBQUFBQUFBQUFBQUFBT0I3NDZRQUE0TnhBVHdNQVBFQlhBSEFOdnJUSTZEbGdyQUF3QiswZ09NOUJjaTN4QUl5bVUwZEV6a2IwSHZKeU9hSVZYdzY5ckM3ckU0NUdma24xdENlWmcrdlN1cjQ5ak93SXk0TFNGSnU0NkdWcDVnZTRJTnFKWjl4Q3lpM0k1b0pMVitpSVVlQTlqNmZuOU9IbHhxeXk2STM1WnNLNjVOOHZ0TGxQR2NxZmZEK3ljdEdyUUUrK2RzSjNheEd1OCtxNnpjTHlIc1huUEJyS2hYZU1XSFZwdVUvSjByTHVjNFkxYTAzY0hocU5WVzg3c0UyWStmRXV6WUhONThBZGRkYU9FdjBPcjArYXI5SmxjbC9idVJOckwyMGR6cVQvbGpLS3U1K0xFcGFGT08rNDlhWlRpdHRrbGZKS3g3d1dQdDFtbmFKLzcwMTBYbHJwaXlPUEZlNHQyeFBQR1JKYXVwN3pQYmZycnk2Sm4wUFdWMGxwUEo4K1YzOHRjNU9iWVZSbjFGZDJYVFR5dStSYW9vZVcrV0NOTWFuZmcydkNPMjEycHZNZzJRRFJOWExFbWhvdHNuTEtGRkwvRWRXaHg5UzJtaEZTOS9hcTNvNzhMVHNUNlZxU3ZaM3YyL3c1NlN1dmxFOHFDd0J3UDdoNXJua3ZpbkhkVW1pWEZlSE1yRzNScE8xZk01SHRFWmVlNjVSV015S3lJSGtjd2hFT01GMEFBT0F3M004MERCbmVkSkZ3Y0Mwa24zRVJkbzZoVFZ2bGIzWWsyNVJOcnpkVnF1djkrdjlxWUM2QmtZSGU2aWlRNUVYS3NIYnJXbDFtN2FJMXViVS95K01EcmZORjRxRnNyb0RrSzlxTVltVnZWa2I1MlRKL3FlMHRwZG5XcTBGR2dwblJnZFdSa3ZQVHVrWW5nS2ZqVlpJMG0yUnVKdHVmNXBVdFRkc2toRnYrUjgrYVVZSmxBZ1hMREpZYVhjclB5UUJOYURaUHhHN3lQQitNN2hvaWVKZjZSTUlsV2RvUXZOVFFpOTVvait4UkhZeTVQUWR2WDVkZ2ZFZC9lVTN4bGlMTUw2WmluQUVBQUFBQUFBQUFBS1BCYnZzWlBLV2ZNWjdCYkRERzVuR0d0a1gvemdOdEN3QUFnQWNyQkFBQUFBQUFBQUNBdmNBZUZBQUFGS0FrQVFBQUFIQnhYbDlNL2Y3dDY5YXlLVUo0RTdVbzYyZnQzRFhnNFg2MmpMWUREMkVaN3RpWHRiTnF3eks0VGFHTEFEZ2NPcCs5cHhORmdmbHhZNktuOGZTbWV6TmpsWmRHZkc0b3MyLzJyRXNxbTJzUDdpWnQvSFJJckRYMjBBQ2pCaVBOdzJsSkx0MW9ScFZWSEdHdGJYZWtabmVXelIyenVVZTl2VjlaSmVIU1Y0ZTdxaUtHZit1VzJmcnNDcXUvczQ1RFA3TTBzMTFHNklpOXloNHBzelhkK25xNzN0cmpQanBQYWZyaTB0UFN1bHNHbE1XUkEzZDFoalhleXdnOU5zUEQ1TFdvSnBYNVhpc0gxK0d3ZmNKK01tZTQzU05XbXFlSjRSTUZBTlJ3M2c1SlYwVDBVVnZDbmF5SXMyeGJwY1lIQUFCd2ZrYTRScm1GTldLczk3am53SGw0NzcxZkhXb1pLbVh6aDZPTXN2N0VWUkVHVzZ1UmxEZC8xRUtGVENOOEs2TjhubDRyZCtTazY3My9udmFpVC95ak1ySnlEWTdDN1ZMcjNXOVFWVUxDUnVCNUFrdTV5cE9heDFJbXh3UHdWQnJuaG5jdHlMU3NnSUtPV2xjdGVjR09ETFFmUUI4OXp3ZWxkRWZNc2VLOGpyeTU1RTEvV2M3NlRBTmNrc1VXeU1IdHZlYjE2UmthWC9VbzQ1K1REWEErRkVaVXkrNFQrSkRhRmc5Q3dkN3NzSEJsNDFwS1g1emhseUh5elhzajYrcDVRMW1IcjFUS0t5RmQyQXIwREpoTngzaC9FcHo1NVdVem54MUswakx0TEJHWDE4TjN4TnFNVHUrczJZWkVkb1p4OGFVeG54eVN4WnpybjZ0dWEwQkNQQXZ5ZDVvaWRYQmhRN2xyUm5CaWFpU2t6T1FITkRPdE5HMGpwR25KYU5sYStwemF0S01YWDZ1dm1UR0pXKy9UMmYvcXROWDZ1VTVQaEZqR3E1WitNNWZhK016ejRnai8zS2Y5ZlBmejQxU3BqSGEwZnRiU3BJSDVhaEZrckZnaW1vcmM3SWlNekNQbW5ITmNzL20wTXJXNmVhMDZtbVpHZTNoMXBGK1g1azBkN05YTlE5OGNXNitmYWFNTDJ1RitvTTVybERva0pha3R0L2ZaMDY4MGo5ODYycC9XTW50MlphMHdaZjZzVjZtZHZVd0lUallYbnBNMWtHTmxHTENQTkp3bVFLdkc5TlFwcGRqSTJxTWJBUUE3czZoNXA3OXVOdGIyaU1hLzNSZEx3SUMxNm1kSlVOWUlXdVpiSDBmSzV0WWRUaUgzTnI1a0lnRUFBRGdIbGxHLzV6WVFETUN4UytPTW1UTFM1NS9YZjBwRzB2TGoxTUx0LzBrVzZ0c1c0eVhmWURMaVBjOGp6cno3dEo0UGFiN2dFWDVMUzBsSThkNHlrNUYvdWY4V0x3UG81ZTJ1bXpoRnFFdlFjcUZsOGtmUGs0bldmSHM4MFFBRGNBK214bmdBYm83N0ZZTU9jNG96QTR0bnlaZk1TbkxkUTlTS0FneVdIdTZSQzA3UHJPNlAxdUdiamwzdkNtdEhlbXU4ZGxXdlF2WTgwd0RIUS9wWCtwME81WDJPV2JYV1M2K0l6T3oycjgrZnY2OHNUaStlMHg1bjBKSjNwQmpYQU94Rk1jSWJGa3ByVFN4R1VWYjZKeU8xcmRsR0paZ2VnRll3dUZ3czVsWExmUFk0d0tLeXpUSVRPQjNjSURJWFlHdkZiY0ZyU0VUbGFUZld1eHZ2OHdaOG1uNWJwOEttcnBONUpyRGwwVmpIKzFzNm5sSU9HYWtWV2pWUXEwYWJMVXNqNzFoV3BJelJmY0FsTGI1cE92SVVGYWVzMXRIdC9kS2lSMGJMckl5bmJXM2JFWDBTbE5GVVpMUW5EN2d2ZDc1aXhCbFBJMWtaSTlyajJERzBObjJLa0NvVzdpMWJtNlh0a3Vzdm8zcGR6bnBwYzFlU2tYWWsxNmJhRGttVGs1TGZtK1FwTTFxSEtNSjlSdnp2MGdPdUZsbGVJa3RMKzhMYVRERURPdVVGb2IzTWRVblVOd29BdUNCTy85MU1Wcys1WnhlbUlTMnY1Sm0wdVlSNGx2YmxYMnRKOXk3NVVOQUFBSEJ0SXU3WTJkdEIwRUhEYzVXZlMvTFczNmc2dkdYVE1vUzZTT0gwMmpYK0NwT0IzcWRuTjlvejJQZWNMSkVKN01ubmxiL0VSZnl0clcxQysyU2tNUXRhMldQL1JEK3FYSXdoRjYxU1pFUlpqSHFpUWJVU1J2RWtlam9NQU9CZkEzcWVhVlI1M3o5TTZWRFlvNmExWlgwQUo3TWFhNVQ1Q2FZUzdmNFo3dWZXT2l4NDM5QWNZV2ZlSHUrOGhhRjhEWXc5bXZRRDFjeE1HczNiTWF2N3Y3WkZMYldxLzUwRTFSNVcyam9kckpCZnZNY0hjTW9FYlFpT29uTU1jaTV2UUxEYVdJajN0SzNWNXZoeUtnRG5RWHAzeXIzaEZBellaWDViajh2QURlQTZPTElBaSt1UlYwQ0pDQ1h4M256MHhqemJzaEVXaUQ1N2NyUU1hWUkzVGN4UDVxTEVaeEk3UmdlMFZ0eVR6M3BMdFVmMmFIcktiTlhNalFia0laQzZyS2F4Tm85dFVlTHhZaTVaV1RXQzZaY0d2Zk04ditwVWxFLy9lTzk2N0pkVGFmMGxqMmR4WHUvQmpETHZlRi9jWWo5aTdSdE5TOXRyTDh6Wjl2TTgvQVpXSnJYaXJJaXRiS3ZNVnZ0S1NqZHkvYUhwTERTamRmYTQ5czRkZjMrM2tVUEJ3NHFJbUdFdFM0TzEyR1VsWDByK0lkWmdSdlRTTTNPa2EycmF3RThId1BQUVZLS1dKZ3IzQ0xKSm54bjZ5dnpDYXNkRERWTlhabWRZWFplVStwYjhNNXJmQUFEd0JGcTJ4NVk3dHBaNUZaY0w4T1ArNUJXVDc1dWkrRzFXYnhZbUkzMUFkdlo2d0tqdnFBamhOQThuT3puRFJ4aFNVaGt0MW0vcmN4T3Z3OE42TnFtVktWMUxhUDFtcFg4bUxmNmE0WFhvOWV2UUlmWlNMWVVyUXhEaEdYSFJrVEx6aVFhVzFRT3hWQ0lBb0FscExmQ3VFVVV3SzFjeVVyQk9pMndqVFdIeWVHVzN4b09LcUprSkRxTjFUbG5wTlpsbm1FdlMvVnpHdG12ZEx1NVp0aFVHem9tenI3S2puemxkTVd1My8yY1hyNmZuNFp5WGt1Wk1VQURBY1FUbk5aeEpBeWl1SVBFOXc2S0VRMDBEY0Y4cy96SDA4czJ4WHE2WVhpaDN2VWVaVnZqSU1yengrMkZ0NWJpMXY2UnlJVnRnWkZzZmVkZFBzNzRLKzJmVFJzRXlYaVBHN2FSdStQbEJLaU03K2dvSmJQVVp3UG9CKzNPTitYemszRGpTYXpUcXNmcUQ4QTVrcTF0SE5HbWpmM0lFSStmeXhqWXZDVDlLQmVDaEhPbTNZNThybE8xMUlWczdkV3UycEZjU0ZySHdwRExjcnNKU0R3QUE5OFZhTUxBR1BJaE82OEd6V1dOZjRIQzh3UkhlQ0VyVzBFeUw4Z3FUYVkvNzNkT1B0Y2Z6ejN0eEJ2OXJkeDB5LzIvUFk3UnorNlVCQU9CKzlPcGRyUFFBbkIvUFBDL0c5WWd5OWtKNkIvbDJ2dzJCMFF4T3lxdzU5cVdMcHlkM2RhRDlWSC9XejI2ZkNOZkcxbW8wOHhmNUFId1RIV09PZ3d0N2Y4NXhlWlVqeld2cDJZRDBTMUlsZWduTUthZ2VvRXZBS0xBK1RjTnNXdVVrdzQyNklVckMrOXRGV2dTNit5S1lpOEtNRmRhUzZkMnpSRVpYOUQ1b0hid1A2KzBIL2QwLzhYUWRrMWcrYWNzMmJ5NHQ3cTB5YVY1TFVqM2FwTVZnOHNpdXczdnYxdHRxWExvemFWRE9BWkNTM0pZdHg4Z1Z2b2hXSTFhYzlsNGRVNmVWUkJjKzRqWEg5TkhMai9sK3JSdnBDN3JLejNhTmF4aGpMSFBwVTlyMmdVZEhWbWtMTytpRTZ4WTA1OWx5elJGdDI2dFlYdDR4RnJtZlFsclUwanVmZk92WXpFalQ0YjZTWEZROW5xdi95cWtrK1RFYlFscmJwUGgxK0tjOXFBdzluMTVtRDcyMjNLeHlXdk1jUkU5VlI5MW1kb2FOWkhsQmI0Q0s3TGNpWkZxc0p5Nit0ZnhiRWJVYnIwRFUzQWJucHNNRWxQeDNtNVdmbE5IMWcvWlhXYTFUYThpWG5ybkNTN0svQW5HRU9YSWgwd0FBQUI0TmRRRm5JeTNzcnAyd2ZHa3p5MHJKSGd6SnNUa3pqQit1Q09rcnJWUldsallHR3JrelBvSjN4enFySEZxbXgvZmI2a09xODJwbGFENno2UFBRN0V4ZmwrMTlUbllOUm11RW5xMzFab1F0ajJTTG5QNG51dk9SQml0VWlJKzZFbGoxbE5Rbk42dThXbnhpNUthMG44WUhMN2dwNzNIdFgwdFZBSEE2TnJyZVdKNno5WGkvWHVLRitSbGQ0M3hQWk51UUxDYW9sb3BteCt2cjM3M01jRENGSTJ5Z2FKbWVSeHFTV3JyRU1Jd1l6cEZYWG1iTWEzQnFObXQrWHYxVEpVeCttWW1mYTNXOGxLK1hyN1FYM0s1enVmUHN6QWRzc09zR1Y4QzcwSUpEUVRjQUFEWllkaHNoOGlvNmRNNkZpTmliNk5nVEVKeTRnMHMrcGxSNFN4K0R4NmZRaXZhaTBLalBqZzJlSkdQY0FRK2JRNlVrL2lzRGQ4ZmJ6L2QwTXMxVUhUT3hYU254dXhyVnU3SWM2NlUrY0J1ODcrWkdmWUxlSnlWY1dpczhLdWRtR08raFBJczc5am1jTHZkaVJQOU5maWF6c3E5S1RPVFE0VnF2UDNoZUNnQUFZQ2F0amdVWTRJUFowL0J0bE4xbGgxV0dWZTNERkgvRVd2anJUQXVMdklhNGh4ZnRZVDdwMDNJL0EzcjAzZlRJRzZXdEl2bm96SXE2Njd3L0Z0VmtqMEtTZjFWZi8yVm8zZGhuSXh3QW9ETDZCNTJTc3NTVXZEQ3pISy9RMjVlZ3Rmc0JBT2REK2xiTTIzc1RQWmZxWVBiNVlhcjIvbEcwSWFTTkMvaWduWExTOG10OEFFWVJPU1dpRVVuSFdqNlF5NmtXNndhbDlCMDM3SFZEUTAyRFE4RUxSeTRzZTNSemtHNGRYaFJoVE50YlhRS2RjVkdzbzYxNmpqY1ZNMHFMbVVVa3ZUazduSFh4UG4xWnB5bVZFZjk1anpLL2NqcGwwdU1ReStzLzBrNjEzdUZ1WGxxUXlvclAzSEhxdVF4SXM4ZmozcFpmWW1ocHJDZDRMZmRFODFyOUs1WE54VnQ1bzJOSmlWZVBDZFB5UmVjeHlWdlBGODlMUVZXNmJCNXZTck85OUlEakI3SGJuNEN0NzZ1WWZiT0VjZTFoalFFcTAyclRocllYOHpySEZKZU1PM0tjYSt0aWxVa0xTVUo2RGN2UXN2cWdweXhKVTBjWDllUk1yNVhKcGVOa3R1dkFiSlRkK3NWeWJjN0ZaVHAxeE1wV0tKczRydHhNN0E1ZTFqcm04OSs2aHBIKzgyTE5MYS8zM1pQV1N0ZGE5eVd2TnFkdWhIVGIzSEpTcDdOa1NmRmVNeXRxd3JhcmxJMzVVWVQ0WEp2b0thWTU2ZkxrcmVhUUx3OENjRWZHYlZKUGo3b2FDVHFpUlNYbXFrMExEZWZxVlJ6eUVxUEdJMnVGczU5N2xnQUFBQUEzd1ZvTVdKOVNzbVdXNU4vT0FnV3k2V3JPMzdIYUgyMC9MZ2ZzbFJuM2IyM1N0UTIrVjVaVWw1WXl2RVFjQUpiZlBKTi9wWFEwbkNzcnFoeEdwOU93L0xEM1FOSW8zdDZOK0hPNHZLWEt0R2x4NzJPVkpUblpOOUZoWFY1cElqUE5lZ0lpVlpGcmh4WWZHRmNITFErVzF3TjRrRThGZ0QyaFg5T212bjF6elNDc2RENUpHMTN6bXA1cEpGNlBSOWNoRUNDNmJlb3hhc0EwdENmTVBidkJHVVRzUWlrOXQvUFFiUFJkOGQ2Z3RQM3JlWDNIeTRodElOaU5rZC9DV0ZFK2RrUTlKTGk1WkszcFBVUEo4Y1BVQVNOMXVUTk5sTGVSc2ZEMWdZMGhBQ3FQbXlLdkcvYmVOMzIva0FNcUJod0tCdURsUUpmZEJPT2htRHZmRzh2TmNNL2Q5UElqa1RsM0oyeklwdTE0dDZYZkYydXplMFptMVBlRWxyU25TbTU5cGZUelpIL0c5dzlTYzJPZnRUdU82UDArWktjRVorMExOTVJkS0lQQ1c5UEp6SHlrNUhGRXo0S1dmYXBIWisxRUZ4TnV5WmowZ09VMFRUckszcGdnQXo5SUJVRGd3WE5qRDlYNVhoRmJDaXVyZi9vckxQeGdsaW5TeHhWZEFBQUFBUGFIYmd1eGRuVFNhN3dOTVA1RVEyTEh1aldYMVpvdjhyS2Y5WXBqblQ0N3k1ZzllWTd3ZVY5Sk9keFhjWTJhdFIzYkhmSGFDamRoM0pHamZNSFNMRDlpTkdOWlBRRVBlV3dJd042TW5Gb1p5dko1UUMvZmd1SDI0UVc1alNzRi9pQlFzK3pOR2haNzZVTlR0ZXhhdExWWG16VXN2MUt5WC9qT2lXOER1dUZVOGZpcHRIeFlNTWZoYlZPMFBkaUxpSTg2S01vS2wyUmNidGgzdEZuOTQxUXVHLzJZbFBTbEJYeUJBVXhqd1BnR2E4elRUZ3dEZG1NK2x0UnBLSUpMTTYyUHJZR1loSXIwYktXc0FUMFNYa0ZsY1lZbVYvaG02bVV1RHluRC9OcWpWTmE2Tk81dWFIN3BDMjN0bTVRVzZ5KzZPSGpxVmtnNjczM1UrU1AwM0c5MFBIdU5kYWtzcVU0cHRiZVRwZ2Vva1pxVXRNbzFhOXpHNXVQbVdGTXhmMTc5dzgxRCtsVkMveWp1VWRMbFZWWisvN1dXRjVVdDlUdjNHZ09YanNQb1J4b3ViVzVjbTgyY1ZwK1BEMitBZW93amEremx4dXRhRGhjWHFhdEhSOUM2ZU9VSDUxNlh6Rno5ZDV2K001dUxJSlhPMWJ3SnAxOHh0YjlzbkZpWlNTaHJMYWUzN2JLckxweldzbVcxcmtjajBucm5ocFdlSzdQM1BtK0M2R1FLNUtONXVmQ1M3Q1lmMlNYTUFzeU9CckpFdE16RTZLcmJPOUo2VnFtcFF2MUd6eWQ5YjVsblpNLzdpcmI1WGNvK0l5MG1uU1ZTYUdQNk1MdkZ4Ny9aRFdaSFhlb3lrN09jTEtRdmVsMTZkcWFiTXJqMUJ3QUF3TFdSM0swU0k3ZW80TnhJaDN1NkQvMGM4TEpGOUlEUkhMWnlOR0ZLWEt0OCtqeUYyN2ozR0Y1ZWZ3OHRpN3VtU0RKYm5CR1dIOWJ5VTlGMGtRMkM1Ymk1cnVLYU1mcTlQcG1tTW1sbVF6VzRIa3RVajV5NDNrMUNlREdxUnFsbnB6YUxOZG5lc3JDVTdnalhHWkpxOVBweDBJRUFoS0ErczgwMXpWRDRkRWxJOS9PbklGTllqamdSYW40dHJaUW5Zc0dCRjVZZTFvd0JLVDE0SEo1ZGhGY25XUE02d2ltR28yWEVGdU42Q2ZNMGhEUmZXemNqa2swSERtSHpqSXIwZC9QdmI3SWQ1UEZPYU9FUkhGOU0vU1dpYU1KNE55a0FnSHRTQnFYcHJNTFQxMXh2RTBjM25nQU1KekxZTUREbm9paE9OUDJEdUowdGYvZk55YkVXejcxMXc1RVc1WjVsbjhGeTdxakRuazh5b2dOK3dBU1pNY2YybTdkSGpDMmh6TnY3cWJBRDNvdmZMNkhQYmVzakg5REsweVQ2cFBQcTNQeit2QSsyYzBQK2xnSHNlY2lueWU1NUdzcTlINXl1dldSTXJmc0k0UWZZVTZka3ovczZzZzNoVEZwVE91TmZyTlMwcFVON2xqUWk2L3NCZXZiNERvTnJnWGpiMVkxR2x3bzMxcG9IQUFBQWdQc2h2UlhvZmx1UU1aSmFpUDQ0dFM0Nld4SGVOMTA1R1ZHaS9pSVlYdU9SZmtLSXRqNmpDOEs3dDhscC9ENm9SVE9BRzJBTk11czM5UUNBWnFUVjJQM0RUV3M1bjdqa2U4Vmk3UmhNMUg4YzlNT0NlNkU5TmoxcVNEem1qWUtJa3B4bFgySGVINHJsem5HN25rNnV4OGtQVS9uYWxqM1VEall0ODJqOXRUejZBY3dpK25QN2hySG9QY1duVHNlOWczRzVhU0F0T3NZOEx4Nlp5NTlGRUZsOFJRSUFqaU9zSXJUbmt0YUxaY2JraDQ2NEdkTEwzalJlRzFQTnpOaHhVU3ZBc2lSYTZsSklXVktqOGFHZjNQbDEvUnRTcEoycTlEWm95NG5lbjh5dVhPdlU1UlczL2xxY1BXaVNjUjBaVk42eVdzYlVyTWZXTGZkRnc2V3hac2twUWhwUG0wdjkwN3BKbFdRWFFVYmhzN3pqcThBcEM1TXhIOHU2UGJZak1DOS92SklYVlRMZkN2eE1wTHFEKzZxakxmMVRDcCttcFo5bld3YmNtQ2hrdWk5am9ocERQMU1uV0xmbUkrMWN3bC8vU25QS295dGIrcHJLME9vU21WU1dVekJxU0l3MFBBb3JPUWx6aHB0TDFoZFFQVEord3o4NXFJUWtwTFQ0ZkJGWkgwdFVsM3hhVkNzN3VvN1MvdkttbDhxUElJMlo1THllUWJROUpwZGxWYU0zM3NvM1FwWE1LSFBKOGxveXZGYW1oNktVeGZuaU51bGZoZjlaNGh2OGRybjZ3L01sanE1MnZ4TWoycU15UTl6cGE2N1NGNjMzR2MxVGxPc2ptUDF5UWVHRE9keXJEZDArNVhWK3FnUGZsa1ZKOXRjYWFCR1pMVEltWkNiWmpvWTZCQUNBRTJLNThpMDN5UjVyREZEb1hHR0grT21zT3V4Z0JkU0dsZlJsVlQ3amtpbTFVVDhQV0s2cDdCYVowZ1RyblhnZTM2ZzNyeVV6R1dWeDZRUFBORlNabGo4ckdlSFJOT2VpWjFTM3p0WXA3Zyt2aTV1bXozSVdMdHNxWEpEaEhRWFpVYWJYUnlhbGs2N0J3WXhlQ2dBQVA3eDkvaS8vV3ZidVhmSW4vMCt3Wmw0bEkzd0ExcEltcFlmdW53QWNsS2RCc29FMHV6TDZTTU83SzlDd2hvdTJnNm56Ui9XQUZYYzQyclpPUzgvcGJlK2MxR1RVLzlMMEIraDlNSjZvKzRvYllrZWE3TXdYVXc4ZWdWNWZEdENCWVFHdURNYnVmTWl6QTh0d2xFUUFzQXM5dXlad0NEQkR3SVpUMi9qUkI4QlhWVVprOFI4c21RLy9MVE1IOG94ajN2MkNoUXUyc2JaQTdhbW5uTExmWDFvTU9KeTgxY1k2L1ZUT01HK1BxTU05MWdUcDJRT2YwbmUvNDNYR2tXMGRMUmQyd3FGRUZ5THZVOWRJbVNNWHcwS3FjZ0k3UWtvWGNiRzhaelFNaHhnajJpc3E0NnErczliNzdNbHpodkhjODN1QUVXa0c4UE9EMCs4LzZwY2VpQzVrWDZUVFpBYXZ6d3BVSmdBQUFEQ0R6aFcySEdHa1I4VVhYNXhnZnhuQ2crRVU3dWNDMGMzcEdkNlNQYk9QY0dhOTd1RWI5VEp6MjNSR1d6OVNwMVhhdkEyZk5VcmdoYjBCM0J2dDNGSndWZjhVQUFjU2VUZFhzK2l1T3UyZ0xpYlFzbCtBL3A1R3kwNHM2aGZIY254aW5yVVZBd2R3dGlHMittSHE1NVQ4ZzRpOFhCSTVQdUNwV0NQTk9xSUFnQnZnblFhY0NybjAxSkJ1VERtQlk5TldvWWNaQU95SVpSTUFFZXRRdFd4bDRFNVpxK09LZU9tdUc3cnpKbmpucWRqeDNOTU5iMkdjREV2T01tTE5XZUdzaTJja1MyV214QzdVcTN3cGZiNXZWbDdYditFbEcrNnIwTVNzSi8ybmJNblF5S1NPNVhVZm41K256clMwaWpQTW0zYzJSNWJwM1Z4NzVHbmp0QWpoS2RsbE5qOUt0OE96czBwTFFDWUpWeThCMVUvdXBmQksxanB3YzhXMXd2dkhxVTYyS2ZWK3o2WUVyWi9Yc21RWlV2cnc0c0Nra1dSYjZZWCtYY0s1ZnZzNXJyWUtzMTVvS3oyT0s4dVM4czVuS2Erbi9hUTZTR3RDRXNJOXUrM2V4eWxXbmFTd212VzZiSTlxc3Y2U0hGejQ4clZ3S2UxSHNxZXV2eW01L05xOFhmdCtPVHNrT3Jiay91WDl6RVhKRy9YZ0pHYytqcFk4SHJqN2EyVldIWTh1cTZOb3J4bXhSeDI0ZWlSNVQvMnV1bUZlWkpLWFcybzhtcjRsdlRUcnRWV0Q1bzNXVFJYR1ZXYWtmTStTMXlQenlmUzBoN2N2UnJSNWI3K1B3THR0R3JtTm92NjdMQ2ZqcWxEcnJjVmtmbi9WSWZNeXRLclVaVmhsVzgyeHhHRTZBd0RBUTJsMXBTUWgzTHRWcGVramVjQjRzckNSaWd0Ni9SdVFOZEsrMU82ajNxUlpaZWFJSlpWSUdndnZaSXJHajBEemZXcEd0Y2M0NS9KSlpYbmpzcEhPZXFnaFhkZmhuS3lJNHJMS1NrYjRmSHEzb2hveGI2MlFKbThmSTVVcWsvbkJZNnR1VEhlS1c4NGMyM3A3eXZkVzM3b0dCK0wxbWRGMUtESDVBQURxRjg4eW5UdmNQT05RMWd6dlU5Q2tpMTZscjhPOUszN2tDZTE1cklnTFFqdTAxVFFIbDRMcjlzanl5KzBTdkhnZlZkeHVIa2Nmc25JTjVWWFFFY1hLcFFQbmdIa0daOW9DYVpzbUMrOFFiUEtsc0JreGRlaFVQMHc5YUlSNm5XYld4TVRtQm9EcmMrQThybFhScmVtNDBWa3Z2Z0hneHRyaGdGTVJOZDNRblJlbnRRUEZmTXZHNElqVitjaUg0bmRoMjNleElRTHZDZGdCcjhkbDlWUS9DM0VWbXgrbDloUDljV3BNOWhrNVF2OC9aa2NJYm96OVRDTy8vdDFuN2hlaEZ2eDh1OXY4Z3o1cEp2cEVSSHZZN2gzb0xVOWhvckpiNGcvMmsyclhtL1FqNnlxcGlGRmxSTjZNNlpGNUZFOXhyb3k0enpPMGxmZDVxUGNwc3ZuREJFVkdLOFlMeis4eXVKZFZuWG8zb3BPZU1nVUFBQUNja0NNZmFZQVBaZWJHWVVZZVNaUWlpN09yTmdIV0R4M1Z3b1hDdkxSc3NzRStTSnZ0YS9aVjFIY3hvb3llZENWNEhlNlZZSGZ1NVNNR0Z5TGlNNXZ0dndQZ0JoUkZKNitpWnN3ZG1HSDNSek1rMFArM1pRLzdGd0RRQ1ptWTRwbGp3ZkNyOFBQRDFPVUVlL24zSHBOV3FsTDlLejA0M1ZZR0FIQjNldnprUmxicDFVZXFBejFGblZJOWVTcFZrdStrczhMKzJYVUNFZ0JOd0JhWXhsQUxUOUVaTU8xdXpyVE85STVRYTVXMzBrdXJIUHVMcytTVDJmT3duaTh6QytGTHZrOE5NaTl0Y3d5dmNtM1djVjEyWnR1eXNEVzBXemdQR2xJZVkwZEtLMTJQS3F2bERpUGEweXA3MUtOMHJVNWVsMmowcURkdC90WnBJK05aS29JY1A4YmwyY2lnUDByMXRYVTJ3bjk3N1RXSC9sZEdhZkpFbFkxTUxwNnZSL1NyaDNvZGZJeVU1VTF2cENuR21IbUhaejU5YVA0V0lYeFRxV1RMMDlKRjJ0SGFDWHJMR0drTlJuV05ad01zcmJ1RlNmV1ptMG00OXNTVlRkbFpDSmNseS9CNUpSdGRLbVZyWjFDZEVsMm50R3R2dmhtMGxzRzM1ckdjc1U0VjBTcTEzSTVuZ2ZYa2IxWG5LVzFQTVJWRXFLZWl0cHFQVWhuV2NwY0dZbTJmdEVwWWlxdTFMa052Y0FMUit6eml2bHJLbERhQ1Y3eGZjU0lMK2ZmZUZtcHQzVkJXTnVKcDBOWVhVZjFMRW1UeVI0dGFIcVFpaHlMWldXZFhQd0FBY0h0NjdQdG9HV0FIT3EwQTdSTlc0VElIYjlxc1p6a0xiTGkzSGw0amw5dWNSZW5KMzlxMkVSK2haNFBLeWJEd3RqRlhqcVd3c3JNTW1vN0R1NEd3cnEzdy9mQnN6ZmJjUjd5bnNiWCtOQTYxVmE5blgxcnAyZ3YzcEVCNm90RTZnOERKNEZTRjVML1RyZ0c0TWkwT0h2cG91Vm9UU3FwTU9HTkozNWlKVW5oMlYyVURyVUowbVJxeHprSmxES0xGaEVmak4yT045eGJWMFZxbXR4c3RsVkVjZWEyMFVoa09kWFZ1dkIycWJRTnBCMXJiUGlzY1hBTDNxN2swSC9uRDhnb3NZVWZ0Zi84a0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhPVC8vUE5mOGlOWS9nU3N2LzVPNCtDTDhNZlROTUJHT3g0QmJRbjJ4anJSZ1dQU1QvZ25ubW01TDlGVE1weHRhWjJpVVAvaC9ZQVFBTjFFanUwNTh2aVBDK051b2daZFVpZm40aUs2QTkxNVliU1RvY0tacmZDbzNJZ003d2lXemlmeXl1WElRczVDVXVWWCtEYmxKa0w5Vk5PdnRIVW12UU05S3VMM1M0d2pOaXN0ZzBteWJsbzFTMC8rV052R1paZUdzbG8wTlhka3JwWG5LQVFkOG00V29aMGlYeHYraWE5bEJDRnprdnRTYXE3K0tvRnl0cjI2NklxZU9SVEo5MXNhZjkxVHRyVTJHTmVyL2szMkhwWExhK3JTSHF5MjhyWmxhNXZYUk85clR6MFFHV1BSYzB4ajY2OFU3eXZMU2lkUnF2OUtFckl6VjY3K0s5c1QrdjFhOWQyTGtiWWVlQVF1cDVpU25rdENsZ3JUakxEVWs1R2ZLM3VWZjVWZzljOWNQTWUzemloREM5ZnEwR3BPYTFobU13Mlh5aDZKdHc5RzNtOHJJNXhIV2poSFpDeEpaVmk2UTByWFl0cDV4cGhHaWFWdm1UcTlSZmNNcFJZVm9jbHFtUTY3NkZzQUFBQys5Umpzek1WWFEybXpGdjM4UmVTcnJTcy9wTy9KeTB1NEpHZ0hnZ2JsaXRaTldPdEdNREh4bHZMdyttY2ptMUR2ZlVmcGNXajBsaTBUdGFPNS9DbWxxYlo3bmE4dUs5S3I3M0JGZGRSSXZpT2Ficm44bHo2eVNueWROS3pSN2JsLzczSTdiMFNCYmlLK0NIUWdBQ0c4cmxINmFrRWVPTmVpYnVmSTJ1ZUpyOU9BSUNPZmFWQ3dNRjhLYjdkcStWUHFmNlRCeWJCMkVhY1lhaTBiQ0V0V0VtUkdsYWduTHppZWdadlExbjFncEtnamhnNittQW9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRnprLy96emYvWFpTZS8vcm4rY1c5SmZmeC8wayt1V1g0cy9rWmJEMVNUUTFtQnZkcGpucldjbmNuaW4wcW5wT1VGSEVHV2Rla0xEQVpoT3l4cjRVTnlIOWpqYU5Ib2dzUGNFSlhBemhpNFMzaU9pck5IbXlXY2RTOVZpY1ZnS2lpOURQb2t3ditJTGwyMHIwanlTa1J5MSs1UEhhMG5wUi9mVmRaUy9uRXBsSlVXbXQreldQRDBEMXJzNWk5YTc1VmkxRk1pamxkRXlubHZMOHNaTGVSbzJ3dS9wTElSM2xlV0QxVFQvcTAvOTVkU05KaVB4M2pKOGNENmpFZU80TjE4UGtYRk1kU0xKbWttRWRhUmRpWTdqbXBGdDFMWU8yZW1qZWtsYXFEZ2k2NDJYTWZwcldjdGlyZUQ5NG5ITDBacmJOaTVHWFg3VHRLNkZlZlhYbnJONVgxZ05EYTZHZHlQY0kxYzQ3ZlFkbmJkWitBQUhVVFBLT09aWVd1R2I1blZrS1drdHhIdi9XaDI0TnZHa0c2SHN0Q1ZSMjVKNnd5VThKbEFyMFg3M3BPUFMxM21pOTZ1Rno5aVNTWGtscENWLzVIMUtaVGxoaDFDaEFkWDFBSnlXdTJ1bjR1MitxSVY3WHhzSUFBQk9ScXVyc0tiWC9nZjNRaDFUWGgvL0VtMzRtNlhQWDdDZlZFeWthSytSSjlGaWRGdnAvaFhDajJER000M2V6VmhrSTl4cVNKZEEyYjM5TTA1NXpyU2ZJOXY4cGkwZG1jNWFHcG91Yi80NEQ5YStTUnRoV0U0dlJNc0dHUjBNd0p2UXgrK3p2UVp3citWOElsZi9pR3ZJQ1A5VlJJYW5EREFaTlBKbDJPT1JSclF1UGZQY2VuUmwyWStuWWRSbUpHSlhXUW9ZWEJ1aGY2VlhjQmVrZHdnK0NTcjV5UjVpU2NndXhZOUMvR0lxeGpjQUFNZzhUa2RpVVFBQUFBQ2VTZDdUQ0hpYXdRRURheitlMWRZWll3c0FBQUFBQUFBQUFBQUFBQUFBdUNqdzhRTUFBQUNQNG9DbEg5WUdBS0FINkJBQUFJWDlZbXA5dFVUKzlYZmFqNTVqYkVjZTJYRm5XazZOUkp1Q3ZiRitvdDh4Sm5zT3ByQTQ1WlNKSEk2b1pGK0pNRTUrZ3BvR2h6RnlRajhVYWQ2KzR5TUh5UXJ4a1lNWHdRMFlzUmdNbjhjOVp3RkZOeVhaa0VQeitzOG1sSnJrODhXenBKZE5UOW4ySHV2N2s3ZG9rbzFXOVg0aHRYU0dSL0RLYUIzQVNjazM0NzU2cmRra2xPMDlNbmVQdmhpQmRlUW9ZL1Rtbk1RNTlCYmpQQjZWU3l2TXRWaHJXR2NVOHZDak0xZnhNOGFVbFhma09KaDUvaU5CK3VvQmpRK1gvWk01elNleWRwMmRucDAvM3c2Zkw2UG0wUFZhc3JRVzl1bHZxYXhGcGs5eVZxNjJaZGgyaDNaWDF1NUR3bWR4ekpjQndBdkZ4TE0raE9NMHMxY3lWM09LbWlsY3Rid21yb0ZyK2NxcmY3WkZSL3lVbGhsdDFFSFpNT254VXA0UkpxNkZ3OHdJMzljZUpvUjFmOUo5amFpVDkvbmhFaGYxYTNHeVBHVjZqaVgyOUhkeWxOVXFzeFAxYXc1YytoUkh1dDBXdStQTXFtSG05QVFBQU1BUVhYZkJOWWw4eXNvalMzMStrZ1FEeFBBQnUveklLVnJvNjkvb3M2dzZMRW94eXQ2REk1Nm4xUGxyb20xdGJZZzF2SnVWWk5UQmxtbU5KQ20zaDdZbkdyeWNFWFdwLzRpb0VNK2oxcWk4dWc0anp4T1cycXJWZlZFR3lnWURpVzZFTFpXeG84OEJnQ2Z3UFkxKzFvWWxZUEljaTFvc0k5WitxSW9EZ2Q2K0RIdTQvRDMyOWV4SEdwZWg5YmtSalU5R09pMVBFbVJnSHQ4QzY0dW9YaGZMMllZRDg4WFVrdW9aZ1BGN1U5Q3hBQUFBQU5nTDJCMEFBQUFleHhrV1B5ekE4MERiZ3RsZ2pBRUFiS0FwQUFCWEEzb0xBQUFBQUFBQThIaXdNUUlBQUVESW16OEFBT0NjUUUwQkFDVHlmLzc1Nyt0WHFQcHYyQS8vWWlxbDlXaXNwOUp5UkFFQVIrRTVKTkE2a1VJUUdUbm9xN0dvYzJJZFk3VEVkZHpvRWVkT0FzRGl0U013K055NEQwZDB0R2xFLzRJYjBISVlzeXFvenVRdDFFcTNwUFVhSUo0eXZQRldXVVdVK0xuT3IydStFYTM0dFZTR3lDZVJQcG5VMUIwbUhjbEpwV2xwVys0amtUS3NnU3psMnh2dGxQVG9kMTlTOGhtU3JYV0lIdE9ycGFueHpERW43SFFtUjFxUGF2SmdsZFNpYzM1VnNXekNmMEtMSm5XUnZOWWR2MTkzdFBKOTh0cHpwV2VUTXFweG8yTk1TYmU1WGVrNDlaYjdqZEppYWJXV0hkRU5FWmtSdlIzVmJUMXIyM3B1OUh3aGRUMm5JbnJPcXI5Y0I2dE9YRHd2SzFmLzNXS1hITEh0dk15UUNVQW5yQjNCSkdQU3FkcEtHKzVlMDgxWWpqWWY4MGxwZlhLN3B5ck8rL2NaTjhrdm8wN3ZOVWRTUTVsVXhrakhzOVVPdmZmVm9qSmJ4bEl5OG5qa1I4cmt3a2VaazlIdGtJVFhGVkdudGNhV0pQc0VqTFJ3dUhUZTNkNG9LenNpcTlmcWJHSGtmUUlBd0tucGNWT2VaSTBFQjlOaXcvYVdsU1Jmb1NOUE42MmJNeTY4am84WXN4cWpqUFlSY1BlbFBkT3dycVV5SXJSdUFLK2w4S3h0TU1XN0hiVHkvYVRML05TMHZtTEQ1a2x5R1NzeFpSdnVZY1FUalZhWFE2Ui93SUZZYW90TEw4WERqZ0xBamZTRjY5VXJCWGw3N1pxdmVSMU5pYmlqbzNndEh6Q1JHYzgwd0dtSXVqZG15TmFHV0hRM0pNbThETllXMUxzNWFTa0Q4L2RSV1B2QTN2WDNLQlArVHdJQUFBQUFBQUFBY0VKTzRIWEk4SHlBMFJ3NXBwNDFuakY3QVFBK29DMEFBQUFBQUFBQUFBQUFBT0NCNyt3UlBLeWJNYW9CQUFBQUFBQUFBSXprNi9Oblh2MFZPUmxwT05xUlZkWlBmcWRYN3FKb2JXcWxSWnVDdmFubithRGpkYnpaZDlOemV6SHl1Q0t5T0x4RmtWT1p1QzhxMUg4VVJnWUFRL0VjNDRQQnh5S3BDSTlwVUY0SmExVkJQeWJIeVVxQk1zQUZhUmxNTGtFajBrYk9EdExDUExLam56V2hSbEJobW5LOXVLOTNjMVNtVms5T0tWckhPUzZMUDhsWFdyNVBVdDlKVVhKbmttYWtsdkQwQzNkdGhWUFpublN0OStVWjk2TmtTK2RPbDRheWlpSGJPbWRQQ292RVcvTzFNTkdGWk0xa1BqajdYZnlpcGxMSG5EWkhxZWJYOWFvSEJKbkY5UlZrSHMvWEY1ZVVhNnp4cmFVZk9kZHIyVkxaUzVySWVDYjNKeDJKK3haWERGSGVjVkhuVy9LOEMwbCtqTFZBbEJmVlc1SDB3VFkzd3oyeTZmM3FhM2NPeStmbkVGMi82UmRWNjdEUE5jM042NjM4L3EvV2Z6U1Vsc0dudDNvZ2tmc29telZEYmtHcjdXV2k2ZmRFV2lQQTA1Q1dCdk1zR0dZYXYwOVhwMU5HTU4ybzMrNTlMWlROMWFta2pSbmlHOUc4bXZJOUIrTGlPRHhMZkRSZmNhWVYyanhVM3pwY1c0YThLbExiNGtSVUVwZldxb1BsbCtQQ0xSbmVkRmFmMU9tOC9TdVY2ZTJMbGlYQWV4OHBHSDhBa1oxcU5xNGxtWDVMSnlaRHFvTlh2VmpNNks0VzZ4Z0FBRTVKejdZL084UEF2YUR1RDY5aEljcFQvSE51bTViS0VCS3pkYU1iQXlrVHhidjVhcDFFcy93YlhyK3hGK3QrdFFGaGxUbkNGOXJuKzl6R1d2ZmIwMitGMUVEeUhjcHcwelBTS2oyMnJQdUpCa21ZaFhBcW1IUDllN2FLV1V0Z0NQQ001bWliZVRVR2x0T1RFWjFNZGI0Nm5lZHhDam9mUEJESkhNeGtEcjJuVXRIbHZLODNDYmhNNUhvcHk1aUxIdjB2bWJLVytSeDFVODZ5R2grTng4OE92WDBhdkZ2UUVmTTJLdHY3Q01lRFpKdmVEbW1MYmowZnhGeDhIUFc2di9sS09zV3pFRE5KWGZWSXh5QitNUlZ6QVFBQXdBWXNEZ0NBQ05BWkFBemlLWk1KU2dQY0VZeHJjQWVlTm82UHU5OE1uUUVBQ0FDTkFRQUFBQUFBQUFEZ09MQXJCUUFBQUFDNEtyRGtBQUFnQUpRbUFDWmYzRzlvcFZPMWVrNmhVdEYrYmwrTWF5c2MyRUJaZ2l2U09lY2p3MTQ3T1VRN3NPQlFXazVzRDJJZGlsL0VBQUFHNHprUlNnc0RiM3BNZ2l6OExSRTVteGJjaUZOM3NIbDJiUUR2RVZuMG1qdGVxKzNrWkdvS2JMODR1clZsZmtLS293NmJJbU1kRzJsTnJ0NzliTzk4alhWdVhGU0RGVWNkcExNbnZVVE9zTFB1WDVJZHFadDFSS05WbGpmY3FvTW5uMlE0Rno0NGs0dDZ6bVRtT2pPWmwyUFJyS05UMmRQMHljL1dDdkhnL0Mrdjc2dW82N21WaGZBSXYxOUYxRk9rbC9SK2VtVzA2QUJ2ZWpwMkNwOXNvZTV2MTlkem1UU2xwejJLVUVaMHZscG42WEo0ejh1M3lyYkNQVWk2UUVxM3ZwYldLMzc5L2YyQ2FCSGJNTEd5aXBCT2IrdkMvTVhkSmE4RGwyKzJaMUtuSXZSM1lVcVJScGhNMU83cVFScXZvK3ZRNG9YYXN4M0FOT2hwNk1McHB1OFJTRTVPelVST2JYNFhZYWlZMmpmejhhWkZTK3BXTDF2U2ZXMkVha3RFZE1oNzAwdDE0TkxRdjZPeVZidXhRVzRMbGdvUlRONU5uTFY4OTRRWFo3NFdKRmtqN3lkU1ZrNStkOEFEc0ZaZHdhbzJpVmh2VWRYUnd3alB3ZWc2QUFEQTZiRVdpYWh5QmM4aGFraDBqUm5EY003T1RacnBpckFNYVMzY3NyUmFKNDkyN3oyTlN2MlJ2ZFpZNi9NRUxyOTNNUFVvSkZwMk1VcWsvc2c2YjBveHl6TW4zV0xPWWs0dVZZdG5OenZ6alI3TmRWNXZtZG1iY1VsVFB4b29UaGtEOTRoVzczTHB3WVh3RHZyb3hNVkFBT0FINjlIcmUyM0lRcjdDcDYvSlh0TW4rNklqNjdCbGFWcFd4Q3pYK0NOcGRScEdGbmt3bk9oYkRwYTd3L2UwZjUyMmxjaXVTek1qV3V6djAwRnZwQmpobEtqeTFNb0d0NkIrZHM2OUNwYWR6NlNqbm9pejhDY0JBQUJvQmpZOUFBRElRRWNDQUlER2tWb1NHdnJPNEl1TGR3ZjlDd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBOWdkdnJRQUFLUGsvLy94WCtGSHRPdml2dnc5U0lkWlBla2NjUHZaVVJoOGpocllIdlhpT0RLSHBMTjFBMHpuSHFlYzBFKzhabGFmQWUyeEt3N0V0OUlRb3E2a3pTUURWQWFaaDZRb3VIZ1BTaFhtSWowT0pMa0YvQkYyQ2c0SWVnalJQVHpzQVdzOGhhejJuU0xOQStMcHNUMG91aklTc2xFUTZwVGhPL0g1bnRReUp0ZXpXTHpMK0ZEVmtNeE0xaVBTMnQvTjc2akxDYUt2ejdyVVlua2xEdDU2dkxmVWoxeTdaY1Yxbm93YXpaRWlUY0NuZEswNzdNcXBVSSsrcGFtdFp1WXFQYkJpODhUMXpxSGZzZWZyWFdlYm10b1Q3Y2czUHJPdFU4ZmpkZDRKMW1XYjRFdWNKMzhOQnA5V0ZLek1GeXJibXI1YXZsaDF6UnBTR01yWnJYbzhkWVJ0YWhTMmJwb3FWNk9uRmxNNnpnbXlKdHIxbnJnRGdKN0wzZnBzTlZUcE9ocWdwbmFhTmxvMFdQc0pLSHNaSWhSYko2eW5UcXl4N2FGMUtSc2lLTEowOVMxMmRmNFE2OXQ3bkh2MzNVRWJ0amtmc2VrZnFzMUdlQ0pybXZQWVVBQUFvV0J2SHFCMkJMZGw5eVZ3QTQyc1R4NVN3b2tZVzROWUZWL0xqaGV4amJVQnIxbzdsODlaa1JPSWpSRFlVSGo5dFN1M1czUWlyYm9RVkp2bnRMQysvcjMrOVR6aldVdGF5dGpKNEgyS0w5M2swRWR2ZEhHR1djOFZUQ0NPenhSc3RoWS9jTDJEcHZCbGVleW9GMHdGd0U2eEhzVnErYjZoSjUzMU12TXJVU2NRYXNkZitiVGc0R1pFOUNqcHlHTkpjR1MxL3hvNnN4VzZzOHo1S043VE9KZTlEV1FzbzRrdWh2Y3JueXR2UjMyY2ZIc29YVXpHeUFRQUFBQURBQUdCV0F0RElDU1pQeGdTK04ramZPL09jM2ozaVRwODJkNkFyQUFBQUFBQUFBQUFBTUFHNEhBQUFRQUZLOG82Z1Z3RUFBSndKckVzQUFBQUFHTUZYdWd0N0hLdDFkM3JhRU8wUFp2TTl4cXlqUUt6OEhVWDN4QjlDeTBsbXhvMThuKzZRSGVuTjlpSW5SZ0Z3Q3JDT2hlQU9DZUsrMk1KZTAyam40Y1JXSExnNG5pUEdkaGtBa3NFeFVuNUsyeHNlZjhhYTltVTI4NnR0WmpNRUpxNllxTzArU3hvNUVLS3labHFGTXdhKzF1WWp4L2xWclRxcGZhejd5ZFcvUlpHbHlKR09UZHNzaWtXVkVUbTB6enVTdUlQOC9QT3VkYnpPbURzOWpKcnJQWnZRb0FIbEY1ejY0TmFySTNSQXI4N1U1bTl2SGZoMDJjeVJtWnlXbnBLdUxkbjJNWXpTdkM5S0hxNU82cjVoRlhJWEQ4Rnl4L0I0Z0htczVsQTE1TXk1OWdvb1VWTW4yOG5mTTM4NUlYWmQ1QnhtTGtPY2lwdzV2Ylh0NFpub01aK0xJOTV6MzlFeVc5cHlwTGtFVmxoZDR1M2VhQmVObUw2MGJyWnRaOHNhbVg2cXZnVUFnSm1NVm1EWWt0MlhZZ1o4WUowUndjRlduR0V1V2N2TEVjNkJxWTVqYmJOQzQ3bnJGSXgzVmFvUmovVTN5OG81cS9WVWd0ZGpTOXIyUks3aStmNksxSEN2Vm8rVTAycWI1OWFieWZPZUxtaDdGT3dYd0EvVzR3WFlUK0Joak5LTnhZcll3Ny9zd0xmMmcxTkRPMUhxUUhUc0ZJNjJwMXBVeU1qZEJDMzdkanBrVDBONjcyZVE0RFJrejh0OEZ4OERxeCttYmplcCt0M1JmUXE0R043MzF0REJZQytveWhteEk4STQvcVh6Ylk3NlVVYTRDNFRQbG11eWVsN3NBQURzQXp0UHE0RE4zQ2Y2V1BKM0Q2c0x1QWJXMnI4cm50V3VkYVJtb1F6cG1zdHJ5UndFMXd6NXVJN0tyMHFVc0plVmVuSzBhN3NXVzVtejJLdXNWUWNiYWFVNlJlYUQ5U01xNjVyS1NVTDhUTElRcG5rb015OGkvRWFCWUZBbmZuUTNGWmJ6S3RmN3h5dU8vTi96dE5TWnFuQ3ZqSDY4OTJ1TnJZNjY1cUNUeGFPdS9JVXp3dXJ3Sk1TM2xCRk5iODNySG5wazlxNE5IdmxwSlRNNzIzRHNqQmx0MDNqNTZFRDZrTXBLZnk1YTZuVEcrd0IzUU5SUzJjNlhra08zWkdlWWtpeTY2bWgxVTdWeXE5cjNVSlE4WGhrOXkrOHNGVEpTYnN2eTY5MXl0Tkl4Zmxkby9SOHBHNGhFVnZ3Wnd6YWFYbnRFWmIxRElPM1Z2Rk5uaHZVTUFBQ25wOVgrNnMwRGJzUnJCUjdwRWd0WFFmYmxydUkzMEllc1JZNS9YMVBMWkE4LzNHajJ0QkFqN1JLMTVxUkJsNFhjVnY4bXBXeTlIVnBiYWQwVHN6ZHgvV1Q2UjFuOXc2ZXRZTk1aMDllc2pHZERvR1R4aXE3RHBUQnZPd0FBd0dQSW4zK2EzTXRlWHpsVjNJeko1clV5WnB1MFozMHk5M2c4cHYxUmozOGZpbWJpU2VIUjNZT0gxdTRkdFZ1a09nTTZoTUZxa09nREIzQU84dW9mWDVhODNsZEd6aXI3eHJmN1B4K3JINmFXb0pvWWJlaWNwekFBd0NHVVFXbDYwci93YkVJdnFaWWFWNnVsUFVZdmNpVVlEa0NJZWlKalVFMmgxV0UzR25UdmhhSHIwcEJCMWJvMW03WGFTV1ZSdkt0aXE0dkl5YnNabURvTy91eDVYM2RMTGpOUDI0NDJLRWYyeFo0YXpWdVdOVFk5QTZKMFhsdmgwVFNSL0QydTRqTEdIaW42VDduNDYyQmhyekphcWlwL1diRjM3a1ZvSGM4bm1yOWR1blhFZlduekxqZVUzZnE0dEtXc0ZxS3laamdqckxZZFVaYm5LZVY0dUIvaDZuNW5QR2tCZ0lQdVVGcnM1MkpGREp4K1VUdkNxNzAyekZRWmUyNExnYzJFY2FweUZrZlhqV25weXIySGdZWDNCWnpabmdnQUFMZzFVZGVDcEloaDA0RzlGOVRzOFd1TmZLYmh0VVM4SERGcEltV085djFIMGthdjErR2ZXTHJENy9rQnFOY3ZmOUwzUUFmaCtSR3B1NldOYmczUEVLV2JteDhYVmFJOVJTY2wvZG4yV21BdzJGUUNzS2FzL29sbjk3NHE0MWlHQzFrYmRDdkNYMVFMbGtXRE5lSUVGQ0VzYWxhQ0pscDl2TDF2TVl6c3pwWjc0TkprNHhwVVNJWTI5d3dLOC9mOE5OZ1FxeCtsTHBrZEQveXR0Ni9Pdm9lcmZwaTZkWU9jWW4vaVBUYWdPTk9ETFdnemNHYm9FMzRyZk1laVR6MWxKcXc2bWY1UmhQQzBqaGV5cmVQSTZSQUFERU14NHQ3eEtjR082TUJxWWpaRCttVEtrazRoNlRrZEVTNGJuQmU2K2FyREtWTTdmdmEyTFRla3NXNjJwODVDWTVJdkp4WTJIeDlqRjdsZTlPV3Z4L2xreDJyaUhUeGVxYXAxazJUanRTYmF2OTc2UnhhLzNuU2NsNngxb3M1WWlGdmEwQU4zMzBZVnl0Z3EwUkhHMjlsNWxiam42NlcvWDBZdDR2VW5mRlVrSzJsTkNVaVE1cGJYYWVUTk42Tk1FdjIrRHRSbDFCUnhIZjFlMzNkZ3ZIY3hxZ3lyb1NJTk9HSU1hWFhZdGkxZEc0dW9QQkpicDd6Smw4U3lXcEZiaFpkZnF2djlmR1daU21zckU0QzdrNDFyOTV4b21QNnRGaDBuSjZVTHVWNUdMM2w3TEtGN1lBM0dQZGlqRG5mcHJ4UGlzMlQ4Y25vc3V0NnlGcXRxcExYY3MwT1J3aStuZndFQTkyZVVnVm5MNDlqYm5RSE9UL05uRUZQaVAzUEJyYmcwWHhxQVo5SndEOWk4cnk1R0tyblhCTmJTenJCaXJJZVMzdnpldkZ4L1VZbTU4VTU5bnZrKzJmUHhQajN3eWxvdENmcGpVZkY5QmZxYjh4SjRGNG9Lczd6TkVqMzdJUEF3bk1zVUFHRE5qOG4zL1lkVDBXWnJMK0xZcTd6TEhJUzFob0tEc014Tjc2Tm9lbTJibGVEQzdPbHYxblJIZHVhNUZDTWVNTkR3bHZKcmVmQmZYUnJONWJUcTFnZm83ZXFIcWFPZFNEc0I2d21BZTZNWjQxTDhCQzZxSWYwY2ZJTlE1V0FxMnZqRzRCdkN1NG1YUHpvTTU0MlBEaHV2NS9LSStYbmtrNkVqSjVadGVFUWU0UU53V3FRMWJOREFwY3Z1VEkyeXI4WjQydUlQWTJkL2JyL0QvMEg2OGJpY3ZyOVY1TmNjZit1U3F4L1BSc3ZDbWc4QUFBQ0FtaU10T3JvSGsvWmtFU0w1dks1dTZ4b0FBRzdMZ0dkVjRLck1lQ0JjeUsvYkNubGZwUVRIV3JRdUl5ME03OXZ1NEVobTJteFhzZ2Q3WjdOa3N5Y1NQbUxZditVL3crME16bzQxZWFEcUFXQnBmVDlGK2tHWE9OVW03bFd3QlRvNXJRNDlMUnlkZmhwR200QjdkcXMwakRDMFhxQWhnSUYwQmhvN2RLeVgraTV1czMvVkY4dExRcVVLOFVCZFZWT1JMRG5RRDlvV0hJMW5ETGFlSURPQVpWOG82ZjFMVEpsc3hQV2NBdExqR1JaT0h2Um1COEFFZzJzNnVmcWoxcFdtWGc3b0NQQWd1dnA4OU02TTJ4R08zQVY2ejhCTlF0bnI2MnpJcFhlenZsNSt3RkplYWVreHZ0eGoyMVJWeGRGeGhaWmU1Q1RWMWZKREZ1bXJjWi80Uk9JTEkzbDc1K3Q0NzhzWjJ2M1NzaVNaRXRaeGE1R3lrN011WG84M055YTllWk1oMDdLMHVicGFpN3kzUDYyeVBQZk5pUG54NGk1enBhemozbFVpc2pmSGJjdkhxK1hOVjRpbDZwUlZ2TlZETHUxR2hsZ1cybkk3ZjlmeHNiYU5qdFBvblVZTUUydnVPTWRXcWY2bVI3YlgxK3owRmNaR3kxY2c2TmNmM0gyUW5PbThmV0k1QWxwbGNESzFWWkhLc3ZwVHlrZERDMU5pSVRVVDFsdHlWUnd6ZGYyRmhYb1FaU0Y5VXVPMzBIbitDYzFNWGRiWFZJbzBaZ0FBQ3kwYVVyUXFNeDgrZ3BiWnU5VUpuL0FaZFFRWEFVc0JTR01mYWN5cUE3M1c5TFcxbTBqT2VBQUFtRWFyQW1ySko3bGxvMXR3VFRhNExwSXJPTEpoMkN6VW5GL09XNS9LZDFaSTJad2p4TDNhZTlKek42NFJ0VHhTRlIvemRjVnBtWnl0ZmthYW5wTVhsV0cxcVozT2I4TmF5bTh0bS9vTTVidVd4cEkyeHRaMTBWcDBXek0rVG9yWDBtdGxlV1JzWmxKZXh4ZWFvUWhsTS9sV2NZb2JOdXBkbHpRRlRjZkZSV1dERTlKaVg5RzhyZkVBM0pUTjQ5QUYrcWgxODhjcm1iUjNpVDZTVGY3dFQrU0pKTGRPK2xkNHJCSFQ4RGdMSTVoN0VYQTBNNWZ3Vm5tYTJtcXhzVzlONjViYm0zL1U5aHJzU3VRMUxQYkw2b1c1TnNiSzFkYm5yelNBVTgwUFRGWUE3b3ZIUXdrZDBJZmZDMjdTc2hDaSs4RGhZQkNlaGpJb0RiZ0kzcmY0RG1HcHpMM2RMbm56V1BaYTl3dDlzQ2RIam84TGxSM1JZKzUzWDVnblpaNTNpWWF3dkhCU2ZmVXdXQlZnWUtuaGtXdmp6NWNjOElUcUNENXphTGtlUDNkNk5LWDFFTHhISnBXTDU2UUF4TEZlSXJreXNDTUFBSzBNTlpNcm1WYTRadU5vc3ExMEFBQUFBSGhoL1dBZ0IvSyszK1FyZGw1Ulp0bks4N3dRTHI0MDRmazFnOGV5eUo3Q0hITHFNS3R4Wis5Rzc3VHozYllYMzZ2OVZxMWtiL3BiMFA5ODBQMUlJOFh0NEdsMjg0U2hkQ2IvWnJRZThNdGVoQkVUQUp0UEFGYjBIaEJ3UjdBbVRNYnJMUFJ5N1ZlN2dNRVp1dlAyUStvTTgrYk9EM3h2VE9TN0FKdFhzaDVpazM4bDVrd3M2MnMwaHhEOTlUbG9SM1RTSmdDT28rZUpmd2VsTWU0eWNHMHBHVDJXSnhzNkFsd1pqT01odUE3NE1vNWhRbGM4ak53WXA2V2ZNbml5Y2QyS3A3TFdqYTNqdHp1NEl1YW0rNyt0VEpxU3hMOWY0c2lKcVFwL1ZGUW0xNGJoa2NXMjlyV0hubmNwTzdvQmt2Ykp4Wm0ycFBpamR5dmNrM2FFVENrUDkzcUJGaTdKaS9SZmNxVHRnYXVUMVBmQ2ZXWWhZUFBsMU1BOU9MOXErYW5wYXk2OTVtTXAwbXN2cjNoSEYvam5aZXNMVUo2NVJkUDJ2dDR5QTJtOEVMSXpyQTUzVjEvSnNQbVI4NmcyNjFtUXFYN1c0ajNoTkY2NjF2Q09SNy9NVE5ZRWVyZkZrRlVjYmJ4ZTQzMTFzMHBkSk5aa1kzeHpMUysvczBsbDh6SUFlRHJleHlSU2VDSC9hbGhhMlNwRGlnY0FnQjY4anpSbTJCRFVsckhDT1NSZEdiRjlxSWNCQUFDR01sT3g5TGgwQWFqUk5oYzk0NGdkaThRZm04bXF2L21TNnN5ZGoyYUplUFBUdkJ5U3pHTEVqOEJ6ZjlGT2psaGVuR1VwMVl1TGwzeWFrZWNNWlJPYWt1WVpiZkhEWjZFdWVSVzdUdDlHcTIwKzFNZXdQSzZrNFlVUGQvdFF5aXN1ci9OR25taDRsOEJpNUpmU2MybG1haW13STlMRzBISU9BdkIwV20zRlY3NmNuZUVrZmhWVXZWNVRrbTZSR2FLNndScHhJcnlMUEpjSEhFYXJyY3ZKaVpiVisyWUVaNGRHell0THdPbHRyL0Z0eWJMeWFZMk0rWHQ3M2o5T3BTNmxKQThWT2k0aVM4SVorR09iRmhlNUZZK2lBQUJjQzhuS1NVSTRGdXBUQXpVTlRnZlZNUmlnM1VBTmc2bVVkTU81ZXZOWlU5bzZTM3JkWVordWh5YUxjL2MyRy9MYVEyY1ZTdjhFOEU2aTRHVHp0TUs4K2Z1VStTcmM1K1crZUhxRkJmelphMERMM1pja20yaTlEOUt4UlFNQWZBTTlBQUE0QTlhN0lwRjNTU1p0elFBQUFJQm4wZUtNS01xMUZtNGU3bGFJRWFCNVMzbzUwanJZeTRQejlKOUhiTzlmR3I3UmxzOGJxMVcyWWtjL2p0aWpGMDlsUHd0TnUrZm94dnZ1RHdZYlNRRE94WUdtRGRhQWkrSGRzNEJUMGJwTHVrSjN3NTRjQU9id282RS9OczNXSVdzM0dDOWZ2LzlZajlKOGVFOXhHb3BVNkNHVnVRbkNxUzVvVTNBSTlXa0JKY20vVktCV1VPTzRiVGsxN2xKVGdyWkxKSS8zMmlpQyszZ2Fsd2VxQnV5Q3BETVNDUWR1TmsxSVRvY3JRVDJrcVhIb2pBZWhEWUJUN0FPa1NuaW9qUjN1V25Oakxlay8vMmFoTHA5bUtZeWthR01Wb3k1VnZPZWxEU1p2M3NRdnFmSXJ0S1hOcmJhVnJMOFJaV25wVXJKLy9GaWMxMXpaM0RXSGR6SzFHSktkUnJvTHFjMnRzcnl2Qkd0bFdtMW5HTXl1WmlpdmZVODI2dks2K2ptcC96TlhNcDFiOUF1cTc3ckVWOXhjL1ZWV2FmUkZmenVmTlVQTUdzZlJSVUVyS3puajlseG9jdHArbVlGTFp0eFhGbzdYVSsvRmFpdm5lRGZqdEhUVzJoR2h6dXZSR2Q0NmUvUWN0d1p6a3RaemczNlZOREx5K1BXeUpLa05jL044L1pTNExzdlBqSlVCZ0NjUTFWS2V1ZWExbW5zdHU4aHEzSk1IQUhCdFdpdy95NXBNUktaVlJrNjI5U2hkZStzZzFTbUMxOEtGM1FVQVVKRU1MbSs0UjZZa1ExUEU0UDRjWWV5M0xvcHZQMjN0cnhQU1pxOS9NbUpGako0c0VSKzY3aXNlZzJVaDlmcUNOYWp2VUMvekV4b2ZURmxNYmRYWGV1NmlsWm5aTzlqV3BjVUszL0l6VlNwSmtTZFpkVGlIOXQ1Um5hYlUzV2dKTDZ0LzN2SGlFc2k0MitzNHpWUHFuY1VsbUQrYUJoeE1aTE1tSzQwdDllUUQ0TUZ3YTBYOXNmdWY2ODBmcjZubWZiUk15OGg4UFVaYVRUMFd6NWdWSG9TUXpHZHIwWjlsYW9NdUlzdnhrajRsZi9kcVM3aFZydlZHaGFmZVhqZk5wWWcrZkJ6OTZoRG04blVoazRmYUZad05VY2RyYVNqdHUveHo4Y1Z0OUZ2WmRlN0FRZ0xnT1N5S1N2SllhalFxcGl3VWZUc092RUd1RzJHRGdkMkFJL1p5UkRmMjRHWjRGbzFMRDVBZVkrZmVvQlVzamxqUXJyU0k3bEhQa1Y0VnE2ajgrYmNZVDZWYlhxYnF5RExtcm1HZ3JablFGdC9qSnZTbDFhZjB4NHo3YkJ2UGVXcWJ0OXNaY1JVUnZ3K3MrUUE4ajVaSFBMQVdBQUFMZStvQ3FuczhqMVdpK3FyRkZtcDFqY0h1QWdBTXBkZEFnM0VIS0hzdVZLMWw1WjdNSG5vdGllakU4dnhvbHRZSkZzVTMvbGJZOXVsZUxjaTlYTzd6N2ZjcjZPeUlYK3BpdmVOOXh1WENPMU94MUFFM2tSODFRQTBEWUZJWVJTMnRnWHV2UTFnYkhvUmtNRmlERHB5UzN0ZHdyUHhuMEEzUVR4TkI0MTRMTW1FMzMyWVIwbTBTUGFqZmY3NllLdC92bWJmM0JFeldmcnpIS2VCRURuQUUyYmp1cEhRVTVaMFNwNWc2MlFpTG5BNVNZdkZTMFQwbnlBRFFSUDEwbzM0Q0E1cFI1eVE5S1NZNzhxUXhPZ1BjRE9zVXVWTU1qcEZ2NEhqUFFQSzljRkIvTVczNzBEbVQrQ3prcFVkQnBYVjRjWFRDNWdkMVMyMkU0NldxVkluVWVWMDNxUjFHdk5wSlpYazJSbldha3VSKzdIcnpoY2lXWkZyWDBiRzFsS21OZHpwaHBUYUx6aGxQbTlPMG5yeGN2TlpYM0tzY0E4akNvaW1sNWViYzVrdXA2L3VTNzY1czVienJzbTFibXA0YkVWbVNyZmEvNTdGZlNmNjUwenJIbHJJME9aRXh3NFZ6NmIxelE5cHNGVFo2bmJVNGgreWdjZDJFWlBWNTYrUlpFN2kyN2ltVEs4dGo4Y3Jyci96MTBxV0VMSVNuelYvODF4RDQrYzJ6MWlteVZzOU1ybldKaVNuUk0xTXRMUjZSQmNDZGtGYWZtZG9yQ1dWeXNyejVPVHVpQk5JREFPNUxOcTU3N0loaXhITnBxVXd0YlkrK3N1bzAweWJTeW9hOUJjQURhRkU4RWNWQU40cmd2dXk1YU5UUEtyaFBVL1JzV3NUUGF0VUJIcCtTdDlDb0pURzZrYk1qWEp2STBSMmhoMkpjUytHVy81Wkx1NlF2cWd6WkR4ZDVoaUhYWUozRGt1M3pFZjZPcU16azhOWkdUdVZwWVUxR3k5SlFKQmU1a29ZcnUwNjNlVVNwdTBwL1ZRNGpreHRCRnA2WkI4QVAzbVhIQ2dmZ0tRaG1SUDN4KzhLazg2NEo3N1VrQytHcGI1M2swQzBCUGgzOE9RZlQ0aVNFL3Q0Tnp4eHFsVm1NZU9tYXhyWDRyUXY1ZDlUenhOUFR1aVZ0NmZESE5DcW9FVjV0M2FUNWpsOXNqR3pZRVVtd0k2N0dsNTNrWXJjRzYyaytMVVlTQUxNWk5DNHh0TnR4MjFSVlgrMWgrd0d3d1hxN0VSeUtwVXZxN2tOM1BSZ01oR1p5OVcvOUVQcG9MRk11M3MzWXRNem5pRGIybG5tenZwYzh5ZHlQVTdWM3BEU1ptM2k5cmVrUDJqMGlvMVU0RnpNZTF3WG5VRTdqcHQwbFZPU01OcDhoczVYUFMyRHp1alY2di8yMW9MYTh4MlR6MXJBTVNnTUE0RGw2YWVCZVFvWDdCZ0J3SmFTWC9idy9QWm5KekorRkFBQ0FDZmUySlZ5M3oyRFBSYU5zL21BdnpYQTJyU0l6MHdBcFlVdjhLQm1SZk5sSTQ5bXQwZnhubXV6amxNOE1yK1hzTWxMS1V6emNubkRKVjZqZDk5NGpKMDhvRUVzZEdFNE9oZ01BUk9wMWFHUFpESnhUUno2WnBGc3ZiTVVPQms2MTAzS0Zyam5UV3c2M0JZME1uSmdISU9YUHY2WE0yV3VlbGE4aVBpcGJyc2N3Zkw2T09HWUwvR0o1ZFdqOGNveExKdkVBSEFYbnVmU096MlVCS0xyb0pTbW5JWXR3cmNrNkhkcHpCWnJHdW1GUGd4VFNsam5acDBkSXNnQm9vZlVVS296QkZSNnI4YTBTeUEvUzMwM2EwS2FXenRpa0ozVUJOMEhxMktrZEhuMGNHazNQRVQxSGpTK1Qrd0dxUEcrNW41WDh4ckRYbTJPSmFYd3R2SHpTdkw3RXVETGx5SkdUZVZPblF1NGhrOUJWWWU4MDViMko0UmcxYUR4eXZQMDRva3hyQSt5ZFJOcDFxK1ViTk5ZMy9TcU4rNVJpRzl0SWVpMk5oZmQrbmUzNTB3VEVrN1daR3pHWitTV3ZsQ0ttb2NKLzV0OXFtbi9tWEdLdmw5REN4aGRYZTliOTRrbHY5YSszTEsxTVN3OXJjeXc0aC9MbUR5R2RNZDdmUi9NbHhiQ0s2c1RvM0Z2Q0lucktNeSs1L0ZJWTF3ZmUvdlRxRXVtK3VhdTFMR2xPU0hPTUgxSDVKYWx2L2NsaW5kT3FMcW1xaXpWejVMTFdFcVB4QUFBZWJsV3J3K25mSGxsSmtPV2R2N2FHM0dwdFN5WUE0RGxZbGptbjN5U2RZZW0xYUYyK3IvKzgvdjVYeUROU2YwWHRyVHBmRFhRcEFEZW5WVm5VK1RWS0lLMTNXdytlaWNlZEYzVXBSY3RrRFEzR2gxYVl2RU04RzU0Sk84cUtpTWltSHA5STNqM1IybGk3dDFhWlhDclpmL2NKWDhkSnRhRjV0LzUyK3BlMnM1WkxxYTkvbjZ1TlEvSVZzbE5vQXR5THdEOHU4c0xIMCt0Qy9wQmVMQzVKN2dVdTdhck1CQzVOcjUxVnk5a2pEd0FQUVRYeENubmtMc2t3N0VUdjArcVMycTBONjhtbFIyWUs1QUdEc0Y0dGlENXlCcWVBZHF2MURJdW02M1hMZU1xUXJoT3B3MjJIV204amF6S3QxMWVzK1N3TkhuQkpQRDg0dGRMY2JWLzRKd0VBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0RnYTMxSlQrcjZYUGNlN0RQeUpDMVZjTXZCWjAvSE9OVkZCTzBKem94MFFvV1FUanFJd25OSy80alRUQTRuY3N4Q0RnV3ZQc29qWVgzNXNFRGZnQmxvcDFMUk5CaURMSzBtQkp1V25rSm5LTm1JN2tYMzNaQ2hKMGpOUE1yZGV3cXhKOTc2cmtmTDhWdEpTTE5PcTMrVnRNNHVXVTdNL1JRbWV3T2VMeXdXOVh3cDdteEtxODFhTkpCM1J4MDlCWjMyZTUzT2U2NldkYjh6ck42ZTArSnB2RFdIdEhSU1dndnRlTXNHWjRSNWlENWpVRXNHc25oVTl6S2ZhZEd2K2IzRXMxOU9wYkxlL3lGU1ZnbFNvcjZsbDJ4YXB1OUxxYlJ0bzJQSTBwVWFkVjV1UitpdGc1V1B5aWgyblRhcW51allUTkpaUjdxdnFwQ0ZjV2FkeTl0aUVWcDZPUWxsdE5SRm03OVJXUnhTM1dvNW56UzhObHV2djlLY1NwdjFPWkgwUzVyRnI5dWk3MlRKaTNUNkYwM3JHRzFzdnRaNEFKNk9OZWNzRGV0Tno2VnBYUUc5dXlaT3ZsVy9rUllzQU9CY0RIaWswWnpPeXZldGMvNFY0dW8wbGd5dUhNMWFwbmxiZHRpZTlIVmRva0F2QTNBZ3ZSTnZoQ0hacW1qQk00aTQ0VWM1RDdMa2ErSWVZQlJqREhzSGVHU1h4Y21PK1A0dHVWcTg1QWRkL3Y1RHJxTjFhckVLUEJaVEhkNXZlWHhzbmxaLzlQYnFWMlpXVXE4bEoxV3luZU5UdzhMRTFmN0oyanZaNnRtalphNlJSdGpxYi9JNFpOVFNVYnU2djh2UVhPVDBTNnFTKzUwRVQ5bWpnSXZnWG5kSStwWkhIVG5wNmhDREN6d0E3dEU1RjAvbnhtYnFGR2E5YVhYa09MTlJFUzMrZDNBaFBBODF2Q1l0YU1iYVJXaTdCdWt0RmErZk5odlhWdDcxbXdWcnJGMlB0TnZGa0dMZ0dpL2lpN0RtSzJ5MWMyRXN3SnM5cWRCbjdKNlZTK3ZZOE45bFdPQ0xxUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3TVhYNy9sWDlZOXh5K3ZrcStVN3FVdUlmQWIrdUxQR0dyQXFrNFI0c01VNlZzR0tCK0NNT0k4RnljVW5waFoxNjRNcnRCTWFqQk9nM3FkQWtMWm5ENlBLL09sVjRzZDVBQmhKYmtpRGNjbWlIZXBqbWhHR0xiYzZ2WlJKSStsdnJrN292aHZCSGRSc2RYUjRJRVNPcTdMaW8rZVBaVWRjY1pheFBjczVzMzk5OW41cEl6bllxUFJJcVB6NlQ2bk9jbU9PbkN4VjNrenVaM3VTRzE5ZjdUNnFDaVlmaHRFakhtdnJrU1hKc0xEU1MrTzJKUDlaZmQ0eDFxSlZyVFA2dkdmNjFmS3NNd205aS9sMmxQbHBMWnVVeVIzVFdvZG5vZXlpTFliOEVXNkZmRUUxMHpKVlBqSkxOYS9ORml2TFA5Nnh5SjA5V2FmUlZudHZmM3FQTFBUTW9lUXN3K080Y3Q2dmQ1aG1ZMTZ2OUxTWDZGd1pvWmV0ZkphZXJ2L09TZFp6U1VndnBVbXBWV2RtZnFlc1NwTFh4dVhhTzk2M1k4MzZTbm9XWkd0M3FXbGRiUlpiZUxVN0FPQVh6NG9uaFdkSGVpdHVCQ09zVHdEQWZhRjZTM01kV2Y1TGpTeWt5MG0za0dkNUlyZzhWbmpVN2xyeWVNcTBHRmtuQUVBamtpTGowcVVVMy82MzVnSDNvM1dzSmVHNlRpdkZoOHNxL0hXZGJqT2VwVXEwK0R6cmNFMU8xSktRckI3TEh4L3hLZjNyekNzeGNvY1hHVVRSRWlYZjJib05yV2RXdGJ4U3haVlVtQkZCbnBzSmZrWmFaamI3WU8xZHJJYzNsNktRbXEvTDVQTjVSdURHSi9oS3RMaW1MUmUxOVpVOGp2cExOL1hYOGFKdTlrMWRFZ0JCckNWQVFsMlhFZ1lqZUI1a0xrbHJ5V3A5WXZMUXg2ZDF1aXlaVVcxVmZJdVFubGh5ZVNRcjBac2VISXgzZXlEbFE0Y093N0pkUjlMalNyR3dmTURXYnU4eFF5dlN3Wkxmb21YYlhvYy9ydEV2QnRlL1ZSamRheGJCN25EYkVZNyt2OHRRd1JkVEFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQWk2L3YvNnhQMkZyNHZ1Wi9kenZqbElBdzFxL0s2ZEc0d01ZNi9JNGVvd0RBV2VCT0JxTjBIbnZpS2NLamppNkpWemZRNU9RMHF2Y3BFZHpSVHdSNllpRUF1NFBUYWtKa0k4NHg3WGxUTkFrbnk1akNkTkhncGtqelZySmgzMk9yWjZKYlZzR21NRWRhcVF5dnBjR2ZSNXpWSTc1K1QyWCsxRWphQjFwbDhaY2k5VkZSTk50cjhyKy82cGp6T28xZ0lCVDFkR3JwcUxPdGxGaDRMZCtUTGlKVGt1MDVqczFUWDVlR1Z2TFRmTjQyYmkyenBRLzRPYkdOMTJUUWNHMHVERngxc25GTUpwbERLc2FjMlJSZHQxUCt6RVVxa3ora21Sd3pYdFpsY2FmRXN4bFVhSnRiK2luU0w3MEdZQmtVenFXeHo3Sm53K25Sd0ZSc2ZiRTVObDRvYXRQRTFucVZsTUt6RVora1FoMTU2dlIxT3MrYTV1a2JhNHhKOTFrY2VaYTFqMXZUNnZpMGl1ZlNsNDErc3RiNnJLYVQ4dmxzaUtWKzlaVk10TGNsR1FPMU13QzNZS2JGdHRDeUNrdjVJMVl3QU9DWlJLeDRTYWQ0ZHQ0OVZyMm5qQmE1TTNmaWRBY3l5NjZDUGdmZ2hGaGJjTStESWEreUErZkRZOHh6cm9ZV2QzUExJaVl0NGxKNksvOUdqdFlBbXY5Sjg3MzQvRUM2ekNqU3hQWFVMUWZpT1ZsL2xMdzBYRk1Tbm5TKzV3YlVoL1libGxNSnRMR1UxcjVMNlQ0eWs1TDYyYktRY2kxRDZtM0x5MXBjYmN5UEdlb0w5S2o3WHJ0UGRGdG5PZDJQeTNzcE83L3VXMW1uc25FaldOYkFobFoxN1ZYVFdsNE1TSEJEclBkRml4bXdEYzdWUFAxWkFxckhvdlRSZHIyWDJhd3ZhWjEybGorR1MyLzVzY0RCU0d1QlpWWnI2Y0VVZXVheDE5MHhvaHZYTm5zcy9ZaDBweVh5ZW9aRjFHOFI5VVZ3ZGNVY244dUVCWHJ6L2pxMUVaeDJoT1pDdXd0LzFpb1NBQUFBT0Jrd3hBQzRQSmpHQUFCd1ZxQ2h3UjE0MmpqR3ZOMFB0RFVBQUFBQUFBQUFBQUFBQUFBQUFBQUF1M0xrSXpvOEhnUUFBQURBWk81b2JuekpKNkhGYjNmWG43ZEdqLytZY2FUczNZa2NwNWFZdEdoTE1CdDZmSURuSU1XQlJ3Vkoybk5pa2NmaVBmV2prSDlIbEVtTGZKV0pyNm1DYWVUR2VJekpIN1FEd0lxaFN6YnBpSzdmcUJ5ME9mRE9SMnZoZGd2bTBuajNVQzFiU3EvTTZHbmI2NlBMYXluKzA2RWpWazU1SmMvYjdKdWs1VDI1TXhlWDdCSzFNNnZ0RTdDbkRhbzAvamhFajhVcGJjNktzMHpMeXBYaTlsTFE5RXhDQ2F2L3BIUmFPTDFQYjk0UkRvM3ZSYkhvMlJURWtjVWRLMTZFR2xiSDFYSTZaS2tlelZ0QzkxblhXQnZIMXFZazB0OVJIWmdNMlpaenhTdEh5MVA0SXBMUUNYWDZYUDFSZnlsVk9vNlloaFZKUnlSbmVCMUgrem1xUzZTMmpUZ1BFcE5ISzhOYnA0Z2NYcTlsNXE5ZkNldjdMVUtPc3BHVlNmNnRiQys1UVZaVWUzdDYxNUlCQVBnUTFXWVJtY21RTFpYdDBTQ1l6d0NBRnJMenVzV1M5VUsvR1daWmlWb2RxR2ZCcXQ4TW5XOHhzOHc5UFE0QTNBcHBFMllwSHEvN3dsSzI0RnEwYkxhNXNhVVorVDBMbU5jZFpja1V4MmxoNHZNMi9oMnVyY2k5cTViazM5TFNhbms5NVMzM0kvblI2dnR0TGRPckpDTFA2cEpRdHR6aHhmM2N5RmVEb29UVU1TVVZrcGFyRy8wcnBsZzFyK002RFM5WEsrM1BLL2JmUUI3eDYzZUZyNXNYNmV1bTlUdEYxT1ZkU0owMlg3eEpuN3p2eWlVc2JVQ2hkVTJ6N0REWVYrQ2hGT0d4cDJWdGFlK1RyblM5OTVGbFlxYmo4bmcrKytvMkExb25xSWFUNE4wT2VOZUVOaE1RT0lnOGN5N0I2K2lTUHhKcnUzdWJvUlJWdU5aMlVjclRNaUEwZVdBZkppekltLzFpVlFZN1ZQSzJPazlSOFg4U0FBQUFBQUFBQUFCd0Z2SlRQREx3UEFFQWdNMVRkZVYrOTUyeEhnRUFBQUFBQUFBQUFBQUFBQTdtQ0MvbFl4NUpBZ0FBQUFBQUFBQVlCcmFTVy9KLy92bXY0N2ZCSmYzMWR3NmRFckFiMWsrR3VZUHFRQitlWTlVQU9Kb0RGSlZWWk12Qkc2Y21lT0licTY0WjNjR3FHT24wUkFCbWN5cWo1eDZZSjBVSmJhNlpkTkpadmVCaFJEL0hNN1RRM3EybU5hSWpaWHZPWTlzdXdMeUpIejBoV3F0TGZSeVVkWFJVMmh4bnVibGJJWjZ0MWYvU2x0S3lpWWtlVTd2SFJzbXpLeGNiTmZuR1d0RElFMlY3MmpaNmZKeG5ZWTdXeFZzMkpiSVNXZmNiYVEvQk1NNWN1a3FtZU5UM3VtVHVxNGVyZWZkZWwrdDVUT29rbFNVY1Uwdkwvb1E3MjBPUXRyNzI1cWR5UEZnN3dCNDlXaE9aVTlLMUpvdjJveFJPK2xFN2Z0aU5wcmMwaXBFK09oNlNVZ2RyL3ZhVW1abjhORnltL3JJRGxXQ1ZVTWVQK0hLcVgvdkd5NHEyYU0rSUJPRE9TQ3VEbEk2bW5hRkp1YlRlOUpHVkRnQUFvcWRUeTNhVHpXaDdKS0tYWjloQzFrNjd0Y3dlU3gyQVJ6Tnk4clJ0LzhEZEdlRitiWGwwb1lWNzRPcW15Um82L2tmNnhDTytNbytQcFRqanRiTHIrQWoyZmJkK3JaVHpaWHR6YnV1azMzZTBqdHU2V2MvUFBBUFhONGFrUStqV1B2OGNpdmY2RWlROG8zVDVnbDJwcjJzWlJjbVhrdmpWVXk0L2Zvd0twdE9xamdFQUs2ejNSYVZIbEZ3NDFmM2l5ay9tNllpdFY5Um5ZajNsQlR2aUdRQ1J4N3dlb3doMDB6cHZQYnNFei9Wb29sdnV4d3d0YTl1VWpQaVJqdlhXaDY1Z0xrWi9TbmFHdGNmczhlN3NvVE9PQkY5TUJRQUFjQTFna0FFQUFBQzdnNitvZ1h0d3hEaCsydHlCcnJnMWVGTm5SNDVyYTZ6NUFBQUFBQUJqZ1hVRkFBQUFBSEFuWU4xTkIwME1BQUNBZ3JVQkFBQUFBRGZpenFaTi9uK3ZMNllXOG8wSyt2Mks3eSttdmpPOVEwL015Q085bjhhSUk0TUJPSnFXajVTa0trL0R1SDdNVklpMnJUTmR5MWRkQU5pZHRvTkpINE4ybW92YmpQQzBjU1ZFT3JYRzh6RTVkTnZGOFI3MUZUa1p5enFtNkZKRXowS3p2MmttZlludE0wMGpSb0l3VWJsMEtxWDZyeVNCbm1TdG5TYzM0dWl6bGpPeDZuQ1BETzg1bVMxdDNHTkljN0l0Szg5VFptc2J0eURWeFZpUU52bTUrS2doMFhJbUk0MG1SN2xaNFl3SWk1K3ZFblBocjMvL2ZaV1J5ZEd5Mnc5dVJ2czFrajdpME9EYVdNS1RMbHEySkx0SFA0MllVMGtmVys0dnAwYks3ajNta292WCt0ZTdWbkN5UFRwRElpcVRwdGJqSTlBMVhmbzZRaStlSG9sb1JnREFPR1phelp3Y2IxMHN2S3N0ZEFnQTRKdFIxbE9MSmRzajI3c3prYkNzNjlZZFI4OU9KWkd5ajlEVFdCdkFLWWh1UWFWNExwM2xTckVtcEphWFN3ZXVoZGVkTVZOWit0d2ZiVzRicTlDM1h5dnRnTmZqa1l4ME5FL0VxMExUSlVlWlZ1TzBEWTcycjUzT2xTbDlHWFhySXl0cW1WSjZxK3dXdG5WWjVJMUQ4aFhPd0hxa3NkeGdFZEo3dnJTS2N4akJORWJiZEZ3ZWpGOXdJNnd2b3RicHZ2RitIVnVkSnNMKzZLY3VxUjNOSXBLMlpGR1RGbXJnQkVRZWFualRldmZrNEZDa25WZE5wUHM1K1ZRR2pmUEUxMm04VysxSDA5cXhMYlljR0V2RUZVSDZtVjN6QzU5TkRhQ3ZTaVYzRlc0N1pNUXZwbUtPQUFBQUFBQ0F5d0pqRmdEUXhKN0tBNG9LM0lmbmp1YUgzZm5qT2hwNkdnQUFKS0FoQVFBQUFBQUdBd01MQUFBQUFBQUFBQTREV3pJQUFBQWJzRGdBNE9icjgrdmJ6NWRTTDMwaVBmZFRmKy9QL2FValNKN0dTQ1dLTmdXeitSNWYzSkVnMGpqMm5QclpPR2F0QTg0dWlYWkVnL1BVbmlFSGpRcTZ4UDFSSGdDOFJHeUdPdjBTOXZDeDJEWFBTZHUvbTVpY2VycTkySjZpSitrRXFJcWJFVG1Kamt2UHpkL2lrSEdhZ2VSY2lKdk9Qc3ZLMVZaeUVXT0VxdFVYOVhHV2hSeFBSY05ZK0RMMVU1cy9KenVYa0JIb01TUnAybTI1V3hsU2VGSmtqRnl3aWxGV2RMSkpkZkNVWWNuUzBudnZTOEt5NXExMlNreGR2UDJaQTJVNitpVXo4VG5wK1Y1emJ2bHFhU2JYNjZSNUZmNzVlMzBmcFVxL0N2amtmT1ZQWnBseHZHM3EyUkJLODlYcVZ5dmNPKzYxdkZJOERaYzE5MitjcGMvSytuSVZuZmxyOFN1OXRHNU1HZUxDVFBOYUs1U1cxNUxsYmZOSVAxcjNhWlVoU2Mxc3JycUU5WFZaNWVWWG9kZDhkTlloU2xhdWUxYUNXdDRJVFFMQUU4bkd0WmJIbXAvYWF0UktxelVKQUhnbTBWMnV0UFBVYU5tbHQ4Z3JEV210M2NHSXNyeFdzMmZYdEpkTmg3VUJuQUxQcEdpSjU5SllrNnR0YXdyMnhxc2tyWFNXNjJ3RTFvYkJ1OUhQampMY0xBN0pOQkJ2WTBldEFhME1yKzh6T2RONTBrZFg2UFY5YTE4MWxiNVc2aStwQ0dVc1phLzkxcnlNVC9wdGVKMUN2Zyt1VHJabFdaUzBXYWlsM20rMnoyenRJK1R6RnpHK0ZlbnJlSktiZVp0dzlZL3JTNm40UWlwb29rVmR0ejdTOE1qRE9BWTNaUE5PYWQ3R3JkSVo4eUI3NWxROUg2dDVYcGNocmFFcDJkT2NTeTl0eWFKV0Q5VEFDZkR1d1R6NURGc0h0Tk96NC9MSXBZeFlyaU03U2Fzc2F6ZnhHRHdQTCtzNFNXRjd5Z0Q3WS9VVjA4L0xHcy9PRFU5ZjBvejBGYWcwMkhWMVFmNGtBQUM0T3FNdFNIQk9ZTVFCQUFBQTkrYXhUNGFQdUc4WVZ2TkJHNE03Z2ZGOFo5QzdBQUFBQUFBQUFBQUFBQUFBQUFBQTREUWMrUEFLejgwQUFBQUFBT0o4MWFkaGJYL2JWWlNya3lGVmJybkJ5QytaZ1U3a0dBVzBLZGlEeUc1d3dLbWZra3E1NVhEdjBhR0JCckVPQlJLL2ZnZ2RBNDZpT01QQUJxOFpzZm5JVnRKMWhYUzZLZ0F1dkdObmx6RVdQVXROUHpGWnpwTTNhYTBsdi9RMkFKM0llVnVIejZXdkxFK2RwRFRkOTJPVStxRStLc3RyTVBVT1N1NnNQSzlSWjVYUlkzeEwrYTM3OWJSYmIzKzI1UGYwMzR5TnMxY21rODQ3dDR4MC9PbjF1dEgrMWxZbE41WDVLZU9zem9ob21UM2plT1Q5T2VmZnB1a0xtNnk5dkJZOTVkV3BYaVNMYzFTWnZmWFZMZW5pME5mbEhWNnFQRkk2dmhSSnRoZmVDbW1UMHhJSEFHam5WTnVtRTVRSkFIZ2VsZzNqc1hHOCtzcHpHSHQwNTJuVm9jZXl0ZUpIN3JnQkFKMUl5cU4vdXdmMlpHL2p2RWZPQ0pmNEtHZkNWRVoyeW9qVm1zdlhPc0hIUFc4b29rKzA3MnVwZGhuKzNDUEs4UG5PUFcwb0QveGlscm1Xa1lYYzB0ZFFQWjdTa1h3L0hzaU9SeHJjVi9YcWRJdU01ZDBCZkMwVk5ETmpBclRLeERnR042ZHMvaERTQ2ZGdVhTK1pNRlg0SHVhejE2ZUNxWDlSdks4S2dXbk1Yc0sxcmVuTStjdVZCVDJoNFBWRmFIRVJHZUJZSEgxVG1GZWNSdThYSlYyeEtqUGRsNi92LzR4ZTg3aXZIZTlHZG9iUmVDZ0xtME03RmdDQmJGelQ4Q0pjMDdUU085WFZ2NUU5YlozWENqOGQzamFXc2t2cHkrb2ZNVStSRWtYcVVNc0NRQ05xOVhHREMzWUZpemtQTGYyZDlOOUMvTVRuTVRvRDNJU1dYZHpoOHpmaVJ2S3VidElQVmhmWmhRM3RRNmtiKzhTNFNyY1lBZlFKTWtWNDZwRGYrWmQvZWpvMGF1MHRhUDFvcFkzMnErWWRzNHc0cVM1V0hYc1pNYTVwSHM5QzdMMHZUeDI4eXNMampLakw4bXhhb3E4YlowV1dYYU1sakc5Uitpb0xmVU9FekdlaHJFOStwWXlmbDBnOG1rcHFRNHVXc1JlbFpXNjFMa3pXTHRSVEI2YnMwRVpZNzM4eFQxTVhXUDBlMVNtYUxHOCtMWHlVRHJHUU8yejk0M0xQbkJvRGI0WEVpTXhXeWRrUEFJaXo5OXlKYWtwTGEydldGUURnT1VRdE8rbmFzK05zSldxeGo1QVp0YTk2ck92VzhEcE9pZ2ZnRWJTNnpoS1RiK3gyRDV5ZEZzVzdWeDI4cU02RVZpL0RERHcrWGk1OU10SkZ5aDZWcnM1QmZ6Z2FLMnZ4ODhvLzJQVDdwejR0V2paMTVNTzNPYU5ZVHgxaUVtdHA1ZFcyWENycWY1ZWxlZUk1U2Rub1J6dCtMWkgxaFA3NDlwT0xsaCtTYW01by9DZ1ZURWV6czJaczVnQzRJQzJQQzJmSXFHVnA3NnBLNW5KWG1kWGZFVlVCVG9EMXdJR21qYndxQktZejhnMGhLb2QyOXg3UHZiazgvbDNVZzJuZkJvSXpNS0QvdEQxcGFBK2E5V0J0Q2FqanRYbDdkYjVtekxQVHp0MFNEQWM2YURkd1Y1U3h2UmlRMGRmQkkrR1hvN1RIaTIwenVIR2dyc0IwV3BURHczSFBTL29rSzFYWFQ3RFdRVHZTMkRrMW5PdUswbXRaME1tekRzMVYrTnoxVTlueGM5ZnZYYnplb2FYTXFQVUlheTdpd2h4RnEzTHNNTzZHbGRHTDVmWHZsUjFOTi9OK1J6elpUb2wrMVZRcjRYdWUxUytrRk85OEp1azl0WHZMTHRzWUtRZC83ZjJaU29Sb3Y3YU1nOWF4VTR4cmkrd1BIcktway9xNWxkazZwZ1c2WVpEMEZIZHRqVS81TVZvUjB2TGh1YUhzRm43TEt1UTZrbnRHV2dDQWp2WlFmWWFsTzJvRmpNWURBSUFIanlYWHl4bTlHNzQ5bkkrV3VrQ0hBNURhWFF0MEs0cm5LYytqZHhHWVdZY1JNbjdlSkV3bklXb2xITEhxeHh2TC9nSm9hd2Q0Rk5NNlh2SkhSOE1qako5QzYvdisvUEIzZlovWmJKZVVvbTIvbEpYVFRwT21rQ2VUMnZ0WURTOWl3VVlFaDhJTlFPMFJnSlFmdGhtNE1iMnZiK1NJTThLUnRnd0tqMkE5emNkYWRtSmFIckhQZWswRmhObnJyYVRJMGs5cEdXS1dMQXczd2hHdmEwa24rSUE0dmYzbnNRMUs2anJVeUhxbThTUzM3QmNYK0prUCtYMnR2WHRHNTg4aFJON1JnalhYeHlrNkhJQkdzbkd0NllyWHRhVnVOSkhnUTBRdGI3cGk0RWxZQUlUSURYR3dPMWE0elFpYWtMUEtqUituUWxjQUZjOWdGR3lCdVVTM241STNJM3BqNngrbDlzRFhJUGdqUGFleVdMNlFxdjBnOVR0TkhiODkyVnNxZkErc0crMzFWa1ZjR2owYlBXbHk5RTRhNjhlRWtid2x0YlhIeUxSU0c3ZU91WVp4bklYNHdzL1l0UTMrbVVzL0w2NHdjMnVKU3lSZlhjYW0xcWRkc0djci9aWTVGOVVaTGZWcGk5Nk1MZXZMMXg2a3IyaUhiNituWFNSWnFVR201cEFvVEhoTVY5aGZVU2hpbnVMV2tiMXJwR1M4MXkvaXJWUFNrbUhhQTNBY3JaWlp5NDZsem90NUR3QTRJNTVuR2ltMTZiN1p0T3dxUm5sS1JyYkxubXNFMWlNd0RkNU5PMzdBMGJlZ0lveFNBR0FmckdjYTNrMTM1UDJyS041eGJyM0hRY01qcnQ4VXFkVG9WV0RHdzZuWkV6VlNselcrbW5sU2JiOHMycW95NWErMy9zYjIrR3VsSDN2V1plVXFOVmV2ajdTWEgvN3RNOVBxTFpjZFNldTExYklzbU0rUUhLTTR4OEtwTUh3ZEZaeUNiRndEQUZRMkZsRGV4cWZrTjFsVjJhbmRGMUhYWVFSUUZSY2t1bjNvMnFzQWlUUE00MUZMLzB4LzdPVVl2UVd2NWFiVXM5Mnp3OEc1Q0V5aTNoK25xckpUdTF2MmF2eUpKQzdrLzVlaEdOY0FnT2NoS1RMdUlZWjBEYnJJd3I4ZUxyY09nZXRpRFRiUFlNUmdIVU9EVlE1ZEFYNlFOakhjQUlsZTM1TCtMYkRkVE1kdXM2RVg5bUxQZnZhV05iSk9lOXpmeE5IcVhDUTNObnZPbit0QjFmdDI4RjNuRUltUi9RNXRwRE5qanVWZ2VBL3hWK0xXLzg3Z0RPdXZkSjkyM1dEYkEzQWZNSmNCQUhmaFNTOEh0YjRmNEhISHRiTG5lb0sxQzF3ZXZBRDdIRHpQT0lxUWoxUFkwdk9WSHJ5eXZHVVBHZDlhSVdkWUJUd1BvL2RjWWYyTlBuSUlqYnZETXIxWHJmdk9RdHB0L0xVVU9QWHpZL2tCajhKNjN6Q3k5Z0VBWEdES2dNUFJkRCtZemxGTlBxUGJNWHgyQUkzOFBGNkdRdS83YU9JN2JjSDM3cDdBRjljaTI1RFlHV2FubXJ2VWM2TmQxK0VwUVFsWldDY1VvbTNCVlhIcWlsSkZjMGp4dHh2K1ZnTkk2VXVWTlgrdWk1Rm45UzhBWitGN1RPTEpTZ2hKTjI1TWhiek9VMmdHRGVIaEYxVElRNGgwZUU3Mml3MjdEaHorOFROL1hZVHJIZ3VrK3VIWlNrSWhxWmJUbVQ4cDFuL1ZuVURySlIxOXZHUXB0SEFTTDJSTERNVU1DTWJUVWlQNTl4eE1TMW1GQ1U5S3VDYXZ6cWYxcnlVakVWblN0UlZPWld2M0s4MGxiMzhVUWFhbmpiM1hYSDdKdTlXS1VQYnlnOU5pZTRSK2ZweGFwTG9sMTVlTTZ6S1grZTdya2ZVYytweVNYOTdYdjFmZTNacUdZMFBURkU3NzE1bzNFZWVLb1N6ZCtlczBVdDdsa3VycjE3WDB0VlBQRjNKL3hsaGlxaWUwYldnNlV6MXMzV2ZQL1BiMEx5YzdXdGFhUXVhSVZFWkpoWmtyZEM1dHBWTTUyOXhKekZYTHJrTWlvOXhxaGNncUhCbzZBSUFmSkl1SXhuRllGczZTeG12NXBSUzN0clNWMGxzMkFBRFUxTFpJaXc2NTI2T1A2RzdKSzlPanIxdDNRUUIwTTNKd1NaUEhpdGNtaFpRL085S0Q4MklacjZNTWE0ckgxV0c1WGl4RmJhWGpDdHQxL0VaWC81a3JVTFNqTFdxTHhOUFJXcmptZDVSeTVzVDlaUFQzTHJubkVIcmJVbC94K25vdGExdEdZdUs1c2p6ZXNDVFVMMjN1dDFUMXpNMTkwQXI5cnF0RE5TenUyZktKTDNSS0xvOFRtS3lSV1VIZHpERHV3SEI2SGM4MFhZOHFCZUNHZUI0UGJoWUhZVDV1cG10ZVgyL1NsU3BPTXVXc01wZ3NudkFreEh2eWdBT0oyQm4xdVBYb2ZyQTd2WDVKQ2EzYm85dGc5dFVJSVcweTBsMmUxaHZ5MkhMUmg1TldKOERXT3c4ZEV6MzZwVlJQVVUvdCtpOXZ3dUtJTzBVamNuNm9RdUs4TWtBYlVLVGdpbWlLVE5FSkdPN2o0V3c4cUdVQUFJZmlJelRUQTNBTnJtcHBTTjdXWSs0SGMzODJpL1YyaHZFYWZaWGhybFI5MGZJVVRHSzBUMlZBVjYxRjVJdjJ2alYvWm81cjY1WHVBNWs2bmMra3QwYXl2cWZzdnIvK2R2Q09Zby9McGFmYm84NS9yQmdBeExtS0JpM0JhL2g0QVFBanVNdU9kSVk5RmczWDByVEtndTBISG9YMmU3RTdib2VmeUN5bDE2S1lSNlgzdm5pV3VVeFhZblFqUnl3UTY2Y1ZMWGc3emkrSkQ5L2VaM1FhZU41N2JJMlBwS3ZWc1BSalhFN21mTlU5YnBHZ1VxeFJpbVVKbklLZVRVdE55N3ZLQUR5QTRsaGkyQ25Uc1VpWVJaNW9mNFMxOEdSNGpVTnI3dzFPU2ZRVkdYUXpBQmRneFB0bkx4bTVjMUYrOHByKyttRnFydjY3cGJ4VXE5YzFOZEtGTlFSby96YTBVd01rck5tRWZnQm5KN0RabEE2L0dPV3J1aXpXOFM2T1BCdTFUZU05cDJnQk1BSjRmcHJRZmpEYW9pS1dqS1ZLekQxTVJIY0Jsa3NORE0vc3NZNzRrc2hDR2ZLUllKOFM4dXJmd3M1QVdnYi9xcmU1Tlh2djhoT2JYMHpQMUdCYnZ5Vk4vZU0xcmMwM2hRbWxlSGJBVWx0Yk1scDIzMUpaZW4vM3ZYb1IvYm1QZHpYd3REa05vNk9zZGU1WTZUeUdhS3QzcE1mSXBUOUtGV1JaQmpVYnI3ZEpjZFk3RTNuWllTMThmNFcxRk04Y29xVVVJYndGYTl4R3k5SjBKazFENTI5bVpOVFhTYmd1UWhrbDljK04xM1VXTm0vdjdJSHhuY2tmVXQ0aWJSZ0ZtV1g1NHkwZzJaWHcxanVpTzNMaTF5RnJMUEhYeTFjZDZKd3Fqakx6UmhaZm9sK3phMlZvcWZ3cmhDWXJtaGNBRU1PenVrVGlXOUo2MC8xNS9mdXZrZ1k2QWdBd0VxK0Y3dDA5YUpaY0x4RkxON3JyYnltakZhdGRldW93VXphNEFONE9uamtBTEdVUmljOUNHdkFzb29wcnBxTHpqdWVpNURHRmo2aDQ2d284Y3JKNVZ5UjZQWHVGNHVUL1MrckFYVmxQcFQ1NXRpRzJGSC84VWtZeDRqVlpmSjNrNTJtZjBQclpXMUZiaExjc1I0K3craS9KQzcraHlQSFJKemZ2OEVMQ0Y3ZXpjTU41WkVNQThNMklNU1c1L2ozNUFMZ3psWTR2U3Z3Ync4VFpQQTVrRnBlaVYwV2NkNVlWMGJKZHhCUy9JYjlHSFE4NmZEZWlUOXlqdTZTZWJ0NWo2NDJoOXNLN2llRzJjTnhnOFd4eXJIVUxuSVA4K2FkK3RhamVTMnF2TVcxZWVTSnltYUlleTVmMmNoQ2wzNlZ6SWpENUFRRGZGR2NZNkVlejBKbWtQZkVBREVkNk1rTFR3TDZZeDdMaHF4NCtjUnNDMFlFSmdNWnBGaDR5MEhjcFE1ODFoNmkxeVlYeXJ6YjBGTnFiLzZxTGgzWGZNelh5bVJmZEU5V3Jwd3ZLd0RZZU1Bem1IMGh6QlVOdTVKeUM0VHFmYUJ2UDY0L1B5MjIrdFg5VXFiUEdXVXZOc1Q4QUFHaGdWUVFBQUp2bXJXV2F6NTYvQ1l6R0EzQTRlN2liRTdnVTdsK2I3VURrRGQzd09CNTVZOVlQUXMyZk8weXVBeGVmalhoUDNiZzAzSzlEZlBkWk5uL1pIVHArZUc0SDBzd25HSzFwSlMvZXJMcnV1VVMwL2xZUGdGMFpNZG1XaVl3TkF3QWJldC9LYUpKeDRMNElXN0lIQU9QbWNFcndPc3FadXhWRHJnR3ZVb1l0ZHgrWUE1VzhQMHFOZ1BtWTBwZHZidVhyekMrdnN2REVRNkhvY08xa1dmOW9XM0FXNkZqa3htWTJyZ21hS0szbzJ5SE5mKzVra1RvUHMvaS9vL01yM1BDNlE4V0EzYUdEanR1NFlKUEN3alZkSGM3bXlkc05BdmNodHl3b0EzUURXSEhhUmNNeXBPbTE5Y0pCUk5aYTNsWlNlWVZyaTMxSzJrYWhXSStkcGFPTnBTK3BPcjdFdHoxdG10YlRla25EaXBmQ1BQSFJ6YW5Id3VUcXJ4bGlWdGtTbG5GWGx5M0ZlK3ZBamExZWQ3SzA4clMrbE1QSnN1S2wrNVBpNmQ4MEQ5TXUzaStqc3NaNHRiQVdwUXdKNmF1VlVwMlkyLzNNWDJsY0o1TEowbzIybnRMN1Vadi8xbnh0V1hna2ZXV04zeGE5UlhXRnRsWm9lTnFhWnNuYjhjQ2VRRUxHVGlabEZtNGNrNEJTNTRucWpWcEFaRXhSUnJYMXVweXM1TXRNR2ZYY0tpUmU3clVzeU9mU1IrOURreVducytMS2dMSUFBRHJlMVRjcVU3SUFQR1ZGNjhTNWMyaGRBQUFnZ25lM2wwZzZLWjVMRXlVYjRZdjhQK1Rhc3FlS1EyWUxYcHN1V3FiWFNvWHVCOE1tSFhXRlJsMFJkYm9XZzZ0dGF3Yk9TSytCcmVXMUZxNGVQRzRxTHAwckxtcXR6L0FFV005THJQUTlIV3JsYjdsZmEzWFh3L1BMa2loR21Wck4ydmRndEM3VTd5VS9WNmg5Wi96enBMUkpwOVdoTUhMcmNPNktodGRmVk5WaytpeEpyYlpNUUpIS1dwZTR1R3N6MFIyMWE1ZTZjck14ZkxQa1pzZDZCcUpRWlRKeUNkQVVWVDEyTVc0QmVPTlpRYVYzd0V4aDFTTnRNWnR6UGtxcmJCSENQV0toQ2g0Q09ub0lQZnNFN3o3Q3V6M3V3YnYxMXRKNzdoZFVXSDROYlgySmJvTzk4V0EzckZmanVMUTBmVzdzVHd5REQxL2VoQ1AyWklleUtBMlBmKzd5TjdzejdWNUJBSzRGeHZrdWFEYWUxUVhvSW5BS1BEdkhtOE9aWGJQTFNrcVowQTBQeC9JSXc1YWR3SG1ldE5VUDdzdXRPL29wVHplUHVNOGoyOVlxbTN1MWVjSTRMM29OU2tNK05ublp5dGJMZ0FJSHZSdzVobVpZekZGNTQrclFLb1hhOGxZWjJyVW5UelFlQVBBczhMZ0lBSEFtOXR5SkZxTnN6enZYM3ZBSVVSbXQ2VDJ2RGdEUXhGUGNkV0EvZXBUVWJLVTZLbStkM3pWLzlyd3hUVVprTmRsamxaelJnZFpUMkt6bS92QnJXWlNHR2tTSnlQRzk0SjQzNmUzZnVmMjJHL2ZlODFwMlA2R3A0eUMzU0JLR1NkNzhVVjFqdlFTemFIRW85OGllTWJFQkFBQmNCKzczS2JCeHd2VHNFN3pMNzVtV2FRd1RBTVlRK2VycGQ5cjNJVXM1bGhmb3ZIK1lxaDhRZEJQVk4rckprdTFadWdmUmQ5a1dTc0piSE9BNkRGUnQwb0ViMGROUGxyakxUQmZMdysxcEVQb1NPbTJBVW9VbjJ4Q0luSDd4enBPZ29vRENTRFBJT21IbkpnUFIyMlRhNFVRMG9naVp4Qitua2padDBRM2dJZEI1cVQxYjN4M1BMMnUxZkZZNkxqMC9NNldhME5PYXQvS1NFdTQwSkxLaEpNczZYV2FTNWYvRkZjY1JtL2tsNDVQVTZueXVidHFnYWhsTW52NHJRdG5GVWFmRXBKZXV2YlM4OXVGWkRIc25vN1h5Y0hYd2pBSGFCelJlSzFNTGo4NWxvU3hyRHFtTFpuR1dTSFdCTWI4M3g5WVdKdlVTdHY1eCtXZS9RRi9xc2RvMmFuQjU1b3hVaG9TMUUweE1QSlZ0N1Q2OTR5WXl6cVc4eHZwVXVNMWVMYWFzZFRpOXJtV0lYMVcxMmtYRGFwdm9HdURWclRSdFpLeHBkZmhZdzZzNVkvU1RyS1gwKytKTDV1VEl6Tm9lOWF5Mm5wVUJBQ0F6WXM1RXRXOUU4M1BwUnN4djZBb0FBSWYzc1Ftbmw3dzcwZm82cGJnT3BlRldISmNtYXRQTjBNTVczaDBkQUVNWjVXYXppRzRqd2Jsb01TUTF4ZXZkakVmTHBIbHBmbS9aR3prakxPbld3a2ROeXBMR3JzemFxc3hKeUNTbDVjOWR2bXI2N3p2RVY0ZVM3TG9WVXRhMjlKUjhCNG5LdzN4ZFgvdStQZjJzKzgyem1ENytUSU4veGxhWWxEUTk3NGZrbjlGdDA5azErenhiMjM3cGxaZFU3Q0ZnZjNVbUI4TUI2SVdmU2g4aW01ZGFVZFVxRXVNWDNKam05NjZNSmJOd2NXUXUvVW1rYkRMblBLdHp6SklCUUVBYVpIUmJRTTFuNE1hNy9IcnljakpHWSswS3RQZ2l4TWV0KzRkZ3ZTcVRoUGdrWEhzYzhXajhTOEx0UmV0WGorb2ZwN3JrVVZrSlVONC9URjBVOVczbURLY0VSdm9VQVFEM0Fqdk4rUXhZWkx4ZDB0SjE2RzRRZ25OeTlRNVFETUptdkUyS0pnWXExRGw0S2ticzBxeUYrTWdkNFQ1bHpyUWpkT0NaQWlmRWZMQStVUitFSjlubkJadnZsMnR5NVJXODE5ck9lY1JuMzJIMGJjVUIxQjdldWdvWnVuSTAxc3ArSmwvdzZOSGVLZ3RiTlFDZUNSNGJBUUN1eUV3YnpuckVMcm5FT1p2T3NxLzJzRVdobndFQXA2ZFZVVVVVcjFYbWlJZnJ6UXAzaEthT3lwaXhPb3pxREc5Y25TcTJzc3BTT1c4Ulp3WFE5SngwNmNlU25CeWVNL2xwUnZ1dHRqODIvVzNMT1I3aDR6eUFjUG1DU3hEOUlRSlZsZmdCRW5nWXpjOWZYdk5EZTgxdTFCVENWQVRUc1g1OWVLYUhzQmVsWjVka3ZRb1RrYmRYTjJLNEFEQ2UraEFON0UzMzRhdStrRTc0eWltdkRFSHZML3VUa1c0WDZBa1VIcXdiZkRxUjR5U3lFaTdsQWVBaVNPNTlhWGg3ZE9NeVpTNDFOYkl6bnJzeFNVY1VJVWhvbU0xcFhOQXQ0QWc4eGl2R3B0dU1zRTZ3NDZaNy9URzQ0aWdFNXNoRGlHd3NvNy9QR2ZLaWhYY2hqYUlkOGNXOU9zamxvUko5eDQ1Skp5bkg3dHZZZlpwSGNhNjlDejlmU3BYc2lMUjhjYkVRbWRwUGVTeXMxemlsZENOMjA1TEJaYlJwODFpcnk2QjFDQmg3b2x3cVQ4cWZqWEphclhldHJwTDE3cWt2bGVQQk00OHQyY2I5QnI2VXVxM2R5NGRFdm9SS3cwdVJkQVpUTitJZHJQVkxVVitoeWtTUzFiL2FwaVVKYWFYNDZGelQrbCthVzFaZXFXenVIcml4VkpKOHY5NTJJR1BxTXlBK2V2YmQ5WUlzK3VWVUtWNGN6K1RhOGRYc2pZd3AraW9aOWJENjJkSm5Xb2hQOGljK3MrSHB2WEx5SmNTMHgxS1dIbTZOUEs1c2FSV1N3Z0VBZlVRMTUwelpFZXRLeTZ0Wlc5QWpBSUFlSW85VnZIa3NDOTVLeDhuTFFuN0ppMkZacnFPdDhKa3lQSFpsSFYvVGM1K3dWVTlBcTZ2STZ0akV4RXV1SlpyUGE5eUFjN0hIaFBhV01kcVk5VzYrUFhXSnhwdVpQUm83T3NFNTJkTEUxdko3MDBicndzWFhNdnordmMvemtqcmRObTN1OGducHFleGhYY1I4Y3F5UDVYREViV2srcWR1dmwvSzFLbFhhei8zKy90WHFyL3VqbGkzM09kZlBSVXlUMTFLaTgxVWVVdjY4V0JQQktLSkxRa242UnFndzZRQzRJOEtTNkRJM3E4ZCs3NmxTMXVsWFU0Z0lLY2IrNkQxOXl5dHJGcXNnNTAwNk5KMjA0a01OWElReEJtUXNIRFJqN3hQaThsS3lkMDNjMGs3cm9sdi9kanhORS9GTFBnYXJjYjNwdFh6VVQ0ZDVmRHBhdjl4T3o4OTNsYlhrSmY5aVdNajg4U2FrQ3JRWWFZc2ozUzYwOVA0cEtuNGpNQVBCamNId0hvRFNpRDErYVFCMlFiTVpTanFaVVhSeEJBZGp2V0dJNmd4MEN6Z093Mk8rUzluektFZk9yUEo1UlFCMnhEZDN1L016YWUwenpPT0JkUmk1S0U2UVJaMktaZmhRZUxwRmNNQTQzdU1oM1NtN05SdlhlNVE1anhGTlRsV0k5NXBUUGJEMUFRQVNrcm1TalR3QUFIQVVSN3pqRmltelZVZk84TTlHWlhyc1NFdmVpRExyT0hCejhNQVRqQ1NxTkVZb1htOSthY00rUS9tdmhGdnhKUkJPMDNCNVp0ek0zaXZySjErOGU1Zi8zV01ONi9VdGJZZDdFVjlrbjA5eGxycmpzNDRqSDZzQXNOQ2pzTFI4R05mZzRiUk1MZTU5RGt3bHNDdDc3bzlBTjZOM1NkWlc5WXg2Q1RvU1BKM0N2RC9tWVhuSC9QM3ZqN0FFQnZPbFBYeGZuK1NWeFhTWGVNOUxpcU9yQ0FhWkRQMnBkNlN0dkVmRkFIQVVrczVRZElUWHlJc004MXRNQldsK2F3M0I2TjlhWFd5TWZIcnFoZEZ3bVZ5VVd6UTBPQlJ1WFpQc0MvQkQ2OUsvU3A5VG9ySittbjZaMStWenZjcGJGSmtBYUhESGtFbnBVZ29PcWxIdUltdmg3U2xQa3JYRWxsZHNUdXNhMEVmdEpTRGJlejlMTUFrbkhvaWZXcnl1YzVXMnVJeUJkZG4ycVZ1UmdkQjdsSnZYZVBYVWdjdnJxWU1ucjNSLzBYTUM2MnZPUDFHUy95VUxLNTNWeGx5Y3BDeTgvWm1NOUZ4ZTdscXJRNWF6L1NUcldTeXJPVkk0M2FDUFJldkg3RXY4N3dsMjJUbC9aV25wVmF2MXZ5WHhiVlVjc2l3a2g0aEhibFIzUitjOWplUG1rdFptbk15czU4c09mVUduRlAzQzZsdTBwSmpMK3Mvc3VXOG0rQ2UvdHcrcytaNk1PbmhrZXZRVHpTZnJpSHJ1NWVTOVQwNnVYUHBaRUhxNVNVNUs1N3hIQU03RUdlYUtaUEZKYnNtSTNLakdCQUNBR210WG5JMXJqbFpicDhXQ3pZb2NqNDZNZWlLV1BFZXRLZHh1SDdiZ0E0Z1lFaHhjZW02TExMa2lrcEl2R2crdWhiVTRLTzZQN3JLaTE1WnNLTXNVNzFCWnhtK1R4aHRWK3JLbVhJTkN5dFFvS2RMUlVsMmsxR25sdC9yODlmSVVLL20wZUEvOFJNdGkyWi80M3l2dXV2eGNyKy9xMDM3Y25TYTJyQ1YwZlorbDZqTSt0UlNUcXBKelVwK3l2UHlyYnpkdGZCanoxMFZKWjhrQndJdWwwTHliTTgvR0IrTVUzSWpscTZhSlBLS2pjeWE2VGZySlUvZ3BKWlh4Zmh5WVlvWDFXQWF0SmpqVXdFbVl0U2RwV1J2QU5DU3prc1pMcmhQUGR0ZHl4MGowNkorNlhoN1gwZVd4SExDdGpUbERCNER6dzR3WCtycFFyc2RZcGI5cFZxL3VvT0ZjM0ZOd2Z6RVZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQThtNi92LzBpSFEzeCswWnZaTktOT210L2xSK24xejVnOVAxV21lYnl5NzB3MnJoZUs4TGVWRm9DelUzelJtMU9jeVBYdGg3MTExQXloL3JpTmRQakpwczNvaVZna0FRMHZURjRBaG1DZGhPZzVlVEU1MHQ2QXFCbmhhWTZWdnFoT3lBdnBCQUFXUEF0UWNlUmQ4bXZwcDlKeTVwSjBBM3JxM0xWaGtrN2R0bVFTQTROK1JTK3hsNi9UUE1zNzdpZis5ZVZGZXRKNGZwLzh2TlpJcGJTZWNONXpCcWVGOTh3K2JrT3NwVTlKbmdCVzNTSWFQQWV2azNDdGxaR0lMQythNDRDVHJiVTdsWm1NY0swZG92M2d2RytYN1pJVCs4bmd0ODRzUk5SeTdhMERZOXovTHlnVEg4T1B2SnlFZlVSWmxjMVhOcTBGYnVENm94aDVra05PTGMrTE5UYXN1V0xKU1laOExxMmxHNnhyWTA1eEJoNk5mSXN1ZkRvNlRsZURoUnZIV3Z0WjkwTnBPVk0xR2JLa2EraytQSFh6aldQdkNFdEt1dlZwdGRyWTRrT3RsdmRxMmhGNFpPYzB0dzRBWEFHdmx2WHFGZy9XS21TdGhONzVEUUFBdlZpMnpJTEhEclBzanNoT3M3NU9TbmhPL3QyRlZ5WVg3ODB6WXcxWndpS3VRU2srY3A5Y3ZXQlhuZ1JyZTErTWRIVmFtazRhYkY3bEFBUGwzTlQ5MVRPaGl6TXNJbU8wZ3ZFdWNOUFlVMnY2eXBMWDhFZzlDOG5CS3czNnRVN2JrckIyWThYMGtITFg5VjlieVhLWjFuQXB6Rjk4T2o0K00zL1Y4anc5OHZGMVM5Si80LzlzK2lJSjExc0pVcjl1NjdMTldZZG5JWHd0T3podGlWczJaQkJxWUIwRE00ZyswdkZ1a0R6R1BjWTB1Q0NTWmJONTFMYWtMK3ZyV2c0YkxteTZNek4zVEN1ckNMSjl5VU5wSlZWZzVRTW5vYmRqYkhONW5iWTIwYkVXN0laM2laZUlQSFAyZG12cnM2akkwLzNiRDdGaVhGdEU1cThVNS9YTGdmMGgvU3ZaQXB0aHhQUzdsRmR5K1ZyZGptR0JMNllDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFuK1QvLy9OLzdOOERiVTdQS08veXZ2K3Z3Q3hBOXFzQjdOS2szN1JPUjJ0eHpPaWphRkJ5RmRsamtvSU0xcGRNU0lxSUhWZVZZdExaV2t2OWtJUTNnUFhYTEd3L0FORWJvbEljTTRCWmRxVFVwL1RCV0haWTlwMWttNkl6SFllMGZ1UGhEQjhtb1k3amF6M2lUVGwvK3BKTE9ZZllvUit1YkdzWTFwd1JvZUhYMDVpZVlPNjFiT3VGYnFoc25pN3Z2Rm9JRzFRcHJZRXZwZWhZdm10L3FWMis0VlhiUG1QTGczZkJ5NlRWYXJGbXZ3dUxpT05uQ3hraWFVMGs0RnJkT3QxbGZYNzZtemRlSmFUNitQVlRiZ0N6eVJaRHhLVHNKakppL1hyMmwwVnFXbFU0cXk0cjNsRm1NZkZ3Nlk5NWFYMFlWajBHTTNBK3RrNVF1cXJkby9KSW1Nc2FDYTZCSllhN1dlVnZ2MmovQzdEblZvcTM0c3V4d2ljaHNCUURFR2JFcVdicWlsVWpaSTZ4bkFBQVlSY3ZPaGN0Ynk3QXM5NTdka3BTdjF4TlJ5K2g1ZnVTMUgvZTBHNk0yTGRpQjZFTU5BRm9WMDlrTno2aDdReFZVWitpaFp4Vm9MU3V0Wkc2L1ptclg0VHNQNzBPcDgvUW9HKzh6RGJ0azZmN2tsalg4MEVLWmlVbHRsK1duZnM1VlZuM3grVXNLci9Qa0haNXB5R1BLYnIrNktHNk01ZXE1V2FCS2Rqb0Fqc1M3UGtueEFEeWMxaWZ2Wm9ia2VKYlQrWGpNczJ6MTd2dWJUVjR3aDZqVHBIRnNPVXhZMElpMVErbVp4M1g2bFBwTUFLOXVURUpaVWo0TXJRRzBiTW1rdk9BOGtFbENYMGZiZEh2Vjc5OXBONis4T1NZYnRnMXg4TVZVQUFBQTF3Q3JPQUFnQW5RR0FDQkMzdnp4RUtBczd3bjZGUURnQnhvREFBQUFBT0Erd0xZREFBQUFBSmpGd3l3dEdKWUFBQUFPQk1zUUFBQUFBTUMxK1BsaXF2eUZtdy9mWDB5MURvYzRKZDRQRUp6NkppNk81OGdLQUk3Q2M5b05kOHhCWVVSWVI2a1VWL1Q5OEJ5NEtRUmJKMU5zUHE3a1RBZkFkS3dUVlRBbTNYak5DUEZEYnBwczlBUFFhUGs4anpkK1Yzck9aUFNlOVZUU3VpUmZXZnlKMzk2VHZnc3Z6UGtEVSs0cmlxdVRvSTIwTkNkZkdTNk94bHQ0QjVQMy9EekhrVi9oTTc1R2J2ZzBvOXdUenRYQk1DaUQ0OXhmQmxlbTk3NnNlZXM5RjlKVGhsQkhhcFN2RmxvbW5xMW1ZZU8zY3lwWC95VW52ZitVL2M2WjJHSldWVmtmaTdmOU9tc1M4TXdOTFU4a0g4MGYxU0ZSR1JhajVtMFM2dUM5UDg4NHRtUXYwWFNqbUxmaDF0ZTBWK1hVNGRiaW40eDBTOW9lblpHYzhlM1FOZHIrZXJpTjFkdXRlRFJpRksvV2x2S092RDhBN2tDdnBjT0ZXK3l4SmJ2RWRoQUFBQ3E4ZXVsSVBlYmREYzJ3QVpORDVwRzJuclZyZUR4T2QwZElWbkxtOWJxdmtwRE9reGFjaDU3SjErTys4Y2kyTnF0YW1kWWNTa3k4Wjl3ZVBzNUhhc3ZacTBCV1E0cmlPOXQyVXpGS0l2NWFObzJ2YkNtMEdNb3d1OHZtNG1uOWl4RFAxMkg5NWRPc3RwZTAvdHFzNjdEMXJjbld6UHFMdVhiL3l1OThybjNqU1hpc3hwV3h3VnJydkdzZnpSL0pBOEFvOW5lM0EzQnFvaFlPZlIxRGVCejhUdmR2SWZrMDJWbDVaTWNFUjB4WExvM2Z3cEdCNnJnWjNzRUZ1dW1keHoxYjhoSGRHMzJqd05xWlBucUlhWTdZQlMxZTJwdFk2YjFsZzMwUTdBanYrOTNjSzBGU0dtY1ZzTVkzZ0MrbWd2M0JEQVVBUklET0FBQUFBQjRHRm44d21pUEdGTVl4QU5jSDh4Z0FBTTRFdERJQUFBQUFBQUFBZ0NlQS9TOEFBQUFBQUFEWEFMYjdEcUNSQWJnRVg5cEphUFNINFBSSHhDMG5EcHlPeUFjS3dCclBxUUUwM25zeUFRQjdJWTNGVXNVWjQxdjZVdXA3dUJlOTZOdmpPdklxdlJ0TVRWNVcvMnhPc0NoRWh1ZTBqTTFwV3dDTW9OWUxrVk40NnZBa3hOK0Vsc09LNmp5YlptdFFxcDZUY3NDRDBVNUx0Y1pNeE9hMTdPamQ0RFpDM29tVlE2bUxlcVpkOUd5NnZFNVdkSU9pL2xKanJoVEhkL0NtMnd6bDhQa0NZN1FEbzJkMWFubXM5dkcwZGUrNW4xNWpyMFcyZDdKcFlkSjllc081YTdvaVNkY1ducklrY2pEY0syZVpVOFFibEplNGVvNjlER254S056MUhNbkNZcDIxS1ZIcU5ubkpTMlFlVjNPUXpzZnRQUFcwanpjdFZlQldQbW51Y1BvM01YRmNmSGJLYmxuVXBBVXFlbjlXL3BZMXdXbElhd2FpZG9SellXUy9peFRXbmFiK1RVeWE1RWdma1JmVENWc3RsTmtTdCttMll5MHI4bnZRV3RxYU1TbTF1WDRmdW1VRFlCalc2c1dsU1NTTnRhcElGbUF2V2gyOU9nUUFBTTVDZExkaHlScXAveUk3dGtnNlQxcVBaOEVLOTVadGVTS1dPTzdhOG5aSS9ibkhPblhaTmJIdWlDTDhYYWVUR3IxMU1zVzJhK0FzUkFaNjFIWEU1ZWZ5UlJTWE4xNHFVNHJYNUdkSCtrblFMMDNPV2EwK3BYbjh0MXZmaVpaNm5hNlFNdXIzK3dyajQvZCtLZFg2bWltWGM4MjI3R3ptOFdPM3RIZkE4d002SzdLNCs4Z3ViNUsrT0JUbXJ5U0V2YjkwdXFrcEh5N3hUbGVrK0VRYXQwcjQ0M2RQY2xXbERUSWppcTB1MWtDd3NJY2hDZHNNZ0NIUTk2dHkvY2o0SnlLdEFnckpsMmk2bFhEaDd5Q2VmWEhVQ3JLQTZqZ1F6OWl5OHRDOG93Y0lFTEY4Yi9RNWNCM1BkWk5sZnRJMFVhenRmY1E4MXRJOWtyb3h0WWQ5TFU3ZW5yTEJ2Z2gyeElMNG5yZnhpbERrbFU2dlN4akltRjlNUlNPQ1lXQXdBUUFBQUFBQUFFUU8zREFjdWxjNW9uQnN6c0NkT0hJOFl5N2RFblFyQUFBQUFBQUFBQUFBQUFEZ2g0YzZDK0VqQlFBQUFBQUFBQUFBZ0pQOC8vNzVyL2xiNE85VHQvNzZXejdmck9kUXdOMlFmald2L1pyZWM0UUtrT2s5WHFKWEJnQ3RSSTRuYVJpalVDMENKUjZkaFFCNnlrWExWeEZ4Q0Fyb3docXdXcngraU90amlONTIvWkZFOFJCWFFUZEk4UUNJU0VjaDdib3hPdUk4SmtsQlpTSDEraVR2NGpnOVBBa2wrT0VWN09wTHFlOC90dlgrVFVaTytuN2JFZEVPOXRUTnltY2M5V1ZDTjd6YXRWV1gxako3c0F6em52cGJjOGd6MGJrMjVkSng4ZDR5UEhVWWlXYUlaRHZmS2prNTBkMzRjcW8zL2kyN01PV0xYd2VReGd3VHpob1NrZjZVNGlWNkRFZExwalcrbHpTenkrRGtSaDExeWxpVXZuNXFoZE00S1p6Tm0xZi9iTUtUbzJ5em43bDBJeGl2USt6UlFHMkNkUTA4SytSSDFpZWZKMTAwYlN2YVRCb2hINEFuMExNNlJheW5GaUtXUE9ZOEFPQ3NTTHM5ajg2MHZCeVczcDVwYjNGMTRlSjZka2ZlK0RxZFZFWWQ3NVhWWXovMzlNSHRiRm1yTWFNdUltKzY4VnN3Y0RXc3NkYnFZckhLNVBKN0RlVmVON1RLM1N6bi9QNXZZUnBDYnZLV0ZTY3pxZVF5aTdPTlAxOVNUVVIyZWt1U1lyektVMWVOL1BNakdtNnYwL3pZMm40cE5xbFN2RzFmeTdUSzhOV0JiNnYwTGl1cDhmNEZLOENtU1NXZnA1QVBnSVZXdzdKbHlXZ2RmeE9tRUFCWDVPY3hhV0RPNWQ1Tko0VXhNeXp6dVdmUFRmT0FteEI5YUdjNXk4Q2hhTnRiMjdyMiswU2pkWXI0Q0MyWDBlMkdYTS9hd01rcUEyUmJyNm1BZmxvWDRJWng0bm52TytlMm9yRWt0R04rTVJVQUFBQUFBSUNyZ0EwQkFLQ0x4eWtQYU10NVBLMXRNWmJBYkRERzdneDZGd0FBQUFEZytzQ21Bd0FBQUFBQUFBQUFBQUFBQURBVU9KN0JKREMweHZMK1lxcDFjdHRmZjlzL1NCNzVBL2RoUkk1SHFOTkpNclQwcDdyeEE3RVBqOXVtUlJ1Q3N4QTltajl3NUVwa3VEY2VBbkVOR2svSVduMjhodndobmRTVkJYMGVPUkFKZ0NsRURwSjlHTjREVlZ0TVBQTXdWeWdCb0tHZHZuVUtXOVk2WDYzR2U1NWMxSWlQblJsVlhMSFJ6UmtIK1dKcTVzTTN1Y3l2TnVhVlBGbVUxYVl0YmQ1YWxnZHYyMnNEdi9mSXVwWis5N1pOZE9IMXJrUmNlSlNXVmE5MW5rcnBwWG9WUjlWaTV6dlMrYmZNdWZWOHpkc1BUTklGL1JVaG5hclBscTJlWkcvTlV5MWRuVGJXSG0yYlQrK0NGTlBQYmZkcnBmT1VsUjNoRVpsR3ZzMVhlTW0xSnJJNCs1TmRKTGg1M0hLL2tUSFZwaU9scncvblRYdzJ5MVEweVZDMGxvM2luVkZhWGlzZEFFL0d1d0tNbUVPZWVldmg5TnRDQUFBWVNNc3VpZExyMVdueHFJelF5OUZYQ3F4ZFlITEdXMlhOV21OYWJkYzkycmlaU09WYXQyUkpLQ09hSDl5ZlZxWFNJOXR5ejBaZFJZbWtqK1M1RUp5dk1LcXZZbC9ubEdWNHZpREt4ZGNVOHBmc0s5VkNkUDlPeE5OWnAvZjZWRHg4aHZGYWVzeHpadm5yZkVUNi83Yy82K3RFNm1mMUcxL0crOW1XNk0rc0FqTU4zOVl5RWd6QU5LTEtSc3NEQUdESjlSK3Z1VldrZUJycENPZVdJKzUxRE0rMHRsYlpFYVp0MUV3R085RHJoRWlPL0szN0pOQk5qODlNa2pXeUc2TmJid2tNclpOaGJmdXdPSXluYmF1OWVlMG1OL1JCdEx0QkhId3hGUUFBd0RYQXFnOEFBQUNBV3dJakI0QXhZQzRCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlENTRDMFZBQUQ0NVd2NTQzTnFsMDNMaWFPTlAzRHVKeHZYR3RFUFRqd2Q3ZkE0cWUya2VKb3VNdGdBNkVIU0dYVE1kWXpCRVNjdUhLWlRlN0ErcENKY2x5cHRxeEh2K1FyaXUzclpseDZBTHJUQi9ORHhKNmtJNmJRcExxK1Vib2xmVG1RcFJFRHhDZ0RQSmp2RHVQaWhZMGc2ZmlzYmxVaEdmRW4raWxvR0V6MlZtei9aTzlZd1BSdUdRazdLaWxrVXk5Y2JQMTlRSmFkdXYwL2p5cXYwbjdSYUcxdEgvUEpsMnZtbHRCNUwxTkt5a2pHWEFuVkp6ckk4NlpiNzh1YWxNbHJxbnBPdjd0N2o4NHFScnNleDRjMmpLYXk2UHFUdHN6S21DdmtqYjAvWDU1S3RSTkJGdXREYzYvUHZ0M1pFSVdWbVFWeDl2TjVuenF0ZmI5MUtjZUlkZTNYYWFMeTFKa2p6Vnd1WDlPeTIxZmt5azFHbnVxeGtoSG4xVkxEb2VoeElCbUxKdWl4NlJHT1IyblRrdlBiYUJpVlEvaktub3YyWFYzK3RWMk0rUEdvUmNQSmEwVFNmRnU2aEp5OEFUNkZsSmV6VkdUT3dWa1pMMXdBQXdGRlk5cFRsemZEb3QxN2RGN1ZHNnpCTEx5Y1NicFhqOFVSWWx2a0krOUxyM2ZGNjByaTBVaG5XN2k5U3AySHJvdFNoUFIwZUhUemVjSEIvdEFtNmg5S3M2K0IxRmJUSVB6SGFsMGEvc2I1aXljWEhQWDk2am0xZHRvT2p0UHE2TnZtelVPYTZMdHRWanJNQ2RCK2k5WFhQanhkWHJ4T1ZyckgxbnNkeTVvWUp1WDIzTXRyZm4zRks3NzJRUEhLZHNwNU9NbEM0OUlXRTY5ME13SEhJS3ZPRDlrZ0Q0eGtBRitYOUg4VWlrQjZER1k4TnBjZHIxaGRVTi9WTHRtbnQzZWRESFZ3RXoxN0t5a3Z6UjUxSG9Kc1I4OWFTYlpYWitqUysxb0dVYUwwdFMxOUxjM3NrQit5TWNscmlQUEhBUnJMUlV4V2VrcnZ2elMrb1ZuSVdXMFFxR2t0Q1AvaGlLZ0FBWEJRc2RoTkI0d0lBQUFBQUFBREFpNGR0a0RJMmhIdURGZ2NBUklET0FBQ0Fjd0c5REFBQUFBQndRMkRrQVFBQUFBQUFBQUFBd01rWERhaC9CZng3T2hjOTdVczVYRXRoeG8vV3UvbmMzdWRhU2hjSmZ5ckw0TW5rdW9lV3dRYkFET2o0ZGxDcUU2VGNlWnpwYnpFVkpKMlIrV1FwTVNkUVFDZUFLeExVSllESFkyWklab1I1VW80a0FBQ0p5KzhYckdObCsrUnVEelU3U0FsMjZ0L1BhWjFXeDNKR1RldGc4SjYvNWFuVDhxOTN3QjY1V00yY1BMMnl0Zk1XdmJLOWZTQ2RSaitqYjZLZUhXNU14ZXEydlZ0dis2M0xidGlxTVpWaFR1WW5ZV3NkTUdQWE5zS0pJcFh0T1ZhUTYxOHJIWGZkd214bmtqVnZKOHlwRXRHcDNKclJVeWRwN1JoM3YxR05VZGRnSnQ1UjdJbjNsZ01BR0k5MVNPNlJjSFVvd1dzQUFMZ2FFVS9DWFJpdDIwZTJVOVFuSG8zM3Bqa05vN2FrRkR6REFTM3NyU3dsOTV4V0I4bEZKTGtTTGthNTdZcFZxdisyNUk3NlhYOXpVU25jQUpGOXZIbFFuVFFaYTlvOTB5MER2d2loUmIxZVFtTlBFejdQMnFRVXlValJ6VTEwQkxneGtpczhKVGhtQU9na2JEWUc1bHhaQkwzTURQL2EyRS9rZVJJNG1OWU90MHhiN1JvTVo2ODNnTFJ1NzVVOVVvNzI5c0pqMld0ZTBvVnM0aXNqb0lIR2ZoZmZCMmY2RnlwL0hsOWM0Tm9YZWRQWlJ0K2IxQjQ0V0U1YThDRWIxeVVZRDhDWnNLekJvbDluWVh6N1hQcTg2RXVSSFdGWnpocTVaOWlJNExSUSs0UERtdWczdFVlaUpnUk5vKzFOelpmU1h3bm9CcVhBTGdHajRlWnZkSkVidnNwWnN5dENWbUt5a1hNNUVFbC9sUEZKdDQxUnI1Y0pyZWpmUFBRTGVaS0dDbmU0SUxjWWFUUXRHTjJFaldpWFBSZXYxamFXNmhpNWY2dHNienRZYjRqTjlOTjRGRlZXOGxSMWM4NnBaZTZWSXVranBlejgrNVJ5VTZPTkNpaXI3RlFuK2RmOHFnOWVaY3Q5MFRLV3RQdU5XRGRSUExLOVRyTG9mT2ZHdGJkTlc4dms4dEpnbzQzTGV6RHgrUXF6bnJFcVFwclhqbm1lU1YyMmxhekdLYzFrTVY3SGpKYW9yV2JXS0piQ1I2NVMxb3JBcFI5ZEJ3Q3VURlJiUmVmT2lKV2oxNnJIZkFjQUhFM3ZicGV6djg3MEdOanlobHdGYWMzWTR6RkNyNWNqUjJTUFhoeDd0K0JwUWppNE5qTVZtaVJibTJTY2twUHFOTUpkR2VEYjd6YmlSNGZiWndZamFML2hyY3BZMzZkMDN6bjhyS09GWHNXVFYzL0o5K1Yvd0ozSnRXZFlVMGtjTGI0V1BVMXVrajJDdXRYNXNmUEwwSHB4amJLempnREFSV1RzYVdySlkrc0JBSDVoN0VtWCtpZVB5NlQzcnRScG5kWExrQjNCNWFkeXVQQzcrQkFlaFhlLzVIbnRvVEQ1d0s1RXR0eFpTYWZ0V0x4MThMeTE0c25UVXZadG1QWHd2WlladmFaNFhrOEIwOWlvNDV6VzcyMDV4NUJrYjZRNmUrYkw1T3FrWFFPYjFROVR2eDBkK1NuTnVveXVUSzQxNEdqeFk2M3UxcE5KQU02QU5JNHR4NVZUVjVTR3VOdXBJZTdkV3dHUG10NkloOTRHWjhMNmpZRjNRM2J6Y2UzeDlYaWVIN2hNTytJUTVlUURNSlRpRE5zTnkwTXJwWXNhNy9XRGZXN1ArUnZPcGRmVDFXbU5WK0RvL20rSi9aOEMrUDdCR3ZlajFOSmxTR2dib2xwRGVjdUlXSWVqQmxWa2daSWUxMWdid3pwL0t5VjRMZVdQakd2UFJvRzdidDM0UnVSNE55c1JUM0NKbFNGNS9LUjZpMVZ3Yk1hS0pDU3p3WVg4V0REK2UvUnEvaGJ2K0g2WFhzbndoTmR4dEE1ZTJWNm9YdXJZNklyNUxKM1lVdmZXK1Z1WGJTVVhERVpOckJSUmU3MzFUSVlzZm54djhlcmYxbkVUWTNaSjBraVNWdDJlbnZBd1F5WUFUNkIxZFcwcHA1VVI4eHM2QWdCd1JiUkg2eEd2eFZtWVdiZVJzbHZiZHNaNlpWMWIrZFc0MFIweTRrRkQ3MVliM0pNOU41QXRianNyZmhmRlBLYVFrVDlJTGN4Zi9USjlqVXZUemZuQkxWOVcvUGxERm5KOHJJQkNydjExV2NLdGV1aEt0N1kvSk5teFBXV3NIM3I3TFF0UzEzWlZNZTZoeGM5Y0pabjFKajhBZXlBOUZzMkJjQUFBUy8xcUJMZnZsek8rL3ZFK1JuTThGdXoxTVVncm91dCt3SFhvZmMwQm5JcEkxMGoreVpUNmx2NlFIMHNJcC9ybnNVTnU5STIzdkw3aTFSSFMvZ2gyNUR5VTE4d2t2Szl3dHN4ak1JNzNEMU1YNTBuOW9uRDl3ckRYWjEvREtkWlRHWGRleS9QeEswU1FVdjBMeFF5dWlqU09OY09ENklyWkwxeFdSVjBUMnNiYXpTeS9LUkhTWk5vZ1FsOFVrZ2MvWEFXNzBiSnBNY1kxK0VVek44VHc1VjMrSW9RbkcrZ1F3QktadDV4M2JOY3h0WWMzSlpNU3Qzdk9iWTdscFF4SlZyU1JLaTBoM0tiMXBkVFAxeHpwOVR1QUtaT1V2WlZLMGtxR0paVXAxdEtaYnFRTW1wNjdYOE5nTm1WYmFKT0l1N1prUk1yVU5nb1czcnBJWHBYa3lCK2QxNTYrNGhRVmNmdVhsTHh0SVk0V01xZms5VmFiWTFSMi9JV3Y1WWZyZGJWK0wrdTJpVmdpeXVia0hXRGRUOVNRbE1LdGhTbHlYeVAxVHkrV2J0WEc3MTZVSkJxU3JVMjV5UmZWb2YzdDRGMjFJaVcxTkljMmFsdDYzNnFEVjFOYWRRRUEvREpDSzQxYWxVWmExZDdWRndBQXJvQjNOK0FOSDZHM2sxR0dONzBYeTlhcjA3VFlrM1hjM210RTdxekxqUDdjaGNwMWlIWDVRZlFPV005RzJMTkJUS205RGkwYjVvR0RmTTg1WTMyRk5WcVg2UHFsbHpLK0piYjN1eTVqKzdYV1g2UVE2aHZOU2ZOUFIzMkM5R29wSzduU2wxWFpWaDA0U2FQdGlGekpEZmlTM1JhRk1vNHJmM1NwWkdaSlJ0dEEvalN4RmMvSkJDQ0s5S2hPR3JkSkNMZW1vL1RJemxZcEFEd0t6ek9OelJKZ1BYcnpGcXFFN1dQTHJkTlk2Y0RGa0I0RWF1bTFhekNNMXEyb3RtTlovczFHMmhIZE9tcTNoeUZHaUF3TXIwTzZGV2wvQkR0eURKYWhvV1JMaVZucmhmeVJqeEtNbXRkZ3l4Y04wSndsMFU0b3pyRFRnOUVId1BOWVZwNklZUUZkRVlPMjhZRFZQdUlES2NGd0FMcndqTzhTdkg0WU16Y0VZYmtadWdJNEtZRzQzUWRWaTdIVFc2TCs4c2pzMHEzNzdXME4rODVtdHZYVFBXTFVvQnhvWUxKbFBhbTlyVGJ0ZkhJNEMyY2R0RU1tUGo5Qy9iMS9QbTNET0RpVkVYSDNjWHptdVdvKzZrLzcxUUZQVkZwcDhYM0RGd0dBekJPMUV1WStBQURzVDQvdUhmR3VoQ2YrcUxXdzExWTk1YnBHalF0bEs0WjErV0gwVG1oUC9wc1BxbjF2cjNURSt0UHJqM1NPM05FWGNxVmY2N210Zk9zZndOcFNwTmpXRjIweSsvdXkrKzhUUHo5Q1BmeCs0U29FSS9HdW56REVBTmdGYlE5cXJiK1JkekxQZ3JXbTRpblpqV2pacjRGVEUrbENTVjh0WUk2ZmtDc29Yd3ljTVFpVDJmeENhb3JseStpdlUvQlZSS2RTTzZOL2pENUxKamdBNlFRZGRDdzRJNjBxMFRtdXJWTmRORXBia2VkRGUvYzJjaHFLc0xrVVAyREc1SGwvdEFiNkNNeGlsUEg3NExXVGUyZWtaOXFLWDBndGNsb2hHanlkN0l3dlFseFJycnZSSGhGNEZWTjJ5bHlIYzN2TjVjZXAwb3NTUmRnb2ZFNzA5cDUxVnh4cFNPcnlXL3J5UmRTY2ZmZjlybW5SWHVLd2pCeXIwejBiS2M1QzFMUmtWbVI1NnNKUlNObkpLTU83TWRUU2FRWWxsOGRiRnczdnBCOUZYV2VyalNuMHZscnFaclV4S1N0TCtVbGRzbGV1Z3g5anZpNkRGNTNMdW96aUdvTmV2VU1SN3JmUWVDNlBVMmJUbktuRGt4RHZxVU15WkhyN002YXY5WFRjZld2M1R1WlVyY2ZwK0tSZnlkNVVrY1FuVDM5WHNsWlZEWTQ1NzdDSXlCU0Y2N2s4cGs1MEZPOUI2MHBZSEdtODZmYThYd0RPREtkZlBKWmZJZjlHNXBha3ArcDRMdHlLdDFiR3lMeUhyZ0FBWElXb3ZtclJoVlkrNzFvUTNZRjZkdUE5ZUR3TjNuV3R4ckpGUFRaOEwxcWRWbjcza3JaMWlDNmdYUG9ScmhGd2ZrWU4zRmJqenl0N2xrRkhYQXcvZURldDNIV3c2TmJtU00xNTJ3N0JiQ216dmF6dGM1SjEvUGk2MEhmK2VvWmI1RWVwZlA1MVRyazkxcytSNnIxZFBiWktDbnZNVm5MWEpjcjNZMzlWZHBHNXBKY2xTVmZaOFBIbFRTNmhOT3F2bElnNnNnQTRJejFPRlFCQTh6T05uL1czOFB2aFlqeHFkOW1rUzVMTTEwVmFDU1BQbGFnTUNwYkFtOU5uMG9JRzlwNVQwdjZoQlU1WDl2b1ZINk5qV2phNFd1TkdPaUg2Z04rU3k2VUZ3L2pwWHFYdHhmZTVlOHVzcnEzbndPaitkdjU4L08vam1ySDI3NTlacHVMdm1sam9BOGprWHdEdWhQUjJsUFVVUEtCTE1IWDhGUEwvVFh6eE56M1VQYmdNc0UvY2pHd3FUZGNBMElXMUo3a0J4OW8ydnRMZnFmTDZrYi8wOEdMbHNDaldheWxIdElDMUtSdFpwMnlVUGJLc00wK1FQVGZDRjMxMFZvVC9TK25lT084MzIyWExSZTh3dGs1bFNEelZvakgwVlNiL3ppaGIvR0hyQUU3Y3JkbTRIc1ZlejQ4ODA5bTdmOEFlQTRCam1XV3h1a3ljQVRJQkFPQk00TmxXSDV5ZWIzbC8wdHB5MDdTUjhGWm9YVHozaFhVUGhObHIwUFFhWm5tUUxHRlN1VnhxZzJsOXhCRzUvVzBaKzJrSmIxbGNIY3V3d2ZLUnFkZmhVK3JXOTFrMjZUeGxGM0lkaCsvcHBRNzFvYWEvL3liMjN6MDVzdXdwcFZvdmNzT0lBMWZBWStSS0JpY0FRSnc2M2ozbjFDbTF3M3lGU25nd1dCdDJ4L3RLeUtpeXRPdGVlUklZU2hNNXd3WVFIVHdWejVkU3krcVBNVnowTGJ2TDhmVng3MnhaK2pQNnkvNzlYSUFkbE9wZitsTm83NDFjNm9aM3hocFUwalVBVjBEYWxVdHZXcEp4WGhSeFZoRVNSUy95UHVyS09BSXJjK21DVDdTc2p5MEJNQTNwVko2SDJSdGVFMElLODhSNWVaL0FNOU5MQXU1SmRxYlpaVnhOL0hITmdGVDJhZU8vVXJqWEZ1cDRLWi9NVm1LMnZvNUhzaTdwZjc2VStyLy9mNjVUQS9INnJ2TlpScWtXNzdGT0xiejlZTW1tOXlPZEN0T0NKTnU2OXBSdmVTaGJ5OVRLa3ZESzlIcFY3ZmxwaDF1T2dDd1hUUXo4amVva3YvRXI5UGk4ZDBSa1YwV3YrZnI5N0JzS1c1aWFyNUpBMGk5aDJyVWtJd2xsYStOQTY0ZWk1QjIxcnBTQlpmZlVsYVRKeHJWVXBwUXVpeGVmN3UxUkNVbExVNnByYVN4NXg2a1BibFRUdUZsUVYyOFM2dUNaVWEwcmphY01BRUFmWHF2WSsyaUhobkdyY1BSbEJDdTlwcWNBQU9DcTlPNGFJanR3S2ErMTgxejRRK0k5TzdNb1hsT2VXNzhzcnc3Tm01eGxTV1gySUQ2VHJQM3FVdDc4OGJ1cmE2UFZlTjUwMmxZekdYa2RvajNoSTVncHU1Y3oxKzBIYXpKNUoycFBHUzB5cmZSWkw3cFZRYmYwWjZ2dWJIRi9mUEx5enhleTZZZHRKLzRGVlV0YkpDRitTVlBVdXF3bEZLTW1lWlhPK3NKcUlibnJrUGpITDVZeTY2dGYvcnhYNTkrNlNjUFcvZ290M3g3YVYxQnBmK1lxOXpvUFA1YmtlQy9VQXFuL1RXclptd1YzNDllc2tudlgwM2VSZ2t6dy85bDcxeTNMVlJ4UkYxYm43dmQvd0ZNL2VqL0dxVEdLM1prWmptQmloQ1F1dm41ZmpWb1o1bTRNUWhLZUdIcXBPVjFDQ0twdjNPTE16ZFBsaWlYREZ4N01pSGF4U3h0L3hINEtqZjBWWWRreGEwWFJGbFZidGpSUkFmQk5UWDFtYlJobW5qWFZWMmJ0c2JYOGVDT1B1V2R2eVZQdVk0ZWdkM0JJRHRrZXZBTzBWU2N5NGpCaXBuOTQ4MzFjZi8zYjQ3Ymo4Yy9ubHpXaCs5Mm5LM1BVQ2dRQTd3VFpNSWVhb1dna0tkY0FsNENCdVpTV0NMRWErendpbUVZeWhqMldXRnpGa0orRXJhVmZ3NENpOFVYcUxucW1XOVFMYnBSNzQzMStNNTczK0Z3WkluMjJaUHMzNVFGRnVvL3M2VE92SHpsbm10NHQ1UjN1N3ZoQXlqYms0VWZVVVFzSFA5cFlXdGZIWnp4RmE1MTVMMmd6cTJmbVlVTUF6T2RrYldRWlQ3MHZBSUNaSENFcld6cmtVWmFacEtPMmROdmV0c3k4aDVHeXZ1MzY3QVhvcFN3d1VyVDloeFZjV1hlNHZGNXpSQU10ZzJLUm9Uejc5bzYwaDhka1NidlRVM0U5QS85WFVKTTd2N2VPWkh3N1F2L2hxcmIyN1VOYVAvcThHdTE5cVdPSUhUR25nWHNXWnJMQ0VadkR0Z0s4ak5tMnlCVjJKc3UyQUxnNTgvV2poN05pVG5ySzlPNy9Bc0E5NlAxeDZtOTZ6MUpDVnF4RitXRnE3cXhidXpvZjlxQjduTDZ0M2FoV0hrYnVYM3I2WERybUJ1QUJSQ0dndHNCcXJ3SGJ0aGh1UElVa0dSQ0xhR3RIQklNeWsvYnBxM1VBakdCWkc3WHdzb3lIanRFUk5hSTgvVjVDbE1zQjRFQk9uOGM5czYxRTAxenlHSnZ3azgyQk1zWmp0R2xiS2w4V2NPRzkySDBSTlRYcXpuU1Z1ZzZodFZmcVMybVE1UEY1R1NNTGpqZWRwUzVCcVRPVldVdGYzbThQMXI2T1FsNUxHNlR4YXMxWFloRVdvODlieXBNcWZ4dkhzM09vcFd6eXhLS01XRlNUeExaOGVpT2o5RmkvWDRUTjZ2emZQUHY1V3h2blphT3Npa1NyLzZ5V29HVUxwaFd1T2JaYTF4S2VjVDV6bkdwMTVmRlNYWjYxc0xPTkk4cHRVSnBpV20raUk2K2Qya3VJVXM5S2FDTm1SUExWMGxsR3YyVVZzcUxWV1V2dnJRUGd5VGpWQ0xQVzZYQVJtdXV5K2lMeU1qejFBZ0E4QVk4MlhWcmVlWGdJc2dYaW9iYkZsTEsvQyt1dm02akUxZG9SRGVrOGRWdlhKOC8yUTFRVTVWYTB0R2YzSjd4U1ZsbW1xeTl5ZjEwUjdMR09RMC9kbFRLVEkvenBuR0wvbE9aeDZjNlI0bnNtVVU1dFl0Znl0OElkSGJYU0Z1MlhSMTkrZGlGM3o1eWJKUnZyWGcyNXJmVXlQKyt2TEZQNzJtZjdDN0Q3K0ZiYnBESmJQODdVMXAxV1cxcElYMnROWC8rTFgvL3o1SlhhVWZaOU1xYXQ3NjZVZlZlU3F0ZmxtSXJOUEU3L1pOUUVWQ3l5cDgrMEtXVU4xT3JZenc2QUlieHJvS0puTnRNQ3dIN3JzbVlJcFNMdEYvK1VlWW9sd2J5WFV5eExxWkl3RldtMFZVanpCeUFPYm9yMllLWDBsakpoT3BJR2E4M250ZDlHVEdsdmVzdSswZDVPMnNkYjZub3NJdzk2VnRtV1RtZmhXSUxIaHlhWnBLbDR6bUs2NEtkbS84TWN6RjlNWFUzUHdPaGlHMDJ0VmJIbEpMWnkyQTBCd0tua0dtYnZ2RWRlSEVweXh2TjRZQW1sZGRxQ1Fia01xeThMNEJCT0g0QTFRK21vbXY5K1FYVlY2YlpYVnVUWENhd3lJbFdLT2Y2eG52Y2N6NjM3Q0xSN08vSytKVGYzR1V4d3FRdmV2cjgvRE0xT3NTLzlPQk51dS95aWFpNlA1QitWQ3pPN2U4TDMzc3pkNXRxZDVNUENkajVjVkY1dE5FdnRPY045czJMZkRRRHVpN1pGQlFBQWJZNTR1ZXNJMWIzMm94VnRPK0NJTldPMFRrOSswZlIyMWpHQ2Q5OXd4cGlZOFRyS2t6amx2cE53R1pYNGpySzc0NlhCMWhKUVJmaEtXN1RmdGs1S2ZFK1o3V3QvT1Q4L1Z2U1hrWXJyL1YvMWZQWXl0WEJyL0Q2ZC9nUEovS3VqTS9aMnZHV3MrT0pwYXgxZVQzU0dPMUMzTko2Nmx3TzNBRWNJd0tHVTd6RVkxTWo1YlNqTGYvcXJCZUJuaGxMZktvT3hOcFZ4bTh1SGJxbkFyYmlTL0djUVRjZnlnMVR2aDhKNnY1QXFnUnF5aGw5bHQzNThIU0lMdDd6RTB6cjk1QndIamtCcmhlcjk2WFJaRnRqNnd6T0k4bmo2R3E2RThiUWVKZm83TGxYeWhFYWVWMUoweE80bGhPTEVqWS9yNHVYejMzOTR2cUFLTUEydlZ2dXlOYkJuMzk2cVJuekhKeUZDS2dDZ0Y4OFlPOVZ3MGdTVE5tbEdhbzVmTlh6V29YNEYwVmg2Tzczd09tTlZrUWpabDFUalI3S2ZabG1NVEVHQjNCM05MK1Zyc2RwdDBob0htdWRBVzh4bWpiRmFuZEsxVkhkdHpPVnBVcGcvSnl6alhXcGZiNW5lY2tLbExkWnJyZXg5K2xqeEt1WW44KzZqazdNRis3cTNIOFNXY1Q5ZmNTbkdzWFFpdlRqT1l5VmRPYmFDTVcvSXlxaUZTMmh6c0ZhbnRheW9wTzJaTDlZNlBBcHpPWS9MTWdacGVjWS9naXJ6VzFnaXhHdDE2RFZrb21jNWJmQ3pqdnVmbHNTb1N6RHZIc2tWWEpZOWczSVdXelVCQU9oRFdnRWxVUm1FOUMyaytlcFpUYVUyYVNzL0FBRHM4VnFlMnByUTRwOWdzOUMwTWkyNmI4M2FzOVJkcHBYQ3BUSjYxcUhkZlhjVUl0WnRmYUJGM1pKTHJjZE1tc1VNblIrN1lRRlhWTUNrY2YxNTJjNlRKNnk0WDZ6ZXFwNTRxOXp5bExrSzdXdXRaYXNxWGZsUlZnclhHRXl0cjVIbTF6cVNsWkkrN2pmL2Nlby9mMWJMZlovRzRxOVdYMjFsYUVSMWxVdk4yTGo3YSsvQktUMkcrekZUcjZNc3UrTFYzb1g4ZkI2ODFwYThFR0dSSy8yUHBSOXkrekpxN3I5MnY4MjdhSkdFOStEVjdRQmdIVW5Zbm9vL3kwT3UrMGdmNHBhV0l5bEJicXZ0MXViNEdiWmZWNHU2aW5pdmZ3QnVqbVpBN0ZXN2ZUeUQ1RFpvY3FDVnhscjJpRFdYalBHdkhYTEsyckJMazRKdmN5MFBMOHNMU2poeTRGaDZuVVpiOXN5Y3pmbkg2d3V1bFIxZ05yL0tidDJjU2JIaEpyRUlmRS9jYVhqZlpPcU5meXUxTjdGR1FUbUVPOUFwRTNLakdiSFNoN2hPZmNtT3ZHL3BZemdOYlMzekdrOWEzRU5ZdWZ3akQrQXcwcVEwajJmRmpOKzBnSGxsMngrVlpoZ2RZZUM4elloYXFWR2p0ZjlsNFppeWRxdm5VVGdlMWFkRE13cmhmV1czdWVMWWVycnN1RUJmYjc5NG5uRzBvN2pNelY4RDc0QjAxNjJudm1JMEhGa1hBTmk1aWxSRUZnQUF3RzlhdnkrVDhMN2dsb3hoUFdXNXl5bGVQcTRwNmQ0eWU5clFxeERNZXNYa3FES2dZS0lQYVJwQ25lcmhxaVVMemYrbmJGSEtYek9WUTQ1amZkMzJINnArQ3VhWlgwajFNdk1McVQvVG8yK2lyTFVoRC9CVC9weThDSEFjNVhUVEZNbmVsNUxmdGcwSzBJazA1VmJ1SW8yV3kvU0diNlExcE1lcEFwZW45bmhuL3h3RkxzVGJYNzk2TWljOTEzZStJWE0rdjJxQlZzZk9qRk1EVG1QRkNuWHJEbG1FMTJIQXkvcHdaeVFaVUp3Y3RjWEhSajZ2dldRVlA3Y1FVelg1clBTdFIzYnNkTmkwTHhJeEE4dklmeGs5US85NDhJRHQzWE1JbnZoWXYweVYrRDlkWGNvbmhBWE1vTFVaZHprMHdXWDVaZjNuaXd1eCtuT1J2SVFvbEtSSmlWcThWY1A2YWtNcEkzYW5UWWRxdXJxc2tOcGJMM01mTVBLYW9YZkJzZTRDajJEc2orRTZVdGozb2RTbmxwZHhySFZvV050UWEzdnIrYlFVNmFEVUpkSGpQUEgyaDFSS1F5akduMWVJL2w3K2ZhdFZmNW1zM2JZMDlYNExRMUM4bmRiWWN0WTFxZTl0WlZobGhVV3JpeDN4bGpyS2VFMUdhblBNZ2VlSHBsSmE3MUxYYkg1czM3NG1LbzF2dzdhYUZMTmgzWkxPUVFrUGpuVFNGNjZzVDJlMGJRQndQSjU1bWN1aEVWL0RES1EyYUcwREFJQTlNL1RJMHRxWDhveks2Qm5Xa2xhV2xHN0craUtkV0srbXIwYUdhcWRId1pUUnpGOVRmd3lhemxlM0MyYnJFVWZlcjJhcXVndXoyTU9lOGtMRlhLNGxqYUh2TjJCRjIxeE5qYzFMdFN4TFhaSTNNby8zZEhrVVVyWjhnOWJ4SFl0YVV4RXVmZVd6NzdHMXBYb1MwdFh1VS9vQnFQZUhvVDAvNnBUMlpxUXlwZlo0NW04cUZvQW8rTFovZmxncmxhUHpzMFZmV29UbDlTZlNPSTFpclpVRjdVOXdFcFBVMjVMbGlkTDFaL0pkbldWWTE1ZFRsWVVYb0NXWVV5VitsbUtSaWpvQVhvSmRyL29Lcnl4RGVaNlBLVlRiNkFsWlhSMWJka21vczczNnlycXNWRDVpNENYVW5ETlJTUXVINFYzeXRmaVdHdEdMSmp2THVucnMzdGZqZFVac2FXcnhrcEEzTDRJQkZ1SDFEWmQ1ODN5YWFTcThzdG5PRStCby9na0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWJpdi83bjN4OC9HcGErWHZOZi81Mm4yZUxyVERtNThFcDRqa2V3MGpvcDZnMVlqNytZMGRjQUsya2Q3Mks5M29MVFoxR1dFMVdzVStKVzhuakdLWG1OdnEwbFFiVEFxVmlQYm51Y2d0V0hkbkJTbnFiczB2OEk0VUhJbDhxSUxkSnoxRE84RTZ2QjFHTFZ5YkZEZUMxQnJSdzViVktFM3MrSjVrRnBnMFZxYUxUdlMveUlYS2FBL1A2YVkwcjZmZmVqYVk0OWRWdVBsNVBTVy9KSVphdzR0MnhsMmF2YklEMC96M1B0TkZLRzZDeFRPQll2RlhNcXIwWjBNZXpzZ2xSdlllMnpMVEdJZGZ0Ty9Kc25HK2ZWMlZKdXJHTnMxcGdha1U4clplbXNzbzFscG9ZTUZaZTA4dXNJd3RjU3RqSXNqM01Yb0xYQmhxVVhySzdDVnJpa3FsdnhhQkVTK0JvQXptWG10b0sxakZtK2lDME5zZ01BNEZncndXSU4xZUpiZFY5QmxsdjA1Kys0R05TdlB1YVp0YkozMTRYSjhwMm9idjUvVTNXTk9rMFZxNGR3NW5yczBVT3NwdHFSWTJ0R1hXZm9OSlp4bkdZMHF2V0F0UnVYeHEwaXdHWSsvNVZqU1p0TFhoMTliQzV0K3dkcGwwNHJxNVgvSis2ek5zdFhUTXN5dGV0NkdmdS9hdXkvTEtwSmx6TDhiNXowL21BUGx2djdTYXM5Nzg4bjJldFRDcFg0S0pZaVlTeGQ5TmNWaTJGcWxLMTlJUlhnQ2hqWFF2ZDJBdU1lWG82a1YxbnRoZGJVK2RoeXRSakMzdTIvUnJwZUc5eFJCZHlaM29IdE1VcWd5Um0raU5DbzAvcjRqclo3ODdvWVlnS3JIMHBldHZaUWtBbnpNRHpYRHpNM0NmR0ZXZnduYVdGS1MxVTNpdWJ4bmdCZlRBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFNy8rL2tZNFB5Y3RmbDl1WDRRb3YwWmpPV2dpeDV2K012VGVzS2ZzTjlBNlhVRDd0VHpIU01EVmlZMHc1OUdNemRPcHZwSjdUeUVPd3ZXbDBUb2lSN3J4MUk0dS95NnIrQkJiNVFrY2VjSVE1cHl1Qys5R083N2w1V3VncGtZa1E5NG81QmZ6bFNmdUZCbVRSNmpBTy9FZXkxUTdzVTlhekZlZUlxWVNCK00vMDZYc1JzdlR0c3ZyVklUTE9wRkhrYkJTdEdVbkpBcTd1ZkpseGI5Qk1SUWZlV3dvRWlQbjZrbURxRVFyMnp2WUxKcW9kbDhqOTYweDY1amwxc3FrbGUydFE4dm5PZHF2dCs0eWZJdXo5SVAzK2JXUHZNdjE4bzk1R0N1dC9ZcmZUN0g0K1U4cVc1RHlpNjhxNHFkTUVxZEVxdGJ4clRpb1U4bzZubHA1ck1kQWF1Vm80WmEwbnZ1Smh2QThUdXJNWHBuaG1kZXR2TFg4cFNKWk9lNXhSemxtaExGVmxsMzc4a0tsMk9ZU1VZN2JrT1dSeXFwZE4vQStOYzFsYUVscnhTdHRWNW9GMmlpZlZRL0EwNWlwUGZiT3MxNE5zSlpYaWdjQWVEbzk4cnhseGJiU2VkVGtvTlN4U282UGVDS2ErcmZnUWlxdGZtMGZUREs5eGZnODhLc3kwZXhKalRJTUpFZWFzanQ2ZGUrUjlkcmlsZkZTUGs5dkczcnFYbTBYVmVzVUVtMWZYaWpqcTEveURYdFRQVWtUWFNJS2ZkNGFYSXJyeVBOTWFqSml0ZzRwalNuUE5rZ3RqZVUrZi92b3lxOTRwaXprWng3WGE3UDJaZXVybmltMEI0WDF5NmdXWXJNSGt5RmZLdXF1azhmLzdkT2ZjbUpXYXZvWXlQdGE4enJMMmp4Zmh0WEdiQkw2WElyL1NSZGM0VnRwYmNyN2JxNjhuK1ZxazZhVnR4bGZKcmY0SXdFbVVRcGtDVTM0SzI1MmdLZFNUaDNKUnRHVUdaYy9VbDk0VGZHN0Qzc2I3RUpyMVgxck9Od09UYTBxa1hRcEJrWTMza2RRNWkzbFY4N29mUGZnYVhlT3Q4MTVtdGNQTzgxMG1WbUgxYkJuOFZpUDRmbGEvWFZSZVBVbEN1VWt3M05rZmg0UFgwd0ZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlB4WC8vemI5UHYwZi9ydjMvKzFnNHJXbkdTNDZVWU9RWUNQckVPSm9BN29ZMWo0K2tnMGdreXRmRFhUWjFCMmRFOG1DOEd2b0lLMTBJN3V1V2w0N1YyU3FCMFBhMU9yZEx2aEpWdzVBclU2Qm5JbDVJRjNyT2xXdWZqN1ZQa3FmUVRzSThqQ2EzOE9hWExJQ3hVbVdGVklQZXQ4K2VSeXRBc2ZHOTVJMldzb0xlUFY3VGhEbjA3czY0UjJmSFRobFJSMnFOdzR2dVdkb3RQTGZzaG03YVNHUDVJTG4xaFl5dGExQVVxL1hDNEQ4bWp6SlJ4cThmdDFXWEhsZHIwaGNVdTdwMTJtazQ3d1JiM2NvU2E3WEU5akU3Zm52czVYR1FBM0JDUE9JdU5mRnY4R1hPdXg4VndoSXdFQUxnNnN6UjN6NTVjYk9UVm1MM09XTm9VSzQzNCtLaGEwUGZUcW5XbmRyeEdxbDBZeXhwWkEzdWZnZVc1ejM2K2x2dTAxdWx0bThVKzZtbURwY3pTQjFQenlaVDd2TksrcitUUHNWTE5yL2owWTZXdEljd2ZHMmZacXFyTUtQNUtTcWtXMjd2OGd1b1JhSFdLNDFjVlpEMjlyQXc2dFk5cno2SldSekJzZ3lZeGZaN0h0aTc5dEtGMWQ3VXlXdW42VmduakxOb0pCVU5kTllHVjB4SjJ0ZlFBby9Rb3MxNnhCQUJkeFB5UFdhcFBmY24vUk5GdHBTU1Y1TlVpRVJud0I0K1JtY2VYYU9NWnBtQ3grNndxUkFoZU84Rkc3ejZLeDcvQkVDdnd6bU5ybVQyRHFReUhTNkw1NzNaZlVQMzZWL1VkQmpnVHZwZ0tBSEF6V0RnUGdFNEd1RDJuVG1Oa0NBQjRRR1lBQUFBQUFOd0NWSGNBQUFBQUFIZzc3N09Mc0FRQkFPQkNITGtzc1FRQ0FBQUFnSkg0Ly8zUC81L3lrOW55azlEeThOb1hVM2VGTmVLMTA5TzBmTE1PZWhtaTU4WnJhUzl4TXhmRGV6UUZ3QjFSam1yd25yU2luVHlqcFhrVXlyRVg1UW5QMngrN0V6ZGFaUUljaFhRVVZCbGZwbm5wbUIwNUdNbGN0aVFyTEVkaElVdWdCOHN4a2JmR2Y0NmNSelRtNmVaMG5WWjdrVHBWN3E5WFhvczM0bXVURFVsWnRkWmhXYUE4NXg3VzRyVzZub3IxZmxmMnk0cXlWNHpqZXNuSktTUStmR014MXVlMXhLN3M4bVI3TGYxWFdLdk82V3VEUjZrNWM4NVpqOGExV011OWRWKzVmd1JNZXNXazlxdHphNTkwWjVzTExlcjFSNjlVcTZRNnRmaldqSHVjMmdkd00yYktqR0ZmaEtFc1hCRUFBSGFzbm9neVRjOWUzRXhQU3EzT0krUjhzdzJsZVZ1WXZWSloydGN2ZWx4bXRiTHllSzkxMkdOTnJuZ2VYajNDWXhkSjRTTzIxMnEwandWYXZub3FmVGxWS212MGk2cWZoZi84MDdJSFMzcm5oRWVmbE9LMU1hWFY1Umxid2RpbWRscmJsMU5qOGRlV3AyZCt4K2JzeW5QYlZvWDkvV3FqeGU1ZGlMdjdqYzY2N0hYTExmbnNqM1l0MnFyd2VULzFXRnVyNm1sc282NmQxakNDdFU4NkQrTWJnd0JtZXJmdXRLa0g4Qks4ZXhyRGhScnpTbHVUUit4cElBckFoTlZJZ1c1NlJJblY1NUNIMTdpcTVzclFVcGpsb0xNNENiMTE5ZXFzWUtmRDdNM04zZFlYVXIxTmdHdlEvR0pxK3ZvZkFBQmNEeFpVQUFBQUFBQUFBTGc3OFVBSEI3NFVBQUFBQUxnNzZMUUFBQUFBQUFCd0ZOaWdBQUFBQUtEeHF6d0g3ZWRzc3Z3SHFTbnN6NDdiLzhDNTlSUFcvQWZvZVg3dFo2K1grbG1zNXpnSTZSZjdiLytkci9WWWk3S3ZMVWN6QXR5YzZBaS9sZXc4ZzVhc2lmcy8vNnhISEJnSlYwRTdscmltU09VS1ZpalNQd1RQWVVVMVRUYlA1ejVsZkthQUJyRHcrTFdvNXdickMzVVNabmd5MXpGK25HSjV5bmlNaFpWZHl1dlFxTEpVU0VTWnNtS1FST1hhbTkrU3R1eVlrYkZSbG0zTjF6Tld0TlBUdFRLOWRWdkwyOUphQnQxb0d5eG40MW9OL3o3eXI1akdXRCtaUDMxTXhIMjY2dFA3MDRYYlBFN2Y5Y1RzcytuYWdZNmZhWlQ1TFBxT0d2MHpYZCtJQTJrMHBYVUdzK2FNWlc3MGN1SEYyeVRlaThDZTAwd044VlgxK1N0UExPcUl4cWJVSktDeE9VdVFScGhYR2x1N0hBRDZhTW1PVXBzcThZcEU3N2FTQldRRUFJQWZqNHUzRmkrYWJvMjAwWmhlaWkvVHBqQXUrMXZXdkxSL3RzdFloSlZmVUJXM05JcFQ4RnQ5WDY3UFF0VlRucCtrQzBqcGo2QkhqOURLMHNLOTVwNW52TmZHbXVmcnBUMWZMYTBkZ05RNkZHbmtTNm1aeTZoU2NQanhKMzJWM2IxWDFValQwbDFyc2tPeXJYdnE4bmd1YTBoMStoNjdiVWNnRlg5Rm9mYTZ4N2Y4S3Fza1JmYXhlWWc4WjFwMzBLNUxLalVLMTZuYkw1OCt5a29WWDV0VThuWi90cHBzOXl1WEpZMXdhNTFTbVpYbkx3b05nMUNSUGdNdE5qSFowcW5VUnppOEdPL0NaQmxDdFNuRk1JT1hNcUozNVRTbm5yWTMwNlBqaG5ZN1J2WTBOSHNQWGtyTHFHeWwzNnVrMEVtdmZHcVZwWVZiVkFpTktKU3Z5VEdwSEV2YmE3NmtWK0x0ekZwNGFmNTVuU1hXY0dzODJCR2VWV215NW5wSWJ0YjJtTGFhWGdYbjB2aGlLbzhJQUFBQUFPNEptaXdBQUx3WFZrRUFBQUFBQUFDQXAzR3F0WStyQVFBQUN0NjNOTEFZQWdBQUFBQmNHVFIyQUlEeitLV2ZSV21QOVo0eE51TlVoVVBvT2FxUUkxM3FqQjdKS0I4ZkNIQmRwUEZzR2NmWjBTcldFNldzYVcrTmRvaG5lYmhrRnB5RXVQd2FrUUtYd0RPaHk1T0RnbkI5WTFwcWxuQkdiYmNhSVovbWEraE9oQWlNWURsZXpUcVFweWdGM3NyV1VaN3NuZFJqMXlUS1RxM2RXMHNLN091S1VwMnA4a0MvaTQ2QzRJcWYxNkZhWlJZLzQreXYzakpxQTdSR3Y4OWhQSitrWU9mL3pxNXpSVmxKS2N0eW1uNmVQdiszOS9tdmVLNCtReWxXanM5TFVobmJsNHlUTGl4VDl2bUttSDgyUFN1NmRvZmYrb1ptLzJtUFU0eHZ6VG10VWl2V2VSMGE2ZGF2Q2ZiN215RWp3MkFaUFgycWxkVlpUdmw1b2xiUjZqUXNNb2pyMDJkaExha3MrVDU2VHZKZWhiZWJSbHpGRjdoZGdFZmowWjY4OFZaZlJLMDhiOWxhT0FBQXpLT2wrMmt5M3F4bUMyWDI2Sk03UFhwVDNTc04vekJGQmIyOHhqK0NHMHZNV3pleHhiNjByRytlTlZIYVByblMrcW50ZFVpMFhBOU5WNE1oWHFzekNIVzIwa2FsUXMzK3E5bUpmOXl0YVY5R0dWNjc5dFpsYlcvcEF0YWVvelIra3hMZll1WDRMdWVRTk1meTZ4eHAva3J4bGpiazRhMHlKRS9GejczVVN2ajU1bWNLcFJkeTd3SHdlMkhMM3RLMC8rMysweTVtYTJsU2ZNUDdQcGQ3L2U4WFVzdWVpNm9MMU5vUGJVOVNyNlR5b0sxQVF2M1dadTE4Y2JrZ3lncExqYnhSOHdudk1nYUFQNVNLWmNuSTlMSk9IWVlqdkFqTk4ramFSNGgxWFZPZFVrVmxxWkx4eitwYUtuTlp2cVFwYXdXYTN1VXNEdTZNVlhXVERHQkxQZ25XblM0MHVTWGhzUWVsT3FWckR4WWJveFp2TFVmS3p6QnJzTUo4MDR4TzdScm1VZlJ4eTl6OXpoS0Q3SU5MZXRsZStRVG44RThBT0Jxa0FRQUFBRHdaZEIyQUczUGdCRVpXQUFBQUFBQUFBQURjRXR3NkFBQndCZDZ6SHJIeUFnQUFBQUFBQUFCY2xmaXYvL20zNlhmcC8vWGZQMzlycDdnOEh1MTRGeTBkMkhuOVlJTmJveDNOSUl6djJ1RVBJa0xlMTB3WjR3MXJmVm85ZURJMEQrSUFPQjdyOFU1YkdzOHhWQTlreHZ6dDZrS0VCTXpBb2d4Y1l0SHZQWWZLcnUwazQ1Rm0vbTZ3bk5VK2RveWFLRU4yUi9RWENTMU5XUEs4MXovUGNYcmJlSFc4OXlVdC9xdnF1R0YvYi9iUmRwaDhHYTNhYXAvenRQVlZqTGo3WTEvRUdEM1BXeXZMY3hTaHQ0d1ZIRlhuakw1ZTJkYkY1MG1QVEh2UE9oVkQrK3MwU1M5Q3cyditlSmZYR2N2eUVTcmNDODFBZ0dHMGxVQVJieDlwZXVaNWJkNTZWbWNBQUxnV0h2Zk9yTDJyWGRtZUJVb3FQQlEycm1ScksxVUdJYjFVdFdYZHJaV2xZZTFyYjNtYXhhYmRUK3U1dHZKWjY1ak5ETjFIcldQN0trS3l4MnRmU05Vci9mcFh1TEZxbStLK0NNbnV0VHpubGM5Vks5czdibXZwUnJjMDJpNEpXVHBZdkRvL2JmRDFzdVgrZE1sVlMvOVQrdGFtenkrZ3h1ektJeVdsR3NzNll2YmZmZDFCQ085NTNwZW4zS3Y1dzRBRldBcUxsa0NMbFlDcUVQR3V0Q3U1M1JPR0Z0NUZYVkptcllzR0FPd1lua0xDTXJRaDdvdHFScGxjaFJndTYxK2hXaVhBRHEvQjRCakg4TW1JWGQreUIzdTBhQTllSDVLbHZGcWJHRW9UYWMzYldwb2VweUFQNmRKRXljeTE1di82bDhkOWJmaGlLZ0FBQUFBOERvd1BBTGdOQ0N3QUFMZ0NyRWNBQUNxSVNnQUF1QUtuckVjc2dnQUE4QVZMd2dGRWVoa0FBQUFBd0FyYU13REErZnhxUi8vK1hmRmVYTDlPZ1BmOHZIcmsrQVVJeldQQkFlNkdkdFJvSHA1K1RuQXBEd0NwbnVDYlFyTkkyRlByeTlxcE9ZZ2h1QVhKR1A2eUFkeDcreTJWejNWSUxrQVAxdmw4cTBWZm1sVTFiV2VzYk51VXpPdVVOSzZSRm4yZWJKN3JGeDhsYjhlQTFWNHN1TFJDc3ZKNUhzbWR6ay9UK2p3SThUUHE5SlI5dmVjdmlsVExIUHFUSnV2ai84MVVmZ2xnbC93cjNaK2MwWG9Xc1BWTXZ4WFB1MmMrbjYzOHRObzA4bTJHMnRvd1V1ZE12SFV0YUp2MWlPdVNtcEZkNXBXdUorQXQ4b3pSZlVTZFo4OWFnS2VSblBFejVxQlVaaFRpQVFEZ21tankybU9CTFZPbm94N3RyVXV6eEtScnlVS3JwZSt4Zm1hdm4yWlhneU4reHA3R1dmU01GUW5OajFPTEw4T1N0ekhLdzBnRzE1bmxhNm0xYXkxOEpqUHF0cFF4TWtmcnNqRk5jVVZJS2NjODRHT0RMVlZicWUxcGVHdHNXeGgvZmFBcGxGK1VsY1B0ZGNaTFNhb0txWGNsRXE3RlR6MEgzeVNKdGJvQUZ1TlZYTFFwYy9IcEQzQUZMTk11T2dvb1A5aXQ1cW5ONDZKUzc0cW82V3lJQnBoR09hZ1laR1o2ZlJGYldrbDBhUGxHV1BGWXRYNWdLRTFnaHZOTVM2Y3RRSEFhbTFrYkxUK0tnVnZ6UzAreWYvTFdWK2NrWDhydFhTWmxCNVJvUmpZK0k0QjNvTWtLS1UrcWk0eVJkYmluS2JjZ0t1R3BlbG50eS9KVDhYbjRuenhDV1dVOHdES2tsOEZoR1RYWitVZE1KMmNtVHp6QVJtdS8rM1pVVjk3Z3dUcDE1SFEvV3NEUEQ4dzBSVUs2YnBPL29GRjd4K0RQZFN6aUx5RTdSancrUjNtTG51cVY2cmt2YjU1VjZXZFlLd3VJSC8rbzhkOVRLNVdKTXRueHYvUDI0OFhDMEo2U3U3TFZlZnpsaVUxS2d5Vm5XMTYyV0pmSk1ncHR6bmpPcStxczljTm9YU3Y3NTJZeWNKSXZWUHF0ZDRlclpScHhvQzVwR2t1Ym5KNnlBT0JZVnF2b0Zsa3hFdDlTSzVBdEFBQnprUGFYdmswOFFlQW1SMW5sWHBWWWlHUUg1NEVLMnNmYkpPdXk5WUtmWnViMjZzOGo2N1RWM2cvR09sSkhIVFB4MmlpMStCRDJmZHRLcUpZcDdNbE94ZGpKNWJndVgrSlAwcUNLUXBXcFhyYmxkbWZxbDk0eDVxbmJVM2JMWStpOTM3WVg4bStyNHNkMW5zdkxmcVliUldXbGpLU2tpbCtwNUJmUW91QzNTbUlabjNXWDhhMDZwUitRZW4rVU9uTTgyL0ZLNkMxUFphV0tSWi8zQ3Ewb0NJdlBQMEsxcmRGcTZaM0JtWFhETW5vVXFxaGNBN3dRYVJwNDlnQ0UxV2xmdG5YQmJTeVJ1NjNKeiszUlhWN3Zua1kwTkFkZWd1WUFzQnI2VXRtdGExaEN1Y1BlOHZlVTlEeWlVUnVrZHg4RkZxTU5sanhkQ0w0RkZZYlFmaHRoK2UxRUxKN3Z4MlVtUkt5bUNIUHkyZ2cvVEcyTFZka2RWczhSRFhrZlFlcU1neC9vSjNnaW11S2pHRStLdmY5UmhQWDY5bWdHcCtHR2QzMHB2UUNROXZrQUxvSFZLSHNScTdxamxNTmkzMXNzSDU0WnRORGV2S3B4aXpGMUJiZkExcGxSZlExa0pxbjQ5Y3oyMmtmK3o5OEl4YldTMXJUdnMvQm9ETGZFcDlEWFZzdXV3aXJPckhzRjFtZGd1Vy90RmJLUFZiS0lPNW9aejdHeWhiTDltUHpyeGNraTlqTzNadmVKUklQTUw1N0Y4QnJnZmU2cm5xbkYwdFhhcXFXcDFSVkR2N3lheVJYYXNKRGFlM1hCSWFWdW9PdTQ3a2U1MXNJQllCMVhtSSsxRnpkbXJCREpFSWJjQVFCWWdMSzR0TjZ0OEw2OFo5V2JVNjJTWGwrM3RTNkYycHBYczl3OGRmU3VheU4xV3RPdDlPNTU0M3JpTGZlZmhoTk13RHNuU25lc3RXTktOMDAyb0wyM09hdGJtbjZyTUY3M1dYcGpXejl1MzZuMnVvWmUzcmtrcFQxSnVmL2t1bk01YmY3alZLM01jenhkMHNyYVU5U2tNVkNXVSs0THhSRS9wZWFQbjlnZjhHeDZGd2VHRmtBVjd3cFM2bXd6ZDdDU1puUjI2S3hpWGNvMUlnTzZqTXRhK3BtdnA4QXdzM3duUFh1czNuZ3ZES21EOEE0V2F6Z01vNW5GRnJNNWY3L3F6M1gyYit0QU4rMXhTejlraFhPcC9EQzFwdWJXVTJnUFVYSjVsSEU5TXNIdk9GekFKUnJ4RWxxRENlQ3VsREpFZXU4M0JmSEhxZFpUSXJTcUsxWGVFNmRjL2xadWFpL0ticzRYNUExY21acUhzblg5WUR3djZ2UzhFTExyeXFqRVM0VjdCVGE4Qjh0dnZzcndFQzVpRVBYR1cycUl6V3ZmN2E5dmIwNzVvOVE4NW51WHA3ZktVK3lqMWc5VVJUZFN1QjVYYkpQRWFGdDdub0UwdUZwbFhXOVJFMXVxZHNmK2Z2OThLYlZSeHZmZHB5aTBKWDZVWExZdWZoV29PMjFuemkwdGY4djZuSTEwWHpYWGM4MWdycVV0NDF0MWpjNlJVVFNIZ0ljSmJiTTJ3WnF1NFF5T1Vwa3pSWWt3cEtTcVJwclErN1JtdHNGYmR6aWdMb0M3MEJCWDFYQUxGdEhvTGNPN1V0Umt5b3RjUlFBQTUxRUk0Q2lFaCt4eUorTmozVTZVYmRKUWpXanVCd3AxTERQL0dtaWVKYTgxNkszVEVtK3RTMXAvUGN6UUl5eDE5T2dsUjd3SUtuM0ZkTFRNbm5KMmJhbnM3NWRmbWRwOWRVb3F1eWpLMWE3czc5WlltNlg3YWVQYW9tOWFYUXllL1Q0cmN0MmIzeTQxMC9ucWFtdnQwZzg2OVMrblNubVMyYmNRbFR1MC9BQTJPa2ZWL211dlhzbHpFZXZGKzZrWUtmMzJnc29XdnZ0eGFyWHdBT0JpZE9xVTA1VWhDRkJsUkplVHlzcnR1T3I3b2FtZHo2UHZXblhXWFYxQytFVldiSmpOcU5HU0hPR3RjbHB0YUcyMWdvdFpleG9qL3BBajBHeFFocEVCcTc2NHdpRWhQVUFlM0dGSTVxNzBhRkw0OUs4bHczc2JjRThxUDB5MXIvcWVRWkNVYXkrbkRrQ0VHQUNNMEpJaHM0Vmxvd2x2RkdHMUZhNTA1SGhmMUVJaGdzT295UTdOZ2ZPaUFUcTZ2eklLc2dDV1VwdlgyQ0tYWlh2UjR2ZS9hZnZsVGZwTXNmM3pETmtodmU3RUlIMEdMM3VlM3k4Ri9jelRIZW5qSHhYVm5uQUxBc096R0JZdVJ6NTNxYTRWMjFaWEhNOFBuMk5XSmYxQnR6OUxOcXdzQTlzRllJLzJqc3hkeFpUMFFzWFpQaFFBQVBna0NnR2JpUnFQWElnT3FFdGJYNlc5dk5tVWJVaU45b3pndWMreUxTdGZ6dktXT2RPL1lTM3JrTEdmYkcxcFBjamU4ZHI3WEwzZE1rUDNTMEpZcVYvVzlNMXJ2enQ2aGRuMXlmZSt3cEs2MnIydTFSMFB0U2lPWHZ4T3NwQWU2aEtFazVrOW5DWEZoUEVMTUoxbGZraHZ3US9mdWdJSEkydUtadkJhODFsLzhNWjRIV2FGTHdJMTRvSHc4RjZQMVFmNHJVNFVZNmIzOERpNFByL3FMM245L2ZmblZMalBFZUZkZER3LzhySEVoM0N3U3lnNjQ2MHZYREdwOXJSK0xsK0xCN2dUSGdIbWxCSFdRMEZxWVdWVnR4Qk5QVHR1djBtVlRlYTAzeWo3eUNxYzd2RlpDTUFKakNoVUQrVU1OVUo4ZVhXVEhVRm94QXB2RGp3YjYxaDUySmdxWDRJb3Z6elllckdyWGU1OGFxZU4vMzJSSTFSLzQvYjVXOVZDYU95dWkweWVHeEFyclNVUUV4bnlXZUkwWVhpbU8vb0t4cVoyM3pYL2pSUnZKVTVLNDBtbm9kM24vRFo4akx6Q0s1b3FGODIxMytxRXJhV3Z6dGRHZi9TdURhWjh4cjZjc3U3MFNuTnZPbS9hR2l2azB4WGt6eUN0YnRrVVp1TUdjYmtVZm9jYnh0aHVFME9ZczZtU0w0L3d6bWVwM0Q5bGhUSHBQRU5udVVJYkFPNUFLYTRrWDZFVno3THJuYWRTbVo2WC9aRU5BQUFUc2ZwdGl2QllFNnBSU0tNVUtlblBxZUZxMlRWVHFhdkx0QlRTYWV1cjZzNHlsbE5Tc3cxNjEwUU5xOGRscE82ZWRibXNVOUlmV3ZrdDZmNmtyWFRDeUZkTFd4OGlMTzFCOTB0dXpzN2M3UUVOVkdXZFd5UGVnNUc4dnluSFRDN3V4RDMyTU5ZL00vbnAyMjEvSVgyRWoxQit0VlNmUS9vZDF0TGtleVhhbDFMTFVSUWQ5VmphbDdjaEQ4bnI5RXVYejlKdDhjWUYxekxCUHo3ZkV2YnBrN0NJNTE4Ky9XakNKckQyUmUzaVBqUG1sVFRpeEFJYzhTMms1OWliRGs1QkU4UTlpa1JPdmdnQXZBQ3JibU9lV2tYQzlQV2Ztbjh5RlhtaVZtYVpmeXUwdHR4VmlraVZzalNmS2VMZ1lZeXVFU3VJblhFdlFwSlRJNXE1dDY2ZWNrYnJ0R3JKTGJrSENyMmRaQmw4a2hOd2UrQ2E4NFFIT0l6a1E5djU0NzdDeGJsZlNTRDV0bU5zWjVYOUdPMXJPSmRmV29LZUI2WUo3OWFDcEMxVVY5SnpaQXNBbG9GVEE5NkFjZU1YSEdTeUkrbEo2R1M0QjVhTkJIU1RhYVJKNFFEZE1LaHV5eWFPVVM5Z0hHMDBTUzhEZ1lybC9abmNlUm9xTDdNNjVYU3k3SnA4MUJhTjZhM2xoam42SXVzVFdIaXhiWEtGMng1NXR3emdiYXpRM2E5bUM3RDBBd0JjaUhLUk9HTEJxTlY1Y2NmVmlEbFJlMWR0OVZwbWVkRngxSnkzeGx2eWVNdndwUC96eGQvdFludUpQdHA5S0ZJNktUd3ZlL3FYRjRyQk5MUDRubWZpR1VPeGtkLzY0bDh3eGwrZkZSSmd0b1pkZjJJLzRucm1tM2VqVC9Sb2g4L0ZGeXdQY1RqQkFiQy9jSHQ2RlFucnRHYUl3TXNZMWFPckJXYnp5THJMeTlTRFE3aXlFOWlpUHIrVTBhWGRrMzVXWFFCd1BsNy9tMXpReHovZkY3RjBpbW9IYmNCdEtYNlkrdWw4Nm5VNmFqOW8zNjZUY3IxdjBVVVdMVTlqZW5ZWTNreHRkeWdQMy82KzFJQUFHRVFRcGsxWitpVTBaMnhJUG5vYTViSkM2SytQVGNvUTlpZDBwSjkwMldXSU5TWEsyaXpIcGl2QU4xRUk4L3c0OWNIclorMDJ5OXZ0MVNzbDUyL1gvQy96SmkwQlFORG4rWU9SVHVmMjJLSitTbWxSaHBldGtOTHZVNnJFZGhYbXJ6R0hMRUdTQ2s5S3BWcTZJS1N6cE5YU1BYeGdmeU1ad0MyZStIcVlkWXpOcUNsOTFSU0w4T3lQekFsYVhhKy9JalExVEtMdlM0eTFSc25KWEEzcnZaRlRXVFZtWm16NUh6ZWVMMFZyeWF5SnVCVEVOU3lXWldRdkwvOEpib3hYYlY1Slg5blpiWklVNWF5WVdsWXRRdE5HV25YV3JtdGw5Tndmd0pQUmJBMXR6dlJzYVhUdTdacXh6UE5icWdRQUFGZkJxMkFWZTFjZllWSzVpb2xSNnJnN0gxS3JUc1hrOUw2M01WTi9ubVZaNVd1eGQxc2xEOCt4OWtlZWZyVHVrYlY2bFI5RGkvL3UrOXpuVXV5VDl2bEs1UFo0eXRsOWJWaFRCbXRsS01sNjU1YjAzTDE3Vy9uNDkrTEo1eDFqUDNQeTcxK3BrZHRyWTB0WTIrZVpjL3F1UWZ2K1VpVWtDcU9xOUdudXY1eGFiN25VbGpreU5ocXZyWXVsdERnbUlYMlc3cnRJWlJaOUNKMVVML2FQTUFreXJVODR0OXBtc2dpdFhpS05XaisyMHVWcHJaYnhuRkVFQmtZTWU2dUFsaFlpS1IwQU5OSHNoNDlBSWM5T2J5N0xGSmFRM1hRVzVtMnBrK2VyY0tnWGJWNWQ0S0Y0RkdWdm1VZmxneDFlamQxVHBqWGNRcTE5TGUxYXMwd1lRZzNLenZVNkltcmxhWGs4Wmd1Y2cyQjZSMFZZL0RtNExoOVRTZFpObUpmMzVoLzlFZG9mc2FTWXhrb2F6WGxhcG1rcHZZY2hOY0p5NCtVMUFuSU0rZytlVG1xTEVPWkFINXJCa3lzN2xvMnIzc2ZBNDRNaHlzSFgwaThZYkZPWXViV215ZzZlR2RUd0RMNUxHRTZRR3VHak9rUXpiNVFDanRnOXRrcEwzRWhnNVlTeFlwa3FTVS9lWWtoTXI1THZUTXN2Wm1wOThJZVhkK1dJak9qeGpYdjk3Vm80QU95WitkTEVDbHJ6M0pJWEFBQU93dnY3a3hWNjlZRzYraFhXR0duUDFlb0dhUDQyS2ZoKzY5R1RibFJuSDlKaFVtai8wTlBRdU9xck5KNU9ObEQ3b1d0NVhYdnA3ZHYrMHU1VHdQSUtrT2Y5elpHeEZJM3BQR2p2bE03eEJGL1BLcDNiR3NuQ3I5OTMzS1VweTJwZDk5TGpkU2p6dHUvTFhwNDB1aVl1WEllZUlHNWQ5SzN4SzhBbmVndEdweWtBSElaM1JUd0N4QUJNWThYQXZ1S2tlUm5zSHdLQUI2OFBMUlovUklzekRXN0oxeGRUVzBjbTlTT2QrbEttZWN5WWlzWTBxWkVuRmVGTXVML1UrcW5scDZUZjRNbzRUdmJvZFV0TDd1M0hUWTFTWmtwa0hiQVRFVjhYdXgrbHByLy9ScW5POEprdkNmRlZrRkV3ZzN5QUZpZktxR3ZoeS9RTWkwNmFwNXVpRlpmeVNUdDJLd2wvQTJ5d0h6eU52eUt5WlpSWlgrMnBoMjlsL3hYSE1RdmYvN1g3YXFOMHJHbVp0VFVlZG11QTBtNTFUZkFNdmxIdDlVNER2VFdHckZnZEFqUDdSVnVJem56eFJicmU4RGhUcEpwaU5WY2V2RTJoM1d5TXhSejlNZ1NrcFY3aTJHVytNSFkwL2RBVnYyb3NXZWJXeW5FNld2YkxGK3dSMFNpa1Q0SU5Mc1czTUgvTW9zejNYWGtab0dPWldyMzA3dGwwM0FZQUJQdDhiVzN4V0xjMHJINE1qZGhvMTJqNXlCSUFnQXFPdmFyNkJwUmU1dTdMcUVJNktUaFY3Ti92dUZBbktkZWE1U2JkN2d3ZFZsdVBOQmRhVDUwOTZhMTFTZGRIZW0yMHZuYVZGWC9HYkcwTVJNVmdjdHR1S1RSL2hGb0xOOStuMGdHbEx1Y1pCNW9uTURyS2tzb2NvV2QrZWRMTjJGcjN5b1l5WGEyYzF0aG9QVi9adzF0dmxjMFRHck05amUyTHFxbFJ4dWEzclBlQTZDTU5hUmYzbWFLY3lhTlB6enU2SkU5cytyeTByQm8xaDVORjJPd0VVNnJINzBaVExOcGhrUkxheU5aR1Q2czhpNlNwY2NSS0JOUFFuQTJ0ZkFDZ1lsbkRMZWxiaUhzYWloaXY1VXY1ZGFqVWxSWGwyZFBRVmlWNE9KcjZzcVd4R0V5OWRZS0sxejd5eUlBcjBtTmpRNEhWNUpEU1M5ZldPbFBRSFRZc1FNdngrdVcyWnhFTnZyNlBjbE9Rdis3K1dUUmNuRjgvZjI0eitkaEhONkpmWEk2ZW03SHU4QURBODlBVUp4aEhXTmEwRmM5ai95S3U0VFJhKzM2YWZ2RkFlWE8wSnN2Y2g5TkJqeGhrbmRUWVhoSXBYK0Q0MFMvMmRTTlQ3c2c1UHBSM1k5SGkxOVg4OTQvdEJTVi9YWWNjeEwvU2lEbE1VREczSHNGTEg1ODBlajArQmcvb0R3RFF3eXpaZ1F3Q0FKaEFwK2tUSitqYitVOTdrT2xyKzhINkE4TFZqTG9NZXZzbjc5dWFieVQyTkthVkpUbm5TQnFLM21HWlc5YjNNM3QrMUlCSDVSeFc5SG5wWS9qWmR3aGgva3o5cVVPS09kYmpzUXJqRERsa0VwM1JkL2hkWDRYMEczTWVQOEF5N3JBaTdzU0FjV2xBZElESURFUFJXeGNEMHMyWjhvbkhCaTRrcHdvRDZCUktQNTcwemxONUlNWU96ZFVBaitIdkQxTy9INnh0NWtvT1VzMXhXcWFkZVFqR0lTRFkxak9qanpVUFBVSU1yb3JreTgvaksxbENJMXVTczM2a3ZaMDgzdEFVbWRySktWTFdwTVJYaXE3bEExaU9kUHFQbEZhTHo4dTQrVm81cWtaWXU5Snl3SnRkaUFBc3dpTXJIa0RhL2ZYVEFlWDgvRWtSRjc1d0ZvWHcvTWVwbiszNUcxd2NONlk5eHhuUCtSSmo0NjdHdHJTejM0cjNsTGZxbFNaUCtOVlkwLzZXK2JBcldmQ21kdSs3RmRQK3UxSlhnWnBsNkdsUU1OYTljc3hJWmFmQmVGaU8xdlUxRVNrOE5ta0RvN214RVgvK2FmNFkzRGkveEk5Z05IVDZXVkpxNWlpV3BqV21DY0FjdExuVWl0L21aMnBjZStyMmlHRXJ5QW9BZUJ3OWdtMVVvV3B0NHFsR2FCRXR4SHZYRGltczVkV1k5ZU81WkF6THcyUHg3OGg3S2hLYUxoK05iZkxvOGt1dDEyemNWb2R2L0xTYnRQc1k3ZHZXTXk0L01MaTdydVJwNGY1eGFnaFRmL0NkWDVkdHRXelphYVRROWtwYXZKUFJlTzE1N3JQMFJVdmR0ZmNiOGp4MjNidyt1bXFoVnUrYnQrL3E1ZjY5dzMzWjBwMlhwWVZkemhiUk5QcXNHNTlMSlZ0UlY0bWw5MU05bmJRblkyMUs3T21IbG5Sc2xTRTk5NmpraytJc1VnTnVSZXN4cHNCakJ1aEVrOXA1dXVVSVN1YjNua2JSaVB4THFUdGJLdGJmcGZpT0QyMFFLZEROVEtQendWajJGNDZzMDROSFpxNTQxVW5TMEkrMFhHNlB0NU90VHBEYWc5ZU03ZUNNQnplbHJ6QVAvNDMyL3NaUGhpQ3ltMythTHp6QW5mZ1ZCdkFvb1pvYkE1MENBRjVQelA0dG5ZRUl5Y3ZBbzRETHNjbU1XcmlFOXcwUytJYXVnOXZCNEx3VVZoOGMzSm1hTWcrUHB2Q2NxcWNCbHRsYnp2aFpRdUtNdHdnQmFpQWlsN3hBNzYyVGFRNEFIcEFaQUFBSGNpRTllVVZUOEpiOFJkc0d0bXdQYSsvMTVZbkV0VHpwUHhqZGxla2tHUlVKNnhjWXJHM3ArWkhwbFB2Ti9pNjMvWU53clpWVEl6YkN0Uit0YXZjM294OUdPVlpXSEtudGpqam84bDZKd1cvcDk0NnFzdTdhdFpjTGo3TFhMbEk0N0I2SFJTVFVGSTRvbE1QUUFQZ0RQaktBVG5qUmJnanR5SldqNm1xbDRUZEIwTTNNZDJKZ21PUjhGbW5TczhQY2VBNS9mNWlxdmhIemFaRjZ4NUhrU0xjZzJieVhRcm9wYlFWR21NcXM2QnY2RzY1R05NWlZOZzVuTHNTUG5CcnF1bVpBNldUcGcyYUlHamdGdFBNUFZxa1JucGNIekRwc0tUeHVvZnpDSllqTzhJY1RpNzlhcDNxZVJWMkdwSy9yendlWHBMZW5KSVVqQ21tUklTZkJ3bndYTEU4cWRVY0tkWDdiRWZKYkhUSDdvLzRsMVRKdmxJcmFLbXVuay94WFBmWlRXam4rNDJCOEQvSnpXbzlGMkY4YzZhMWNBejB2RXY4WnRzbitPcWI0TmRiaXVsVmZYcDZHSloxMWxQY3M4Wm9ha1pSMEFQQ0pObGQ2WHVMUXJzczZ0WlhDNDdlb29XMXhTV2tBQUU1bGhvQWV6V045dWQvNkN6RkQybDVyb1VmV2UxNk55TlBuUHZZWWZLYW90aVllZ1Rha1BHMXF2VEpTL2xZa2hEblB0OVhuK1I4N2U2aTRzU2dXVU5SZHFTeHErOTlSemx1amxyNzNTNm5hK04yd1B1LzhPVVlsejB4WC82d1hndi9US0c4V0xWbGl0dXVONmN0OGNwdDZYeXBJb3VqZjI5eXhpTmUwOWx6N3J5MGdyWms5SWlWTHFTRzFKWTgvRzgvOUZtbDNEdGxONkFtQ0tRclM0ZnRCRnlPaTlvbHFkY1pxSzI1MHBtdHhoZWYzY2xZcU56VWxvRGFOQVdBSTc1VHk2TDdpRjhxS3VwT3cvTVJTMTYrVUVZcXlwRHJnb1ZqWElldEdrMGJUT0ZYcWhoMjFwYjRWUHB0U3JiQm90Q1Y3dStuenVwV24xcDVXdXRjTnBSRTlVeHRFM2tXa05WQzFzclEySUNQTVNGOUcvWTRQd3FNeStxY3RRNDNIOWt4Y1gwejFEZ0tQTEJwTmR4c2VkME1Bc0lUYVpsM0FON2lTbG9Fa3BRK085QUNINEIzSVlLYm1ORG5LZ1FQZ2drRjVTZHFPMXpqKzJGQVNBYWJnWHRzTkdkSk11WnpLeWx2eDFuSUcwZ0JvV0IwWmQxdkR2dTVweHZMcjlTMk1UTTFrREdmNkF6eVhtbGdlOVlrQ0FMeVdJM1RZQXpZR2F6ODdXZzB1ckU5VzdUTzA5alJhdW9EVlFDaC9lNlc5U3hTelJDblU5MWswSDRvVXZiMVFGeTgwdUs0MHp0bkw4bER2cVhMdWZQWnAra2czV3BlY3BqVzdSaTE3YlFaYjhwWm9aWTNVZVNjS0tkdjhVU3E4bXRXQzJyTVlzR2dBREdGZDRjN1VYOUVQWWNlUmE0VFZBWTI2Wk9icytiemlWZFhGN2pDd3NQSUI4SUJQcGRmL3BwWWJLbzlWZFVUQ2svajE4NFN6WVZSKzNTREdxakxhT3k1SzE1bG5BSS84Y0g4Nk15ZkdwVzdzQWtpbkpsampBZTVNNDFTUUtGMExXWHRPa3ZGT3AwdUtMNDk4amorSzFzZUt5RnRZY0RkUzltK3ZnbFdXZFZObXF4R3RiZDl1NTRvbVBKRXhNSXZhV0h2Z1RrT3A2MWptK2J3dWFHbGF2MzkwbXIrWTBwSWlXZDVVeERmZjZQcEtuemNqdnc1RmVDMHZ2SURaT3ppdDFmSGVhR3Y3YnRidVhXajFjbU05NEhzcXVuUzNPSC91dW04OFhKRFo0M3gyV1hlcWV5S0RQMHJkbmVndExhWHBNMjNyaXpubGZKTk9HeS9uWi9teWRtMjV0WExGWlZocTAwdlVTUUF6a3UyaCtWODlTNm0xVEFsTDJYazZpeXRKYXdQbUJRQXM0d3pGUTZwejlEYzJQU3IrQVdaQnJZb2VxNzljQ3pSL1hWRHE3YW5URzI4cE93aGxTUGZiZzlWc3NscTkzajJOcEtUN2MyM3NUSzJzanpvTDErZk85aEpzdWRyOWo3N1U3eDNuUFdtc3oyK2xWOE02WjFiVS9YUC84ZXM2TmZOWmJORDl2R3d2R2ozNmRQd28reWRGNllhUDFiYmsxOTVlOTBoaXE3U3piRTVLZDVZcStVYWthMHNDV2ZOS3lRVGhJYVZOU1g2UWtoT3BiRkpvQ2JSa0ZGTFcvclN1VURObk5OeUN0Z2owNjZnTUlYZ1o1UlNxNmJCRDVYOFZtQzhscWR6Zkx5cVBvYjZNaVhzYVd4MmhIditSTmkrdkxGL09adFpwNGVhTUdOTzFzbnA4TEhBWVBYc2FzM3hKdGJ4bFdFdkY2VkY5WHNlSTJhYkZKK1c2Vlk2bFhaWUh6SU0yczN1SElyUjlMK293cUNSSXRZdFUxSjI1QWJRaEJQZmlud0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWU9EWG4vLysrWW16ZEg3QlQ3am41TVZXK3RwNWF0S3ZyS1ZmUWdjbC9GQm0vRHo3MUJ1NE1GcmYwbS93UklUeC9pRWpoYm14aGZlZUVOTTZuS2luek10Uk84WW43WU8ycEI5OVhqbTVMRGppZCsxQWZzRnNvbkpkWThiQnRoZG1saHJST2dHc2xyYlVjVjJWSXh0Z0ZNL2NmOEI2WkRYRlBLZXMrMmtMNFB3RStGUzBlQzlmWWhBaS9nWnYrb1ltODFzNnp5V01hRGllMmVmSlBlTjhPdkVnL096dllUMUNPYUEvWlNjNS9qMzVPR1VuSkJ1TVExc3JtcGM3R1NISmlaYmo3aElPdTJlTVMvaWt0TFZqWThKdUh4UCtFL1E5cHlwMnVzZCtiN1JCODhHVWRVWno0bzlzYWgxV25VYnp0MXRrWWlzTTRDMW9CejlyYXJjMm4ydG9jODVhdDVUUEVtZVZFV3R0THdDNExTUDJRVkxLMU5LRkNXMngxalZxa2xpTTBZTTRvdnFlT2p6cmFtODdKRE4zQnRxWENQTHdIRTFuYitWdjdWbjhjUUY4SmZoUGFYTXBuZTFwUXg0WTgvS0tScFYxbDAzNVI3TGxUcHc3STlWNWRUYVBYVGpxejFyTDMxWjQrcTQxOWxQbFN0SlI5VG8zdjcydHArTDNmMXRPczVLZUJhdldBeXNzaXhEMkcwaFNiNVovdDhxcDRSZ0I1aGN4ak9tMHI1ZTJIbUVVcksrZDA2Z3NMRFFLbGRJR0lhKzBJWFRFRExldVJLRGlOWlNGb2ZkTkNuWmgyYldJQTl3Ymp6UXUwMGhTVjZva0psdUdqK1V0VzBieTYxU1VrWXhpMkNJeWdoQW5oY0ZMa05TS1hsOUtDbmExMks2MHZ4NU5qZEM2dm55Y25qME56NTVDTUtUVjZwYkNhdUVNSFNPVytXdzFQYlFGeDlNZWJ4eW1pWnZhT3hPeDV1Lzcwa2RFUGFJd2YzZit2ZkI1L1MyUEtzL0tyR2ZCTGVDTHFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmc0dThYVTlQM2Z5cjgvc2x6RFA4SndYeENjcEJMMnRFNm9WSEwyd28vbE5ycEFUSFlEek96bHZsR3ZBTUM0RW1VcDErRmZyRmlPV0ZHT21melVkTk5XSWlpRko1bkZUb2lLdkhtZGdDczRzWDZ4aGxxaE9Va3I0OEVaWHJrQTh5aTU5RHRHK0xSalhJVDdRd2RKNDZjNjlXakJGcE9QTFowQXJZcFBCanR2UDdTWDdWa0dxVHl6N2c3RVZtcjNQelJnRXFkUDRVRTM2bTFucU5USlVaUGhZZG5VNTZzR2V2UnB2Vk9TcXJrM1owK1huNEVJeGhRNXRhbys5aWkwMGpwbUVvQVkxajBpTnExUnMvYzdLMXJ5MU5UTzhveXk3cUNNVnlMQTRDWFlGRll5blM5UnRnTVc4WHplWWE4cmxGbWxYTVEyc2NUUnN1dDRWMW5VeVZ2R1c3OUNJUlV0bWY5dFE1SGJiL1hnM1IvMy9GZkNmNXgraFkyRyswL2luMzA4UXdxWDJhb0dpdGxXMHBiTEJabE96cm1TcTRJNjc1K3k0MGpsU1YwcVJnZlFyc05GakV0dldOZ0dSc2EwWm5mUDFmaVY1a3B1N0xXNk8xOWpaNWREZXVpNTNtN1QzdUNHaE1YTlhYQVNrSmlWSkZvS0FUZnlVb2gyS040ZU5wME5JSnpUSXdITTk1OVhFdCtyN0FFZ0IzU2ltcVJjdUsrUWJGMGxPbDNTVWYyTklwa2trNm5JZWw0dFd0NEdLTUdjTThtTzRQS1RYTEdXMnpNV25oREc1N20rK214dVJWTmZVaVd2d0tQdzBBYkZGWVRWSHM0cllVbkNHWHdRTjE4djRmMEVmajNuenc4aHZENWJrYlI5MUhvKzlaODVuRzlBOU1YVXhOV0tnQUFBQUFBQU1DendQTURBQUFBQUFBQUFBQUFMd0tYNkhyb1l3QUFBQUFBQUFBQWdQZnc2K2RQK1hmS01kUy83YUw5Nkh6bXlYM2VjOThPcGZaTGZ1dHBIMXFab05QYnh3QlhaenRkb25YMDZJWjA2dFpudEhoZDVyWEk3OGRRTzhiblM0NVhEMklwT3JrOFFXUjNTaS95Q2M1bXhzbVlsMUM0NWpQanRtb25RcWN3Zm1ieFIrSVFRdlBZYVlBYVBhZU9QWWhrQ0pOMG02TkZYdXZnTi9QajhoamxTY2p6c2pFQ1lDRXFjVjNUSTM3OHM5Y2pVdGgvcGZIcjc0ODZzNHhKcUdPWFFLclVneWFvUXFPdUlPUzFkaWJ5NkYwSVk3UDgrSVdXVFhMWDFzcEt4aU9DWXpHKzQvZC9tdGxjU010MWEyNUpab0oxbWxxbnQxUVdVeFRna3lWNmhJSTIzMnZwQkxWRExVT3EyNklDSURNQVRtS2x3Nk4zWW52YXBPeVBOZlBsNlN4S1QyVy9xSnIzNWN6Nk9rWlpscVZjemZXcGxlRnBlNi9lUEd2L1liUU1TeDEvaHJsUVNSVDJSWGRmaElwRm1SVjdTUlVWeWcyTEgwVU05YnEvQXpJOE9vc2x2b1hWLzF4ZVc5dm8wYnRTc0xVaERMU2h6Qk5EVzRScUx1Mlo4MWduRldYMnpMN2FqbUZlUmsrWjBwTnJ0Y0ZTbnRiN2xySm1va2tIbzFDb0Zadi9rWXBacHUyZnRNcVAwdlAwS2hwNU9tdFowdGhhOGN5T25ZbXZRaHYyUFNMRFVtZW9sTXRqaEJmaFdXMTZ0ODk2UHR3ZGhmMEZhVTlEYTV4Mkw5NXJ1Q0dxOFZWSkg0SmZ0WkgybnFNeEhYUmhVU01zKzRSNStqeWRkSjJYWjdYYk5EUmJVMHRYUzZ1RlB4NnJIdGxLcHprMHBIeVdzclgwWGljQ21DbDFrOWE3RVhuVVB4WC8yMi9pN285RzNmYWtjR05NWDB3RkFBRDR6V3VVQXJRZkFMZ0x5Q3NBQUlEVFlCa0dBQUFBQUFENEFnTUo0TFl3ZlovTm1jK1hzUVdQSURLU0FRQUFBQUFBUHNCTUFvQ0NYNTZmbEVzbkVIaE9MTENrOVp6VU1QTmdxRzQ4djhxM25DSVF3a1Z1N0lJa1k5aHZ2S2UrQUZ5VjFnbEM1UWtXWlpidEJOcFVqN2ZJVytra1ZRM3ZvU2VIb01uYTRsU202RGdxYlhjNjJRd3UyWWx3ZVlweFhNVWFyaWw3TnlNcDF4czlKMERYNG10MWlWMlpESVdYQWhrREh5eU1uQ0IyWTMxNlpIb2NkY3N0Y2QzUzJheUYvbjVYSWhuVFZxOGwwRS9naFhoZEVhWjRZVDJYdmtSU0xWTTd2dFNTemp1WHJlazFmY1hqL0FQSW1Qa3U0TzdrY21mWnFaSCtUOVRBMkJhTEx2dzdaVnBQbFpJcTBOUEZUR01BR1k4ZUlXSFZMNlI2UEFkZWUySCtBOXlJbFJPMjE1SFJzbDFtdnlSZ2FWczBoa2x0d1Yvcnd2SXhCR3NaMHJWR3l6OVhwckdXUGROMVpuYlhsYmFOaC9qeHowL2Q2Zk5mcWE1YTNTbExtNlFIYkptTGl2S1RLbVdscjYvenRQWnB5cjg5ZUo2dmRZdEhFb1hlOHN1OFBYVjV4WG5QbHFRMnArTHVyK1NvKzBndHQxYVg1ZW4xU0FscDhuZ2xsMWFuMW41TDNUMWtBc1VqeUhZQ1Nna3ZxdHVsU2JWRThhZHRUU2tpT1dBOWZWbzJ4dnU4a3RJV2l6ZHA1bk9GTGpTQjNSb1crU1BYSGl1UEdtNU9yeFNUSk9STVJQMjViSU13bjF1K1JIWC92NENwL21LOEtuRnlobnNuRStyR01KNXU4Nm9SMm41aCtmaGljVzFTcnl2eHJiWll0R1JKYTM3OUVMT2FLalY2ekpkYXZ0WWdhcVd2eFVsbHdoOHNac0ozV3NIa0ZzMkZRb2NwMFN6UU1oMDhINzZZQ2dBQUtxL1Y1VkJpQVFBQUFBQUFBQUFBQUFBQUFBQnV6UlcyZlk5c0E5dmNBTE5oQmdNQXdQbXdRZ0RBWFVCZUFRQzhpMStleEwyL1dDNS95RzQ1ZzZ1TXY4V3ZwVnMzV3FiUmZ0RmZjcXVPV01ETWs4QWszdDdIY0gwTXA0THNUcDVJeGJXU2ZndXJuZlhvUGNYaUZsT3A0OUJTOVdUZ3orUmpJSStnQjR1T1lUa285VUgwbmdTbXBhdWRBTmJkcFJZQnJSMzVCZUFoVFVyeklLeG13OHo2UXFqTGpobGl1dnIxTjR2TnFoWWNBRjVEeittZVpqMGkyc3ZVS2hPLytwaWNqZkpnVlpTMG8xQ1JLVENJMTg5Y1hYZUYwejQxbDhIT1Q1SVZJSDVOdFhQY1YrL242MVRUMnBMZlF0TXpMUFlUMHhmQXo4aVdobmRieVNJUFpzMWhUWVlBd0FWWjZRdTJuc2l2Q1M3cjNvMms5TlhxMU5LTllGWEVvTXFaM1JjTllkNGhGWlIwSlROZVkyaDl2ZlM3akZqUHQ5dmZWQnFlckw2SUl1MjNMWlkrMjVScVNrOG95aFNvdFZuYVBvbEZ2SVpuWE5iZWdhcGRTMTBsUFYrdnJWY3JReXZMNnBlV2FQbTR0V3VkWktyYms4ZU8xRk5iWEcyVWhlQmJtS0loenloV1M4SmphVWdqZXBTMEZ5amVMNmh1eEdpTGx6NzFQSFhqUkp2cGVkd1dMMW1HclhGWmk5ZXVXMlhEY3B4cm5qbWRKSjRBYm9va2xUV3BtK2UzcHZkS1F0RzhMUXF5Nk9wUytHNHBqS0ZkZHdEb1JKc3MydDZ6dFh6b3ByVzh4NDUwV3RwV3Zsb1pSKzVweEVvKzFKOEdIdU84OVdBc20xczk0WnVadVlWTDdVT09WSEdOL2ZUVmpiRmhEaHZ3NmxjOHV2ZkFGMVBoSFNEVkFBQUFZREdvR3dEMzUzWHpHTUVGME1YTXFjTTBCRGlXUzh3NUpqNEFHRUJVQUFBWVFGZ0NESEdGS1hSR0c5NVNKOEE2R05ISFFWOERBQUFBQUdpZ05RTUFuTTh2MDNFQlVUNTlwb1hudEpwS2xkWDAxdE1EVDhINjYveWUwNms0enVFdnRRZXVIVUhwUFFvSjRBNElwNEtVcDlxR2VySmRNUzFhWjM2VzZheGxYcGF5UDcvLzB6aTdORlh5QUZ3UjYvRlYrYlZXWGhxSVB3SHJLYzNsQVc5bEdkcHRXOW9RbExyVkFxMEg2MHBwNEwxVVR0VGNoVDhRaS9sZ1BmeHhOajBPVWxPYkxLY210d3E3dFBFTmNEeWxyS2pKa2hCa1BjSTdoVm9uSUl2bFdBMUJ6d0g5dlZpRUt2SUVKcUFOODQzV2tOT0dvblNpZWZXRTgwSllTQi8zMEw3U1d1YXBUbHVqUDBJN3BiaEhCNUprWVZEQ0FkN0l5aTBOcTgrMzVTYlFEc1hXWEF6Sm1NNGFCL0FhalB2elN4YmFJeWFoSnFBa0Ewb1NtcTJ5dkcyUTdLYlM0SU5icytKUmFyNTlyUzFiV3N2d0RrcGQ0bFNxMlI1WklSOTFHK2ZXN290UG9SMHYzVlJ0ZXBlMlZSbStxelRLWmRXU3R1SXQ3U3ZMQzhZNnBiRmhGV2NXL1NvR201NlpoNGVPY0t0NHRvalNxTmJpWWJYVmFkRm1OUzNlRzY0OThZYnpRWHhpUWFuRE9zcHFhV1pKMklaVWxENHBwMjJxU3NLbFZxNzdOcXplRkU5Kzc5Z3B5K3FsbFgvMmMzNDRIb0dzNVkxQ2VCRFNOYVlRancrZWdFWGExcWFCWkdvR0pkeUQxYmNmaXZEcWg3dHJEVXFOc29TNnkzaXZUZ2NQUnBvMFVsaDBodGZLWVhDWnNIYTExU2ExcFBPMnlmSW9lNjBlYjdvV0RMa3ZyS1oyTXBSUnB2T2E0aVBPQ0V5U0t0b1gyTnVadi9LbDc4dmlqOUJVck1SM0pTckZ3RHZoaTZrQUFLQ0N3Z0FBY0ZFUTBBQlRZQ29CUUEvSURnQUFBSGdpNkRnQUY0Q0pDQUFBQUFBQUFBQUFBQUJYQXI4MUFBakVmLzNQditYZlRHZS9iUCt2LzdiL2lENDQwbmwvUEg5TFpweUlCVDdvTjNneWxwT0ZsQ04wZWc4dGVlelVFbzZPVFZtY2V2YWw4UURQb29yZDZjU3BjZUlJd0dHOGZNek52UDNoc3F4SFhVdmhJU0JENEJOTmozaklXTEtvUzJXNmtqTnYyM29PdG5hNmFiSjJSSmtaQUxxWlBaV0d5bXNKaVpERnRXUy9sTThMZWdsY2hOUUlsRTc1Rk10cTZPclNsMUkvMG9lZyttK0NrS3lXUlVzblZXSFJLNlR3Vi9qMkFRN2k2TGsxdTQ1U2hwVGhaUnl5QStCQ2VIVDEzYVpHYUo2aXZnc3YwWlFjajNCYytja0ZnQVZZWGYrZmY5UUxzWmovRXU2UFhRaDd6clV2TmtqN25oOTFwa3JaUlZSTHY4aUx0b1Jyb3NKcUw1WDVwTHBhSXRJcWpxenVuUkdzOS90OHJLT3RGdCs3V1NkWjJ4STl6Z1l0dnNmaUgxMTRLM1YrQ3cxaEJGcGZ5TmdOWklPekpWbzN6Q1JHcElXMTdGcFpyWGlVbnNQb21VTGVza3Q0ekhCQmVuUlJiNzdXS3B5SEhhblRsRHI3N2o2S1JxZ2lvMXdhUTRWeVQrT3pDb0E5dmVzU2FzYmg5TXBTcVN5UHJLemx2eElNdTBXTUREcE5SbWd5dytKRWdTYWlsVi94MDlYeXRzemkzZU9WVFBVQThCZjlpNm1NRmdBQStJSWw0UURvWkFEb0Fka0JBQUFBQUtDQzJnd0Fkd0Y1QlFDM0FZRUZNSVV6cDlJWmRTTTZBQUFBQUFBQUFBQUFBSjdCTDA5aTY0L2hQVCthbjNHcXcyV1FmdG1mLzZSOFJTZkNKL1FkUEoyV1RKRk9raDJZRjYrWVVyVlRvWkx6c0tqaVpHQkxsYnNpS20wQU9BVEdXamUvdTI3MEROMW00YTFyYjM2QTMwUkQvSVBHenNqdDNxa2JraFMyM1NCdmVnSGNpbnphZG9ubEdYYkZiQ0dJWGdJWFlOa3dMQ2RzTk5RMVNRRnB1YUd0NElvQWdKVmdrZ0RjZ0tGTmpiQ09rUStKQWR3QTF4cHAvWnhKUnh0bVVmc0NRM1hmYzhGOHRYNWJjdXI5R3ROWlhoVXFINjhYUk9CTTBxUTBJK2xYYnVKbytVckpwSDBGVml2TDJaWmtuYkhKWFhTVmo5dGQ1UXlkOVNYVzNycFdjVWFkRnlZWncxYlZCWEFSVnExT0kyVWNJYVZxWHpvMVZXNTQxend4NTJFV2pLWGJNUHRSV1d6U082QlpCMmlsQS9RT0RJL0paakZGdDM5NW9DNUVYNVBTNTdzdWozTFo1ZGZodGJidytONkw3WWVwc2U1dUd2Mk1kK3NMekVHb1E3dStCRFdoYVBYWG9RQ08wVE9JTkM0NXlPRDFhUHNOakZzL2dqd3VsYXBZeEhkVkVmZjFBRnlLSGhreXNnOTZVV3JkVUhQWWxLcGZhcFJoVmtzc2lqTEFLaDR3NWp4T2ppdWFaRk9kTktOdk5Ia2RBUUR3aDE1WFJFc0ZxRjAzeTF3eFg2M09RTXVOajlwRnlDTncwSFNoeFBhMU5kLzNvUkRWeEhraUJ4WmZSQ0VjZHJLaVV5Q042Q09ZTUFCejBWVHpVTVJmemExamxTZldObHpSaGdOd2N3VmQxdEtHVVo5Q2I3NGVZVENhRHVBRW9uTGRYV0REUHZnT0YyenlMVHlWKzZSU2xVWDZWcDNmZFJWMmp1WmlDQjN4a2cvbERGYUsvRm4zTlgwc1R1ZU9WcVozaEkvc2FualJabzgxYlN2L3dNalBCWlRYcURIbGljV2ZJMk1yR2hzeFU4blJMQ0tVbjBzejYvMVJIak5BRmF0VXZoU1pmcnp4ZXlscy9hQmt0NmNSQU1MWWdKZjJrV0E2Zzl1RmxtMUNOZThLKzIvVXQ5ODdCS1YzTngrSnBrZEtuVGRqbzJpbGsrWDZEb2xiVWZQVFNXbStyNE94N09LYXZUa29hZjh3TlZYL2JJYjl4cnBBYkhJcUZ0ZVdPcXp4cDFBNjhVZHVFSFEwaldLMHozbEdjQ1dzR2pUajFvOVhsa3lvZ3BQTjRMTDBqTTBiam1mSnVSR0U2ektzMUdYTGNLa01OeXRlRGdObzhSS2I1YzZPeVZNZkNmb0x3QjkydW4wbHZuVXRvZWtSa3Y1UlpjWExLMTVIWFJvb1N3TjVCQTZzRzZJaCtGOGRqRnFsSXdwSDV6eitrQ1dwenhkaDJmelZUQldtS1VBZjF1WFVHNzRSTy9LTW9PbE5Xbmh2T29CTGM0V0JuSXhwTEJPNGxpOUhVNmhDSlgzdFpTZVBmbVZSWnF6YzJZa0V0MExkcWxSK0xPclpkeXp0aER6Y2xILzNSeVd1UWpUSUZFbUVTT2trRVRIREpKUHExT0pXaW93VjkzVjk3cUFCZXIyQm8xcDdiVEo1WDk5ZU9Zb0ducGxvTVBTV2VjVDQwYXljWGtmczZwbCtsT1NDRDNvY2xUd2VnRDg4NGJYZlhadGlvVnR2MTlvUGtDcGxJaXBlenNpQUg1MWNETDdsV0cxUmE1NWF1cFhibVZxNjN1SDdLdnZZMm5rclpNSE1PbktRSGRNeG1jM2FCcjlVWmhTVEFQemg3dzlUcGMyZFRzRlJabThKL2FoY1g5RTRFSkVhWC9OK2EyVWs0Um8rc1F3eWdLZFJHKy9TaTRpQ0RJbkZoY2VIZjJzNUxTSEo2enhPb2tnWHkvQXRPbjFXTWZTalZOWUdtRTNQbVBKc21Ed1lUY2Qxdjd6ZVU1bTNjb0FXcFYzWXNoTnZQTlk4WnNTVmRaK2V0cm5GOTBnSHNGYkF3MW5saXREZTBYVFg2Y2x3cFhtcmRRU0FrMVd1dzZidk93ckRWOUtyUWhFdTVXdnhOWS96Nlp6QzNrY2tWU21xZUIyNlg3ZEl3YVlCV01ZcVdhajlZT1RiSjFya1lackQ0K2xkMDNyOXRkNDh0ZnloS0VlYXdMVzBNN0crWExBYWp4TUpJS2R6VG40TU5hbU1nZm0rc3hPeThCQWFSWGFNLzlqOGxhMHhYYU1wcmZzSXdyVzNEbXZhbG9qc0RXL0ZQMXNjZVFhNFY4TWNXV0M5K1VicTNOSzM2cTR0MEdXZFV0NFZMRFRrTFo5OHlkc1FSMS9FT05wS2FkWFpzNHRsUlJwVEZsQ0todWtWVjNROVhJalJWYmUxV3RXR3VtWEZHMW1OeXErVVJxRXk2L3QrMzIySnhYV1pJQlFSbVRnVzl4Y0Fmak9xMm9aS2ZxdmF3Y0M4TkNzMTJqTzBaWTNIcVVkSGRiSzJFTGNXWG12NzBGMVB3MnhHbDZRc2IvREI0NFpmWVFHbHE2Sm5vQ1ZuK0dOSXlqVjhja1V0QitBb3lwM0RHcGI1a1poSzN4M1FzV0JaSFdpV1BBQzNnb0U4aE5wOTZEaHdCbDViNU1aamRHRHBQd1ZOMWZQY0I2SUZZQjVIeUpDYXZITFBZKzNsbGJLU3ErZ2hDQ3k0T2RFZFljQ3F3RlRtc2FUcWFjVjlwL3VxMi9yQ1VRZ0QwL2hPaWhyQUpKN3FCcEJjMkZkVE93QmdBazlkdSsvbVJJTHIwTG5BUlVzWnpwZmhwd3hqNS8zRW9GUTZVUWs0YzNwTzdXUDR3ak13anRqVU9GTmJUWXZqUjlCR2ZNL3V4VkdjTVZzOURwM1c5VXhxUCt5RzVWalhkaDRIM0lCWnE1Umx1TC9DZDJSVUtCRVA4TTJNWHd5eExoM09FZkxzVENzQkFDNkNNTkZkNGh4aEFVNysvakExMS9KVFVBZVM1UWZ2STI0Y3o0L3NveUh2STdCMCtsc3B4NjMxN1NpdEwrbHp1Q0tkUjMxOVQ0K0cwTnk1bll1VHdDcFplcHB5WGFJU0xubkVCdmF2ZHFldGJTZWRhWFVobDJBMTB0aXpUUFNKTHhPc1JwcmVNMjVQRXgwV1BrNC9MSFdkVnFYU05iSURXbmpHaHpaWmJxSVVhS0l1Q1BGWHdDcXZnaUZkTTJQb0xXUWdEOEJOOEM2N25tVzU5VXFReFdlMk84SFFvN3hZSzVYeWFXdERLMTJ2b2dYZ3hLcFdlMHh3cTk1dlBtRzB0UjVieDc1d0k3c1RVZ1hqNVRzNEZmVUhlYnAyNng4MXJqekhiMlQzd3IxbzZRQTFKSDJqRlQ2NkxXS3BvNWFuZFYrald6cW9CbkFLdFlGZEc0UkhEc3pWdnozNVRXMVBOdjgzRk5kV3c4anJQRTBMeW13eHN5eUFMMnJEV0J4cW00NnV2RlJXblJxRmZsOG1MSDBKMGJqSXExODV6ZTBRNjU2R0VDeE42NTZwS2QyZVZxZWxMc2tlRWt3dU15dkUybnZ3T3E1Nk5rcktmRmJ0dFdSa0lWZTlFUlByeXZQbkUxeDcwYkJ3UnRRKzM1SUxGc2taa1YzdTh4bnZLMVhLL0l3TTQxWktMWjFVOXFpVTAxNHVhWldKWkJsQ1dvQjdSRW12eU9BUndndXdTRE1wcldlRlNBMzdOVFdjYXRJWHlSVDMreTdkVnBabDliR0d3NHV4T0pwSFZVS3BYRERSWTRHc3F0UHpHTDFibEZyK1VYdjVrZFE2eWZLU2lEWGUwc205ZTlGbE9FeG5SSGFVdnJ5UG9WWDZDaHRyQ1BNVkpKWjhNYlZGeSsrOHhjOEl2d1RialBYdXN0ZTQ5STFlZ0xLdmUvb1k0QVg4ZG9LWWxRSG0wQmhmTWlrcFNWclhBTGZrcFFOWjAzSHpkSjR5djVIMFNvQlpXUFJuNndDK3NSeTR5eFRUZElqWWlBTUFxT0xaMmRmeTlhWjd3VG9EMStFTmFyWFZuKzZkZWoyK2ZRQ3dzOEw4UDl1ZElPMWZ6MXI2a1Qzd1NQQUR0c0ZYQ2c5ZzVUQ1dmb1RhUlU5K0Z1Zm1xMEp3SkN1ZFRkSU10bXF2SzE1RnQxanVNeGg5SVN0OWRkL0pNK0tVNm5tcDdWRWtZeGdBTlBHOFYxY0x2NXQrWmJVQldERmdpRjZIS29QdE1PaHFBT2hoeUJKUGRUTzgrcnNTRkJEbzRKZDRPRmNJdXdHbG5iaGkxV1Y2M1hOSE1kWDkxK28waTRXa0hROEJQMmhlL1ZUOHEwRWZ3NTJReG5zUm5ZSitvRXBzcE11TExxOGZQMldFRGlnUDRQem9oOHB6YU1XcjExcWJBRmJ4OEoxeXF3cFIvbDJHNVRxdWQrdFhFZVAxUkZKRHZQa0FObDcrYTBacEhrb3l3dE5Gby80YWs0eW9wTlhTZlp4eXB0bWtuaHZIUVFVd1pDLzFUcC9vamxBcXJEbnczbUtESU1jZWpYVktST04xbmsveXBZaHRpRDk1VytuU0xtTm9acXgrY0NUdDQ2cGxOSHhLMjcreG1DUGFsTG1FNk5BZXFJY3J5Z2ZyL2VCTHVnVWUvZDlTVGswKzVXbG1ESWRrQ0grNXlRbFhZS1lNek5lVDFpUWJxZHVpV1BRc3dGcGJXaE5YMGh1c0x4Rm9DbFZacnFWc2F6akFVZFRtbUxBWjZ4NnV5cnd1djNacW1Vcld1clJwVzYzVW1OVHFscFRDdGE0T2pXdHJuZGI0TUZDM3Raejdzc0lZV2VYQWtVWlhLTUpyempOUG1aNzI5TXpva2NYU2F1a2I0OU4vOWtscURvcldpeXVsZ3lPR3ordnkwblg3a3RJektxRmFsZGI2Mk5Qbm1vSzFZczZCRysvMEhaM2VBRGZBS3Ayc1BxWFdhaXlhMVp0ZnZ0R0laQlNmclMrdDFvSlR5bnpzZndLeXNtSzlDTTJVOXVpb2NHTm1MZTB6VkFNR1d6Y3pIcU9rcWMrMlRDUlpZMm5MTEExMHlLL3hGQ3crM04vVU5uUnI0UjQwTTBsckc3SmltRkdaVVg3WlBmOXhhc3JEczdTN3ZFVmJBQ1FPKzJKcXk1V1N1MFN1NEE0NXBBM2VqVHNwSHdEQWI1QU5sMk9sd1FWd0dBeGFFeFlkZGpRZUFNQ0s5VlVZNUE3QWZSaldJMFk4eFVtNWZpb0lTVmpBa3MwYXdSaVo0V2RQampqc0hZQnJZclVOVmhJcjdVQW1BRnlVY3JMVzNvUTlhZ0xYaEFmQVhiQnNFSHJuVXFmQ0xVMmw2bTlrUnBYOHpwZCtaa3p6OGo0UklWZGx4U0t5YW1GYXNkTS9JZ2hxYjloSjhmbTFkUmFNT0EvaFB2QjhUOEh5d2l6QXk3Q3VnTGxhV2RQMWhodHhsVG1JOGdwV1JnWStZK3d5ekxCZ1JuNlVLdVdYMGgwOWJHcnVTWVl2dkpsaFQwU3FoMjAvT3YzOXIvUWxWUUF2djB3ak5yWVZldS9wTmExVGE2cE84R0EvN2FYVmxpUDN5NXBvSFFKMlBQNVhiWkRFUmw2QWgxQ2JCcmtjVFVFL1NHVkduYmZFZUFQbENTT205U25XRlVEenlUSUEwSVcyemVwUjJXTHg3eEhUVTJ6VGlNSU1VTU9xUno5a2JLMllNck83UmpOZFdvN1puZXpRakc2UDgwbFNLRDM1ODdZQTNCaEpsbGo5WE5MMWxtZGttalNubXZTckVldlJxMXJEV3BYUDhwRWhTMkFRYVNuVTdJY2Excm11NWEveFBXV0UwMnFqTUJkaThVY3lPb0krL0IzU2krK0ZmK05RMTdmWGgzS2tqQmlSUzlaTzlBNHFaT1d0ME14OEtkeWltbXV2c0h1SFNDMWZTNzNvZ1dFTDNYamVmcldtdC9wS1BJNUliMzNTV2lHdDhkTDFKalJhazFPYTBOcjlTWDNheXRjckpBRGdBM0ZhS2d0MHVjOXAxVWUrQXcxeUxYYkdXMFRHS2hHQ2FIb0swc0kwdzFEeWJxaG9vMHJUb0QwdlJXbWtNS2NQYXNTUGYxeDZWaFFjR0dWOEtBU1h1VjB0eThscUlYa3NLYXVocnltVVZzazNPc1k4V01mMVF4ajFkZWRUamdVR0hvRG1BKzlaWWZLcE5HUEtKUEhDVG5UNjFaT2xzZGt5bWE5S3BTaVJ0QWhFQ0pobytYd1lSSWN6MC9KWW1kK2l6bGpxOE81cHhFb1pJT0ExVmJSd0tiOFdWbXVUdHk3b1pxZWZWTVpGdm85Zi9qaTFsc1c2cGNGamhZM0R2cGlxMGZ2ZXhPM3hiTURCbnMzNmlwM3hBTkNFcVRPT1owOEZBSzVKN3N5OTBueEZkc0F5dklPTHdYZ1lEZitSdTR6cG9EZ0NkR0Y1Nzd2M3ZSYXh6dHFPZGEwaDVZNS90YkRnckR5c2gzVUpUcUkxWDg5b2hQVVZXQ3ZKNEdOTnlqVUEzSU9WY2t0U0wxcXYyTTk0U1FmZzhjeDBYTEt2Q3ZBT1p0bjVFcnluQVpkbXBtYVpCcStsTWpYSFhTamlReGgvOHk0S2JmQ2dlQ09RQ3hjRWdkMU42b3pycVlQSEF3K2dkMW84VlVwNTd3a3hBRlB3L3NxUWdiZU1HYXFDdGlkNXR1eGsrTndFVElGSHNEdkhxYmorODRoVHBsZEptM0tNQlJpZy9zUFVpbDhzSDJ0SGJQNHlycjhZNmZTci9YcGlGYVVtVllhM2ZLbEJ5QXR3Tnl4SHlVakp2MDdCK000aXlBNnBDbzNIVFMydEk5Sm5NdFA5Uzg4THVRUm5NM0tvNnczMEVFMTBSaVdQNTBDb0hobmE3TUthenRNcUtNOXpwRklQOTBiU281UHgrcVpJdHhXSzhDc3hwZXMxb2FpbGw5TFU1TlhxRjk4QUxrQTBYcWZnUDFCU0NoZmxsbkRDNGU0ZE42bVNaS2pVR3U5QjB5YzEvODdLZFFsOTZoVlk3SU1TNzVTeE51TDdsTk45VkxVUnlTSmN5ckt0NzhZV2RWa2F0ZE92aW80eDFhM0poTm0veEIzaERQK085ejVuOURtY2hxWWJlR3daVFc1SlpXdEVSNTFiT291Y3RkVEJNbjB6cnZqQVBMNVFTVlpxTnJYWDV2WVlEbFlkZmNSSTJaRHExTnJnbmZBQVQ4TnE3M3AxM0ZxNHRxa2g1STJLN0RCTjR4dk9kY1RUbWZRb0JWNmpSZE9ZZ3hBK1ExR3gxcDBia2xhUGhMVnNMWCtyRFJQeGR1ZnVqZHJTa1pFKy9wR2JiRkd3UmpjMUxJN0pXa05UMEJVcUtkenJzSzB4NnpuZlZJcGFwM3lQRWNyQ0FnK20xM1hZczhyMjdwT0owN1ZEN1NpWG4yaHNWR3JFcHlKQnZwK1hyd3lZMUxBTUJ0TXdWbGs0S2pNdDdzZ3RYUjVmMCtoSEhydFV0NlJGUzlkbGVLOGw4eGdzNjVMVno5eGpEbWltaC9hQTRiTEV5cmo0SjFZZWVmclJTNkx4K1RJTW9PU1FMNlp1OGlnVzF6UHBlVy9tMHN4bzdLMXVHQUNHR05ITU0xa1JpMnV3ODNyakNKN0ppSUtGTEtuaTZaWm0ybExCQmpnRDZ4NDVUT2R4OWk4QVRNVnNtOFJHNWp6ZTQ4aWJLWHlTTS81SXZRZ2hDMWVuTVcrVDgzb0ZUQ0dBWXpqRGJWRFdhWDFScFN6RFd0ZElmZ0FZQkw4a1FCOGpMd1QyNU90VkNDd3ZKZGF1QWJycEdmanVYemdLMTVhM2dFZlI2ZzdadFRaeHJSTjc1SWVxUjFvVGpycVFOYkNDbFVab3o0OExBRzdDclY4VnVOSzdOc1d5Ryt2QkFIQlJWbStoSjJQWUJqTGpwbHhaNERPbzdrMzYvRE4rL0pHeDRzZDk4RHAraWNjcDVHRnh2NUZjWnRHSXl2VXNqbkFYTHFIbktLQmFmb1NDanVaYkhuMFdBRmZBZU1STVVySW9TOE11alNmZDdURDJxUnBlS3lJRzI5ZE1DaWRVUWo3QmJMempYRXI3MExHcHljdzhmS1VxOTkzRjBWaElGT0lmSzdCaG1HaU1mOWxZdVlMWklFMWJTNTZjbG80My9DNVBLdzc1QWkvR3N0ekdTdm9sYUtkcDV0ZFJ5Vk9XbVJ6eFIrbU5Nd1UyK3RLcjBJYTlkVGkzNXJ2cVNvajErRmJaWmVKWUNLRHlSUGNrck5mUktpc2F3YXF1NHBsTFovckxOWGxWMXVXUmhhMXdLU3dNcFBPd1d0WWhVODE0OVA4OG5jWGRLTlUxUXE1Q2JPMnB5Y3lhdThMcUZ3bkIxOVlIdTZ2dXp4VWVqTWRIcHRtNTNnR2FPdUpMdzZGc3QxYzNsM3lNcmJaWTdRTnJ1RmZRQVZ3Umk3SnVtVHROeDEwbjVlSmMxaGtNZGFLN3ZSVExnMytMcGlYZHAzWHg4bXF2V2prcDlDK2NIVHNMcFpNZ2FZcUdGRjA2STdKLzg4L0VWY3RNcG1DZG1ac2FYcVVvQ1g5YjhscVJPc2FqekQyY1dXSkw4bm1IU25nTnl6UkdQNFlMNEJuV1VqNUx1cEZwMldXcWw4dEsvRnpleXV0eTZVdmFlemRsZE12dkxuUVdJZ0M2a1d4TFM3NFFzUHNFWm04NzVXV05sRDFiVnZTMFJaTERpb2pjMWZscWV2ekVOU3orS1c4WlFTaVRCM3dhVVJNaXhYVnBnZWUyeVBlU29Ud243VEVEL0JNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBejgrdjZyZFNSeGFsNTJZemxMVGpzTndub1krWlkyTmE0UHczUDRuUFU0akxlZlVESnkvNWFUZndHdWp2VVV2VUttZkdjVEJITE1ULzZxeFAvNVJ6aFI0N0VIS0FrM2VNZ3BJRnRmVzA4K0J4aWxOY1lreGVyRzQ5RXpqNlVUZ0dhZWJTdnBxaW1FWURvMTNhcy9Ja3RBdy9vRkR1dlhBUzQrNXJ6bm5COXBWbWlIekxYTzNJNUJ1YmVScjVmYzRMa0NYSVdWOWtPM1BPcHBsUFVrUmt0K2JUMEpXZHBhdkVXM0dlMTRaQnlFNFA2NG1BVnQ2bmg4TGVVSjl1b2h0ZEtKcVVsSVYzNGtwYWk3cFlmb0VST1pXWWYxbEdLckRlYloxQWhGSGkyOVpaQllzZGFwNWJmYXBEUEtmQ2hlK2RJakkycnhlVm1qTG9kV1hNM0ZVVU9UdTYycHlCTGV5ZWhSL1RNN2ZvYXZRYm9mejBLcmxSMkVzclcyakV4MHE1UEFxN3hZSjJjdDNudGZLdzBrZ0tOSUU5SWtZM3FyYktubDhjejlWaDN3RWl5TFpHdEFybGI2cFRxc1ZyYVdUNHJQeTBsS1c0S3hyTHpNM3J4V1oxcExJT1QzMFhwWlJFUHArKyttUkRscktJc1FubzlaTHMwMGxEV0ZNZ2pwUnJCYWI5N3gwZE1HNjFpN0tON0hvdm5BdFh3QU44ZXlLdmFvbjJYOFAwSjhpNTFrL0Nvc0tabWxkSG00OUlYVDhrdXA1VEtWaEJ1UHlBUTRFczIybENZdzQ3VEpEQmVwcGszMlVCTTdQVnZ3WlhtZU9Na2E4cm9pWGpzRWF3TkRHandiMW5udU1iRzFzcno1a1NuRFNEcExxYWNrWVR4RWFXeUYvaTBOQUFtK21Bb0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFKdUsvL3VmZjhtL2dzMTlKLzlkLys4LzE2dm1SZlZEcWlFcTRsTysyUE9aR1RzSnltb3YxWkFlZUJUd0I3d2wrVzlya1ArenZjWExZZWdTLzhmUzFGcjlQS1VsNW1RQm4wWklac1pIK0lmVGM3cWdzUEtRTFBRZEJ4NEFzQXAzWEdHZHRybmliclRaTm45NldrL3Q2ZEZHQWh6T2lYbGxQVkxWTXdXVkwvb2dnc3NTMzZtakZhMGQ1VytzQWFHQnhTOWJTaGtvK2FSaW5uc29sUDBlWnJESHVZMVo1S2hzVjdDZW1KcWxOalZOZS8vaE1QUE4yNWFiR3FON2JrNzlYWUkvSU0rekN4OU96RkdwVHpWSzJWb2NWclcxU25RenJCelA2d1RMUG9MTFdaZFZkeXpaWUYxVkxYdThuQ2l4cEFjREhyQVhJbzBkcTl1K3NlWTdzZ0Vjd1loQ1dLQzhUcU9ta3VzNll5RmtiMVUvUkdSVU9pd0VoN1RPNHNRak5hS3pjNnNHWmNZT1NVaG9NWlZ2U2d4dlA5RzExUDJzbVhKQ1JmU1BydG5CUXdudncrcTI2VlBIQzV5MStNVldxUTBrUHNNTTdZSzNPVURpRmxYNW95VXFZcGtZcmRkYnFsdEtocVNyTTJOVFFGc1ZnaksrbHM5WU55NGxTZ0dWUEk5TkZra0ZJOEZqQkMxOU1CUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFUdjZxaHNSN2svUkc5ZHNxRGR0YWFsc2NTdnBYZGU1cVBWdll5cGh6WEF4LzlweDFJbUlwL3l6TEtNSjRKM0lGeW5EdFA5azVaMnZLTEZGR1JUNDhSWDk2ajJ3dzN2RnVYaXI1TjNsUFRBVllSbGV1TkhrWHJCa2hxUk90MnRWdjNucWZyWVpkMzlDQmRLUXhBMHkrc2gwMkhSdm9Mb2sycG52bTdXbVMyeFBiU2JpK0ZwcVkvaFNJZTJRTVBwalVkTEhKbXB0NHhSSzlkNURsVzBlTlliTVZMSFNHdFN3Qkd0Q0ZVc3lkcWNkWTZYRXdZMDFFbzQ3ZlBJalY4UVgvaXN6SkszOUpXUnIzd3JLQ3c5ME0xZFJpclBCcloxUEFLWW8yZVRZMHpoTCszckROMHVwZnJrZEt5ckMyRk9kNGhwOVhaS2pzMDhrajV0WHlXY0c4YWFERFZnVFhZanBZL3ErV0xzSmFmbDFjcmMxUkdSbU82V3B4V1J6RFdwZVVIZURxakRqcVBYSnVsVjNrMkdHcjZzQmFmaHlNN1lEb3pGSW5lL0ZvYldocTBaWkNuUmgzVysvYjBqM2ZqcjFlSnNPUVYwdTI2d2ZpU2lYVHRha05yMDZwa2RGTkRLcTlNMTlwWnNqb3d0REV5b2tpK25OWVVxRjIzdWxwYmYza1VjQkU4d3pqUFkxbGhOSE8zaDkzN2RlYU1ILzk4bDlHVXFNV1NrR0xSaGlKYzhvRkg1anQ0OFM3eDJwSmZxamFha3hpNmtQYitlelMybnJxbXFORkYzcEcxd2F2WnZwNFpQaVhOWE9qMTgzak1JeGhHL0oyR2dtaHlSeUZ0eDdOa0dJQUdYMHlGZDRBVUJKZ0NVd2tBQUFCZ0x1aFhBT0FCbVFFQUFBQkhnZDRCajRDQkRBQUFBQUFBQUFBVDRjZW1BQUFBQUFDZmZINHh0WEh3VndwOVo4YTFpTUYrZ2s1WlY2dk1NcDNsZ0pDZXVwYlNPaVN0ZGcwNjB2aVdmc0tmaFBqV01TWUFWME9TRllxd3JBN3g4aVF2WVI0OGZucElza09RSVpaSGtKK1NscEs5YW9ERDBVNU5hNTJ5ZHVNQjNGSUJhbXBFNnhaVEkxK1pOeXJYVXRtbXdtc2daTURLakVPYXBYRjZZVHhuajB2elZUc2xjQlJOVEh0d2k0VGF1TEFJelZvOHdJUFJUaXV0eVloU3pkTDRwNUkvdjY3SksvZjBtL1d4Z0x3UnZYanMzcklkVmgzV1c3ZUYwZnVHMDlGMCtmSnZhZmpYY0xweGZBaCtEZkVycUJZbEl1N1RmMHl0MkM0ekNhZkoxOUpVQldsTHYremQxR2gxZWt0VzlOakJQWnNhczJTSTEyNXNsVkZiYUZycHBEUTliYmlTUEIxWkd3YXJ0SWFYYVdwTFljOFVrZUl0VTBBekZhUjhXeDIxYTJzWnlWRDJwYmgwNHc3RzJnZmFnanRyTUpYbGhrYVk1bHVSMHZVd293eUFKK09WSlpxZVZxWnZwZE0yQWJ4bHQ4b3EwMHB5S3lsMUlGTnV6aE1VaVJsdDkyNXFXTXV6bEtuVjRWVWtraEJldS9ZU3cvNnpjTUhIcnF0VGNkM0lHd3RCcHNvaDcvTzBlRW10emdZdHZsV250WjNlNSt0OS9xMnhkSE0wWDRQMCtGdnBRL0N2amF5aGNFRjZmQ2hXU2VrcE55K25SYjZNdE5JbkpiK1dMby84c3hUVzJoRGJaZkRqVlppRzFXK2xxVHBTT2hEeGJHa01xOG5GZFN1Zjl1aTlXTGQ0OHJSbHVuSi9vYVM4UDRiaEFONU5EWThQWEZ0Z3BUSmhLdmwrK2U0TDdFWGZpL0VsbFRWQm1zOVNHSThiTlBoaUtyd0xwQ0lBWEIza0ZNRHRZUm9EQUFBQUFFQUpkc0pMT1BKQk02aGdFV2NNTFlZelBBb0dOQUFBQUFBQUFNQlNNTDBCQUs0Sjh2a0E2R1FBdUNEeFgvL3o3NlNleFBpLzE3LytqMXlJZG1paXEwRkJQa1doZGwybXM5YlJrMjhabHVNbEx0SFFHeUtkK3RKYkJzRGQwRTVLMnVJTUo0SlpUdU41TkwybnZEUU9EeTIva0pxZmxwYVFQWEJGakRLa0dYNGpKRFZDVVp2Rk1peDFTWWRSaFVxNHVUQXA4d3psSFNESE1vWXVaNHo1OFp4VWVEYWF2RnBxaWxxRmFCbG1BVHNaWG9CbnZrcDVQWEpxdWVyV2MvS21WM1o0WkVPdGN5dytKRTNQNnBGUDNsTk40ZFpvS3JtVXJzV3FOVDQxeG5YcHo5alZFWDFUU2dyWW5UcnZNY1kwckhaVEM2dk5OVktYSnE5Njh0Zkt1dFNpWVFBWldVZm9GNHZieHVyZnNCeXEzUW92eSs1NWhGdWU3ZVRkL3pUS3o5TnZjWmIrV01vUmxWMWhubHJ4eXNaZWZhdkdTQjlwdXFxVlhqazhzMndBK0l0VmRsb1h3eU1adFlkenRFVWZIczdkRkcydlpqbExrWmlsUk9SbDlTb1JscnplT2pvVWoveVRMdFg0c2lrRzQ4VnQ5MnZQMXlzc1J4eDJsc1dpZCtQRTZyalVudnVJRXZ0UWVvY1EzUWMzb05kL28vbDFyR1gxcExQUTYvNG92MmFhRE02ajB1ZjlrM21mRG1BSVRZM3crdEpxWlV2NUdiL2RXUGJtUE5ybDFVMXlxeVhHa0NxdzZwTWpKa3N0WFEzTWhWdmczb3B1S0ZvZnYwK29sQUV3aXZ6RjFCTkhHUU1jQUFCZUQ0c2hBQUFBUEJGMEhBQUFBSUQ3ZzA0SE1BWnpDQUFBQUFBQUFBQmdtQ05kTExoekFBRGdVckF3QWNDRitQWG52OUt2M3JkZjB3dS9xRjl4V0dMdm1XTGFDY2g1dUhhN2gyTTVZRy9rbEpOV3ZhZmM4SUZZQnFQVzE0M1RBd0F1VCtlSmZUV1JjOVhUZHc3RGVlUGJhV3JSbUNhRnl0ZEl0c3Z5Z0ZIa0VwekZEQUd3UXFkWmhPV2t4N0w1dmJLeU5hM2RaUW9KdGNPSzFUSU5wMFRDUzVseE11TU44UjQ4WnprbGNGYVhTZlp3VFg1SmoyM0dtZUlpMWxNK3BXdmtEN3lBbHI3UlMwdW5zUGpqVE8yd0tpN1JHT2Y1V0lCVmh0VEs4SzVoMXJWUGMxaTJIakN5N2hWWTExdlBFTFVPWHpGKzgxVUlQdEx2WVJ1TDZab3FkYVRQNjlJbTJYMFJWWmpuc1d6RGlLT3FOOThJTXpZMTh2Q21zMG01cnBVZkhPWGxZZEVaYmtGYmNEVFphU25mMjZZN0lkelhUUCtHZFloOUROc295QWduMWlFbjVWdXk3UGFNcWJ6aHE4YmlySEo3RnFUb0RQZTJaU2JhODdNKzM1YXg3WldaV2gwZWpsenJBTzZBSm9jOGM5MlR6OU9XbWgvZVVwY2tlMnBsYW5hcmRnMFBaNlp5MGhyb3RicGFDKzhWRlFscm5aclFzRXpjbG9HNFFnRXg5TmRPeVZjc2lsMFQwMmQxK1lzUU1idC8xNlB6ZWxtc2dqOHYzK09BbE1LbDV4WWNaYlRTYTNYWC9uNEFQYlpabmpkL0pIbDRqaFlQY0NEZWxWR1NWbDdWMEZLSHRlNmcxRldWWGpGVTMzZlorWjJMakttbnM0cXl5L2dvK0hpOTVqNkEyVmJWVkwyZXNxM2xnSWlrUmxqakxlWFB3cXF4YWlxUVZFYkxuZkZhTEozWkNtOWhOVTFtNkxBc2JvY2o2aCtmbDNMNlNrSnAzbzRzTXdBNS82Z3BHRlVBQUsrSHBRQUFBSGF3T0FBQUFBQUFBTURSWUl2Q2szamJlR2IrQWdBQUFEeUhpRElMQUFBQUFBQUFBQUMvdjVqYThwc0lQM21XZmdudE9YektlbXFQNXRheC9pcmJjbUpENzRrVVM5QU9ydk4wdHNTbGJ2Z0VSZ1lQd04zUWpoWHJPSUNVVXpIYTFMNU1XQjRjdWwybk1yN283L0xrdHUvSFpUM0dDR0Eya2d6eDVyMHB0VE50OCtzUlBQbXQrblExbzVkTEs4NXdPcHJ0b3AzSWY3UHhwTjJ1dDZ6SzBqL015SG5uTGJXeGRtMHVLTStNRFFhZzR2R1pXVjFHVWJtZU12Vm1mNGdoTnNLc3g3WktkcTVXcm9YV21qY0tkdDJyOE01SGoxL2VxMjVwNzVWR1k3NVVxYnowYjRoeUt0Ymo5d2tyYUxJaEt2bGFhSjFwVlFobmJtcjArb1pHNUpjbXMxTm52QmFYeC9mS3lCbVRKTThubFhrelBMWk16ZWM1VW0rUHpyT0xON2JwY21iSTZESDVtanhhY1VPcEk0MW0rRXJLckZadVhyWTFYSk1oSHAyMHpDLzVTRFhkRlFDT0k1K0hVeFJub1h4di9wWXNzaG9HTFYzUUt1c0FwcU10L2xwNGF5Q1hlYVNGdUV4WEsxc0w3MVVZdkVaYXk5TDNHcUpHbzYxcXlDdFp3L2FDUXlyQ3R6S0tzbmZYb1o0dnRvUmZTM0NIUmo0dHZLWGs5UnFiMWpaWm42K0ZYc2ZyUTdEWVJ4cld4K2YxKzNqeUFDekd1NjJpNFJubVBWTkhqRXUyOEZBc1ExTDR0dnhJUHZHcU9pMHNuMHgzNkdhV0xWbExVLzROSDZ4U0k1SVFQNk9lc3E0ZVBOWlFxd3lMcW5STEdUbGpZQVNsakpHTjNYS3dKYVZPbzNuWXBQVHhJMWY2RVo1ditkdUMzVzhHRk4xR3JLNHd4WE5FOHp6d3VLRVAvWXVwQUFBQWNCeG9jUUFBQUsrQ3BSOEFBQUJXYzZxK2diSURBQUNzQlFBQUFBRFA0WlF2cGFKUUFnQUFBQUFBZklDWkJJdGdhRUVQdnp5bjIxck9vTHNpTXc0dGdBZWpuWkFNOEhTU1BSNWx3NERRbi9FcmJqdE5aSGNkZjlLcGowUmJlSkZqc0FybmlUdFBKRG12ZTh1WFRsSUxsWGh2MmMzS0FGWXdldlRmeGRCT2ttMmRBbWdOUDRORDIrSVZudWcyOEJLKzdZVGdPd2d6eng4YTRaWlRxKzhncjZZME11OXNiMTZwUEUrNEZnZXZ3enBQV3liWm1mTjNkaDFKaTdRSU5LMndYbnZvdzdHekVHdW5ycEpmMWp3elpXbHZHODRxNitGeVBMa2pHbVdsc2FMTXZ0SUJ1b3M0WXh6Y2JhNk5mSGJsTjU2UG45WENSK1MxMWRESHR3WndMM29kN2pNM0ExYjV3cXp2L3NUR05jQmxHRFZXZnVQZFROZnFQR3F5akdyS3huWjZmV20xVElmb3BpczlIcjFDY0tSTlZ4YThOMXdVanZRUGVIMUpySyt3a0JYdnBYano5dVkvZ2g1ZmtlVyttTlp3Q0RQMk5MRHpUSnloUnB6SmJLMDZmN2RndGhwMUtsZllXRFc5UkI1OGRXbWZUOWM0YW4vMDZVajdaWlBHWGZsVitGM2RSVGlQRTJieUszVFFNd2hudjRzOFl5SllYL2kvZ2tJZ2NvdEdYaFJyMzQxOE1oM2dxblRJamxpTWQ4ODdnTTZxSGtXczlIV1UwbVR4bHY1aUNZQlQ2VlhHWnF5L0oySDVjVWdhRE0vcmttU0JWZjRlMG5VSUlyRGkxWnR2cEVpVTA2RDJicGUzakR2UTlZaEdieFNaQXcrbUprUE9jQUtYNG5yWTdiSHlKa2FWb3BiQ3BaWFZxK1NOMENONDhWdGRIbTBvYVhpR3NiY05Wanc2Z1BlVjRMS0lKQ2xjWmNKYWNQeko2c25YWlpSNTZ5ampMY1puS05MMnZoVFprbXVXUmFIMkxDU1pLY1VIcFE0TG1vejBEUFRaaytvTUhYWkJuYVdQTXdwMXBqVGVCRFh2NVB1YnZqODRYYUdhZ0ZlUDBEcEFraG1oVWM5cVBja2lyM3ZsZDRsMjN6Vld0UVhnTGF5V0lUUExtZlVyQVUrWjNycExRNktsWDhQTG1PSHdXS0g4ekh3cjExcGZXZWJzU1RKcWhNNHdXa2FLS0F5QU1seThEaU9WZnYwN3VzRVFpbklzVG9ZcjFMbGFVTjk4VVJqeE5WamlRempmcmdPb0lPMUo5NzYvb3RGYUdUV1hvTllXYVdrcDgxaFdaNmxNNmY0OUxzK2doS05Xd3g5bXJCM2FKTkxxeE00YjVnNnVpQlhNdFA1UW93WllZVnBMOVlSZzI5TkFwaXpudCs3aStaR3FlYW5JMW9ab2ZJNDhidkRTOWNQVURVMUI3MDFycVhPR0cwYlR1eTZ4RUNabk9BQ0Fod0hsRlRGa1k3Y1hrOGRsZjlRY1ZlcjJHZzhCenNMend0V28wbmNoZW16dVdkdVV0ZkJwWFlRc2dWbFlIT0ZXdzFEYXNib0JYV3Q2T0o3UmZZaXVOczk4TVEvZ1lXeXlRdE1ybHVnQ0NrZnRlWHdqdlZYZ2RTNnViUFFSL3JvWnpsVGtKaGpvSFZyYjlQVElDRTNGUzQwRVNaSU56cnE3TS9Rb1RyUGYvTElZbjZPNy9PV0NwQzFRbnZlakxmWkNMelB0aDlrNjYxbksvcUl5dlYzZG8wZWs0UVRqV1llNjhJcGpZUHBEK0VMN1VWTVpQNk5PYTk2V2ZCcVZGUzNaMkpLWkFORFBhdnV1UjdtdGxUUEtVWGF2VmRlREZ6TEQ0YkZRR1hYSHIzVFV6Q3F2OVRNZVNkRTZROEVzU1VydzF4L1NLVkZkY21lV3NWWVQrcXZIVURLR2xlRXpuUkZiWE12QXYvR2lrRHJqTExmckhRYUhPOVRoelhqY2VEUFF6T0hXdFpvKzZYWG5iYWlWRVoxbHR2elJHZ05aNFEyY29ZWk8wYmNnWjdVcjRqZmFZenJqc2FaSmFSaUNneHhsb2tpS0JENmpTNUVVRTF3N3JDTi9ualVQQTQ4Wlp2RExZMkJyN3g1SWJyTVdwUzF1L3VXMm9WeEwvcEhKNUxuUFlYb2FLVGs2Y0lCODRuM3hoNzZEcHpGcEQ4TTZSWHFtMHEybW43S1FiZXRPelNHM2UyOW4yNmRKU3Zpc3hSTkFZNlkrY2xOVzY0M1JHRmZxejExZDNHb1UraUtNOEhCWm9kbkZXdHlWWGhrcGZZcDUzRkwxUWlxOHAxTGtGVHdJeSsrTmV2eFlNNXpJaDAwMXlWQ3l5b05XV1I2c1R0RGVzbytXVzFxZHlOTEQ2TkVqZXVxWU1meTEvYzdhM21SWmhwVFhXMmNlOGVla1dLR00xQ3JjR2o2YWRoVzlja2xyZXpTRVdmdFFVeWkxL0pZMDFrMm9HZkxheXNxNlJzdWUwTGJvTEVNYVVxYWxYUENGU25XWW1wUlZyaTJGK1I5cDVmUGM2SG01dVNmZlNGbVdlWjAvNEtxVFd5a2pLZW1ERUYvTDM2c285OGpRV3R5STBnNEFuM2lWMnBFWFZMWjhzUkcvQ3F2VDBQcENUbytNUkY3Qk1pek9pQkI4eW9BMmFheDF0c3F3NHEycnAreWF0YTMxUzVEanJRcDNyU210K0p3bDhuT21JbHdyMjdwNDFOb3dZMU9qOTdsNnNTaXJOMW9VZWtSSW1jWWFiL1Z6dE1vQWFEQXE1VXBWdGxaMk1JWmJPR0o0bDE4TGk1WDQzNmcvTEUyZjZVV1M3SGNHR01heTFIdlVFZWw2eEVjR2YraVJ4elhOTGxUSzZiV095dmdaaktqd2d4Yko4K2oxczJ0NEg0bzNqMWFXZEEybm81bjFXM3gxV0dUUHMvUTR0S3hFQUN2L2hJZVN3aHI1ZlJxZUc4cnplTUtoRHYwRmJ5RU54aytxNWcxWXhiTWsrbnVXQklETHdBQjJVVHFzYXQxbmxSMEFoOUZhd0dwSU8yV3RzbTdNRlJ3NWxqYmNvdXRiWXdmZ1lSdzV6QzM2eHlWSndkL2cxQkUrMmhsbmRPWkI5ajY4QTh0TFRwcU40cDZ1V2FXdmNIbS9aZU1YMmJNZSt2Z2J5MUo0SzcxbkJPeW5kV0NqQXN5ajU3MklPd3B3aisyYUd0ZFNlRTB1b1IvQVlWZzFNR3Q0Q1BVQkxzWDMxRzJOdHl6NlNmaS9seG1LeGFDUWpHVlpkK2ZNZTRqS3YwZldmWE42UkVpWnByWDV6bm9KQjNLbGJRZUcvMS9Pa05Md1lIcFYyeVBhQUIvTStKa0dYUTIzZzBGN0tkSU1wVERwanhWZEIxYnd5L1FUNTJnTGxxNDFkMTdyMmx1bkIrME1Na3Y3dzBENktZVXVxZlJsYkgybitZeDcvTm84SDdnTExXRllKTmtwSXNVNHQvN1FJZWhWUG1JS1dRK25TdG0vMzZld3BYcFpTUXdBdUNFM0hzY2pQa0xMN1c2eU1UclNXOHYrU0RqeURKQS9rQ09OcGRZaXI0VS9ZSXkxM2dXN3d1c1BVbmp2S3pKSlM1QVhybm00cE1iRW5zb0I3by8zd00xZ1RDK1ZjYnFOWnZWWGVocWozVmhlWG8vUDlJaU93VmY0Q3FTbHIvWjRaMjE2ZTRaT2Era3VwNUNyUFkwNWQ1a1Q2ejJHb0ZYbjdVM1RTdS9OdnlISlNNdkdpU1FUV3h0SGxwZEZhMlVFb1V5dG5Gb2J5ckJhK2pLK1ZyYldMMmNOWUcrOThlT2Y3MDN3cUtRdis2RzJlVjUrN1dJM3RveHRkZDFTMHFkdEVpLzIrWGFQTnhiaHJUazB1bmFQNkR5OU9rMXl0RVc2VDJrUks4T0RFQitVZExXNkxUcWZKYnlIbVdVQndEaEhyc090dWxvTFVNdjJsR1NuWmMyb3lWbExuUUNINDFXa3RRRmV5N3R5c1I4MTNtcmgwdHNVZy9lVC90T2YvMDhUTWlHU0NzTmhsNzVRbEljZXdRb2hyalZNVTFLVEVLNk41MWFZcE1TV2JaRHlXenI3WmNLL1poZjFPc3NCTHNacUZXOW1XUzF6UG8vL2NCRlZFcVdLRDZuOGF0aTNKQ3pFY2lyU2wxOVEvUjFmcGdtZlJleEFOTUFVU3RYVzQ4L3kxRkhXQlUxR1hRazlXOHdyc0c1cFNQbHFHckRtTG43ZEVMTU9FczlnOGc0ODc3NURiV0YrN1FPOER6djlwTnpMcStTeFdLV3RjQUF2dnhoTlB5VGxlalQ5RWs2cDlPWDBPcW9BcnN3MnJqVkR0d2J6WVFwNWw5T2xjR3RLNzRwWG9ib1JwZWc4b3E0VzA3c1NuUWRXVWNvSWo4eUE1WXc4QWg0ZndMT29xUUxMNTdsSHdlcHBUR3UzclBXaXNOYWVJd1hnZy9WcmtEbks3aGhsWkpQK3NranZpVDUxWDZYMjBpYU05Y09UeDB1TkM5N3ZqR2tycWhCdmU3NVh3cnVud1hNQ2VDZVd0N0swOEpHNjhyZ2VPVFJpbE5mcWZMb3VDemVsWjFMMnZzMDFZL0RYTmpWNk5qazhiV3I5T0xlM3pCNEtoZXYyc2dSaCtBcEdYc1RScHRUcUtRZlFRREtIcFZWSituR285VGNySzdtVWVzcDhoalB3N292Mm5JdUNIWGc0eVhsOVphekRoeUVHc0pCaURaQU8xQUE0azEvZmZ3MXMxbDNkenRiMklpMzVRemhaRVlqQzlaMjBrNnZTY3dTQWRWRHhmT0JPU0p1VFdycFV2L1NJcVZWN3dKZkEwUkhmWFY2a2pVcWZtMDdtQnppQzB0dmRraUVQR2FmVzA4TzA4SkxhWVZUV2JlM1d5V1hWaE1GUW1JYjM5QzE0TnBvZXZXR1JHUTlEbXlwYXVpdFFtOWJ1eDJlOTRkaVpEK0Rsekp3YWt2NnhkSW1QeG5pdGNrdTYxaHNiVjZPbjB6MC8wRUNtWG9yYTQ3WU0rWkY1T3FyU1crclIzdU9ieWJDY3N1cTBWNmRuODZibnhaYld0VFZkRXVKU0dCK0FsZ0VoR2ZCU3VqaFFkbDVIUzdIMkRtQ3pRNkJCNlhjcy9vamFPLzVmejB2NzhrU3FQVmV0dmNhM0tNdXZaZFN5QnEyS1Noa2Y2Zko0VFlmUXh0WVphN0Rta085NUZyWDdiRG00ckF1UGRGMytYYXRUU2djQTE4TnF1MWhsNXJBeU9LSHVVT1NiYVhPMlpLTldKeklSVHFkSEdkS0VSRSs2dk83V1JMZHNhcFRYcmJxOFNBWkROc0dqb3J6dUZPYlB5MTNTcGswU1A4c1Fvc1hyS1l3cTFKWkdhUUxXbWw1SzUyMlBwVXpOWUhveHJlbFpUckdjTTJ3MXVEWFdWYWlWUDRTK0xRMHB2TGNOTS9DWS8wbEpMLzM0UWxyNnBDK2twa2JuL3ZGWEJhUW5UTUtyQXM2MEYyc3dvTHZvMGVSSDE0SmFlYjExOThxejFBalQxS2ZYTVdydXpTeW5MTU5xdXBRTDhoYkdnejRHUVdob3Z4a1FnNVZueFdPRmxmeFNVMXhzMUhrWHlobk54ODhBQUsraVllakdNaDNZcVNpUTNpN1ViQVdBMHltOTNUVmVNR0JuNko4akd3ZEp1UVk0bkcxQVJ5Vjh0b2YySmx6RjVQYnNpZlRtQllEN2NMbDUzYk5HcE00MHRicXVvTnYyMUpVRzR3R0N6Ujd4dkN4MUZBenZ5VWc2L1JGMXJOZ0FYMzB2SXp6RkxsTDYrUHZIcVN1cVRzRjFTdlJVTmVOS3orL010cHhwNS9QU0RNQXpXV0VQbmxGM3pSZmFJNmUwTmgyaHV3RjBzOExCWVUwMzQyMWg3NmFHTjE2YnVCNEZ5MXAzRk9KaS9mcjJzdVZJQWVtdDY2VWJaV2RCVjhOa1JvZFU3NWFHSlYxTDRsK0ZNOVZYdmpZRzAra1ZDSlk5U20xQ001NVA1VTNxQlVOdElsZjA0V0NhSE1OQmZUekRIUW1nMGY1aHF2RlgwOTdUZWxaUXRxRm53dHhhaHJZZUFvdUREOCtiVnZRdFBJM0dyNkRFcVZISUg4dWE4RnFjTWlOYUZ6YzZHNjZFTk01ZkloeWljdDJyUDdjTVFxa09ONVlUc0x3Z24yRERPb0J2ckYrWFpvSUZiZjZlSVRyamhMWU1QMGFyTUFWNEtaS1pNR3RxZU1vNVZFNXBzbUZqaHFEeUNySVZ6bEZrMzZ2bzhXbVhyNGZPR2lLMTRheTlXNS9uSFRFSEQ5VTMzb0puVUIxVlZtdkFlMSttR1ZHb3BiUmJYRExXS2RWbDJiT3gxcUdsYTkyTFZMY1ZZOThuU3grWFJRaGxpRit4S09NYmZaNktzSS9icmhodnNZeEw3VGFYYmZ0b2l0YkgxbkZxblhNVy9VTjc1bDdGc2lYc3BmQmtUQmM2NDN2VEFzQzFPY0kybTZWWWVtUm9MUEpvWldrYkRhMHlBQjVGeStxMEtDZ3pKN3QwWFlZbkpWOU42WTF5a1NuTEc3L1NKNHRRS0tvd0pVaGh0MXNaclVwYnFoYzVSVGJOZUk0MTVkdnFqUWpCMXdhdk11NVZ5cTBLdDRlcEQyd01yVHQ2SG9uM2NmZkdBMHlrVjJXVnBzZy9SZmlNNGV4ZGRUdGNTZUloWjVLUFNmclNxcFFQWUNtajY0OTFUUVF6WGpYQzR2SnY1VTJHc25vZW8rWUM3cjIvbWx5L2tKWjREdVdEbkRGNHBMSXNneXJQWjlXWHZYNTJIdncxS1ByZXFzTjR0bUlCUnZubis2K2JqckxhWW1weE53Wmp2c01wYjBpNzFzSkR1TWlOUFFodG93amd6bGpHdDFVdXdUQ3ArRC9BcldFZ2R5R0o1YVZxQ0RvT3dCQ0h6dGNENkJIZmlIdUFlK09SVzdkVjhWbyt0S3ZjRkFZaE9EaFQzNGpDdjcvcDBTR3NMbTZtQlp6Q3pNbDJ4c1M5d2p2Rks5dmdmUW1rb3kzaUZsM3FsRXNyK3VQS1JpZytKd0NRbVBXZXc1bU9MRS9kS2JSdFB1OWVMSFlqdkFiTFc3bGxlc3ZrbUdHTmVnV0FoTFREY0tBaUZTVkwvNmcySU5DdXdVV1U5NUUxc0NmY3MvNENIRWp2bGdiRDJBZXZCY05TbUl5WHcvdHpqQjYxdzF2M2xhajlUakwvRng3S0JVeFNDUFdEVzcyQ0NlQmdQcitZS2gxYjB6aU1yWFl0alhzcHI4WGxwalRGWEZZeWhMZnU0NUc4N29ZbjBEcVZKalhTMGNkd0I2emp1N05ZcG9ITWJtMFU5cmxpTFVPZTNMS3dhdWtBWmpHcWFEMU1lRVFsUEhYazBlcnFmakhTWXJpaTZ3QjhFNDF4bG1seWh1aXoydmVlYVc5V0g1MitDREg4cXAwTGNCQTlVNlBsSzZ2bDc5RmxEbWZFZVNpVmxaVDRFWHB0TkV1bkQ5cnhjQnpXSmM5ajd2YysrcDU4TlQwaVplVkplNWJXcVdWZDRrZmEvcmlwb2lseGxuemVQTkY0YlMxdnkyTnBrM1MvVXQyMU9yeDlwZzFncVI5cWFVTm5HNlEyU2NwOUVOcGcyZE9RSnZJV0xJVG5tK2Q1bW1hVnhnbFo3VnBoZ3pLVm1ZeUNOeGIzMzJ4YjdmbHB6ejBZeXV0OEpsV3M0MW9UeExWNHJ4MW5kV3dCQVB6R2FwdFoxbDlMWFRQMk5DUThOcHpWUVFjd2pHZWdyM0kyekdqRExLdXpiRXNLc3FWYjVsK2g5R3pLYUJHc2RwVlNkaFRLemVPKzQ2MDdDS21yS2Z2OEtlaDk2ZDNFYk9XcktiTTFJMDBiSzJXNFJoTCticFZsTmZ3c2hyQTFyeFhOS0RpQjJsQXFXU1hXQUFvMGlXRU50OVFSaXJ4ZUNicmw4YXkycWxSV2ZDczk5NnRSK3Fzc0I2WmRTSUxCblpnNXlXcnBXdGR3S2pXdHF0Y1YwWXZGZGR2SzEzS3BsS3FVMVFxNkpETVdtcnlUVm05S2F2c04xdjBEangxcDllMURuUWxqN0xldWtuLzVmZFpocjdlYnIzQkxmcWtwSGpiNmFtdUJSK2FleHNwRzRWd0JnQnJJaGlYa2ltT0p4U2UrcGZzb013QmNqRmxlbHhCZUk0dXM4MThyWXlvanp3MEFSTzQ2dFRUZlpTc1BBRndmeVJGdG5jZVhtTytXZDdlOERVMkQ4YjFwQVI1R2p4N2hTZWROT3lQZlk5bVUxU3M0bS9JZjNSMzlvTjdxYkZ0NDMvRktZNnFCOWk3SExaazVyNlZ5cmlRN0FPQ2RlRjc0OE5wNXN4VE5uZzFBS1I1NUM5TzVncll6WWdFZU5iRTNQSk5RbTdnakU5djZpdmtnaDlwa0tKYkg4YksrYm8xam5FTndFR2xTK0VoZEFMQ0ltWlBPNnFCRVhib0VWa3Zqem5JWjdmd0NIUEVBZU1qalRKcm9yZDhZZEpjWm1NdXdudllQVTQyanIrZTBCYXNielB1U2l2VXN1ZVFJYjVVVFFwOGNFZXVLemtwcThiMC9CaG01b1RkUzYrUFovbXlBcytpUkdZSU1pWVlpS3RrZVRlMUZyTzlUVHZKNDV3YTBLUnR5Q1k0aUt0ZGwrSTNIWnFrU2VQS1VwNHpOYUlPR3E4dHJlbVZ2eFFBOWFDZTdsZUUzUVZLajdpb1NwK3QwWG1GYTVoMTUrUkRnUmtpeUpBamhrbit1NXNyUVZBQnJteTdGNks5dnoySmxwM3Fkb1hBNk5mdEJHODdXSVhURy9NVzhXTWpJenFKWDZHOUlDNC9WUDlCYWVMUXl0WHhCeUM5TnBqSzlwMDNhZld0MTF1cVg3c05hVHBsdnk1TU1kU2poNWVaNDdlc1gwZGkzNnBjenBQaWk3ei9TT2ZxNnVXZFhsUDJkcmNmMmtOcmZPODR0ekp6WEtjZy9UZ1VBcURGVDZiT3V2eGFEV0h1bm9wVzNCMGwrdHVwZTFSYUFRd2VWWjJLMnlyQk01RnE4dHk0cnZVNlZXVXBUUmVHVzlNeWdLTnBOdnU1elp6K01QRTlMblRXOE95ckpXSDR5NVBHaUdWUmxleXlHUlhuZlVyd1dYdFk5Z3RhMkNWajFDTXRRN0xYN0FRNm1OcHkxNFN1Rmp3empYb2s0YzJVb2Y1Z2gvVkFqQ1g0Yk03TTZEV0FVYkw2cDlHcnN0WEpDYUZzMG1vdEJLMnNtMW52VzVIWFBsc2FsR1RDSHhMSThuYWpWSTZXejdpTkpaVm5OSzdnVVViQk5ka1BGOGZ4NDFMQ2FmOExEU01YL3BUZ3BiMDlkUFN6Vkg1TnkzY3FIWW1zbkN2OENQSUdaTDcyQW15UFhJd0FZNTJoVlFOTnByZmtCTG90bE1qR1FMd1Y3ZFFEM1JucmZKZzkvdEd2cGJNRmxjVmdtUjNpWlppUWVMa3Z2NzR1T1pFU2xROVY3S1ZiaitzaUJ2YUl1YjVrejJ4Q1ZmeC9DNkl1VGg0SUJCUUJ2WUlaeUo3MEU0cjNXNnFqVk9SUHJDNGJTL1FKTTQ4aTNuVVltWnA2bnhLTE1qazRpYXgwOVNQMmlPWW5LdGgzSVkzUlg2YzN0SStxU3dEQVFzVTVqNjlRcG9ldmhnbGlIdmFSRzNwVlQyODc3djNBR1Z2c1F1am5LRlJFTTExb2RkOER5VGdGMGd1OEhBQjVBKzR1cHpsL0RSMmVhMmlrS1h0bHFPUWpBZTNaZWIxdVcwbk9xUWd5NmM0WEZiSXlvWE5PL2NHYzZmNXk2V3pvYThzdTV6RnhUUHEvZzZ3Yk5KL0NYSGRtU1JjaCtnQ1hNZXE5VWszTTFSNWFtamt5WG5aYk5PK1FNakxMcUJmQVR4MmJ0bFJIdG9EcnJ3WFVyYjhzcXIzSjVkRWwxUStvczVCWThBSXR2ckpXM3BVOXMvLzVIU0ZlbVAxSStpWTBJSFpYM3ZzSGhxVE1hMDYzQUs1aG5QTURaaThITDVYVk5WOWk2MktwSGFQTjBaSW5VL096QldQYU1PbXZwckdYQ0lGWmwxbE9HTmQ3clhKVHdLTzJhWTFNYTROdmZTVW5UWW1SZ1c1K1RzUTdwU3hUNVYwdXRYNjFJbGJ4NVc1TFc1M0ZmVmg2VlVqM3RSenBOT0VycEN5d2ZvL3J6bFk5V0F1MStwZlE5ZWFSeFBXTmVBd0QwTU51ZVdGV21WbDhJZGp2UlU2WTFIQjZNMXlMYU9Ib1NySEpHdEpTVWtVbG50V3hyeXVLQ2lmanhXVGpKRXg4cXpTN0QwMGV3bWZUOUg5MCtLdXYrTEtRU2IvRllOaHNXeHZxOHB2ajJlQmxxTzdkbHV2eVphV1czeHBUbUFkS1UrU0NVWnlsTDRvUUZTQnRDVXJ6RnVRMHdHZXZLNWxrQnBieGwva0YzVDdOc0xhLzRyb3VoMHR3M2xQdVVwREkwdjVRTFpBRjQ2Rkd6ZTFWNExSeFVlalc5R1hWNXJhSVo5S3BMb1FpM2FKV1BHcFk5QTBEeXJ3ZmgybEpXM3A0VS9JcUV0YzZXSEVQZTJJZ2YvOGk2VG1WOFNGK0JiMlJwcGl2UjVuY3JMMEF2ai90aUtnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ3NvZjNGVk9OUG9iM25ZOVZPZzVoMUlrVHRGK0xlczlLOGJXbjlLbjM2YVJmYTRXVGF3V2c1UngvRGNWZTBFeTBzekRoS0JlQnFDT001S3VOOVpEbzhhZ3ExVGpzUk9razdjTlJ5dWh4eUNFN0hleXJUMmNlSURlSlZJN3luSEtXT09pUjFNbGt5YUNjN3RmSUN6T0RHaWtUclhIWHZDV2F0K05XaTBuSk91WlZoRWFISm5oekxjWEFBTjBWYTB5MXpyRFUxTEtjbHpqajhjeG1hejZ4RSsxQkRMYTFIOFdycFVVbkpPMHBTNnJMV0tjVnJEdG1aOS9CU05QOTZEYThlNFRsUXR6d3QzL3A0TEVOSHcrcmp0OVlabGZUd0VMejdLVFcwdEpweUh4eGxTMmhIbFhzbW1YWjB1N2JYcE54dktrNSszbFVmZjlLVlgxUk5VcDFCcWJzc3ArZFpsSFhYTDNla3hscGV5c3pkMzhKejNaMnk3ZDJNdGVEVmx3QUFmdE9yVUxYc25qSmVzeWMwMjhSUzVtekZ6eU5EcGZ0R0RvTVppME5DYzBiVXl1bXgwaVNzSGlwTG5aSVZxazBteld0V3krc2hEcVRSMmhRS0pkTmkvVWNsYWFxbjA1cTR5eCtDL0NrNnJ6ZGlxeWdwYWF4bGViSE1KUStlT1JTTllkcGNzaHFHTlVlbFpXNjEydEpCYTIyM09MSm4yTU1BaTlDa21iYk4wRHV6UE9xa1owcTR0elF5WDg4b3BhOG9EOXZhVUV0ZnRnVmdHYjBxUkcxOVlyd3V4MnFKV0xVdXpiMmhhVjIxNnhsWTNSMjl3L2Z4dzlhcXdyZE16MTU2eklqa3lGTkRHOGdnVXp5RDczbGU2a0lObWQ4N1Q2MTZvOVhNQjVnSlgwd0ZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlA3TDZhdStDVy9VSFR0WkFicE1JRmFHUzBzSnpaWTAvYTJvU3hqVWpmK0ZKaFhJS1ZKald1d29SMXo0dW5UeVhNSzREQmFndGw0M0pyMWNNUFhUQS9oMVAzOEt3SE9JdXlKa1VGd0p1WlRkeXRwTk1YeGdzeFkra2VucjlhMTVqSXRRcWU3Y0FBajBoaTdxWjVkMnNYV2c1NWJyTzRDbytwbjRwVEgxWE84SmNERmljN3JEZTlwcUQwSGRONkNIdCtadFZNdGZqdnR1TXM4ZlMzZWVqeHZxdzNXTXEvMFlGOHV0NlhUbHErc1EvekdjMGg0QzY5THZMY3NlQkF1SjlvSmRaVHl0N2NPYmEzUTBzZk9OSlU2eXk5VDdKYmJ4a1RkeVFTaHp0eWZtZ2VJTGlWSmVPYi9PdG1kaEIzcWRUUzNsOG9ibGs3VjlqYXFKeThBUUE4alBoYk43dW10czBmK1dSVko2MHNrbG5WVkNnTVladlRiR3lOb3pwV2V6N3RZM2pTdzVOY0VsUFE1azlMeTduMXJiSVJHblR2bHUxREtkOWZmR2ZXeWQvVkl6cVRPTWwxcFo3Mmc1ZkdlZU5xV3A3Y2FZY0ZRdDlXYllpMTdwRzBURmkxTi9FUmp1bENrdDNSVHI5NEJVQ0JKSSt2cU11aUtFTXR2MVRtcm50cFUydGg5dGJTTUw4SjNVekxxNWY1TzgrZTl1cUxRbVY5ckJmaERqOXFZSTZtVGVkNVdldWhpdGFiZTh2R200anFQOTJDUjM3M3JrSlRldW1ZOGZtaldPbUwyWHJsbkQxNGFWTnJBdFE1c1pFMC95UmhjMDFPRXZOODZUcEhuTzE2b1E5V3ZBc0J4WFBLTHFVd0NBQUI0TFN5Q0FBQUFyNEtsSHdBQUFGYUJuZ0VBQUFBQUFBQUFjem5UMjRDbkF3QUFBQUFBQUFEZ2F1eS9tTm82TWRoSTY5Zlh4c09VM2FmMmVBOGd5Y090WndWcWh3dFl5cGlHNWRDNTFzL2lwemZvQmRTT2NXb2RNZUk1a2dUZ1RoUkNVVHFobzB6ZTRwWGJCOUlSU3ZtbDhYQlRWMzFmQjVsV3YwelFhaFB5QzFZakhRODU0NURhQzFCVEkxcnB0SU94YXRQWG9oN1d3b2VtdWFRb1cyKzRCcm9xV1BDZTdIYWhNVld6VGEyMzQ1VWRaMkN4bTVlMVZ6dDV0R1hEVFJHS0FOZGtkSGkzNW05NUxha0dsNTVTbWg3ekcrc1JzYk1kbXJVMFd1ZldmTHNTMmttcnRUSnIxNVlqZ21melVqbGR6a2VMUDBWVHI2MUR6RE8wZXJIY2o0Wm1TMGxUbnFVZkRxZTEzekJqTXN3c3A0WGt6eW5pWXhHMysxaVRvYWd5M1U5aG4rblYrUnoxS09sazY1My9Wc2lmKzg2VElJaDI4dFdpazFnNDRya0R3RHZvL1FSSE1sN1g2dENVTjZtdTFuc1J3VkNIUjhtVjdzdGlKd0hjaGhGTHlickQxZVAxbmlVMHRQU2hVa2NwTERRSGtsSzJxQVJxR1lLdUtFZmxwWU95SDhwUDBlM0t6ZU9EUXE4dzNjS1NFRjZHZWJDT05RM1BwclYxckxYR2R5dHRmdDI3QUFkRFhlcGdxMGZQRUNIU2JVanBwWFpZL0piWVVLOWloZ3UvTmNNOSt5bldtV2hKcTYyUXRmVEJrZDZEOU1IdW1PcDFSZUdoSktYOFdnS21NMHhIbTdoZVZhNW1lN0llVGFPbDdiWGs4NGhWMFhxY3RjZXQxZUdwVTlNZVF5VnZxK3pYRHNHV2NsQWJQTkxEQ0kxdzYwT280WDNnUE5qalVmcTQ5cDUvTk9hUjlLcGQrcUlwTTNVN0FDdnlGMU1SUkFCak1JY0E0RzRndHdBQUFPREpvT3NBQU1CTFlRa0VBQUFBQUFBQUFCZ0I3d29BWEp2WFNTbkVNZ0FBQUFEQVpZai8rci8vTnYwbyt0Zi9DVzYwVTN0YWh3ajBuT2Zsd1hPaTBDMStOVzQ5QmNIVDZXQ2oxYWQ1ZUFqMExUd0w0OG1FMnFFd0xSNDlwVFI1bk9wSmEreStySnI5WVQwb0IrQTBlZ2JvZ3diMml0T0tSazczSEs0TW5RZG0wNnRJakp4b2QyR3VQT1dzWFYzTE0vMCtMQWIvNkdIaXlEbTRFWnJwVnFhYldlZXQ2UEh2ZU5ZbnpUbHF6VGVqYzZVajNGdnB2RzN3MUlGLzhsQm1ycis5dzFwTEt5Mi9sbklZVWdEM3hySXNIV2tYV2N1VzVKWERCUXdBOEJ3MEIxQVo3aWx6eFBudEZjUldlMGl6RTRQUUZvRFhZZlVPejNKR3RQSlk2NnlWNDdGT0xXWEd6K1NwSW1SK3Z3eVFzdTh0eFVMai9DNnErSlJLMllhZGJPejRiTXRIWVZlenZsZTB3ZmtjMWZpZWNheVY1VjFVVmk1SXZXMnE0Sm1XZVhydDlsaVBZU0s5NnVUZDhQb3Z1dFhvY2huTHkybzVXd0N1d09qeURFdVJSSWcxbnplUFpjL0tVMTVQRzRJaG4xWHJoT0JmREk5b0F3L29PbWhtZlo0MEZycU84VG1PV3FZQVIvQlB1QkJNQmdBQUtIbnQyc0NpQ0FBQUFBQUFBQUFBQUM4Q2x5Z0FBQUFBd0YxQWV3Y0FBQUFBdURKbzdBQUFjQlMvd2tKR0ZqVFA2Y08xOEZyZE1kVFBEMHVWZUE4OUoxSk14M0xVMEl3REJxR05OcGpvZTNneXlzR2JMYVFwWXpuazhIWVVwOWFVaDV0K1hCZFphNmZEZlZ4Yk9zaDZaQjl5Q1ZialBWVThOZkxla0NSY3J6aklQUm5EelhXMEVxSnZ3bXlpTXp3Vi81WjVVcEFuNEFXWk9hVjY3VjBON1VDK211MHRsVEZORFpucGpMQW9xUnJvVjNBeW51OGMvS1lsUXIxMTNtcllSK1c2aHZiaGpUeGRUYWg3Qkx4V2w4Y090RDZZa1RyeisvWG85aU4xd2plV2I1Wll1N0xWOWIxK2Rja2NiTld0bFg5RFZROEFCTHh5UzVNcFBicU5kZG5SYkxab3lHdXRlNGJyRndCZXhFcjlXU3ZiRTI2MXU2ejdDVWtJbDhyZDBsaHNtMkJzUXl2L2lNOEtZQ2xIR3QyZUhiS1MxdWZTYXM0WGJkSlpKM0tKTkxFOWs3eEkyL3BTYWlvRVZsTGFxMzF5cGZyNXVmQlpoNHIwSEtYbjJkUFhSMmkzdFhaWW5HamxHRXRLdkFlcjEwVEs1K2xyNzlqWGlMWWtQVU9zVm80bjNCb1BqMGVUVGg1YU15Z0YrM3NhSTJqdmtsanZ6OU1Qc1JKUSt6S1lLRUdMeXFJU1h4YUllZzBxUFJPN2R5UFVVemNEOWpSR3RTc3RYMDE3SExVU1N1MjZUQ1BKd2hUOGZtY3AzZTNSMUdLdG8vSjByYlF6VEJacjIyWXcyd1I0QTFiZjRWZWZxbDlCN1RDYmV2YUxBSTdtVWw5TUJYZ1VMTm9BMEFPeUF3RHVCbklMQUFEZ0ZiRGtBd0FBQUFBQUFBQUFBQUFBWEpjejluSWlHMGdBQVBCV1dBTmhFUXd0dUJ0THZwamFPbEhJZWdxRWRsS1E5QXZ2ZnhyeHZiOEs3MjNMbHViVVg2TjdUMjRJZ1ovUGU2bjFtL2VFMkRnWUQ3Q2FtaURmSFZuV3pob25uT3J5aUNsUTlFUFpMN0dXWnZ1alBDM3U2NC9rT1NKSjYwVGtEQnlGSmhPMFE0MXZQbGFsMitrNUlGYWE1bHJYdGRTTFpqdWlNY3hjb01McENqVmNFdXVoMjdVOE4yYmtjTTlWdDI4NUZUS0d0bi9BSXdPbm9aMWl1akhEQVlBTWc0c2grZWxhNW9SMEF1Ti9oUERIbzhrS0xYMlpiMHVqeVpoYVhvdGNTc1YxSzMwSSt2MTRaS01VNzlYeHZLZlpqdFQxVUt6dXg1SWVWNE4zT0V0MWxqWk5jclJCbzBldkFvQmo4UjVnbm96cDg3alc2Zkt0c3FNU0w5Vlhxek1QTDlzV2d1OGtiR1Fhd0F2cEVZS3o2eXJqTFcydzJpcFJ1UzdyOGppYmFtMndZRzJUTlI1ZXpKRldpWFZUVHNvM3VzbmpxYU0xMGIzT0FTMjlwWnd2NzNhK3FTOTJSeFlSaTdmWHRLK2Mxc0pUZnM5Wld6Nnl0TnBWMUJuemNpdHRyQmRpeEhwZkZxRzRlbGNqeDdLbzFTd0d5M2dOSFdVbklkMk02MWJaQnpLcVIxZ2ZBYndXcTgwZGhHdHZYY0ZSbm5VbDhFZ1E3WDYwK3pQNUluNHZnMmxmWjdtczdNb3VialNsZXZwb0ZWZHhId1JRcFdkaWo2b2RsazJOOHByQlBBMUo5a3ZwbWpJditMV3FXcnpWL3h3YVpkZmEwSkw5VWx1czNGNjkwallPdll0aXEyeXRUSzhackpXWHgza2ZrQ1Nmd0k1empaQjBuWjMxbDdMSFU0eXhKT2c5bzhzVndFcjRZaW9BQUFBQXdNM0Jad0FBQUFDclFNOEFnQjZRSFFCd0Y1QlhBQUFBQUFBZ2c4VUFBQUFBQVBma2Rab3NxanNBd0duRWYvM2ZmNXQrUFAzci80VERhSjFhMUVxajBUb1ZJeG5xOG9iZmpwSFRJTjZJTkdoYUI5cEowTGR3Rnl6Q3Nvai9QbkF6Mkl2VzZEa3QvdXA4ZEsxMExKTnk0OTk5WFo2d29pMnNsZmhZbEFsd0dqT09xTHpnT0xib2tWWTFvcmR1RDhOdHNRaHNyWkpWSFFMUHduTU1valg4UW5qMXBTdmRUcS9zNmMwN3pFeURIM3NQTG9KbldJL0tFTTJFZVN5ZUcxZHNzbW82U3gzV3VsY29uajBueVhyS09KdWJEMmhyczYydWlDM080eXJxWmNieXkzSU1jRjltenVNcm0zM2UrMFN1QVVBVGo1Qm8rY3BDcFJ5djB0ZmpDOWJLc0g1NVFzSmpnd1doYm9CTHNFcTc2ZEUwTEpzOGVabmVpZHdTUkZJNVVwMFNyYlpaaEtMV3hsclJoamZTZm0vY2YzdzlkZnQwU3ZsSmxlSmxnU2tjNmRBNVUxdWY3UndyYVMyQzNnWFgrM3dIeHVzTXZIdHltcWhnSFliRmVOVm9pWU5tMkVjZG1rb2Z3aHdmaTdyaUY0V25JdHoxeFZTcFVtUUQ1TXhRUTNyTDdGbjZ0Ynp3aDVGdDBEenRhbGZFN01kb0VZbXo2M2dOUnpqZVY4cWpYbGdyKzJtWmJqbUNiaU8rejE4VWxldEdYbk9leHdwWDRwSmZUR1dTd0tOZ1FBUEExVUZPQWNCZFFGNEJBQUFBQUFBQUFBQUFBQUFBQkRiT0FBQmdneFVCQUFBQUFBRE80bGU0R0drd3ZqZnY5cVAyYUV4ZksvZnl4bDN2RGZhbWZ6cTFRWk9IaCtBZlJBQlhwM1pzME1ENG5UMzA3enlWZGlLbHNxaVVYNThWejArMWRJU1NoaStsd3VHc1VLaHVQbzZ2MVB4a1RiQlNJVVl1UVkyWlkrK0JZOHg3NHVOc1J1cyt0TzFuT1NNQUxrcnZzSjFvTHQ2YkNUYlpMcDExcmJ0Q3A0LzREcTQ4YUY0Nm9DMEhCM3Rkb2FOMTlwVEJjZ3h3Zjk0eWo5bFdBb0FwV0lXRXhjNlFGS3NSRzJYMFBRV3JINmQ4TjJMRi9nTy9BSUJUV2FVUjlKUzdhdWRmK3pwcXpQNGRkVWEwUG05aitjeFZ5eU5mZkRiT0pUeFNWblNXTDZVK0dlVDZzbXB1OFZ1L0RYaEhqcHhMeVpDMlo0R096dmpTbzdOb1FidlZSaEhBUERYNjdEM2FEZkc5c2pCZXBoaGZ2TnRtTGxCYTBzdndtamlEZDdOaXNvM2FyQnZhdUFhUksrd1RhZmw1akRmamlJVjVaUjBMVlhZd1loUUM1YnYzcW1YR2M0V0hjTGtmcHBaWWpMamZlR1M1WlBqRlJ2cFJUamMyUzE4U2pwczVhSVBHNHI4R3VCdFd3YnhkQ3Q0dGp4eCt5OVFSZjVScWxDbGJYemQvVk1vYUFIZGpwb2Y4UWxoVmlDM3M5cmVOTGdSSDBTTXpySlBzUXVQWTB4VHQ5bGFKMlRQcW5FbzBwdkU2STBKQUZzSnBqQXhyNy9EdDlkZUZTcjViNjBJZWdXYzFpRDJLWkI3WDA0a2ovaTNwZ2RiU3pSaDBXbG5JM20rc1hidEMzNWp4R0xSWGtudnI3aG51REMyQVk5RG1ZMnU1WFNXZmpsVHRNU01BWUFqTlR0Q1lZVWRvNFZJWnMreUVQTDMwSWp0Q0ZtQUJzNXdSdFltYms4ZExtcUZGNEFWaHMxMjVqMTJlK1BHUGJvd1diZHVseis2dmx2Ymo5bXNDcmxxb0UrdXpPQXFQdyswdWRaWmp6dElHSzFHSlcvQjhWeGd4VnhoNjhHaG11Nk5YY1VYVlZaU1EyL0lsTkRqMjJDclJtQTVBd3JwM1ZVdHZ6VlBMSjRYQlZFYTNDYTN1akZtL0thblY1UzNENGpwaDZDMmc3UHplbHlsQ0pWL3R3WTZvN0F5QVpYdy85dElOOFBXOHZ0MEZsVHkxc3J4NktNRFZ1UHdQVXpkbUdsVEpHZC96N3BWVzV1RnNFaXNXMTNBTTlEVzhrWTV4WCtyTnFaSHUxUlFkNFBxNktmSUk3c1pMeDJ5NURkakQ3Ym9PK1FRamVJeTJwRnhiODkwRXIvMDdpNWJKZWF1dXRQeUs1ZUZqQ0o2UFJlL29mZWQzUnA1SFRaMFpiNnBJdTRnamE1KzE4MWNzS2pNZlBFNkVxYVJKYVdhbld5V1BlbFJFaGhiQXRaQmVHR3FsdVlQUEJWa0RBRU9NS0RXOSt2OE12WHkyOE5NTTMvSmRDZ0NZd0N4blJDdXROMTdaUUVnZGRTZmh2cEltVUlvMmxUOXN6UVZUNnlXS2FHamJzR3c3U2tqTzlqTE14TnUySG1mZldTeDR2aU8zTkRvTVdNdWhrN3U0bzJlcjdrdTVaS1BnOVJ6bERPeFJDY0NFWnp2VWtxY24zUXkwdG80TUhhdTVBQUl6bFFKdmV1MVhpenpRWTNHNkE1SVVIei9EYWw5SUhaVS9MRHR3Qlc3enc5U05HYWRFdEVnSDFuVTRuUDU1UEk4YlJBQVZKbWd5dnhXdFRRbmI5R2VtVFQrN3cxSmJtK3o1OVVlbUFIQXNIbG1pL1lMOUlVSmsxVzFZVDNqcktuUWx5Q21vWVJtNHJSYzJlc2JSaVRwK0ZLN1AyUGkwb0lucjN2S1czRmMweHFkR1hBbHlDbTdFckpOaWd4TC9ZTlh0TDNGU0drOTY3ZGhiejlyWGU1cXJkZkFjcWR6Q2pxaGN6MXlyUjh0YzJUYmo2OGdBY0VHc1MrZ01GNFZYeFo5MXduMWVobGFtMVJ4K3ZQNEY4RFNPbnFCMzhZMVo3U0l0amRXSGFJbWZzZURBUzFnNXNWYzV1YTNPME9RSW42bEpqWHF5cEhTR05NMnFEVUxtdTBrdHIvNldOb2FQSDlWcisvdlZzbjd6eitkMTlHN0tabTI2SkZlMjhHdHRteTBUb2pOOE5PMUI0TGlCU2JUczRoRDAxZWxJZXJZYlJ6VUJTeDI3dkRFMFA2QVFsYzZOMnA0R3dKRklLcXdsZlN1ODFPSGdsc3h3QTV5cDBqRDBKckJLZGRkZXRtamxoWGw0bjY5eFFuOS9LVFVWMmRMUHY5SDVQSG44Y0FkdTk4UFUxYlJrak9lZHJNT1ZDQXcxQUxnWmQ5akN1Q3VKam9VN0liMXRGdzE1ZXVOZnpxaXVDM0FMSkVWamhnTENaRG1OVTdzZS9RcGV3RXAvVnVxTWd3NUdPdHY3TUR6cHp4aGNBQmxKdVFhQTUzQ0c2bjVWY3dFZkVNQU51Y01FUGFPTjFuY2hlbDdzMDRRNDcySEFNQ3NuVFcvWkl3NkNOQ25jR2o4cnp3aWVJMUtjYmZ1V1FjTG1SUms4NVNVTEJCdGNoRk5lc0lTM01ibzZsYjlaZTd2a25Mb2NiZEN4Y0NhOSsyTDh3UHFWOUxnY3pvSWhlVE9rdFpBSHVaYVY3MFpVMkE3M2lEeFhlQ2lYLzJGcU1sNzNuQmdrNFozdjBscHdpdThFUSsxYVNBTlVNbEFBbm9SaDNHdXlPMzRKVTgybWY4c1VpcFY5cUQra2ozOHFGeFcwQmJhc0JEa0ZaeUhKa29jakhYaGNDOWVtYnhEU0hkcTF2WTNjMHFTQUhJSTJIZ2VkOXhUTG02MkY1WlM1OHI2K2RoamdLWStnMVppeVU5bG9ncHRUMHl0aWFPc2JTUW1YOG1uaDRFQmJ4MXI2bERXOGxpN0g4d0JiZGJmS3N5cTd5VkNYTlQ1UEY4SnJCbXFQejBYcXl0RXU4eXlwMW1GdGZadzk5d3NBNXlDcDRUWFZmVlpkTTlONi9UbWFiRVMvQW5ncDNwY2p6aEFXUFhWcWRzSk1jaVdQZHl6Z0Z0eHQxZGNjQWxZckxSalQxL0k0MDMwM3pTRVFkc1owRks0Ynp1UzBwWXVoK2drNnI0SVlpcnFIeHN5SU5XMmxac2w3eHM3TU52WTZyRHgxMVBLbVNyeTJhYVcxcFZYdmhSWTlhNWRidytIMWFCSmt3N3NIZWFUYXVOSVhvZVdUM082MXpPVXk4OTJuVnJIVWN1UklUbDZBRml1ZC9IZFR4VitPOTNIM1dCNWJ1bG5pU2R0N2wrcXZsU0dsZTYwb0hka29ySFZlYmQyeVlua2ZxWXlEdy9uekE5THR3dkdzTFQ4NGpRMTNSTS8rZHBrZTRFejRZdW9pVHRNL0xaTGxDQXNaQUVEemx4ZFVEVUtNZVFESVFTWU0rMHB6THRtZE0yOFFZS08xYVdVWmN3OFlrM2ViV3Q3WFNrNEYyeHB1ekNZYmVrUmpMeXp6SjVHYzRkNXlOR3FEYW5UOTdmbFZwR2NuR1VTdXZ2VDE2aEdwTXc0QTRHeVFVUUF2eC9wMllZLytQRXBQK2IwNnZSYmVlaG1lZHlmZ050eHQxWi9sakRnUWt6eXdDZzJyZ042U0orR0hwRmNSVUFqTE5aelJweGQ0anVXTC9mbHZiY3RmWTBUaHVzUTU1ZUM1ekY1OUpEWDZxVVB0RXZkV3lnVG1OVmpSZm5IZHN3RTZxcm95Zms5aDFtTzIvbzd4Q2pEVUpuQ2xOWWNIZWlwcGx0dUM5MkRoWlZ6dWg2bWovb1JXdnQ3NUxkVWhrUXgxVHBjMTFrWEljbnhUemRjSmZVZ0QyanZRQWE2TTBjRnJTYVlkTEtOZGwrVzhaZ3JGajM4K0ZPTS9wN2RZRnFhaUxOWGhEekFMcnc1VDVubkJtS3lwRVNuNDFZZzRHRCtFeDJFaUxRYklJZWlocGp6VWZvSDFBakE1akhoTzdaWFdvOWpJQzNBeHRIZHpKWDJoOTJSR3pSU1JmR2pXTWlDME8reE1QVnFyZTRXczlEcGdaN1RoZ1J0TTBaaW1OdFN1cE1xdmFKUFh4UUlBYzlDMlZ6eS96WktXVFcwUGNvU1ZNaUVlWEI4QWRHSlJFbWJwN3F2MDdGcVozdkNWMVBhNk5KK1BWaGJBcS9CTTNMTU0va1hwa3hLWnRrU3hubjUzTFNTb0tacXA4TVp0ZFVXcm9PcjEyR20waE9rS0RYbjJndUh4U0VxV2dMZU8ydTZ1RjJsQmxiRHNBbGszTlJaU2EwSSt0SENtZ0JHcnVtemRkNURDcGRldFd1cGxXWlpWUGI2S0wwSnNseVF5OC9oYVJrMmNXVjhrQlBEaStSR0J0c25ocWFNVkR0MjBIb24xc2M1dWl3WHIrODNhV3FIZGY2MitFVTMwRmxnZnNPY0Z5U1RVTVhzZ2VkWkN1QjdTQkswbE16NWIxYldRbHdsd1VSNzd4VlNMOGVjcHl4S2ZMK0pKeVh1YS8rVFNqUU9BUjlLai9JZDFodUdUMmRsRlh3c1RmUW1QWUJ2STFoMkdteVA1UEZlQ25JQkg0cGxNRDVnRVYzWkFQVVlmcWExSGVUakFnemg2V09PbUdzVHpycHEzVTBjZWdsV0hYL0dnenhnOEROZ2wrc2dNZWFSdDZNMG8weHNQQU9jZ3FmUjNoeCtsQXR5SXpuMnpydlJINnRsWE51cWtGemw0bXd0QVlPVG5LN1Bib0RrNFZreGt5Y2xpMFNTOWI1aUZTbDFaR2ZFSVFXVnQwOXVFNWl4dnhGWDZUZHJVT0xoOTVZOVFXWmVoRSt2c25PMi9PMkxtWEhFNnhPRUVBQ2RnbmVDMWRRa3VSK3FJZTlManRLNE5iOVhjQVE0bHRZT1pmL0JXVHYxaGF1dmtCdTNBa2FpRTV3Y1V6RDZ3UUd0Ylh1Y2xHVDNkQmVYYmozVENoaFFPY0NjVWdid2RBaXJ0bVpSZjkvellaOW5TQkIrdm0wcmFLWFFoRS8xSkNDL0xrbzVsWWkyQU05RmVhSCtZazFCN29mREk2YWgxL1hTU0ljeHpQQnk4RzR2SHAyZmNYR2pNYWJmb2FlTEsyN0tLNlI0ejZkQWxRSHMvQjdrRUQ0SmhmR09rWGNkU29hd3BtRkllNy9HODVZdGxyYnFEb1V4ckc2S2hUZkROREQxQ2NuVjZ5dEJZcFVmZ25nVzRMeFpUYnpUdkRCbXlldm54eU43RC9Uc0FUK2RvQjYxRmY1YmF0S0t0WnhpTVh1RWZoYkRTVmdFNEJhOEJ2QkpOcS9GWVR0RVFuNWVoYVRPYWc4TXhrYnU3TlAzZGdFOVpJVldmU3NyQzRzYy9lVkhWOENoZTJObzNoVlpmbG0vejVYbHE2VmFNMjlHNVVrdFh2bG1vNWRIYUVJSmNoNVJXcTFNclI1dFQwVkRYTENwdHFIVnRQdFNrZFhuR21nL2d3RE9FWmczUGx2VHkrQ01zMGtzTE45WGxGWUZXaDBWTGhESzNZVFhSZVEybnMxTGIxT3IwNW1tOTQ5ZXpEV3E5NThjUDI2MXp2WU9nWi9EMDFtSE5yNjJaY0N6Syt3emJlL21wOGc1K0NIMFdhd3crRHdyQWxUbjFoNm5Td250MWtqUDg4bGdiamxRRGdObG92blQ0ZzJSL21PMlN1RmVHeXpJQUxrZHRnRXViVkdXZUI2TVpvNnM0dk02emJoVEF3NFhINkpXbmtLVnRQVzFIWkFBQUdFak82eEZucmViMDdYV3dXbXdBRm9WVE9NSzN2K2tScmJwNkh6L0RCZ0N1enN4M1ZKQjVBSk00Y2pKWmZlRkh2c2h3cHFPNlJ4alc5aGQ0OFE5T1pZV1h0SmVaYlVtRDE5YUplZVJFOXJhcGg1bmFYaTl2RllwWFdod2UrQXlPMUUwQUhJeit6Z1FtVW9wZWRIVTRDc2JZTGJtYksySkczUXhWZ0lOSVE5SE5mTXhqZUFPbi9qRDFOOVp6d0Rhc2V5NGpwMFJZRCtXUjBwZDVHeitldnhhdG96YWdEMGtqOVE2Mkd2eGdBMjZDZUFDYU1yNWI4WjZwOG1qS2sxZGlJNW4xa005WUx6T0ZJaDNBS3FRMU1qOHlyUFhqMUZaWk45SnRXdE5WTy9qTGU1dW5kb3ZsUnExNVozVUl3TXdqWkJmVGNvQ1hza0xUbjQ0VW1WRzUxdXE4MUtPdzZGZTk0UUR3QVZORndkTkJSL3FVVnUyeW5Ia2tjbXV4ZklDL1RuRVROSmMrclN4ckhiMTFXWWQvQ0dQNlJubCtrdFFHNUJiQXRaZ3BJeXhsYS82YjNqYU0rc1pIWkJKeURWN1BMSVhEb2tkNjljcWVDZXF0MDN0ZjFwY3BnaVBkeUJ0ZzI3KzUveG5na2h6cG1UM1RxSjVacGhGejFWSE9HNzllWkJEM3FBVHZkN0srNFpxQ3VPbS9ERTk5UFpaOG5yN25KU2d0NzhpdVJteGNlMTZ1OEhnWjhydzFMMEl0VHkyK0RQZU9tMWJkcWQwRzBlRVQ2K0VXNG1BOHZBNlBmNjdscjFzNTlGYXZzaU1TMDVNdlh3S3JCVmx2dENYT1VoSE9uQWNQUFh2d2pMRkgwZXZlMkJqUllDVWtjMEhUSnBPaHJKRGw5V2lYajJIVU4rVEJPN2hHMTBRdHZTY1BMS2MwM1Z1UHhxdWI3ZW9LQU5mbjlCK21ycUswVldhVk9aTG44a0loS2RmUUI2c0J3RjlLWC9YWG5rMzREUDVPcStud3NDZDlMWDdhZG9tcnpBQndNcExqc0NmdmpWanBMRUxsZzllakdZc1BuQlJQTTBrdTlZaFFXZ0VPZzZubUpIOG5yVmV4VE01cnFRMld0RjVXRElnMEdHOU5jM091dFBSdGJaR0dldzF2MjJ0bFdqY1BrVnNBOStKcGRwT2tBb3pJY2VRYXZCN3Z5MldlK0ZGRll1WmJrcjNNYU1NcVNzVVI0TktzbkJobnJ1WWpRclFtc0N3VFdudjlXMHQvQmtmV2ZZWDdQWkl6RjRJckxrSUxQRHdZREhBZ3ZmNDVoaW5BQTdFS2hESXVOcTdoVm5pM1FkK3dGakNjSHdaK3JYUG9WQ1M5bmdpQXAzRHFEMU43RGlJcEo2bTMvQmxFWXhxdnNuTWEyaEVjV25xUTBmelpaVHBQbjlML2NCY2E0enNxTDZsS1dXZE1vVHNoaVpLb25DS1hPaGJMWFpFOWIyeFd5Z1Z3VXh0TFZvWHFJVDhTcXQxdVMzOXVuWjRXRFBscUltVTVSOGdNNUJIazVCT2wxMGp6ak52RjhzaGlib2g2UkpIMlNodXp2WWVhbnRibVVxZVZiT3VaRGJUZU1Mb1pUTUk2bEdhNGxCUXpFVFNpTWN3UzcxVXNnNkdjaCtqcVQ4YXlPVlkreGlTRWEzVll3NFBTbHZMYVlqZFp5MnVWQ1FEWHBtVVhuYm1ISi9sZlp1bFJIbnV3YkFQQUt4bXhtNzE3N05ZeTc2WS9hNDdta1RLdDRTTmxBdHlHRWUrb1ZkTUlRcnBSeDBGUG5Sb2pUdjRCdHMxenIzeld2b0thZjJsU2xhY3JuYjZqbG4ydFBHdDZ5YnRnWFdoSDI3MnFQN2V5ZTh1MzdwaDQ1bWw1YkUycWhGdktkcUE1YkFBbUk5bkhNMVZXTDliWnZMSnVNYUx4enQ3dlAvNThMRHdKWlduaUp5cnBBR2FocWN1aGlOL1V5ZklhTG9WSGRvNCt2aFd1aUpLWnZtQ3Q3RXN4ODRhOXRsaWV6MXBIRU5KYVZmTGVSVjNiMUlCTEVEdWZCY3NNUEoxL0FnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FnVk8vbURyelFNdmV3dzlxWjZ5MTB2ZkdKNlh1dzJsOVBTRVpyNjMxbkhxakYwVTdXb1UrZ3lkaUZOeWVFOTFUSmMrYitUNUlkZURrb0ZSTEY4TDRwNUVBZXZFb2pOS2hycEt3dU9HNDFiNWE5SnRlbmJhVXY0ZDJ6NHhqNTVBL1lLRkhEKzh4UHFPeDdFVzB6dURXRHRXNzRsU3lmQXRBT2t2OU1IcE9MaXpYSjR1QWJvWGxaVHhvN1lOck1Ic29hVXM4US9RQXZJN01XbmhRd2tmVDF1cWU0YS9zWmNRWllWMmd6cncvcFVxTERqSHFPdWk5WGNzeWZJWk94TElMY0M0MXU4aXFnMWpUOWN4dnFZNFozMC9TVElkb0NDL2phdkZTT29CYk12S1NnVlZvZUZoUlpsNWVVdEswNG51Rnd3cWx5Tm9XZ0VjeE1vbG1XV0dhQTEyTHI1VTE4dktNMVN0czFjRGlaN0o4MC8zM1Jyd21RNnRWT1orYlNaNXBEaHFyVUpRK1lUZERjSStVb2QzZlRMeDlablhZaUFOQ1NEY0RxUzdyem5DTmNrNVVzdGF5TzRvVzA2L1NpZUF4bEpLL3ZOWm01OHEyU0hqVjVOYlVPc29lVDkvL3FmVGRyUG5LUElkWldPM0Vsak9OOWVkd3ZGdVEzdTNObytTbFZLZDBmNk5hWkRER1g0WTBHTzlKNjFYVkxYZ0gwNmdaRFBPWlllWnVSV2p2TFJUcFBGOVluZGhNZ01QaGk2a0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFZT0xVTDZiV3NCNStiNzB1eTlYQzhyei9LYTY5dEE0OE9PeVg3TklwWko0ak9Udy92NWVPbnpyajZKRXJveDJCeFpFSDhHUVV1UlMzL3hRSGtIcm1RMnNLUFVJY0tTZXM1UHc1dkxXeENINGY3cHIyNFhsd1h0NUhPSElLenFMbnlNbWVNaTZHSk5la09FdFozdFBaeXJxWGRLTzBWa2hwQUVheDJFZldlQzN1SkxiNXFwa2lXdmdSZU9WUjYxRFR3L0E0RHBLU1orUW1aZ2gzZ0FhcjNCZXRwZDk2b0NqRGV5TGVVMXExTDRZazVicFYxZ3gvcFpTM0RDL1J2Z1loNWFuZHI3V2RSOGh0WjkvMStGaTg3dVl5M0Z1bjVZQnpEVzE1N2dHNUJIQU52Qi9veWErdFMwYU5YcE55dG00elE2Nk5MUFd0ZkZyWkFGTlk0Zmc0eWhqUkpsK3RMVUVJYnlsdFcveW9nOWxqTDFpRVU0K2hDUEJvV2hQYSttTE82STVTRDVyV0kxMDN3cjgzd0NXRFhmRmd4VUp3aVlaay9LeCtaM3htR1ZQOFRET0VWYVBLMDdmQ3ZSdW1MUUZzeGZsTXZzTkd4dHFvcGkyMXFZZmVQclZzVm5tZjY0VDdTb0xDRVpWNEs5RVlCby9ITTB2TGxVOWFDV3Z4bzNoWFc4MVhLdVhYMHRXUUpJWVVYeTZOTVRYeWE4N2dzaExyNWc2QWhqYXBySk51aTdPRU0wNFBZNFZsVXNyK1dyeWxEc3ZqbDRhT1ZKWlhVMlVvQm5seHI2VUx3Vy8rV1BCdU5wWm92clAvMTk2Ykp0bHFBd3UzNFBBMy94SGVQM2NhTjhLOGQ4cEZtYTFTS2h1bGFNUmFFWFlkUU4wR0tUc0pBZU5wUEVOeGpiM2c1bS9DQlBjdmRWUUxaOWlhUkZlQlI4SVhVd0VBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURBeE8yK21Lb2g3Wm5YczMrYmQ3TVRiZU5SS1cvbWhnMW1MQnZqUmJkbjhwRDJneVpCZXk3bHNiWXRBdmNYbmtSTC9pei9YV3ZKMUJGN3NqNEtZYWV2bjYrWmxqdllGZWsvZEo1d1E4em4yWm9GcnNMVDk0UXg4eVNCWUxGdE5kdTE1Sy9pZXNRTUdYWUxMWWIyQTU4ajNKaU0zWmh2MkNlZnFxWWxzVjNTMnVYeTFtakdiWWJ4aTJ5RVpGYmxXRXB2N1lxV25jN0x0TXNoRHlSZzNXTDRtTmE2dTZ2MVF4QzFPcVR6bGdEdE1lK21wR2xoamMvVjB0ZmF1UzJ4T3JJdzFoSHhEMnBsYkk0bVdNcjJmSTNnZUU0cUI1a0NBSCt3eW9vTWNaMjFZWHR2VzdSNXpHaWR2WnZIQTZTVE9hZlJhMWRtSURsS21uRlRPNzhKWldmakZWaTFSUlhTN3dCNEZiMGUwL0c2ZCtLczVUbjFXaS9XZ01SV3lhSUloZkx6SlB0WFRiZWlvUFY3eHV6WFowKys2eWpsMG5vOFdJU2ZFQlYrbVlJdTAxTFV5cmQrZDByS1cxTk1Ybm9zYld1a1FvdVNlbVkxdEdDUk5YS2hCZE9rWXcvQ0o0QittaWlVbmZGWTRkRjR6VXVyRm9yTVYyU0dYemZuY1cvNUxUUkpJcVgvTlh3OVpvYmxobnZTQTJoby9xOTNFRnBWSnp3R0tWeFRudGRpd0ZxNld0ZXhkTGVhQmFoMTQ2VzRYdUt4eEc5Qnh1S0I1WEN1aG5ZVHJXWjBxd3dwdmRVZFFzN2NrazF4RlgvWlRZVjdWUExYN3lLcS85N0xrT1FYd05QZ2k2bmZNSUFCQUFBQUFBQUFBQUFBQVBJZzdnNEFBQUFBQUFCVGcrTUxBQUEzQUhVRUFIQlBrTThBQVBBR2J2ZkZWTy9lWXBiOXdidzdTV2hZZDR0djdVamgzYkJoTWRhcEl1N2tGNmdzc3YwSHRKRTZkT3VCYzgvaEtaVDl1N1dyemY5L2JhM0lGdTkrb3RPemI4TGFvVHorN09MU3pLOHBISXR1OEc2RENCQWhZNnZORzJNeDJidzdKa1gyRGI1c09HZmJyQUFTRmlkdVZhN3YxN1JkOGk3b2s1YVBZeHl2U1huT1F2UDdieis4b3pzSDkvd2dhZHRQWkNBTUpycHZ2N2ZjU04xZ3hCTW83WjFCamVTWE9wVjBmVThqeEJ4Y084QmJpQmpYZTFzcythUHBCOUFLNTFqeTFJNjE5RjVxSnRjSU95TExQMEpkQTl5WEhqdkRLaU84TW5GMTFPbVZVNzBxWGlxekovd01rTTRkNWpRc0hWK3lZYldBVFUrN2UyMVNxN0czVks2dndyOXJ4d0MzdzZMdHJ0SjBVckJRT2k3UDE0VExhcXpMaW1YMWw4VVNNcFM5bHVlWHordEw1ZnBXSzNPVHEvcVp3UC9uKzlEYTVwN0pnOTcrMVJMY3JYYlZydjBscEczaFVVQWVDOXRiZnBtM1poeTA3c0h4V0VxblRTelZ6bXVUVXhJdHhmeTlZUERyWnhsK2wxWmw1TEhBS3hnVis5TzAwdHJJMDF0M0pqM3pLdGJRdHhZYmRaa3dVVFZzUFEvZ05TZWxnZDN5OCs4dytGOUdsamZVZXN5YlVGZXRYczNpdGRSZFh0c2F4NW9ua3hWS3VUMlpMazZXNjZtZHI3WEg2bXA0SHppNjhUd016L3RuVGYxMk9GNXlIaGVQR21hR0w2WUNBQUM4SGF4ZEFBQ0FWNElKTUNrOFdBQUFBQUFBQUFBQUFBQ1lqaXVEMzJmV1RaQWZBT0lnUVFBQUFBQUE0R3h1OThWVURlOWVZMHZsdW5YekUrOE9TYXZ6dUdjWGtQQXVUcDVHYUQ5QXE0ZmRaZkt3YkxVQ2NIZWtYVjRDZ2p4VG5zNkF0dEhxOFl1bzZxYXMwZ2E0Ym9WemJNQUNNSjZXWUhocEg0enVRR3JaQU95V2FEdWE5Y2d4ZUE4V244ZlNweUlEN0NJazhYbW5EZm9lTzN5akc1ZVg1eU5sVzRNbkFKMVkxV3cwdG1ZcGkyNzlBQ3dmZjlCMlQ3ZDB0dFdRZjFIYVVTc25ZazlxY1R1dExPbjZqVHE4UlcxWjdZZ1JvUWlwTGRZMlJNcXM3WXpkU3ErZEI0RDc0SkZMNVJ5a3BoSzBjTWFtdEtYMmRRQ3BiQ3VhL0xhNEc5YjdnQXlFVytKVjJsNUR3dnFKaldQNmNqQloyekxDaG8wZWV6NFpBdkFvdHM3ck94a2VrUFI5SHVsWUV4cWVUOHBJYVpaQjV4djhOTytmNHNUTzRiTW56Zk1SNjBVcTIrb2hYb0hIV3BYb1VVQ1dzbHZLcjBSU01wWTJIZk42QWsyYVlyTXEySnBGSGNYUUI3ZmltbVNQL0dyRzlqdGY1VFRHUG1pYzBYVWt6UmlweTJJdW00YVEwSlpXUGszRHIwVUN0L2JzdWZuWTlwQ0ZOWmdtNVN1cEJjM29wMFBvc1o2amRkWHFyajNtaU1kU3NobnFMTk5LWVoxRktFczYxdEsvRXErczZISFpXNGFFMTRqd25JYzhQUGY0TyszMi9lLzE5NlgvcmkvOUhtZXRiSUFud3hkVEFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQm12SFdwTGt1VUFUSTRjeVJkT21vUkdRQUF0d1R4REFBQWIrQnhYMHpkYWUxQTRjMnJwZXZkalVuYTlMUjI3SzJ6dTQwOUZvL2xsWDd3NGRra2tYc01UOFVyZDdiWW5xd2dVMjdRdW43L3Izbi9pczFkTittaDhCRGdhbHBiVUhyMDdBT0o3dVJtTFVmYklFeExFNkwyUEd2WHRMd0FHVmgzc0xOK2djS1Qva1NpTXVDTW55SHRFRnp5dU9FZjNSM1JFbXhBRnNKZ3JMdTRuaWxEOEE4dlFMSzN0YlJyb0N6dkZxTmFXazhhVHpEQ0c5UXR6NC84TEVBclhVZmRxeU9OOVZHMXZnclErbGtXTjhJVG5vcHV1b3djQW5ndXBhd1lNUWRaazJzZUlqSm10Ty9XK2cyYUd0V09BY0pvbmN0cUoxa05rVEtmdFE2ckllRWRGSmFnN3A0dVlpaTE2clE2akFEVDBLdHBQVTVuRnB2eCtNcWdZOFZpVXVXeWNPOSs2UURoK3A3Z2VIMWRqY2FiOU56dVpOWDA5SzBSRnFWVTVuNSthK1JiRnIvU2pIekh4am9XTE9OWW05WElWcGdkWlcvQzd5NFhuS0Q3WDQ5WE1sZzFualFDUFYzTDZ3WllRcjZyY2wwNjdxRjJiell0UWUzOElxU3I1U3Qvc0ZUSHV1VDZFekFudmVaSExhL0hGS0JmRGlWRDNubXRMa3NjY3BScFlna1JhWHJtTldqanRFYzJhSXA1VWVyMDFuRThoODU3SHQvUDdHZjllK1haZlhTbDdmRHY5ZU9QKzdIWHVya20wK2hpOEVUNFlpb0FBQUFBQUFBQUFBQUFBQUFBd0lsY3NhaUFoUXdBQUFBd0pSZzVKOExOQmdDQUFsUURBQUJjQ1hvSUFPQnlIdlBGVkdubm8wMjQ3dDM4b0xZNWlyWkRrclhzeFZDT3QvMlpiVFRUOC9xOWQwZUt0eEs1eDl4Ym1JenQ1My9mdTVPc2xkMkx0a1BhNC9uRlVIWWx6NnhEU053UXJPTUhiNUZOUHdIT1pEV2VPNTZmcEwrTzNpbXB0UnVkZGFjMzk2MWVnOWRxbFNHWFlEUTlXd0hmQU0wbnRld1FmQll0MmFLSmhxbEVmMnRidlpHNkR4OFVBa1R0Q01tSHEwRzN2QkNyOEkyVTFSUDBMZE92d3IrM1lKMnR0bGgvcy9mM1JPNkROVzF3RUZsMmhxNmxYWmErbjlINlNvREhqZEIyenE1OUhHQXhIcGRsbFhVQ3dIM1J6T21kbHNwb2xiRXRjUldYc1ltOHRRNHB2K2FUV2VMd21sejMrS1F3QVNNZnNMVnpTZGVQNThvQkxDRjk1a01UR3BvaHNSbnE4clR0Mko2ZVlJdFVCOEFqaWE3WUdjRUliUisxUEdybFJ5TTNFY2QvcldmNU9LN2tXNHNWWnZ0RXR5aW5pblJmQ3hYV2Y0K2w1djhpR3Jnb2d4WmEwQ0hpZlVyMzJDUDBSd1FaSW9HWDQzWHJyRWJHbUxKWXhLMzBOVVBDTzJZMHlueU91bi85akxWNXFKNkhLYkNZc3BZeXJQNXlxODRNckJJak9xZFJTNk9OOHNWUW52dTY5UWRhSG16dHBuakVHY0FmZWt5RGFORE1NdmpvdDZkaDFRVTdWa3ZRVWxhWng1cmVvaHRhT3FIbVBWbkY4TFJkTTJKSXRNcXk2S09vVExFdy9RT2JBSWU3K2FzcnJYVWIwT3A1MTY1NzVRL0FrK0NMcWQ4d2dBRUFBQUFBQUFBQUFPNEQ4VG9BOElETUFJQ25nTHdDQUFBQWdENndLQUVBN2d4U0dnQUFTdEFOQUFBd000LzVZdXFPWnpNVGI1blNzYmVjMnU1SDFqcEc3QzNYemNqZElxQWZuZ2ZNd3ZjT05zZmRndjVzUHJwV2hLcG5SeVNONllmUTRRZnU5M0xmMkhWMGZRQzNnLzdaVFhTZjU2R3dFeWRjeGFRNzM4MGdLc3ZkSjQrOFFoVzArbVRHRFVDZmdvT2U3dElibjRPSDB2c0FwVzNwOStQVzlSRklXNkJPMU1FLzRqakM5VFB3ZmtjbG80N3NtRDhBUEljcjQ4OTNreWsxVlZmenlYcmJqU3lkbkNzZjhCa0Qyaklnb29aRWI4RFdZcU9XZG5TWm5uZ3NURVhQaXAwbmFLdk1XUjZyMElnS09POTM1dzRXeU0rWFVZMmY0OW1XZXJyMSsxenArS2JLdlphQTlkS3JOSjRxMEs4WWU1bGo2UTk3SjFzcjU2V3lyTjhaMDZ4MHFZNjFmbnBaMFAwdm84ZVV0Vjd2VFo5UlpxWVBLNVdWc2Q0NVhRMTVPRmJ1L2ZRaHdOWFUraS85OWxReTVld1I3OUtJcSthc3ZNZlRNUEtIYXE1bTVzT09HalBJbWR1aHJwcy9QTE9QVUlIaldVcVAzK0Y1QVR5U3g3eVlLb1VMcGM4ZFMrZlBvQlZtWFpYalc5T0syVDdxaDl3WVNRdDU3bTBrRDhCZFdQLzdzeDNtalZaQnhxemxQenI2L1pSaTdQQ0Qxa0srbEMrbmZoMGY4NndmZi80ckV0a0NjRnQ2elFndC9XT0hmNCtPd01ZRkR5MG45QUY5eWVwelMzbnY1aVphbGo3VjBqOSt5RnNqbHZpTk1DR2FIS083UDVRMWVGMWJIeXNwcmxaZWIvck5VTGUzL1QwTUhBemFMVzNsVzViY3hWbTlSR3dmM0FZQWtJaUdJang1ejV3UDFkeGVLVzNtRkJlMjNZdUlLdGpNUWVGdFE5VDR5UlFXbmpxMGdUcjBSU3lBTnhEMUhEekNvYmVPa2l5aDJYSythL2txeC92azlpWTUxN1dpdnVzVURRbmp2VjJGYzFXWmFIMWVkNHBjV2J6eE8zdTZWb3N4a2o5cmJFUVcySzNLc1ZhRnBTL1ZsUCtoUTM4MERlVVBmckpqWnJQN2Y5N2ZaekxOZTIrYUpnYVBsU01pWURRMW9TS2xheDNUZjZka1ZhNVp1czRaZUdPZGRNMFR5REF3N3V3dXZSM0g4LzFaTTE4cDRzTXQydjlLb1lqRjFxUVNrMjBIOENBZTk4WFVLR2ZxZ0ZXb2UycWhzWFZlaHp5NDF6QUorNHVUWDdKVDZkYy9tNTR1Y1dZZk9wWVhTbXNHTlNJRkhzVmRva28zd1R0K3B4M3ZQVDhNSVFoUk51WDRRZHhwQ0VuQitBeWYrOUhEL1JWQkIzZ0taMHlhZWRkd284NWZTaXNZN0YzcEU3bXVyUUhjaW5RWms2QWFnd2REN1piUDZwTk1aT29CUURJMUVWOHkwblk1V3g1WlhCRXBYSGZGL1lHSEVYM1lWM1FTNlIwakxkMFpiZFZXUGg2UFcrMGo1Z0FRSURyb0l5L0FhUmFJVkVlV003bzI2dERPQzlHa3JTVmN0L3F4K2pPMlpwVXFYWEhZVEtIZlc5YVdsT1lxbm14Ukg5K0cwWlloS3diRzFodUpMVHAwcldtblJIdGhKckxOM2RuOHZ3eHRxNnFoTEdmN2xRdWc0WFo0KzdQMGhoLzlkMHF1ZU13UnkyZzJYWmJPZytkRjRhWTRudnNtQ0kyUGtPaDZPSmZnSHRFdFlXYW1lekhWdXd2R1pzaHJGUUphM1QxSU52TWxBa3JhVVFiR29YVWduZ0ZNeWlvSTZ0WFk1MXZpcXJWRzljMlk5VXRFRVdtYmYvSkFvSWZhTEllMlc1NFdyRnlVZEEvaFNqUGlsT0V0VlJJeG9GRU80Q0hpUUdwTzZmRzh0Y3hrbnFxV1h6K1BwT204bmNpRHRmWmJnQW85TWdVMzRhVkV0eFRWMHZaMHBCNDdNc3NQOXFTMy9tNnJYK1N3cDg5UUVkbDFYR2xEdEc1cFZ2Y0ZnREY0NXlKM2VzU3loamRNVzhzYkRmbEsxTzVEVkFYV3lnUndrZUZnM0ZsQnI4THhKbHpYeXBBRTJXSTREL0Jvcm94RzlFWlJ6bXB6NUczT0k0RVhkTmVESmJHVkwvT1Z4eDJZWktWMnJ6UDdVRlpkMW9tMEhqS3ROc21pdmxMNTlyWmhGYzVGK3E4M29HTW82NWNkc1g2dXZMN0RJNEJoZUtjN0k2UDlDck5SKzEwanUzVzBiSy9KbmxxcFpiME45aitNNGd4Zm0vNDdGSTl1eUxiMGp1THFEbzlabXhiYzJaVHJqeUZxU054eDNVcm1Ba3Rrem4zUSt0eTJmSDQ1OVdBc0htWExuLy8rV1h4VlZxb0NtSnJYZkRGVklsTXZsWTZycGM1QXlOV1ZieWhJeVB1UWJXQUIzSW1PL3Awdy9mUm85cS9PV2tDRXdPTnB5UXF2SWNXQXFCSVJ4OXhLZUNVZWViUjBwZ01BQUhncjFrRHNNZTFJUmh2S252VFdZSWpYTHpLMmdUQ2xuUzE0RFFEZ2lVUmo5Y2hEdUJUTDRteEx2alB4MnNtcmNJeFJCNi9sRGdONGRKNWVycXF6OVpiOHlOWEpvNUYrMnhtckhONjZtdUtLMzkxNnpqZDZEdDQ1ck1oR0dIQTd6cGovMTE2TG42SHIwUDBCT25pQ3J3MU52Rk5ZcmVNZWFtR05FZkw1clZiMDZ5azcxYzFNZVlqeklZY09JWVd6SGk5ZENHYmhjUyttZWdkZkdYNXNsV2sxY0F3dno3dGVUbDBXZnh0cTVmWGtOeFd1cFhseXJIY0dJbHVTQVR5Rm9uOXJRY3N5N1RwVVNONmI4dVhVMmxkb2o1dGRtc3Y5L3J1Wkx5eHR4UW1RZ2RkUXpOeUY2NFo0OTlYZDBYYXVXd3pwcGNta29iY3NZK2N5NUJGa0VaVVJON0padEhGOFBENnJ1VmNFL0I0aEZpeUJqL0s2UjBCcnMwTXZ0clhoTjU3WVcydkgyS05za2JydEloeEwwRVZmU3F2VGFSMTJGRm1kVWRzTVF4b3NKd3dHangweHFrN3Ara2drTzhLNk15NHFGV0JPTkxta2pma1I0U3N0VER0S0hsbkswM3d5WkNXa3gyVzluV3FVblZXK0lGbzduOGwyK0x0V2prZldEZkJvM3FLSnJGNk1KNi8xdWxUdFVWQUpaYTdGOFZKa1NZa0RiTTdqU0ptOTBTNVBQODNxeTltdkZMU09kN3pSL0JHekd0SzlibG5odmRITlFsSC91ZzNmNmRhMVhjd2k1S3ZWVVo3R0dIOFZsc2ZlQ3J0NnVvdDNWQytOT252OVcwOCtyK2JUMUZLSXJJWFBubnJ3RjZBWHlSZXRYZGZLYVIxRG1NdzRuZlZ4SHROYnl6Nm15d3hydEg2dkpiNjZDZWVud21PQzE5TDN1QzZhRzdVNXoxdEEzdHdYbzBIMjArVTA0M1pQZC95N21xb3dlZmgwSFppUjZiK1k2alZtc3FqWnlmdjV4WEhlVTk5cGJJWnpCS0VBb0FkSmlFYUwyOTVyeUgzRUJJOWVkNmVjUnN6REZQUjBaQWJCRjFiYmx0c0ZJUERnd1pGc3JnM0RlNHNmK1VpdUNud0EzQVJ0VGdsZVJLbWNwUFYwbHRuaXpEYTFqalBMOWw0L2lhZkdZektXRW12bm8ra0E0UGxrcTVwVnFlc3ErUktwRzFrSUtoa0xxTFBia0ZHMlpYR0JaT3N1U3I3amNXa1hTOGNBSURDYnBocmhyYlNjODJYUlgzcE5lWHNVb0VKVTBXWDJ2UUg5dVBtaXFhRytIMXRndGVlQlYyRjkzNlRNazdnODZSSVlEUUw0RFpETmlENDFZcTducFdST1E0Mk9FWmJ2T1IvUEE4QUxzTzVLc3IrZ3Vycy9lMXJEUzZlOU5pMW1GTXpPdnkrbTFyWXRlcGhIMkxJbDk1OFQzU3hoTVo2dnlUTFAvSkFGVFY2ZWl2U0RaNHZGM3dsdGg0WmE1K041d05Nd0dIdmxGMUFsZVY3YmRVZzZucEZmWDBvOUlpbkh3K1hsZUZuWU1XWXY5K2U0ekFkd0I2d2QwMm9NUGhTdkRac1pZR3pWbFk0MXlJekFnaXVSYlBmeTJHTGtERUlhU3BaZElDWE9IbmF0V3p6ZDBDOXR1OTRBUjZ1T25qTGc5WGgya3BXT0FhcVVzUVNMbnZWaVVXUzlzZEVlWlprZGlKYktWOHFPbURoYWxmdkJuOWpEVWRXZEpSOUczMXFwVHVRZndCeG9hcW1XZmxrK1ZWdnJlaTJOMW9iaitWcitERGZCdXNoQ2MxM09VTDlnNElrM1dlcGNad1ludkhWcGc4Wmo2MXArYjVhZERBQkJQQVBXVTZhbU5UUHFLS2xaRTBIbDhkUEV0WDZ0S2dPTENldnllb3E4RzYwTVcxRXpiOTFXNjI1RWY0aFljMUVpWlVabk5jcGppd1YrVE5lNlQ2dmh2SlMzVm1mWmx4cDFsNHRJdmxabkx6cllFRk9SRlk0c09mYSsxWmovSHlXOVZFWk5jaDdiVWFaZkZ0dnY5Wmp4TllZT0RVa25SaHZqdVRHTWVjakcyNmZvZzdmREswSkdXZFcxc2kzeHlWbzVlMTVyV2kyOVpoMCtGdTJCWHVtS2FPZkw2NVlGbE1pZjYwbDBNY3VYVTlmVlZyWFVsRlpYa3NvQW1JbC9YMHkxeHFUQXhFakQ2WlJISTBsR3F4SUhBT2lodFdKbE9zOXNMTHZoM0RLWW8vNllsSTVOTk9FV2xQMndkOFlBd3JlMFZnN0F0SlIyU3NzeDFIeHdkR2s2cnpCUlduWTB3QXZBem5nNVI3M2Iwck90V0lPRU5SYlJJMzh6NGgzbGFxL3NRV0VzTDFNZGxlVmsvaXpQTGI5Q3ZTTFRBSjVOS1FzeDFmL0RLOThzVTlqSVRLaGluZDhlMllGR3ZDL2piYisyT0JEQkJIQWhJd1JTajFDSXBHdWxEVHJiUDdLcGRsMXo4Si9NVlo0bml1QWNwSHQ5eGYwL2VDZGVrVER0R3hYdnBrZjd0S1FJM2VOaDFBS3hBS1BwTlVYUVI3Y2h3M3ZJWVBSTFlGalBrOU15MlhuNDk2RXo3RkYra0VrcVltMGNlNkg3d0Z2NGU1bUVubmNtVnlHUGRENmpUQWt0L1VpamJDZ2pGa1BOek1nNWg1Nk9EWEFXd2tKUkxaNndDdjA3MHUybG1QclRobzcxcGRTZnpTKzNldjZ0dUJHL3prc0Y3M2tzTnc3NUJCa2NGNk5iRjQ1UDF1ZXl6WWh5bXI5MWZBdFc1UmpnVEI3czBIbUd6bFBjdlZjRSs2SXJBQ3pCQ0d3MENORHlwODZTSGRxT2xIVHRoOUthR0d3eFNobFk1TzlXT2ErMTErdXoxTjZDNmlYZ042MUtHWnFKZEV4ZXlwRjFxYXVsVmhrWldCZmF0ZXFiSmRZRUFEYTg0UW5yWEtVVUk3ZUVhYjNYTFhoZVJmR0VpTXM4STJYbXRQTFkrOE5HM0lpTXlmWWpQZk1NbnJaNDV6UktySFY3NGthMXdHd3JqM2JkRTBjSGVEUlhldjVTM1ZFQnZUVHlyWUh6V3BrV0JrVjZ0dUpnMzQxNU85WjFTTGNLaXdPa2NrTnlMeXB3eTNTdDhqeVdsYWZ1RnR2U0Y3bUwzbFF0WXJjMHJudnI4SlNsL1c3Tk9tMzlMczBROEtKWnp1c2lOc242WlZTUnJzRUVGOUVycGFYZVhUTW5vejBqa3E5WDgyUzREMUZDVXNFYkhMV1V0eHpLWkZpRGw5Nmd0NmZmWmFjRGxkN0hPNktPbGo0cTAvUzJwWVltZnN2elduc2YwVjA5SnE2MWpJeE8xYXU4UGI5SG0rK0YrMVAwRCttRFQyWEl0RHl1cFJXcStHVm1MUXRkQnVabW1oZFRaMldrY3pzRXo0UVpBSUFWcjBkWE9mMVdnNjc4N2NmamZRNHZjblBNNGh4TEdzNEdlOE9OSmdaYXQ1UmJEYUNRYllUY2NOQXgvek1wYnphZ1lRaFhkaW5QNUNGTWdNVWZpRjZQZEtaZVF6cGpJbFk3ZndhZGRhOEpaZlJTdmhoN0pQbzRrVUVBOENhczZ1a0ttM0ZhZWV6OVlTTU01OTczWkhaNk9vYTNEWjY2ZWxjVVJkcFdMdUR6bG4ySFFRZHdLbmQwaERJRmRHL2VxTk5aZWtndGo4bFNuaWVOSXJpUWF3R3VpTnpkT1FCZDl1c0p1Y0syZzhmVCs1Sk83WDJPTzQreVhpbUFPb0xYa0JuMDdnMjhNL0RTT1dOT0k2T09yQkJTTnROMHljbE5ZemN2Y0JmZXd2R2pUSzJYVkxPZ3k4RHNUUE5pYXMvN2tGbmhZTTltQzU2MHJmd2xLVUp3TlI1SEt1TmxFUnVhOXZIczFGR1d5ZjJIcDdISnA3UWRTS3pYTE9tZk9IUis3ZDZ5SFk3M0RUS04xdTdxdWRrL21SWWZ5Q2ZJSW1xN1RLSXJSNWdSZjMybitlZFFSeTJ3ZCt0YmpJeUIwVWk2c3JVdTUwSCtVV2wvV2RROFFmK0hJL1hOb1FFSm1BMXBzKzM5ZUUrVEVVdXoyQm1FcFY1Q1RVNXBIY09hTnBzZVE3cTNRM3VOODFaNnBTMC80OTM1ZTllaWdBeFpVYWF6VUhNeHo3ejFBUEI4UEdySWs5ZFM5aDFrVFNTR1ZLYVhqcEdsRDhmYUlZN09SSGJadFR4WlpNNnhIOHV3Q0JYTFJCckJFcGlhTzBVQW5oaU4wQUtBWmREYmtsZXFZOVB6YlVzN2pWckU3bVJ1em53V3ZHOU1aSkpacG5WMWhGZVpiWTM4dmF2MXRMYjBQR0RONnZTV1hTc3YyajZQQVhWTXZ6VHlPZHV3UnU0cFBBWFBGSkJuMmpOaTByZW92ZWlxdFdGWmRHblhtdE93MW1IMVcxZWxUZFZZcXJVd2IzQ1VZUTJqc2FydHpETGhkZlNLTWtrbmFPbGFhYWNoR3N6VjhwY21hNllzME01TGJUaWVsNjZoTjU5THBWK3MydG9DNC9PMmRwZEEwUUNQZ0MrbUptSnhvTXMwVVp2NFVsczZVbmwyZEFFQTNzTVQ1K3B1d3ZIVzFRS1psb1dWUGRNMUFJOERXV09pOW43ZGxkUHVBTGRsSHlRdGhaczU4WElTVDNMdFdyWU5BRnhMaHBzWERVL0JaTFFtRTUvd3dIc1UxVm1EYUV0S015TGRDVHl0U3dIQVBSa1I0bjY2YnlaaFhUOEVrekRDOXJseVV1T3NPSSsyNHI5MnpBSTZlQjEzMGh4bnRNVmJoL1dGdGgxcGxlYmFPSmJLakFvZ1N4dXNYS2tzM3M2VHJOZ3prQ2FRRXUvUnRnaDFISStUeXViUjNwcXp3bkpYTFBHYWRsa1pJaE5td3ZQR2VFOVp0WFNNbzZtd1RsbDVQQldBTCtnbzcrTGdlbTJ0NjRPYkFEQVQwN3lZMnRwa1Fkc29xSmFubFQ1cUkyL0MzOGNpYlFtMVZNN3Z4MGpSNjVneUFnT3Y0ZHZJRXpleCtiNndmeEcwUEc0VTZXckNzanh2S0gzOXpscWp0Mit4dlA1Ty8zMTVQS3dxZ3F0WWpkZnBtMTlvRzRDMXBpNHZ1WVhhSkdpa2tmUUppTEkyemtmNjNnVjlVVEFqdXYzanMyaTVxSzhpc3c4aEM4RkJhODUzRjRXMU5KTHNXWVJ5TE9mcHVpOWhWMUsxQjU2NDd1NGp2elUyV2w2WDB0VFNaVEJpVUNnMnpTWWNueEVpN2xWNW50dDF3dHdrQUR5RWxwcVI1RW9wRzdXNXk2TjhhNm1SMm5VeHZ0Nm9ReXEvMXJZV3ExTG5HYnd1dkpQNWc1K3M3SzY0RDFaanA2ZHRtckR3NWdNQUo1WUJIQldlVm8zZHlxc2hsUzFkYjVWei9KMzdzWUdmbjJOSlg1blEzaXAxU2s3bnp5S0NwWjFPYlVPV01qazJJZ09yOVJaVllwdnc3OFZ3dnRhM3NuNjdwNTk2eS9ST0prZkdualdxYVcyRGRMMTJhdjNkbEcyVHkrWUxxYmNsUTZLTWxFclI2eFpxdm5SdHZzRXJHUzMzUVJ2NXRiYTE4aldQYXlwN00xUXE2c1FGWUN3OWZTNDZoNk9sYzVpb01CN05xdTdWUzZXWEVQQlVmcFZseWFkNVdOcjVhYmhDejJndWlzY29hSFVVaTN3SytacVFpdkM4VnlIdFppZ3Iramd0c2c1Z0p2aGk2aUJxdW1sZEpyTnhKU2QzZGVZQkFMRFE4a29qa2NJMzBiaDMzdWthREdKNEJjaVFEMW8yckZVczN3cUN6bkFsM3NGeFl4dUhvUVFBbVl5VUo1aDJMME9iNlMxbm9WdDVORGJqdWF5eXM4ck1ISENEQnRpWmRrYkdiZWsxOFFCZ0h1NDBENmd0OHVyaENqbDl0N0lld2R0dlhrVEpiOEhyVzdCdTYzMWRpenhaQTlBeXIwL3dCMERBODlwS1Z0bmVPdGZLK2VqcTJjMVlad1N0YnVIOG54ZmxOcStnd2h1RHE3aUpVcTBOZ2VQTHFsSTdyWXY2cGZRd2pBeXBsdTAyelBiWU1Za0JuUFFJbFpwdm5mRkdJSVA0VmtSREx4cmxOR0J0V2hEQUJNcC9TamJ0eFdRQTZPYmZGMU5mb25uTHNLc1dONGx1M3RMYVljTzZJNVJsWTRiajhhTGtTMFZycEVVcFN6OEVDekFQN2pITXlMNERpYk1mMTc2Z2Vod2FJNmNPYjhOaDk1WVBJM3RySnY5dGtCZnkvZGU5TFhjUWFvRThBcmd0cFd6OGE1SFhWKzNwdmVXWFphVFJHNWdlK1lJQnZCTlAvNGtPam9HRHF1Vno5amJ6U2hkbFN2ZW9KWmg3Z3hGN21sWWR5RXFvNE4xUTFOS05yTjBaWHNJYVNHTU5CR1RJT2EydVRJVVVqZkZiQTlJbGhycWtXMmlKZmF0clNkYlBtTVdadWozN1ZoTzJCWmdMcXkxaVZUTlN1b2dKMzVyVzg5YVJKYk84OThIemUrRUVzbTJkV3Zyc0J6c3lPREZDcWRjY0pzOWN2SVJXbHFjdWdGc3lXbmljV1hlMHJxMXhYZFBBcmV0SnYwOHR3aUI4MXZVejdlNGthazdYdWlvSmFtUTkweEY5US92QnBkS1Q4a25uZWpqVHVzdFU4dEk5NjZsalU0NjFBSXcxcWxDa2J6VnhGVTZzeGZFbXRFbjdraXAyeENQcE5XbVBqMzJFZVN6VmFUbFh1MjRaMWJWUlY0dGZhbldrREFkcnBkS3hKOGpBK0lVN1VOTWxWdUZDSHg2T0pqb3NYb1RGUXZYVWFUbld5TkJmSGd1OGxtNTZKQk5XdXU0cHF5UWorSDNNc3kyNnV3RFhZKzFEbSs3V2VLdlF6S3RXRndKNE1uOHRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHL3YxaTZ1aHRpVzdJMmpnbmJjQWdwZituT0s3dDdON2FCV1NwWFBPK0FYL0pJMnh0NVZIdURyRUlhVE0zckpzWnoyNVUyaFlNQUU5bDB5K0ozZjl3d3JwTC9FelV2aXB5WlB2NVgzR3VrcWY4Z3VwMnQ0MkJBVHhFdGxsN0lGYjdzbWJETHNJNTc0NTFTMmY2NFNDajRPbWMySWNqNDMrMGkyTFpnVk5yeXlORmZ2bkRhei9lR25SNFZEQUNua2lyaTQyMkk3U1BBdENOSjhNYVE3UElUTzI2NTJNWTBqYjZxOUsrekE3cVZjaVJOaWlEU3J1RnJWaEVLOWJUcWl0NkMxc3lRL3BLd2dpUVV3QnpFUEdidkJ1OTczazhjc29ybDVkR25SWThzU1dMSE5kaS9jalFFekRzT0c5Q2UrQlJ1NlNXSjd0anQ5QUd0T1YzSGN0WURlbXNhTFp2S3czQUk4aldBSjd5ZWllZlBFS3ZkRHFYNHJqWEFTeFhRUzNDc2RRdVR4NE5RVUJ0eDk5WmZPMXhzN1poKzB5L1pqamxWdXR1UkFEQVkwSDJFbTIveGNyck5TU3NsclduRGRvWTB0SWR5NjdsdGN4cWVHWjgvL3haZjE5YWxDcWxJbitPOTRCTldlWDJlUjNTR0NFcHZIVkUyaUQ1YTVrOUpIcFB2RDU0cTA2dno5MzErelZmeFJ0TWFOMklsQVlETkxEMjU1MnlUM3BWSktUanNUb2x6OFhyUFkwUVY5WjhyWGlzdDY3cHVtMnZmdW9oY3lMd0Q2MjJJbS91ajJMclNPdmdhOWxibmx1WjFzT3ExQW53VlBoaUtnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ1krUHZqeUx0MXd3MlFkaTJTOXUwcjh4MkpmaGhFMjlpK2R0NjZ2MXZtTGxUZFNEKzR0VDJBOXdjK3JQOWRScXRqUzF2TEFEeWRTci8vMlhCeFAxN3F4eDk1bHZldy9mcEhmWFBLOWVkL2g3eGIvVmphTVViYlNRYmdFVWpickUyR2RUUDhUY2tYM1ZTM1ZrYlhyZGFNY29zTkN6Q1NXa2YzT0twYVdZT3grcjJib1l4UmVIejVxWWIrR3JobTdVT1pHOVlETExvZEVlbE9rZTVjZm4rQWJqd0I1UVAyeEMybFhiVkxNanBzeGc3MWk1QjJ2MjRkREt1eGJvc3VLSS9MV01MaGNxME83ZFllWXd4U3FMTlhMV1haRVQwMmtXWnZBY0Q5OEk1Yml5cXhpUDdhZFc4YlBGTjR2YlRVdERhZksvMCtqMTJKcmZjQWV1SWN0UTYxVk01WmJSK3RycFk5cHRsUGtYaFByYzZ0a1NkcVNHajJOQUFVV0Fhc0pEU1dTdDVhbVpGSmpYS1JTTlNTMElUQUpxVHRFU2JXV2F2MTk2VnlrcnY4K2I5K25xSVVWb3REdkZUeWpsWkVWNkFwdjJXeGVlT1IzMmxONnkwN09xWnE2YlhuYXJGU3ZVcTNES3FzSDRkU3NvOTZ0Mk9pWTlCRmFZdlk1T0lDWDBvZHhnaEpZVFZseXpZYzg1WGFwNWIrbU9kTWF0cDVXV1J0YTlXY05hUmh1QmpQbHduS3RYRG15bG82VU1yZnVoRU1hWWlncWNqbGNOMGkzS3crTzF5Q0p1OHk5SmZWMnF5bGwzU0JWb2MyZlZqVGhlVzFSYW5yOGQyMnZMa1JRMElxVnl0dlhYeXl3U0tQV3ZuaFdxeHhXZW04OGZsdVN5WDlhdXNHdlpFV3Vock1BbDlNdlJBRUNReUhUZ1lBQUFBQUFBQUFBQUFBQUhBYnJweTZZZG9JQUFBQXB1WVNZK2V0RnRiYmZqZVdOTURUZU4yb1JVd0JBQUFBQU1CRnJQL3p2LzluMnBUaTcvKzNQQUxySmo2dFhURWtzbmJ4c096SW9iM0FiOTJ3WVFqZW5aWDJ0S2MyY2hLc3U0UUF3QWQ4dFRQRzl2Ty8veEMvaEpxeG16akEyWXphWVBlbVpKc1JGaFBQV3RmUVd4emRqZzRnU3U5T3NxMUJ0RHJxdXBncjNFQ0xYeS9GQVY2TDFJZGFmVW9TOWxKNmdBcldyaFdKejExcWQ4Q2NhTEZQTFYrTjFYQzlWWVprWjJqS3o5STJTMTJEOFlRY3NtTDVtZ3JNaUw5NzFDMEF6SUhISFJ3aEc3eW1lcGFzTzh2djIrdXJuUy9USUdzN3VMdkNpdHBWWjg1cDlOekQxb0tHMm5sTE9jYzhYaHNYQUw2SkRPeHNZVEpTUUhzQzBTMUI0b24wZEFpa1liTHNUQ1hvc2NSNlY3dWRpYlV2OVZoMTN1Zmt2ZGVXWUl2MWQwVmxSMWxQZWQ2UVhXMUNveSt0d3VlRHNDT21wTmQwM1pUanBWTCsyaWl2VE91NWJpSERYVGpteWZDOWZ3M2JETWRYdXNtYXVBSTRFNi9Rb0wrK2d1aDBXWWxWUDdYS3Rvcmp4Wm11VnNkanVaTkxFbzBadHE0amIrNUhwMEg0c3g2K1V1UW82RWJ3RnZoaTZqY01lZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTGcvckhhYkc1NHZBQUFBQUlBWnpHY0FnTXY0Kyt2L2Q5cXg0QUtzbXg5azdFTm9MZE82azdKVzE1REhxdTJvNUwwR3YvRnNoOUxhc0kvN0RrL0NzVTNSL3ZWT2NTZTc0Z0pENFpOTjJPeHkvZm5mSWUzeDJ1RjQvOGV2TDZyV0hvcjJBSkJYY0JhYXdWVWFhQS9GYWthMGJOcmpzTlIyaUxMcy9pYlp3S2xvenpWakYwWGtGZFJZbGVQTmtFZEt1eG5UbllnMGhHby9lM1F6dFRic01Hd3I5TWhHaTIxblNRZXZRT3RheCs3U3NpTmE3b1ZGN01LRXRIeFFyNTFuN1RROUFWa3RyOVZIc1F3YXI1eldBdGJXY3NzNk5ybHA2L0w1ajlWUjlpWlVvY21LRXFzSzdBbTdXazA3QUppSG1waXV5U3N0YnkyZDlrV1ZXaG9yUGZLcDFsNlBqTXhRMnhaN0VSbnNJT05tUmUwSXF6OFpzUUUxUHpoalRxTW5JTHQwWHJQaW1Jc0RnQ090QVhoSFRhTjVPRDJ6TnByMjMrK0hNWUt6L3ZWNXJEWmxPNlJaUC82WUhielNLVzNlQjYrVkkrWHY4UkMxQUVCdlFEWXpvSnNSWkxFcWRTbWZkSy9YNG0rdFhNbUs5NVRST3E2VmJlNnd0dlBsK0JCdmRVRHhhL1lVUEpLSTZXM05hMDFqVFd1VkhDMXBya2xVRDVvMEt0T3R4dXRkbFMvT3doblBjQ1dhMnV6dGovaTdsMkwxa3JRcEtxdDRLaCszZFMySnRVeFAzWjVZOE9QSmNDR3lpQm9TcXlGUHkvM1Ywc08xRk1KRVdqdXZqZVBhWTlmQ3pKRVFOc0NUNFl1cEFET0RCZ09BcDRDOEFvQ25nTHdDQUFBNEhkUXZBRmhBVmdBQUFBQUFBQUFBQUFBQUFBQUFBQUNjeDc5ZlRMM1RqZ1ZHcEUwRnBMZkxhL3Z4U1ZnM2plOGh1bW1yaCtHUHRmVUt2N2JkU2M4UGV3T2VWVlNaVzNrQlhFbERvUDk4SWJYWTlMVDhzc1pQdHkvNmYrc0xxclhoTnV2d2FZcUxMWmczc3VtbnRYQ0FzL0hZSjlhdDNTN0Fha1pZaCtYcXVHWXBieGplWFQ1dmFXRERWTFIwNGtSOTZZNC9oYUhhWUlwZ0JEeUpLK3dJUy9lOXNTa0hWanhCWUsyemVUOU00ZlVibGtwNnJjNGxlTjJDeFk5dm5ZL1VJU1VUMGxua2czVXpkZXRYSHhaaitsWWFhY2ZjU051UVV3RFBwcVU2c3VSWHhIVFh2dnVVSWZvdEc4eTM2dFRDTzdVeWUrVWxVNVlEaU43TUhrVWMrWXlGbEc5VnJrY1hFWGlVdnpaZ3kvUExVbTlUNjdOTWxvRUxBQWFzZ3NscjVWdWR0MW9kV1phRVZWQjBDSktmaFFCYW5UVkxRc2xTOHV0NlJIbG9BdHZLeU1rcjcyZDd6ckNDZXZwK2RyNFJCb2ZuM3RhZWgyY3hoV0l4LytwS201TDNjUDNQd3BydHNFQ25UQzg1T2pBRmtsUmFoR09wWisxZnFTdk5UYXNXV3haOXBMVkdsb1JWVXJicThvNWF5UlJmbExyVzFoeXpGVTI5V0VWTExUMWpIODdDT3BoNkJSZDBVeE0xbHJtWlZtakNFME8xdWdNYVVTdlUwNWFzdHQ0T1NVOUZiMFRVeGRKaWI3V3lXMjN4enZNaVc4WVRkYUVyNlQrS09wNC91RllXT1dXMVlRRm1oeSttQWdBQUZHQUlBZ0FBQUFBQUFBQUFBTUJzRVBzR0FBQUF5QVlMQzJhQy9nd0FBQUFBRHdWVEZnRGdNdjVlSG9wMWx5YnBUWFhQcmtVWmU3SFYyck9mbDlLVlpkeUcyZzN5TnZTV1Ard0dXTFovOGU2QUJmQlVHaHN6dHI2QSttK0M0dnIyKzVKUTFkd1U5N1RGZnIzY0RQT1hlT3JaVUJUZ0tucU12SElycEJ2UnV6dVRsUjRUOEJReUc0WGRCVjZPQTA3N0VzWEQrcFlrWTJxME5rTTgrMmRITjFqTWtwbVg0VlVLandoR3dBeGNZVWRFZGsrSEIySGRoaml5UTY0bUt5MVlGYWhVdDNSOUJCbktUMUQyMXR1Z3hmekw4bHBzeHV2ZVRZMWJObzYxcTJnNzV0N1cxd0lBa2RvOG41V2VMOEpZeXJaOHFTQlQ1bWdxZC84OS94ek9IZk5wcm94VW5tWGVOM29kVHNEeUlMV0ovak1OQ1MyZHRXNnJMVnNyUS9waWpEVWU0RmxNNFJWc0FDQVExVGlaMWtBcjNiR09WckF3SzhwYkNKZHlJVUJ0QWNDK2FFQVNkcHBURnBKbm0vRll1aSs5U3FWVjl2SDZzWXdNNjZlMm1tMlUxZFJiOXNDQWhsbXBSK3FXbEhiUWlGbTFDOUxZV2I5L2ZtMUJ6cDdWT09iZ1ZuaEhsdVl2cm9hOHRkNjJHUEtYNVVUSStyMnQ2OUgyZVdPanpVS3lrRVNuNUFjd3ppRktocHFPQnZPajZjQk16K09OV2xQV09pVngxb1BuOTBZdHZjZDIwNXJpcnhrRWxueTliZkIyVEMybXFCbEp0VHd3SHVQelZidkRkbmowYXoyL05BOThLS0phRis0U3ZBMittQW9BQUk4QTR3d0FBQUJ1VGZhRTRLUmcwd0VBQUFBQUFBQUFBQURBZkJEOUJnQUFBQUFBK0FMM0NDYUM3Z3lnODlndnBtcEU5d3EwblBkdW9tQTlieWxyeEk3SjNkUnUwQldiUGM2QXRkTzBPdVhJalFvQnpxVFM3MzlPRlZ1SnJFV2YvOW5JY2ZsTnVXZnBXNGVMZEk4ME1iUjVGSkZsODFia0ZZekNzNmx0MU5pN0diMW1oSGRUekZaZGw5cXMwWjNNYWlDandJTzJ0YUYyN2xqR0xSMi8vcXF6bXoxeTA5N0hELy9zZ0FRMkhRVHg3QUpwNldyTDByWlZvdENOSjhCcXFPNTRIcmhrWDdaMGZObXBvc0dJYUpDN1pjUm5kbmJwZHdwb0pvNDNYNjBKdmVNNTR2Tmt5U1hrRU1CejBiNUIxTXF6S09tOW04cnZaVVZpMzFhVkYzVk5OME5aV3AydHNtQWdvdzFtejZjbXZOZEh6bWxvZzZIczJOSzIrY2V5UnhrUzB1L05qQjhBbk00WndkS1JkVmlkTlV2ZFhrdEMwc0NXd1M4NXZsYlBUcG1sRW8yQ2JmbjExVWJwQzZvV1E2SjJ2Z3VQd21tbFArYlowMG4zdkN3cnczcVRGRkowREZqcTdoMWZJNElzbW1MV3JGaUxsZXVkMVpESzNFOEhPdmI2blc5YjJubC92bVM4ZlI1akwxeEd6OGl5bUx6VzhtcGxlVFNEVjh0bXhQdzBpZWt0VTdvdnJib3Q1Ym9TdFJxaDZVVHRHTUJLMU9UeFhMZXF1aUcySHRUb2ZieTFzcXlobGxwZHh6S2l5eUtrT2hhbFBWYjkrZmd3VE5TUWtOSlpaTVpxUEsrWjhGYTNhUkhPVzlQRHRSVFBhMnZGWncvdVRTbERsdC9KcWtVc1JkcGFVMnJYNlQ0d0kzd3hGV0JHMEZnQThCU1FWd0FBQUFEUEI1c09BQUJ1QkdvSkFBQUFBQUFBQUFBQUFBQUE0RVV3UVFnQWNCblRmakcxeFJtN0xCM0xzT3orVk5zWXRTeEhxeWNkeis0T1dRMFk4a01teGRLNUFKNkd0MTl2SDM5QTRXZlQyQVBpcmkxbHVzaE52a1I1QVh6VDJxRkw2dmllamFBZmpPZm50dEIyUUczVmZRbklITGdLYmNmQUk1UG96ck9hV2ZyU3VFY0hnbmExKzVybE9rQ0Z1OWtSZE9PWDRlMThXdjY3VWZ0OW8zeWRwSHNSallsbjVJbjRSOGdNQUpEWWJaeWFUTEdxbnl2OUdtc2JNK1ZncjFxR2szamlnemxqVHNNYmZ4NkJ0YzBFVFdCS3poQk9UNGxHOURxMjJxZGpyR1d1aldOdmNTMEJ0cGY5QkFXVnFaQ3VpTHozOGhRaklqdFlaQ25QKzcwY2JkeGE4NVdYR2w1TStZVlV1QTA5SXlzekRtL3ArV3ZqZWlaWnByeUh5OWMrUk5ieVdqL2xsYWpTNFNXTThNR3ZMZys2aUM2UjZlMUtQZUtyUjBkR2YrL09ZOFJzbGlIUlkzQkk1M3M3WGN2MTNLK2pFKytQdFIrMDNLRGxuRmVtTEhVQlBJbHBYMHkxZkNZNUs1U20xV1VSR21VWjBjL1VuNExVdURKTnk5b3J6K01VK1BCMExvQ24wQ00waGNzZW5qSjExVXZ0NVZRdC9SKzJucHZ6bHBzTDl5UGp6Y3MvMEg5RkxHYmhaV0Fqd1oyWVFCZmVWU1R5Y21xRHpHREVmZzJkQ0lsa0wwalJ1bk1KM2ZtbHRCNThaeXdpeEZrS3RxWVRUbFR1M3FveW1xYVZFYTBqMGlhcExseE9nRG14dkpSNkZWRzVjNlc4V28xcGtLVVBwOVhKdkE4NHk1QzQwOEMxdEFYREFzQko1cUI1Z3lheTNxL3loZEZ5RlcramJMRUtLY2haMWlVWGJUNmZ3cWpnd2RuQmlDZjI2NHhaeTk3ZkhiMjNudGtOTGNxZ0pLczE0V3NSeWZLN1NkV01NQXRTUEYwYkFkNWVicERXelhMMk1peDFlZk5hMGt1OVB1UDNkSThvaitpSWxsMVQ2UUNqMElRRmZmQTBNdWMwV28vVlc0Nld0emIzM0JKZjBmYzBvdmZCbStmVzFONFJ5WWhmWmJ2cVBYVjUzRm9ZUjlDUS9GbjNmaWptZVB4eHNrS1A2V1BOaDVrRnN6SHRpNmtXSjlFVVV3blVkYXhURXhwZWcrdFNvOFJUdWZYbVRtTmxKU05wd3FOeDQrMVVBSGRINjljMXoxSEFNZ3l5ZE1EVDhMNWdhazZQN0lFbllKa3Y5NlMvS1pvWm9lVXJxWW5uTXJaMEs1QkhjQWR1UFVoaTNIbG90Y3pJa3RlSkNFa0pSSHgwNUNza1lJblhaZGZsY0NYaDZkU00xdHJMbUY0L056SUphcFd6WjhaTUx4d0EzcW96YnZVSXN1Y1BrRWtBYzVNdE04NHVJNnU4Y3QzT0NKMkFQSjJBVEYvMHFYTWEyb3JLU0g1TEhsWTl3V3ZKRkFJemFTTEw2MGlia3RaN2ZtMWZydFo5eVBleksvTXFWM21xckx2U29lOE5SbWpYN3M0ZExla1N5VEp1ZGRKZ216eVBXV3NLQnZlVWpQSlpXeS8vbk9rUFp0VVZOYk5yYUMrNWh0UlYxdmc4Yy9JR1FLS21qNlQ5SEk1cHJHWFRyODJjSVJPamNscXptbXBkUjNyODBiWmhHaTMyOGRyS0Y3bnVJYnBPMVBLZUJweEgxQjNhbEdJcSsvcHN4OFRyNS9tZU1LMGtsOHJyQUUvbjhTK21ya2xwTFBraWE1RmF4czFqakpQb0Q2NGRReCtsNWR3aXNtZ080R3BhSG1ERHVsdUwvaTRaZG04ZkRrZGoyL3ZsMUY5SVNoTGdDVVIyeEpySXBySGF6NUlEWEl2TFBOSkJSam5BS0NLRDVFSDk4YTVOSGZWUzZtTkZCVElPYm9KbFk0eGVPOEs3NDJTWmwyRXlDV1hzb0JWTGFCbTdIczd3aXpQaytZMDZldGJQV1JMS3FaWFh3bE1YSVJNQWFJMTdiU014N1h3R2tqek9kQ05LZGZ5WElYME5aQ2o4MEd2VFpBNnFrZmFWMXpiVmhJcVcvckhCWFlBbkU5VzRuc2tycitmVXN5aElPKytrK1RPMXhRSkZJVnRDZTM0M1FqZ2VnZlo4c1pSc1pGdTVXZWw3eTFyYnlYb21SS0xYNFpGSVBXdGtGOUxLSGlIbHZINXdobVpzcFE4VFZUOVd2NEZ4RGxkUU03T1d4bkdybkJyNHYyYXVtSkxTNVBDaVhHOHR6OUdtQzYyMDdvdG5mVjJyN01lU1pVaGtkYjRqVjVqL01JNXM5N2dpRkxRcWxrYlR5cUpiYVZzcUQrREpUUHZGMUR1eEN4R3Z3WEViUEkwbDdua1AwRlR3TmpiOThsdUh4WWV6L2YweTZvcU1nTGNSY1R4ZlRFUkVZQUlDSElpc3kyRVFoUmtkc09QUkFNd05ZM3dpeWdCc09kdHN3YnFZdjB6L0JMd3JBVjZBdHNnaG8yekNMd0JRZ2x6NExTTjdGdjhDdVBBbzZLM3plaWJldG5qVGx3c1lFRlFBSnhBVklwRjhXUUpyUzByVHlyZitkN2kyMGlLNDRFbGMwRWZWb2JqRzh4THdtSktSTWJJbmc0WXA0R2JBU0xMMGo1U3V0b0FmcW1SNEQxbEw5S1RIV1o3WHByK1lIZ00zeUl0N01tSzkzZmV6MWg1NUxSS3hMSFFUZ0pKL1gweWRVUE1lSnk2dFAwMHlZR3BsV3NxSzdJS2gxYUcxMGRNbU45cU9NcENIcHVHaWVRRm1vZWpuMG1hbkVWMHdFL3Q5K1RLTXYyL0cydGhJZHRzVE4xaUxEV2JYd3h5aFNQVG1zd29Kc3JGdVgvVHdQaGMxMlNJbXhDM2RDRzFsbzVZWG1RTVpXTFpSOHpwenRUd0Q1Vll0b0M5aEhUclp6VzN0Zm1sbGVuUERHa1N3M0lqcy9ndXZaNWNkMlYyREx2ZGlwTVVHbzhxUHlFeHRCdDFxdEVkK1YrYmdhTnpiMnM5ZEc4V1VlY1FxdnpmYjJnN0hyWXhueUlEZUxsYitmdVFYd0p6MFR0bDQzRUROWkxldTg4dWdKdHN5WmVaK2JvVE1uRlllUjM1WVpQTXRyVHh2RzFwbFhSR01zTlJWRW8zbmFBTTlVcVpVMW5iNDJ5dTRBTURKS0VHMUJlcktVQlpXSWRLb3ExcjlRVkI5T0lnSHdmVlQ1UFo1TEZFYUxLYkUwdkZTRkpiaDRIdFgzbzVVdEY3bEg1blVhQmtlUjNwL24zZjFueVZ0SzUwMWIvUzZSS1dEdCtKVlc2TnU3VGE0eGhMY2hReUowZXNXU0hoaVpkWTJTTkpvRWM1dlFwN0lLTmR3RFIxcm96S0RFWXh0OEpBZDlNNHdhNDd0Z0ZSNnA2d2lIb3Vuck9OMUR4N3JVOU1MMHBDUThqK21xKzQzUFRwR0krNkNocmNzaXdrZmRYZmhlcXg5N0R1a3NPMlhLdWNQaDFXMExnYndGdjZtMTU5THI1M2NrNy9iUm84RWtySWNBd0NBR3B0KytjMXFydmFGMU5ZOXNRUnNFZXN3TmQ1STBtUllaZVpSVmlBVEFCcGtEaGJ2K3BPWGtCRURSbzRCUEI5dGJwdHhQamxhdkRMaTZHWTR4bGwxWm5Ub1VYYUVjRy8zMCtueG1PMnpqanNNN2kzNU92SUtZQjZHeWNLSFkzR1RyYkp3NUwyZFZoN2Z3WTY0NHVhZXFYQ3RjK2s5Y1doSnVIZ05qOWFMS1FCd01pTldBWjBwcUxPRmlDU3dKRXNDd2ZVc25td2xUOURYb2lLREFNYVVaR2dRU1JyWHVrenRPaEw4aHBRUGk0Y0VYakoxaGxVLzBVOHY0MHBQcG56OHBiZHdoMjZ4S3Nmd0VBajJQeE5ObUZTZTYvRURXVDhmZ2xycWtRZ0ErTTNmeThPUmJNdk11VFhwdW1XekJPbmNxcVJ0bFczRnN1NUtMYUMzRVZyWnk4QTZac0t6elFMM0VsN0Vqdzc0SGlPMUw2ZldaUGViaGtuNVV1cit0N1ZtOThpdmU3WDlMdGZlbUNVZXhRYm80ZVdCZ1JGbWhQWXkyQ1hEVjNJTVZtTzY0eldBTEN4Yk05WUcwdzM2NGdqUm1lbS9MMEpaSUdDOStkNUFSNDNhRG9NQTN4eTdSNjFibnQxZDN1WWZUbzNIMGQzVDkrTFIyOWFPN2kxemF4eWZRZVBsVkRIOXN2d1dBSVoyZjhTQUhMOVQyeEEzZzk1YmZ5TVRFQUFTc2NvWnEwbHVsUlZaYW1ZVTFqWkU1RGUyblpFN0s1NHo1cVk5Wlk5MlZxSy85Mmo3YW1WSTl0ZFN5VWVRQlY3SkZVTHh5anF6OG0yT3RGbzZnek8vSGM5dHhYR2xXV3BUOWhXbUFlZFV4U3FRdlFySk1wRVF0U0JyU0dWM09QWmkyZEw1L1hkN0E5TmFQUjRzQ3RTVHJreFQrMzNheEtZMzJGKzdYbGxsYmVHTUlBdmNEb3NtV0J2bkxldVVGa01kV2hxcE8xc2xwblMrWjA3RE95Vm5NdFhMSCtyOUlaYkdtUFVwZ0lQYVlHenBvWWdhcDgrZXhoVWVqVVFaSXJIb25XaWMxYUlUclV2WHRQTzNKMnFpUy9rMUplbkIrNEM5Smp6Y0MrK0VnM1R1a0w5Y0d5OTU1TkdtQU16SzMvVCs4OWdGVThzNXpYd2N0MzYwT0xBQTBFTlFlTDVkNUpUT2R3MnI3c0I4QUhnM21iRmhnR2xvUlppMVdVbE5RWU5JemNkdUJRRzV4UUQzSXROSHkxaGlCdyttdGZxcGRqNUNOSkRyNmVnOTZ6alA3TkRSdWpyYnZBYnlTRmlYZFI3ckh1VUhJWXNBQUg1aldlcC9wU3A4TkhlK1VadmoyaE1ldUhlRlk2UnN6ZGEwM2pmbTdPRzFYQ0ZNN2lqQU1nU1dkL1d1NUpWcDFGWmVIY3RFb0kxamxudDc1MzZTSFMxZGk3S0xjMTV4aE1IOVNxd2FZTmE1dWFqRXlCek5sMGdzMUNtY1FWYkEzZnIySUtSeE43bGVlem5WdW9Za1drOEx1dUFrOENDZlFYVEJ1L0dsMUZwV0swUW80RzA4L291cDJsdm5KUmJoWU5uOG9IWGVXblp0amRRdEhYR1BWS3h0QzlBNmhoamNVNEF2ckx2SFdSM0NOd3lscjk4cC9OQ3RUUGpyNUlLbERIT2lDWS9KaEVQdno2dlpzQkpXdTNvSXlERzRpbHBreVRwWUhpQnZNcHFZOVRQTDNTN0w0eHFYeXFVck9WUFg0WjlDQTgvN2d0YnhhdlVMTFhYQ0E5RTZTcWtrYW5relpXSXRGcXFsdDlRNVFvRmRvQlN0UDlNaUU3THE5R0NWSVpPNmtnRGd3Q0xISkRHc3hiUmI2cXRsTDlXdWU5V1FKdnM4Y3E5WERTTmpiOElUSmxha3daZHBUMlhZY3RMN1ZkNjJSTW9nWGdwUUlTSXNOT2R6V1d6T3FmZDZLNC8xZW1RaXhhSUV5aVhpRnF4MWw0ZmJkM1ArL0YzYjJmYko4cC9qZjc2UGV4WkhhVVNlcjJURjlWcHZuajZsM1JQdmlqcFBNS0puQmxNNzMyc0lTUGV3dEc1cjZTU0wzenFyb2FUNzZPZmI4dnZsVkRuckI5dlAveGJ4OTdyR0RQUVFIYlZuKzJpOXZiZ0g2N3F4aUdTMG50Tk1jckZ0MWlFbU9mYVdRT1dpTkVLNkRoQWxZc0xXeXVpWlFJUmI0MzJNbXA2U1BJL2FkWXNYMDdyV0VwV1NIbjZkZU0yUUFaWTZJcWErMVNob2xldWRENGJ6TWF3aCtHTnJIZGZTYXkrbGFtRm1xVHV1UWxsSDA0NHVCRFB3K0JkVHZXaSsySm5jcVMwbUpFZjArRU0ySlk5MkRBQlEwcEl4a0FOV0xid0ZMZUsvR00rL0hJOVl2dVV0MUtLRUFCbG9BY2l5SHo1WTNsdzVuS3l1NkNTM0dnQVNRUmE4aUZyOFVpTERMN0FxSkNtOXRkd01tT242UWd0WGwzWUVyZ1FBV0RoelhjcmJaQk4yM00xNHdnTnBLWGR2WHV0MTdSMFZLYzhWQVF5TUd3Q0J5Q0FjNVhUMkNBVHJpbHh2UG11YXpId2FqMXVCOWMwYnJUbVV6MUN5aHNGVGg5U2s5SVFuby9reUh2K2JSanlTRGFBZ1M2alVGZ1F3NEthaTF4dmF1OGlxWEllSDhTUWpBcG4wV0w1a3cwR0kxTHBkaGd6eHZOQU84R1QrZlRHMU5rTTZzU2JXUXF2V1RSQzB6WVlzdDNBMVh0OGMxeTlaZE52Ylo3VHRUTjZLZGFMU0F2Y1Vub3kwa2tkYVVMQjlIaTZWNUdXUlV3OE5TVWtzaTd5SnBYRnVkTSsvbGNldDdWMEE3czRrT2xNekl6dy96K3N1WEhJTEpYdXkxcGlhL2tCR1FTOVN4NWNXRnU3bkkzM3Z4RUVteVpLN0JNWXM4cW5uVms5TGJ6QmlUOU93TTduaFVPUFl0VnF4cm9qN1lKVkxkTTBYWVZWZWtoMjVHTS92MTZ3S0tRdUxVUjZSMDRsMmh0ZU8yQXhsU1dXczM3ODNHaXJWVExuU2hNdGdFdGNUQUFTMC9RZzA5VlBMc3locEpOVWd5VHFyL05Ga3BYUk95M084N3MyM3AwR0duc3dWTjEycU02c3QwbVM3TjNpNkxPcWNsWnF2RnNEUWJEcHIyd0JleDkyMGhDVElwR3NhbHQ4WEVXUlNYbzlETE9WeHRpRjBlNzR6bForZUs0MmZYNFpZUkZoRys1YzBhVlc3eDFvZExVKzJsYzVpM1MyR2F4NHNVY0ZzTXJ4dXpXcTNSaGRxbEZhOE51NXErV3JIKzJHeGtLTXMydExFMVJyUmdiUG82WEhXTXJPcFNialJlSHpXOG5wRU1scTFxTFNNSWFUU05kR3hPUnRqcVJzUkFLUFJ6TXBvOEFtR28za0x0Zk8xWTYwc2EvM2U2OWJ5UFJhZWxQYzFvdFE3SGlVM0tWS0hOcys3T2E1YlRYSzRENUZuY3NoVHMxMjFibENtMCtab3RvVXVCSFB5NzR1cEZtMFBLVWpPOXRaSTMxTlhDaEZycXJjTytpQUEvTUVyTktIT2JzMGU1dUwrdkRpNkpsaTF2OFQzRlZGbEFDL1J3QVdZNFJiQ0s3RUdQWThUS3RIQmNvTkJkaWVWWDVnNmtBRTNGRzZNRktRbmVEODUxZ2Vjb1JTMFRsYXJjekdtemRUaFhyL0cycVprTytPME1UbklQb3FFcGZDSEFFQkNXbC8zRkVhNENWNjFDeGR6eFlQSnJuT0U3V010dzFwM0szWmtIWWpTeWlpQTEzQW5UWExuMVVCZUFYWjhsWVlBWWk1WHZickZNN3duQXhaeTFLcXdyc2VobTl5R0swM1pFV1VSMDFlNDIyUXN3R2dHejFYQU9VUkRKT1Y1ejN2elpYcXNYQWhCeDVrRHF5OXo0Yk1tb2dLejh2ZnljS0pHeUo1SE9sL0w0ekdZYXUwNnpoL1Z6cmZxdGw1ZmpOZTdpRzV2QW40eVp1S3RuUWJnYmtoQ3M1TEV1OG1OZEs3RjQ0ZVNzRUZtdUxoOWc4Mk1td3R3RmkvVGlWbG14Sjk4L3h5T2I0ODFvTEFKL3diSVFGdHQvS0RWeU5KT2NKTGY2eWt6OHhiY01KWjRQcEp2ZnJ6bU1aeHJBVnZMUTBPbXdvR0luRGl6QzVYZCtrSGlHVnBFaGI5WFFaMmhaREtNZXExc3kwSkZTN3BhMW1KUVpkeXlmYk10TFhidi9Yblc4eDRJeXdKQURlc2M1R3JNcDVWUk0vRjc1aUtqQzQydDlNaE9iTG1Da1lySWVyUHY5RUR2cEpndGJXbjlmbFl1QWR3Y1MzQjRXWEkwczZkTm5qSmFGc3RhcEpIeWFtVVA0S2ZaMitleDlIUFdSVWxRSmg3OURFWXBxVWlkMllyWTJ0OHoycEE1cGlMdGpxU3Y1WlhhSU1tUVJjbFhtVUFRWDByVnlvWTNJUFhFTXMzWjhmeEZhVXUwUFY3dGZNUzZqbGNiM2E2NXVxMDRYaXJwYXBXMWZBeXBEWWdDOEpCaHVtcGxSNi9EY0VaWWJ0YjB1NmRpV0hKc3JrUERvaHV0djJzNjY2djhJWkl2cHVtbk1rK0dZcTZWdStlcmRheGptckl0a3Y2YzVrRStuL0xSMUo2TnRXdHBlTXFnaThDTS9MVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmo0OTR1cFdhOTZYNEQyeHJpMmVjOWFTUnZaK1VncXMzVysxamJyRGtwTEkzMzNvOVEyamF1bDQ5WDk2NURHYjdRREE5eUYxazQwNjJjU3FaK1AyTVB6aVd5TnhuOTlhZVFyMFgvSGxyeGJrWDdyMmFvZllEVDB0eW90VTBIYTJFc3JxK1NXdDE3YmtoUWd5cW9jZThxNFVYKzA3Q2xlRzFZZTB5Q2JEUGYwa2U3VTZyaVdzZVd6SlVBQnIyY05wdEcrVCtFNVh5dTN0SFhLNjNCREluSXMycm1rTXErTWY0N29uRlpkRU4zaWVwTmpCZHJHd1UwN1lsdU9WY2pwbGhpWmRrUjUzQ056Q0tVQXpJY20rNnhpdW5hOVY1WmRJVzlhbTg5YnJtY3l6ZlRheUIvZy9keURsZGE4MERGTlk5NG85QVVnS1cxWlordTRsci9Ydm9yRUw2WEJvcVhmODJRS0U0RFhZTFhXdFUrcTFOSkwxNjBla1NRMHBUcThtbFlTR2xZblBRbE45b25YZTRLakVoa2U0QjNRbE9FSW90K1hzaXBNelhLMkxMenlCbEcwVHFtbGExRzA1V2ZoUm5IOUo5a3FWMStlWElQanRWeEVBby9HWW01N1RjOUZLTk5LanhTeXhpTXRta0VMTzJ0MUxjcjVKbFlWWDB0dnVZNC9BTDFZaE1meG11Vzh0Ly9TZDArblIzUnNDZWRYNGQ5ZWV1T3dyWEJWeWRPOEF6ZWFMTkFVYjAxUmU5M2FucmhrNjdwMExKMkRjeENlMzlhNHZxK2R6eDZQcUNWNEszd3hGUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJNL1B2RjFBbTJYckM4Vlc3ZGlTSzZXWUtYdGFQdW9XMlV0b1FxYjNKdDE5cmExaVBUYisxeEVkck9WOXgzbUFWcGQ2d0RXL0VQU1l5OWxWOWZRUzJ2Ly95dmthZ29hOS9zY292c05JUjhnclBwMmU1eVFpSWZCZER3N0JhM05OS21QZ3JyN3FCNzVTZ1BHSVcycGE1bkEvQUw1TmJxdks3OVhDMU5EK1d3dHV4dmJpbHJTcVRkSEM4UjJQQjJldTJJUGQwL25lWEF3N0RzU212SjEwTkwwVWpYeTNTV0hZQmJaWGlVM3lLVVBjTCtFT0l6VXRGRnRucmFkZm40QW12NWNZQmVMRzZpdGE0TS84aGFKZ0RjQzYvWVhpckhtMUttdExsOExjKzYyTDVxVXg0dmxUeFd5cWtycnk0b3oxdmtjemJJM0FwV0c2ZVhpS0xWNWt1OVgyU3cxS2tkYTIwb3o3ZnFzMzRaSm5xOVRKTnBMd05NVFcyeHpISTRaNkVuUWxrYjVKcFZVRHUvT2RPWDE2eWFYQ3JybUtXY2hHNElKSzloSlJhVnFkUjZyWlVPNTd1cmpHaGRWcndXcHVhVjE2NTV4MXlQMWF1VlliSFdXM205NlE5L3pUL2prSEQvUkZBanlVZFZVaE9PNWNGdDZZMmhlYlhTV1dqdXdJNVY0eTNDK1UzNGR5M1BwclNoVkhsbGdsVXEzTklJdGZKS3VRQWpzUWdQNmJ4Vi95ektlVGlWRVpib1dWaXQ2NVkzYUJYWFpwZmxEbVM0R1ZhOWxlRVdSV1ZMRFcrd0c4NG5PdEd5L0dlTGxYUFEwZWRzSGRjSlZRSGNFcjZZQ2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBbS9sNG13ZlBHdUhYUFFDbGZaTk1INis1TXExQ1haVSsxWVZoMkQ5QnVLdVN3R3RQd0RPQ0psREpsazVPc3dwWWk0aTVGMG01ekw2VzVFOHRoRjVpdnY5dmgydElRTDVhZGd3Q3V3cnJqVmNZT1h6Zkcrb1VLNythYXg3eldQSzJ2ZFF5alpXQWpvMkFra1MxMUpXN2NWdzJtM09uTloyZTVBOUZneEg3dVZJRU5NK0sxSTFycTJmckJJNms3TDQzcjhHQmFja3RUQ0sxTzAwclhTaU8xUlVyWHlpOWQ5KzRBYkVVYlpKRnlsWHRycWtMSjZ5VzY2WG9OYTlqRDJ0VUE0TG0wNGlOSEdWQWVMNHRkTG5uQ3NKcWN5UkR4VXBsL0xYMGIyL2VxSFl1UENnNTZiMkRtQXkzUFJ4V3NaekJGc1JvVVpZZlZQcjFSeSt2OTh0R3F0QUVBRkR4Q1pCWCszZXVzbGYrdTFWMWlqYUpvd2tjcjM1SjNGWnIyMStjSjFhZmVEc2ZyeHgrL1BMTUVSeVY2RlVlRzRzbjBPck9Vb1hjeTF0T0hORHgxU1dPenRPSnJhY3I4dGVOVzNscGRudXZLK2VQWGg5ZER1bDlPU3FYZWFFd05XK0tXWlBsRWtkNnQ5V290WFF0TEdTM0pZZzJ4dHFpNUpzMDZ0OC9qTXNIeDYxMzFBcFpZSTQ5NXBlT2FMOEtZaHF2d21oRXdqRE52dlZUWENGR1VHVXFTMG1oVzlTTkU3SWdIbjZtSXZYVjVEUllMNk16cnNicVl3ak5hVDN4Mm1Gc3dLM3d4RldCRzBGQUFBQUFBQUFBQUFBQUFBQUMzZ3lrY0FBQUFBSUNuZ1JVUDhGU3VHTDFJREFBQTJFRW5BQURBRzFqLzUzLy83Nzkzd1J0Yk0vejkvNVpibyswTGRrVGJnYUtXZmxuc215UkVkcy9RTmlYeW9HMGMyNDJsOExUSzRJTmFweW5QQXp5YzQxZE4xMS8vK0V4ajNWV3Z4c3hEYUt2SWlxOC94Zm5hRjJTalg1ZDE1VU5Id0ZYMDdLWTNRYi8xMk11UmNtdGwxOUpjaG1jRGM0QVJQS1NQV2ZmY0h1cHpKc1B3cm1EOU9JS0hWakFpV2laTWoyWkhaSGFiSjhrdENHQ05WOWJTVzdkZnpyQW52YlBQbVIxMHNEeHVqV2ROelhTcG45VWZ3L0NRVVhTMkR3WUF6eU5paC9USURtdnMyeXFYUjdnSmkxQkhlYjZuanBZcDRLMERKc1FiRzE0TTZVZllXMXJkV2tEV2FuOWFncndBVTNDSFNFQ0dSdkpZRWhZSHVKYXZsYzVTaDRSUisvOU1QaTlLT1llMFVuckp1SEY1cVZGbE1OS1M4cFJ6UkZNU1Q3R1NNaFN2WlN4Wk9wVjBYY0tpMUsyL2E3V2Qzbjc5NHp1b3N0aUxGb2Z2OWw5NWNGdEdoUzkzV3BvZ0tzMHNvOXo3dTNvMG9PWmpTdmxhNmQxWTFaR1dYMUo5QUhkQ1U4TXduRE10V2MyS2JzbHBpM3kyMUttZHQxeVBla25URUkxVDljelJhbTNwbmYrVmVPVURIa2l2KzJzVkdwb3dXZUpSRFE5MEdaZ1J2cGdLQUFBQUFBQUFBQUQ5RUQyRlpPaFNBQUFBTUROdnNYV3c2UUFBQU9BME1Ed2dIVG9WUUFiNHZ3QUFBQUFBQVBQeTk5Zi85N2ZNbjdMcFdZUHlMWFRKMmZOc2VLRHRZN2NwK2ZhODVmR3h2TWd1SDR1aFhtOWVWOEcxSDlCS08wSC91cHpXUGErbDVaN0RBMW5MZzBwL1h3VmhLWDBob3lhL3ZjT2pad2Vvcy9uNGV1bnhIdFhPaHl2NStPTXJEdGtFVjlHN0pacVU5aUY5T3ZxekxMdUJMbzIwZS9yVzlhRjRER2pzSnhoSlpDQmNNSGdrbi9UT3RsRFA3cGUxTXFaQUN6TDBiRG1xMVdrOUQ2K2dGVXJTMGg3ejBJMUFwZVg0VzdjMTFjNjNaS2UxQTB0eWQybmtiN1hKZzdVdWJ4c3J5WCtLK1A3OW1YYkVyOGZaV2FpMW0waHB0a2E2bGs4RkFIUGoyV1RkYTVwSGR1U1hybXNxTUVOK2U5VlBKSjBVMXRrYTZWN0JuUjE1QzFaSHdKTXVTbTlIdG40TllrL3JlV2Fhc05EeTdXbGZNekFBN2lRVU16UnNiU1dTTUVIOGdYZlExNXhUTFpDb09MUy9aT2NxSjY4YU9ldS9UdWVmaWU5TnFGTTFwTFo2T3RYaWFESENrcEtlczRUVks5WEtpTFE5NDNkYjZ6NWpWbEo3N3Q2VmhLMHl2TmUxTVdYQU9uWisxYkdQbmZYekw5d2E3NGp3eFBhUGFXb2FJbXBPWjBvUzZmZEkxMnRZMjFlVDJyVjg0WkdUSVo0elJTWEFrWjYrWlIyNDNZTUlyUFE4eGswNGI2M0xveE9pTWNDSWxWeGV0ODRidlk2SUlTSGx0NWpMRmhmT1duZDF3ck9SRG5Mb0hUakc1LzNMTGxzL3IybVAvUTkvdGF2NFZaZWxld0xNQUY5TS9ZYUJEVk5DeHdZQUFBQUFBQUNBaDBONEF3QUFBQ0FYN0NzQUFBQ0FKNE0xQndDZ2NhV2tSRW9EQUFDY0NJb1hBT0J5MXYvNTMvOHp2V1ArOS85YkhvRng3ejF6bXFXUmIrU3VGdHFMKzVaTmpLTDcxNWxwVlRhODhwY3pZdU5DZ0x0aUVlQjdVa1BmWjRqOHgrYTRFZUttdFpLQ1dvVHJBR2RSMnpscnhNYTVEeFFxMGR1UWFVOWI2MHdGZVFSblkvR1BlbVhJcVlQb2t6c09xWnJvYjUwdnI4RmkyMFZROC84djdKZHdYelE3SW1xR0hmTm1kam44eGdueHlDMnJ2N3NJNldwYzJhbGFkc2l5UE02TzBINU90UHp5OFpmbk0rb0FnUGZoOFVXMHRUTWpaS2NsMzdIdUVhckRJbi9oaGp6UllJN01hWGcvU0pjeGJ4STFPS0tmWVdvSktnQ29NTktSeXRTR1htR1NJU1FsWjF0Q0VWVHFJcWhLWGZzWFZNdmZzWC9OMFd1QXBkSTdHYmtFOGwvbytJczhKWGhzRFhwckN0aXp1TXZhSVpXWjNwK3FOV05ncStmVmdpNjFJckFoSG9YWGxNL1FUdFl1SXBuWGticWpTMFE4MDJQVzY1MGEwVWFXSHdGd1I3ejlGUDEwSzZ6aUtVUG1aOVB6bmtaVUoweEhoaUZSSzlPNmpzVlNkL1NoRUZPN0p4YjNaMCs2eHJwU0xiMVFSVE1QWFFobWd5K21Bc3dJR2dvQUFBQUFBQURPQWg4VUFBQnVCR29KQUFBQUFBRGdwYXg0aEFBQWNCMjMwRUtvUWdBQWVDdm9RQUNBeS9oN21RVHJqdWFiNDdwVTFxYlVhYTJyZGQ2N0sxUHRMZnZOMENZWHJjWllHcFRTaUpjaGRiTFc5Z3FlcmJ3QTdzVDI4ZWVMWC9KVjJYRFMwdDJQV1N5N0Y3MkZudzFrQmJieTVrcHAyY1lGN29pbUczc0cvNDBGaDllTTBIYUFzdTd0cTVYcHVkNUYyWEJzSWhoTnFRTXRnOCs3VFcrcnpndTVpeDFsaVFlMC9QakhFTEczdEtDSlJWYVdOM0VSMHVLVFFnWHI3dVNMa3E2VkpyT3IwVjBmakNRalYyT2UyckVtT3kyMGdoSGw5V1hwNitCbEhSYi9YU3JIa3E2RHlKY0x0SjhUMWZGbjJoRVpqeGtBbm9ISHh2R08vUXlab2JYUEVqdXlZSEZockhFc1pPVkFQRGYzQm5hRUdvekltTlB3eG1VeURCWEx2YlVNS3V0blBSNGRJQUc0QzFuUjBVeWg2UlhVWG9GWGx0UEswK3RVSCtyZURvc0NOa1ArOGlYVkxwbG5YVjB3d25xSnJ2N3llTnRMSTYwMW5hWE16RG90NWRUcWpEd1RyNUszR0NsYXZxQ1MzMVk1LzlldHJkUlJDM3hzbFRyMnZMd0EvbWk4bzhzakFiejV0TFFSU1JEUUxoLzVXdEs3cGNHcVEraE12T3ExekxjSStTMWlDZDZGVlkxbW1CdWxmanFlMThvcjY2Yi9kdUd4cXJRcEtrMUdXdVduRm1Oc3BmSE9UVm04bm1QZVdyZDlMUm15SXFwWXJXNkE5cUNsVG9WY3VRYXR6Mmc2SXhBbThKcFpWaGxDRjRMWjRJdXBCUXh5QUFCNExTaEJBQUFBQUFBQUFBQUFBQUFBQUFDQUc4UEVQZ0RBblVGS0F3QUFBQURBbTVqbWk2a1MrMFlKYTNHOExQS21CNHZ4ZkF2TEhuQzFObW41TS9mUUc1OFIwcmprd1FPY3pMY3dMT1gyQjhJV0lqOGJNeTUyckhKM1drWnNnNWlSQnlDTFM3YWh2Q2ZaWmtSTlR0LzZWdE1QNEd3eUJzZU4rKzJUaGxURS8zOEVUWU5ad2JQYm8rZWFwVTZBQTQreEkrQloxSVQ5S2h4Ny9JWEl4eSswc3F6SDJ2bmV0R2VVMDFIa21hRUk3WXNIcmVOb1hkYnpBUEJzUm8zdGpITFBranMxMnkvNkZSdGs1VUF5Yis0ZEh0UWQ1elI2eTI4dGVHRGxPOEJKYk1aemR5ZExJRm5LMGp3ZzRWc2ltMVJYOFlYSGoyUmJ1K291V2VrTkluanplUmpsbGZha3ZhTWg4WlNGVm9kKzNReitkN2JwcDRyMWU0SE5XaTg2RWp1RDE5TmFPOURqRDBiYk1qcGZOTWJwOVlORDl5bDczUGJNU2NLY2pEQU5vZ0Z6NjJDaC8zYmplVVM5M29FVnkrT1BXbFU5Yll4MjJ6TjA1QzJKM05Tc1R1VE5qeXk1QjFGaFVUbit1TFIrL09seWg2UXFJL0lLNEVsTTgyTHE2cmdXRlJaQ09EUk1HVnF5MUxrSTZVdUhmbWhzeUhxekNWRDFJM1dBbmp5Uk1nSE9vakR1UHRqazlGSi9wcnNMT0c2SStSNjJGQlBBVldRYmJ3L0RLd010NlIvMVVpcEtBTTdHb3d1WjBEK042dnFrWllMYm42WFR2TUdJTXMrVU54ZEdjb2Jib01YTWF1ZHJaZENWSDRZVUhOMkU0Mld4ei9wS2dka3JPa2xHM1pQSjYxRnlwWGFiZW1XRDVLSWlid0RtWmFTdEk1bnFsanF0MDBpTGtzNkRkYjVUUzYvVmdVd0ZNMCtaMCtnZEpDK0xpUVA4NWdydGtMVWlhUVNhUnJaTXFHblJGZXQxejRUMS9pTGRucSsxcU9BNy9aNzBOTHdlMzl1dEhjL3ZQOU43OWxyVTBubnZXenV0Z0pXM0RZWmtYMlBLa0haZDJ3bXdNMTZKMU12TE1Pd3hiUzM5SXFTejFKV0JOVFJjNWhuYWxwNGYzSHV6cktvZjRBcWlmWkMrMjgwWmN4cldPaVM1dlMzOUwzdU5XbDhudGVmVmVGM1NIbmNoczhNaVQ2NUhNOFNLTU1IbTdRL2Z3cUwwekZwTG90WllGZFh6cmVzQVQySDZMNmIrSWJwNGZsT092VVNjYis5NTdkb1F5c1ZkTFY1dlZaMEF6d0JtUUJIY1AxOUl4UW96c3gzK1VUT2N0MDNKQi9CRUlvYlVpOW1TMGdEQU4xSlFiRld1MzVSYithQU5hb0c2ZFNHQUo1SVpkRUJKUUFQTG9vNHpzTW9DdXZNRGtlS1RxM0M5RlpqVjVCd0t4YzBvMVhIR295anRpRXdURGxrRE1EOW51MzB0RjFSTDU3a2V3YXBlcytkaVlXTGU4S0NsQWF5dHVLemxaV0RBYTdtaTgwZnJ2SEtnUnVvMnZkVzIrTXV1Q2JMQzBhLzUvV1d5NFd6T1l5MS9wTTRuNC9rdDJiOTd4R3lISjJoMDhuUDAzbXJQbUNKV0JnY3NMLzFFTmNJSUlsSTZ1dWE0UEw5Nk0vWlUyb1BtZXdCY2hYY3cwby9EZUMzY2tYVzBIcWZsUlRKUEczclRsK1pVS3o1TDkxU3dHQkJhcDRFNU1QYUQ4R05mUDRzcVpVcXRLM3JyYW0zR2d0a0ZNekQ5aTZubGVxT0l3TW1hREQyV2RXUnoxT2s5TDdYQjlWdFdZNXJOY1I1ODlFd2VablpnZ0ROb0NXNmhQNjhKL1h4bWNiVVYvL2k2dFljZFlyYVBSTi9udjY5djJubXNZYmdyM2lqVHhQU2FFVnNsWDh0Ukx0TmVEcllRWElsbEZ2YUl0WjllMksrdHV6OWV1ZVNyRnJCN3ZjbGl2UUd0Qjl6eSs2VThrWFR3V3M2U0hRVDFKMGFiYlc2OW5LcVZ1eXh5UUhZUnJrdGxiWVl5VnVIWVVxYVZDK1N5ZHNzOGF1ak1jZHpxU3BienZYV2pPZ0dlalZWK2FUSXhJdmU4ZWM1UURiMXR1ck5QK2dydWZIT3RrK2dqalFoclhWRmpwMmJMNHR3QUZOeGRVSjNWdHRFZVZDdElHRDF2MWZLVnBwaXJ2c0FSWG1acFEyLy92YUpPRDFydyt3NTRKNXljUldZc3NJUXBDVXJucm5SYS9oSCtZR1Q5ZzdVdXJ3UmNsNDdLWElVdStzczhMVDBMWUtFMkFMTDBqTFZ2MG85UDVhb3BxN3VFU2xybTFmRzZOdVVJQjJvM2RYUTlvK3VDNnpBT3RreVpzaWFsQWJnNzA3K1lldGRZU1Ntd2V0dm95ZDk5UDA2dERLb1FCSVMzc2luSGxjc1liQWVSOGYyUDQ1ZG12YUlFMFFPUG9hWXI2Y0JkN0xlMEZlL2hGZ01vWkEwU0Jsc1ZUVTVoRndMTURlRXErRVV0S0ZDK25Hb3R4M00rb3l5UG9ZMWpQNFRJb29DdDgzcFdIZ0M0TDIvMlNiUllmVlJGZXNxQ0JKNTRjNlZPTk9LOUlLMHVhMTdMZ3J2ZVRWTzBBVWtRQldBQVp3clJyTmtiS1o4MkNkZDZ1ejZ5WXdDQ0NXQUkwdUxGRVFFT21JN2FuRnpyL0JHUEJpanpuYTBOWHFPQnBCK0srb1ZlTnVPNWFGbTE4NnR5REVQSmZyelJkUEJ3N3FEMExVWU5QQStISWJvVmErMEJvTTNuaTZrUGZ0bXRaVnZ1UDh1NzY1QTEzdUtsdFF1R2w1RWJ5b1I0Y0I5NkhMVk5Mcm4zTUNsV1cvQW4zWGZDUDRZaFR1dS9yTC8rc1h4OERmWFBQZnM2OUU0eWJQL2xMOHMwTndyWkJhUFF0clhja1F6SlNmdW1OT1Z2K2JuYXkxNHZ1NVVBUGp5RExESkFCN01xMSs0eXppVTV0UjlyTzFGT1Q5bTNlb0tvWmJCRnU2a29nMWZUTXIra3VOMkljVXJvNUlYVUpneHJNYlZseWRHLzJmRTZyN0YrMDFpaEpBTisvYnpHNzkwYVpXVDhURXZNeWFvMk0rUVg4Z3BnRG1ycXhwdTNOK2JTdWo1NlBuU3BsSjg1SDlxcWE4K0RMRFZ3NDFqRUYwOEpPdHlsRHUzNVdZeWUvVzlQekFEZ3NUd3RhaGdWa3RwRW1iZU1WaVMycDl6dnN2WkpiR24zWlMwZXVWcUY0eG5LY0J0UXB6ZHZKTWpRZSs4aXY4dWJaOFJ6OUNyVUxaaXVkZDRhVmJHTTY0ck0rQnF1cTNqNVYvWldsWEJycE1kckhTbWVkeFpIZGcyclQyaU9Sd3JwV3VlME9ZMHluelprVEVQcUROUEVLc0lBV3R4cFRvTStmQm9ScXl2N2NXZmlEYTNVck9ZdW1YODNXamZFYXorVzV4ZmgrdkZjMXMzYWpHbktGNURnWG5pTjE0YlI5N05tdnNqeWRYbjc3Mi8wNVZTNkQ3eU56eGRUNzZybEV4aHB4SGgwbjhlcHRhU3pPTU9uTW5FZnVpVjN0czRCb2h6N2RiUi9NeTVNWk56cW5hMTB5Z0R1akhXMjRpVjRodStXZEI3Z2xVUnNkd2FSU2luRE5KbjJ5RUEvQURUeGlFckU2Z3VvNmR2YWpGTExJYzVjcjlqdGJIZWtmV0tIUDdITmtXV3FWdDhwNDJjZ3J3RG1ZRmMzSS95UEo0VmpNNmF5SW91a2thVkc3bTVEUkNmUnM5Tkg4eHp6ZVFidG1Rc2JqZ0pscE9BQ09JVXpuYkNyNlJtbzF1WFNyVHByd3NOU1ZuUkdLVk13V1g3LzJZTHdpY0lYWmZFc0xPTjFpUTFudXNJamlFcGZLWWEyVnRJY29Wc0F2QlNyT1cyWnEra0ZQWFVhWjRaWXZIVzhQUzZiQW5FaXVCTlpMMXdkWDByZERuK01icE8xQ1F3ZGVCTi9MNU5nV1VDaU9jVGxOY3VHREZMNXRmUlJCLzkyZUc3TTZGMXQ0UGMyWE9WZzRIN0RFeWxreGZwOS9FcytDOExmMHUxZkxZNk85M1kvTkJqaTZ2bHQ4ZTJRaEh5Q3UyRHAzeE5pR2I3YWtPM2RXWFVvbmlBek5pcWNoVFpveXVNYjlzdk5jTzZzWmg5ZG5yVnlmR1RLWVY3NjJ0YTBsdk9XdEZjOWVIZ2tMVHRpTTU3WDhNYnh5angwNFluUUZ0QWRKNVNXUlY5ZGxkazVWdU4xajIvaVZYS3RWV1JIQmd3S3J5cXgvR3oxY1NVOFI4M09BQUJvSWRrYmF5UGRNVzFyemxLSzU3VHNyRm9kNWZVUmR0RnFQQjlwazBXOVd2SmpEeWFRZVRON0hYbXJYWlZwWjJXUmFmTkpaYmVDS1JnN0FJTTVRL3RGNi9SZUw0Vkh5OHV6T3FNMTF0L0ZPYkw5Zk9wRWJFSXI2bTIxSkZwbDFTcVAxTGtxK1JaajNaYnJscllzZ2JhMDZvL21ML05HREJKdnZWby90dlFMYmZHRU5tYU1ZMm10alIrbFgyYytYbmdNSGpONVAyOE53MHAxV2ZGcXhsck1VUHQ5UFJMRDZvTXZRaHRjOTBNVG1kTE5ra1NHVlkwQmVORjg3ZkxZTzZsbk9iOGMydUFWUEhBYVhyUERLclpxSG91VlRUbXVuZE1zTzZQbGRsKzBHNjNsOHhvYXJUSWtyTEhBOG55VW1yc0w5MGNUSWdlaDBmdWwxSnA5V0tZQm1JbHBYa3d0T2RPV1BEcVhxeUhka1VmN2NoNkR3Sk1IQU9BUDVZUTRwS0pORTZZVURQQVVvc0dUeWNnSXhtbm5BVjVMTkJnTFRWcm1vdmY0a2FRYWNRRHZocUUwSWRGVlVXVzZiS3hyZTdWODFtdVc5TmtUc1lta2hCaTJyc3ZWTk1nTUFJZ3l3b1NmUFJ4cmxkTnJSeG5JOVVReWIyWnZXVmE3S3RQTzByQ1dGMWxVRUYzaEtMMmNXanNHZ0dSNlpsaWlBaXJxRUZxV1VrWTlKeTBkZ21nOENQeXBFWWZZd1FpbzJRQmxVa3NkMkJHUEpqS3YxcExnbGk1bE5XR2YySjBlMy8wWnY5Q0w1bXQ3K3BoWEw4R2o4QzZWaVlSV01FdGdDSHNubzNNOUY4dm1DUUJnWnJvWFUydHZtVXNUdmVWNTZ6cWdXamwvL3Z0bmtSM21tdjVwMVYxTHMxVFNaOCtIaGFuZHpOczBiZ0k4eW8vN0RqTlJ5SkpWMmZscVBjVE5ENmROQWRJM2lhMFBwM3UvZDViRXJldXRjOGNkSEFEdXhPME1xakY0WXJTUkFKNld6bE51RjZYdzkreUVobnlDa1V6YXY2TCtjemFhUEpyZXhpdnRMTVZlL2tGTC8rcWJDaU9weGUxS3ZCT1FXcmZQbXNDRUI5S0tWeDREdGJWQTdyTFlaYXNsOEh3R3JkVmV4K3ZlZGcwdzZsZWxiSXVwcmk2T1U5cXQvU3pQejI3TlB4eEIzZ0RBSHp6aGl0YjVJNUpNTE9XVFZ2YVpja3I3dlV0eFhic1AyOUtPZWNGRmVPMElTM3B0c2oyakkvZk9lM3VkR2MyUTZHbUxoWnFkWExPYkFlQkZXTHlacUtBU2hFcjFxNDVTMXVLRk9qRmRVZmFlMlBYWms2eklra2Q0MXdJU1BaUHRub2t5ellMVXprZG9lZVlSQld5OUhsR3drZ1h0RGNBZjAyaDFTSUdyeFpsdXFmek13d1REdm5qRWN4dktKcFRIMkJHUEpDTm1wb1VwSTlTNmswVmFTZGN0a3RHS2RjcHRWZEs1SzdSYzB4eC9UZVRVeW1WY1F3WVdIVEhDLzRVaGVLYkxvam9pSXFmdkVON28wUytQUlByQjFpQnZxNXhlMTh6aTVtcDV2TmZoY3NwUXcwL1gyajdUUkx4QkNVdDNsenh3dWhROG1XbS9tRm95Y3VCS2ptOGtsT2tWV3Bld0phVUJBTEJRQ3pJWVpReHg3djg0M29zdlEzcGJmSE51QUUvbWpEblR5UW1LWVc0eHZJOWU0NE5CRTZJMUo4VXRCYmdYWi9wb2hLOWV6SWNETEJ5WDZaZEY3NXlSTmFSWjZUTEt5bHEvbXNtTnk4NTQzTWdZQUlEZmVCZnNsdWN0WmNPTjhENlV1enhveTBwS2IzNUx1alBuYkdydnJtaDJNd0FrY2NYZ0d1bWtSbWVRSWpEN0R6M1FmMHhrMmdEYzdrZlMrL2g3WGtxMStJdDBxOEZJTjNsZGVBQ1F6MW1MNU9tM3cvRzhMeStKa296dWdKaWFpRHM4VERyVEZJZ1JpNE50STRXQ2oza2kzY0dhRHpNTFptRzZGMU5ieG9kMWJkRXE1R3N0TU5tVytnWkRoNzNGcW1WcmFIWGZIaWF0Y3FqTndITmY0VTBVWThDelljNFZhMEh2eHI2N3k1ZGUrcjQ1cTdTeUoycmRXclozOGVRQkdFSEc5cDRQSkxLUVQwcHYzZXpsa2x1b3lUWHJRaTlrRWtRcEhjRWFrUWo3eFpSRHlTSlRybkFEYS9LcEZUeWNRaFhVZnJBays2eXJ2alhaS1owREVLaDFxVmEzM0lSLzk0RGI4VEpxK2xnSzltcEUvT01zSmVpVjR4bDRmcS94ZC82eUk0cmYxUnVLY0RTbG1iL1dsb2lOWS9XOWtFc0E4QWVyek9pUkZWSW9aSVQ4c2NqamlLMkh6RXprNmc2d3A0dTJRWFAwSStWNTJ6SXk0TkZqRUdYVkU3V2JBZUFiYTRReXE2NmRNN1NrSkRRVGZxL2xTNmw3Z3MyVXNKNDNIYXVIMkd2MWpHaTc1OVdCTS9xYWRDKzkxcXpGQysvOURWTDBRSnRKc1FSMnlpQi9LKzBpMS9Yck5tMlZpN1h5aEdTUjg5Z1FqOEFxcGJ3aHc2VlNybFRHWDVXMEdyV1I0SmtQdE1ZQ2ErZTltajRzY1hybTZMUWZKSlZubWNSaGJJTUhhK0RyekRiQXBSeGw1bkVLcjVadVdlTGhtbGJaSTlFc09Fbi9USWRta2kvSzlWb0F1YVhzTFIzRjRpYlV6dGZ5STFlbVF2cFNhczJtOVlTK2ozbTN4YVlTNlZvd0E5Ti9NZFdpeTdKdDNyM01WVGhlRm4rWTdCWjREUWFrSkFEMGNwV25PQm10TDZRR3BpSHE4S3pnQ2R6YTBMb3ZrbTE3aEZzTHI2Wm5uUWFESjVWeXdpSENveDlKTGZpUVZTWkFNaU5jQjJraWp5NzhNaVJsNE9sMFBiUENXUjFPTXJpN0hIZGpuWmJmN2FoN0RlYTdpdWljK1o0MytmWUJBS1J4aDlDdHg3MUFWZzVnNUUwOTQ4Rm14MWg2VnIrZlFYUXhRZFNtWTM0SElJRXpaMDYwV1p0UnRHYU12TXJBSzNnc3djL3M0T2laUExudEVNZjZnck1EODF0eWxWZnN2SUVOdXV3cjhKck5WMmluRVhpbGN1cHdRQ1hBREZ6cFI3ZmVBR1I4WFVMdGxvOStiNk04RDJDbTdFaDBvbWNqck9telJoWXlIcitrZWxCSE1CdlR2WmdhR2FTbEhhcXQrNG04OVM2dEdiSXVsck9tYTVHdUc5ZmdOWkR4cktKczdRSWk1UUY0RWtlaFhJeUpuNDFUdjlPSTc4Y1g2ZmEwYnh3ZTFaZFNpeHZ4Y2Fzak4rbFlRTTl1UkFEWnRJS094L05hdnB0ai9YbXI4L3p4V3UzWWtqNWlUNmNqS1F0a0VXVGhkZHBxanFGbllKNkVaK2pzZHRhVnc2cXlsRUpOdnl5M3ZQVXhWdVhZcXd2THRORmdSRFF2UEI1cmw3U2s4WGFsV3ZxMytvT3ZROXBKcFRkZTZmRXIxbVZzNTdNR3FLL3E4TjkxcjhmalpmbHBUL1E5aTFhZVhuV2pQVjRwejRpdUJnRFB4ZU9MbFBMR0tzY2k4azd6NnpKTWRxK05OZ0pzdlNTdTlPR2lSbnhQVzZPRHFoWFg2UjEwVmxzdm1yZVdEaU1HSUJHclE5Z2I2WWdzbFl6VzJUcW4xYTBJRjVmTVd4dnBEL2RsVzRYOFdnVWVaV0JWVGxyWngrdWJVSWFWMVZtM2hkNDI5TlJSOWkycnBXd3QzNXZtV0lkMGp5Tkt2SnhaV1kzNWhNdWJWczZoeXVPcTdKcG9FZGtEUElmOGNGdEdhWWhXMmZ0NXJUZExjM01aYUthMlJXS1dTNkEycGF5UzZPL1p2diszYWdzNE5pbXpWdmp5T3hoaFNRc3dHcXNaN1dWYkFyb09zb2plNnFoZThweTMxdWxwUzYwYkgvTmFsMi9jQW84ZTBzYXJkbE0xaFh5OHRwK3p1Rmhsdm1XeFBlQ2F2clNZN0hBZmhQNXJmWFJseE1XYXgzcU5MZ1F6TXYwWFUrK0l0R0NsUm9aZFBhS3NlMVVHQUZQU2NsYWlFK3R3M2kzSkNnNEJqTUFhZUhnWnRkaXJKUjU3bFcwTGNCdTBXZGNhREpxaHRPYVZwaklqdFpuOUhrYVZDMUJ3dHR1QVdIMFIwc3l2aDlZa2FPMTY3WnAwSE1XN1RuSmtIWjR5SGpqNHBIbHVUMTRBZUI4alRYVFFRZjRtY2VXTjdGbFkzWXZIT2RtTXg1NlZpOTdmWWExRHNsa3o3R1VBRUJnVi9JMEl5YXowa21kVXJ0SzFsckVzK2NzeW1aeWVFNTZyR2M5dDJwekhIcHNHYmtlV0ZyS1dNYXRQZklrMHVzUE54RStBTS9IT0s3VG1hSTZVSml2OStsUkdleXlscDNMbngvdTRybmZGRFdXTVFoYUNNTm1Nb1lpUjNaQXVEclB5NzR1cEQ0N2pXRUtZMW5YQ1doaFUyMXpCZ3hhMnJWMjduSjVBRTdGQ0c1NnR3bXJLY1Z1NHp6QVhxL1B5OTRueVM2cXRIZXlPV1djZlBsdmxCNjZDNHBIT2IwTCt6YUpvQWE1bThra3pxeG5SbWt1c21ScldsMU5yWlY5S3BtRTllZCtCQkZvRDBET0JjbU9IVUl2TkhXV0kxUVFZT2JScUw2ZE9PWVM5QVFuckZweVp2aVd5ODVWSVhhdEdPVDVITHBTUjZvUkpzY3JJVlRqMnZKamdzUVhLNjh1aTEyVko1LzI5a1JjbWptVTQwbHZzaU5iNWFoTldJYzVoeU9zaDA0N3d0QTA1QmZCY3BQay9pVklHYWpLeUZkZXgxcUZkNzFFUnZXanFEQms2a0JOc2dwUk9wUTB5clk1VnlYdVh6bE5ieU9BSnRsanJBSUJFZW9YSVNDRXBhZmxhMmhhMVlMZGt4ZFRTTzdCTThKZHBOY0VtR2tVanJaL2U1K2tKS3RTZWp5VmZCdDR5dlI3eWtXajBVRnRaNkMzUFVyWjFzVmNycjNaZWFjdkhnbzVhR2R0bjJzMVE1NG9SQVczKytmNnIrYUFaU01zbnZma3Nta0RTc2xacEs0NmNJdUZhYTFpSk5UaWc1WmRpNHdCbllqVjVJdVZhemtFM1o0U1Vhdm1QbEd0RElrU3R6RlphVFFmY3ZrdG0zQlJ2ZmttNWU5MVd6WTJRQXZPYTZWNHpxNjJtT2d6bjEzcDJUVUJWaEVhdjJtbFZUUmVCbWZsckFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXc4UDhCeXZqWExIb3YwQ29BQUFBQVNVVk9SSzVDWUlJPSIvPgo8L2RlZnM+Cjwvc3ZnPgo=", xQ = (e) => /* @__PURE__ */ z.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22.423 11.0365L2.74838 1.1166C1.75916 0.675714 0.660018 1.55748 1.09967 2.54947L3.6962 9.5276C3.78981 9.77917 4.01073 9.96154 4.27548 10.0058L16.3777 12.0285L4.27548 14.0511C4.01073 14.0954 3.78981 14.2777 3.6962 14.5293L1.09967 21.5074C0.769932 22.4994 1.75916 23.3812 2.74838 22.8301L22.423 12.9102C23.1923 12.5796 23.1923 11.4773 22.423 11.0365Z", fill: "#30308F" })), j6 = A.div`
  position: relative;
  background: ${({ botCategory: e }) => e ? `url(${O6}) no-repeat center center` : "#eeeeee"};
  background-size: cover;
  border-bottom-left-radius: 15px;
  border-bottom-right-radius: 15px;
`, GQ = `
  padding: 10px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
`, H6 = A.div`
  ${GQ}
  background: #dce1fb;
`, j2 = A.div`
  ${GQ}
  background: transparent;
`, f6 = A.textarea`
  width: ${(e) => e.isActive ? "calc(100% - 30px)" : "100%"};
  transition: ${(e) => e.isActive ? "none" : "width 0.5s"};
  transition-timing-function: ease;
  padding: 8px 16px;
  font-size: 14px;
  font-family: "Roboto", sans-serif;
  line-height: 20px;
  color: rgba(0, 0, 0, 0.88);
  resize: none;
  border: none;
  outline: none;
  max-height: 116px;
  background: ${({ botCategory: e }) => e ? Sl[e]["input-message-background-color"] : "rgba(255, 255, 255, 0.38)"};
  border-radius: 8px;
  height: auto;
  ::placeholder {
    color: rgba(0, 0, 0, 0.38);
  }
`, w6 = A.div`
  font-weight: 600;
  padding-top: 14px;
  padding-bottom: 14px;
  cursor: pointer;
  text-align: center;
  transition: color 0.3s ease;
  display: flex;
  justify-content: center;
  align-items: center;

  &:hover {
    color: #007bff;
  }
`, H2 = A.div``, sN = A.div`
  padding-left: 16px;
  padding-right: 16px;
  padding-bottom: 8px;
  gap: 12px;
  display: flex;
  flex-direction: column;
  max-height: 240px;
  overflow-y: auto;
`, g6 = A.div`
  padding-left: 16px;
  padding-right: 16px;
  padding-bottom: 12px;
  gap: 12px;
  display: flex;
  flex-direction: column;
  max-height: 200px;
`, I6 = A.div`
  display: flex;
  height: 154px;
  flex-direction: column;
  overflow-y: auto;
`, L6 = A.div`
  margin-left: 16px;
  margin-right: 16px;
  margin-bottom: 12px;
  background-color: rgba(255, 255, 255, 0.4);
  border-radius: 8px;
`, C6 = A.div`
  display: flex;
  flex-direction: ${({ showTip: e }) => e ? "column" : "row"};
  justify-content: space-between;
  gap: 8px;
  flex: 1 1 auto;

  > div {
    width: 100%;
  }
`, K6 = A.div`
  padding: 4px 12px;
  background-color: var(--sendbird-light-primary-300); // Blue background
  color: var(--sendbird-light-background-50-0); // White text
  border: 1px solid var(--sendbird-light-primary-300);
  border-radius: 8px;
  text-align: center;
  cursor: pointer;
`, _6 = A.div`
  padding: 4px 12px;
  background-color: transparent;
  color: var(--sendbird-light-primary-300);
  border: 1px solid var(--sendbird-light-primary-300); // Blue border
  border-radius: 8px;
  text-align: center;
  cursor: pointer;
  ${({ showTip: e }) => !e && "width: 100%;"}
`, f2 = A.div`
  background-color: rgba(255, 255, 255, 0.4);
  height: 140px;
  color: black;
  border-radius: 8px;
  text-align: start;
  margin-top: 8px;
  display: flex;
  flex-direction: column;
  padding-bottom: 8px;
`, P6 = A.div`
  padding: 4px;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
`, w2 = A(Fe)`
  font-weight: 700;
`, g2 = A(Fe)`
  padding: 12px;
  font-weight: 500;
  white-space: normal;
  display: -webkit-box;
  -webkit-line-clamp: 5;
  -webkit-box-orient: vertical;
  overflow: auto;
`, I2 = A(Fe)`
  font-weight: 700;
  font-size: 11px;
  //  not draggable
  user-select: none;
`, A6 = A.textarea`
  padding: 8px 16px;
  font-size: 14px;
  line-height: 20px;
  border: none;
  border-radius: 8px;
  outline: none;
  resize: none;
  height: 36px;
  background: rgba(255, 255, 255, 0.4);

  ::placeholder {
    color: rgba(0, 0, 0, 0.38);
  }
`, L2 = A.button`
  padding: 4px 12px;
  background-color: ${(e) => e.disabled ? "rgba(0, 0, 0, 0.12)" : "#007bff"};
  color: #ffffff;
  border: none;
  border-radius: 8px;
  cursor: pointer;

  &:disabled {
    cursor: not-allowed;
  }
`, q6 = A.div`
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 11px 12px;
  background-color: rgba(0, 0, 0, 0.12);
  border-radius: 8px;
  cursor: not-allowed;
`, C2 = A.button`
  padding: 4px 12px;
  background: transparent;
  border: 1px solid var(--sendbird-light-primary-300);
  border-radius: 8px;
  cursor: pointer;

  &:disabled {
    cursor: not-allowed;
  }
`, $6 = A(Fe)`
  padding-bottom: 10px;
`, e_ = A.div`
  line-height: 50px;
  cursor: pointer;
  transition: background-color 0.3s ease;

  &:hover {
    background-color: #cccccc; /* Hover 시 회색으로 배경색 변경 */

    &:first-child {
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
    }

    &:last-child {
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
    }
  }

  &:last-child > div {
    border-bottom: none;
  }
`, t_ = A.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-left: 12px;
  margin-right: 12px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.38);
`, n_ = (e, n) => {
  _e(() => {
    if (e) {
      e.style.height = "0";
      const t = e.scrollHeight;
      e.style.height = t + "px";
    }
  }, [e, n]);
};
function l_({
  onSendMessage: e,
  setModalContent: n,
  setShowModal: t
}) {
  var ge, Me;
  const { inputValue: l, botId: a, userId: d } = jn(), [r, i] = me(""), [c, V] = me(null), [s, o] = me(null), U = Wt(null), [N, R] = me(!1), [h, Z] = me((l == null ? void 0 : l.value) ?? ""), { botCategory: W } = jn(), [F, m] = me(!1), [E, u] = me(!1), [b, k] = me(!1), [Q, S] = me(""), [v, G] = me(!1), w = {
    "Content-Type": "application/json"
  }, { allMessages: y } = fl(), g = [
    {
      symptom: "headache",
      date: "2024.02.21",
      medicalHistory: `
  - Diagnosis: Common Cold
  - A 28-year-old male (example patient information), experiencing high fever, cough, body aches, and other flu-like symptoms since last week.
  - Symptoms started suddenly and are ongoing.
  - No underlying conditions identified in the past.
  - Currently resting at home, under self-isolation.
  - Resides in the city, has not received a flu vaccine recently.
  - Scheduled for flu diagnosis and appropriate treatment plan through interaction with a doctor.`
    },
    {
      symptom: "stomachache",
      date: "2024.02.10",
      medicalHistory: `
  - Diagnosis: Gastritis
  - A 35-year-old female, complaining of persistent stomach pain, nausea, and bloating after meals.
  - Symptoms have been present for the last two weeks.
  - No history of gastrointestinal disorders noted previously.
  - Currently avoiding spicy and acidic foods.
  - Scheduled for further evaluation and treatment under the care of a gastroenterologist.`
    },
    {
      symptom: "back pain",
      date: "2024.01.01",
      medicalHistory: `
  - Diagnosis: Lumbar Strain
  - A 45-year-old male, reporting sudden onset of lower back pain after lifting heavy objects.
  - Pain worsens with movement and is alleviated with rest.
  - No previous history of significant back injuries.
  - Currently using over-the-counter pain relievers and hot/cold therapy.
  - Advised on proper lifting techniques and referred for physiotherapy sessions.`
    },
    {
      symptom: "fever",
      date: "2023.10.21",
      medicalHistory: `
  - Diagnosis: Urinary Tract Infection (UTI)
  - A 30-year-old female, presenting with high fever, frequent urination, and burning sensation during urination.
  - Symptoms began two days ago and are progressively worsening.
  - No known history of UTIs.
  - Currently drinking plenty of water and cranberry juice.
  - Prescribed antibiotics and advised to follow up with a urologist if symptoms persist.`
    },
    {
      symptom: "cough",
      date: "2023.06.15",
      medicalHistory: `
  - Diagnosis: Acute Bronchitis
  - A 40-year-old male, complaining of persistent cough with yellowish sputum production, chest discomfort, and mild fever.
  - Symptoms started a week ago after a cold.
  - No history of chronic respiratory conditions.
  - Currently using cough suppressants and expectorants.
  - Recommended rest, hydration, and follow-up visit if symptoms worsen or persist beyond two weeks.`
    }
  ], f = Ji();
  n_(U.current, h), _e(() => {
    var We;
    if (y.length > 0) {
      const De = y[y.length - 1];
      (De == null ? void 0 : De.messageType) === "user" && ((We = De.sender) == null ? void 0 : We.userId) === d && G(!0);
    }
    y.length == 0 && G(!0);
  }, [y]), _e(() => {
    (async () => {
      var De, Oe, tt;
      if ((l == null ? void 0 : l.value) != null && l.value.length > 0) {
        u(!0), V(null), i(l.value), k(!0), m(!1);
        try {
          const Be = await ae([
            {
              role: "user",
              content: "I'm now talking to Patient X. "
            },
            {
              role: "user",
              content: l.value
            }
          ]);
          V(Be), ((Oe = (De = Be.response_method) == null ? void 0 : De.function_calls) == null ? void 0 : Oe.length) > 0 && o((tt = Be.response_method) == null ? void 0 : tt.function_calls[0]);
        } catch (Be) {
          console.error("Failed to fetch AI response", Be);
        }
        i(""), k(!1);
      }
    })();
  }, [l == null ? void 0 : l.value, l == null ? void 0 : l.id]), _e(() => {
    typeof h == "string" && h.length > 0 && R(!0);
  }, [h]), _e(() => {
    setTimeout(() => {
      f("How can I help you today?");
    }, 500);
  }, []);
  function I() {
    m(!F);
  }
  const Ue = y.filter(
    (We) => We.messageType === "user"
  ).map((We) => ({
    role: We.sender.userId === a ? "user" : "assistant",
    content: We.message
  })), { isPending: q } = ZK({
    queryKey: ["getAIRecommendMessage", Ue],
    queryFn: async () => !Ue || Ue.length < 1 ? Promise.resolve([]) : (Ue.length < 2 && !y.filter(
      (Oe) => (Oe == null ? void 0 : Oe.message) === "How can I help you today?"
    ) && Ue.unshift({
      role: "assistant",
      content: "How can I help you today?"
    }), await X2.post("/api/assistant", {
      params: {
        botId: "healthcare"
      },
      data: {
        messages: Ue,
        include_response_method: !0
      },
      headers: w
    }).then((Oe) => {
      const tt = Oe.data.reply_messages[0];
      return tt && !(tt === "How can I assist you today?") && (G(!1), S(Oe.data.reply_messages[0])), Oe.data;
    }))
  });
  async function ae(We) {
    return (await X2.post("/api/assistant", {
      params: {
        botId: "healthcare"
      },
      data: {
        messages: We,
        include_response_method: !0
      },
      headers: w
    })).data;
  }
  async function se() {
    var De, Oe, tt;
    k(!0);
    const We = await ae([
      {
        role: "user",
        content: "I'm now talking to Patient X. "
      },
      {
        role: "user",
        content: r
      }
    ]);
    V(We), ((Oe = (De = We.response_method) == null ? void 0 : De.function_calls) == null ? void 0 : Oe.length) > 0 && o((tt = We.response_method) == null ? void 0 : tt.function_calls[0]), k(!1), i("");
  }
  function le(We) {
    i(We.target.value);
  }
  function L() {
    e == null || e(h), f(h), Z("");
  }
  function $(We) {
    if (h == null)
      return;
    const De = We.target.value;
    Z(De), R(De.length > 0);
  }
  function ee(We) {
    !We.shiftKey && We.charCode === 13 && h != null && (We.preventDefault(), L());
  }
  function O() {
    u(!E), V(null), i("");
  }
  function re() {
    Z(Q), m(!0);
  }
  function te() {
    u(!E), i(""), Z((c == null ? void 0 : c.reply_messages[0]) ?? ""), m(!0), V(null);
  }
  function Qe() {
    V(null);
  }
  function Ye() {
    return /* @__PURE__ */ Y.jsx(Y.Fragment, { children: g.map((We, De) => /* @__PURE__ */ Y.jsx(e_, { children: /* @__PURE__ */ Y.jsxs(
      t_,
      {
        onClick: () => {
          Se(We);
        },
        children: [
          /* @__PURE__ */ Y.jsx(
            "div",
            {
              style: {
                fontSize: "14px"
              },
              children: We.symptom
            }
          ),
          /* @__PURE__ */ Y.jsx(
            "div",
            {
              style: {
                color: "rgba(0, 0, 0, 0.5)",
                fontSize: "12px"
              },
              children: We.date
            }
          )
        ]
      },
      De
    ) }, `${We.symptom}-${We.date}-${De}`)) });
  }
  function Se(We) {
    n(We), t(!0);
  }
  function P() {
    switch (s == null ? void 0 : s.name) {
      case "get_medical_history":
        return /* @__PURE__ */ Y.jsxs(Y.Fragment, { children: [
          /* @__PURE__ */ Y.jsx(sN, { children: /* @__PURE__ */ Y.jsx(
            $6,
            {
              type: oe.BODY_1,
              color: ie.ONBACKGROUND_1,
              children: "This is `Patient X` past medical history."
            }
          ) }),
          /* @__PURE__ */ Y.jsx(L6, { children: /* @__PURE__ */ Y.jsx(I6, { children: Ye() }) }),
          /* @__PURE__ */ Y.jsx(sN, { children: /* @__PURE__ */ Y.jsx(C2, { onClick: Qe, children: /* @__PURE__ */ Y.jsx(
            Fe,
            {
              type: oe.BODY_1,
              color: ie.PRIMARY,
              children: "Cancel"
            }
          ) }) })
        ] });
      case "get_user_info":
        return /* @__PURE__ */ Y.jsx("div", { children: "User Info" });
      default:
        return /* @__PURE__ */ Y.jsx("div", { children: "Default Case" });
    }
  }
  return /* @__PURE__ */ Y.jsxs(j6, { botCategory: W, isFolded: F, children: [
    F ? /* @__PURE__ */ Y.jsxs(w6, { onClick: I, children: [
      /* @__PURE__ */ Y.jsx(
        Fe,
        {
          type: oe.BODY_1,
          color: ie.ONBACKGROUND_1,
          children: "AI medical assistant"
        }
      ),
      /* @__PURE__ */ Y.jsx(
        D6,
        {
          style: {
            paddingLeft: "4px",
            width: "10px",
            height: "10px"
          }
        }
      )
    ] }) : E ? /* @__PURE__ */ Y.jsxs(H2, { children: [
      /* @__PURE__ */ Y.jsxs(
        j2,
        {
          onClick: O,
          style: {
            cursor: "pointer",
            display: "flex",
            justifyContent: "flex-start",
            gap: "8px"
          },
          children: [
            /* @__PURE__ */ Y.jsx(B6, {}),
            /* @__PURE__ */ Y.jsx(
              w2,
              {
                type: oe.SUBTITLE_1,
                color: ie.ONBACKGROUND_1,
                children: "Ask the assistant"
              }
            )
          ]
        }
      ),
      c && c.reply_messages.length > 0 ? ((Me = (ge = c.response_method) == null ? void 0 : ge.function_calls) == null ? void 0 : Me.length) > 0 ? P() : /* @__PURE__ */ Y.jsxs(sN, { children: [
        /* @__PURE__ */ Y.jsxs(f2, { children: [
          /* @__PURE__ */ Y.jsxs(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                paddingTop: "8px",
                paddingLeft: "12px",
                paddingRight: "12px"
              },
              children: [
                /* @__PURE__ */ Y.jsx(
                  G6,
                  {
                    style: {
                      paddingRight: "4px"
                    }
                  }
                ),
                /* @__PURE__ */ Y.jsx(
                  I2,
                  {
                    type: oe.CAPTION_2,
                    color: ie.ONBACKGROUND_2,
                    children: "AI medical assistant"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ Y.jsx(
            g2,
            {
              type: oe.BODY_1,
              color: ie.ONBACKGROUND_1,
              children: c.reply_messages[0]
            }
          )
        ] }),
        /* @__PURE__ */ Y.jsx(L2, { onClick: te, children: /* @__PURE__ */ Y.jsx(
          Fe,
          {
            type: oe.BODY_1,
            color: ie.ONCONTENT_1,
            children: "Paste this answer"
          }
        ) }),
        /* @__PURE__ */ Y.jsx(C2, { onClick: Qe, children: /* @__PURE__ */ Y.jsx(
          Fe,
          {
            type: oe.BODY_1,
            color: ie.PRIMARY,
            children: "Cancel"
          }
        ) })
      ] }) : /* @__PURE__ */ Y.jsxs(
        sN,
        {
          style: {
            paddingBottom: "80px"
          },
          children: [
            /* @__PURE__ */ Y.jsxs(
              Fe,
              {
                type: oe.BODY_1,
                color: ie.ONBACKGROUND_1,
                children: [
                  "Looking for better phrases or stuck on something?",
                  /* @__PURE__ */ Y.jsx("br", {}),
                  " Ask away!"
                ]
              }
            ),
            /* @__PURE__ */ Y.jsx(
              A6,
              {
                value: r,
                onChange: le,
                placeholder: "Ask the assistant"
              }
            ),
            b ? /* @__PURE__ */ Y.jsx(q6, { children: /* @__PURE__ */ Y.jsx(O2, {}) }) : /* @__PURE__ */ Y.jsx(
              L2,
              {
                onClick: se,
                disabled: !r.trim(),
                children: /* @__PURE__ */ Y.jsx(
                  Fe,
                  {
                    type: oe.BODY_1,
                    color: ie.ONCONTENT_1,
                    children: "Send"
                  }
                )
              }
            )
          ]
        }
      )
    ] }) : /* @__PURE__ */ Y.jsxs(H2, { children: [
      /* @__PURE__ */ Y.jsxs(j2, { onClick: I, style: { cursor: "pointer" }, children: [
        /* @__PURE__ */ Y.jsx(
          w2,
          {
            type: oe.SUBTITLE_1,
            color: ie.ONBACKGROUND_1,
            children: "AI medical assistant"
          }
        ),
        /* @__PURE__ */ Y.jsx(y6, {})
      ] }),
      /* @__PURE__ */ Y.jsxs(g6, { children: [
        /* @__PURE__ */ Y.jsxs(f2, { children: [
          /* @__PURE__ */ Y.jsxs(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                paddingTop: "8px",
                paddingLeft: "12px",
                paddingRight: "12px"
              },
              children: [
                /* @__PURE__ */ Y.jsx(
                  X6,
                  {
                    style: {
                      paddingRight: "4px"
                    }
                  }
                ),
                /* @__PURE__ */ Y.jsx(
                  I2,
                  {
                    type: oe.CAPTION_2,
                    color: ie.ONBACKGROUND_2,
                    children: v ? "Tips for using AI assistant" : "Suggested by AI"
                  }
                )
              ]
            }
          ),
          q || v ? /* @__PURE__ */ Y.jsx(
            "div",
            {
              style: {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                height: "100%"
              },
              children: /* @__PURE__ */ Y.jsx(O2, {})
            }
          ) : /* @__PURE__ */ Y.jsx(
            g2,
            {
              type: oe.BODY_1,
              color: ie.ONBACKGROUND_1,
              children: /* @__PURE__ */ Y.jsx(
                "div",
                {
                  dangerouslySetInnerHTML: {
                    __html: Uh(Q)
                  }
                }
              )
            }
          )
        ] }),
        /* @__PURE__ */ Y.jsxs(C6, { showTip: v, children: [
          !v && /* @__PURE__ */ Y.jsx(K6, { onClick: re, children: /* @__PURE__ */ Y.jsx(
            Fe,
            {
              type: oe.BODY_1,
              color: ie.ONCONTENT_1,
              children: "Paste this answer"
            }
          ) }),
          /* @__PURE__ */ Y.jsx(
            _6,
            {
              onClick: O,
              showTip: v,
              children: /* @__PURE__ */ Y.jsx(
                Fe,
                {
                  type: oe.BODY_1,
                  color: ie.PRIMARY,
                  children: "Ask the assistant"
                }
              )
            }
          )
        ] })
      ] })
    ] }),
    !E && /* @__PURE__ */ Y.jsxs(H6, { children: [
      /* @__PURE__ */ Y.jsx(
        f6,
        {
          isActive: N,
          onKeyPress: ee,
          ref: U,
          value: h,
          onChange: $,
          rows: 1,
          placeholder: "Enter message",
          botCategory: W
        }
      ),
      N && /* @__PURE__ */ Y.jsx(P6, { children: /* @__PURE__ */ Y.jsx(
        xQ,
        {
          onClick: () => {
            L();
          },
          height: "20px",
          width: "20px",
          children: "Send"
        }
      ) })
    ] })
  ] });
}
const a_ = A.div`
  display: flex;
  justify-content: center;
  align-items: end;
  margin-bottom: 6px;
  flex-wrap: wrap-reverse;
  gap: 8px;
  padding-left: 16px;
  padding-right: 16px;
`, d_ = A.div`
  font-size: 11px;
  width: fit-content;
  font-weight: normal;
  font-stretch: normal;
  font-style: normal;
  line-height: 1.43;
  letter-spacing: normal;
`, r_ = A.div`
  color: #808080;
  max-width: 600px;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 8px 12px;
  gap: 12px;
  border-radius: 16px;
  white-space: pre-wrap;
`, i_ = A.div`
  white-space: pre-line;
`;
function K2(e) {
  const { message: n } = e;
  return /* @__PURE__ */ Y.jsx(a_, { children: /* @__PURE__ */ Y.jsx(d_, { children: /* @__PURE__ */ Y.jsx(r_, { children: /* @__PURE__ */ Y.jsx(i_, { children: n }) }) }) });
}
const AZ = {
  sendbird_emoji_thumbsup: "https://static.sendbird.com/icons/emoji_thumbsup.png",
  sendbird_emoji_thumbsdown: "https://static.sendbird.com/icons/emoji_thumbsdown.png"
}, V_ = A.div`
  display: inline-block;
  margin-top: -12px;
  margin-left: 6px;
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);

  .sendbird-reaction-button--selected {
    border: none;
    background-color: transparent;
  }
`;
function _2({
  reacted: e,
  onClick: n,
  emoji: t,
  url: l
}) {
  return /* @__PURE__ */ Y.jsx(
    zc,
    {
      width: "24px",
      height: "24px",
      selected: e,
      onClick: n,
      dataSbId: `ui_emoji_reactions_menu_${t}`,
      children: /* @__PURE__ */ Y.jsx(el, { url: l, width: "18px", height: "18px" })
    }
  );
}
function c_({ message: e }) {
  var d;
  const { toggleReaction: n } = fl(), [t, l] = me(
    Object.keys(AZ).reduce(
      (r, i) => ({
        ...r,
        [i]: !1
      }),
      {}
    )
  ), a = (d = Object.entries(t).find(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ([r, i]) => i
  )) == null ? void 0 : d[0];
  return /* @__PURE__ */ Y.jsx(V_, { children: a != null ? (
    // display only the selected emoji
    /* @__PURE__ */ Y.jsx(
      _2,
      {
        reacted: !0,
        emoji: a,
        url: AZ[a],
        onClick: (r) => {
          l((i) => ({
            ...i,
            [a]: !1
          })), n == null || n(e, a, !0), r == null || r.stopPropagation();
        }
      }
    )
  ) : (
    // display all emojis if none is selected
    Object.entries(AZ).map(([r, i]) => {
      const c = t[r] || !1;
      return /* @__PURE__ */ Y.jsx(
        _2,
        {
          reacted: c,
          emoji: r,
          url: i,
          onClick: (V) => {
            l((s) => ({
              ...s,
              [r]: !s[r]
            })), n == null || n(e, r, c), V == null || V.stopPropagation();
          }
        },
        r
      );
    })
  ) });
}
const s_ = A.div`
  display: flex;
  align-items: flex-end;
  flex-wrap: wrap;
  position: relative;
`, o_ = A.div`
  font-style: normal;
  font-weight: 700;
  font-size: 12px;
  line-height: 12px;
  color: rgba(0, 0, 0, 0.5);
  transition: color 0.5s;
  transition-timing-function: ease;
  margin: 0 0 4px 12px;
`, U_ = A.div`
  font-size: 14px;
  color: rgba(0, 0, 0, 0.88);
  max-width: calc(100% - 96px);
  font-weight: normal;
  font-stretch: normal;
  font-style: normal;
  line-height: 1.43;
  letter-spacing: normal;
  margin-right: 4px;
  margin-left: 8px;
`, P2 = A.div`
  width: fit-content;
  color: rgba(0, 0, 0, 0.38);
  font-size: 12px;
  line-height: 1;
  margin-bottom: 2px;
`, N_ = A.div``, R_ = A.div`
  width: 28px;
`;
function Ud(e) {
  const { enableEmojiFeedback: n } = jn(), {
    botUser: t,
    message: l,
    bodyComponent: a,
    messageCount: d,
    zIndex: r,
    bodyStyle: i,
    chainTop: c,
    chainBottom: V,
    isBotWelcomeMessage: s,
    isFormMessage: o = !1,
    newLineSentTime: U = !1,
    marginBottom: N = "12px"
  } = e, R = c == null && V == null, h = R || V, Z = R || c;
  return /* @__PURE__ */ Y.jsxs(s_, { style: { zIndex: d === 1 && r ? r : 0, marginBottom: N, paddingLeft: 16, paddingRight: 16 }, children: [
    h ? /* @__PURE__ */ Y.jsx(N_, { children: /* @__PURE__ */ Y.jsx(
      da,
      {
        src: (t == null ? void 0 : t.profileUrl) || Nh,
        alt: "botProfileImage",
        height: "28px",
        width: "28px"
      }
    ) }) : /* @__PURE__ */ Y.jsx(R_, {}),
    /* @__PURE__ */ Y.jsxs(U_, { style: i ?? {}, children: [
      Z && /* @__PURE__ */ Y.jsx(
        o_,
        {
          style: {
            textAlign: "left"
          },
          children: t.nickname
        }
      ),
      a,
      n && h && !s && !o && /* @__PURE__ */ Y.jsx(c_, { message: l })
    ] }),
    U ? /* @__PURE__ */ Y.jsx(
      "div",
      {
        style: {
          paddingLeft: "40px",
          width: "100%",
          display: "flex",
          justifyContent: "flex-start",
          marginTop: "4px"
        },
        children: /* @__PURE__ */ Y.jsx(P2, { children: kR(l.createdAt) })
      }
    ) : /* @__PURE__ */ Y.jsx(P2, { children: kR(l.createdAt) })
  ] });
}
const h_ = A.div`
  display: flex;
  justify-content: flex-end;
  align-items: end;
  margin-bottom: 16px;
  flex-wrap: wrap-reverse;
  gap: 4px;
  padding-left: 16px;
  padding-right: 16px;
`, Z_ = A.div`
  max-width: calc(100% - 90px); // 600px;
  font-size: 14px;
  width: fit-content;
  font-weight: normal;
  font-stretch: normal;
  font-style: normal;
  line-height: 20px;
  letter-spacing: normal;
`, T_ = A.div`
  color: rgba(0, 0, 0, 0.38);
  font-size: 12px;
  line-height: 1;
  margin-bottom: 6px;
`, F_ = A.div`
  ${({ botCategory: e }) => e && aa`
      background-color: ${Sl[e]["--sendbird-light-primary-300"]};
      &:hover {
        background-color: ${Sl[e]["--sendbird-light-primary-300"]};
      }
    `};

  //background-color: var(--sendbird-light-primary-300);
  //&:hover {
  //  background-color: var(--sendbird-light-primary-300);
  //}
  color: rgba(255, 255, 255, 0.88);
  max-width: 600px;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 8px 12px;
  gap: 12px;
  border-radius: 16px;
  white-space: pre-wrap;
`, W_ = A.div`
  white-space: pre-line;
`;
function m_(e) {
  const { message: n } = e, { botCategory: t } = jn();
  return /* @__PURE__ */ Y.jsxs(h_, { children: [
    /* @__PURE__ */ Y.jsx(T_, { children: /* @__PURE__ */ Y.jsx("div", { children: kR(n.createdAt) }) }),
    /* @__PURE__ */ Y.jsx(Z_, { children: /* @__PURE__ */ Y.jsx(F_, { botCategory: t, children: /* @__PURE__ */ Y.jsx(W_, { children: /* @__PURE__ */ Y.jsx(
      "div",
      {
        dangerouslySetInnerHTML: {
          __html: Uh(n.message)
        }
      }
    ) }) }) })
  ] });
}
const u_ = A.div`
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 8px 12px;
  gap: 8px;
  border-radius: 16px;
  ${({ botCategory: e }) => e && aa`
      background-color: ${Sl[e]["--sendbird-light-background-50-0"]};
      &:hover {
        background-color: ${Sl[e]["--sendbird-light-background-50-0"]};
      }
    `};

  //max-width: 600px;
`, p_ = A.div`
  width: 100%;
  text-align: left;
  white-space: pre-line;
  word-break: break-word;
  line-height: 1.43;
`;
function M_(e) {
  const { message: n } = e, t = ch.sanitize(n), { botCategory: l } = jn();
  return /* @__PURE__ */ Y.jsx(u_, { botCategory: l, children: /* @__PURE__ */ Y.jsx(p_, { children: t }) });
}
class mh extends sW {
  render() {
    return /* @__PURE__ */ Y.jsx(
      "img",
      {
        src: this.props.image,
        alt: "item",
        style: {
          width: this.props.width,
          height: this.props.height,
          borderRadius: 8,
          objectFit: "cover",
          objectPosition: "center",
          filter: "brightness(80%)"
        }
      }
    );
  }
}
const E_ = A.div`
  display: flex;
  align-items: start;
  justify-content: space-between;
`, S_ = A.div`
  text-align: center;
  width: 44px;
  margin-right: 8px;
  padding-top: 4px;
`, k_ = A.div`
  width: ${(e) => e.hasRightColumn ? "60%" : "85%"};
  text-align: left;
`, b_ = A.div`
  width: 40%;
  padding-left: 4px;
  text-align: right;
`, oN = A.div`
  margin-left: 8px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  // max-width: 130px;
`, Cc = ({
  icon: e,
  title: n,
  description: t,
  rightTop: l,
  rightBottom: a
}) => {
  const d = l != null || a != null;
  return /* @__PURE__ */ Y.jsxs(E_, { children: [
    /* @__PURE__ */ Y.jsx(S_, { children: e }),
    /* @__PURE__ */ Y.jsxs(k_, { hasRightColumn: d, children: [
      /* @__PURE__ */ Y.jsx(oN, { children: n }),
      /* @__PURE__ */ Y.jsx(oN, { children: t })
    ] }),
    d && /* @__PURE__ */ Y.jsxs(b_, { children: [
      l && /* @__PURE__ */ Y.jsx(oN, { children: l }),
      a && /* @__PURE__ */ Y.jsx(oN, { children: a })
    ] })
  ] });
}, A2 = A.div`
  display: flex;
  flex-direction: column;
  width: 244px;
  font-family: var(--sendbird-font-family-custom);
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 16px;
  padding: 12px;
  gap: 8px;
`, Y_ = A.div`
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 16px;
  display: flex;
  flex-direction: column;
  gap: 6px;
`, Q_ = A(Ql)`
  width: 100%;
  border-radius: 18px;

  &:hover {
    background-color: #44712f !important;
  }
`, J_ = A(Fe)`
  font-weight: 700;
`, v_ = A(Fe)`
  font-weight: 500;
  white-space: normal;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
`, z_ = ({ message: e }) => {
  const n = e == null ? void 0 : e.cancel_order, t = Ji();
  function l() {
    t("Connect to an agent");
  }
  return /* @__PURE__ */ Y.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        gap: 4
      },
      children: [
        /* @__PURE__ */ Y.jsx(A2, { children: /* @__PURE__ */ Y.jsxs(Fe, { type: oe.BODY_1, color: ie.ONBACKGROUND_1, children: [
          "Order ",
          /* @__PURE__ */ Y.jsxs("strong", { children: [
            "[",
            n.id,
            "]"
          ] }),
          " has been successfully cancelled"
        ] }) }),
        /* @__PURE__ */ Y.jsxs(A2, { children: [
          /* @__PURE__ */ Y.jsxs(J_, { type: oe.CAPTION_3, color: ie.ERROR, children: [
            "Canceled on ",
            n.date
          ] }),
          n.items.map((a) => /* @__PURE__ */ Y.jsx(
            Cc,
            {
              icon: /* @__PURE__ */ Y.jsx(mh, { image: a.image, width: 40, height: 40 }),
              title: /* @__PURE__ */ Y.jsxs(Y.Fragment, { children: [
                /* @__PURE__ */ Y.jsx(
                  Fe,
                  {
                    type: oe.CAPTION_3,
                    color: ie.ONBACKGROUND_2,
                    children: "Paid on " + n.date
                  }
                ),
                /* @__PURE__ */ Y.jsx(
                  v_,
                  {
                    type: oe.BODY_1,
                    color: ie.ONBACKGROUND_1,
                    children: a.name
                  }
                )
              ] })
            },
            a.name
          )),
          /* @__PURE__ */ Y.jsx(Y_, { children: /* @__PURE__ */ Y.jsx(
            Q_,
            {
              onClick: () => {
                l();
              },
              children: /* @__PURE__ */ Y.jsx(
                Fe,
                {
                  type: oe.BUTTON_2,
                  color: ie.ONCONTENT_1,
                  children: "Connect to an agent"
                }
              )
            }
          ) })
        ] })
      ]
    }
  );
}, T1 = _l({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), uh = _l({}), ph = _l(null), Mh = typeof document < "u", Eh = Mh ? ud : _e, yQ = _l({ strict: !1 }), F1 = (e) => e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), x_ = "framerAppearId", BQ = "data-" + F1(x_);
function G_(e, n, t, l) {
  const { visualElement: a } = Gt(uh), d = Gt(yQ), r = Gt(ph), i = Gt(T1).reducedMotion, c = Wt();
  l = l || d.renderer, !c.current && l && (c.current = l(e, {
    visualState: n,
    parent: a,
    props: t,
    presenceContext: r,
    blockInitialAnimation: r ? r.initial === !1 : !1,
    reducedMotionConfig: i
  }));
  const V = c.current;
  qS(() => {
    V && V.update(t, r);
  });
  const s = Wt(!!(t[BQ] && !window.HandoffComplete));
  return Eh(() => {
    V && (V.render(), s.current && V.animationState && V.animationState.animateChanges());
  }), _e(() => {
    V && (V.updateFeatures(), !s.current && V.animationState && V.animationState.animateChanges(), s.current && (s.current = !1, window.HandoffComplete = !0));
  }), V;
}
function $V(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function y_(e, n, t) {
  return Pt(
    (l) => {
      l && e.mount && e.mount(l), n && (l ? n.mount(l) : n.unmount()), t && (typeof t == "function" ? t(l) : $V(t) && (t.current = l));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [n]
  );
}
function Bo(e) {
  return typeof e == "string" || Array.isArray(e);
}
function Sh(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
const W1 = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], m1 = ["initial", ...W1];
function kh(e) {
  return Sh(e.animate) || m1.some((n) => Bo(e[n]));
}
function DQ(e) {
  return !!(kh(e) || e.variants);
}
function B_(e, n) {
  if (kh(e)) {
    const { initial: t, animate: l } = e;
    return {
      initial: t === !1 || Bo(t) ? t : void 0,
      animate: Bo(l) ? l : void 0
    };
  }
  return e.inherit !== !1 ? n : {};
}
function D_(e) {
  const { initial: n, animate: t } = B_(e, Gt(uh));
  return nn(() => ({ initial: n, animate: t }), [q2(n), q2(t)]);
}
function q2(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const $2 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Do = {};
for (const e in $2)
  Do[e] = {
    isEnabled: (n) => $2[e].some((t) => !!n[t])
  };
function X_(e) {
  for (const n in e)
    Do[n] = {
      ...Do[n],
      ...e[n]
    };
}
const u1 = _l({}), XQ = _l({}), O_ = Symbol.for("motionComponentSymbol");
function j_({ preloadedFeatures: e, createVisualElement: n, useRender: t, useVisualState: l, Component: a }) {
  e && X_(e);
  function d(i, c) {
    let V;
    const s = {
      ...Gt(T1),
      ...i,
      layoutId: H_(i)
    }, { isStatic: o } = s, U = D_(i), N = l(i, o);
    if (!o && Mh) {
      U.visualElement = G_(a, N, s, n);
      const R = Gt(XQ), h = Gt(yQ).strict;
      U.visualElement && (V = U.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        s,
        h,
        e,
        R
      ));
    }
    return z.createElement(
      uh.Provider,
      { value: U },
      V && U.visualElement ? z.createElement(V, { visualElement: U.visualElement, ...s }) : null,
      t(a, i, y_(N, U.visualElement, c), N, o, U.visualElement)
    );
  }
  const r = vV(d);
  return r[O_] = a, r;
}
function H_({ layoutId: e }) {
  const n = Gt(u1).id;
  return n && e !== void 0 ? n + "-" + e : e;
}
function f_(e) {
  function n(l, a = {}) {
    return j_(e(l, a));
  }
  if (typeof Proxy > "u")
    return n;
  const t = /* @__PURE__ */ new Map();
  return new Proxy(n, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (l, a) => (t.has(a) || t.set(a, n(a)), t.get(a))
  });
}
const w_ = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function p1(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(w_.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(e))
    )
  );
}
const JR = {};
function g_(e) {
  Object.assign(JR, e);
}
const ZU = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], jV = new Set(ZU);
function OQ(e, { layout: n, layoutId: t }) {
  return jV.has(e) || e.startsWith("origin") || (n || t !== void 0) && (!!JR[e] || e === "opacity");
}
const Kl = (e) => !!(e && e.getVelocity), I_ = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, L_ = ZU.length;
function C_(e, { enableHardwareAcceleration: n = !0, allowTransformNone: t = !0 }, l, a) {
  let d = "";
  for (let r = 0; r < L_; r++) {
    const i = ZU[r];
    if (e[i] !== void 0) {
      const c = I_[i] || i;
      d += `${c}(${e[i]}) `;
    }
  }
  return n && !e.z && (d += "translateZ(0)"), d = d.trim(), a ? d = a(e, l ? "" : d) : t && l && (d = "none"), d;
}
const jQ = (e) => (n) => typeof n == "string" && n.startsWith(e), HQ = jQ("--"), KF = jQ("var(--"), K_ = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g, __ = (e, n) => n && typeof e == "number" ? n.transform(e) : e, Si = (e, n, t) => Math.min(Math.max(t, e), n), HV = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, ao = {
  ...HV,
  transform: (e) => Si(0, 1, e)
}, UN = {
  ...HV,
  default: 1
}, ro = (e) => Math.round(e * 1e5) / 1e5, bh = /(-)?([\d]*\.?[\d])+/g, fQ = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, P_ = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function TU(e) {
  return typeof e == "string";
}
const FU = (e) => ({
  test: (n) => TU(n) && n.endsWith(e) && n.split(" ").length === 1,
  parse: parseFloat,
  transform: (n) => `${n}${e}`
}), Lr = FU("deg"), Pd = FU("%"), wt = FU("px"), A_ = FU("vh"), q_ = FU("vw"), eE = {
  ...Pd,
  parse: (e) => Pd.parse(e) / 100,
  transform: (e) => Pd.transform(e * 100)
}, tE = {
  ...HV,
  transform: Math.round
}, wQ = {
  // Border props
  borderWidth: wt,
  borderTopWidth: wt,
  borderRightWidth: wt,
  borderBottomWidth: wt,
  borderLeftWidth: wt,
  borderRadius: wt,
  radius: wt,
  borderTopLeftRadius: wt,
  borderTopRightRadius: wt,
  borderBottomRightRadius: wt,
  borderBottomLeftRadius: wt,
  // Positioning props
  width: wt,
  maxWidth: wt,
  height: wt,
  maxHeight: wt,
  size: wt,
  top: wt,
  right: wt,
  bottom: wt,
  left: wt,
  // Spacing props
  padding: wt,
  paddingTop: wt,
  paddingRight: wt,
  paddingBottom: wt,
  paddingLeft: wt,
  margin: wt,
  marginTop: wt,
  marginRight: wt,
  marginBottom: wt,
  marginLeft: wt,
  // Transform props
  rotate: Lr,
  rotateX: Lr,
  rotateY: Lr,
  rotateZ: Lr,
  scale: UN,
  scaleX: UN,
  scaleY: UN,
  scaleZ: UN,
  skew: Lr,
  skewX: Lr,
  skewY: Lr,
  distance: wt,
  translateX: wt,
  translateY: wt,
  translateZ: wt,
  x: wt,
  y: wt,
  z: wt,
  perspective: wt,
  transformPerspective: wt,
  opacity: ao,
  originX: eE,
  originY: eE,
  originZ: wt,
  // Misc
  zIndex: tE,
  // SVG
  fillOpacity: ao,
  strokeOpacity: ao,
  numOctaves: tE
};
function M1(e, n, t, l) {
  const { style: a, vars: d, transform: r, transformOrigin: i } = e;
  let c = !1, V = !1, s = !0;
  for (const o in n) {
    const U = n[o];
    if (HQ(o)) {
      d[o] = U;
      continue;
    }
    const N = wQ[o], R = __(U, N);
    if (jV.has(o)) {
      if (c = !0, r[o] = R, !s)
        continue;
      U !== (N.default || 0) && (s = !1);
    } else
      o.startsWith("origin") ? (V = !0, i[o] = R) : a[o] = R;
  }
  if (n.transform || (c || l ? a.transform = C_(e.transform, t, s, l) : a.transform && (a.transform = "none")), V) {
    const { originX: o = "50%", originY: U = "50%", originZ: N = 0 } = i;
    a.transformOrigin = `${o} ${U} ${N}`;
  }
}
const E1 = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function gQ(e, n, t) {
  for (const l in n)
    !Kl(n[l]) && !OQ(l, t) && (e[l] = n[l]);
}
function $_({ transformTemplate: e }, n, t) {
  return nn(() => {
    const l = E1();
    return M1(l, n, { enableHardwareAcceleration: !t }, e), Object.assign({}, l.vars, l.style);
  }, [n]);
}
function eP(e, n, t) {
  const l = e.style || {}, a = {};
  return gQ(a, l, e), Object.assign(a, $_(e, n, t)), e.transformValues ? e.transformValues(a) : a;
}
function tP(e, n, t) {
  const l = {}, a = eP(e, n, t);
  return e.drag && e.dragListener !== !1 && (l.draggable = !1, a.userSelect = a.WebkitUserSelect = a.WebkitTouchCallout = "none", a.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (l.tabIndex = 0), l.style = a, l;
}
const nP = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function vR(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || nP.has(e);
}
let IQ = (e) => !vR(e);
function lP(e) {
  e && (IQ = (n) => n.startsWith("on") ? !vR(n) : e(n));
}
try {
  lP(require("@emotion/is-prop-valid").default);
} catch {
}
function aP(e, n, t) {
  const l = {};
  for (const a in e)
    a === "values" && typeof e.values == "object" || (IQ(a) || t === !0 && vR(a) || !n && !vR(a) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && a.startsWith("onDrag")) && (l[a] = e[a]);
  return l;
}
function nE(e, n, t) {
  return typeof e == "string" ? e : wt.transform(n + t * e);
}
function dP(e, n, t) {
  const l = nE(n, e.x, e.width), a = nE(t, e.y, e.height);
  return `${l} ${a}`;
}
const rP = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, iP = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function VP(e, n, t = 1, l = 0, a = !0) {
  e.pathLength = 1;
  const d = a ? rP : iP;
  e[d.offset] = wt.transform(-l);
  const r = wt.transform(n), i = wt.transform(t);
  e[d.array] = `${r} ${i}`;
}
function S1(e, {
  attrX: n,
  attrY: t,
  attrScale: l,
  originX: a,
  originY: d,
  pathLength: r,
  pathSpacing: i = 1,
  pathOffset: c = 0,
  // This is object creation, which we try to avoid per-frame.
  ...V
}, s, o, U) {
  if (M1(e, V, s, U), o) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: N, style: R, dimensions: h } = e;
  N.transform && (h && (R.transform = N.transform), delete N.transform), h && (a !== void 0 || d !== void 0 || R.transform) && (R.transformOrigin = dP(h, a !== void 0 ? a : 0.5, d !== void 0 ? d : 0.5)), n !== void 0 && (N.x = n), t !== void 0 && (N.y = t), l !== void 0 && (N.scale = l), r !== void 0 && VP(N, r, i, c, !1);
}
const LQ = () => ({
  ...E1(),
  attrs: {}
}), k1 = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function cP(e, n, t, l) {
  const a = nn(() => {
    const d = LQ();
    return S1(d, n, { enableHardwareAcceleration: !1 }, k1(l), e.transformTemplate), {
      ...d.attrs,
      style: { ...d.style }
    };
  }, [n]);
  if (e.style) {
    const d = {};
    gQ(d, e.style, e), a.style = { ...d, ...a.style };
  }
  return a;
}
function sP(e = !1) {
  return (t, l, a, { latestValues: d }, r) => {
    const c = (p1(t) ? cP : tP)(l, d, r, t), s = {
      ...aP(l, typeof t == "string", e),
      ...c,
      ref: a
    }, { children: o } = l, U = nn(() => Kl(o) ? o.get() : o, [o]);
    return na(t, {
      ...s,
      children: U
    });
  };
}
function CQ(e, { style: n, vars: t }, l, a) {
  Object.assign(e.style, n, a && a.getProjectionStyles(l));
  for (const d in t)
    e.style.setProperty(d, t[d]);
}
const KQ = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function _Q(e, n, t, l) {
  CQ(e, n, void 0, l);
  for (const a in n.attrs)
    e.setAttribute(KQ.has(a) ? a : F1(a), n.attrs[a]);
}
function b1(e, n) {
  const { style: t } = e, l = {};
  for (const a in t)
    (Kl(t[a]) || n.style && Kl(n.style[a]) || OQ(a, e)) && (l[a] = t[a]);
  return l;
}
function PQ(e, n) {
  const t = b1(e, n);
  for (const l in e)
    if (Kl(e[l]) || Kl(n[l])) {
      const a = ZU.indexOf(l) !== -1 ? "attr" + l.charAt(0).toUpperCase() + l.substring(1) : l;
      t[a] = e[l];
    }
  return t;
}
function Y1(e, n, t, l = {}, a = {}) {
  return typeof n == "function" && (n = n(t !== void 0 ? t : e.custom, l, a)), typeof n == "string" && (n = e.variants && e.variants[n]), typeof n == "function" && (n = n(t !== void 0 ? t : e.custom, l, a)), n;
}
function Yh(e) {
  const n = Wt(null);
  return n.current === null && (n.current = e()), n.current;
}
const zR = (e) => Array.isArray(e), oP = (e) => !!(e && typeof e == "object" && e.mix && e.toValue), UP = (e) => zR(e) ? e[e.length - 1] || 0 : e;
function HN(e) {
  const n = Kl(e) ? e.get() : e;
  return oP(n) ? n.toValue() : n;
}
function NP({ scrapeMotionValuesFromProps: e, createRenderState: n, onMount: t }, l, a, d) {
  const r = {
    latestValues: RP(l, a, d, e),
    renderState: n()
  };
  return t && (r.mount = (i) => t(l, i, r)), r;
}
const AQ = (e) => (n, t) => {
  const l = Gt(uh), a = Gt(ph), d = () => NP(e, n, l, a);
  return t ? d() : Yh(d);
};
function RP(e, n, t, l) {
  const a = {}, d = l(e, {});
  for (const U in d)
    a[U] = HN(d[U]);
  let { initial: r, animate: i } = e;
  const c = kh(e), V = DQ(e);
  n && V && !c && e.inherit !== !1 && (r === void 0 && (r = n.initial), i === void 0 && (i = n.animate));
  let s = t ? t.initial === !1 : !1;
  s = s || r === !1;
  const o = s ? i : r;
  return o && typeof o != "boolean" && !Sh(o) && (Array.isArray(o) ? o : [o]).forEach((N) => {
    const R = Y1(e, N);
    if (!R)
      return;
    const { transitionEnd: h, transition: Z, ...W } = R;
    for (const F in W) {
      let m = W[F];
      if (Array.isArray(m)) {
        const E = s ? m.length - 1 : 0;
        m = m[E];
      }
      m !== null && (a[F] = m);
    }
    for (const F in h)
      a[F] = h[F];
  }), a;
}
const ll = (e) => e;
class lE {
  constructor() {
    this.order = [], this.scheduled = /* @__PURE__ */ new Set();
  }
  add(n) {
    if (!this.scheduled.has(n))
      return this.scheduled.add(n), this.order.push(n), !0;
  }
  remove(n) {
    const t = this.order.indexOf(n);
    t !== -1 && (this.order.splice(t, 1), this.scheduled.delete(n));
  }
  clear() {
    this.order.length = 0, this.scheduled.clear();
  }
}
function hP(e) {
  let n = new lE(), t = new lE(), l = 0, a = !1, d = !1;
  const r = /* @__PURE__ */ new WeakSet(), i = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (c, V = !1, s = !1) => {
      const o = s && a, U = o ? n : t;
      return V && r.add(c), U.add(c) && o && a && (l = n.order.length), c;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (c) => {
      t.remove(c), r.delete(c);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (c) => {
      if (a) {
        d = !0;
        return;
      }
      if (a = !0, [n, t] = [t, n], t.clear(), l = n.order.length, l)
        for (let V = 0; V < l; V++) {
          const s = n.order[V];
          s(c), r.has(s) && (i.schedule(s), e());
        }
      a = !1, d && (d = !1, i.process(c));
    }
  };
  return i;
}
const NN = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], ZP = 40;
function TP(e, n) {
  let t = !1, l = !0;
  const a = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, d = NN.reduce((o, U) => (o[U] = hP(() => t = !0), o), {}), r = (o) => d[o].process(a), i = () => {
    const o = performance.now();
    t = !1, a.delta = l ? 1e3 / 60 : Math.max(Math.min(o - a.timestamp, ZP), 1), a.timestamp = o, a.isProcessing = !0, NN.forEach(r), a.isProcessing = !1, t && n && (l = !1, e(i));
  }, c = () => {
    t = !0, l = !0, a.isProcessing || e(i);
  };
  return { schedule: NN.reduce((o, U) => {
    const N = d[U];
    return o[U] = (R, h = !1, Z = !1) => (t || c(), N.schedule(R, h, Z)), o;
  }, {}), cancel: (o) => NN.forEach((U) => d[U].cancel(o)), state: a, steps: d };
}
const { schedule: Bn, cancel: Sd, state: gl, steps: qZ } = TP(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ll, !0), FP = {
  useVisualState: AQ({
    scrapeMotionValuesFromProps: PQ,
    createRenderState: LQ,
    onMount: (e, n, { renderState: t, latestValues: l }) => {
      Bn.read(() => {
        try {
          t.dimensions = typeof n.getBBox == "function" ? n.getBBox() : n.getBoundingClientRect();
        } catch {
          t.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), Bn.render(() => {
        S1(t, l, { enableHardwareAcceleration: !1 }, k1(n.tagName), e.transformTemplate), _Q(n, t);
      });
    }
  })
}, WP = {
  useVisualState: AQ({
    scrapeMotionValuesFromProps: b1,
    createRenderState: E1
  })
};
function mP(e, { forwardMotionProps: n = !1 }, t, l) {
  return {
    ...p1(e) ? FP : WP,
    preloadedFeatures: t,
    useRender: sP(n),
    createVisualElement: l,
    Component: e
  };
}
function ur(e, n, t, l = { passive: !0 }) {
  return e.addEventListener(n, t, l), () => e.removeEventListener(n, t);
}
const qQ = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function Qh(e, n = "page") {
  return {
    point: {
      x: e[n + "X"],
      y: e[n + "Y"]
    }
  };
}
const uP = (e) => (n) => qQ(n) && e(n, Qh(n));
function Qr(e, n, t, l) {
  return ur(e, n, uP(t), l);
}
const pP = (e, n) => (t) => n(e(t)), Wi = (...e) => e.reduce(pP);
function $Q(e) {
  let n = null;
  return () => {
    const t = () => {
      n = null;
    };
    return n === null ? (n = e, t) : !1;
  };
}
const aE = $Q("dragHorizontal"), dE = $Q("dragVertical");
function eJ(e) {
  let n = !1;
  if (e === "y")
    n = dE();
  else if (e === "x")
    n = aE();
  else {
    const t = aE(), l = dE();
    t && l ? n = () => {
      t(), l();
    } : (t && t(), l && l());
  }
  return n;
}
function tJ() {
  const e = eJ(!0);
  return e ? (e(), !1) : !0;
}
class vi {
  constructor(n) {
    this.isMounted = !1, this.node = n;
  }
  update() {
  }
}
function rE(e, n) {
  const t = "pointer" + (n ? "enter" : "leave"), l = "onHover" + (n ? "Start" : "End"), a = (d, r) => {
    if (d.pointerType === "touch" || tJ())
      return;
    const i = e.getProps();
    e.animationState && i.whileHover && e.animationState.setActive("whileHover", n), i[l] && Bn.update(() => i[l](d, r));
  };
  return Qr(e.current, t, a, {
    passive: !e.getProps()[l]
  });
}
class MP extends vi {
  mount() {
    this.unmount = Wi(rE(this.node, !0), rE(this.node, !1));
  }
  unmount() {
  }
}
class EP extends vi {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let n = !1;
    try {
      n = this.node.current.matches(":focus-visible");
    } catch {
      n = !0;
    }
    !n || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Wi(ur(this.node.current, "focus", () => this.onFocus()), ur(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const nJ = (e, n) => n ? e === n ? !0 : nJ(e, n.parentElement) : !1;
function $Z(e, n) {
  if (!n)
    return;
  const t = new PointerEvent("pointer" + e);
  n(t, Qh(t));
}
class SP extends vi {
  constructor() {
    super(...arguments), this.removeStartListeners = ll, this.removeEndListeners = ll, this.removeAccessibleListeners = ll, this.startPointerPress = (n, t) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const l = this.node.getProps(), d = Qr(window, "pointerup", (i, c) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: V, onTapCancel: s, globalTapTarget: o } = this.node.getProps();
        Bn.update(() => {
          !o && !nJ(this.node.current, i.target) ? s && s(i, c) : V && V(i, c);
        });
      }, { passive: !(l.onTap || l.onPointerUp) }), r = Qr(window, "pointercancel", (i, c) => this.cancelPress(i, c), { passive: !(l.onTapCancel || l.onPointerCancel) });
      this.removeEndListeners = Wi(d, r), this.startPress(n, t);
    }, this.startAccessiblePress = () => {
      const n = (d) => {
        if (d.key !== "Enter" || this.isPressing)
          return;
        const r = (i) => {
          i.key !== "Enter" || !this.checkPressEnd() || $Z("up", (c, V) => {
            const { onTap: s } = this.node.getProps();
            s && Bn.update(() => s(c, V));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = ur(this.node.current, "keyup", r), $Z("down", (i, c) => {
          this.startPress(i, c);
        });
      }, t = ur(this.node.current, "keydown", n), l = () => {
        this.isPressing && $Z("cancel", (d, r) => this.cancelPress(d, r));
      }, a = ur(this.node.current, "blur", l);
      this.removeAccessibleListeners = Wi(t, a);
    };
  }
  startPress(n, t) {
    this.isPressing = !0;
    const { onTapStart: l, whileTap: a } = this.node.getProps();
    a && this.node.animationState && this.node.animationState.setActive("whileTap", !0), l && Bn.update(() => l(n, t));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !tJ();
  }
  cancelPress(n, t) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: l } = this.node.getProps();
    l && Bn.update(() => l(n, t));
  }
  mount() {
    const n = this.node.getProps(), t = Qr(n.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(n.onTapStart || n.onPointerStart) }), l = ur(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Wi(t, l);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const _F = /* @__PURE__ */ new WeakMap(), eT = /* @__PURE__ */ new WeakMap(), kP = (e) => {
  const n = _F.get(e.target);
  n && n(e);
}, bP = (e) => {
  e.forEach(kP);
};
function YP({ root: e, ...n }) {
  const t = e || document;
  eT.has(t) || eT.set(t, {});
  const l = eT.get(t), a = JSON.stringify(n);
  return l[a] || (l[a] = new IntersectionObserver(bP, { root: e, ...n })), l[a];
}
function QP(e, n, t) {
  const l = YP(n);
  return _F.set(e, t), l.observe(e), () => {
    _F.delete(e), l.unobserve(e);
  };
}
const JP = {
  some: 0,
  all: 1
};
class vP extends vi {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: n = {} } = this.node.getProps(), { root: t, margin: l, amount: a = "some", once: d } = n, r = {
      root: t ? t.current : void 0,
      rootMargin: l,
      threshold: typeof a == "number" ? a : JP[a]
    }, i = (c) => {
      const { isIntersecting: V } = c;
      if (this.isInView === V || (this.isInView = V, d && !V && this.hasEnteredView))
        return;
      V && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", V);
      const { onViewportEnter: s, onViewportLeave: o } = this.node.getProps(), U = V ? s : o;
      U && U(c);
    };
    return QP(this.node.current, r, i);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: n, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(zP(n, t)) && this.startObserver();
  }
  unmount() {
  }
}
function zP({ viewport: e = {} }, { viewport: n = {} } = {}) {
  return (t) => e[t] !== n[t];
}
const xP = {
  inView: {
    Feature: vP
  },
  tap: {
    Feature: SP
  },
  focus: {
    Feature: EP
  },
  hover: {
    Feature: MP
  }
};
function lJ(e, n) {
  if (!Array.isArray(n))
    return !1;
  const t = n.length;
  if (t !== e.length)
    return !1;
  for (let l = 0; l < t; l++)
    if (n[l] !== e[l])
      return !1;
  return !0;
}
function GP(e) {
  const n = {};
  return e.values.forEach((t, l) => n[l] = t.get()), n;
}
function yP(e) {
  const n = {};
  return e.values.forEach((t, l) => n[l] = t.getVelocity()), n;
}
function Jh(e, n, t) {
  const l = e.getProps();
  return Y1(l, n, t !== void 0 ? t : l.custom, GP(e), yP(e));
}
let WU = ll, ma = ll;
process.env.NODE_ENV !== "production" && (WU = (e, n) => {
  !e && typeof console < "u" && console.warn(n);
}, ma = (e, n) => {
  if (!e)
    throw new Error(n);
});
const Jr = (e) => e * 1e3, Ad = (e) => e / 1e3, BP = {
  current: !1
}, aJ = (e) => Array.isArray(e) && typeof e[0] == "number";
function dJ(e) {
  return !!(!e || typeof e == "string" && rJ[e] || aJ(e) || Array.isArray(e) && e.every(dJ));
}
const vs = ([e, n, t, l]) => `cubic-bezier(${e}, ${n}, ${t}, ${l})`, rJ = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: vs([0, 0.65, 0.55, 1]),
  circOut: vs([0.55, 0, 1, 0.45]),
  backIn: vs([0.31, 0.01, 0.66, -0.59]),
  backOut: vs([0.33, 1.53, 0.69, 0.99])
};
function iJ(e) {
  if (e)
    return aJ(e) ? vs(e) : Array.isArray(e) ? e.map(iJ) : rJ[e];
}
function DP(e, n, t, { delay: l = 0, duration: a, repeat: d = 0, repeatType: r = "loop", ease: i, times: c } = {}) {
  const V = { [n]: t };
  c && (V.offset = c);
  const s = iJ(i);
  return Array.isArray(s) && (V.easing = s), e.animate(V, {
    delay: l,
    duration: a,
    easing: Array.isArray(s) ? "linear" : s,
    fill: "both",
    iterations: d + 1,
    direction: r === "reverse" ? "alternate" : "normal"
  });
}
function XP(e, { repeat: n, repeatType: t = "loop" }) {
  const l = n && t !== "loop" && n % 2 === 1 ? 0 : e.length - 1;
  return e[l];
}
const VJ = (e, n, t) => (((1 - 3 * t + 3 * n) * e + (3 * t - 6 * n)) * e + 3 * n) * e, OP = 1e-7, jP = 12;
function HP(e, n, t, l, a) {
  let d, r, i = 0;
  do
    r = n + (t - n) / 2, d = VJ(r, l, a) - e, d > 0 ? t = r : n = r;
  while (Math.abs(d) > OP && ++i < jP);
  return r;
}
function mU(e, n, t, l) {
  if (e === n && t === l)
    return ll;
  const a = (d) => HP(d, 0, 1, e, t);
  return (d) => d === 0 || d === 1 ? d : VJ(a(d), n, l);
}
const fP = mU(0.42, 0, 1, 1), wP = mU(0, 0, 0.58, 1), cJ = mU(0.42, 0, 0.58, 1), sJ = (e) => Array.isArray(e) && typeof e[0] != "number", oJ = (e) => (n) => n <= 0.5 ? e(2 * n) / 2 : (2 - e(2 * (1 - n))) / 2, UJ = (e) => (n) => 1 - e(1 - n), Q1 = (e) => 1 - Math.sin(Math.acos(e)), NJ = UJ(Q1), gP = oJ(Q1), RJ = mU(0.33, 1.53, 0.69, 0.99), J1 = UJ(RJ), IP = oJ(J1), LP = (e) => (e *= 2) < 1 ? 0.5 * J1(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), iE = {
  linear: ll,
  easeIn: fP,
  easeInOut: cJ,
  easeOut: wP,
  circIn: Q1,
  circInOut: gP,
  circOut: NJ,
  backIn: J1,
  backInOut: IP,
  backOut: RJ,
  anticipate: LP
}, VE = (e) => {
  if (Array.isArray(e)) {
    ma(e.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [n, t, l, a] = e;
    return mU(n, t, l, a);
  } else if (typeof e == "string")
    return ma(iE[e] !== void 0, `Invalid easing type '${e}'`), iE[e];
  return e;
}, v1 = (e, n) => (t) => !!(TU(t) && P_.test(t) && t.startsWith(e) || n && Object.prototype.hasOwnProperty.call(t, n)), hJ = (e, n, t) => (l) => {
  if (!TU(l))
    return l;
  const [a, d, r, i] = l.match(bh);
  return {
    [e]: parseFloat(a),
    [n]: parseFloat(d),
    [t]: parseFloat(r),
    alpha: i !== void 0 ? parseFloat(i) : 1
  };
}, CP = (e) => Si(0, 255, e), tT = {
  ...HV,
  transform: (e) => Math.round(CP(e))
}, iV = {
  test: v1("rgb", "red"),
  parse: hJ("red", "green", "blue"),
  transform: ({ red: e, green: n, blue: t, alpha: l = 1 }) => "rgba(" + tT.transform(e) + ", " + tT.transform(n) + ", " + tT.transform(t) + ", " + ro(ao.transform(l)) + ")"
};
function KP(e) {
  let n = "", t = "", l = "", a = "";
  return e.length > 5 ? (n = e.substring(1, 3), t = e.substring(3, 5), l = e.substring(5, 7), a = e.substring(7, 9)) : (n = e.substring(1, 2), t = e.substring(2, 3), l = e.substring(3, 4), a = e.substring(4, 5), n += n, t += t, l += l, a += a), {
    red: parseInt(n, 16),
    green: parseInt(t, 16),
    blue: parseInt(l, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const PF = {
  test: v1("#"),
  parse: KP,
  transform: iV.transform
}, ec = {
  test: v1("hsl", "hue"),
  parse: hJ("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: n, lightness: t, alpha: l = 1 }) => "hsla(" + Math.round(e) + ", " + Pd.transform(ro(n)) + ", " + Pd.transform(ro(t)) + ", " + ro(ao.transform(l)) + ")"
}, $l = {
  test: (e) => iV.test(e) || PF.test(e) || ec.test(e),
  parse: (e) => iV.test(e) ? iV.parse(e) : ec.test(e) ? ec.parse(e) : PF.parse(e),
  transform: (e) => TU(e) ? e : e.hasOwnProperty("red") ? iV.transform(e) : ec.transform(e)
}, Cn = (e, n, t) => -t * e + t * n + e;
function nT(e, n, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? e + (n - e) * 6 * t : t < 1 / 2 ? n : t < 2 / 3 ? e + (n - e) * (2 / 3 - t) * 6 : e;
}
function _P({ hue: e, saturation: n, lightness: t, alpha: l }) {
  e /= 360, n /= 100, t /= 100;
  let a = 0, d = 0, r = 0;
  if (!n)
    a = d = r = t;
  else {
    const i = t < 0.5 ? t * (1 + n) : t + n - t * n, c = 2 * t - i;
    a = nT(c, i, e + 1 / 3), d = nT(c, i, e), r = nT(c, i, e - 1 / 3);
  }
  return {
    red: Math.round(a * 255),
    green: Math.round(d * 255),
    blue: Math.round(r * 255),
    alpha: l
  };
}
const lT = (e, n, t) => {
  const l = e * e;
  return Math.sqrt(Math.max(0, t * (n * n - l) + l));
}, PP = [PF, iV, ec], AP = (e) => PP.find((n) => n.test(e));
function cE(e) {
  const n = AP(e);
  ma(!!n, `'${e}' is not an animatable color. Use the equivalent color code instead.`);
  let t = n.parse(e);
  return n === ec && (t = _P(t)), t;
}
const ZJ = (e, n) => {
  const t = cE(e), l = cE(n), a = { ...t };
  return (d) => (a.red = lT(t.red, l.red, d), a.green = lT(t.green, l.green, d), a.blue = lT(t.blue, l.blue, d), a.alpha = Cn(t.alpha, l.alpha, d), iV.transform(a));
};
function qP(e) {
  var n, t;
  return isNaN(e) && TU(e) && (((n = e.match(bh)) === null || n === void 0 ? void 0 : n.length) || 0) + (((t = e.match(fQ)) === null || t === void 0 ? void 0 : t.length) || 0) > 0;
}
const TJ = {
  regex: K_,
  countKey: "Vars",
  token: "${v}",
  parse: ll
}, FJ = {
  regex: fQ,
  countKey: "Colors",
  token: "${c}",
  parse: $l.parse
}, WJ = {
  regex: bh,
  countKey: "Numbers",
  token: "${n}",
  parse: HV.parse
};
function aT(e, { regex: n, countKey: t, token: l, parse: a }) {
  const d = e.tokenised.match(n);
  d && (e["num" + t] = d.length, e.tokenised = e.tokenised.replace(n, l), e.values.push(...d.map(a)));
}
function xR(e) {
  const n = e.toString(), t = {
    value: n,
    tokenised: n,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  return t.value.includes("var(--") && aT(t, TJ), aT(t, FJ), aT(t, WJ), t;
}
function mJ(e) {
  return xR(e).values;
}
function uJ(e) {
  const { values: n, numColors: t, numVars: l, tokenised: a } = xR(e), d = n.length;
  return (r) => {
    let i = a;
    for (let c = 0; c < d; c++)
      c < l ? i = i.replace(TJ.token, r[c]) : c < l + t ? i = i.replace(FJ.token, $l.transform(r[c])) : i = i.replace(WJ.token, ro(r[c]));
    return i;
  };
}
const $P = (e) => typeof e == "number" ? 0 : e;
function eA(e) {
  const n = mJ(e);
  return uJ(e)(n.map($P));
}
const ki = {
  test: qP,
  parse: mJ,
  createTransformer: uJ,
  getAnimatableNone: eA
}, pJ = (e, n) => (t) => `${t > 0 ? n : e}`;
function MJ(e, n) {
  return typeof e == "number" ? (t) => Cn(e, n, t) : $l.test(e) ? ZJ(e, n) : e.startsWith("var(") ? pJ(e, n) : SJ(e, n);
}
const EJ = (e, n) => {
  const t = [...e], l = t.length, a = e.map((d, r) => MJ(d, n[r]));
  return (d) => {
    for (let r = 0; r < l; r++)
      t[r] = a[r](d);
    return t;
  };
}, tA = (e, n) => {
  const t = { ...e, ...n }, l = {};
  for (const a in t)
    e[a] !== void 0 && n[a] !== void 0 && (l[a] = MJ(e[a], n[a]));
  return (a) => {
    for (const d in l)
      t[d] = l[d](a);
    return t;
  };
}, SJ = (e, n) => {
  const t = ki.createTransformer(n), l = xR(e), a = xR(n);
  return l.numVars === a.numVars && l.numColors === a.numColors && l.numNumbers >= a.numNumbers ? Wi(EJ(l.values, a.values), t) : (WU(!0, `Complex values '${e}' and '${n}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), pJ(e, n));
}, yc = (e, n, t) => {
  const l = n - e;
  return l === 0 ? 1 : (t - e) / l;
}, sE = (e, n) => (t) => Cn(e, n, t);
function nA(e) {
  return typeof e == "number" ? sE : typeof e == "string" ? $l.test(e) ? ZJ : SJ : Array.isArray(e) ? EJ : typeof e == "object" ? tA : sE;
}
function lA(e, n, t) {
  const l = [], a = t || nA(e[0]), d = e.length - 1;
  for (let r = 0; r < d; r++) {
    let i = a(e[r], e[r + 1]);
    if (n) {
      const c = Array.isArray(n) ? n[r] || ll : n;
      i = Wi(c, i);
    }
    l.push(i);
  }
  return l;
}
function z1(e, n, { clamp: t = !0, ease: l, mixer: a } = {}) {
  const d = e.length;
  if (ma(d === n.length, "Both input and output ranges must be the same length"), d === 1)
    return () => n[0];
  e[0] > e[d - 1] && (e = [...e].reverse(), n = [...n].reverse());
  const r = lA(n, l, a), i = r.length, c = (V) => {
    let s = 0;
    if (i > 1)
      for (; s < e.length - 2 && !(V < e[s + 1]); s++)
        ;
    const o = yc(e[s], e[s + 1], V);
    return r[s](o);
  };
  return t ? (V) => c(Si(e[0], e[d - 1], V)) : c;
}
function kJ(e, n) {
  const t = e[e.length - 1];
  for (let l = 1; l <= n; l++) {
    const a = yc(0, n, l);
    e.push(Cn(t, 1, a));
  }
}
function bJ(e) {
  const n = [0];
  return kJ(n, e.length - 1), n;
}
function aA(e, n) {
  return e.map((t) => t * n);
}
function dA(e, n) {
  return e.map(() => n || cJ).splice(0, e.length - 1);
}
function GR({ duration: e = 300, keyframes: n, times: t, ease: l = "easeInOut" }) {
  const a = sJ(l) ? l.map(VE) : VE(l), d = {
    done: !1,
    value: n[0]
  }, r = aA(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    t && t.length === n.length ? t : bJ(n),
    e
  ), i = z1(r, n, {
    ease: Array.isArray(a) ? a : dA(n, a)
  });
  return {
    calculatedDuration: e,
    next: (c) => (d.value = i(c), d.done = c >= e, d)
  };
}
function YJ(e, n) {
  return n ? e * (1e3 / n) : 0;
}
const rA = 5;
function QJ(e, n, t) {
  const l = Math.max(n - rA, 0);
  return YJ(t - e(l), n - l);
}
const dT = 1e-3, iA = 0.01, oE = 10, VA = 0.05, cA = 1;
function sA({ duration: e = 800, bounce: n = 0.25, velocity: t = 0, mass: l = 1 }) {
  let a, d;
  WU(e <= Jr(oE), "Spring duration must be 10 seconds or less");
  let r = 1 - n;
  r = Si(VA, cA, r), e = Si(iA, oE, Ad(e)), r < 1 ? (a = (V) => {
    const s = V * r, o = s * e, U = s - t, N = AF(V, r), R = Math.exp(-o);
    return dT - U / N * R;
  }, d = (V) => {
    const o = V * r * e, U = o * t + t, N = Math.pow(r, 2) * Math.pow(V, 2) * e, R = Math.exp(-o), h = AF(Math.pow(V, 2), r);
    return (-a(V) + dT > 0 ? -1 : 1) * ((U - N) * R) / h;
  }) : (a = (V) => {
    const s = Math.exp(-V * e), o = (V - t) * e + 1;
    return -dT + s * o;
  }, d = (V) => {
    const s = Math.exp(-V * e), o = (t - V) * (e * e);
    return s * o;
  });
  const i = 5 / e, c = UA(a, d, i);
  if (e = Jr(e), isNaN(c))
    return {
      stiffness: 100,
      damping: 10,
      duration: e
    };
  {
    const V = Math.pow(c, 2) * l;
    return {
      stiffness: V,
      damping: r * 2 * Math.sqrt(l * V),
      duration: e
    };
  }
}
const oA = 12;
function UA(e, n, t) {
  let l = t;
  for (let a = 1; a < oA; a++)
    l = l - e(l) / n(l);
  return l;
}
function AF(e, n) {
  return e * Math.sqrt(1 - n * n);
}
const NA = ["duration", "bounce"], RA = ["stiffness", "damping", "mass"];
function UE(e, n) {
  return n.some((t) => e[t] !== void 0);
}
function hA(e) {
  let n = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!UE(e, RA) && UE(e, NA)) {
    const t = sA(e);
    n = {
      ...n,
      ...t,
      mass: 1
    }, n.isResolvedFromDuration = !0;
  }
  return n;
}
function x1({ keyframes: e, restDelta: n, restSpeed: t, ...l }) {
  const a = e[0], d = e[e.length - 1], r = { done: !1, value: a }, { stiffness: i, damping: c, mass: V, duration: s, velocity: o, isResolvedFromDuration: U } = hA({
    ...l,
    velocity: -Ad(l.velocity || 0)
  }), N = o || 0, R = c / (2 * Math.sqrt(i * V)), h = d - a, Z = Ad(Math.sqrt(i / V)), W = Math.abs(h) < 5;
  t || (t = W ? 0.01 : 2), n || (n = W ? 5e-3 : 0.5);
  let F;
  if (R < 1) {
    const m = AF(Z, R);
    F = (E) => {
      const u = Math.exp(-R * Z * E);
      return d - u * ((N + R * Z * h) / m * Math.sin(m * E) + h * Math.cos(m * E));
    };
  } else if (R === 1)
    F = (m) => d - Math.exp(-Z * m) * (h + (N + Z * h) * m);
  else {
    const m = Z * Math.sqrt(R * R - 1);
    F = (E) => {
      const u = Math.exp(-R * Z * E), b = Math.min(m * E, 300);
      return d - u * ((N + R * Z * h) * Math.sinh(b) + m * h * Math.cosh(b)) / m;
    };
  }
  return {
    calculatedDuration: U && s || null,
    next: (m) => {
      const E = F(m);
      if (U)
        r.done = m >= s;
      else {
        let u = N;
        m !== 0 && (R < 1 ? u = QJ(F, m, E) : u = 0);
        const b = Math.abs(u) <= t, k = Math.abs(d - E) <= n;
        r.done = b && k;
      }
      return r.value = r.done ? d : E, r;
    }
  };
}
function NE({ keyframes: e, velocity: n = 0, power: t = 0.8, timeConstant: l = 325, bounceDamping: a = 10, bounceStiffness: d = 500, modifyTarget: r, min: i, max: c, restDelta: V = 0.5, restSpeed: s }) {
  const o = e[0], U = {
    done: !1,
    value: o
  }, N = (Q) => i !== void 0 && Q < i || c !== void 0 && Q > c, R = (Q) => i === void 0 ? c : c === void 0 || Math.abs(i - Q) < Math.abs(c - Q) ? i : c;
  let h = t * n;
  const Z = o + h, W = r === void 0 ? Z : r(Z);
  W !== Z && (h = W - o);
  const F = (Q) => -h * Math.exp(-Q / l), m = (Q) => W + F(Q), E = (Q) => {
    const S = F(Q), v = m(Q);
    U.done = Math.abs(S) <= V, U.value = U.done ? W : v;
  };
  let u, b;
  const k = (Q) => {
    N(U.value) && (u = Q, b = x1({
      keyframes: [U.value, R(U.value)],
      velocity: QJ(m, Q, U.value),
      damping: a,
      stiffness: d,
      restDelta: V,
      restSpeed: s
    }));
  };
  return k(0), {
    calculatedDuration: null,
    next: (Q) => {
      let S = !1;
      return !b && u === void 0 && (S = !0, E(Q), k(Q)), u !== void 0 && Q > u ? b.next(Q - u) : (!S && E(Q), U);
    }
  };
}
const ZA = (e) => {
  const n = ({ timestamp: t }) => e(t);
  return {
    start: () => Bn.update(n, !0),
    stop: () => Sd(n),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => gl.isProcessing ? gl.timestamp : performance.now()
  };
}, qF = 2e4;
function $F(e) {
  let n = 0;
  const t = 50;
  let l = e.next(n);
  for (; !l.done && n < qF; )
    n += t, l = e.next(n);
  return n >= qF ? 1 / 0 : n;
}
const TA = {
  decay: NE,
  inertia: NE,
  tween: GR,
  keyframes: GR,
  spring: x1
};
function yR({ autoplay: e = !0, delay: n = 0, driver: t = ZA, keyframes: l, type: a = "keyframes", repeat: d = 0, repeatDelay: r = 0, repeatType: i = "loop", onPlay: c, onStop: V, onComplete: s, onUpdate: o, ...U }) {
  let N = 1, R = !1, h, Z;
  const W = () => {
    Z = new Promise((se) => {
      h = se;
    });
  };
  W();
  let F;
  const m = TA[a] || GR;
  let E;
  m !== GR && typeof l[0] != "number" && (process.env.NODE_ENV !== "production" && ma(l.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${l}`), E = z1([0, 100], l, {
    clamp: !1
  }), l = [0, 100]);
  const u = m({ ...U, keyframes: l });
  let b;
  i === "mirror" && (b = m({
    ...U,
    keyframes: [...l].reverse(),
    velocity: -(U.velocity || 0)
  }));
  let k = "idle", Q = null, S = null, v = null;
  u.calculatedDuration === null && d && (u.calculatedDuration = $F(u));
  const { calculatedDuration: G } = u;
  let w = 1 / 0, y = 1 / 0;
  G !== null && (w = G + r, y = w * (d + 1) - r);
  let g = 0;
  const f = (se) => {
    if (S === null)
      return;
    N > 0 && (S = Math.min(S, se)), N < 0 && (S = Math.min(se - y / N, S)), Q !== null ? g = Q : g = Math.round(se - S) * N;
    const le = g - n * (N >= 0 ? 1 : -1), L = N >= 0 ? le < 0 : le > y;
    g = Math.max(le, 0), k === "finished" && Q === null && (g = y);
    let $ = g, ee = u;
    if (d) {
      const Qe = Math.min(g, y) / w;
      let Ye = Math.floor(Qe), Se = Qe % 1;
      !Se && Qe >= 1 && (Se = 1), Se === 1 && Ye--, Ye = Math.min(Ye, d + 1), !!(Ye % 2) && (i === "reverse" ? (Se = 1 - Se, r && (Se -= r / w)) : i === "mirror" && (ee = b)), $ = Si(0, 1, Se) * w;
    }
    const O = L ? { done: !1, value: l[0] } : ee.next($);
    E && (O.value = E(O.value));
    let { done: re } = O;
    !L && G !== null && (re = N >= 0 ? g >= y : g <= 0);
    const te = Q === null && (k === "finished" || k === "running" && re);
    return o && o(O.value), te && Ue(), O;
  }, I = () => {
    F && F.stop(), F = void 0;
  }, K = () => {
    k = "idle", I(), h(), W(), S = v = null;
  }, Ue = () => {
    k = "finished", s && s(), I(), h();
  }, q = () => {
    if (R)
      return;
    F || (F = t(f));
    const se = F.now();
    c && c(), Q !== null ? S = se - Q : (!S || k === "finished") && (S = se), k === "finished" && W(), v = S, Q = null, k = "running", F.start();
  };
  e && q();
  const ae = {
    then(se, le) {
      return Z.then(se, le);
    },
    get time() {
      return Ad(g);
    },
    set time(se) {
      se = Jr(se), g = se, Q !== null || !F || N === 0 ? Q = se : S = F.now() - se / N;
    },
    get duration() {
      const se = u.calculatedDuration === null ? $F(u) : u.calculatedDuration;
      return Ad(se);
    },
    get speed() {
      return N;
    },
    set speed(se) {
      se === N || !F || (N = se, ae.time = Ad(g));
    },
    get state() {
      return k;
    },
    play: q,
    pause: () => {
      k = "paused", Q = g;
    },
    stop: () => {
      R = !0, k !== "idle" && (k = "idle", V && V(), K());
    },
    cancel: () => {
      v !== null && f(v), K();
    },
    complete: () => {
      k = "finished";
    },
    sample: (se) => (S = 0, f(se))
  };
  return ae;
}
function JJ(e) {
  let n;
  return () => (n === void 0 && (n = e()), n);
}
const FA = JJ(() => Object.hasOwnProperty.call(Element.prototype, "animate")), WA = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]), RN = 10, mA = 2e4, uA = (e, n) => n.type === "spring" || e === "backgroundColor" || !dJ(n.ease);
function pA(e, n, { onUpdate: t, onComplete: l, ...a }) {
  if (!(FA() && WA.has(n) && !a.repeatDelay && a.repeatType !== "mirror" && a.damping !== 0 && a.type !== "inertia"))
    return !1;
  let r = !1, i, c, V = !1;
  const s = () => {
    c = new Promise((m) => {
      i = m;
    });
  };
  s();
  let { keyframes: o, duration: U = 300, ease: N, times: R } = a;
  if (uA(n, a)) {
    const m = yR({
      ...a,
      repeat: 0,
      delay: 0
    });
    let E = { done: !1, value: o[0] };
    const u = [];
    let b = 0;
    for (; !E.done && b < mA; )
      E = m.sample(b), u.push(E.value), b += RN;
    R = void 0, o = u, U = b - RN, N = "linear";
  }
  const h = DP(e.owner.current, n, o, {
    ...a,
    duration: U,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: N,
    times: R
  }), Z = () => {
    V = !1, h.cancel();
  }, W = () => {
    V = !0, Bn.update(Z), i(), s();
  };
  return h.onfinish = () => {
    V || (e.set(XP(o, a)), l && l(), W());
  }, {
    then(m, E) {
      return c.then(m, E);
    },
    attachTimeline(m) {
      return h.timeline = m, h.onfinish = null, ll;
    },
    get time() {
      return Ad(h.currentTime || 0);
    },
    set time(m) {
      h.currentTime = Jr(m);
    },
    get speed() {
      return h.playbackRate;
    },
    set speed(m) {
      h.playbackRate = m;
    },
    get duration() {
      return Ad(U);
    },
    play: () => {
      r || (h.play(), Sd(Z));
    },
    pause: () => h.pause(),
    stop: () => {
      if (r = !0, h.playState === "idle")
        return;
      const { currentTime: m } = h;
      if (m) {
        const E = yR({
          ...a,
          autoplay: !1
        });
        e.setWithVelocity(E.sample(m - RN).value, E.sample(m).value, RN);
      }
      W();
    },
    complete: () => {
      V || h.finish();
    },
    cancel: W
  };
}
function MA({ keyframes: e, delay: n, onUpdate: t, onComplete: l }) {
  const a = () => (t && t(e[e.length - 1]), l && l(), {
    time: 0,
    speed: 1,
    duration: 0,
    play: ll,
    pause: ll,
    stop: ll,
    then: (d) => (d(), Promise.resolve()),
    cancel: ll,
    complete: ll
  });
  return n ? yR({
    keyframes: [0, 1],
    duration: 0,
    delay: n,
    onComplete: a
  }) : a();
}
const EA = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, SA = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), kA = {
  type: "keyframes",
  duration: 0.8
}, bA = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, YA = (e, { keyframes: n }) => n.length > 2 ? kA : jV.has(e) ? e.startsWith("scale") ? SA(n[1]) : EA : bA, eW = (e, n) => e === "zIndex" ? !1 : !!(typeof n == "number" || Array.isArray(n) || typeof n == "string" && // It's animatable if we have a string
(ki.test(n) || n === "0") && // And it contains numbers and/or colors
!n.startsWith("url(")), QA = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function JA(e) {
  const [n, t] = e.slice(0, -1).split("(");
  if (n === "drop-shadow")
    return e;
  const [l] = t.match(bh) || [];
  if (!l)
    return e;
  const a = t.replace(l, "");
  let d = QA.has(n) ? 1 : 0;
  return l !== t && (d *= 100), n + "(" + d + a + ")";
}
const vA = /([a-z-]*)\(.*?\)/g, tW = {
  ...ki,
  getAnimatableNone: (e) => {
    const n = e.match(vA);
    return n ? n.map(JA).join(" ") : e;
  }
}, zA = {
  ...wQ,
  // Color props
  color: $l,
  backgroundColor: $l,
  outlineColor: $l,
  fill: $l,
  stroke: $l,
  // Border props
  borderColor: $l,
  borderTopColor: $l,
  borderRightColor: $l,
  borderBottomColor: $l,
  borderLeftColor: $l,
  filter: tW,
  WebkitFilter: tW
}, G1 = (e) => zA[e];
function vJ(e, n) {
  let t = G1(e);
  return t !== tW && (t = ki), t.getAnimatableNone ? t.getAnimatableNone(n) : void 0;
}
const zJ = (e) => /^0[^.\s]+$/.test(e);
function xA(e) {
  if (typeof e == "number")
    return e === 0;
  if (e !== null)
    return e === "none" || e === "0" || zJ(e);
}
function GA(e, n, t, l) {
  const a = eW(n, t);
  let d;
  Array.isArray(t) ? d = [...t] : d = [null, t];
  const r = l.from !== void 0 ? l.from : e.get();
  let i;
  const c = [];
  for (let V = 0; V < d.length; V++)
    d[V] === null && (d[V] = V === 0 ? r : d[V - 1]), xA(d[V]) && c.push(V), typeof d[V] == "string" && d[V] !== "none" && d[V] !== "0" && (i = d[V]);
  if (a && c.length && i)
    for (let V = 0; V < c.length; V++) {
      const s = c[V];
      d[s] = vJ(n, i);
    }
  return d;
}
function yA({ when: e, delay: n, delayChildren: t, staggerChildren: l, staggerDirection: a, repeat: d, repeatType: r, repeatDelay: i, from: c, elapsed: V, ...s }) {
  return !!Object.keys(s).length;
}
function y1(e, n) {
  return e[n] || e.default || e;
}
const BA = {
  skipAnimations: !1
}, B1 = (e, n, t, l = {}) => (a) => {
  const d = y1(l, e) || {}, r = d.delay || l.delay || 0;
  let { elapsed: i = 0 } = l;
  i = i - Jr(r);
  const c = GA(n, e, t, d), V = c[0], s = c[c.length - 1], o = eW(e, V), U = eW(e, s);
  WU(o === U, `You are trying to animate ${e} from "${V}" to "${s}". ${V} is not an animatable value - to enable this animation set ${V} to a value animatable to ${s} via the \`style\` property.`);
  let N = {
    keyframes: c,
    velocity: n.getVelocity(),
    ease: "easeOut",
    ...d,
    delay: -i,
    onUpdate: (R) => {
      n.set(R), d.onUpdate && d.onUpdate(R);
    },
    onComplete: () => {
      a(), d.onComplete && d.onComplete();
    }
  };
  if (yA(d) || (N = {
    ...N,
    ...YA(e, N)
  }), N.duration && (N.duration = Jr(N.duration)), N.repeatDelay && (N.repeatDelay = Jr(N.repeatDelay)), !o || !U || BP.current || d.type === !1 || BA.skipAnimations)
    return MA(N);
  if (
    /**
     * If this is a handoff animation, the optimised animation will be running via
     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
     * optimised animation.
     */
    !l.isHandoff && n.owner && n.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !n.owner.getProps().onUpdate
  ) {
    const R = pA(n, e, N);
    if (R)
      return R;
  }
  return yR(N);
};
function BR(e) {
  return !!(Kl(e) && e.add);
}
const xJ = (e) => /^\-?\d*\.?\d+$/.test(e);
function D1(e, n) {
  e.indexOf(n) === -1 && e.push(n);
}
function vh(e, n) {
  const t = e.indexOf(n);
  t > -1 && e.splice(t, 1);
}
class X1 {
  constructor() {
    this.subscriptions = [];
  }
  add(n) {
    return D1(this.subscriptions, n), () => vh(this.subscriptions, n);
  }
  notify(n, t, l) {
    const a = this.subscriptions.length;
    if (a)
      if (a === 1)
        this.subscriptions[0](n, t, l);
      else
        for (let d = 0; d < a; d++) {
          const r = this.subscriptions[d];
          r && r(n, t, l);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const RE = /* @__PURE__ */ new Set();
function zh(e, n, t) {
  e || RE.has(n) || (console.warn(n), t && console.warn(t), RE.add(n));
}
const DA = (e) => !isNaN(parseFloat(e)), io = {
  current: void 0
};
class XA {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(n, t = {}) {
    this.version = "10.18.0", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (l, a = !0) => {
      this.prev = this.current, this.current = l;
      const { delta: d, timestamp: r } = gl;
      this.lastUpdated !== r && (this.timeDelta = d, this.lastUpdated = r, Bn.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), a && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.scheduleVelocityCheck = () => Bn.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: l }) => {
      l !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
    }, this.hasAnimated = !1, this.prev = this.current = n, this.canTrackVelocity = DA(this.current), this.owner = t.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(n) {
    return process.env.NODE_ENV !== "production" && zh(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", n);
  }
  on(n, t) {
    this.events[n] || (this.events[n] = new X1());
    const l = this.events[n].add(t);
    return n === "change" ? () => {
      l(), Bn.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : l;
  }
  clearListeners() {
    for (const n in this.events)
      this.events[n].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(n, t) {
    this.passiveEffect = n, this.stopPassiveEffect = t;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(n, t = !0) {
    !t || !this.passiveEffect ? this.updateAndNotify(n, t) : this.passiveEffect(n, this.updateAndNotify);
  }
  setWithVelocity(n, t, l) {
    this.set(t), this.prev = n, this.timeDelta = l;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(n) {
    this.updateAndNotify(n), this.prev = n, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return io.current && io.current.push(this), this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      YJ(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(n) {
    return this.stop(), new Promise((t) => {
      this.hasAnimated = !0, this.animation = n(t), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function QV(e, n) {
  return new XA(e, n);
}
const GJ = (e) => (n) => n.test(e), OA = {
  test: (e) => e === "auto",
  parse: (e) => e
}, yJ = [HV, wt, Pd, Lr, q_, A_, OA], Ts = (e) => yJ.find(GJ(e)), jA = [...yJ, $l, ki], HA = (e) => jA.find(GJ(e));
function fA(e, n, t) {
  e.hasValue(n) ? e.getValue(n).set(t) : e.addValue(n, QV(t));
}
function wA(e, n) {
  const t = Jh(e, n);
  let { transitionEnd: l = {}, transition: a = {}, ...d } = t ? e.makeTargetAnimatable(t, !1) : {};
  d = { ...d, ...l };
  for (const r in d) {
    const i = UP(d[r]);
    fA(e, r, i);
  }
}
function gA(e, n, t) {
  var l, a;
  const d = Object.keys(n).filter((i) => !e.hasValue(i)), r = d.length;
  if (r)
    for (let i = 0; i < r; i++) {
      const c = d[i], V = n[c];
      let s = null;
      Array.isArray(V) && (s = V[0]), s === null && (s = (a = (l = t[c]) !== null && l !== void 0 ? l : e.readValue(c)) !== null && a !== void 0 ? a : n[c]), s != null && (typeof s == "string" && (xJ(s) || zJ(s)) ? s = parseFloat(s) : !HA(s) && ki.test(V) && (s = vJ(c, V)), e.addValue(c, QV(s, { owner: e })), t[c] === void 0 && (t[c] = s), s !== null && e.setBaseTarget(c, s));
    }
}
function IA(e, n) {
  return n ? (n[e] || n.default || n).from : void 0;
}
function LA(e, n, t) {
  const l = {};
  for (const a in e) {
    const d = IA(a, n);
    if (d !== void 0)
      l[a] = d;
    else {
      const r = t.getValue(a);
      r && (l[a] = r.get());
    }
  }
  return l;
}
function CA({ protectedKeys: e, needsAnimating: n }, t) {
  const l = e.hasOwnProperty(t) && n[t] !== !0;
  return n[t] = !1, l;
}
function KA(e, n) {
  const t = e.get();
  if (Array.isArray(n)) {
    for (let l = 0; l < n.length; l++)
      if (n[l] !== t)
        return !0;
  } else
    return t !== n;
}
function O1(e, n, { delay: t = 0, transitionOverride: l, type: a } = {}) {
  let { transition: d = e.getDefaultTransition(), transitionEnd: r, ...i } = e.makeTargetAnimatable(n);
  const c = e.getValue("willChange");
  l && (d = l);
  const V = [], s = a && e.animationState && e.animationState.getState()[a];
  for (const o in i) {
    const U = e.getValue(o), N = i[o];
    if (!U || N === void 0 || s && CA(s, o))
      continue;
    const R = {
      delay: t,
      elapsed: 0,
      ...y1(d || {}, o)
    };
    if (window.HandoffAppearAnimations) {
      const W = e.getProps()[BQ];
      if (W) {
        const F = window.HandoffAppearAnimations(W, o, U, Bn);
        F !== null && (R.elapsed = F, R.isHandoff = !0);
      }
    }
    let h = !R.isHandoff && !KA(U, N);
    if (R.type === "spring" && (U.getVelocity() || R.velocity) && (h = !1), U.animation && (h = !1), h)
      continue;
    U.start(B1(o, U, N, e.shouldReduceMotion && jV.has(o) ? { type: !1 } : R));
    const Z = U.animation;
    BR(c) && (c.add(o), Z.then(() => c.remove(o))), V.push(Z);
  }
  return r && Promise.all(V).then(() => {
    r && wA(e, r);
  }), V;
}
function nW(e, n, t = {}) {
  const l = Jh(e, n, t.custom);
  let { transition: a = e.getDefaultTransition() || {} } = l || {};
  t.transitionOverride && (a = t.transitionOverride);
  const d = l ? () => Promise.all(O1(e, l, t)) : () => Promise.resolve(), r = e.variantChildren && e.variantChildren.size ? (c = 0) => {
    const { delayChildren: V = 0, staggerChildren: s, staggerDirection: o } = a;
    return _A(e, n, V + c, s, o, t);
  } : () => Promise.resolve(), { when: i } = a;
  if (i) {
    const [c, V] = i === "beforeChildren" ? [d, r] : [r, d];
    return c().then(() => V());
  } else
    return Promise.all([d(), r(t.delay)]);
}
function _A(e, n, t = 0, l = 0, a = 1, d) {
  const r = [], i = (e.variantChildren.size - 1) * l, c = a === 1 ? (V = 0) => V * l : (V = 0) => i - V * l;
  return Array.from(e.variantChildren).sort(PA).forEach((V, s) => {
    V.notify("AnimationStart", n), r.push(nW(V, n, {
      ...d,
      delay: t + c(s)
    }).then(() => V.notify("AnimationComplete", n)));
  }), Promise.all(r);
}
function PA(e, n) {
  return e.sortNodePosition(n);
}
function AA(e, n, t = {}) {
  e.notify("AnimationStart", n);
  let l;
  if (Array.isArray(n)) {
    const a = n.map((d) => nW(e, d, t));
    l = Promise.all(a);
  } else if (typeof n == "string")
    l = nW(e, n, t);
  else {
    const a = typeof n == "function" ? Jh(e, n, t.custom) : n;
    l = Promise.all(O1(e, a, t));
  }
  return l.then(() => e.notify("AnimationComplete", n));
}
const qA = [...W1].reverse(), $A = W1.length;
function e8(e) {
  return (n) => Promise.all(n.map(({ animation: t, options: l }) => AA(e, t, l)));
}
function t8(e) {
  let n = e8(e);
  const t = l8();
  let l = !0;
  const a = (c, V) => {
    const s = Jh(e, V);
    if (s) {
      const { transition: o, transitionEnd: U, ...N } = s;
      c = { ...c, ...N, ...U };
    }
    return c;
  };
  function d(c) {
    n = c(e);
  }
  function r(c, V) {
    const s = e.getProps(), o = e.getVariantContext(!0) || {}, U = [], N = /* @__PURE__ */ new Set();
    let R = {}, h = 1 / 0;
    for (let W = 0; W < $A; W++) {
      const F = qA[W], m = t[F], E = s[F] !== void 0 ? s[F] : o[F], u = Bo(E), b = F === V ? m.isActive : null;
      b === !1 && (h = W);
      let k = E === o[F] && E !== s[F] && u;
      if (k && l && e.manuallyAnimateOnMount && (k = !1), m.protectedKeys = { ...R }, // If it isn't active and hasn't *just* been set as inactive
      !m.isActive && b === null || // If we didn't and don't have any defined prop for this animation type
      !E && !m.prevProp || // Or if the prop doesn't define an animation
      Sh(E) || typeof E == "boolean")
        continue;
      let S = n8(m.prevProp, E) || // If we're making this variant active, we want to always make it active
      F === V && m.isActive && !k && u || // If we removed a higher-priority variant (i is in reverse order)
      W > h && u, v = !1;
      const G = Array.isArray(E) ? E : [E];
      let w = G.reduce(a, {});
      b === !1 && (w = {});
      const { prevResolvedValues: y = {} } = m, g = {
        ...y,
        ...w
      }, f = (I) => {
        S = !0, N.has(I) && (v = !0, N.delete(I)), m.needsAnimating[I] = !0;
      };
      for (const I in g) {
        const K = w[I], Ue = y[I];
        if (R.hasOwnProperty(I))
          continue;
        let q = !1;
        zR(K) && zR(Ue) ? q = !lJ(K, Ue) : q = K !== Ue, q ? K !== void 0 ? f(I) : N.add(I) : K !== void 0 && N.has(I) ? f(I) : m.protectedKeys[I] = !0;
      }
      m.prevProp = E, m.prevResolvedValues = w, m.isActive && (R = { ...R, ...w }), l && e.blockInitialAnimation && (S = !1), S && (!k || v) && U.push(...G.map((I) => ({
        animation: I,
        options: { type: F, ...c }
      })));
    }
    if (N.size) {
      const W = {};
      N.forEach((F) => {
        const m = e.getBaseTarget(F);
        m !== void 0 && (W[F] = m);
      }), U.push({ animation: W });
    }
    let Z = !!U.length;
    return l && (s.initial === !1 || s.initial === s.animate) && !e.manuallyAnimateOnMount && (Z = !1), l = !1, Z ? n(U) : Promise.resolve();
  }
  function i(c, V, s) {
    var o;
    if (t[c].isActive === V)
      return Promise.resolve();
    (o = e.variantChildren) === null || o === void 0 || o.forEach((N) => {
      var R;
      return (R = N.animationState) === null || R === void 0 ? void 0 : R.setActive(c, V);
    }), t[c].isActive = V;
    const U = r(s, c);
    for (const N in t)
      t[N].protectedKeys = {};
    return U;
  }
  return {
    animateChanges: r,
    setActive: i,
    setAnimateFunction: d,
    getState: () => t
  };
}
function n8(e, n) {
  return typeof n == "string" ? n !== e : Array.isArray(n) ? !lJ(n, e) : !1;
}
function Xi(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function l8() {
  return {
    animate: Xi(!0),
    whileInView: Xi(),
    whileHover: Xi(),
    whileTap: Xi(),
    whileDrag: Xi(),
    whileFocus: Xi(),
    exit: Xi()
  };
}
class a8 extends vi {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(n) {
    super(n), n.animationState || (n.animationState = t8(n));
  }
  updateAnimationControlsSubscription() {
    const { animate: n } = this.node.getProps();
    this.unmount(), Sh(n) && (this.unmount = n.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: n } = this.node.getProps(), { animate: t } = this.node.prevProps || {};
    n !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {
  }
}
let d8 = 0;
class r8 extends vi {
  constructor() {
    super(...arguments), this.id = d8++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: n, onExitComplete: t, custom: l } = this.node.presenceContext, { isPresent: a } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || n === a)
      return;
    const d = this.node.animationState.setActive("exit", !n, { custom: l ?? this.node.getProps().custom });
    t && !n && d.then(() => t(this.id));
  }
  mount() {
    const { register: n } = this.node.presenceContext || {};
    n && (this.unmount = n(this.id));
  }
  unmount() {
  }
}
const i8 = {
  animation: {
    Feature: a8
  },
  exit: {
    Feature: r8
  }
}, hE = (e, n) => Math.abs(e - n);
function V8(e, n) {
  const t = hE(e.x, n.x), l = hE(e.y, n.y);
  return Math.sqrt(t ** 2 + l ** 2);
}
class BJ {
  constructor(n, t, { transformPagePoint: l, contextWindow: a, dragSnapToOrigin: d = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const o = iT(this.lastMoveEventInfo, this.history), U = this.startEvent !== null, N = V8(o.offset, { x: 0, y: 0 }) >= 3;
      if (!U && !N)
        return;
      const { point: R } = o, { timestamp: h } = gl;
      this.history.push({ ...R, timestamp: h });
      const { onStart: Z, onMove: W } = this.handlers;
      U || (Z && Z(this.lastMoveEvent, o), this.startEvent = this.lastMoveEvent), W && W(this.lastMoveEvent, o);
    }, this.handlePointerMove = (o, U) => {
      this.lastMoveEvent = o, this.lastMoveEventInfo = rT(U, this.transformPagePoint), Bn.update(this.updatePoint, !0);
    }, this.handlePointerUp = (o, U) => {
      this.end();
      const { onEnd: N, onSessionEnd: R, resumeAnimation: h } = this.handlers;
      if (this.dragSnapToOrigin && h && h(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const Z = iT(o.type === "pointercancel" ? this.lastMoveEventInfo : rT(U, this.transformPagePoint), this.history);
      this.startEvent && N && N(o, Z), R && R(o, Z);
    }, !qQ(n))
      return;
    this.dragSnapToOrigin = d, this.handlers = t, this.transformPagePoint = l, this.contextWindow = a || window;
    const r = Qh(n), i = rT(r, this.transformPagePoint), { point: c } = i, { timestamp: V } = gl;
    this.history = [{ ...c, timestamp: V }];
    const { onSessionStart: s } = t;
    s && s(n, iT(i, this.history)), this.removeListeners = Wi(Qr(this.contextWindow, "pointermove", this.handlePointerMove), Qr(this.contextWindow, "pointerup", this.handlePointerUp), Qr(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(n) {
    this.handlers = n;
  }
  end() {
    this.removeListeners && this.removeListeners(), Sd(this.updatePoint);
  }
}
function rT(e, n) {
  return n ? { point: n(e.point) } : e;
}
function ZE(e, n) {
  return { x: e.x - n.x, y: e.y - n.y };
}
function iT({ point: e }, n) {
  return {
    point: e,
    delta: ZE(e, DJ(n)),
    offset: ZE(e, c8(n)),
    velocity: s8(n, 0.1)
  };
}
function c8(e) {
  return e[0];
}
function DJ(e) {
  return e[e.length - 1];
}
function s8(e, n) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let t = e.length - 1, l = null;
  const a = DJ(e);
  for (; t >= 0 && (l = e[t], !(a.timestamp - l.timestamp > Jr(n))); )
    t--;
  if (!l)
    return { x: 0, y: 0 };
  const d = Ad(a.timestamp - l.timestamp);
  if (d === 0)
    return { x: 0, y: 0 };
  const r = {
    x: (a.x - l.x) / d,
    y: (a.y - l.y) / d
  };
  return r.x === 1 / 0 && (r.x = 0), r.y === 1 / 0 && (r.y = 0), r;
}
function Ha(e) {
  return e.max - e.min;
}
function lW(e, n = 0, t = 0.01) {
  return Math.abs(e - n) <= t;
}
function TE(e, n, t, l = 0.5) {
  e.origin = l, e.originPoint = Cn(n.min, n.max, e.origin), e.scale = Ha(t) / Ha(n), (lW(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1), e.translate = Cn(t.min, t.max, e.origin) - e.originPoint, (lW(e.translate) || isNaN(e.translate)) && (e.translate = 0);
}
function Vo(e, n, t, l) {
  TE(e.x, n.x, t.x, l ? l.originX : void 0), TE(e.y, n.y, t.y, l ? l.originY : void 0);
}
function FE(e, n, t) {
  e.min = t.min + n.min, e.max = e.min + Ha(n);
}
function o8(e, n, t) {
  FE(e.x, n.x, t.x), FE(e.y, n.y, t.y);
}
function WE(e, n, t) {
  e.min = n.min - t.min, e.max = e.min + Ha(n);
}
function co(e, n, t) {
  WE(e.x, n.x, t.x), WE(e.y, n.y, t.y);
}
function U8(e, { min: n, max: t }, l) {
  return n !== void 0 && e < n ? e = l ? Cn(n, e, l.min) : Math.max(e, n) : t !== void 0 && e > t && (e = l ? Cn(t, e, l.max) : Math.min(e, t)), e;
}
function mE(e, n, t) {
  return {
    min: n !== void 0 ? e.min + n : void 0,
    max: t !== void 0 ? e.max + t - (e.max - e.min) : void 0
  };
}
function N8(e, { top: n, left: t, bottom: l, right: a }) {
  return {
    x: mE(e.x, t, a),
    y: mE(e.y, n, l)
  };
}
function uE(e, n) {
  let t = n.min - e.min, l = n.max - e.max;
  return n.max - n.min < e.max - e.min && ([t, l] = [l, t]), { min: t, max: l };
}
function R8(e, n) {
  return {
    x: uE(e.x, n.x),
    y: uE(e.y, n.y)
  };
}
function h8(e, n) {
  let t = 0.5;
  const l = Ha(e), a = Ha(n);
  return a > l ? t = yc(n.min, n.max - l, e.min) : l > a && (t = yc(e.min, e.max - a, n.min)), Si(0, 1, t);
}
function Z8(e, n) {
  const t = {};
  return n.min !== void 0 && (t.min = n.min - e.min), n.max !== void 0 && (t.max = n.max - e.min), t;
}
const aW = 0.35;
function T8(e = aW) {
  return e === !1 ? e = 0 : e === !0 && (e = aW), {
    x: pE(e, "left", "right"),
    y: pE(e, "top", "bottom")
  };
}
function pE(e, n, t) {
  return {
    min: ME(e, n),
    max: ME(e, t)
  };
}
function ME(e, n) {
  return typeof e == "number" ? e : e[n] || 0;
}
const EE = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), tc = () => ({
  x: EE(),
  y: EE()
}), SE = () => ({ min: 0, max: 0 }), Rl = () => ({
  x: SE(),
  y: SE()
});
function La(e) {
  return [e("x"), e("y")];
}
function XJ({ top: e, left: n, right: t, bottom: l }) {
  return {
    x: { min: n, max: t },
    y: { min: e, max: l }
  };
}
function F8({ x: e, y: n }) {
  return { top: n.min, right: e.max, bottom: n.max, left: e.min };
}
function W8(e, n) {
  if (!n)
    return e;
  const t = n({ x: e.left, y: e.top }), l = n({ x: e.right, y: e.bottom });
  return {
    top: t.y,
    left: t.x,
    bottom: l.y,
    right: l.x
  };
}
function VT(e) {
  return e === void 0 || e === 1;
}
function dW({ scale: e, scaleX: n, scaleY: t }) {
  return !VT(e) || !VT(n) || !VT(t);
}
function Hi(e) {
  return dW(e) || OJ(e) || e.z || e.rotate || e.rotateX || e.rotateY;
}
function OJ(e) {
  return kE(e.x) || kE(e.y);
}
function kE(e) {
  return e && e !== "0%";
}
function DR(e, n, t) {
  const l = e - t, a = n * l;
  return t + a;
}
function bE(e, n, t, l, a) {
  return a !== void 0 && (e = DR(e, a, l)), DR(e, t, l) + n;
}
function rW(e, n = 0, t = 1, l, a) {
  e.min = bE(e.min, n, t, l, a), e.max = bE(e.max, n, t, l, a);
}
function jJ(e, { x: n, y: t }) {
  rW(e.x, n.translate, n.scale, n.originPoint), rW(e.y, t.translate, t.scale, t.originPoint);
}
function m8(e, n, t, l = !1) {
  const a = t.length;
  if (!a)
    return;
  n.x = n.y = 1;
  let d, r;
  for (let i = 0; i < a; i++) {
    d = t[i], r = d.projectionDelta;
    const c = d.instance;
    c && c.style && c.style.display === "contents" || (l && d.options.layoutScroll && d.scroll && d !== d.root && nc(e, {
      x: -d.scroll.offset.x,
      y: -d.scroll.offset.y
    }), r && (n.x *= r.x.scale, n.y *= r.y.scale, jJ(e, r)), l && Hi(d.latestValues) && nc(e, d.latestValues));
  }
  n.x = YE(n.x), n.y = YE(n.y);
}
function YE(e) {
  return Number.isInteger(e) || e > 1.0000000000001 || e < 0.999999999999 ? e : 1;
}
function Ar(e, n) {
  e.min = e.min + n, e.max = e.max + n;
}
function QE(e, n, [t, l, a]) {
  const d = n[a] !== void 0 ? n[a] : 0.5, r = Cn(e.min, e.max, d);
  rW(e, n[t], n[l], r, n.scale);
}
const u8 = ["x", "scaleX", "originX"], p8 = ["y", "scaleY", "originY"];
function nc(e, n) {
  QE(e.x, n, u8), QE(e.y, n, p8);
}
function HJ(e, n) {
  return XJ(W8(e.getBoundingClientRect(), n));
}
function M8(e, n, t) {
  const l = HJ(e, t), { scroll: a } = n;
  return a && (Ar(l.x, a.offset.x), Ar(l.y, a.offset.y)), l;
}
const fJ = ({ current: e }) => e ? e.ownerDocument.defaultView : null, E8 = /* @__PURE__ */ new WeakMap();
class S8 {
  constructor(n) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Rl(), this.visualElement = n;
  }
  start(n, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: l } = this.visualElement;
    if (l && l.isPresent === !1)
      return;
    const a = (s) => {
      const { dragSnapToOrigin: o } = this.getProps();
      o ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(Qh(s, "page").point);
    }, d = (s, o) => {
      const { drag: U, dragPropagation: N, onDragStart: R } = this.getProps();
      if (U && !N && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = eJ(U), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), La((Z) => {
        let W = this.getAxisMotionValue(Z).get() || 0;
        if (Pd.test(W)) {
          const { projection: F } = this.visualElement;
          if (F && F.layout) {
            const m = F.layout.layoutBox[Z];
            m && (W = Ha(m) * (parseFloat(W) / 100));
          }
        }
        this.originPoint[Z] = W;
      }), R && Bn.update(() => R(s, o), !1, !0);
      const { animationState: h } = this.visualElement;
      h && h.setActive("whileDrag", !0);
    }, r = (s, o) => {
      const { dragPropagation: U, dragDirectionLock: N, onDirectionLock: R, onDrag: h } = this.getProps();
      if (!U && !this.openGlobalLock)
        return;
      const { offset: Z } = o;
      if (N && this.currentDirection === null) {
        this.currentDirection = k8(Z), this.currentDirection !== null && R && R(this.currentDirection);
        return;
      }
      this.updateAxis("x", o.point, Z), this.updateAxis("y", o.point, Z), this.visualElement.render(), h && h(s, o);
    }, i = (s, o) => this.stop(s, o), c = () => La((s) => {
      var o;
      return this.getAnimationState(s) === "paused" && ((o = this.getAxisMotionValue(s).animation) === null || o === void 0 ? void 0 : o.play());
    }), { dragSnapToOrigin: V } = this.getProps();
    this.panSession = new BJ(n, {
      onSessionStart: a,
      onStart: d,
      onMove: r,
      onSessionEnd: i,
      resumeAnimation: c
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: V,
      contextWindow: fJ(this.visualElement)
    });
  }
  stop(n, t) {
    const l = this.isDragging;
    if (this.cancel(), !l)
      return;
    const { velocity: a } = t;
    this.startAnimation(a);
    const { onDragEnd: d } = this.getProps();
    d && Bn.update(() => d(n, t));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: n, animationState: t } = this.visualElement;
    n && (n.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: l } = this.getProps();
    !l && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1);
  }
  updateAxis(n, t, l) {
    const { drag: a } = this.getProps();
    if (!l || !hN(n, a, this.currentDirection))
      return;
    const d = this.getAxisMotionValue(n);
    let r = this.originPoint[n] + l[n];
    this.constraints && this.constraints[n] && (r = U8(r, this.constraints[n], this.elastic[n])), d.set(r);
  }
  resolveConstraints() {
    var n;
    const { dragConstraints: t, dragElastic: l } = this.getProps(), a = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (n = this.visualElement.projection) === null || n === void 0 ? void 0 : n.layout, d = this.constraints;
    t && $V(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && a ? this.constraints = N8(a.layoutBox, t) : this.constraints = !1, this.elastic = T8(l), d !== this.constraints && a && this.constraints && !this.hasMutatedConstraints && La((r) => {
      this.getAxisMotionValue(r) && (this.constraints[r] = Z8(a.layoutBox[r], this.constraints[r]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: n, onMeasureDragConstraints: t } = this.getProps();
    if (!n || !$V(n))
      return !1;
    const l = n.current;
    ma(l !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: a } = this.visualElement;
    if (!a || !a.layout)
      return !1;
    const d = M8(l, a.root, this.visualElement.getTransformPagePoint());
    let r = R8(a.layout.layoutBox, d);
    if (t) {
      const i = t(F8(r));
      this.hasMutatedConstraints = !!i, i && (r = XJ(i));
    }
    return r;
  }
  startAnimation(n) {
    const { drag: t, dragMomentum: l, dragElastic: a, dragTransition: d, dragSnapToOrigin: r, onDragTransitionEnd: i } = this.getProps(), c = this.constraints || {}, V = La((s) => {
      if (!hN(s, t, this.currentDirection))
        return;
      let o = c && c[s] || {};
      r && (o = { min: 0, max: 0 });
      const U = a ? 200 : 1e6, N = a ? 40 : 1e7, R = {
        type: "inertia",
        velocity: l ? n[s] : 0,
        bounceStiffness: U,
        bounceDamping: N,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...d,
        ...o
      };
      return this.startAxisValueAnimation(s, R);
    });
    return Promise.all(V).then(i);
  }
  startAxisValueAnimation(n, t) {
    const l = this.getAxisMotionValue(n);
    return l.start(B1(n, l, 0, t));
  }
  stopAnimation() {
    La((n) => this.getAxisMotionValue(n).stop());
  }
  pauseAnimation() {
    La((n) => {
      var t;
      return (t = this.getAxisMotionValue(n).animation) === null || t === void 0 ? void 0 : t.pause();
    });
  }
  getAnimationState(n) {
    var t;
    return (t = this.getAxisMotionValue(n).animation) === null || t === void 0 ? void 0 : t.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(n) {
    const t = "_drag" + n.toUpperCase(), l = this.visualElement.getProps(), a = l[t];
    return a || this.visualElement.getValue(n, (l.initial ? l.initial[n] : void 0) || 0);
  }
  snapToCursor(n) {
    La((t) => {
      const { drag: l } = this.getProps();
      if (!hN(t, l, this.currentDirection))
        return;
      const { projection: a } = this.visualElement, d = this.getAxisMotionValue(t);
      if (a && a.layout) {
        const { min: r, max: i } = a.layout.layoutBox[t];
        d.set(n[t] - Cn(r, i, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: n, dragConstraints: t } = this.getProps(), { projection: l } = this.visualElement;
    if (!$V(t) || !l || !this.constraints)
      return;
    this.stopAnimation();
    const a = { x: 0, y: 0 };
    La((r) => {
      const i = this.getAxisMotionValue(r);
      if (i) {
        const c = i.get();
        a[r] = h8({ min: c, max: c }, this.constraints[r]);
      }
    });
    const { transformTemplate: d } = this.visualElement.getProps();
    this.visualElement.current.style.transform = d ? d({}, "") : "none", l.root && l.root.updateScroll(), l.updateLayout(), this.resolveConstraints(), La((r) => {
      if (!hN(r, n, null))
        return;
      const i = this.getAxisMotionValue(r), { min: c, max: V } = this.constraints[r];
      i.set(Cn(c, V, a[r]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    E8.set(this.visualElement, this);
    const n = this.visualElement.current, t = Qr(n, "pointerdown", (c) => {
      const { drag: V, dragListener: s = !0 } = this.getProps();
      V && s && this.start(c);
    }), l = () => {
      const { dragConstraints: c } = this.getProps();
      $V(c) && (this.constraints = this.resolveRefConstraints());
    }, { projection: a } = this.visualElement, d = a.addEventListener("measure", l);
    a && !a.layout && (a.root && a.root.updateScroll(), a.updateLayout()), l();
    const r = ur(window, "resize", () => this.scalePositionWithinConstraints()), i = a.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: V }) => {
      this.isDragging && V && (La((s) => {
        const o = this.getAxisMotionValue(s);
        o && (this.originPoint[s] += c[s].translate, o.set(o.get() + c[s].translate));
      }), this.visualElement.render());
    });
    return () => {
      r(), t(), d(), i && i();
    };
  }
  getProps() {
    const n = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: l = !1, dragPropagation: a = !1, dragConstraints: d = !1, dragElastic: r = aW, dragMomentum: i = !0 } = n;
    return {
      ...n,
      drag: t,
      dragDirectionLock: l,
      dragPropagation: a,
      dragConstraints: d,
      dragElastic: r,
      dragMomentum: i
    };
  }
}
function hN(e, n, t) {
  return (n === !0 || n === e) && (t === null || t === e);
}
function k8(e, n = 10) {
  let t = null;
  return Math.abs(e.y) > n ? t = "y" : Math.abs(e.x) > n && (t = "x"), t;
}
class b8 extends vi {
  constructor(n) {
    super(n), this.removeGroupControls = ll, this.removeListeners = ll, this.controls = new S8(n);
  }
  mount() {
    const { dragControls: n } = this.node.getProps();
    n && (this.removeGroupControls = n.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || ll;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const JE = (e) => (n, t) => {
  e && Bn.update(() => e(n, t));
};
class Y8 extends vi {
  constructor() {
    super(...arguments), this.removePointerDownListener = ll;
  }
  onPointerDown(n) {
    this.session = new BJ(n, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: fJ(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: n, onPanStart: t, onPan: l, onPanEnd: a } = this.node.getProps();
    return {
      onSessionStart: JE(n),
      onStart: JE(t),
      onMove: l,
      onEnd: (d, r) => {
        delete this.session, a && Bn.update(() => a(d, r));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Qr(this.node.current, "pointerdown", (n) => this.onPointerDown(n));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function Q8() {
  const e = Gt(ph);
  if (e === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: t, register: l } = e, a = oW();
  return _e(() => l(a), []), !n && t ? [!1, () => t && t(a)] : [!0];
}
const fN = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function vE(e, n) {
  return n.max === n.min ? 0 : e / (n.max - n.min) * 100;
}
const Fs = {
  correct: (e, n) => {
    if (!n.target)
      return e;
    if (typeof e == "string")
      if (wt.test(e))
        e = parseFloat(e);
      else
        return e;
    const t = vE(e, n.target.x), l = vE(e, n.target.y);
    return `${t}% ${l}%`;
  }
}, J8 = {
  correct: (e, { treeScale: n, projectionDelta: t }) => {
    const l = e, a = ki.parse(e);
    if (a.length > 5)
      return l;
    const d = ki.createTransformer(e), r = typeof a[0] != "number" ? 1 : 0, i = t.x.scale * n.x, c = t.y.scale * n.y;
    a[0 + r] /= i, a[1 + r] /= c;
    const V = Cn(i, c, 0.5);
    return typeof a[2 + r] == "number" && (a[2 + r] /= V), typeof a[3 + r] == "number" && (a[3 + r] /= V), d(a);
  }
};
class v8 extends T.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: n, layoutGroup: t, switchLayoutGroup: l, layoutId: a } = this.props, { projection: d } = n;
    g_(z8), d && (t.group && t.group.add(d), l && l.register && a && l.register(d), d.root.didUpdate(), d.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), d.setOptions({
      ...d.options,
      onExitComplete: () => this.safeToRemove()
    })), fN.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(n) {
    const { layoutDependency: t, visualElement: l, drag: a, isPresent: d } = this.props, r = l.projection;
    return r && (r.isPresent = d, a || n.layoutDependency !== t || t === void 0 ? r.willUpdate() : this.safeToRemove(), n.isPresent !== d && (d ? r.promote() : r.relegate() || Bn.postRender(() => {
      const i = r.getStack();
      (!i || !i.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: n } = this.props.visualElement;
    n && (n.root.didUpdate(), queueMicrotask(() => {
      !n.currentAnimation && n.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: n, layoutGroup: t, switchLayoutGroup: l } = this.props, { projection: a } = n;
    a && (a.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(a), l && l.deregister && l.deregister(a));
  }
  safeToRemove() {
    const { safeToRemove: n } = this.props;
    n && n();
  }
  render() {
    return null;
  }
}
function wJ(e) {
  const [n, t] = Q8(), l = Gt(u1);
  return T.createElement(v8, { ...e, layoutGroup: l, switchLayoutGroup: Gt(XQ), isPresent: n, safeToRemove: t });
}
const z8 = {
  borderRadius: {
    ...Fs,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Fs,
  borderTopRightRadius: Fs,
  borderBottomLeftRadius: Fs,
  borderBottomRightRadius: Fs,
  boxShadow: J8
}, gJ = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], x8 = gJ.length, zE = (e) => typeof e == "string" ? parseFloat(e) : e, xE = (e) => typeof e == "number" || wt.test(e);
function G8(e, n, t, l, a, d) {
  a ? (e.opacity = Cn(
    0,
    // TODO Reinstate this if only child
    t.opacity !== void 0 ? t.opacity : 1,
    y8(l)
  ), e.opacityExit = Cn(n.opacity !== void 0 ? n.opacity : 1, 0, B8(l))) : d && (e.opacity = Cn(n.opacity !== void 0 ? n.opacity : 1, t.opacity !== void 0 ? t.opacity : 1, l));
  for (let r = 0; r < x8; r++) {
    const i = `border${gJ[r]}Radius`;
    let c = GE(n, i), V = GE(t, i);
    if (c === void 0 && V === void 0)
      continue;
    c || (c = 0), V || (V = 0), c === 0 || V === 0 || xE(c) === xE(V) ? (e[i] = Math.max(Cn(zE(c), zE(V), l), 0), (Pd.test(V) || Pd.test(c)) && (e[i] += "%")) : e[i] = V;
  }
  (n.rotate || t.rotate) && (e.rotate = Cn(n.rotate || 0, t.rotate || 0, l));
}
function GE(e, n) {
  return e[n] !== void 0 ? e[n] : e.borderRadius;
}
const y8 = IJ(0, 0.5, NJ), B8 = IJ(0.5, 0.95, ll);
function IJ(e, n, t) {
  return (l) => l < e ? 0 : l > n ? 1 : t(yc(e, n, l));
}
function yE(e, n) {
  e.min = n.min, e.max = n.max;
}
function ga(e, n) {
  yE(e.x, n.x), yE(e.y, n.y);
}
function BE(e, n, t, l, a) {
  return e -= n, e = DR(e, 1 / t, l), a !== void 0 && (e = DR(e, 1 / a, l)), e;
}
function D8(e, n = 0, t = 1, l = 0.5, a, d = e, r = e) {
  if (Pd.test(n) && (n = parseFloat(n), n = Cn(r.min, r.max, n / 100) - r.min), typeof n != "number")
    return;
  let i = Cn(d.min, d.max, l);
  e === d && (i -= n), e.min = BE(e.min, n, t, i, a), e.max = BE(e.max, n, t, i, a);
}
function DE(e, n, [t, l, a], d, r) {
  D8(e, n[t], n[l], n[a], n.scale, d, r);
}
const X8 = ["x", "scaleX", "originX"], O8 = ["y", "scaleY", "originY"];
function XE(e, n, t, l) {
  DE(e.x, n, X8, t ? t.x : void 0, l ? l.x : void 0), DE(e.y, n, O8, t ? t.y : void 0, l ? l.y : void 0);
}
function OE(e) {
  return e.translate === 0 && e.scale === 1;
}
function LJ(e) {
  return OE(e.x) && OE(e.y);
}
function j8(e, n) {
  return e.x.min === n.x.min && e.x.max === n.x.max && e.y.min === n.y.min && e.y.max === n.y.max;
}
function CJ(e, n) {
  return Math.round(e.x.min) === Math.round(n.x.min) && Math.round(e.x.max) === Math.round(n.x.max) && Math.round(e.y.min) === Math.round(n.y.min) && Math.round(e.y.max) === Math.round(n.y.max);
}
function jE(e) {
  return Ha(e.x) / Ha(e.y);
}
class H8 {
  constructor() {
    this.members = [];
  }
  add(n) {
    D1(this.members, n), n.scheduleRender();
  }
  remove(n) {
    if (vh(this.members, n), n === this.prevLead && (this.prevLead = void 0), n === this.lead) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(n) {
    const t = this.members.findIndex((a) => n === a);
    if (t === 0)
      return !1;
    let l;
    for (let a = t; a >= 0; a--) {
      const d = this.members[a];
      if (d.isPresent !== !1) {
        l = d;
        break;
      }
    }
    return l ? (this.promote(l), !0) : !1;
  }
  promote(n, t) {
    const l = this.lead;
    if (n !== l && (this.prevLead = l, this.lead = n, n.show(), l)) {
      l.instance && l.scheduleRender(), n.scheduleRender(), n.resumeFrom = l, t && (n.resumeFrom.preserveOpacity = !0), l.snapshot && (n.snapshot = l.snapshot, n.snapshot.latestValues = l.animationValues || l.latestValues), n.root && n.root.isUpdating && (n.isLayoutDirty = !0);
      const { crossfade: a } = n.options;
      a === !1 && l.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((n) => {
      const { options: t, resumingFrom: l } = n;
      t.onExitComplete && t.onExitComplete(), l && l.options.onExitComplete && l.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((n) => {
      n.instance && n.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function HE(e, n, t) {
  let l = "";
  const a = e.x.translate / n.x, d = e.y.translate / n.y;
  if ((a || d) && (l = `translate3d(${a}px, ${d}px, 0) `), (n.x !== 1 || n.y !== 1) && (l += `scale(${1 / n.x}, ${1 / n.y}) `), t) {
    const { rotate: c, rotateX: V, rotateY: s } = t;
    c && (l += `rotate(${c}deg) `), V && (l += `rotateX(${V}deg) `), s && (l += `rotateY(${s}deg) `);
  }
  const r = e.x.scale * n.x, i = e.y.scale * n.y;
  return (r !== 1 || i !== 1) && (l += `scale(${r}, ${i})`), l || "none";
}
const f8 = (e, n) => e.depth - n.depth;
class w8 {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(n) {
    D1(this.children, n), this.isDirty = !0;
  }
  remove(n) {
    vh(this.children, n), this.isDirty = !0;
  }
  forEach(n) {
    this.isDirty && this.children.sort(f8), this.isDirty = !1, this.children.forEach(n);
  }
}
function g8(e, n) {
  const t = performance.now(), l = ({ timestamp: a }) => {
    const d = a - t;
    d >= n && (Sd(l), e(d - n));
  };
  return Bn.read(l, !0), () => Sd(l);
}
function I8(e) {
  window.MotionDebug && window.MotionDebug.record(e);
}
function KJ(e) {
  return e instanceof SVGElement && e.tagName !== "svg";
}
function j1(e, n, t) {
  const l = Kl(e) ? e : QV(e);
  return l.start(B1("", l, n, t)), l.animation;
}
const fE = ["", "X", "Y", "Z"], L8 = { visibility: "hidden" }, wE = 1e3;
let C8 = 0;
const fi = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function _J({ attachResizeListener: e, defaultParent: n, measureScroll: t, checkIsScrollRoot: l, resetTransform: a }) {
  return class {
    constructor(r = {}, i = n == null ? void 0 : n()) {
      this.id = C8++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, fi.totalNodes = fi.resolvedTargetDeltas = fi.recalculatedProjection = 0, this.nodes.forEach(P8), this.nodes.forEach(tq), this.nodes.forEach(nq), this.nodes.forEach(A8), I8(fi);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = r, this.root = i ? i.root || i : this, this.path = i ? [...i.path, i] : [], this.parent = i, this.depth = i ? i.depth + 1 : 0;
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0;
      this.root === this && (this.nodes = new w8());
    }
    addEventListener(r, i) {
      return this.eventHandlers.has(r) || this.eventHandlers.set(r, new X1()), this.eventHandlers.get(r).add(i);
    }
    notifyListeners(r, ...i) {
      const c = this.eventHandlers.get(r);
      c && c.notify(...i);
    }
    hasListeners(r) {
      return this.eventHandlers.has(r);
    }
    /**
     * Lifecycles
     */
    mount(r, i = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = KJ(r), this.instance = r;
      const { layoutId: c, layout: V, visualElement: s } = this.options;
      if (s && !s.current && s.mount(r), this.root.nodes.add(this), this.parent && this.parent.children.add(this), i && (V || c) && (this.isLayoutDirty = !0), e) {
        let o;
        const U = () => this.root.updateBlockedByResize = !1;
        e(r, () => {
          this.root.updateBlockedByResize = !0, o && o(), o = g8(U, 250), fN.hasAnimatedSinceResize && (fN.hasAnimatedSinceResize = !1, this.nodes.forEach(IE));
        });
      }
      c && this.root.registerSharedNode(c, this), this.options.animate !== !1 && s && (c || V) && this.addEventListener("didUpdate", ({ delta: o, hasLayoutChanged: U, hasRelativeTargetChanged: N, layout: R }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const h = this.options.transition || s.getDefaultTransition() || iq, { onLayoutAnimationStart: Z, onLayoutAnimationComplete: W } = s.getProps(), F = !this.targetLayout || !CJ(this.targetLayout, R) || N, m = !U && N;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || m || U && (F || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(o, m);
          const E = {
            ...y1(h, "layout"),
            onPlay: Z,
            onComplete: W
          };
          (s.shouldReduceMotion || this.options.layoutRoot) && (E.delay = 0, E.type = !1), this.startAnimation(E);
        } else
          U || IE(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = R;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const r = this.getStack();
      r && r.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Sd(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(lq), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: r } = this.options;
      return r && r.getProps().transformTemplate;
    }
    willUpdate(r = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let s = 0; s < this.path.length; s++) {
        const o = this.path[s];
        o.shouldResetTransform = !0, o.updateScroll("snapshot"), o.options.layoutRoot && o.willUpdate(!1);
      }
      const { layoutId: i, layout: c } = this.options;
      if (i === void 0 && !c)
        return;
      const V = this.getTransformTemplate();
      this.prevTransformTemplateValue = V ? V(this.latestValues, "") : void 0, this.updateSnapshot(), r && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(gE);
        return;
      }
      this.isUpdating || this.nodes.forEach($8), this.isUpdating = !1, this.nodes.forEach(eq), this.nodes.forEach(K8), this.nodes.forEach(_8), this.clearAllSnapshots();
      const i = performance.now();
      gl.delta = Si(0, 1e3 / 60, i - gl.timestamp), gl.timestamp = i, gl.isProcessing = !0, qZ.update.process(gl), qZ.preRender.process(gl), qZ.render.process(gl), gl.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, queueMicrotask(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(q8), this.sharedNodes.forEach(aq);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Bn.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Bn.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++)
          this.path[c].updateScroll();
      const r = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = Rl(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: i } = this.options;
      i && i.notify("LayoutMeasure", this.layout.layoutBox, r ? r.layoutBox : void 0);
    }
    updateScroll(r = "measure") {
      let i = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === r && (i = !1), i && (this.scroll = {
        animationId: this.root.animationId,
        phase: r,
        isRoot: l(this.instance),
        offset: t(this.instance)
      });
    }
    resetTransform() {
      if (!a)
        return;
      const r = this.isLayoutDirty || this.shouldResetTransform, i = this.projectionDelta && !LJ(this.projectionDelta), c = this.getTransformTemplate(), V = c ? c(this.latestValues, "") : void 0, s = V !== this.prevTransformTemplateValue;
      r && (i || Hi(this.latestValues) || s) && (a(this.instance, V), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(r = !0) {
      const i = this.measurePageBox();
      let c = this.removeElementScroll(i);
      return r && (c = this.removeTransform(c)), Vq(c), {
        animationId: this.root.animationId,
        measuredBox: i,
        layoutBox: c,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: r } = this.options;
      if (!r)
        return Rl();
      const i = r.measureViewportBox(), { scroll: c } = this.root;
      return c && (Ar(i.x, c.offset.x), Ar(i.y, c.offset.y)), i;
    }
    removeElementScroll(r) {
      const i = Rl();
      ga(i, r);
      for (let c = 0; c < this.path.length; c++) {
        const V = this.path[c], { scroll: s, options: o } = V;
        if (V !== this.root && s && o.layoutScroll) {
          if (s.isRoot) {
            ga(i, r);
            const { scroll: U } = this.root;
            U && (Ar(i.x, -U.offset.x), Ar(i.y, -U.offset.y));
          }
          Ar(i.x, s.offset.x), Ar(i.y, s.offset.y);
        }
      }
      return i;
    }
    applyTransform(r, i = !1) {
      const c = Rl();
      ga(c, r);
      for (let V = 0; V < this.path.length; V++) {
        const s = this.path[V];
        !i && s.options.layoutScroll && s.scroll && s !== s.root && nc(c, {
          x: -s.scroll.offset.x,
          y: -s.scroll.offset.y
        }), Hi(s.latestValues) && nc(c, s.latestValues);
      }
      return Hi(this.latestValues) && nc(c, this.latestValues), c;
    }
    removeTransform(r) {
      const i = Rl();
      ga(i, r);
      for (let c = 0; c < this.path.length; c++) {
        const V = this.path[c];
        if (!V.instance || !Hi(V.latestValues))
          continue;
        dW(V.latestValues) && V.updateSnapshot();
        const s = Rl(), o = V.measurePageBox();
        ga(s, o), XE(i, V.latestValues, V.snapshot ? V.snapshot.layoutBox : void 0, s);
      }
      return Hi(this.latestValues) && XE(i, this.latestValues), i;
    }
    setTargetDelta(r) {
      this.targetDelta = r, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(r) {
      this.options = {
        ...this.options,
        ...r,
        crossfade: r.crossfade !== void 0 ? r.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== gl.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(r = !1) {
      var i;
      const c = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = c.isSharedProjectionDirty);
      const V = !!this.resumingFrom || this !== c;
      if (!(r || V && this.isSharedProjectionDirty || this.isProjectionDirty || !((i = this.parent) === null || i === void 0) && i.isProjectionDirty || this.attemptToResolveRelativeTarget))
        return;
      const { layout: o, layoutId: U } = this.options;
      if (!(!this.layout || !(o || U))) {
        if (this.resolvedRelativeTargetAt = gl.timestamp, !this.targetDelta && !this.relativeTarget) {
          const N = this.getClosestProjectingParent();
          N && N.layout && this.animationProgress !== 1 ? (this.relativeParent = N, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Rl(), this.relativeTargetOrigin = Rl(), co(this.relativeTargetOrigin, this.layout.layoutBox, N.layout.layoutBox), ga(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = Rl(), this.targetWithTransforms = Rl()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), o8(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : ga(this.target, this.layout.layoutBox), jJ(this.target, this.targetDelta)) : ga(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const N = this.getClosestProjectingParent();
            N && !!N.resumingFrom == !!this.resumingFrom && !N.options.layoutScroll && N.target && this.animationProgress !== 1 ? (this.relativeParent = N, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Rl(), this.relativeTargetOrigin = Rl(), co(this.relativeTargetOrigin, this.target, N.target), ga(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          fi.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || dW(this.parent.latestValues) || OJ(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var r;
      const i = this.getLead(), c = !!this.resumingFrom || this !== i;
      let V = !0;
      if ((this.isProjectionDirty || !((r = this.parent) === null || r === void 0) && r.isProjectionDirty) && (V = !1), c && (this.isSharedProjectionDirty || this.isTransformDirty) && (V = !1), this.resolvedRelativeTargetAt === gl.timestamp && (V = !1), V)
        return;
      const { layout: s, layoutId: o } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(s || o))
        return;
      ga(this.layoutCorrected, this.layout.layoutBox);
      const U = this.treeScale.x, N = this.treeScale.y;
      m8(this.layoutCorrected, this.treeScale, this.path, c), i.layout && !i.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (i.target = i.layout.layoutBox);
      const { target: R } = i;
      if (!R) {
        this.projectionTransform && (this.projectionDelta = tc(), this.projectionTransform = "none", this.scheduleRender());
        return;
      }
      this.projectionDelta || (this.projectionDelta = tc(), this.projectionDeltaWithTransform = tc());
      const h = this.projectionTransform;
      Vo(this.projectionDelta, this.layoutCorrected, R, this.latestValues), this.projectionTransform = HE(this.projectionDelta, this.treeScale), (this.projectionTransform !== h || this.treeScale.x !== U || this.treeScale.y !== N) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", R)), fi.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(r = !0) {
      if (this.options.scheduleRender && this.options.scheduleRender(), r) {
        const i = this.getStack();
        i && i.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(r, i = !1) {
      const c = this.snapshot, V = c ? c.latestValues : {}, s = { ...this.latestValues }, o = tc();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !i;
      const U = Rl(), N = c ? c.source : void 0, R = this.layout ? this.layout.source : void 0, h = N !== R, Z = this.getStack(), W = !Z || Z.members.length <= 1, F = !!(h && !W && this.options.crossfade === !0 && !this.path.some(rq));
      this.animationProgress = 0;
      let m;
      this.mixTargetDelta = (E) => {
        const u = E / 1e3;
        LE(o.x, r.x, u), LE(o.y, r.y, u), this.setTargetDelta(o), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (co(U, this.layout.layoutBox, this.relativeParent.layout.layoutBox), dq(this.relativeTarget, this.relativeTargetOrigin, U, u), m && j8(this.relativeTarget, m) && (this.isProjectionDirty = !1), m || (m = Rl()), ga(m, this.relativeTarget)), h && (this.animationValues = s, G8(s, V, this.latestValues, u, F, W)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = u;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(r) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Sd(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Bn.update(() => {
        fN.hasAnimatedSinceResize = !0, this.currentAnimation = j1(0, wE, {
          ...r,
          onUpdate: (i) => {
            this.mixTargetDelta(i), r.onUpdate && r.onUpdate(i);
          },
          onComplete: () => {
            r.onComplete && r.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const r = this.getStack();
      r && r.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(wE), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const r = this.getLead();
      let { targetWithTransforms: i, target: c, layout: V, latestValues: s } = r;
      if (!(!i || !c || !V)) {
        if (this !== r && this.layout && V && PJ(this.options.animationType, this.layout.layoutBox, V.layoutBox)) {
          c = this.target || Rl();
          const o = Ha(this.layout.layoutBox.x);
          c.x.min = r.target.x.min, c.x.max = c.x.min + o;
          const U = Ha(this.layout.layoutBox.y);
          c.y.min = r.target.y.min, c.y.max = c.y.min + U;
        }
        ga(i, c), nc(i, s), Vo(this.projectionDeltaWithTransform, this.layoutCorrected, i, s);
      }
    }
    registerSharedNode(r, i) {
      this.sharedNodes.has(r) || this.sharedNodes.set(r, new H8()), this.sharedNodes.get(r).add(i);
      const V = i.options.initialPromotionConfig;
      i.promote({
        transition: V ? V.transition : void 0,
        preserveFollowOpacity: V && V.shouldPreserveFollowOpacity ? V.shouldPreserveFollowOpacity(i) : void 0
      });
    }
    isLead() {
      const r = this.getStack();
      return r ? r.lead === this : !0;
    }
    getLead() {
      var r;
      const { layoutId: i } = this.options;
      return i ? ((r = this.getStack()) === null || r === void 0 ? void 0 : r.lead) || this : this;
    }
    getPrevLead() {
      var r;
      const { layoutId: i } = this.options;
      return i ? (r = this.getStack()) === null || r === void 0 ? void 0 : r.prevLead : void 0;
    }
    getStack() {
      const { layoutId: r } = this.options;
      if (r)
        return this.root.sharedNodes.get(r);
    }
    promote({ needsReset: r, transition: i, preserveFollowOpacity: c } = {}) {
      const V = this.getStack();
      V && V.promote(this, c), r && (this.projectionDelta = void 0, this.needsReset = !0), i && this.setOptions({ transition: i });
    }
    relegate() {
      const r = this.getStack();
      return r ? r.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: r } = this.options;
      if (!r)
        return;
      let i = !1;
      const { latestValues: c } = r;
      if ((c.rotate || c.rotateX || c.rotateY || c.rotateZ) && (i = !0), !i)
        return;
      const V = {};
      for (let s = 0; s < fE.length; s++) {
        const o = "rotate" + fE[s];
        c[o] && (V[o] = c[o], r.setStaticValue(o, 0));
      }
      r.render();
      for (const s in V)
        r.setStaticValue(s, V[s]);
      r.scheduleRender();
    }
    getProjectionStyles(r) {
      var i, c;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return L8;
      const V = {
        visibility: ""
      }, s = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, V.opacity = "", V.pointerEvents = HN(r == null ? void 0 : r.pointerEvents) || "", V.transform = s ? s(this.latestValues, "") : "none", V;
      const o = this.getLead();
      if (!this.projectionDelta || !this.layout || !o.target) {
        const h = {};
        return this.options.layoutId && (h.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, h.pointerEvents = HN(r == null ? void 0 : r.pointerEvents) || ""), this.hasProjected && !Hi(this.latestValues) && (h.transform = s ? s({}, "") : "none", this.hasProjected = !1), h;
      }
      const U = o.animationValues || o.latestValues;
      this.applyTransformsToTarget(), V.transform = HE(this.projectionDeltaWithTransform, this.treeScale, U), s && (V.transform = s(U, V.transform));
      const { x: N, y: R } = this.projectionDelta;
      V.transformOrigin = `${N.origin * 100}% ${R.origin * 100}% 0`, o.animationValues ? V.opacity = o === this ? (c = (i = U.opacity) !== null && i !== void 0 ? i : this.latestValues.opacity) !== null && c !== void 0 ? c : 1 : this.preserveOpacity ? this.latestValues.opacity : U.opacityExit : V.opacity = o === this ? U.opacity !== void 0 ? U.opacity : "" : U.opacityExit !== void 0 ? U.opacityExit : 0;
      for (const h in JR) {
        if (U[h] === void 0)
          continue;
        const { correct: Z, applyTo: W } = JR[h], F = V.transform === "none" ? U[h] : Z(U[h], o);
        if (W) {
          const m = W.length;
          for (let E = 0; E < m; E++)
            V[W[E]] = F;
        } else
          V[h] = F;
      }
      return this.options.layoutId && (V.pointerEvents = o === this ? HN(r == null ? void 0 : r.pointerEvents) || "" : "none"), V;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((r) => {
        var i;
        return (i = r.currentAnimation) === null || i === void 0 ? void 0 : i.stop();
      }), this.root.nodes.forEach(gE), this.root.sharedNodes.clear();
    }
  };
}
function K8(e) {
  e.updateLayout();
}
function _8(e) {
  var n;
  const t = ((n = e.resumeFrom) === null || n === void 0 ? void 0 : n.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
    const { layoutBox: l, measuredBox: a } = e.layout, { animationType: d } = e.options, r = t.source !== e.layout.source;
    d === "size" ? La((o) => {
      const U = r ? t.measuredBox[o] : t.layoutBox[o], N = Ha(U);
      U.min = l[o].min, U.max = U.min + N;
    }) : PJ(d, t.layoutBox, l) && La((o) => {
      const U = r ? t.measuredBox[o] : t.layoutBox[o], N = Ha(l[o]);
      U.max = U.min + N, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[o].max = e.relativeTarget[o].min + N);
    });
    const i = tc();
    Vo(i, l, t.layoutBox);
    const c = tc();
    r ? Vo(c, e.applyTransform(a, !0), t.measuredBox) : Vo(c, l, t.layoutBox);
    const V = !LJ(i);
    let s = !1;
    if (!e.resumeFrom) {
      const o = e.getClosestProjectingParent();
      if (o && !o.resumeFrom) {
        const { snapshot: U, layout: N } = o;
        if (U && N) {
          const R = Rl();
          co(R, t.layoutBox, U.layoutBox);
          const h = Rl();
          co(h, l, N.layoutBox), CJ(R, h) || (s = !0), o.options.layoutRoot && (e.relativeTarget = h, e.relativeTargetOrigin = R, e.relativeParent = o);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: l,
      snapshot: t,
      delta: c,
      layoutDelta: i,
      hasLayoutChanged: V,
      hasRelativeTargetChanged: s
    });
  } else if (e.isLead()) {
    const { onExitComplete: l } = e.options;
    l && l();
  }
  e.options.transition = void 0;
}
function P8(e) {
  fi.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function A8(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function q8(e) {
  e.clearSnapshot();
}
function gE(e) {
  e.clearMeasurements();
}
function $8(e) {
  e.isLayoutDirty = !1;
}
function eq(e) {
  const { visualElement: n } = e.options;
  n && n.getProps().onBeforeLayoutMeasure && n.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function IE(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function tq(e) {
  e.resolveTargetDelta();
}
function nq(e) {
  e.calcProjection();
}
function lq(e) {
  e.resetRotation();
}
function aq(e) {
  e.removeLeadSnapshot();
}
function LE(e, n, t) {
  e.translate = Cn(n.translate, 0, t), e.scale = Cn(n.scale, 1, t), e.origin = n.origin, e.originPoint = n.originPoint;
}
function CE(e, n, t, l) {
  e.min = Cn(n.min, t.min, l), e.max = Cn(n.max, t.max, l);
}
function dq(e, n, t, l) {
  CE(e.x, n.x, t.x, l), CE(e.y, n.y, t.y, l);
}
function rq(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const iq = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, KE = (e) => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(e), _E = KE("applewebkit/") && !KE("chrome/") ? Math.round : ll;
function PE(e) {
  e.min = _E(e.min), e.max = _E(e.max);
}
function Vq(e) {
  PE(e.x), PE(e.y);
}
function PJ(e, n, t) {
  return e === "position" || e === "preserve-aspect" && !lW(jE(n), jE(t), 0.2);
}
const cq = _J({
  attachResizeListener: (e, n) => ur(e, "resize", n),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), cT = {
  current: void 0
}, AJ = _J({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!cT.current) {
      const e = new cq({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), cT.current = e;
    }
    return cT.current;
  },
  resetTransform: (e, n) => {
    e.style.transform = n !== void 0 ? n : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), sq = {
  pan: {
    Feature: Y8
  },
  drag: {
    Feature: b8,
    ProjectionNode: AJ,
    MeasureLayout: wJ
  }
}, oq = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function Uq(e) {
  const n = oq.exec(e);
  if (!n)
    return [,];
  const [, t, l] = n;
  return [t, l];
}
const Nq = 4;
function iW(e, n, t = 1) {
  ma(t <= Nq, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
  const [l, a] = Uq(e);
  if (!l)
    return;
  const d = window.getComputedStyle(n).getPropertyValue(l);
  if (d) {
    const r = d.trim();
    return xJ(r) ? parseFloat(r) : r;
  } else
    return KF(a) ? iW(a, n, t + 1) : a;
}
function Rq(e, { ...n }, t) {
  const l = e.current;
  if (!(l instanceof Element))
    return { target: n, transitionEnd: t };
  t && (t = { ...t }), e.values.forEach((a) => {
    const d = a.get();
    if (!KF(d))
      return;
    const r = iW(d, l);
    r && a.set(r);
  });
  for (const a in n) {
    const d = n[a];
    if (!KF(d))
      continue;
    const r = iW(d, l);
    r && (n[a] = r, t || (t = {}), t[a] === void 0 && (t[a] = d));
  }
  return { target: n, transitionEnd: t };
}
const hq = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), qJ = (e) => hq.has(e), Zq = (e) => Object.keys(e).some(qJ), ZN = (e) => e === HV || e === wt, AE = (e, n) => parseFloat(e.split(", ")[n]), qE = (e, n) => (t, { transform: l }) => {
  if (l === "none" || !l)
    return 0;
  const a = l.match(/^matrix3d\((.+)\)$/);
  if (a)
    return AE(a[1], n);
  {
    const d = l.match(/^matrix\((.+)\)$/);
    return d ? AE(d[1], e) : 0;
  }
}, Tq = /* @__PURE__ */ new Set(["x", "y", "z"]), Fq = ZU.filter((e) => !Tq.has(e));
function Wq(e) {
  const n = [];
  return Fq.forEach((t) => {
    const l = e.getValue(t);
    l !== void 0 && (n.push([t, l.get()]), l.set(t.startsWith("scale") ? 1 : 0));
  }), n.length && e.render(), n;
}
const Bc = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: n = "0", paddingRight: t = "0" }) => e.max - e.min - parseFloat(n) - parseFloat(t),
  height: ({ y: e }, { paddingTop: n = "0", paddingBottom: t = "0" }) => e.max - e.min - parseFloat(n) - parseFloat(t),
  top: (e, { top: n }) => parseFloat(n),
  left: (e, { left: n }) => parseFloat(n),
  bottom: ({ y: e }, { top: n }) => parseFloat(n) + (e.max - e.min),
  right: ({ x: e }, { left: n }) => parseFloat(n) + (e.max - e.min),
  // Transform
  x: qE(4, 13),
  y: qE(5, 14)
};
Bc.translateX = Bc.x;
Bc.translateY = Bc.y;
const mq = (e, n, t) => {
  const l = n.measureViewportBox(), a = n.current, d = getComputedStyle(a), { display: r } = d, i = {};
  r === "none" && n.setStaticValue("display", e.display || "block"), t.forEach((V) => {
    i[V] = Bc[V](l, d);
  }), n.render();
  const c = n.measureViewportBox();
  return t.forEach((V) => {
    const s = n.getValue(V);
    s && s.jump(i[V]), e[V] = Bc[V](c, d);
  }), e;
}, uq = (e, n, t = {}, l = {}) => {
  n = { ...n }, l = { ...l };
  const a = Object.keys(n).filter(qJ);
  let d = [], r = !1;
  const i = [];
  if (a.forEach((c) => {
    const V = e.getValue(c);
    if (!e.hasValue(c))
      return;
    let s = t[c], o = Ts(s);
    const U = n[c];
    let N;
    if (zR(U)) {
      const R = U.length, h = U[0] === null ? 1 : 0;
      s = U[h], o = Ts(s);
      for (let Z = h; Z < R && U[Z] !== null; Z++)
        N ? ma(Ts(U[Z]) === N, "All keyframes must be of the same type") : (N = Ts(U[Z]), ma(N === o || ZN(o) && ZN(N), "Keyframes must be of the same dimension as the current value"));
    } else
      N = Ts(U);
    if (o !== N)
      if (ZN(o) && ZN(N)) {
        const R = V.get();
        typeof R == "string" && V.set(parseFloat(R)), typeof U == "string" ? n[c] = parseFloat(U) : Array.isArray(U) && N === wt && (n[c] = U.map(parseFloat));
      } else
        o != null && o.transform && (N != null && N.transform) && (s === 0 || U === 0) ? s === 0 ? V.set(N.transform(s)) : n[c] = o.transform(U) : (r || (d = Wq(e), r = !0), i.push(c), l[c] = l[c] !== void 0 ? l[c] : n[c], V.jump(U));
  }), i.length) {
    const c = i.indexOf("height") >= 0 ? window.pageYOffset : null, V = mq(n, e, i);
    return d.length && d.forEach(([s, o]) => {
      e.getValue(s).set(o);
    }), e.render(), Mh && c !== null && window.scrollTo({ top: c }), { target: V, transitionEnd: l };
  } else
    return { target: n, transitionEnd: l };
};
function pq(e, n, t, l) {
  return Zq(n) ? uq(e, n, t, l) : { target: n, transitionEnd: l };
}
const Mq = (e, n, t, l) => {
  const a = Rq(e, n, l);
  return n = a.target, l = a.transitionEnd, pq(e, n, t, l);
}, XR = { current: null }, H1 = { current: !1 };
function $J() {
  if (H1.current = !0, !!Mh)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), n = () => XR.current = e.matches;
      e.addListener(n), n();
    } else
      XR.current = !1;
}
function Eq(e, n, t) {
  const { willChange: l } = n;
  for (const a in n) {
    const d = n[a], r = t[a];
    if (Kl(d))
      e.addValue(a, d), BR(l) && l.add(a), process.env.NODE_ENV === "development" && zh(d.version === "10.18.0", `Attempting to mix Framer Motion versions ${d.version} with 10.18.0 may not work as expected.`);
    else if (Kl(r))
      e.addValue(a, QV(d, { owner: e })), BR(l) && l.remove(a);
    else if (r !== d)
      if (e.hasValue(a)) {
        const i = e.getValue(a);
        !i.hasAnimated && i.set(d);
      } else {
        const i = e.getStaticValue(a);
        e.addValue(a, QV(i !== void 0 ? i : d, { owner: e }));
      }
  }
  for (const a in t)
    n[a] === void 0 && e.removeValue(a);
  return n;
}
const Xo = /* @__PURE__ */ new WeakMap(), ev = Object.keys(Do), Sq = ev.length, $E = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], kq = m1.length;
class bq {
  constructor({ parent: n, props: t, presenceContext: l, reducedMotionConfig: a, visualState: d }, r = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => Bn.render(this.render, !1, !0);
    const { latestValues: i, renderState: c } = d;
    this.latestValues = i, this.baseTarget = { ...i }, this.initialValues = t.initial ? { ...i } : {}, this.renderState = c, this.parent = n, this.props = t, this.presenceContext = l, this.depth = n ? n.depth + 1 : 0, this.reducedMotionConfig = a, this.options = r, this.isControllingVariants = kh(t), this.isVariantNode = DQ(t), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(n && n.current);
    const { willChange: V, ...s } = this.scrapeMotionValuesFromProps(t, {});
    for (const o in s) {
      const U = s[o];
      i[o] !== void 0 && Kl(U) && (U.set(i[o], !1), BR(V) && V.add(o));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(n, t) {
    return {};
  }
  mount(n) {
    this.current = n, Xo.set(n, this), this.projection && !this.projection.instance && this.projection.mount(n), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, l) => this.bindToMotionValue(l, t)), H1.current || $J(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : XR.current, process.env.NODE_ENV !== "production" && zh(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    Xo.delete(this.current), this.projection && this.projection.unmount(), Sd(this.notifyUpdate), Sd(this.render), this.valueSubscriptions.forEach((n) => n()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const n in this.events)
      this.events[n].clear();
    for (const n in this.features)
      this.features[n].unmount();
    this.current = null;
  }
  bindToMotionValue(n, t) {
    const l = jV.has(n), a = t.on("change", (r) => {
      this.latestValues[n] = r, this.props.onUpdate && Bn.update(this.notifyUpdate, !1, !0), l && this.projection && (this.projection.isTransformDirty = !0);
    }), d = t.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(n, () => {
      a(), d();
    });
  }
  sortNodePosition(n) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== n.type ? 0 : this.sortInstanceNodePosition(this.current, n.current);
  }
  loadFeatures({ children: n, ...t }, l, a, d) {
    let r, i;
    if (process.env.NODE_ENV !== "production" && a && l) {
      const c = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      t.ignoreStrict ? WU(!1, c) : ma(!1, c);
    }
    for (let c = 0; c < Sq; c++) {
      const V = ev[c], { isEnabled: s, Feature: o, ProjectionNode: U, MeasureLayout: N } = Do[V];
      U && (r = U), s(t) && (!this.features[V] && o && (this.features[V] = new o(this)), N && (i = N));
    }
    if ((this.type === "html" || this.type === "svg") && !this.projection && r) {
      this.projection = new r(this.latestValues, this.parent && this.parent.projection);
      const { layoutId: c, layout: V, drag: s, dragConstraints: o, layoutScroll: U, layoutRoot: N } = t;
      this.projection.setOptions({
        layoutId: c,
        layout: V,
        alwaysMeasureLayout: !!s || o && $V(o),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof V == "string" ? V : "both",
        initialPromotionConfig: d,
        layoutScroll: U,
        layoutRoot: N
      });
    }
    return i;
  }
  updateFeatures() {
    for (const n in this.features) {
      const t = this.features[n];
      t.isMounted ? t.update() : (t.mount(), t.isMounted = !0);
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Rl();
  }
  getStaticValue(n) {
    return this.latestValues[n];
  }
  setStaticValue(n, t) {
    this.latestValues[n] = t;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(n, t = !0) {
    return this.makeTargetAnimatableFromInstance(n, this.props, t);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(n, t) {
    (n.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = n, this.prevPresenceContext = this.presenceContext, this.presenceContext = t;
    for (let l = 0; l < $E.length; l++) {
      const a = $E[l];
      this.propEventSubscriptions[a] && (this.propEventSubscriptions[a](), delete this.propEventSubscriptions[a]);
      const d = n["on" + a];
      d && (this.propEventSubscriptions[a] = this.on(a, d));
    }
    this.prevMotionValues = Eq(this, this.scrapeMotionValuesFromProps(n, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(n) {
    return this.props.variants ? this.props.variants[n] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(n = !1) {
    if (n)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const l = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (l.initial = this.props.initial), l;
    }
    const t = {};
    for (let l = 0; l < kq; l++) {
      const a = m1[l], d = this.props[a];
      (Bo(d) || d === !1) && (t[a] = d);
    }
    return t;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(n) {
    const t = this.getClosestVariantNode();
    if (t)
      return t.variantChildren && t.variantChildren.add(n), () => t.variantChildren.delete(n);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(n, t) {
    t !== this.values.get(n) && (this.removeValue(n), this.bindToMotionValue(n, t)), this.values.set(n, t), this.latestValues[n] = t.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(n) {
    this.values.delete(n);
    const t = this.valueSubscriptions.get(n);
    t && (t(), this.valueSubscriptions.delete(n)), delete this.latestValues[n], this.removeValueFromRenderState(n, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(n) {
    return this.values.has(n);
  }
  getValue(n, t) {
    if (this.props.values && this.props.values[n])
      return this.props.values[n];
    let l = this.values.get(n);
    return l === void 0 && t !== void 0 && (l = QV(t, { owner: this }), this.addValue(n, l)), l;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(n) {
    var t;
    return this.latestValues[n] !== void 0 || !this.current ? this.latestValues[n] : (t = this.getBaseTargetFromProps(this.props, n)) !== null && t !== void 0 ? t : this.readValueFromInstance(this.current, n, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(n, t) {
    this.baseTarget[n] = t;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(n) {
    var t;
    const { initial: l } = this.props, a = typeof l == "string" || typeof l == "object" ? (t = Y1(this.props, l)) === null || t === void 0 ? void 0 : t[n] : void 0;
    if (l && a !== void 0)
      return a;
    const d = this.getBaseTargetFromProps(this.props, n);
    return d !== void 0 && !Kl(d) ? d : this.initialValues[n] !== void 0 && a === void 0 ? void 0 : this.baseTarget[n];
  }
  on(n, t) {
    return this.events[n] || (this.events[n] = new X1()), this.events[n].add(t);
  }
  notify(n, ...t) {
    this.events[n] && this.events[n].notify(...t);
  }
}
class tv extends bq {
  sortInstanceNodePosition(n, t) {
    return n.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(n, t) {
    return n.style ? n.style[t] : void 0;
  }
  removeValueFromRenderState(n, { vars: t, style: l }) {
    delete t[n], delete l[n];
  }
  makeTargetAnimatableFromInstance({ transition: n, transitionEnd: t, ...l }, { transformValues: a }, d) {
    let r = LA(l, n || {}, this);
    if (a && (t && (t = a(t)), l && (l = a(l)), r && (r = a(r))), d) {
      gA(this, l, r);
      const i = Mq(this, l, r, t);
      t = i.transitionEnd, l = i.target;
    }
    return {
      transition: n,
      transitionEnd: t,
      ...l
    };
  }
}
function Yq(e) {
  return window.getComputedStyle(e);
}
class nv extends tv {
  constructor() {
    super(...arguments), this.type = "html";
  }
  readValueFromInstance(n, t) {
    if (jV.has(t)) {
      const l = G1(t);
      return l && l.default || 0;
    } else {
      const l = Yq(n), a = (HQ(t) ? l.getPropertyValue(t) : l[t]) || 0;
      return typeof a == "string" ? a.trim() : a;
    }
  }
  measureInstanceViewportBox(n, { transformPagePoint: t }) {
    return HJ(n, t);
  }
  build(n, t, l, a) {
    M1(n, t, l, a.transformTemplate);
  }
  scrapeMotionValuesFromProps(n, t) {
    return b1(n, t);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: n } = this.props;
    Kl(n) && (this.childSubscription = n.on("change", (t) => {
      this.current && (this.current.textContent = `${t}`);
    }));
  }
  renderInstance(n, t, l, a) {
    CQ(n, t, l, a);
  }
}
class lv extends tv {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1;
  }
  getBaseTargetFromProps(n, t) {
    return n[t];
  }
  readValueFromInstance(n, t) {
    if (jV.has(t)) {
      const l = G1(t);
      return l && l.default || 0;
    }
    return t = KQ.has(t) ? t : F1(t), n.getAttribute(t);
  }
  measureInstanceViewportBox() {
    return Rl();
  }
  scrapeMotionValuesFromProps(n, t) {
    return PQ(n, t);
  }
  build(n, t, l, a) {
    S1(n, t, l, this.isSVGTag, a.transformTemplate);
  }
  renderInstance(n, t, l, a) {
    _Q(n, t, l, a);
  }
  mount(n) {
    this.isSVGTag = k1(n.tagName), super.mount(n);
  }
}
const Qq = (e, n) => p1(e) ? new lv(n, { enableHardwareAcceleration: !1 }) : new nv(n, { enableHardwareAcceleration: !0 }), Jq = {
  layout: {
    ProjectionNode: AJ,
    MeasureLayout: wJ
  }
}, vq = {
  ...i8,
  ...xP,
  ...sq,
  ...Jq
}, Cl = /* @__PURE__ */ f_((e, n) => mP(e, n, vq, Qq));
function av() {
  const e = Wt(!1);
  return Eh(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
}
function zq() {
  const e = av(), [n, t] = me(0), l = Pt(() => {
    e.current && t(n + 1);
  }, [n]);
  return [Pt(() => Bn.postRender(l), [l]), n];
}
class xq extends z.Component {
  getSnapshotBeforeUpdate(n) {
    const t = this.props.childRef.current;
    if (t && n.isPresent && !this.props.isPresent) {
      const l = this.props.sizeRef.current;
      l.height = t.offsetHeight || 0, l.width = t.offsetWidth || 0, l.top = t.offsetTop, l.left = t.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Gq({ children: e, isPresent: n }) {
  const t = oW(), l = Wt(null), a = Wt({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return qS(() => {
    const { width: d, height: r, top: i, left: c } = a.current;
    if (n || !l.current || !d || !r)
      return;
    l.current.dataset.motionPopId = t;
    const V = document.createElement("style");
    return document.head.appendChild(V), V.sheet && V.sheet.insertRule(`
          [data-motion-pop-id="${t}"] {
            position: absolute !important;
            width: ${d}px !important;
            height: ${r}px !important;
            top: ${i}px !important;
            left: ${c}px !important;
          }
        `), () => {
      document.head.removeChild(V);
    };
  }, [n]), z.createElement(xq, { isPresent: n, childRef: l, sizeRef: a }, z.cloneElement(e, { ref: l }));
}
const sT = ({ children: e, initial: n, isPresent: t, onExitComplete: l, custom: a, presenceAffectsLayout: d, mode: r }) => {
  const i = Yh(yq), c = oW(), V = nn(
    () => ({
      id: c,
      initial: n,
      isPresent: t,
      custom: a,
      onExitComplete: (s) => {
        i.set(s, !0);
        for (const o of i.values())
          if (!o)
            return;
        l && l();
      },
      register: (s) => (i.set(s, !1), () => i.delete(s))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    d ? void 0 : [t]
  );
  return nn(() => {
    i.forEach((s, o) => i.set(o, !1));
  }, [t]), z.useEffect(() => {
    !t && !i.size && l && l();
  }, [t]), r === "popLayout" && (e = z.createElement(Gq, { isPresent: t }, e)), z.createElement(ph.Provider, { value: V }, e);
};
function yq() {
  return /* @__PURE__ */ new Map();
}
function Bq(e) {
  return _e(() => () => e(), []);
}
const wi = (e) => e.key || "";
function Dq(e, n) {
  e.forEach((t) => {
    const l = wi(t);
    n.set(l, t);
  });
}
function Xq(e) {
  const n = [];
  return ek.forEach(e, (t) => {
    Pv(t) && n.push(t);
  }), n;
}
const dv = ({ children: e, custom: n, initial: t = !0, onExitComplete: l, exitBeforeEnter: a, presenceAffectsLayout: d = !0, mode: r = "sync" }) => {
  ma(!a, "Replace exitBeforeEnter with mode='wait'");
  const i = Gt(u1).forceRender || zq()[0], c = av(), V = Xq(e);
  let s = V;
  const o = Wt(/* @__PURE__ */ new Map()).current, U = Wt(s), N = Wt(/* @__PURE__ */ new Map()).current, R = Wt(!0);
  if (Eh(() => {
    R.current = !1, Dq(V, N), U.current = s;
  }), Bq(() => {
    R.current = !0, N.clear(), o.clear();
  }), R.current)
    return z.createElement(z.Fragment, null, s.map((F) => z.createElement(sT, { key: wi(F), isPresent: !0, initial: t ? void 0 : !1, presenceAffectsLayout: d, mode: r }, F)));
  s = [...s];
  const h = U.current.map(wi), Z = V.map(wi), W = h.length;
  for (let F = 0; F < W; F++) {
    const m = h[F];
    Z.indexOf(m) === -1 && !o.has(m) && o.set(m, void 0);
  }
  return r === "wait" && o.size && (s = []), o.forEach((F, m) => {
    if (Z.indexOf(m) !== -1)
      return;
    const E = N.get(m);
    if (!E)
      return;
    const u = h.indexOf(m);
    let b = F;
    if (!b) {
      const k = () => {
        o.delete(m);
        const Q = Array.from(N.keys()).filter((S) => !Z.includes(S));
        if (Q.forEach((S) => N.delete(S)), U.current = V.filter((S) => {
          const v = wi(S);
          return (
            // filter out the node exiting
            v === m || // filter out the leftover children
            Q.includes(v)
          );
        }), !o.size) {
          if (c.current === !1)
            return;
          i(), l && l();
        }
      };
      b = z.createElement(sT, { key: wi(E), isPresent: !1, onExitComplete: k, custom: n, presenceAffectsLayout: d, mode: r }, E), o.set(m, b);
    }
    s.splice(u, 0, b);
  }), s = s.map((F) => {
    const m = F.key;
    return o.has(m) ? F : z.createElement(sT, { key: wi(F), isPresent: !0, presenceAffectsLayout: d, mode: r }, F);
  }), process.env.NODE_ENV !== "production" && r === "wait" && s.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), z.createElement(z.Fragment, null, o.size ? s : s.map((F) => $S(F)));
};
function Oo(e) {
  const n = Yh(() => QV(e)), { isStatic: t } = Gt(T1);
  if (t) {
    const [, l] = me(e);
    _e(() => n.on("change", l), []);
  }
  return n;
}
const Oq = (e) => e && typeof e == "object" && e.mix, jq = (e) => Oq(e) ? e.mix : void 0;
function Hq(...e) {
  const n = !Array.isArray(e[0]), t = n ? 0 : -1, l = e[0 + t], a = e[1 + t], d = e[2 + t], r = e[3 + t], i = z1(a, d, {
    mixer: jq(d[0]),
    ...r
  });
  return n ? i(l) : i;
}
function rv(e, n) {
  const t = Oo(n()), l = () => t.set(n());
  return l(), Eh(() => {
    const a = () => Bn.update(l, !1, !0), d = e.map((r) => r.on("change", a));
    return () => {
      d.forEach((r) => r()), Sd(l);
    };
  }), t;
}
function fq(e) {
  io.current = [], e();
  const n = rv(io.current, e);
  return io.current = void 0, n;
}
function bi(e, n, t, l) {
  if (typeof e == "function")
    return fq(e);
  const a = typeof n == "function" ? n : Hq(n, t, l);
  return Array.isArray(e) ? eS(e, a) : eS([e], ([d]) => a(d));
}
function eS(e, n) {
  const t = Yh(() => []);
  return rv(e, () => {
    t.length = 0;
    const l = e.length;
    for (let a = 0; a < l; a++)
      t[a] = e[a].get();
    return n(t);
  });
}
function iv(e, n, t) {
  var l;
  if (typeof e == "string") {
    let a = document;
    n && (ma(!!n.current, "Scope provided, but no element detected."), a = n.current), t ? ((l = t[e]) !== null && l !== void 0 || (t[e] = a.querySelectorAll(e)), e = t[e]) : e = a.querySelectorAll(e);
  } else
    e instanceof Element && (e = [e]);
  return Array.from(e || []);
}
function Vv() {
  !H1.current && $J();
  const [e] = me(XR.current);
  return process.env.NODE_ENV !== "production" && zh(e !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), e;
}
function wq(e, n) {
  let t;
  const l = () => {
    const { currentTime: a } = n, r = (a === null ? 0 : a.value) / 100;
    t !== r && e(r), t = r;
  };
  return Bn.update(l, !0), () => Sd(l);
}
const gq = JJ(() => window.ScrollTimeline !== void 0);
class cv {
  constructor(n) {
    this.animations = n.filter(Boolean);
  }
  then(n, t) {
    return Promise.all(this.animations).then(n).catch(t);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(n) {
    return this.animations[0][n];
  }
  setAll(n, t) {
    for (let l = 0; l < this.animations.length; l++)
      this.animations[l][n] = t;
  }
  attachTimeline(n) {
    const t = this.animations.map((l) => {
      if (gq() && l.attachTimeline)
        l.attachTimeline(n);
      else
        return l.pause(), wq((a) => {
          l.time = l.duration * a;
        }, n);
    });
    return () => {
      t.forEach((l, a) => {
        l && l(), this.animations[a].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(n) {
    this.setAll("time", n);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(n) {
    this.setAll("speed", n);
  }
  get duration() {
    let n = 0;
    for (let t = 0; t < this.animations.length; t++)
      n = Math.max(n, this.animations[t].duration);
    return n;
  }
  runAll(n) {
    this.animations.forEach((t) => t[n]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  stop() {
    this.runAll("stop");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function Iq(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function Lq(e) {
  const n = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, t = KJ(e) ? new lv(n, {
    enableHardwareAcceleration: !1
  }) : new nv(n, {
    enableHardwareAcceleration: !0
  });
  t.mount(e), Xo.set(e, t);
}
function Cq(e, n = 100) {
  const t = x1({ keyframes: [0, n], ...e }), l = Math.min($F(t), qF);
  return {
    type: "keyframes",
    ease: (a) => t.next(l * a).value / n,
    duration: Ad(l)
  };
}
function tS(e, n, t, l) {
  var a;
  return typeof n == "number" ? n : n.startsWith("-") || n.startsWith("+") ? Math.max(0, e + parseFloat(n)) : n === "<" ? t : (a = l.get(n)) !== null && a !== void 0 ? a : e;
}
const Kq = (e, n, t) => {
  const l = n - e;
  return ((t - e) % l + l) % l + e;
};
function _q(e, n) {
  return sJ(e) ? e[Kq(0, e.length, n)] : e;
}
function Pq(e, n, t) {
  for (let l = 0; l < e.length; l++) {
    const a = e[l];
    a.at > n && a.at < t && (vh(e, a), l--);
  }
}
function Aq(e, n, t, l, a, d) {
  Pq(e, a, d);
  for (let r = 0; r < n.length; r++)
    e.push({
      value: n[r],
      at: Cn(a, d, l[r]),
      easing: _q(t, r)
    });
}
function qq(e, n) {
  return e.at === n.at ? e.value === null ? 1 : n.value === null ? -1 : 0 : e.at - n.at;
}
const $q = "easeInOut";
function e7(e, { defaultTransition: n = {}, ...t } = {}, l) {
  const a = n.duration || 0.3, d = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = {}, c = /* @__PURE__ */ new Map();
  let V = 0, s = 0, o = 0;
  for (let U = 0; U < e.length; U++) {
    const N = e[U];
    if (typeof N == "string") {
      c.set(N, s);
      continue;
    } else if (!Array.isArray(N)) {
      c.set(N.name, tS(s, N.at, V, c));
      continue;
    }
    let [R, h, Z = {}] = N;
    Z.at !== void 0 && (s = tS(s, Z.at, V, c));
    let W = 0;
    const F = (m, E, u, b = 0, k = 0) => {
      const Q = t7(m), { delay: S = 0, times: v = bJ(Q), type: G = "keyframes", ...w } = E;
      let { ease: y = n.ease || "easeOut", duration: g } = E;
      const f = typeof S == "function" ? S(b, k) : S, I = Q.length;
      if (I <= 2 && G === "spring") {
        let ae = 100;
        if (I === 2 && a7(Q)) {
          const L = Q[1] - Q[0];
          ae = Math.abs(L);
        }
        const se = { ...w };
        g !== void 0 && (se.duration = Jr(g));
        const le = Cq(se, ae);
        y = le.ease, g = le.duration;
      }
      g ?? (g = a);
      const K = s + f, Ue = K + g;
      v.length === 1 && v[0] === 0 && (v[1] = 1);
      const q = v.length - Q.length;
      q > 0 && kJ(v, q), Q.length === 1 && Q.unshift(null), Aq(u, Q, y, v, K, Ue), W = Math.max(f + g, W), o = Math.max(Ue, o);
    };
    if (Kl(R)) {
      const m = nS(R, r);
      F(h, Z, lS("default", m));
    } else {
      const m = iv(R, l, i), E = m.length;
      for (let u = 0; u < E; u++) {
        h = h, Z = Z;
        const b = m[u], k = nS(b, r);
        for (const Q in h)
          F(h[Q], n7(Z, Q), lS(Q, k), u, E);
      }
    }
    V = s, s += W;
  }
  return r.forEach((U, N) => {
    for (const R in U) {
      const h = U[R];
      h.sort(qq);
      const Z = [], W = [], F = [];
      for (let E = 0; E < h.length; E++) {
        const { at: u, value: b, easing: k } = h[E];
        Z.push(b), W.push(yc(0, o, u)), F.push(k || "easeOut");
      }
      W[0] !== 0 && (W.unshift(0), Z.unshift(Z[0]), F.unshift($q)), W[W.length - 1] !== 1 && (W.push(1), Z.push(null)), d.has(N) || d.set(N, {
        keyframes: {},
        transition: {}
      });
      const m = d.get(N);
      m.keyframes[R] = Z, m.transition[R] = {
        ...n,
        duration: o,
        ease: F,
        times: W,
        ...t
      };
    }
  }), d;
}
function nS(e, n) {
  return !n.has(e) && n.set(e, {}), n.get(e);
}
function lS(e, n) {
  return n[e] || (n[e] = []), n[e];
}
function t7(e) {
  return Array.isArray(e) ? e : [e];
}
function n7(e, n) {
  return e[n] ? { ...e, ...e[n] } : { ...e };
}
const l7 = (e) => typeof e == "number", a7 = (e) => e.every(l7);
function sv(e, n, t, l) {
  const a = iv(e, l), d = a.length;
  ma(!!d, "No valid element provided.");
  const r = [];
  for (let i = 0; i < d; i++) {
    const c = a[i];
    Xo.has(c) || Lq(c);
    const V = Xo.get(c), s = { ...t };
    typeof s.delay == "function" && (s.delay = s.delay(i, d)), r.push(...O1(V, { ...n, transition: s }, {}));
  }
  return new cv(r);
}
const d7 = (e) => Array.isArray(e) && Array.isArray(e[0]);
function r7(e, n, t) {
  const l = [];
  return e7(e, n, t).forEach(({ keyframes: d, transition: r }, i) => {
    let c;
    Kl(i) ? c = j1(i, d.default, r.default) : c = sv(i, d, r), l.push(c);
  }), new cv(l);
}
const i7 = (e) => {
  function n(t, l, a) {
    let d;
    return d7(t) ? d = r7(t, l, e) : Iq(l) ? d = sv(t, l, a, e) : d = j1(t, l, a), e && e.animations.push(d), d;
  }
  return n;
}, OR = i7(), ov = typeof window < "u" ? T.useLayoutEffect : () => {
};
function Dc(...e) {
  return (...n) => {
    for (let t of e)
      typeof t == "function" && t(...n);
  };
}
let Ws = /* @__PURE__ */ new Map(), aS = /* @__PURE__ */ new Set();
function dS() {
  if (typeof window > "u")
    return;
  let e = (t) => {
    let l = Ws.get(t.target);
    l || (l = /* @__PURE__ */ new Set(), Ws.set(t.target, l), t.target.addEventListener("transitioncancel", n)), l.add(t.propertyName);
  }, n = (t) => {
    let l = Ws.get(t.target);
    if (l && (l.delete(t.propertyName), l.size === 0 && (t.target.removeEventListener("transitioncancel", n), Ws.delete(t.target)), Ws.size === 0)) {
      for (let a of aS)
        a();
      aS.clear();
    }
  };
  document.body.addEventListener("transitionrun", e), document.body.addEventListener("transitionend", n);
}
typeof document < "u" && (document.readyState !== "loading" ? dS() : document.addEventListener("DOMContentLoaded", dS));
function xh(e) {
  for (rS(e) && (e = e.parentElement); e && !rS(e); )
    e = e.parentElement;
  return e || document.scrollingElement || document.documentElement;
}
function rS(e) {
  let n = window.getComputedStyle(e);
  return /(auto|scroll)/.test(n.overflow + n.overflowX + n.overflowY);
}
function f1(e) {
  var n;
  return typeof window < "u" && window.navigator != null ? e.test(((n = window.navigator.userAgentData) === null || n === void 0 ? void 0 : n.platform) || window.navigator.platform) : !1;
}
function V7() {
  return f1(/^Mac/i);
}
function c7() {
  return f1(/^iPhone/i);
}
function s7() {
  return f1(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  V7() && navigator.maxTouchPoints > 1;
}
function Uv() {
  return c7() || s7();
}
function md() {
  return md = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, md.apply(this, arguments);
}
function Kc(e, n) {
  if (e == null)
    return {};
  var t = {}, l = Object.keys(e), a, d;
  for (d = 0; d < l.length; d++)
    a = l[d], !(n.indexOf(a) >= 0) && (t[a] = e[a]);
  return t;
}
var iS = "calc(100% - env(safe-area-inset-top) - 34px)", Nv = typeof window > "u", o7 = {
  ease: "easeOut",
  duration: 0.2
}, U7 = {
  ease: "linear",
  duration: 0.01
}, N7 = 0.6, R7 = 500;
function VS(e, n) {
  for (var t = e[0], l = Math.abs(e[0] - n), a = 1; a < e.length; a++) {
    var d = Math.abs(e[a] - n);
    d < l && (t = e[a], l = d);
  }
  return t;
}
function h7(e) {
  var n = document.querySelector("body"), t = document.querySelector("#" + e);
  if (t) {
    var l = 24, a = window.innerHeight, d = (a - l) / a;
    n.style.backgroundColor = "#000", t.style.overflow = "hidden", t.style.willChange = "transform", t.style.transition = "transform 200ms ease-in-out, border-radius 200ms linear", t.style.transform = "translateY(calc(env(safe-area-inset-top) + " + l / 2 + "px)) scale(" + d + ")", t.style.borderTopRightRadius = "10px", t.style.borderTopLeftRadius = "10px";
  }
}
function cS(e) {
  var n = document.querySelector("body"), t = document.getElementById(e);
  function l() {
    t.style.removeProperty("overflow"), t.style.removeProperty("will-change"), t.style.removeProperty("transition"), n.style.removeProperty("background-color"), t.removeEventListener("transitionend", l);
  }
  t && (t.style.removeProperty("border-top-right-radius"), t.style.removeProperty("border-top-left-radius"), t.style.removeProperty("transform"), t.addEventListener("transitionend", l));
}
function Z7(e) {
  for (var n = 0; n < e.length; n++)
    if (e[n + 1] > e[n])
      return !1;
  return !0;
}
function sS(e) {
  var n = e.snapTo, t = e.sheetHeight;
  return n < 0 && console.warn("Snap point is out of bounds. Sheet height is " + t + " but snap point is " + (t + Math.abs(n)) + "."), Math.max(Math.round(n), 0);
}
function w1(e) {
  return function(n) {
    e.forEach(function(t) {
      typeof t == "function" ? t(n) : t && (t.current = n);
    });
  };
}
function T7() {
  return typeof window > "u" ? !1 : "ontouchstart" in window || navigator.maxTouchPoints > 0;
}
var g1 = Nv ? _e : ud;
function F7(e, n) {
  var t = Rv(e);
  _e(function() {
    n && !t && e ? h7(n) : n && !e && t && cS(n);
  }, [e, t]), _e(function() {
    return function() {
      n && e && cS(n);
    };
  }, [e]);
}
function W7(e, n) {
  var t = Rv(e), l = Wt(!1), a = Pt(function() {
    l.current ? (n.current.onCloseEnd == null || n.current.onCloseEnd(), l.current = !1) : (n.current.onOpenEnd == null || n.current.onOpenEnd(), l.current = !0);
  }, [e, t]);
  return _e(function() {
    !t && e ? n.current.onOpenStart == null || n.current.onOpenStart() : !e && t && (n.current.onCloseStart == null || n.current.onCloseStart());
  }, [e, t]), {
    handleAnimationComplete: a
  };
}
function m7() {
  var e = me(0), n = e[0], t = e[1];
  return g1(function() {
    var l = function() {
      return t(window.innerHeight);
    };
    return window.addEventListener("resize", l), l(), function() {
      return window.removeEventListener("resize", l);
    };
  }, []), n;
}
function Rv(e) {
  var n = Wt();
  return _e(function() {
    n.current = e;
  }), n.current;
}
function oS(e) {
  var n = Wt();
  return g1(function() {
    n.current = e;
  }), Pt(function() {
    for (var t = n.current, l = arguments.length, a = new Array(l), d = 0; d < l; d++)
      a[d] = arguments[d];
    return t == null ? void 0 : t.apply(void 0, a);
  }, []);
}
var u7 = {
  bottom: 0,
  top: 0,
  left: 0,
  right: 0
};
function hv() {
  var e = Wt(null), n = Pt(function() {
    return u7;
  }, []);
  return {
    constraintsRef: e,
    onMeasureDragConstraints: n
  };
}
var Zv = /* @__PURE__ */ _l(void 0), Gh = function() {
  var n = Gt(Zv);
  if (!n)
    throw Error("Sheet context error");
  return n;
}, Tv = /* @__PURE__ */ _l(void 0);
function p7(e) {
  var n = e.children, t = Gh(), l = me(!!t.disableDrag), a = l[0], d = l[1];
  function r() {
    t.disableDrag || d(!1);
  }
  function i() {
    a || d(!0);
  }
  return na(Tv.Provider, {
    value: {
      disableDrag: a,
      setDragEnabled: r,
      setDragDisabled: i
    }
  }, n);
}
var Fv = function() {
  var n = Gt(Tv);
  if (!n)
    throw Error("Sheet scroller context error");
  return n;
}, oT = typeof window < "u" && window.visualViewport, M7 = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]), TN = 0, UT;
function E7(e) {
  e === void 0 && (e = {});
  var n = e, t = n.isDisabled;
  ov(function() {
    if (!t)
      return TN++, TN === 1 && (Uv() ? UT = k7() : UT = S7()), function() {
        TN--, TN === 0 && UT();
      };
  }, [t]);
}
function S7() {
  return Dc(so(document.documentElement, "paddingRight", window.innerWidth - document.documentElement.clientWidth + "px"), so(document.documentElement, "overflow", "hidden"));
}
function k7() {
  var e, n = 0, t = function(U) {
    e = xh(U.target), !(e === document.documentElement && e === document.body) && (n = U.changedTouches[0].pageY);
  }, l = function(U) {
    if (e === document.documentElement || e === document.body) {
      U.preventDefault();
      return;
    }
    var N = U.changedTouches[0].pageY, R = e.scrollTop, h = e.scrollHeight - e.clientHeight;
    h !== 0 && ((R <= 0 && N > n || R >= h && N < n) && U.preventDefault(), n = N);
  }, a = function(U) {
    var N = U.target;
    NS(N) && N !== document.activeElement && (U.preventDefault(), N.style.transform = "translateY(-2000px)", N.focus(), requestAnimationFrame(function() {
      N.style.transform = "";
    }));
  }, d = function(U) {
    var N = U.target;
    NS(N) && (N.style.transform = "translateY(-2000px)", requestAnimationFrame(function() {
      N.style.transform = "", oT && (oT.height < window.innerHeight ? requestAnimationFrame(function() {
        US(N);
      }) : oT.addEventListener("resize", function() {
        return US(N);
      }, {
        once: !0
      }));
    }));
  }, r = function() {
    window.scrollTo(0, 0);
  }, i = window.pageXOffset, c = window.pageYOffset, V = Dc(so(document.documentElement, "paddingRight", window.innerWidth - document.documentElement.clientWidth + "px"), so(document.documentElement, "overflow", "hidden"), so(document.body, "marginTop", "-" + c + "px"));
  window.scrollTo(0, 0);
  var s = Dc(ms(document, "touchstart", t, {
    passive: !1,
    capture: !0
  }), ms(document, "touchmove", l, {
    passive: !1,
    capture: !0
  }), ms(document, "touchend", a, {
    passive: !1,
    capture: !0
  }), ms(document, "focus", d, !0), ms(window, "scroll", r));
  return function() {
    V(), s(), window.scrollTo(i, c);
  };
}
function so(e, n, t) {
  var l = e.style[n];
  return e.style[n] = t, function() {
    e.style[n] = l;
  };
}
function ms(e, n, t, l) {
  return e.addEventListener(n, t, l), function() {
    e.removeEventListener(n, t, l);
  };
}
function US(e) {
  for (var n = document.scrollingElement || document.documentElement; e && e !== n; ) {
    var t = xh(e);
    if (t !== document.documentElement && t !== document.body && t !== e) {
      var l = t.getBoundingClientRect().top, a = e.getBoundingClientRect().top;
      a > l + e.clientHeight && (t.scrollTop += a - l);
    }
    e = t.parentElement;
  }
}
function NS(e) {
  return e instanceof HTMLInputElement && !M7.has(e.type) || e instanceof HTMLTextAreaElement || e instanceof HTMLElement && e.isContentEditable;
}
var pr = {
  wrapper: {
    position: "fixed",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    overflow: "hidden",
    pointerEvents: "none"
  },
  backdrop: {
    zIndex: 1,
    position: "fixed",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    backgroundColor: "rgba(0, 0, 0, 0.2)",
    touchAction: "none",
    border: "none"
  },
  container: {
    zIndex: 2,
    position: "absolute",
    left: 0,
    bottom: 0,
    width: "100%",
    backgroundColor: "#fff",
    borderTopRightRadius: "8px",
    borderTopLeftRadius: "8px",
    boxShadow: "0px -2px 16px rgba(0, 0, 0, 0.3)",
    display: "flex",
    flexDirection: "column",
    pointerEvents: "auto"
  },
  headerWrapper: {
    width: "100%"
  },
  header: {
    height: "40px",
    width: "100%",
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  indicator: {
    width: "18px",
    height: "4px",
    borderRadius: "99px",
    backgroundColor: "#ddd"
  },
  content: {
    flexGrow: 1,
    display: "flex",
    flexDirection: "column",
    minHeight: "0px",
    position: "relative"
  },
  scroller: {
    height: "100%",
    overflowY: "auto"
  }
}, b7 = ["onOpenStart", "onOpenEnd", "onClose", "onCloseStart", "onCloseEnd", "onSnap", "children", "disableScrollLocking", "isOpen", "snapPoints", "rootId", "mountPoint", "style", "detent", "initialSnap", "disableDrag", "prefersReducedMotion", "tweenConfig"], Y7 = /* @__PURE__ */ vV(function(e, n) {
  var t = e.onOpenStart, l = e.onOpenEnd, a = e.onClose, d = e.onCloseStart, r = e.onCloseEnd, i = e.onSnap, c = e.children, V = e.disableScrollLocking, s = V === void 0 ? !1 : V, o = e.isOpen, U = e.snapPoints, N = e.rootId, R = e.mountPoint, h = e.style, Z = e.detent, W = Z === void 0 ? "full-height" : Z, F = e.initialSnap, m = F === void 0 ? 0 : F, E = e.disableDrag, u = E === void 0 ? !1 : E, b = e.prefersReducedMotion, k = b === void 0 ? !1 : b, Q = e.tweenConfig, S = Q === void 0 ? o7 : Q, v = Kc(e, b7), G = Wt(null), w = Oo(0), y = m7(), g = Vv(), f = !!(k || g), I = md({
    type: "tween"
  }, f ? U7 : S), K = Oo(0), Ue = bi(K, function(O) {
    return O >= y ? -1 : 9999999;
  }), q = bi(K, function(O) {
    return O >= y ? "hidden" : "visible";
  }), ae = Wt({
    onOpenStart: t,
    onOpenEnd: l,
    onCloseStart: d,
    onCloseEnd: r
  });
  g1(function() {
    ae.current = {
      onOpenStart: t,
      onOpenEnd: l,
      onCloseStart: d,
      onCloseEnd: r
    };
  }), U && (U = U.map(function(O) {
    return O > 0 && O <= 1 ? Math.round(O * y) : O < 0 ? y + O : O;
  }), console.assert(Z7(U) || y === 0, "Snap points need to be in descending order got: [" + U + "]"));
  var se = oS(function(O, re) {
    var te = re.delta, Qe = K.getVelocity();
    Qe > 0 && w.set(10), Qe < 0 && w.set(-10), K.set(Math.max(K.get() + te.y, 0));
  }), le = oS(function(O, re) {
    var te = re.velocity;
    if (te.y > R7)
      a();
    else {
      var Qe = G.current, Ye = Qe.getBoundingClientRect().height, Se = K.get(), P = 0;
      if (U) {
        var ge = U.map(function(tt) {
          return Ye - Math.min(tt, Ye);
        });
        W === "content-height" && !ge.includes(0) && ge.unshift(0), P = VS(ge, Se);
      } else
        Se / Ye > N7 && (P = Ye);
      if (P = sS({
        snapTo: P,
        sheetHeight: Ye
      }), OR(K, P, I), U && i) {
        var Me = Math.abs(Math.round(U[0] - P)), We = U.indexOf(VS(U, Me));
        i(We);
      }
      var De = Math.round(Ye), Oe = P >= De;
      Oe && a();
    }
    w.set(0);
  });
  _e(function() {
    if (!(!U || !i)) {
      var O = o ? m : U.length - 1;
      i(O);
    }
  }, [o]), Av(n, function() {
    return {
      y: K,
      snapTo: function(re) {
        var te = G.current;
        if (U && U[re] !== void 0 && te !== null) {
          var Qe = te.getBoundingClientRect().height, Ye = U[re], Se = sS({
            snapTo: Qe - Ye,
            sheetHeight: Qe
          });
          OR(K, Se, I), i && i(re), Se >= Qe && a();
        }
      }
    };
  }), F7(o, N), E7({
    isDisabled: s === !0 || !o
  });
  var L = nn(function() {
    var O = {
      drag: "y",
      dragElastic: 0,
      dragMomentum: !1,
      dragPropagation: !1,
      onDrag: se,
      onDragEnd: le
    };
    return u ? void 0 : O;
  }, [u]), $ = {
    y: K,
    sheetRef: G,
    isOpen: o,
    initialSnap: m,
    snapPoints: U,
    detent: W,
    indicatorRotation: w,
    callbacks: ae,
    dragProps: L,
    windowHeight: y,
    animationOptions: I,
    reduceMotion: f,
    disableDrag: u
  }, ee = na(Zv.Provider, {
    value: $
  }, na(Cl.div, Object.assign({}, v, {
    ref: n,
    style: md({}, pr.wrapper, {
      zIndex: Ue,
      visibility: q
    }, h)
  }), na(dv, null, o ? na(p7, null, ek.map(c, function(O, re) {
    return $S(O, {
      key: "sheet-child-" + re
    });
  })) : null)));
  return Nv ? ee : Yi(ee, R ?? document.body);
}), Q7 = ["children", "style", "className"], J7 = /* @__PURE__ */ vV(function(e, n) {
  var t = e.children, l = e.style, a = l === void 0 ? {} : l, d = e.className, r = d === void 0 ? "" : d, i = Kc(e, Q7), c = Gh(), V = c.y, s = c.isOpen, o = c.callbacks, U = c.snapPoints, N = c.initialSnap, R = N === void 0 ? 0 : N, h = c.sheetRef, Z = c.windowHeight, W = c.detent, F = c.animationOptions, m = c.reduceMotion, E = W7(s, o), u = E.handleAnimationComplete, b = U ? U[0] - U[R] : 0, k = U ? U[0] : null, Q = k !== null ? "min(" + k + "px, " + iS + ")" : iS;
  return na(Cl.div, Object.assign({}, i, {
    ref: w1([h, n]),
    className: "react-modal-sheet-container " + r,
    style: md({}, pr.container, a, W === "full-height" && {
      height: Q
    }, W === "content-height" && {
      maxHeight: Q
    }, {
      y: V
    }),
    initial: m ? !1 : {
      y: Z
    },
    animate: {
      y: b,
      transition: F
    },
    exit: {
      y: Z,
      transition: F
    },
    onAnimationComplete: u
  }), t);
}), v7 = ["children", "style", "disableDrag", "className"], z7 = /* @__PURE__ */ vV(function(e, n) {
  var t = e.children, l = e.style, a = e.disableDrag, d = e.className, r = d === void 0 ? "" : d, i = Kc(e, v7), c = Gh(), V = Fv(), s = hv(), o = s.constraintsRef, U = s.onMeasureDragConstraints, N = a || V.disableDrag ? void 0 : c.dragProps;
  return na(Cl.div, Object.assign({}, i, {
    ref: w1([n, o]),
    className: "react-modal-sheet-content " + r,
    style: md({}, pr.content, l)
  }, N, {
    dragConstraints: o,
    onMeasureDragConstraints: U
  }), t);
}), x7 = ["children", "style", "disableDrag"], G7 = /* @__PURE__ */ vV(function(e, n) {
  var t = e.children, l = e.style, a = e.disableDrag, d = Kc(e, x7), r = Gh(), i = r.indicatorRotation, c = r.dragProps, V = hv(), s = V.constraintsRef, o = V.onMeasureDragConstraints, U = a ? void 0 : c, N = bi(i, function(h) {
    return "translateX(2px) rotate(" + h + "deg)";
  }), R = bi(i, function(h) {
    return "translateX(-2px) rotate(" + -1 * h + "deg)";
  });
  return na(Cl.div, Object.assign({}, d, {
    ref: w1([n, s]),
    style: md({}, pr.headerWrapper, l)
  }, U, {
    dragConstraints: s,
    onMeasureDragConstraints: o
  }), t || na("div", {
    className: "react-modal-sheet-header",
    style: pr.header
  }, na(Cl.span, {
    className: "react-modal-sheet-drag-indicator",
    style: md({}, pr.indicator, {
      transform: N
    })
  }), na(Cl.span, {
    className: "react-modal-sheet-drag-indicator",
    style: md({}, pr.indicator, {
      transform: R
    })
  })));
}), y7 = ["style", "className"], RS = function(n) {
  return !!n.onClick || !!n.onTap;
}, B7 = /* @__PURE__ */ vV(function(e, n) {
  var t = e.style, l = t === void 0 ? {} : t, a = e.className, d = a === void 0 ? "" : a, r = Kc(e, y7), i = RS(r) ? Cl.button : Cl.div, c = RS(r) ? "auto" : "none";
  return na(i, Object.assign({}, r, {
    ref: n,
    className: "react-modal-sheet-backdrop " + d,
    style: md({}, pr.backdrop, l, {
      pointerEvents: c
    }),
    initial: {
      opacity: 0
    },
    animate: {
      opacity: 1
    },
    exit: {
      opacity: 0
    }
  }));
}), D7 = ["draggableAt", "children", "style", "className"], X7 = /* @__PURE__ */ vV(function(e, n) {
  var t = e.draggableAt, l = t === void 0 ? "top" : t, a = e.children, d = e.style, r = e.className, i = r === void 0 ? "" : r, c = Kc(e, D7), V = Fv();
  function s(R) {
    var h = R.scrollTop, Z = R.scrollHeight, W = R.clientHeight, F = Z > W;
    if (F) {
      var m = h <= 0, E = Z - h === W, u = l === "top" && m || l === "bottom" && E || l === "both" && (m || E);
      u ? V.setDragEnabled() : V.setDragDisabled();
    }
  }
  function o(R) {
    s(R.currentTarget);
  }
  function U(R) {
    s(R.currentTarget);
  }
  var N = T7() ? {
    onScroll: o,
    onTouchStart: U
  } : void 0;
  return na("div", Object.assign({}, c, {
    ref: n,
    className: "react-modal-sheet-scroller " + i,
    style: md({}, pr.scroller, d)
  }, N), a);
}), tr = Y7;
tr.Container = J7;
tr.Header = G7;
tr.Content = z7;
tr.Backdrop = B7;
tr.Scroller = X7;
const O7 = (e) => /* @__PURE__ */ z.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.7071 0.292893C16.0676 0.653377 16.0953 1.22061 15.7903 1.6129L15.7071 1.70711L9.414 7.99988L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3466 16.0676 14.7794 16.0953 14.3871 15.7903L14.2929 15.7071L7.99988 9.414L1.70711 15.7071C1.31658 16.0976 0.683418 16.0976 0.292893 15.7071C-0.0675906 15.3466 -0.0953204 14.7794 0.209704 14.3871L0.292893 14.2929L6.58575 7.99988L0.292893 1.70711C-0.0976309 1.31658 -0.0976309 0.683418 0.292893 0.292893C0.653377 -0.0675906 1.22061 -0.0953204 1.6129 0.209704L1.70711 0.292893L7.99988 6.58575L14.2929 0.292893C14.6834 -0.0976309 15.3166 -0.0976309 15.7071 0.292893Z", fill: "#30308F" })), Wv = (e) => /* @__PURE__ */ z.createElement("svg", { width: 44, height: 44, viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("g", { id: "Avatar" }, /* @__PURE__ */ z.createElement("circle", { id: "Image", cx: 22, cy: 22, r: 22, fill: "#30308F" }), /* @__PURE__ */ z.createElement("g", { id: "icon_transfer", clipPath: "url(#clip0_960_67548)" }, /* @__PURE__ */ z.createElement("g", { id: "Group" }, /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M25.4988 14.0418C25.9016 13.6391 26.5545 13.6391 26.9572 14.0418L29.9479 17.0324C30.3506 17.4351 30.3506 18.0881 29.9479 18.4908L26.9572 21.4815C26.5545 21.8842 25.9016 21.8842 25.4988 21.4815C25.0961 21.0787 25.0961 20.4258 25.4988 20.023L27.7602 17.7616L25.4988 15.5002C25.0961 15.0975 25.0961 14.4445 25.4988 14.0418Z", fill: "white" }), /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)_2", fillRule: "evenodd", clipRule: "evenodd", d: "M13.75 17.772C13.75 17.2024 14.2117 16.7407 14.7812 16.7407H29.2188C29.7883 16.7407 30.25 17.2024 30.25 17.772C30.25 18.3415 29.7883 18.8032 29.2188 18.8032H14.7812C14.2117 18.8032 13.75 18.3415 13.75 17.772Z", fill: "white" }), /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)_3", fillRule: "evenodd", clipRule: "evenodd", d: "M18.5011 22.5186C18.9038 22.9213 18.9038 23.5743 18.5011 23.977L16.2397 26.2384L18.5011 28.4998C18.9038 28.9026 18.9038 29.5555 18.5011 29.9583C18.0984 30.361 17.4454 30.361 17.0427 29.9583L14.052 26.9676C13.8586 26.7742 13.75 26.5119 13.75 26.2384C13.75 25.9649 13.8586 25.7026 14.052 25.5092L17.0427 22.5186C17.4454 22.1159 18.0984 22.1159 18.5011 22.5186Z", fill: "white" }), /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)_4", fillRule: "evenodd", clipRule: "evenodd", d: "M13.75 26.2283C13.75 25.6587 14.2117 25.197 14.7812 25.197H29.2188C29.7883 25.197 30.25 25.6587 30.25 26.2283C30.25 26.7978 29.7883 27.2595 29.2188 27.2595H14.7812C14.2117 27.2595 13.75 26.7978 13.75 26.2283Z", fill: "white" })))), /* @__PURE__ */ z.createElement("defs", null, /* @__PURE__ */ z.createElement("clipPath", { id: "clip0_960_67548" }, /* @__PURE__ */ z.createElement("rect", { width: 24.75, height: 24.75, fill: "white", transform: "translate(9.625 9.625)" })))), mv = (e) => /* @__PURE__ */ z.createElement("svg", { width: 44, height: 44, viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("g", { id: "Avatar" }, /* @__PURE__ */ z.createElement("circle", { id: "Image", cx: 22, cy: 22, r: 22, fill: "#30308F" }), /* @__PURE__ */ z.createElement("g", { id: "icon_money" }, /* @__PURE__ */ z.createElement("g", { id: "Group" }, /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M14.8773 12.3673C15.9599 11.9337 17.3848 11.6875 18.9062 11.6875C20.4277 11.6875 21.8526 11.9337 22.9352 12.3673C23.4735 12.5829 23.9782 12.8652 24.3652 13.2307C24.7538 13.5978 25.0938 14.1214 25.0938 14.7812C25.0938 15.4411 24.7538 15.9647 24.3652 16.3318C23.9782 16.6973 23.4735 16.9796 22.9352 17.1952C21.8526 17.6288 20.4277 17.875 18.9062 17.875C17.3848 17.875 15.9599 17.6288 14.8773 17.1952C14.339 16.9796 13.8343 16.6973 13.4473 16.3318C13.0587 15.9647 12.7188 15.4411 12.7188 14.7812C12.7188 14.1214 13.0587 13.5978 13.4473 13.2307C13.8343 12.8652 14.339 12.5829 14.8773 12.3673ZM14.7716 14.8397C14.7715 14.8397 14.7721 14.838 14.774 14.8345C14.7727 14.838 14.7718 14.8397 14.7716 14.8397ZM14.8136 14.7812C14.8263 14.7669 14.8427 14.7498 14.8635 14.7302C14.9986 14.6026 15.2493 14.4401 15.6442 14.2819C16.4283 13.9679 17.5815 13.75 18.9062 13.75C20.231 13.75 21.3842 13.9679 22.1683 14.2819C22.5632 14.4401 22.8139 14.6026 22.949 14.7302C22.9698 14.7498 22.9862 14.7669 22.9989 14.7812C22.9862 14.7956 22.9698 14.8127 22.949 14.8323C22.8139 14.9599 22.5632 15.1224 22.1683 15.2806C21.3842 15.5946 20.231 15.8125 18.9062 15.8125C17.5815 15.8125 16.4283 15.5946 15.6442 15.2806C15.2493 15.1224 14.9986 14.9599 14.8635 14.8323C14.8427 14.8127 14.8263 14.7956 14.8136 14.7812ZM23.0409 14.8397C23.0407 14.8397 23.0398 14.838 23.0385 14.8344C23.0404 14.838 23.041 14.8397 23.0409 14.8397ZM23.0385 14.7281C23.0398 14.7245 23.0407 14.7228 23.0409 14.7228C23.041 14.7228 23.0404 14.7245 23.0385 14.7281ZM14.774 14.728C14.7721 14.7245 14.7715 14.7228 14.7716 14.7228C14.7718 14.7228 14.7727 14.7245 14.774 14.728Z", fill: "white" }), /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)_2", fillRule: "evenodd", clipRule: "evenodd", d: "M24.0625 13.75C24.632 13.75 25.0938 14.2117 25.0938 14.7812V22.7838C25.0938 23.3533 24.632 23.815 24.0625 23.815C23.493 23.815 23.0312 23.3533 23.0312 22.7838V14.7812C23.0312 14.2117 23.493 13.75 24.0625 13.75Z", fill: "white" }), /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)_3", fillRule: "evenodd", clipRule: "evenodd", d: "M14.7804 18.8638C14.7581 18.3139 14.3053 17.875 13.75 17.875C13.1805 17.875 12.7188 18.3367 12.7188 18.9062C12.7188 19.5661 13.0587 20.0897 13.4473 20.4568C13.8343 20.8223 14.339 21.1046 14.8773 21.3202C15.9599 21.7538 17.3848 22 18.9062 22C20.4277 22 21.8526 21.7538 22.9352 21.3202C23.4735 21.1046 23.9782 20.8223 24.3652 20.4568C24.7538 20.0897 25.0938 19.5661 25.0938 18.9062C25.0938 18.3367 24.632 17.875 24.0625 17.875C23.5072 17.875 23.0544 18.3139 23.0321 18.8638C23.0208 18.8811 22.9967 18.9123 22.949 18.9573C22.8139 19.0849 22.5632 19.2474 22.1683 19.4056C21.3842 19.7196 20.231 19.9375 18.9062 19.9375C17.5815 19.9375 16.4283 19.7196 15.6442 19.4056C15.2493 19.2474 14.9986 19.0849 14.8635 18.9573C14.8158 18.9123 14.7917 18.8811 14.7804 18.8638ZM23.0409 18.8478C23.041 18.8478 23.0404 18.8495 23.0385 18.8531C23.0398 18.8495 23.0407 18.8478 23.0409 18.8478ZM14.774 18.853C14.7721 18.8495 14.7715 18.8478 14.7716 18.8478C14.7718 18.8478 14.7727 18.8495 14.774 18.853Z", fill: "white" }), /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)_4", fillRule: "evenodd", clipRule: "evenodd", d: "M29.1887 24.0884C27.7884 22.68 25.5039 22.677 24.0905 24.0905L24.0884 24.0925L24.0884 24.0925C22.68 25.4929 22.677 27.7774 24.0905 29.1908L24.0925 29.1929C25.4929 30.6012 27.7774 30.6042 29.1908 29.1908L29.1929 29.1887C30.6012 27.7884 30.6042 25.5039 29.1908 24.0905L29.1887 24.0884ZM30.6502 22.6331C28.4415 20.4128 24.8494 20.4158 22.6331 22.631C20.4128 24.8398 20.4158 28.4319 22.631 30.6482C24.8398 32.8684 28.4319 32.8654 30.6482 30.6502C32.8684 28.4415 32.8654 24.8494 30.6502 22.6331Z", fill: "white" }), /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)_5", fillRule: "evenodd", clipRule: "evenodd", d: "M14.7804 22.9888C14.7581 22.4389 14.3053 22 13.75 22C13.1805 22 12.7188 22.4617 12.7188 23.0312C12.7188 23.6911 13.0587 24.2147 13.4473 24.5818C13.8343 24.9473 14.339 25.2296 14.8773 25.4452C15.9599 25.8788 17.3848 26.125 18.9062 26.125C20.4057 26.125 21.8205 25.8844 22.8986 25.4531C23.4274 25.2416 23.6846 24.6414 23.4731 24.1126C23.2616 23.5838 22.6614 23.3266 22.1326 23.5381C21.3545 23.8494 20.2118 24.0625 18.9062 24.0625C17.5815 24.0625 16.4283 23.8446 15.6442 23.5306C15.2493 23.3724 14.9986 23.2099 14.8635 23.0823C14.8158 23.0373 14.7917 23.0061 14.7804 22.9888ZM14.774 22.978C14.7721 22.9745 14.7715 22.9728 14.7716 22.9728C14.7718 22.9728 14.7727 22.9745 14.774 22.978Z", fill: "white" }), /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)_6", fillRule: "evenodd", clipRule: "evenodd", d: "M13.75 13.75C14.3195 13.75 14.7812 14.2117 14.7812 14.7812V27.1151C14.7929 27.1326 14.8169 27.1634 14.8635 27.2073C14.9986 27.3349 15.2493 27.4974 15.6442 27.6556C16.4283 27.9696 17.5815 28.1875 18.9062 28.1875C20.1851 28.1875 21.3065 27.9762 22.0996 27.6765C22.6324 27.4753 23.2275 27.744 23.4288 28.2768C23.63 28.8096 23.3613 29.4047 22.8285 29.606C21.7654 30.0076 20.3912 30.25 18.9062 30.25C17.3848 30.25 15.9599 30.0038 14.8773 29.5702C14.339 29.3546 13.8343 29.0723 13.4473 28.7068C13.0587 28.3397 12.7188 27.8161 12.7188 27.1562V14.7812C12.7188 14.2117 13.1805 13.75 13.75 13.75ZM14.7716 27.0978C14.7718 27.0978 14.7727 27.0995 14.774 27.1031C14.7721 27.0995 14.7715 27.0978 14.7716 27.0978Z", fill: "white" }))))), uv = (e) => /* @__PURE__ */ z.createElement("svg", { width: 44, height: 44, viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("g", { id: "Avatar" }, /* @__PURE__ */ z.createElement("circle", { id: "Image", cx: 22, cy: 22, r: 22, fill: "#30308F" }), /* @__PURE__ */ z.createElement("g", { id: "icon_wallet" }, /* @__PURE__ */ z.createElement("g", { id: "Group" }, /* @__PURE__ */ z.createElement("g", { id: "Group_2" }, /* @__PURE__ */ z.createElement("path", { id: "Vector (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M25.0833 13.1795L15.6295 16.7509H25.0834V13.1828C25.0834 13.1813 25.0834 13.1802 25.0833 13.1795C25.0833 13.1795 25.0833 13.1795 25.0833 13.1795ZM27.1459 16.7509V13.1828C27.1459 11.7561 25.7169 10.7286 24.3557 11.2496C24.3545 11.25 24.3534 11.2504 24.3523 11.2509L13.6856 15.2805C13.6854 15.2806 13.6852 15.2806 13.6851 15.2807C12.4883 15.7317 11.6875 16.8902 11.6875 18.174V29.2187C11.6875 30.9226 13.0773 32.3124 14.7812 32.3124H29.2188C30.9227 32.3124 32.3125 30.9226 32.3125 29.2187V19.8446C32.3125 18.1407 30.9227 16.7509 29.2188 16.7509H27.1459ZM25.9683 18.8134C26.0161 18.8202 26.065 18.8237 26.1147 18.8237C26.1644 18.8237 26.2133 18.8202 26.2611 18.8134H29.2188C29.7836 18.8134 30.25 19.2798 30.25 19.8446V29.2187C30.25 29.7835 29.7836 30.2499 29.2188 30.2499H14.7812C14.2164 30.2499 13.75 29.7835 13.75 29.2187V18.8134H25.9683ZM24.7225 12.2134L24.7225 12.2135L24.7225 12.2134Z", fill: "white" }), /* @__PURE__ */ z.createElement("path", { id: "Shape 3077 (Stroke)", fillRule: "evenodd", clipRule: "evenodd", d: "M25.8591 23.1792C25.944 23.1566 26.0332 23.1445 26.1252 23.1445C26.9113 23.1445 27.5483 23.7816 27.5483 24.5677C27.5483 25.3174 26.9573 25.9908 26.1355 25.9908C25.3858 25.9908 24.7124 25.3997 24.7124 24.578C24.7124 23.9119 25.1788 23.3061 25.8591 23.1792Z", fill: "white" })))))), hS = [
  /* @__PURE__ */ Y.jsx(Wv, {}, "1"),
  /* @__PURE__ */ Y.jsx(mv, {}, "2"),
  /* @__PURE__ */ Y.jsx(uv, {}, "3")
], j7 = A(tr.Container)`
  padding-bottom: 16px;
  border-radius: 15px 15px 0 0 !important;
  max-height: initial !important;
  -webkit-font-smoothing: subpixel-antialiased;
`, H7 = A(tr.Header)`
  display: flex;
  justify-content: space-between;
  width: auto;
  padding: 26px 20px 18px 16px;
  margin-bottom: 8px;
`, f7 = A(tr.Content)`
  overflow: scroll;
`, w7 = A(Fe)`
  font-weight: 500;
`;
function g7(e) {
  const n = {};
  return e.forEach((t) => {
    const l = new Date(t.timeStamp), a = qY(l).formattedDate;
    n[a] || (n[a] = []), n[a].push(t);
  }), n;
}
const pv = ({
  historyList: e,
  bottomSheetOpen: n,
  setBottomSheetOpen: t
}) => {
  var a;
  const l = nn(
    () => g7(e),
    [e.map((d) => d.timeStamp)]
  );
  return /* @__PURE__ */ Y.jsxs(
    tr,
    {
      detent: "content-height",
      mountPoint: (a = document.getElementsByClassName(
        "sendbird-conversation"
      )) == null ? void 0 : a[0],
      rootId: "chat-window",
      isOpen: e.length > 0 && n,
      onClose: () => {
        t(!1);
      },
      children: [
        /* @__PURE__ */ Y.jsxs(j7, { children: [
          /* @__PURE__ */ Y.jsxs(H7, { children: [
            /* @__PURE__ */ Y.jsx(Fe, { type: oe.H_2, children: "Transaction history" }),
            /* @__PURE__ */ Y.jsx(
              O7,
              {
                style: { cursor: "pointer" },
                onClick: () => {
                  t(!1);
                }
              }
            )
          ] }),
          /* @__PURE__ */ Y.jsx(f7, { children: Object.entries(l).map(([d, r]) => /* @__PURE__ */ Y.jsxs(
            "div",
            {
              style: {
                padding: "2px 16px"
              },
              children: [
                /* @__PURE__ */ Y.jsx(
                  Fe,
                  {
                    type: oe.CAPTION_2,
                    color: ie.ONBACKGROUND_2,
                    children: d
                  }
                ),
                r.map((i, c) => {
                  const { formattedTime: V } = qY(
                    new Date(i.timeStamp)
                  );
                  return /* @__PURE__ */ Y.jsx(
                    "div",
                    {
                      style: { margin: "20px 0px" },
                      children: /* @__PURE__ */ Y.jsx(
                        Cc,
                        {
                          icon: hS[c % hS.length],
                          title: /* @__PURE__ */ Y.jsx(w7, { type: oe.SUBTITLE_1, children: i.description }),
                          description: /* @__PURE__ */ Y.jsx(
                            Fe,
                            {
                              type: oe.CAPTION_3,
                              color: ie.ONBACKGROUND_3,
                              children: V
                            }
                          ),
                          rightTop: /* @__PURE__ */ Y.jsx(Fe, { type: oe.SUBTITLE_1, children: i.amount }),
                          rightBottom: /* @__PURE__ */ Y.jsx(
                            Fe,
                            {
                              type: oe.CAPTION_3,
                              color: ie.ONBACKGROUND_3,
                              children: i.currentBalance
                            }
                          )
                        }
                      )
                    },
                    i.transactionId
                  );
                })
              ]
            },
            d
          )) })
        ] }),
        /* @__PURE__ */ Y.jsx(tr.Backdrop, {})
      ]
    }
  );
}, I7 = (e) => /* @__PURE__ */ z.createElement("svg", { width: 78, height: 70, viewBox: "0 0 78 70", fill: "none", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ z.createElement("rect", { width: 77.8202, height: 70, fill: "url(#pattern0)" }), /* @__PURE__ */ z.createElement("defs", null, /* @__PURE__ */ z.createElement("pattern", { id: "pattern0", patternContentUnits: "objectBoundingBox", width: 1, height: 1 }, /* @__PURE__ */ z.createElement("use", { xlinkHref: "#image0_796_33511", transform: "scale(0.00245098 0.0027248)" })), /* @__PURE__ */ z.createElement("image", { id: "image0_796_33511", width: 408, height: 367, xlinkHref: "data:image/png;base64,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" }))), L7 = A.div`
  display: flex;
  flex-direction: column;
  width: 220px;
  font-family: var(--sendbird-font-family-custom);
`, C7 = A.div`
  background-color: var(--sendbird-light-primary-300);
  border-radius: 16px 16px 0 0;
  text-align: center;
  padding: 16px 0;
  display: flex;
  justify-content: center;
`, K7 = A.div`
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 0 0 16px 16px;
  padding: 12px;
`, _7 = A(Ql)`
  width: 100%;
  border-radius: 8px;
  margin-top: 12px;
`, P7 = A.div`
  font-family: var(--sendbird-font-family-default);
  font-size: 16px;
  font-weight: 700;
  line-height: 20px;
  letter-spacing: -0.01em;
  margin-top: 6px;
`, A7 = ({
  message: e
}) => {
  const [n, t] = me(!1), l = JSON.parse((e == null ? void 0 : e.transaction_history) ?? "[]"), { inputValue: a } = jn();
  return _e(() => {
    t(!1);
  }, [a == null ? void 0 : a.value, a == null ? void 0 : a.id]), /* @__PURE__ */ Y.jsxs(L7, { children: [
    /* @__PURE__ */ Y.jsx(C7, { children: /* @__PURE__ */ Y.jsx(I7, {}) }),
    /* @__PURE__ */ Y.jsxs(K7, { children: [
      /* @__PURE__ */ Y.jsx(Fe, { type: oe.BODY_1, children: "Your balance" }),
      /* @__PURE__ */ Y.jsx(P7, { children: (e == null ? void 0 : e.current_balance) ?? "$0" }),
      (e == null ? void 0 : e.transaction_history) != null && /* @__PURE__ */ Y.jsx(
        _7,
        {
          onClick: () => {
            t(!0);
          },
          children: /* @__PURE__ */ Y.jsx(
            Fe,
            {
              type: oe.BUTTON_2,
              color: ie.ONCONTENT_1,
              children: "View transaction history"
            }
          )
        }
      )
    ] }),
    /* @__PURE__ */ Y.jsx(
      pv,
      {
        historyList: l,
        bottomSheetOpen: n,
        setBottomSheetOpen: t
      }
    )
  ] });
}, q7 = A.div`
  display: flex;
  flex-direction: column;
  width: 244px;
  font-family: var(--sendbird-font-family-custom);
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 16px;
  padding: 12px;
  gap: 12px;
`, $7 = A.div`
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 16px;
  display: flex;
  flex-direction: column;
  gap: 6px;
`, e$ = A(Ql)`
  width: 100%;
  border-radius: 18px;
  height: 36px;

  &:hover {
    background-color: #44712f !important;
  }
`, t$ = A(Ql)`
  width: 100%;
  border-radius: 18px;
  height: 36px;

  &:hover {
    background-color: #44712f !important;
  }
`, NT = A(Fe)`
  font-weight: 700;
`, n$ = A(Fe)`
  font-weight: 400;
`, ZS = A(Fe)`
  font-weight: 400;
`, l$ = A(Fe)`
  font-weight: 500;
  white-space: normal;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  margin-bottom: 8px;
`;
class a$ extends sW {
  render() {
    return /* @__PURE__ */ Y.jsx(
      "div",
      {
        style: {
          width: "100%",
          height: 1,
          backgroundColor: "rgba(0, 0, 0, 0.12)"
        }
      }
    );
  }
}
const d$ = ({ message: e }) => {
  const n = e == null ? void 0 : e.order_details, t = Ji();
  function l(d) {
    t(`Cancel Order #${d}`);
  }
  function a() {
    t("Connect to an agent");
  }
  return /* @__PURE__ */ Y.jsxs(q7, { children: [
    /* @__PURE__ */ Y.jsxs(
      "div",
      {
        style: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        },
        children: [
          /* @__PURE__ */ Y.jsxs(
            NT,
            {
              type: oe.BODY_1,
              color: ie.ONBACKGROUND_1,
              children: [
                "Order No.",
                n.id
              ]
            }
          ),
          /* @__PURE__ */ Y.jsx(
            n$,
            {
              type: oe.BODY_1,
              color: ie.ONBACKGROUND_1,
              children: n.date
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ Y.jsx(a$, {}),
    /* @__PURE__ */ Y.jsx("div", { children: /* @__PURE__ */ Y.jsx(
      "div",
      {
        style: {
          borderRadius: 10,
          backgroundColor: `${n.status === "Delivery Completed" ? "#E2FAE4" : "#E7F1FF"}`,
          width: 126,
          textAlign: "center",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          height: 20
        },
        children: /* @__PURE__ */ Y.jsx(
          "div",
          {
            style: {
              fontFamily: "var(--sendbird-font-family-default)",
              fontWeight: 500,
              fontSize: 11,
              lineHeight: "20px",
              margin: "4px 8px",
              color: `${n.status === "Delivery Completed" ? "#084D42" : "#30308F"}`
            },
            children: n.status
          }
        )
      }
    ) }),
    n.items.map((d) => /* @__PURE__ */ Y.jsx(
      Cc,
      {
        icon: /* @__PURE__ */ Y.jsx(mh, { image: d.image, width: 40, height: 40 }),
        title: /* @__PURE__ */ Y.jsx(
          l$,
          {
            type: oe.BODY_1,
            color: ie.ONBACKGROUND_1,
            children: d.name
          }
        ),
        description: /* @__PURE__ */ Y.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "column",
              gap: 4
            },
            children: [
              /* @__PURE__ */ Y.jsx(
                ZS,
                {
                  type: oe.CAPTION_3,
                  color: ie.ONBACKGROUND_1,
                  children: /* @__PURE__ */ Y.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        justifyContent: "space-between"
                      },
                      children: [
                        /* @__PURE__ */ Y.jsx("div", { children: "Unit Price" }),
                        /* @__PURE__ */ Y.jsxs("div", { children: [
                          "$",
                          d.price
                        ] })
                      ]
                    }
                  )
                }
              ),
              /* @__PURE__ */ Y.jsx(
                ZS,
                {
                  type: oe.CAPTION_3,
                  color: ie.ONBACKGROUND_1,
                  children: /* @__PURE__ */ Y.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        justifyContent: "space-between"
                      },
                      children: [
                        /* @__PURE__ */ Y.jsx("div", { children: "Quantity" }),
                        /* @__PURE__ */ Y.jsx("div", { children: d.quantity })
                      ]
                    }
                  )
                }
              )
            ]
          }
        )
      },
      d.name
    )),
    /* @__PURE__ */ Y.jsxs(
      "div",
      {
        style: {
          display: "flex",
          justifyContent: "space-between"
        },
        children: [
          /* @__PURE__ */ Y.jsx(
            NT,
            {
              type: oe.BODY_1,
              color: ie.ONBACKGROUND_1,
              children: "Item total:"
            }
          ),
          /* @__PURE__ */ Y.jsxs(
            NT,
            {
              type: oe.BODY_1,
              color: ie.ONBACKGROUND_1,
              children: [
                "$",
                n.items.reduce(
                  (d, r) => d + r.price * r.quantity,
                  0
                )
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ Y.jsxs($7, { children: [
      n.status === "Payment Completed" && /* @__PURE__ */ Y.jsx(
        e$,
        {
          onClick: () => {
            l(n.id);
          },
          children: /* @__PURE__ */ Y.jsx(
            Fe,
            {
              type: oe.BUTTON_2,
              color: ie.ONCONTENT_1,
              children: "Cancel Order"
            }
          )
        }
      ),
      /* @__PURE__ */ Y.jsx(
        t$,
        {
          onClick: () => {
            a();
          },
          children: /* @__PURE__ */ Y.jsx(
            Fe,
            {
              type: oe.BUTTON_2,
              color: ie.ONCONTENT_1,
              children: "Connect to an agent"
            }
          )
        }
      )
    ] })
  ] });
};
class Mv extends sW {
  render() {
    return /* @__PURE__ */ Y.jsx(
      "div",
      {
        style: {
          borderRadius: 10,
          backgroundColor: `${this.props.history.status === "Delivery Completed" ? "#E2FAE4" : "#E7F1FF"}`,
          width: 126,
          textAlign: "center"
        },
        children: /* @__PURE__ */ Y.jsx(
          "div",
          {
            style: {
              fontFamily: "var(--sendbird-font-family-default)",
              fontWeight: 500,
              fontSize: 11,
              lineHeight: "20px",
              margin: "4px 8px",
              color: `${this.props.history.status === "Delivery Completed" ? "#084D42" : "#30308F"}`
            },
            children: this.props.history.status
          }
        )
      }
    );
  }
}
const Ev = (e) => /* @__PURE__ */ z.createElement("svg", { width: 14, height: 14, viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.39986 10.671C4.17205 10.8988 4.17205 11.2682 4.39986 11.496C4.62766 11.7238 4.99701 11.7238 5.22482 11.496L9.30815 7.41264C9.53595 7.18484 9.53595 6.81549 9.30815 6.58768L5.22482 2.50435C4.99701 2.27654 4.62766 2.27654 4.39986 2.50435C4.17205 2.73216 4.17205 3.1015 4.39986 3.32931L8.07071 7.00016L4.39986 10.671Z", fill: "black", fillOpacity: 0.5 })), r$ = (e) => /* @__PURE__ */ z.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.7071 0.292893C16.0676 0.653377 16.0953 1.22061 15.7903 1.6129L15.7071 1.70711L9.414 7.99988L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3466 16.0676 14.7794 16.0953 14.3871 15.7903L14.2929 15.7071L7.99988 9.414L1.70711 15.7071C1.31658 16.0976 0.683418 16.0976 0.292893 15.7071C-0.0675906 15.3466 -0.0953204 14.7794 0.209704 14.3871L0.292893 14.2929L6.58575 7.99988L0.292893 1.70711C-0.0976309 1.31658 -0.0976309 0.683418 0.292893 0.292893C0.653377 -0.0675906 1.22061 -0.0953204 1.6129 0.209704L1.70711 0.292893L7.99988 6.58575L14.2929 0.292893C14.6834 -0.0976309 15.3166 -0.0976309 15.7071 0.292893Z", fill: "#508357" })), TS = "calc(100% - env(safe-area-inset-top) - 34px)", Sv = typeof window > "u", i$ = {
  ease: "easeOut",
  duration: 0.2
}, V$ = {
  ease: "linear",
  duration: 0.01
}, c$ = 0.6, s$ = 500;
function FS(e, n) {
  let t = e[0], l = Math.abs(e[0] - n);
  for (let a = 1; a < e.length; a++) {
    const d = Math.abs(e[a] - n);
    d < l && (t = e[a], l = d);
  }
  return t;
}
function o$(e) {
  const n = document.querySelector("body"), t = document.querySelector(`#${e}`);
  t && (n.style.backgroundColor = "#000", t.style.overflow = "hidden", t.style.willChange = "transform", t.style.transition = "transform 200ms ease-in-out, border-radius 200ms linear", t.style.transform = `translateY(calc(env(safe-area-inset-top) + ${24 / 2}px)) scale(1)`, t.style.borderTopRightRadius = "10px", t.style.borderTopLeftRadius = "10px");
}
function WS(e) {
  const n = document.querySelector("body"), t = document.getElementById(e);
  function l() {
    t.style.removeProperty("overflow"), t.style.removeProperty("will-change"), t.style.removeProperty("transition"), n.style.removeProperty("background-color"), t.removeEventListener("transitionend", l);
  }
  t && (t.style.removeProperty("border-top-right-radius"), t.style.removeProperty("border-top-left-radius"), t.style.removeProperty("transform"), t.addEventListener("transitionend", l));
}
function U$(e) {
  for (let n = 0; n < e.length; n++)
    if (e[n + 1] > e[n])
      return !1;
  return !0;
}
function mS({
  snapTo: e,
  sheetHeight: n
}) {
  return e < 0 && console.warn(
    `Snap point is out of bounds. Sheet height is ${n} but snap point is ${n + Math.abs(e)}.`
  ), Math.max(Math.round(e), 0);
}
function I1(e) {
  return (n) => {
    e.forEach((t) => {
      typeof t == "function" ? t(n) : t && (t.current = n);
    });
  };
}
function N$() {
  return typeof window > "u" ? !1 : "ontouchstart" in window || navigator.maxTouchPoints > 0;
}
const L1 = Sv ? z.useEffect : z.useLayoutEffect;
function R$(e, n) {
  const t = kv(e);
  z.useEffect(() => {
    n && !t && e ? o$(n) : n && !e && t && WS(n);
  }, [e, t]), z.useEffect(() => () => {
    n && e && WS(n);
  }, [e]);
}
function h$(e, n) {
  const t = kv(e), l = z.useRef(!1), a = z.useCallback(() => {
    var d, r, i, c;
    l.current ? ((c = (i = n.current).onCloseEnd) == null || c.call(i), l.current = !1) : ((r = (d = n.current).onOpenEnd) == null || r.call(d), l.current = !0);
  }, [e, t]);
  return z.useEffect(() => {
    var d, r, i, c;
    !t && e ? (r = (d = n.current).onOpenStart) == null || r.call(d) : !e && t && ((c = (i = n.current).onCloseStart) == null || c.call(i));
  }, [e, t]), { handleAnimationComplete: a };
}
function Z$() {
  const [e, n] = z.useState(0);
  return L1(() => {
    const t = () => n(window.innerHeight);
    return window.addEventListener("resize", t), t(), () => window.removeEventListener("resize", t);
  }, []), e;
}
function kv(e) {
  const n = z.useRef();
  return z.useEffect(() => {
    n.current = e;
  }), n.current;
}
function uS(e) {
  const n = z.useRef();
  return L1(() => {
    n.current = e;
  }), z.useCallback((...t) => {
    const l = n.current;
    return l == null ? void 0 : l(...t);
  }, []);
}
const T$ = { bottom: 0, top: 0, left: 0, right: 0 };
function bv() {
  const e = z.useRef(null), n = z.useCallback(() => T$, []);
  return { constraintsRef: e, onMeasureDragConstraints: n };
}
const Yv = z.createContext(
  void 0
), yh = () => {
  const e = z.useContext(Yv);
  if (!e)
    throw Error("Sheet context error");
  return e;
}, Qv = z.createContext(void 0);
function F$({
  children: e
}) {
  const n = yh(), [t, l] = z.useState(
    !!n.disableDrag
  );
  function a() {
    n.disableDrag || l(!1);
  }
  function d() {
    t || l(!0);
  }
  return /* @__PURE__ */ Y.jsx(
    Qv.Provider,
    {
      value: { disableDrag: t, setDragEnabled: a, setDragDisabled: d },
      children: e
    }
  );
}
const Jv = () => {
  const e = z.useContext(Qv);
  if (!e)
    throw Error("Sheet scroller context error");
  return e;
}, RT = typeof window < "u" && window.visualViewport, W$ = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let FN = 0, hT;
function m$(e = {}) {
  let { isDisabled: n } = e;
  ov(() => {
    if (!n)
      return FN++, FN === 1 && (Uv() ? hT = p$() : hT = u$()), () => {
        FN--, FN === 0 && hT();
      };
  }, [n]);
}
function u$() {
  return Dc(
    oo(
      document.documentElement,
      "paddingRight",
      `${window.innerWidth - document.documentElement.clientWidth}px`
    ),
    oo(document.documentElement, "overflow", "hidden")
  );
}
function p$() {
  let e, n = 0, t = (o) => {
    e = xh(o.target), !(e === document.documentElement && e === document.body) && (n = o.changedTouches[0].pageY);
  }, l = (o) => {
    if (e === document.documentElement || e === document.body) {
      o.preventDefault();
      return;
    }
    let U = o.changedTouches[0].pageY, N = e.scrollTop, R = e.scrollHeight - e.clientHeight;
    R !== 0 && ((N <= 0 && U > n || N >= R && U < n) && o.preventDefault(), n = U);
  }, a = (o) => {
    let U = o.target;
    MS(U) && U !== document.activeElement && (o.preventDefault(), U.style.transform = "translateY(-2000px)", U.focus(), requestAnimationFrame(() => {
      U.style.transform = "";
    }));
  }, d = (o) => {
    let U = o.target;
    MS(U) && (U.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      U.style.transform = "", RT && (RT.height < window.innerHeight ? requestAnimationFrame(() => {
        pS(U);
      }) : RT.addEventListener(
        "resize",
        () => pS(U),
        { once: !0 }
      ));
    }));
  }, r = () => {
    window.scrollTo(0, 0);
  }, i = window.pageXOffset, c = window.pageYOffset, V = Dc(
    oo(
      document.documentElement,
      "paddingRight",
      `${window.innerWidth - document.documentElement.clientWidth}px`
    ),
    oo(document.documentElement, "overflow", "hidden"),
    oo(document.body, "marginTop", `-${c}px`)
  );
  window.scrollTo(0, 0);
  let s = Dc(
    us(document, "touchstart", t, {
      passive: !1,
      capture: !0
    }),
    us(document, "touchmove", l, {
      passive: !1,
      capture: !0
    }),
    us(document, "touchend", a, {
      passive: !1,
      capture: !0
    }),
    us(document, "focus", d, !0),
    us(window, "scroll", r)
  );
  return () => {
    V(), s(), window.scrollTo(i, c);
  };
}
function oo(e, n, t) {
  let l = e.style[n];
  return e.style[n] = t, () => {
    e.style[n] = l;
  };
}
function us(e, n, t, l) {
  return e.addEventListener(n, t, l), () => {
    e.removeEventListener(n, t, l);
  };
}
function pS(e) {
  let n = document.scrollingElement || document.documentElement;
  for (; e && e !== n; ) {
    let t = xh(e);
    if (t !== document.documentElement && t !== document.body && t !== e) {
      let l = t.getBoundingClientRect().top, a = e.getBoundingClientRect().top;
      a > l + e.clientHeight && (t.scrollTop += a - l);
    }
    e = t.parentElement;
  }
}
function MS(e) {
  return e instanceof HTMLInputElement && !W$.has(e.type) || e instanceof HTMLTextAreaElement || e instanceof HTMLElement && e.isContentEditable;
}
const Mr = {
  wrapper: {
    position: "fixed",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    overflow: "hidden",
    pointerEvents: "none"
  },
  backdrop: {
    zIndex: 1,
    position: "fixed",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    backgroundColor: "rgba(0, 0, 0, 0.2)",
    touchAction: "none",
    // Disable iOS body scrolling
    border: "none"
  },
  container: {
    zIndex: 2,
    position: "absolute",
    left: 0,
    bottom: 0,
    width: "100%",
    backgroundColor: "#fff",
    borderTopRightRadius: "8px",
    borderTopLeftRadius: "8px",
    boxShadow: "0px -2px 16px rgba(0, 0, 0, 0.3)",
    display: "flex",
    flexDirection: "column",
    pointerEvents: "auto",
    WebkitFontSmoothing: "subpixel-antialised"
  },
  headerWrapper: {
    width: "100%"
  },
  header: {
    height: "40px",
    width: "100%",
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  indicator: {
    width: "18px",
    height: "4px",
    borderRadius: "99px",
    backgroundColor: "#ddd"
  },
  content: {
    flexGrow: 1,
    display: "flex",
    flexDirection: "column",
    minHeight: "0px",
    position: "relative"
  },
  scroller: {
    height: "100%",
    overflowY: "auto"
  }
}, M$ = z.forwardRef(
  ({
    onOpenStart: e,
    onOpenEnd: n,
    onClose: t,
    onCloseStart: l,
    onCloseEnd: a,
    onSnap: d,
    children: r,
    disableScrollLocking: i = !1,
    isOpen: c,
    snapPoints: V,
    rootId: s,
    mountPoint: o,
    style: U,
    detent: N = "full-height",
    initialSnap: R = 0,
    disableDrag: h = !1,
    prefersReducedMotion: Z = !1,
    tweenConfig: W = i$,
    ...F
  }, m) => {
    const E = z.useRef(null), u = Oo(0), b = Z$(), k = Vv(), Q = !!(Z || k), S = {
      type: "tween",
      ...Q ? V$ : W
    }, v = Oo(0), G = bi(
      v,
      (q) => q >= b ? -1 : 9999999
    ), w = bi(
      v,
      (q) => q >= b ? "hidden" : "visible"
    ), y = z.useRef({
      onOpenStart: e,
      onOpenEnd: n,
      onCloseStart: l,
      onCloseEnd: a
    });
    L1(() => {
      y.current = {
        onOpenStart: e,
        onOpenEnd: n,
        onCloseStart: l,
        onCloseEnd: a
      };
    }), V && (V = V.map((q) => q > 0 && q <= 1 ? Math.round(q * b) : q < 0 ? b + q : q), console.assert(
      U$(V) || b === 0,
      `Snap points need to be in descending order got: [${V}]`
    ));
    const g = uS((q, { delta: ae }) => {
      const se = v.getVelocity();
      se > 0 && u.set(10), se < 0 && u.set(-10), v.set(Math.max(v.get() + ae.y, 0));
    }), f = uS((q, { velocity: ae }) => {
      if (ae.y > s$)
        t();
      else {
        const le = E.current.getBoundingClientRect().height, L = v.get();
        let $ = 0;
        if (V) {
          const re = V.map(
            (te) => le - Math.min(te, le)
          );
          N === "content-height" && !re.includes(0) && re.unshift(0), $ = FS(re, L);
        } else
          L / le > c$ && ($ = le);
        if ($ = mS({ snapTo: $, sheetHeight: le }), OR(v, $, S), V && d) {
          const re = Math.abs(Math.round(V[0] - $)), te = V.indexOf(FS(V, re));
          d(te);
        }
        const ee = Math.round(le);
        $ >= ee && t();
      }
      u.set(0);
    });
    z.useEffect(() => {
      if (!V || !d)
        return;
      const q = c ? R : V.length - 1;
      d(q);
    }, [c]), z.useImperativeHandle(m, () => ({
      y: v,
      snapTo: (q) => {
        const ae = E.current;
        if (V && V[q] !== void 0 && ae !== null) {
          const se = ae.getBoundingClientRect().height, le = V[q], L = mS({
            snapTo: se - le,
            sheetHeight: se
          });
          OR(v, L, S), d && d(q), L >= se && t();
        }
      }
    })), R$(c, s), m$({ isDisabled: i === !0 || !c });
    const I = z.useMemo(() => h ? void 0 : {
      drag: "y",
      dragElastic: 0,
      dragMomentum: !1,
      dragPropagation: !1,
      onDrag: g,
      onDragEnd: f
    }, [h]), K = {
      y: v,
      sheetRef: E,
      isOpen: c,
      initialSnap: R,
      snapPoints: V,
      detent: N,
      indicatorRotation: u,
      callbacks: y,
      dragProps: I,
      windowHeight: b,
      animationOptions: S,
      reduceMotion: Q,
      disableDrag: h
    }, Ue = /* @__PURE__ */ Y.jsx(Yv.Provider, { value: K, children: /* @__PURE__ */ Y.jsx(
      Cl.div,
      {
        ...F,
        ref: m,
        style: { ...Mr.wrapper, zIndex: G, visibility: w, ...U },
        children: /* @__PURE__ */ Y.jsx(dv, { children: c ? /* @__PURE__ */ Y.jsx(F$, { children: z.Children.map(
          r,
          (q, ae) => z.cloneElement(q, { key: `sheet-child-${ae}` })
        ) }) : null })
      }
    ) });
    return Sv ? Ue : tk.createPortal(Ue, o ?? document.body);
  }
), E$ = z.forwardRef(
  ({ children: e, style: n = {}, className: t = "", ...l }, a) => {
    const {
      y: d,
      isOpen: r,
      callbacks: i,
      snapPoints: c,
      initialSnap: V = 0,
      sheetRef: s,
      windowHeight: o,
      detent: U,
      animationOptions: N,
      reduceMotion: R
    } = yh(), { handleAnimationComplete: h } = h$(r, i), Z = c ? c[0] - c[V] : 0, W = c ? c[0] : null, F = W !== null ? `min(${W}px, ${TS})` : TS;
    return /* @__PURE__ */ Y.jsx(
      Cl.div,
      {
        ...l,
        ref: I1([s, a]),
        className: `react-modal-sheet-container ${t}`,
        style: {
          ...Mr.container,
          ...n,
          ...U === "full-height" && { height: F },
          ...U === "content-height" && { maxHeight: F },
          y: d
        },
        initial: R ? !1 : { y: o },
        animate: { y: Z, transition: N },
        exit: { y: o, transition: N },
        onAnimationComplete: h,
        children: e
      }
    );
  }
), S$ = z.forwardRef(
  ({ children: e, style: n, disableDrag: t, className: l = "", ...a }, d) => {
    const r = yh(), i = Jv(), { constraintsRef: c, onMeasureDragConstraints: V } = bv(), s = t || i.disableDrag ? void 0 : r.dragProps;
    return /* @__PURE__ */ Y.jsx(
      Cl.div,
      {
        ...a,
        ref: I1([d, c]),
        className: `react-modal-sheet-content ${l}`,
        style: { ...Mr.content, ...n },
        ...s,
        dragConstraints: c,
        onMeasureDragConstraints: V,
        children: e
      }
    );
  }
), k$ = z.forwardRef(
  ({ children: e, style: n, disableDrag: t, ...l }, a) => {
    const { indicatorRotation: d, dragProps: r } = yh(), { constraintsRef: i, onMeasureDragConstraints: c } = bv(), V = t ? void 0 : r, s = bi(
      d,
      (U) => `translateX(2px) rotate(${U}deg)`
    ), o = bi(
      d,
      (U) => `translateX(-2px) rotate(${-1 * U}deg)`
    );
    return /* @__PURE__ */ Y.jsx(
      Cl.div,
      {
        ...l,
        ref: I1([a, i]),
        style: { ...Mr.headerWrapper, ...n },
        ...V,
        dragConstraints: i,
        onMeasureDragConstraints: c,
        children: e || /* @__PURE__ */ Y.jsxs("div", { className: "react-modal-sheet-header", style: Mr.header, children: [
          /* @__PURE__ */ Y.jsx(
            Cl.span,
            {
              className: "react-modal-sheet-drag-indicator",
              style: { ...Mr.indicator, transform: s }
            }
          ),
          /* @__PURE__ */ Y.jsx(
            Cl.span,
            {
              className: "react-modal-sheet-drag-indicator",
              style: { ...Mr.indicator, transform: o }
            }
          )
        ] })
      }
    );
  }
), ES = (e) => !!e.onClick || !!e.onTap, b$ = z.forwardRef(
  ({ style: e = {}, className: n = "", ...t }, l) => {
    const a = ES(t) ? Cl.button : Cl.div, d = ES(t) ? "auto" : "none";
    return /* @__PURE__ */ Y.jsx(
      a,
      {
        ...t,
        ref: l,
        className: `react-modal-sheet-backdrop ${n}`,
        style: { ...Mr.backdrop, ...e, pointerEvents: d },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 }
      }
    );
  }
), Y$ = z.forwardRef(
  ({ draggableAt: e = "top", children: n, style: t, className: l = "", ...a }, d) => {
    const r = Jv();
    function i(o) {
      const { scrollTop: U, scrollHeight: N, clientHeight: R } = o;
      if (!(N > R))
        return;
      const Z = U <= 0, W = N - U === R;
      e === "top" && Z || e === "bottom" && W || e === "both" && (Z || W) ? r.setDragEnabled() : r.setDragDisabled();
    }
    function c(o) {
      i(o.currentTarget);
    }
    function V(o) {
      i(o.currentTarget);
    }
    const s = N$() ? { onScroll: c, onTouchStart: V } : void 0;
    return /* @__PURE__ */ Y.jsx(
      "div",
      {
        ...a,
        ref: d,
        className: `react-modal-sheet-scroller ${l}`,
        style: { ...Mr.scroller, ...t },
        ...s,
        children: n
      }
    );
  }
), nr = M$;
nr.Container = E$;
nr.Header = k$;
nr.Content = S$;
nr.Backdrop = b$;
nr.Scroller = Y$;
const Q$ = A(nr.Container)`
  padding-bottom: 16px;
  border-radius: 15px 15px 0 0 !important;
`, J$ = A(nr.Header)`
  display: flex;
  justify-content: space-between;
  width: auto;
  padding: 26px 20px 18px 16px;
  margin-bottom: 8px;
`, v$ = A(nr.Content)``, z$ = A(Fe)`
  font-weight: 700;
`, x$ = A(Fe)`
  font-weight: 500;
  white-space: normal;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
`, G$ = ({
  historyList: e,
  bottomSheetOpen: n,
  setBottomSheetOpen: t
}) => {
  var r;
  function l(i) {
    return i.items.length === 1 ? i.items[0].name : `${i.items[0].name} and ${i.items.length - 1} other items`;
  }
  const a = Ji(), d = (i) => {
    a(`Details for Order #${i}`), t(!1);
  };
  return /* @__PURE__ */ Y.jsxs(
    nr,
    {
      detent: "content-height",
      mountPoint: (r = document.getElementsByClassName(
        "sendbird-conversation"
      )) == null ? void 0 : r[0],
      rootId: "chat-window",
      isOpen: e.length > 0 && n,
      onClose: () => {
        t(!1);
      },
      children: [
        /* @__PURE__ */ Y.jsxs(Q$, { children: [
          /* @__PURE__ */ Y.jsxs(J$, { children: [
            /* @__PURE__ */ Y.jsx(Fe, { type: oe.H_2, children: "Order history" }),
            /* @__PURE__ */ Y.jsx(
              r$,
              {
                onClick: () => {
                  t(!1);
                }
              }
            )
          ] }),
          /* @__PURE__ */ Y.jsx(v$, { children: e.length > 0 && e.slice(0, 4).map((i) => /* @__PURE__ */ Y.jsx(
            "div",
            {
              style: {
                padding: "8px 16px",
                cursor: "pointer"
              },
              onClick: () => d(i.id),
              role: "button",
              tabIndex: 0,
              onKeyDown: (c) => {
                (c.key === "Enter" || c.key === " ") && d(i.id);
              },
              children: /* @__PURE__ */ Y.jsx(
                Cc,
                {
                  icon: /* @__PURE__ */ Y.jsx(
                    mh,
                    {
                      image: i.items[0].image,
                      width: 44,
                      height: 44
                    }
                  ),
                  title: /* @__PURE__ */ Y.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        flexDirection: "row",
                        alignItems: "center",
                        justifyContent: "space-between"
                      },
                      children: [
                        /* @__PURE__ */ Y.jsxs(
                          "div",
                          {
                            style: {
                              width: 269
                            },
                            children: [
                              /* @__PURE__ */ Y.jsx(
                                "div",
                                {
                                  style: {
                                    width: 150
                                  },
                                  children: /* @__PURE__ */ Y.jsx(
                                    z$,
                                    {
                                      type: oe.BODY_2,
                                      color: ie.ONBACKGROUND_2,
                                      children: i.date
                                    }
                                  )
                                }
                              ),
                              /* @__PURE__ */ Y.jsx(
                                x$,
                                {
                                  type: oe.BODY_1,
                                  color: ie.ONBACKGROUND_1,
                                  children: l(i)
                                }
                              ),
                              /* @__PURE__ */ Y.jsx(Mv, { history: i })
                            ]
                          }
                        ),
                        /* @__PURE__ */ Y.jsx(
                          "div",
                          {
                            style: {
                              width: 14
                            },
                            children: /* @__PURE__ */ Y.jsx(
                              Ev,
                              {
                                style: {
                                  width: 14,
                                  height: 14
                                }
                              }
                            )
                          }
                        )
                      ]
                    }
                  )
                },
                i.id
              )
            },
            i.id
          )) })
        ] }),
        /* @__PURE__ */ Y.jsx(nr.Backdrop, {})
      ]
    }
  );
}, y$ = A.div`
  display: flex;
  flex-direction: column;
  width: 244px;
  font-family: var(--sendbird-font-family-custom);
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 16px;
  padding: 6px 12px;
`, B$ = A.div`
  display: flex;
  flex-direction: column;
  width: 244px;
  font-family: var(--sendbird-font-family-custom);
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 16px;
`, D$ = A.div`
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 16px;
  padding: 6px 12px 12px;
`, X$ = A(Ql)`
  width: 100%;
  border-radius: 18px;
  height: 36px;

  &:hover {
    background-color: #44712f !important;
  }
`, O$ = A(Fe)`
  margin: 10px 20px;
`, j$ = A(Fe)`
  font-weight: 700;
`, H$ = A(Fe)`
  font-weight: 500;
  white-space: normal;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  margin-bottom: 8px;
`, f$ = ({ message: e }) => {
  const n = e == null ? void 0 : e.order_history, [t, l] = me(!1);
  function a(i) {
    return i.items.length === 1 ? i.items[0].name : `${i.items[0].name} and ${i.items.length - 1} other items`;
  }
  const d = Ji(), r = (i) => {
    d(`Details for Order #${i}`);
  };
  return /* @__PURE__ */ Y.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        gap: 4
      },
      children: [
        /* @__PURE__ */ Y.jsx(y$, { children: /* @__PURE__ */ Y.jsx(Fe, { type: oe.BODY_1, color: ie.ONBACKGROUND_1, children: "Here are your recent orders. Select each one to see it in detail." }) }),
        /* @__PURE__ */ Y.jsxs(B$, { children: [
          n.length > 0 && n.slice(0, 3).map((i) => /* @__PURE__ */ Y.jsx(
            "div",
            {
              style: {
                padding: "6px 12px",
                cursor: "pointer"
              },
              onClick: () => r(i.id),
              role: "button",
              tabIndex: 0,
              onKeyDown: (c) => {
                (c.key === "Enter" || c.key === " ") && r(i.id);
              },
              children: /* @__PURE__ */ Y.jsx(
                Cc,
                {
                  icon: /* @__PURE__ */ Y.jsx(
                    mh,
                    {
                      image: i.items[0].image,
                      width: 40,
                      height: 40
                    }
                  ),
                  title: /* @__PURE__ */ Y.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        flexDirection: "row",
                        alignItems: "center",
                        justifyContent: "space-between",
                        width: "100%"
                      },
                      children: [
                        /* @__PURE__ */ Y.jsxs(
                          "div",
                          {
                            style: {
                              width: "150px"
                            },
                            children: [
                              /* @__PURE__ */ Y.jsx(
                                j$,
                                {
                                  type: oe.BODY_2,
                                  color: ie.ONBACKGROUND_2,
                                  children: i.date
                                }
                              ),
                              /* @__PURE__ */ Y.jsx(
                                H$,
                                {
                                  type: oe.BODY_1,
                                  color: ie.ONBACKGROUND_1,
                                  children: a(i)
                                }
                              ),
                              /* @__PURE__ */ Y.jsx(Mv, { history: i })
                            ]
                          }
                        ),
                        /* @__PURE__ */ Y.jsx(Ev, { style: { width: 14, height: 14 } })
                      ]
                    }
                  )
                },
                i.id
              )
            },
            i.id
          )),
          /* @__PURE__ */ Y.jsx(D$, { children: /* @__PURE__ */ Y.jsx(X$, { onClick: () => l(!0), children: /* @__PURE__ */ Y.jsx(
            O$,
            {
              type: oe.BUTTON_2,
              color: ie.ONCONTENT_1,
              children: "See all"
            }
          ) }) }),
          /* @__PURE__ */ Y.jsx(
            G$,
            {
              historyList: n,
              bottomSheetOpen: t,
              setBottomSheetOpen: l
            }
          )
        ] })
      ]
    }
  );
}, w$ = A(Fe)`
  font-weight: 500;
  white-space: normal;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
`, g$ = A(Fe)`
  font-weight: bold;
`, I$ = A(Fe)`
  padding-left: 4px;
  text-decoration: line-through;
  text-decoration-color: var(--sendbird-light-onlight-02);
`, L$ = A.div`
  display: flex;
  overflow-x: hidden;
  cursor: grab;
  gap: 10px;
  padding-top: 8px;
  padding-left: 51px;
  user-select: none;
`, C$ = A.div`
  flex: 0 0 auto;
  width: 160px;
  display: flex;
  background: #ffffff;
  flex-direction: column;
  align-items: center;
  border-radius: 8px;
`, K$ = ({
  message: e
}) => {
  const n = e == null ? void 0 : e.recommend_items, t = Wt(null), [l, a] = me(!1), [d, r] = me(0), [i, c] = me(0), V = (N) => {
    var h;
    a(!0), r(N.pageX);
    const R = ((h = t.current) == null ? void 0 : h.scrollLeft) ?? 0;
    c(R), N.preventDefault();
  }, s = () => {
    a(!1);
  }, o = (N) => {
    if (!l)
      return;
    const R = N.pageX - d, h = i - R;
    t.current && (t.current.scrollLeft = h);
  }, U = (N) => {
    if (!t.current)
      return;
    const { deltaX: R, deltaY: h } = N;
    Math.abs(R) > Math.abs(h) ? (N.preventDefault(), t.current.scrollLeft += R) : (N.preventDefault(), t.current.scrollLeft += h);
  };
  return /* @__PURE__ */ Y.jsx("div", { style: { display: "flex", flexDirection: "column", width: "100%", marginBottom: 12 }, children: /* @__PURE__ */ Y.jsx(
    L$,
    {
      ref: t,
      onMouseDown: V,
      onMouseMove: o,
      onMouseLeave: s,
      onMouseUp: s,
      onWheel: U,
      children: n.map((N) => /* @__PURE__ */ Y.jsxs(C$, { children: [
        /* @__PURE__ */ Y.jsx(
          "img",
          {
            src: N.image,
            alt: N.name,
            style: {
              width: "160px",
              height: "140px",
              borderTopRightRadius: "8px",
              borderTopLeftRadius: "8px",
              objectFit: "cover",
              objectPosition: "center"
            }
          }
        ),
        /* @__PURE__ */ Y.jsxs(
          "div",
          {
            style: {
              padding: "12px",
              display: "flex",
              flexDirection: "column",
              gap: "6px"
            },
            children: [
              /* @__PURE__ */ Y.jsx(
                w$,
                {
                  type: oe.BODY_1,
                  color: ie.ONBACKGROUND_1,
                  children: N.name
                }
              ),
              /* @__PURE__ */ Y.jsxs("div", { children: [
                /* @__PURE__ */ Y.jsxs(
                  g$,
                  {
                    type: oe.SUBTITLE_1,
                    color: ie.ONBACKGROUND_1,
                    children: [
                      "$",
                      N.price
                    ]
                  }
                ),
                N.original && /* @__PURE__ */ Y.jsx(
                  I$,
                  {
                    type: oe.SUBTITLE_2,
                    color: ie.ONBACKGROUND_2,
                    children: N.original
                  }
                )
              ] })
            ]
          }
        )
      ] }, N.name))
    }
  ) });
}, _$ = (e) => /* @__PURE__ */ z.createElement("svg", { width: 80, height: 80, viewBox: "0 0 80 80", fill: "none", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ z.createElement("rect", { width: 80, height: 80, fill: "url(#pattern1)" }), /* @__PURE__ */ z.createElement("defs", null, /* @__PURE__ */ z.createElement("pattern", { id: "pattern1", patternContentUnits: "objectBoundingBox", width: 1, height: 1 }, /* @__PURE__ */ z.createElement("use", { xlinkHref: "#image0_796_33532", transform: "scale(0.00555556)" })), /* @__PURE__ */ z.createElement("image", { id: "image0_796_33532", width: 180, height: 180, xlinkHref: "data:image/png;base64,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" }))), P$ = A.div`
  display: flex;
  flex-direction: column;
  width: 220px;
`, A$ = A.div`
  background-color: var(--sendbird-light-primary-300);
  border-radius: 16px 16px 0 0;
  text-align: center;
  padding: 16px 0;
  display: flex;
  justify-content: center;
`, q$ = A.div`
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 0 0 16px 16px;
  padding: 12px;
`, $$ = ({
  message: e
}) => /* @__PURE__ */ Y.jsxs(P$, { children: [
  /* @__PURE__ */ Y.jsx(A$, { children: /* @__PURE__ */ Y.jsx(_$, {}) }),
  /* @__PURE__ */ Y.jsxs(q$, { children: [
    /* @__PURE__ */ Y.jsx(Fe, { type: oe.CAPTION_1, children: "Success!" }),
    /* @__PURE__ */ Y.jsxs("div", { children: [
      (e == null ? void 0 : e.target_amount) ?? 0,
      " was sent to ",
      e == null ? void 0 : e.recipient
    ] })
  ] })
] }), eee = A.div`
  display: flex;
  flex-direction: column;
  width: 224px;
  border-radius: 16px;
  padding: 16px;
  background-color: var(--sendbird-light-background-50-0);
`, tee = A.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 16px;
`, vv = A(Ql)`
  background-color: rgba(154, 154, 255, 0.3) !important;
  border-radius: 8px;
  width: 106px;
  border: none !important;
  color: var(--sendbird-light-primary-300) !important;
`, nee = A(vv)`
  background-color: rgba(48, 48, 143, 1) !important;;
  margin-left 4px;
`, SS = A(Fe)`
  color: ${({ fontColor: e }) => e ?? "#FFFFFF"};
  opacity: ${({ disabled: e }) => e ? 0.4 : 1};
  font-weight: 500;
`, lee = ({ message: e }) => {
  const [n, t] = me(!1), { inputValue: l } = jn(), a = Ji(), d = (r) => {
    a(r), t(!0);
  };
  return _e(() => {
    t(!1);
  }, [l == null ? void 0 : l.value]), /* @__PURE__ */ Y.jsxs(eee, { children: [
    /* @__PURE__ */ Y.jsxs(Fe, { children: [
      "Send to ",
      (e == null ? void 0 : e.recipient) ?? "Jin Ku"
    ] }),
    /* @__PURE__ */ Y.jsxs(Fe, { type: oe.H_2, children: [
      "Amount: ",
      e == null ? void 0 : e.target_amount
    ] }),
    /* @__PURE__ */ Y.jsxs(tee, { children: [
      /* @__PURE__ */ Y.jsx(
        vv,
        {
          disabled: n,
          onClick: () => {
            d("Cancel");
          },
          children: /* @__PURE__ */ Y.jsx(
            SS,
            {
              fontColor: "var(--sendbird-light-primary-300)",
              disabled: n,
              children: "Cancel"
            }
          )
        }
      ),
      /* @__PURE__ */ Y.jsx(
        nee,
        {
          disabled: n,
          onClick: () => {
            d("Send");
          },
          children: /* @__PURE__ */ Y.jsx(SS, { disabled: n, children: "Send" })
        }
      )
    ] })
  ] });
}, kS = [
  /* @__PURE__ */ Y.jsx(Wv, {}, "1"),
  /* @__PURE__ */ Y.jsx(mv, {}, "2"),
  /* @__PURE__ */ Y.jsx(uv, {}, "3")
], aee = A.div`
  display: flex;
  flex-direction: column;
  width: 220px;
  font-family: var(--sendbird-font-family-custom);
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 16px;
  padding: 12px;
`, dee = A.div`
  background-color: var(--sendbird-light-background-50-0);
  border-radius: 16px;
`, ree = A(Ql)`
  width: 100%;
  border-radius: 8px;
`, iee = A(Fe)`
  font-weight: 500;
`, Vee = ({
  message: e
}) => {
  const n = JSON.parse(
    (e == null ? void 0 : e.transaction_history) ?? "[]"
  ), [t, l] = me(!1), { inputValue: a } = jn();
  return _e(() => {
    l(!1);
  }, [a == null ? void 0 : a.value, a == null ? void 0 : a.id]), /* @__PURE__ */ Y.jsxs(aee, { children: [
    n.length > 0 && n.slice(0, 4).map((d, r) => /* @__PURE__ */ Y.jsx("div", { style: { marginBottom: 16 }, children: /* @__PURE__ */ Y.jsx(
      Cc,
      {
        icon: kS[r % kS.length],
        title: /* @__PURE__ */ Y.jsx(
          iee,
          {
            type: oe.SUBTITLE_1,
            color: ie.PRIMARY,
            children: d.amount
          }
        ),
        description: /* @__PURE__ */ Y.jsx(Fe, { type: oe.CAPTION_3, children: d.description })
      },
      d.transactionId
    ) }, d.transactionId)),
    /* @__PURE__ */ Y.jsx(dee, { children: /* @__PURE__ */ Y.jsx(
      ree,
      {
        onClick: () => {
          l(!0);
        },
        children: /* @__PURE__ */ Y.jsx(
          Fe,
          {
            type: oe.BUTTON_2,
            color: ie.ONCONTENT_1,
            children: "See more"
          }
        )
      }
    ) }),
    /* @__PURE__ */ Y.jsx(
      pv,
      {
        historyList: n,
        bottomSheetOpen: t,
        setBottomSheetOpen: l
      }
    )
  ] });
}, zv = A(Fe)`
  font-size: 11px;
  position: relative;
  bottom: 4px;
`, cee = ({ children: e }) => /* @__PURE__ */ Y.jsx(
  zv,
  {
    className: "sendbird-input-label",
    style: aa`
      margin-bottom: 8px;
    `,
    type: oe.CAPTION_2,
    color: ie.ONBACKGROUND_2,
    children: e
  }
), see = A.div`
  padding-bottom: 12px;
  width: 100%;
  .sendbird-input .sendbird-input__input {
    background-color: #fff;
    border: ${({ hasError: e }) => `solid 1px ${e ? "#DE360B" : "rgba(0, 0, 0, 0.12)"}`};
    &:focus {
      border: ${({ hasError: e }) => e ? "solid 1px #DE360B" : "none"};
      box-shadow: none;
    }
    &:disabled {
      pointer-events: none;
      background-color: #fff;
    }
  }
`, oee = A.input`
  ::placeholder {
    color: rgba(0, 0, 0, 0.38);
  }
`, Uee = A(zv)`
  position: relative;
  top: 0;
  color: #de360b;
`, Nee = A(dt)`
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
`, Ree = A.div`
  position: relative;
`, hee = (e) => {
  const {
    name: n,
    required: t,
    disabled: l,
    hasError: a,
    isValid: d,
    value: r,
    type: i,
    onChange: c,
    placeHolder: V
  } = e;
  return /* @__PURE__ */ Y.jsx(see, { hasError: a, children: /* @__PURE__ */ Y.jsxs("div", { className: "sendbird-input", children: [
    /* @__PURE__ */ Y.jsx(cee, { children: t ? `${n} *` : n }),
    /* @__PURE__ */ Y.jsxs(Ree, { children: [
      /* @__PURE__ */ Y.jsx(
        oee,
        {
          type: i,
          className: "sendbird-input__input",
          name: n,
          required: t,
          disabled: l,
          value: r,
          onChange: c,
          placeholder: l ? "" : V
        }
      ),
      d && /* @__PURE__ */ Y.jsx(
        Nee,
        {
          type: Le.DONE,
          fillColor: Pe.SECONDARY,
          width: "24px",
          height: "24px"
        }
      )
    ] }),
    a && /* @__PURE__ */ Y.jsx(Uee, { type: oe.CAPTION_4, children: "Please check the value" })
  ] }) });
}, Zee = A.div`
  max-width: 244px;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 16px 12px;
  gap: 8px;
  border-radius: 16px;
  ${({ botCategory: e }) => e && aa`
      background-color: ${Sl[e]["--sendbird-light-background-50-0"]};
      }
    `};
`, Tee = A(Ql)`
  width: 100%;
`;
function Fee(e) {
  const {
    message: n,
    form: { fields: t, key: l, data: a }
  } = e, d = {};
  t.forEach(({ key: o, required: U }) => {
    d[o] = {
      value: "",
      required: U,
      hasError: !1,
      isValid: !1
    };
  });
  const [r, i] = me(d), { botCategory: c } = jn();
  _e(() => {
    if (a) {
      const o = {};
      Object.entries(r).forEach(([U, N]) => {
        o[U] = {
          ...N,
          isValid: (a == null ? void 0 : a[U]) != null && a[U] !== ""
        };
      }), i(o);
    }
  }, [a]);
  const V = Pt(async () => {
    try {
      const o = Object.keys(r).filter(
        (R) => r[R].required && r[R].value.length === 0
      );
      if (o.forEach((R) => {
        i((h) => ({
          ...h,
          [R]: { ...h[R], hasError: !0 }
        }));
      }), o.length > 0 || Object.values(r).some(
        ({ hasError: R, required: h }) => h && R
      ))
        return;
      const N = Object.entries(r).reduce(
        (R, [h, { value: Z }]) => ({
          ...R,
          [h]: Z
        }),
        {}
      );
      await n.submitForm({
        formId: l,
        answers: N
      });
    } catch (o) {
      console.error(o);
    }
  }, [r, n.messageId, n.submitForm, l]), s = Object.values(r).filter(({ required: o }) => o).every(({ isValid: o }) => o);
  return /* @__PURE__ */ Y.jsxs(Zee, { botCategory: c, children: [
    t.map(
      ({ title: o, placeholder: U, key: N, required: R, regex: h, input_type: Z }) => /* @__PURE__ */ Y.jsx(
        hee,
        {
          type: Z,
          placeHolder: U,
          hasError: r[N].hasError,
          isValid: r[N].isValid,
          disabled: a != null,
          name: o,
          required: R,
          onChange: (W) => {
            const F = W.target.value, m = h ? h.test(F) : R && F === "";
            i(() => ({
              ...r,
              [N]: { ...r[N], value: F, hasError: m }
            }));
          }
        },
        N
      )
    ),
    !s && /* @__PURE__ */ Y.jsx(Tee, { onClick: V, children: /* @__PURE__ */ Y.jsx(
      Fe,
      {
        type: oe.BUTTON_2,
        color: ie.ONCONTENT_1,
        children: "Submit"
      }
    ) })
  ] });
}
function Wee(e, n) {
  if (e == null)
    return {};
  var t = {}, l = Object.keys(e), a, d;
  for (d = 0; d < l.length; d++)
    a = l[d], !(n.indexOf(a) >= 0) && (t[a] = e[a]);
  return t;
}
function hr() {
  return hr = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var t = arguments[n];
      for (var l in t)
        Object.prototype.hasOwnProperty.call(t, l) && (e[l] = t[l]);
    }
    return e;
  }, hr.apply(this, arguments);
}
var bS = function(n) {
  return n.reduce(function(t, l) {
    var a = l[0], d = l[1];
    return t[a] = d, t;
  }, {});
}, YS = typeof window < "u" && window.document && window.document.createElement ? z.useLayoutEffect : z.useEffect, Za = "top", id = "bottom", Vd = "right", Ta = "left", C1 = "auto", uU = [Za, id, Vd, Ta], Xc = "start", jo = "end", mee = "clippingParents", xv = "viewport", ps = "popper", uee = "reference", QS = /* @__PURE__ */ uU.reduce(function(e, n) {
  return e.concat([n + "-" + Xc, n + "-" + jo]);
}, []), Gv = /* @__PURE__ */ [].concat(uU, [C1]).reduce(function(e, n) {
  return e.concat([n, n + "-" + Xc, n + "-" + jo]);
}, []), pee = "beforeRead", Mee = "read", Eee = "afterRead", See = "beforeMain", kee = "main", bee = "afterMain", Yee = "beforeWrite", Qee = "write", Jee = "afterWrite", vee = [pee, Mee, Eee, See, kee, bee, Yee, Qee, Jee];
function lr(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function fa(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var n = e.ownerDocument;
    return n && n.defaultView || window;
  }
  return e;
}
function JV(e) {
  var n = fa(e).Element;
  return e instanceof n || e instanceof Element;
}
function nd(e) {
  var n = fa(e).HTMLElement;
  return e instanceof n || e instanceof HTMLElement;
}
function K1(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var n = fa(e).ShadowRoot;
  return e instanceof n || e instanceof ShadowRoot;
}
function zee(e) {
  var n = e.state;
  Object.keys(n.elements).forEach(function(t) {
    var l = n.styles[t] || {}, a = n.attributes[t] || {}, d = n.elements[t];
    !nd(d) || !lr(d) || (Object.assign(d.style, l), Object.keys(a).forEach(function(r) {
      var i = a[r];
      i === !1 ? d.removeAttribute(r) : d.setAttribute(r, i === !0 ? "" : i);
    }));
  });
}
function xee(e) {
  var n = e.state, t = {
    popper: {
      position: n.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(n.elements.popper.style, t.popper), n.styles = t, n.elements.arrow && Object.assign(n.elements.arrow.style, t.arrow), function() {
    Object.keys(n.elements).forEach(function(l) {
      var a = n.elements[l], d = n.attributes[l] || {}, r = Object.keys(n.styles.hasOwnProperty(l) ? n.styles[l] : t[l]), i = r.reduce(function(c, V) {
        return c[V] = "", c;
      }, {});
      !nd(a) || !lr(a) || (Object.assign(a.style, i), Object.keys(d).forEach(function(c) {
        a.removeAttribute(c);
      }));
    });
  };
}
const Gee = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: zee,
  effect: xee,
  requires: ["computeStyles"]
};
function qd(e) {
  return e.split("-")[0];
}
var MV = Math.max, jR = Math.min, Oc = Math.round;
function VW() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(n) {
    return n.brand + "/" + n.version;
  }).join(" ") : navigator.userAgent;
}
function yv() {
  return !/^((?!chrome|android).)*safari/i.test(VW());
}
function jc(e, n, t) {
  n === void 0 && (n = !1), t === void 0 && (t = !1);
  var l = e.getBoundingClientRect(), a = 1, d = 1;
  n && nd(e) && (a = e.offsetWidth > 0 && Oc(l.width) / e.offsetWidth || 1, d = e.offsetHeight > 0 && Oc(l.height) / e.offsetHeight || 1);
  var r = JV(e) ? fa(e) : window, i = r.visualViewport, c = !yv() && t, V = (l.left + (c && i ? i.offsetLeft : 0)) / a, s = (l.top + (c && i ? i.offsetTop : 0)) / d, o = l.width / a, U = l.height / d;
  return {
    width: o,
    height: U,
    top: s,
    right: V + o,
    bottom: s + U,
    left: V,
    x: V,
    y: s
  };
}
function _1(e) {
  var n = jc(e), t = e.offsetWidth, l = e.offsetHeight;
  return Math.abs(n.width - t) <= 1 && (t = n.width), Math.abs(n.height - l) <= 1 && (l = n.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: t,
    height: l
  };
}
function Bv(e, n) {
  var t = n.getRootNode && n.getRootNode();
  if (e.contains(n))
    return !0;
  if (t && K1(t)) {
    var l = n;
    do {
      if (l && e.isSameNode(l))
        return !0;
      l = l.parentNode || l.host;
    } while (l);
  }
  return !1;
}
function Gr(e) {
  return fa(e).getComputedStyle(e);
}
function yee(e) {
  return ["table", "td", "th"].indexOf(lr(e)) >= 0;
}
function zi(e) {
  return ((JV(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function Bh(e) {
  return lr(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (K1(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    zi(e)
  );
}
function JS(e) {
  return !nd(e) || // https://github.com/popperjs/popper-core/issues/837
  Gr(e).position === "fixed" ? null : e.offsetParent;
}
function Bee(e) {
  var n = /firefox/i.test(VW()), t = /Trident/i.test(VW());
  if (t && nd(e)) {
    var l = Gr(e);
    if (l.position === "fixed")
      return null;
  }
  var a = Bh(e);
  for (K1(a) && (a = a.host); nd(a) && ["html", "body"].indexOf(lr(a)) < 0; ) {
    var d = Gr(a);
    if (d.transform !== "none" || d.perspective !== "none" || d.contain === "paint" || ["transform", "perspective"].indexOf(d.willChange) !== -1 || n && d.willChange === "filter" || n && d.filter && d.filter !== "none")
      return a;
    a = a.parentNode;
  }
  return null;
}
function pU(e) {
  for (var n = fa(e), t = JS(e); t && yee(t) && Gr(t).position === "static"; )
    t = JS(t);
  return t && (lr(t) === "html" || lr(t) === "body" && Gr(t).position === "static") ? n : t || Bee(e) || n;
}
function P1(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Uo(e, n, t) {
  return MV(e, jR(n, t));
}
function Dee(e, n, t) {
  var l = Uo(e, n, t);
  return l > t ? t : l;
}
function Dv() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Xv(e) {
  return Object.assign({}, Dv(), e);
}
function Ov(e, n) {
  return n.reduce(function(t, l) {
    return t[l] = e, t;
  }, {});
}
var Xee = function(n, t) {
  return n = typeof n == "function" ? n(Object.assign({}, t.rects, {
    placement: t.placement
  })) : n, Xv(typeof n != "number" ? n : Ov(n, uU));
};
function Oee(e) {
  var n, t = e.state, l = e.name, a = e.options, d = t.elements.arrow, r = t.modifiersData.popperOffsets, i = qd(t.placement), c = P1(i), V = [Ta, Vd].indexOf(i) >= 0, s = V ? "height" : "width";
  if (!(!d || !r)) {
    var o = Xee(a.padding, t), U = _1(d), N = c === "y" ? Za : Ta, R = c === "y" ? id : Vd, h = t.rects.reference[s] + t.rects.reference[c] - r[c] - t.rects.popper[s], Z = r[c] - t.rects.reference[c], W = pU(d), F = W ? c === "y" ? W.clientHeight || 0 : W.clientWidth || 0 : 0, m = h / 2 - Z / 2, E = o[N], u = F - U[s] - o[R], b = F / 2 - U[s] / 2 + m, k = Uo(E, b, u), Q = c;
    t.modifiersData[l] = (n = {}, n[Q] = k, n.centerOffset = k - b, n);
  }
}
function jee(e) {
  var n = e.state, t = e.options, l = t.element, a = l === void 0 ? "[data-popper-arrow]" : l;
  a != null && (typeof a == "string" && (a = n.elements.popper.querySelector(a), !a) || Bv(n.elements.popper, a) && (n.elements.arrow = a));
}
const Hee = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Oee,
  effect: jee,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Hc(e) {
  return e.split("-")[1];
}
var fee = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function wee(e, n) {
  var t = e.x, l = e.y, a = n.devicePixelRatio || 1;
  return {
    x: Oc(t * a) / a || 0,
    y: Oc(l * a) / a || 0
  };
}
function vS(e) {
  var n, t = e.popper, l = e.popperRect, a = e.placement, d = e.variation, r = e.offsets, i = e.position, c = e.gpuAcceleration, V = e.adaptive, s = e.roundOffsets, o = e.isFixed, U = r.x, N = U === void 0 ? 0 : U, R = r.y, h = R === void 0 ? 0 : R, Z = typeof s == "function" ? s({
    x: N,
    y: h
  }) : {
    x: N,
    y: h
  };
  N = Z.x, h = Z.y;
  var W = r.hasOwnProperty("x"), F = r.hasOwnProperty("y"), m = Ta, E = Za, u = window;
  if (V) {
    var b = pU(t), k = "clientHeight", Q = "clientWidth";
    if (b === fa(t) && (b = zi(t), Gr(b).position !== "static" && i === "absolute" && (k = "scrollHeight", Q = "scrollWidth")), b = b, a === Za || (a === Ta || a === Vd) && d === jo) {
      E = id;
      var S = o && b === u && u.visualViewport ? u.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        b[k]
      );
      h -= S - l.height, h *= c ? 1 : -1;
    }
    if (a === Ta || (a === Za || a === id) && d === jo) {
      m = Vd;
      var v = o && b === u && u.visualViewport ? u.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        b[Q]
      );
      N -= v - l.width, N *= c ? 1 : -1;
    }
  }
  var G = Object.assign({
    position: i
  }, V && fee), w = s === !0 ? wee({
    x: N,
    y: h
  }, fa(t)) : {
    x: N,
    y: h
  };
  if (N = w.x, h = w.y, c) {
    var y;
    return Object.assign({}, G, (y = {}, y[E] = F ? "0" : "", y[m] = W ? "0" : "", y.transform = (u.devicePixelRatio || 1) <= 1 ? "translate(" + N + "px, " + h + "px)" : "translate3d(" + N + "px, " + h + "px, 0)", y));
  }
  return Object.assign({}, G, (n = {}, n[E] = F ? h + "px" : "", n[m] = W ? N + "px" : "", n.transform = "", n));
}
function gee(e) {
  var n = e.state, t = e.options, l = t.gpuAcceleration, a = l === void 0 ? !0 : l, d = t.adaptive, r = d === void 0 ? !0 : d, i = t.roundOffsets, c = i === void 0 ? !0 : i, V = {
    placement: qd(n.placement),
    variation: Hc(n.placement),
    popper: n.elements.popper,
    popperRect: n.rects.popper,
    gpuAcceleration: a,
    isFixed: n.options.strategy === "fixed"
  };
  n.modifiersData.popperOffsets != null && (n.styles.popper = Object.assign({}, n.styles.popper, vS(Object.assign({}, V, {
    offsets: n.modifiersData.popperOffsets,
    position: n.options.strategy,
    adaptive: r,
    roundOffsets: c
  })))), n.modifiersData.arrow != null && (n.styles.arrow = Object.assign({}, n.styles.arrow, vS(Object.assign({}, V, {
    offsets: n.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: c
  })))), n.attributes.popper = Object.assign({}, n.attributes.popper, {
    "data-popper-placement": n.placement
  });
}
const Iee = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: gee,
  data: {}
};
var WN = {
  passive: !0
};
function Lee(e) {
  var n = e.state, t = e.instance, l = e.options, a = l.scroll, d = a === void 0 ? !0 : a, r = l.resize, i = r === void 0 ? !0 : r, c = fa(n.elements.popper), V = [].concat(n.scrollParents.reference, n.scrollParents.popper);
  return d && V.forEach(function(s) {
    s.addEventListener("scroll", t.update, WN);
  }), i && c.addEventListener("resize", t.update, WN), function() {
    d && V.forEach(function(s) {
      s.removeEventListener("scroll", t.update, WN);
    }), i && c.removeEventListener("resize", t.update, WN);
  };
}
const Cee = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Lee,
  data: {}
};
var Kee = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function wN(e) {
  return e.replace(/left|right|bottom|top/g, function(n) {
    return Kee[n];
  });
}
var _ee = {
  start: "end",
  end: "start"
};
function zS(e) {
  return e.replace(/start|end/g, function(n) {
    return _ee[n];
  });
}
function A1(e) {
  var n = fa(e), t = n.pageXOffset, l = n.pageYOffset;
  return {
    scrollLeft: t,
    scrollTop: l
  };
}
function q1(e) {
  return jc(zi(e)).left + A1(e).scrollLeft;
}
function Pee(e, n) {
  var t = fa(e), l = zi(e), a = t.visualViewport, d = l.clientWidth, r = l.clientHeight, i = 0, c = 0;
  if (a) {
    d = a.width, r = a.height;
    var V = yv();
    (V || !V && n === "fixed") && (i = a.offsetLeft, c = a.offsetTop);
  }
  return {
    width: d,
    height: r,
    x: i + q1(e),
    y: c
  };
}
function Aee(e) {
  var n, t = zi(e), l = A1(e), a = (n = e.ownerDocument) == null ? void 0 : n.body, d = MV(t.scrollWidth, t.clientWidth, a ? a.scrollWidth : 0, a ? a.clientWidth : 0), r = MV(t.scrollHeight, t.clientHeight, a ? a.scrollHeight : 0, a ? a.clientHeight : 0), i = -l.scrollLeft + q1(e), c = -l.scrollTop;
  return Gr(a || t).direction === "rtl" && (i += MV(t.clientWidth, a ? a.clientWidth : 0) - d), {
    width: d,
    height: r,
    x: i,
    y: c
  };
}
function $1(e) {
  var n = Gr(e), t = n.overflow, l = n.overflowX, a = n.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + a + l);
}
function jv(e) {
  return ["html", "body", "#document"].indexOf(lr(e)) >= 0 ? e.ownerDocument.body : nd(e) && $1(e) ? e : jv(Bh(e));
}
function No(e, n) {
  var t;
  n === void 0 && (n = []);
  var l = jv(e), a = l === ((t = e.ownerDocument) == null ? void 0 : t.body), d = fa(l), r = a ? [d].concat(d.visualViewport || [], $1(l) ? l : []) : l, i = n.concat(r);
  return a ? i : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    i.concat(No(Bh(r)))
  );
}
function cW(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function qee(e, n) {
  var t = jc(e, !1, n === "fixed");
  return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t;
}
function xS(e, n, t) {
  return n === xv ? cW(Pee(e, t)) : JV(n) ? qee(n, t) : cW(Aee(zi(e)));
}
function $ee(e) {
  var n = No(Bh(e)), t = ["absolute", "fixed"].indexOf(Gr(e).position) >= 0, l = t && nd(e) ? pU(e) : e;
  return JV(l) ? n.filter(function(a) {
    return JV(a) && Bv(a, l) && lr(a) !== "body";
  }) : [];
}
function ete(e, n, t, l) {
  var a = n === "clippingParents" ? $ee(e) : [].concat(n), d = [].concat(a, [t]), r = d[0], i = d.reduce(function(c, V) {
    var s = xS(e, V, l);
    return c.top = MV(s.top, c.top), c.right = jR(s.right, c.right), c.bottom = jR(s.bottom, c.bottom), c.left = MV(s.left, c.left), c;
  }, xS(e, r, l));
  return i.width = i.right - i.left, i.height = i.bottom - i.top, i.x = i.left, i.y = i.top, i;
}
function Hv(e) {
  var n = e.reference, t = e.element, l = e.placement, a = l ? qd(l) : null, d = l ? Hc(l) : null, r = n.x + n.width / 2 - t.width / 2, i = n.y + n.height / 2 - t.height / 2, c;
  switch (a) {
    case Za:
      c = {
        x: r,
        y: n.y - t.height
      };
      break;
    case id:
      c = {
        x: r,
        y: n.y + n.height
      };
      break;
    case Vd:
      c = {
        x: n.x + n.width,
        y: i
      };
      break;
    case Ta:
      c = {
        x: n.x - t.width,
        y: i
      };
      break;
    default:
      c = {
        x: n.x,
        y: n.y
      };
  }
  var V = a ? P1(a) : null;
  if (V != null) {
    var s = V === "y" ? "height" : "width";
    switch (d) {
      case Xc:
        c[V] = c[V] - (n[s] / 2 - t[s] / 2);
        break;
      case jo:
        c[V] = c[V] + (n[s] / 2 - t[s] / 2);
        break;
    }
  }
  return c;
}
function Ho(e, n) {
  n === void 0 && (n = {});
  var t = n, l = t.placement, a = l === void 0 ? e.placement : l, d = t.strategy, r = d === void 0 ? e.strategy : d, i = t.boundary, c = i === void 0 ? mee : i, V = t.rootBoundary, s = V === void 0 ? xv : V, o = t.elementContext, U = o === void 0 ? ps : o, N = t.altBoundary, R = N === void 0 ? !1 : N, h = t.padding, Z = h === void 0 ? 0 : h, W = Xv(typeof Z != "number" ? Z : Ov(Z, uU)), F = U === ps ? uee : ps, m = e.rects.popper, E = e.elements[R ? F : U], u = ete(JV(E) ? E : E.contextElement || zi(e.elements.popper), c, s, r), b = jc(e.elements.reference), k = Hv({
    reference: b,
    element: m,
    strategy: "absolute",
    placement: a
  }), Q = cW(Object.assign({}, m, k)), S = U === ps ? Q : b, v = {
    top: u.top - S.top + W.top,
    bottom: S.bottom - u.bottom + W.bottom,
    left: u.left - S.left + W.left,
    right: S.right - u.right + W.right
  }, G = e.modifiersData.offset;
  if (U === ps && G) {
    var w = G[a];
    Object.keys(v).forEach(function(y) {
      var g = [Vd, id].indexOf(y) >= 0 ? 1 : -1, f = [Za, id].indexOf(y) >= 0 ? "y" : "x";
      v[y] += w[f] * g;
    });
  }
  return v;
}
function tte(e, n) {
  n === void 0 && (n = {});
  var t = n, l = t.placement, a = t.boundary, d = t.rootBoundary, r = t.padding, i = t.flipVariations, c = t.allowedAutoPlacements, V = c === void 0 ? Gv : c, s = Hc(l), o = s ? i ? QS : QS.filter(function(R) {
    return Hc(R) === s;
  }) : uU, U = o.filter(function(R) {
    return V.indexOf(R) >= 0;
  });
  U.length === 0 && (U = o);
  var N = U.reduce(function(R, h) {
    return R[h] = Ho(e, {
      placement: h,
      boundary: a,
      rootBoundary: d,
      padding: r
    })[qd(h)], R;
  }, {});
  return Object.keys(N).sort(function(R, h) {
    return N[R] - N[h];
  });
}
function nte(e) {
  if (qd(e) === C1)
    return [];
  var n = wN(e);
  return [zS(e), n, zS(n)];
}
function lte(e) {
  var n = e.state, t = e.options, l = e.name;
  if (!n.modifiersData[l]._skip) {
    for (var a = t.mainAxis, d = a === void 0 ? !0 : a, r = t.altAxis, i = r === void 0 ? !0 : r, c = t.fallbackPlacements, V = t.padding, s = t.boundary, o = t.rootBoundary, U = t.altBoundary, N = t.flipVariations, R = N === void 0 ? !0 : N, h = t.allowedAutoPlacements, Z = n.options.placement, W = qd(Z), F = W === Z, m = c || (F || !R ? [wN(Z)] : nte(Z)), E = [Z].concat(m).reduce(function($, ee) {
      return $.concat(qd(ee) === C1 ? tte(n, {
        placement: ee,
        boundary: s,
        rootBoundary: o,
        padding: V,
        flipVariations: R,
        allowedAutoPlacements: h
      }) : ee);
    }, []), u = n.rects.reference, b = n.rects.popper, k = /* @__PURE__ */ new Map(), Q = !0, S = E[0], v = 0; v < E.length; v++) {
      var G = E[v], w = qd(G), y = Hc(G) === Xc, g = [Za, id].indexOf(w) >= 0, f = g ? "width" : "height", I = Ho(n, {
        placement: G,
        boundary: s,
        rootBoundary: o,
        altBoundary: U,
        padding: V
      }), K = g ? y ? Vd : Ta : y ? id : Za;
      u[f] > b[f] && (K = wN(K));
      var Ue = wN(K), q = [];
      if (d && q.push(I[w] <= 0), i && q.push(I[K] <= 0, I[Ue] <= 0), q.every(function($) {
        return $;
      })) {
        S = G, Q = !1;
        break;
      }
      k.set(G, q);
    }
    if (Q)
      for (var ae = R ? 3 : 1, se = function(ee) {
        var O = E.find(function(re) {
          var te = k.get(re);
          if (te)
            return te.slice(0, ee).every(function(Qe) {
              return Qe;
            });
        });
        if (O)
          return S = O, "break";
      }, le = ae; le > 0; le--) {
        var L = se(le);
        if (L === "break")
          break;
      }
    n.placement !== S && (n.modifiersData[l]._skip = !0, n.placement = S, n.reset = !0);
  }
}
const ate = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: lte,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function GS(e, n, t) {
  return t === void 0 && (t = {
    x: 0,
    y: 0
  }), {
    top: e.top - n.height - t.y,
    right: e.right - n.width + t.x,
    bottom: e.bottom - n.height + t.y,
    left: e.left - n.width - t.x
  };
}
function yS(e) {
  return [Za, Vd, id, Ta].some(function(n) {
    return e[n] >= 0;
  });
}
function dte(e) {
  var n = e.state, t = e.name, l = n.rects.reference, a = n.rects.popper, d = n.modifiersData.preventOverflow, r = Ho(n, {
    elementContext: "reference"
  }), i = Ho(n, {
    altBoundary: !0
  }), c = GS(r, l), V = GS(i, a, d), s = yS(c), o = yS(V);
  n.modifiersData[t] = {
    referenceClippingOffsets: c,
    popperEscapeOffsets: V,
    isReferenceHidden: s,
    hasPopperEscaped: o
  }, n.attributes.popper = Object.assign({}, n.attributes.popper, {
    "data-popper-reference-hidden": s,
    "data-popper-escaped": o
  });
}
const rte = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: dte
};
function ite(e, n, t) {
  var l = qd(e), a = [Ta, Za].indexOf(l) >= 0 ? -1 : 1, d = typeof t == "function" ? t(Object.assign({}, n, {
    placement: e
  })) : t, r = d[0], i = d[1];
  return r = r || 0, i = (i || 0) * a, [Ta, Vd].indexOf(l) >= 0 ? {
    x: i,
    y: r
  } : {
    x: r,
    y: i
  };
}
function Vte(e) {
  var n = e.state, t = e.options, l = e.name, a = t.offset, d = a === void 0 ? [0, 0] : a, r = Gv.reduce(function(s, o) {
    return s[o] = ite(o, n.rects, d), s;
  }, {}), i = r[n.placement], c = i.x, V = i.y;
  n.modifiersData.popperOffsets != null && (n.modifiersData.popperOffsets.x += c, n.modifiersData.popperOffsets.y += V), n.modifiersData[l] = r;
}
const cte = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Vte
};
function ste(e) {
  var n = e.state, t = e.name;
  n.modifiersData[t] = Hv({
    reference: n.rects.reference,
    element: n.rects.popper,
    strategy: "absolute",
    placement: n.placement
  });
}
const ote = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: ste,
  data: {}
};
function Ute(e) {
  return e === "x" ? "y" : "x";
}
function Nte(e) {
  var n = e.state, t = e.options, l = e.name, a = t.mainAxis, d = a === void 0 ? !0 : a, r = t.altAxis, i = r === void 0 ? !1 : r, c = t.boundary, V = t.rootBoundary, s = t.altBoundary, o = t.padding, U = t.tether, N = U === void 0 ? !0 : U, R = t.tetherOffset, h = R === void 0 ? 0 : R, Z = Ho(n, {
    boundary: c,
    rootBoundary: V,
    padding: o,
    altBoundary: s
  }), W = qd(n.placement), F = Hc(n.placement), m = !F, E = P1(W), u = Ute(E), b = n.modifiersData.popperOffsets, k = n.rects.reference, Q = n.rects.popper, S = typeof h == "function" ? h(Object.assign({}, n.rects, {
    placement: n.placement
  })) : h, v = typeof S == "number" ? {
    mainAxis: S,
    altAxis: S
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, S), G = n.modifiersData.offset ? n.modifiersData.offset[n.placement] : null, w = {
    x: 0,
    y: 0
  };
  if (b) {
    if (d) {
      var y, g = E === "y" ? Za : Ta, f = E === "y" ? id : Vd, I = E === "y" ? "height" : "width", K = b[E], Ue = K + Z[g], q = K - Z[f], ae = N ? -Q[I] / 2 : 0, se = F === Xc ? k[I] : Q[I], le = F === Xc ? -Q[I] : -k[I], L = n.elements.arrow, $ = N && L ? _1(L) : {
        width: 0,
        height: 0
      }, ee = n.modifiersData["arrow#persistent"] ? n.modifiersData["arrow#persistent"].padding : Dv(), O = ee[g], re = ee[f], te = Uo(0, k[I], $[I]), Qe = m ? k[I] / 2 - ae - te - O - v.mainAxis : se - te - O - v.mainAxis, Ye = m ? -k[I] / 2 + ae + te + re + v.mainAxis : le + te + re + v.mainAxis, Se = n.elements.arrow && pU(n.elements.arrow), P = Se ? E === "y" ? Se.clientTop || 0 : Se.clientLeft || 0 : 0, ge = (y = G == null ? void 0 : G[E]) != null ? y : 0, Me = K + Qe - ge - P, We = K + Ye - ge, De = Uo(N ? jR(Ue, Me) : Ue, K, N ? MV(q, We) : q);
      b[E] = De, w[E] = De - K;
    }
    if (i) {
      var Oe, tt = E === "x" ? Za : Ta, Be = E === "x" ? id : Vd, He = b[u], at = u === "y" ? "height" : "width", Ge = He + Z[tt], $e = He - Z[Be], fe = [Za, Ta].indexOf(W) !== -1, Xe = (Oe = G == null ? void 0 : G[u]) != null ? Oe : 0, pt = fe ? Ge : He - k[at] - Q[at] - Xe + v.altAxis, Vt = fe ? He + k[at] + Q[at] - Xe - v.altAxis : $e, yt = N && fe ? Dee(pt, He, Vt) : Uo(N ? pt : Ge, He, N ? Vt : $e);
      b[u] = yt, w[u] = yt - He;
    }
    n.modifiersData[l] = w;
  }
}
const Rte = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Nte,
  requiresIfExists: ["offset"]
};
function hte(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function Zte(e) {
  return e === fa(e) || !nd(e) ? A1(e) : hte(e);
}
function Tte(e) {
  var n = e.getBoundingClientRect(), t = Oc(n.width) / e.offsetWidth || 1, l = Oc(n.height) / e.offsetHeight || 1;
  return t !== 1 || l !== 1;
}
function Fte(e, n, t) {
  t === void 0 && (t = !1);
  var l = nd(n), a = nd(n) && Tte(n), d = zi(n), r = jc(e, a, t), i = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = {
    x: 0,
    y: 0
  };
  return (l || !l && !t) && ((lr(n) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  $1(d)) && (i = Zte(n)), nd(n) ? (c = jc(n, !0), c.x += n.clientLeft, c.y += n.clientTop) : d && (c.x = q1(d))), {
    x: r.left + i.scrollLeft - c.x,
    y: r.top + i.scrollTop - c.y,
    width: r.width,
    height: r.height
  };
}
function Wte(e) {
  var n = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), l = [];
  e.forEach(function(d) {
    n.set(d.name, d);
  });
  function a(d) {
    t.add(d.name);
    var r = [].concat(d.requires || [], d.requiresIfExists || []);
    r.forEach(function(i) {
      if (!t.has(i)) {
        var c = n.get(i);
        c && a(c);
      }
    }), l.push(d);
  }
  return e.forEach(function(d) {
    t.has(d.name) || a(d);
  }), l;
}
function mte(e) {
  var n = Wte(e);
  return vee.reduce(function(t, l) {
    return t.concat(n.filter(function(a) {
      return a.phase === l;
    }));
  }, []);
}
function ute(e) {
  var n;
  return function() {
    return n || (n = new Promise(function(t) {
      Promise.resolve().then(function() {
        n = void 0, t(e());
      });
    })), n;
  };
}
function pte(e) {
  var n = e.reduce(function(t, l) {
    var a = t[l.name];
    return t[l.name] = a ? Object.assign({}, a, l, {
      options: Object.assign({}, a.options, l.options),
      data: Object.assign({}, a.data, l.data)
    }) : l, t;
  }, {});
  return Object.keys(n).map(function(t) {
    return n[t];
  });
}
var BS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function DS() {
  for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++)
    n[t] = arguments[t];
  return !n.some(function(l) {
    return !(l && typeof l.getBoundingClientRect == "function");
  });
}
function Mte(e) {
  e === void 0 && (e = {});
  var n = e, t = n.defaultModifiers, l = t === void 0 ? [] : t, a = n.defaultOptions, d = a === void 0 ? BS : a;
  return function(i, c, V) {
    V === void 0 && (V = d);
    var s = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, BS, d),
      modifiersData: {},
      elements: {
        reference: i,
        popper: c
      },
      attributes: {},
      styles: {}
    }, o = [], U = !1, N = {
      state: s,
      setOptions: function(W) {
        var F = typeof W == "function" ? W(s.options) : W;
        h(), s.options = Object.assign({}, d, s.options, F), s.scrollParents = {
          reference: JV(i) ? No(i) : i.contextElement ? No(i.contextElement) : [],
          popper: No(c)
        };
        var m = mte(pte([].concat(l, s.options.modifiers)));
        return s.orderedModifiers = m.filter(function(E) {
          return E.enabled;
        }), R(), N.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!U) {
          var W = s.elements, F = W.reference, m = W.popper;
          if (DS(F, m)) {
            s.rects = {
              reference: Fte(F, pU(m), s.options.strategy === "fixed"),
              popper: _1(m)
            }, s.reset = !1, s.placement = s.options.placement, s.orderedModifiers.forEach(function(v) {
              return s.modifiersData[v.name] = Object.assign({}, v.data);
            });
            for (var E = 0; E < s.orderedModifiers.length; E++) {
              if (s.reset === !0) {
                s.reset = !1, E = -1;
                continue;
              }
              var u = s.orderedModifiers[E], b = u.fn, k = u.options, Q = k === void 0 ? {} : k, S = u.name;
              typeof b == "function" && (s = b({
                state: s,
                options: Q,
                name: S,
                instance: N
              }) || s);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: ute(function() {
        return new Promise(function(Z) {
          N.forceUpdate(), Z(s);
        });
      }),
      destroy: function() {
        h(), U = !0;
      }
    };
    if (!DS(i, c))
      return N;
    N.setOptions(V).then(function(Z) {
      !U && V.onFirstUpdate && V.onFirstUpdate(Z);
    });
    function R() {
      s.orderedModifiers.forEach(function(Z) {
        var W = Z.name, F = Z.options, m = F === void 0 ? {} : F, E = Z.effect;
        if (typeof E == "function") {
          var u = E({
            state: s,
            name: W,
            instance: N,
            options: m
          }), b = function() {
          };
          o.push(u || b);
        }
      });
    }
    function h() {
      o.forEach(function(Z) {
        return Z();
      }), o = [];
    }
    return N;
  };
}
var Ete = [Cee, ote, Iee, Gee, cte, ate, Rte, Hee, rte], Ste = /* @__PURE__ */ Mte({
  defaultModifiers: Ete
}), kte = typeof Element < "u", bte = typeof Map == "function", Yte = typeof Set == "function", Qte = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function gN(e, n) {
  if (e === n)
    return !0;
  if (e && n && typeof e == "object" && typeof n == "object") {
    if (e.constructor !== n.constructor)
      return !1;
    var t, l, a;
    if (Array.isArray(e)) {
      if (t = e.length, t != n.length)
        return !1;
      for (l = t; l-- !== 0; )
        if (!gN(e[l], n[l]))
          return !1;
      return !0;
    }
    var d;
    if (bte && e instanceof Map && n instanceof Map) {
      if (e.size !== n.size)
        return !1;
      for (d = e.entries(); !(l = d.next()).done; )
        if (!n.has(l.value[0]))
          return !1;
      for (d = e.entries(); !(l = d.next()).done; )
        if (!gN(l.value[1], n.get(l.value[0])))
          return !1;
      return !0;
    }
    if (Yte && e instanceof Set && n instanceof Set) {
      if (e.size !== n.size)
        return !1;
      for (d = e.entries(); !(l = d.next()).done; )
        if (!n.has(l.value[0]))
          return !1;
      return !0;
    }
    if (Qte && ArrayBuffer.isView(e) && ArrayBuffer.isView(n)) {
      if (t = e.length, t != n.length)
        return !1;
      for (l = t; l-- !== 0; )
        if (e[l] !== n[l])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === n.source && e.flags === n.flags;
    if (e.valueOf !== Object.prototype.valueOf && typeof e.valueOf == "function" && typeof n.valueOf == "function")
      return e.valueOf() === n.valueOf();
    if (e.toString !== Object.prototype.toString && typeof e.toString == "function" && typeof n.toString == "function")
      return e.toString() === n.toString();
    if (a = Object.keys(e), t = a.length, t !== Object.keys(n).length)
      return !1;
    for (l = t; l-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, a[l]))
        return !1;
    if (kte && e instanceof Element)
      return !1;
    for (l = t; l-- !== 0; )
      if (!((a[l] === "_owner" || a[l] === "__v" || a[l] === "__o") && e.$$typeof) && !gN(e[a[l]], n[a[l]]))
        return !1;
    return !0;
  }
  return e !== e && n !== n;
}
var Jte = function(n, t) {
  try {
    return gN(n, t);
  } catch (l) {
    if ((l.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw l;
  }
};
const vte = /* @__PURE__ */ nk(Jte);
var zte = [], xte = function(n, t, l) {
  l === void 0 && (l = {});
  var a = z.useRef(null), d = {
    onFirstUpdate: l.onFirstUpdate,
    placement: l.placement || "bottom",
    strategy: l.strategy || "absolute",
    modifiers: l.modifiers || zte
  }, r = z.useState({
    styles: {
      popper: {
        position: d.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), i = r[0], c = r[1], V = z.useMemo(function() {
    return {
      name: "updateState",
      enabled: !0,
      phase: "write",
      fn: function(N) {
        var R = N.state, h = Object.keys(R.elements);
        tk.flushSync(function() {
          c({
            styles: bS(h.map(function(Z) {
              return [Z, R.styles[Z] || {}];
            })),
            attributes: bS(h.map(function(Z) {
              return [Z, R.attributes[Z]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []), s = z.useMemo(function() {
    var U = {
      onFirstUpdate: d.onFirstUpdate,
      placement: d.placement,
      strategy: d.strategy,
      modifiers: [].concat(d.modifiers, [V, {
        name: "applyStyles",
        enabled: !1
      }])
    };
    return vte(a.current, U) ? a.current || U : (a.current = U, U);
  }, [d.onFirstUpdate, d.placement, d.strategy, d.modifiers, V]), o = z.useRef();
  return YS(function() {
    o.current && o.current.setOptions(s);
  }, [s]), YS(function() {
    if (!(n == null || t == null)) {
      var U = l.createPopper || Ste, N = U(n, t, s);
      return o.current = N, function() {
        N.destroy(), o.current = null;
      };
    }
  }, [n, t, l.createPopper]), {
    state: o.current ? o.current.state : null,
    styles: i.styles,
    attributes: i.attributes,
    update: o.current ? o.current.update : null,
    forceUpdate: o.current ? o.current.forceUpdate : null
  };
};
function fv(e) {
  var n = z.useRef(e);
  return n.current = e, z.useCallback(function() {
    return n.current;
  }, []);
}
var Gte = function() {
};
function yte(e) {
  var n = e.initial, t = e.value, l = e.onChange, a = l === void 0 ? Gte : l;
  if (n === void 0 && t === void 0)
    throw new TypeError('Either "value" or "initial" variable must be set. Now both are undefined');
  var d = z.useState(n), r = d[0], i = d[1], c = fv(r), V = z.useCallback(function(o) {
    var U = c(), N = typeof o == "function" ? o(U) : o;
    typeof N.persist == "function" && N.persist(), i(N), typeof a == "function" && a(N);
  }, [c, a]), s = t !== void 0;
  return [s ? t : r, s ? a : V];
}
function wv(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = 0), function() {
    return {
      width: 0,
      height: 0,
      top: n,
      right: e,
      bottom: n,
      left: e,
      x: 0,
      y: 0,
      toJSON: function() {
        return null;
      }
    };
  };
}
var Bte = ["styles", "attributes"], XS = {
  getBoundingClientRect: wv()
}, OS = {
  closeOnOutsideClick: !0,
  closeOnTriggerHidden: !1,
  defaultVisible: !1,
  delayHide: 0,
  delayShow: 0,
  followCursor: !1,
  interactive: !1,
  mutationObserverOptions: {
    attributes: !0,
    childList: !0,
    subtree: !0
  },
  offset: [0, 6],
  trigger: "hover"
};
function Dte(e, n) {
  var t, l, a;
  e === void 0 && (e = {}), n === void 0 && (n = {});
  var d = Object.keys(OS).reduce(function(f, I) {
    var K;
    return hr({}, f, (K = {}, K[I] = f[I] !== void 0 ? f[I] : OS[I], K));
  }, e), r = z.useMemo(
    function() {
      return [{
        name: "offset",
        options: {
          offset: d.offset
        }
      }];
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Array.isArray(d.offset) ? d.offset : []
  ), i = hr({}, n, {
    placement: n.placement || d.placement,
    modifiers: n.modifiers || r
  }), c = z.useState(null), V = c[0], s = c[1], o = z.useState(null), U = o[0], N = o[1], R = yte({
    initial: d.defaultVisible,
    value: d.visible,
    onChange: d.onVisibleChange
  }), h = R[0], Z = R[1], W = z.useRef();
  z.useEffect(function() {
    return function() {
      return clearTimeout(W.current);
    };
  }, []);
  var F = xte(d.followCursor ? XS : V, U, i), m = F.styles, E = F.attributes, u = Wee(F, Bte), b = u.update, k = fv({
    visible: h,
    triggerRef: V,
    tooltipRef: U,
    finalConfig: d
  }), Q = z.useCallback(
    function(f) {
      return Array.isArray(d.trigger) ? d.trigger.includes(f) : d.trigger === f;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Array.isArray(d.trigger) ? d.trigger : [d.trigger]
  ), S = z.useCallback(function() {
    clearTimeout(W.current), W.current = window.setTimeout(function() {
      return Z(!1);
    }, d.delayHide);
  }, [d.delayHide, Z]), v = z.useCallback(function() {
    clearTimeout(W.current), W.current = window.setTimeout(function() {
      return Z(!0);
    }, d.delayShow);
  }, [d.delayShow, Z]), G = z.useCallback(function() {
    k().visible ? S() : v();
  }, [k, S, v]);
  z.useEffect(function() {
    if (k().finalConfig.closeOnOutsideClick) {
      var f = function(K) {
        var Ue, q = k(), ae = q.tooltipRef, se = q.triggerRef, le = (K.composedPath == null || (Ue = K.composedPath()) == null ? void 0 : Ue[0]) || K.target;
        le instanceof Node && ae != null && se != null && !ae.contains(le) && !se.contains(le) && S();
      };
      return document.addEventListener("mousedown", f), function() {
        return document.removeEventListener("mousedown", f);
      };
    }
  }, [k, S]), z.useEffect(function() {
    if (!(V == null || !Q("click")))
      return V.addEventListener("click", G), function() {
        return V.removeEventListener("click", G);
      };
  }, [V, Q, G]), z.useEffect(function() {
    if (!(V == null || !Q("double-click")))
      return V.addEventListener("dblclick", G), function() {
        return V.removeEventListener("dblclick", G);
      };
  }, [V, Q, G]), z.useEffect(function() {
    if (!(V == null || !Q("right-click"))) {
      var f = function(K) {
        K.preventDefault(), G();
      };
      return V.addEventListener("contextmenu", f), function() {
        return V.removeEventListener("contextmenu", f);
      };
    }
  }, [V, Q, G]), z.useEffect(function() {
    if (!(V == null || !Q("focus")))
      return V.addEventListener("focus", v), V.addEventListener("blur", S), function() {
        V.removeEventListener("focus", v), V.removeEventListener("blur", S);
      };
  }, [V, Q, v, S]), z.useEffect(function() {
    if (!(V == null || !Q("hover")))
      return V.addEventListener("mouseenter", v), V.addEventListener("mouseleave", S), function() {
        V.removeEventListener("mouseenter", v), V.removeEventListener("mouseleave", S);
      };
  }, [V, Q, v, S]), z.useEffect(function() {
    if (!(U == null || !Q("hover") || !k().finalConfig.interactive))
      return U.addEventListener("mouseenter", v), U.addEventListener("mouseleave", S), function() {
        U.removeEventListener("mouseenter", v), U.removeEventListener("mouseleave", S);
      };
  }, [U, Q, v, S, k]);
  var w = u == null || (t = u.state) == null || (l = t.modifiersData) == null || (a = l.hide) == null ? void 0 : a.isReferenceHidden;
  z.useEffect(function() {
    d.closeOnTriggerHidden && w && S();
  }, [d.closeOnTriggerHidden, S, w]), z.useEffect(function() {
    if (!d.followCursor || V == null)
      return;
    function f(I) {
      var K = I.clientX, Ue = I.clientY;
      XS.getBoundingClientRect = wv(K, Ue), b == null || b();
    }
    return V.addEventListener("mousemove", f), function() {
      return V.removeEventListener("mousemove", f);
    };
  }, [d.followCursor, V, b]), z.useEffect(function() {
    if (!(U == null || b == null || d.mutationObserverOptions == null)) {
      var f = new MutationObserver(b);
      return f.observe(U, d.mutationObserverOptions), function() {
        return f.disconnect();
      };
    }
  }, [d.mutationObserverOptions, U, b]);
  var y = function(I) {
    return I === void 0 && (I = {}), hr({}, I, {
      style: hr({}, I.style, m.popper)
    }, E.popper, {
      "data-popper-interactive": d.interactive
    });
  }, g = function(I) {
    return I === void 0 && (I = {}), hr({}, I, E.arrow, {
      style: hr({}, I.style, m.arrow),
      "data-popper-arrow": !0
    });
  };
  return hr({
    getArrowProps: g,
    getTooltipProps: y,
    setTooltipRef: N,
    setTriggerRef: s,
    tooltipRef: U,
    triggerRef: V,
    visible: h
  }, u);
}
const Xte = (e) => /* @__PURE__ */ z.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { d: "M7.25 11.75V7.25H8.75V11.75H7.25Z", fill: "black", fillOpacity: 0.5 }), /* @__PURE__ */ z.createElement("path", { d: "M8 6.125C8.51777 6.125 8.9375 5.70527 8.9375 5.1875C8.9375 4.66973 8.51777 4.25 8 4.25C7.48223 4.25 7.0625 4.66973 7.0625 5.1875C7.0625 5.70527 7.48223 6.125 8 6.125Z", fill: "black", fillOpacity: 0.5 }), /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.5 8C0.5 3.85786 3.85786 0.5 8 0.5C12.1421 0.5 15.5 3.85786 15.5 8C15.5 12.1421 12.1421 15.5 8 15.5C3.85786 15.5 0.5 12.1421 0.5 8ZM8 2C4.68629 2 2 4.68629 2 8C2 11.3137 4.68629 14 8 14C11.3137 14 14 11.3137 14 8C14 4.68629 11.3137 2 8 2Z", fill: "black", fillOpacity: 0.5 }));
const Ote = A.div`
  color: rgba(0, 0, 0, 0.5);
  font-weight: 700;
  font-size: 14px;
  line-height: 20px;
`, jte = A.div`
  width: 100%;
  position: relative;
`, Hte = A.div`
  //border-radius: 0 0 16px 16px;
  display: flex;
  justify-content: flex-start;
  gap: 7.5px;
  align-items: center;
  width: 100%;
  padding: 12px 0 4px;
`, fte = A.div`
  position: absolute;
  width: calc(100% + 24px);
  transform: translateX(-12px);
  border-top: 1px solid rgba(0, 0, 0, 0.12);
`, wte = A.div`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 18px;
  cursor: pointer;
`, gte = A.div`
  padding: 8px 12px;
  //width: calc(100% - 140px);

  max-width: 260px;
  width: 100%;
  background: rgb(0, 0, 0, 0.8);
  border-radius: 8px;
  color: white;
  margin-top: 8px;
  font-family: 'Roboto', sans-serif;
  font-size: 14px;
  line-height: 20px;

  @media screen and (min-width: 600px) {
    max-width: 400px;
  }
`;
function Ite() {
  const { messageBottomContent: e } = jn(), n = "auto", { getTooltipProps: t, setTooltipRef: l, setTriggerRef: a } = Dte({
    placement: n
  }), [d, r] = me(!1);
  return /* @__PURE__ */ Y.jsxs(Y.Fragment, { children: [
    /* @__PURE__ */ Y.jsxs(jte, { ref: a, children: [
      /* @__PURE__ */ Y.jsx(fte, {}),
      /* @__PURE__ */ Y.jsxs(Hte, { children: [
        /* @__PURE__ */ Y.jsx(Ote, { children: e.text }),
        /* @__PURE__ */ Y.jsx(
          wte,
          {
            onMouseEnter: () => r(!0),
            onMouseLeave: () => r(!1),
            children: /* @__PURE__ */ Y.jsx(Xte, { height: "28px", width: "28px" })
          }
        )
      ] })
    ] }),
    d && Yi(
      /* @__PURE__ */ Y.jsx("div", { ref: l, ...t(), children: /* @__PURE__ */ Y.jsx(gte, { children: e.infoIconText }) }),
      document.getElementById("sb_chat_root_for_z_index")
    )
  ] });
}
const Lte = (e) => /* @__PURE__ */ z.createElement("svg", { width: 13, height: 13, viewBox: "0 0 13 13", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { d: "M10.7239 1.33333H8.33335V0H13V4.66667H11.6667V2.27614L6.33325 7.60958L5.39044 6.66677L10.7239 1.33333Z", fill: "#0D0D0D" }), /* @__PURE__ */ z.createElement("path", { d: "M0.334656 0.666667H5.25502V2H1.66799V11C1.66799 11.1841 1.81723 11.3333 2.00132 11.3333H10.668C10.8521 11.3333 11.0013 11.1841 11.0013 11V7.94903H12.3347V11C12.3347 11.9205 11.5885 12.6667 10.668 12.6667H2.00132C1.08085 12.6667 0.334656 11.9205 0.334656 11V0.666667Z", fill: "#0D0D0D" })), Cte = A.div`
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 8px 0;
  gap: 4px;
  width: 100%;
`, Kte = A.div`
  font-weight: 700;
  font-size: 14px;
  line-height: 20px;
  color: rgba(0, 0, 0, 0.5);
  padding-bottom: 4px;
`, _te = A.a`
  font-weight: 400;
  font-size: 14px;
  line-height: 20px;
  letter-spacing: -0.1px;
  color: rgba(0, 0, 0, 0.88);
  width: fit-content;
  block-size: fit-content;
`, Pte = A.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  gap: 16px;
`, Ate = A.a`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 15px;
  padding: 0 1px;
`;
function qte(e) {
  const { sources: n } = e, t = n[n.length - 1];
  return /* @__PURE__ */ Y.jsxs(Cte, { children: [
    /* @__PURE__ */ Y.jsx(Kte, { children: "Source" }),
    /* @__PURE__ */ Y.jsxs(Pte, { children: [
      /* @__PURE__ */ Y.jsx("div", { children: /* @__PURE__ */ Y.jsx(_te, { href: t.source, id: "openLinkText", target: "_blank", children: t.title }) }),
      /* @__PURE__ */ Y.jsx(Ate, { href: t.source, id: "openLinkIcon", target: "_blank", children: /* @__PURE__ */ Y.jsx(Lte, { width: "15px", height: "15px" }) })
    ] })
  ] });
}
const $te = qv(
  () => import("./CodeBlock-e287a6cc.mjs").then(({ CodeBlock: e }) => ({ default: e }))
), ene = A.div`
  display: flex;
  ${({ botCategory: e }) => e && aa`
      background-color: ${Sl[e]["--sendbird-light-background-50-0"]};
      &:hover {
        background-color: ${Sl[e]["--sendbird-light-background-50-0"]};
      }
    `};
  //max-width: 600px;
  flex-direction: column;
  align-items: flex-start;
  padding: 8px 12px;
  gap: 12px;
  border-radius: 16px;
  white-space: pre-wrap;
`, jS = A.div`
  width: 100%;
  text-align: left;
  word-break: break-word;
`, tne = A.div`
  width: 100%;
`;
function nne(e) {
  const { message: n, tokens: t } = e, { enableSourceMessage: l } = jn(), { botCategory: a } = jn(), d = JSON.parse(
    n.data === "" || n.data === "None" || !VC(n.data) ? "{}" : n.data
  ), r = Array.isArray(d.metadatas) ? d.metadatas : [];
  return t.length > 0 ? /* @__PURE__ */ Y.jsxs(ene, { botCategory: a, children: [
    t.map((i, c) => i.type === AY.string ? /* @__PURE__ */ Y.jsx(
      jS,
      {
        dangerouslySetInnerHTML: {
          __html: Uh(i.value)
        }
      },
      "token" + c
    ) : /* @__PURE__ */ Y.jsx(tne, { children: /* @__PURE__ */ Y.jsx($v, { fallback: /* @__PURE__ */ Y.jsx(Y.Fragment, {}), children: /* @__PURE__ */ Y.jsx($te, { token: i }) }) }, "token" + c)),
    r.length > 0 && l ? /* @__PURE__ */ Y.jsxs(Y.Fragment, { children: [
      /* @__PURE__ */ Y.jsx(qte, { sources: r }),
      /* @__PURE__ */ Y.jsx(Ite, {})
    ] }) : null
  ] }) : /* @__PURE__ */ Y.jsx(jS, { children: n.message });
}
const lne = A.div`
  display: flex;
  align-items: center;
  width: 100%;
  margin-bottom: 8px;
  padding-left: 16px;
  padding-right: 16px;
`, ane = A.div`
  width: 40px;
`, $r = {
  dotDiameter: "8px",
  duration: "1.4s",
  blinkedScale: 1.2,
  defaultOpacity: 0.12,
  blinkedOpacity: 0.38
}, dne = hk`
  0% {
    opacity: ${$r.defaultOpacity};
    transform: scale(1);
  }

  21.43% {
    opacity: ${$r.blinkedOpacity};
    transform: scale(${$r.blinkedScale});
  }

  42.86% {
    opacity: ${$r.defaultOpacity};
    transform: scale(1);
  }

  100% {
    opacity: ${$r.defaultOpacity};
    transform: scale(1);
  }
`, rne = A.div`
  align-items: center;
  border-radius: 16px;
  display: flex;
  gap: 6px;
  justify-content: center;
  padding: 16px 12px;
  background-color: var(--sendbird-light-background-50-0);
`, ZT = A.span`
  animation: ${dne} ${$r.duration} infinite;
  animation-fill-mode: both;
  border-radius: 50%;
  height: ${$r.dotDiameter};
  width: ${$r.dotDiameter};
  background-color: black;

  &:nth-child(1) {
    animation-delay: 0.4s;
  }

  &:nth-child(2) {
    animation-delay: 0.6s;
  }

  &:nth-child(3) {
    animation-delay: 0.8s;
  }
`;
function ine() {
  return /* @__PURE__ */ Y.jsxs(rne, { children: [
    /* @__PURE__ */ Y.jsx(ZT, {}),
    /* @__PURE__ */ Y.jsx(ZT, {}),
    /* @__PURE__ */ Y.jsx(ZT, {})
  ] });
}
function gv({
  botProfileUrl: e
}) {
  return /* @__PURE__ */ Y.jsxs(lne, { children: [
    /* @__PURE__ */ Y.jsx(ane, { children: /* @__PURE__ */ Y.jsx(
      "img",
      {
        src: e || Nh,
        alt: "profileImage",
        style: {
          height: "28px"
        }
      }
    ) }),
    /* @__PURE__ */ Y.jsx("div", { className: "sendbird-message-content__middle", children: /* @__PURE__ */ Y.jsx(ine, {}) })
  ] });
}
const Vne = A.div`
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 8px 12px;
  gap: 8px;
  border-radius: 16px;
  background-color: var(--sendbird-light-background-50-0);
  &:hover {
    background-color: var(--sendbird-light-background-50-0);
  }
`, cne = A.div`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
`, sne = A.a`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 0px 12px;
  height: 32px;
  background: var(--sendbird-light-primary-300);
  border-radius: 16px;
  color: white;
  cursor: pointer;
  margin: 4px 0;
  text-decoration: none;
  width: 100%;
`, one = A.div`
  text-align: left;
  white-space: pre-line;
  word-break: break-word;
  line-height: 1.43;
  width: 100%;
  max-width: 600px;
`;
function Une(e) {
  const { message: n } = e, t = JSON.parse(n.data ?? "");
  return /* @__PURE__ */ Y.jsxs(Vne, { children: [
    /* @__PURE__ */ Y.jsx(one, { children: t.text }),
    /* @__PURE__ */ Y.jsx(cne, { children: /* @__PURE__ */ Y.jsx(sne, { href: t.link, id: t.buttonText, target: "_blank", children: t.buttonText }) })
  ] });
}
const Nne = A.div`
  display: flex;
  align-items: flex-end;
  margin-bottom: 12px;
  flex-wrap: wrap;
  gap: 8px;
  position: relative;
  padding-left: 16px;
  padding-right: 16px;
`, Rne = A.div`
  font-style: normal;
  font-weight: 700;
  font-size: 12px;
  line-height: 12px;
  color: rgba(0, 0, 0, 0.5);
  transition: color 0.5s;
  transition-timing-function: ease;
  margin: 0 0 4px 12px;
`, hne = A.div`
  font-size: 14px;
  color: rgba(0, 0, 0, 0.88);
  max-width: calc(100% - 96px);
  font-weight: normal;
  font-stretch: normal;
  font-style: normal;
  line-height: 1.43;
  letter-spacing: normal;
`, Zne = A.div`
  width: fit-content;
  color: rgba(0, 0, 0, 0.38);
  font-size: 12px;
  line-height: 1;
  margin-bottom: 2px;
`, Tne = A.div``, Fne = A.div`
  width: 28px;
`;
function Wne(e) {
  const { user: n, message: t, bodyComponent: l, bodyStyle: a, chainTop: d, chainBottom: r } = e, i = d == null && r == null, c = i || r, V = i || d;
  return /* @__PURE__ */ Y.jsxs(Nne, { children: [
    c ? /* @__PURE__ */ Y.jsx(Tne, { children: /* @__PURE__ */ Y.jsx(da, { height: "28px", width: "28px", src: n == null ? void 0 : n.profileUrl }) }) : /* @__PURE__ */ Y.jsx(Fne, {}),
    /* @__PURE__ */ Y.jsxs(hne, { style: a ?? {}, children: [
      V && /* @__PURE__ */ Y.jsx(
        Rne,
        {
          style: {
            textAlign: "left"
          },
          children: n.nickname
        }
      ),
      l
    ] }),
    /* @__PURE__ */ Y.jsx(Zne, { children: kR(t.createdAt) })
  ] });
}
const mne = 3 * 60 * 1e3;
function une(e) {
  const n = e.reduce((t, l, a) => {
    var V, s;
    const { createdAt: d, sender: r, messageType: i } = l, c = Object.keys(t)[Object.keys(t).length - 1];
    return c && d - Number(c) <= mne && i !== "admin" && (r == null ? void 0 : r.userId) === ((s = (V = e[a - 1]) == null ? void 0 : V.sender) == null ? void 0 : s.userId) ? {
      ...t,
      [c]: [...t[c] ?? [], l]
    } : {
      ...t,
      [d]: [l]
    };
  }, {});
  return Object.values(n).flatMap(
    (t) => t.length > 1 ? t.map((l, a) => ({
      ...l,
      chaintop: a === 0,
      chainBottom: a === t.length - 1
    })) : t
  );
}
function pne(e, n) {
  var l, a;
  if (e.length === 0 || ((a = (l = e[0]) == null ? void 0 : l.sender) == null ? void 0 : a.userId) !== n)
    return [];
  if (e.every((d) => {
    var r;
    return ((r = d == null ? void 0 : d.sender) == null ? void 0 : r.userId) === n;
  }))
    return e;
  const t = e.find(
    (d) => {
      var r;
      return ((r = d == null ? void 0 : d.sender) == null ? void 0 : r.userId) !== n;
    }
  );
  return e.slice(0, e.indexOf(t));
}
function Mne(e) {
  var n;
  return !!((n = e.extendedMessagePayload) != null && n.forms);
}
function Ene(e) {
  var n;
  return (e == null ? void 0 : e.value_type) === "BALANCE" && (e == null ? void 0 : e.current_balance) != null && ((n = e == null ? void 0 : e.current_balance) == null ? void 0 : n.trim()) !== "";
}
function Sne(e) {
  var n;
  return (e == null ? void 0 : e.value_type) === "TRANSACTION_HISTORY" && (e == null ? void 0 : e.transaction_history) != null && ((n = e == null ? void 0 : e.transaction_history) == null ? void 0 : n.trim()) !== "";
}
function kne(e) {
  return (e == null ? void 0 : e.value_type) === "SENDING_MONEY" && (e == null ? void 0 : e.target_amount) != null && (e == null ? void 0 : e.recipient) != null;
}
function bne(e) {
  return (e == null ? void 0 : e.value_type) === "SENDING_MONEY_CONFIRMED" && (e == null ? void 0 : e.target_amount) != null && (e == null ? void 0 : e.recipient) != null;
}
function Yne(e) {
  return (e == null ? void 0 : e.value_type) === "ORDER_HISTORY" && (e == null ? void 0 : e.order_history) != null;
}
function Qne(e) {
  return (e == null ? void 0 : e.value_type) === "ORDER_DETAILS" && (e == null ? void 0 : e.order_details) != null;
}
function Jne(e) {
  return (e == null ? void 0 : e.value_type) === "CANCEL_ORDER" && (e == null ? void 0 : e.cancel_order) != null;
}
function vne(e) {
  return (e == null ? void 0 : e.value_type) === "RECOMMEND_ITEMS" && (e == null ? void 0 : e.recommend_items) != null;
}
function zne(e) {
  var h, Z, W;
  const {
    message: n,
    activeSpinnerId: t,
    botUser: l,
    lastMessageRef: a,
    chainTop: d,
    chainBottom: r,
    isBotWelcomeMessage: i
  } = e, { replacementTextList: c, userId: V } = jn(), { currentGroupChannel: s } = fl(), { allMessages: o } = fl(), U = nn(() => {
    let F;
    try {
      F = n != null && n.data ? JSON.parse(n.data) : null;
    } catch {
      F = null;
    }
    return F;
  }, [n == null ? void 0 : n.data]), N = nn(() => {
    var F, m;
    return U && ((F = U.function_calls) != null && F[0]) && ((m = U.function_calls[0]) == null ? void 0 : m.response_text) !== "" ? JSON.parse(U.function_calls[0].response_text) : null;
  }, [U]);
  if (n.messageType === "admin")
    return /* @__PURE__ */ Y.jsx("div", { children: /* @__PURE__ */ Y.jsx(K2, { message: n.message }) });
  if (Mne(n)) {
    const F = n.extendedMessagePayload.forms;
    return /* @__PURE__ */ Y.jsx(
      Ud,
      {
        botUser: l,
        message: n,
        bodyComponent: /* @__PURE__ */ Y.jsx(Fee, { form: F[0], message: n }),
        bodyStyle: { maxWidth: "320px", width: "calc(100% - 98px)" },
        messageCount: o.length,
        chainTop: d,
        chainBottom: r,
        isBotWelcomeMessage: i,
        isFormMessage: !0
      }
    );
  }
  if (kne(N))
    return /* @__PURE__ */ Y.jsx(
      Ud,
      {
        botUser: l,
        message: n,
        messageCount: o.length,
        bodyComponent: /* @__PURE__ */ Y.jsx(lee, { message: N }),
        chainTop: d,
        chainBottom: r
      }
    );
  if (bne(N))
    return /* @__PURE__ */ Y.jsx(
      Ud,
      {
        botUser: l,
        message: n,
        messageCount: o.length,
        bodyComponent: /* @__PURE__ */ Y.jsx($$, { message: N }),
        chainTop: d,
        chainBottom: r
      }
    );
  if (Ene(N))
    return /* @__PURE__ */ Y.jsx(
      Ud,
      {
        botUser: l,
        message: n,
        messageCount: o.length,
        bodyComponent: /* @__PURE__ */ Y.jsx(A7, { message: N }),
        chainTop: d,
        chainBottom: r
      }
    );
  if (Sne(N))
    return /* @__PURE__ */ Y.jsx(
      Ud,
      {
        botUser: l,
        message: n,
        messageCount: o.length,
        bodyComponent: /* @__PURE__ */ Y.jsx(Vee, { message: N }),
        chainTop: d,
        chainBottom: r
      }
    );
  if (Yne(N))
    return /* @__PURE__ */ Y.jsx(
      Ud,
      {
        botUser: l,
        message: n,
        messageCount: o.length,
        bodyComponent: /* @__PURE__ */ Y.jsx(f$, { message: N }),
        chainTop: d,
        chainBottom: r,
        newLineSentTime: !0
      }
    );
  if (Qne(N))
    return /* @__PURE__ */ Y.jsx(
      Ud,
      {
        botUser: l,
        message: n,
        messageCount: o.length,
        bodyComponent: /* @__PURE__ */ Y.jsx(d$, { message: N }),
        chainTop: d,
        chainBottom: r,
        newLineSentTime: !0
      }
    );
  if (Jne(N))
    return /* @__PURE__ */ Y.jsx(
      Ud,
      {
        botUser: l,
        message: n,
        messageCount: o.length,
        bodyComponent: /* @__PURE__ */ Y.jsx(z_, { message: N }),
        chainTop: d,
        chainBottom: r
      }
    );
  if (vne(N)) {
    const F = A.div`
      display: flex;
      flex-direction: column;
      width: 170px;
      font-family: var(--sendbird-font-family-custom);
      background-color: var(--sendbird-light-background-50-0);
      border-radius: 16px;
      padding: 6px 12px;
    `;
    return /* @__PURE__ */ Y.jsxs(Y.Fragment, { children: [
      /* @__PURE__ */ Y.jsx(
        Ud,
        {
          botUser: l,
          message: n,
          messageCount: o.length,
          bodyComponent: /* @__PURE__ */ Y.jsx(F, { children: /* @__PURE__ */ Y.jsx(
            Fe,
            {
              type: oe.BODY_1,
              color: ie.ONBACKGROUND_1,
              children: "Here are our top sells."
            }
          ) }),
          chainTop: d,
          chainBottom: r,
          newLineSentTime: !1,
          disableProfileContainer: !0,
          marginBottom: "3px"
        }
      ),
      /* @__PURE__ */ Y.jsx(K$, { message: N })
    ] });
  }
  if (((h = n.sender) == null ? void 0 : h.userId) === V) {
    const F = s == null ? void 0 : s.members.map((m) => m.userId);
    return /* @__PURE__ */ Y.jsxs("div", { children: [
      /* @__PURE__ */ Y.jsx(m_, { message: n }),
      t === n.messageId && (F == null ? void 0 : F.includes(l.userId)) && /* @__PURE__ */ Y.jsx(gv, { botProfileUrl: l == null ? void 0 : l.profileUrl })
    ] });
  }
  if (((Z = n.sender) == null ? void 0 : Z.userId) !== l.userId) {
    const F = n;
    return /* @__PURE__ */ Y.jsxs("div", { ref: a, children: [
      ((W = F.sender) == null ? void 0 : W.userId) === BN && F.message === `Hello! This is ${T2(
        BN
      )} from Sendbird Shopping. How can I help you?` && /* @__PURE__ */ Y.jsx(
        K2,
        {
          message: `${T2(
            BN
          )} from Sendbird Shopping has joined the chat.`
        }
      ),
      /* @__PURE__ */ Y.jsx(
        Wne,
        {
          message: n,
          user: n == null ? void 0 : n.sender,
          chainTop: d,
          chainBottom: r,
          bodyComponent: /* @__PURE__ */ Y.jsx(M_, { message: n.message })
        }
      )
    ] });
  }
  if (!iC(n.customType) && n.customType === $Y.linkSuggestion)
    return /* @__PURE__ */ Y.jsx(
      Ud,
      {
        botUser: l,
        message: n,
        bodyComponent: /* @__PURE__ */ Y.jsx(Une, { message: n }),
        bodyStyle: { maxWidth: "320px", width: "calc(100% - 98px)" },
        messageCount: o.length,
        chainTop: d,
        chainBottom: r,
        isBotWelcomeMessage: i
      }
    );
  const R = rC(n.message);
  return R.forEach((F) => {
    F.type === "String" && (F.value = oC(F.value), F.value = cC(
      F.value,
      c
    ), F.value = Uh(F.value));
  }), /* @__PURE__ */ Y.jsx("div", { ref: a, children: /* @__PURE__ */ Y.jsx(
    Ud,
    {
      botUser: l,
      message: n,
      messageCount: o.length,
      bodyComponent: /* @__PURE__ */ Y.jsx(
        nne,
        {
          message: n,
          tokens: R
        }
      ),
      chainTop: d,
      chainBottom: r,
      isBotWelcomeMessage: i
    }
  ) });
}
const xne = A.textarea`
  width: ${(e) => e.isActive ? "calc(100% - 30px)" : "100%"};
  transition: ${(e) => e.isActive ? "none" : "width 0.5s"};
  transition-timing-function: ease;
  padding: 8px 16px;
  font-size: 14px;
  font-family: 'Roboto', sans-serif;
  line-height: 20px;
  color: rgba(0, 0, 0, 0.88);
  resize: none;
  border: none;
  outline: none;
  max-height: 116px;
  background: ${({ botCategory: e }) => e ? Sl[e]["input-message-background-color"] : "#eeeeee"};
  };
  border-radius: 20px;
  height: auto;
  ::placeholder {
    color: rgba(0, 0, 0, 0.38);
  }
`, Gne = A.div`
  width: 100%;
  border-bottom-left-radius: 15px;
  border-bottom-right-radius: 15px;
  background: ${({ botCategory: e }) => e ? Sl[e]["input-container-color"] : "#eeeeee"};
  };
`, yne = A.div`
  padding: 12px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
`, Bne = A.div`
  padding: 4px;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
`, Dne = (e, n) => {
  _e(() => {
    if (e) {
      e.style.height = "0";
      const t = e.scrollHeight;
      e.style.height = t + "px";
    }
  }, [e, n]);
};
function Iv({
  onSendMessage: e
}) {
  const { inputValue: n } = jn(), t = Wt(null), [l, a] = me(!1), [d, r] = me((n == null ? void 0 : n.value) ?? ""), { botCategory: i } = jn(), c = Ji();
  Dne(t.current, d), _e(() => {
    (n == null ? void 0 : n.value) != null && n.value.length > 0 && c(n.value);
  }, [n == null ? void 0 : n.value, n == null ? void 0 : n.id]), _e(() => {
    typeof d == "string" && d.length > 0 && a(!0);
  }, [d]);
  function V() {
    e == null || e(d), c(d), r("");
  }
  function s(U) {
    if (d == null)
      return;
    const N = U.target.value;
    r(N), a(N.length > 0);
  }
  function o(U) {
    !U.shiftKey && U.charCode === 13 && d != null && (U.preventDefault(), V());
  }
  return /* @__PURE__ */ Y.jsx(Gne, { botCategory: i, children: /* @__PURE__ */ Y.jsxs(yne, { children: [
    /* @__PURE__ */ Y.jsx(
      xne,
      {
        isActive: l,
        onKeyPress: o,
        ref: t,
        value: d,
        onChange: s,
        rows: 1,
        placeholder: "Enter message",
        botCategory: i
      }
    ),
    l && /* @__PURE__ */ Y.jsx(Bne, { children: /* @__PURE__ */ Y.jsx(
      xQ,
      {
        onClick: () => {
          V();
        },
        height: "20px",
        width: "20px",
        children: "Send"
      }
    ) })
  ] }) });
}
const Xne = A.div`
  white-space: nowrap;
  height: 32px;
  font-size: 12px;
  padding: 3px 14px;
  display: flex;
  align-items: center;
  color: ${(e) => e.isActive ? "var(--sendbird-light-primary-300)" : "#EEEEEE"};
  border: ${(e) => e.isActive ? "1px solid var(--sendbird-light-primary-300)" : "1px solid #EEEEEE"};
  border-radius: 18px;
  background-color: #ffffff;
  cursor: ${(e) => e.isActive ? "pointer" : "not-allowed"};
  &:hover {
    ${(e) => {
  if (e.isActive)
    return "background-color: var(--sendbird-light-primary-300);";
}};
  }
  &:active {
    ${(e) => {
  if (e.isActive)
    return "background-color: var(--sendbird-light-primary-300); color: #FFFFFF;";
}};
  }
`, One = A.div`
  position: relative;
  display: flex;
  justify-content: flex-end;
  align-items: flex-end;
  flex-wrap: wrap;
  column-gap: 10px;
  row-gap: 8px;
  margin-top: 16px;
  flex-direction: column;
`, jne = (e) => {
  const { replyOptions: n } = e, [t, l] = me(n), a = Ji(), d = (r, i) => {
    r.preventDefault(), a(i), l([]);
  };
  return t && t.length > 0 ? /* @__PURE__ */ Y.jsx(One, { children: n.map((r) => /* @__PURE__ */ Y.jsx(
    Xne,
    {
      id: r,
      onClick: (i) => d(i, r),
      isActive: !0,
      children: r
    },
    r
  )) }) : null;
}, Hne = (e) => /* @__PURE__ */ z.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.7071 0.292893C16.0676 0.653377 16.0953 1.22061 15.7903 1.6129L15.7071 1.70711L9.414 7.99988L15.7071 14.2929C16.0976 14.6834 16.0976 15.3166 15.7071 15.7071C15.3466 16.0676 14.7794 16.0953 14.3871 15.7903L14.2929 15.7071L7.99988 9.414L1.70711 15.7071C1.31658 16.0976 0.683418 16.0976 0.292893 15.7071C-0.0675906 15.3466 -0.0953204 14.7794 0.209704 14.3871L0.292893 14.2929L6.58575 7.99988L0.292893 1.70711C-0.0976309 1.31658 -0.0976309 0.683418 0.292893 0.292893C0.653377 -0.0675906 1.22061 -0.0953204 1.6129 0.209704L1.70711 0.292893L7.99988 6.58575L14.2929 0.292893C14.6834 -0.0976309 15.3166 -0.0976309 15.7071 0.292893Z", fill: "#000" })), fne = A.div`
  position: relative;
  height: ${({ height: e }) => e};
  font-family: 'Roboto', sans-serif;
  z-index: 0;
  border: none;

  .sendbird-place-holder {
    background: ${({ botCategory: e }) => e ? Sl[e]["sendbird-conversation__messages-background-color"] : "#eeeeee"};
    };
  }
  ${({ botCategory: e }) => e && aa`
      --sendbird-light-primary-300: ${Sl[e]["--sendbird-light-primary-300"]};
      --sendbird-light-background-50-0: ${Sl[e]["--sendbird-light-background-50-0"]};
      --sendbird-light-background-50: ${Sl[e]["--sendbird-light-background-50"]};
    `}
  .sendbird-place-holder__body {
    display: ${({ hidePlaceholder: e }) => e ? "none" : "block"};
  }

  .sendbird-message-input-wrapper {
    width: 100%;
  }

  .sendbird-message-input-wrapper__message-input {
    padding: 12px 16px;
    display: flex;
    -webkit-box-pack: justify;
    justify-content: space-between;
    -webkit-box-align: center;
    align-items: center;
  }

  .sendbird-conversation__messages {
    background-color: ${({ botCategory: e }) => e ? Sl[e]["sendbird-conversation__messages-background-color"] : "#eeeeee"};
  }

  .sendbird-separator {
    padding-top: 16px;
    padding-bottom: 16px;
  }

  .sendbird-message-input {
    display: flex;
    align-items: center;
    .sendbird-message-input-text-field {
      transition: ${(e) => e.isInputActive ? "none" : "width 0.5s"};
      transition-timing-function: ease;
      padding: 8px 16px;
      font-size: 14px;
      font-family: 'Roboto', sans-serif;
      line-height: 20px;
      color: rgba(0, 0, 0, 0.88);
      resize: none;
      border: none;
      outline: none;
      max-height: 116px;
      background: ${({ botCategory: e }) => e ? Sl[e]["input-container-color"] : "#eeeeee"};
      };
    
      border-radius: 20px;
      height: auto;
      ::placeholder {
        color: rgba(0, 0, 0, 0.38);
      }
      :focus {
        border: none;
        box-shadow: none;
      }
    }
    .sendbird-message-input--send {
      position: relative;
      right: 0;
      bottom: 0;
      :hover {
        background-color: transparent;
      }
    }
    .sendbird-message-input--placeholder {
      top: 9px;
    }
  }
`, wne = A.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  width: 335px;
  max-height: 319px;
  padding: 20px;
  border-radius: 8px;
  z-index: 9999;
`, gne = A.div`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 15px;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 999;
`;
function Ine(e) {
  var k, Q;
  const { botUser: n, createGroupChannel: t } = e, { userId: l, suggestedMessageContent: a } = jn(), { botCategory: d } = jn(), { allMessages: r, currentGroupChannel: i } = fl(), c = Wt(null), [V, s] = me(!1), [o, U] = me({
    symptom: "",
    date: "",
    medicalHistory: ""
  });
  pC(n.userId), EC();
  const N = i, R = r == null ? void 0 : r[(r == null ? void 0 : r.length) - 1];
  (R == null ? void 0 : R.messageType) !== "admin" && ((k = R == null ? void 0 : R.sender) == null || k.userId, n.userId);
  const [h, Z] = me(-1), W = r.length === 1 && R.messageType === "admin", F = nn(() => {
    let S;
    try {
      S = R != null && R.data ? JSON.parse(R.data) : null;
    } catch {
      S = null;
    }
    return S;
  }, [R == null ? void 0 : R.data]), m = (R == null ? void 0 : R.extendedMessagePayload) != null && "suggested_replies" in R.extendedMessagePayload && R.extendedMessagePayload.suggested_replies != null ? R.extendedMessagePayload.suggested_replies : [];
  r && r.length > 1 && (R == null ? void 0 : R.messageType) !== "admin" && ((Q = R.sender) == null ? void 0 : Q.userId) === n.userId && // in streaming
  F != null && "stream" in F && !F.stream && UC(
    R.message,
    a.messageFilterList
  );
  function E() {
    s(!1);
  }
  _e(() => {
    var S;
    R && (R == null ? void 0 : R.messageType) !== "admin" && ((S = R.sender) == null ? void 0 : S.userId) === l && R.sendingStatus === $t.SUCCEEDED && // this bubble loading should be shown only when there're only bot and 1 user in the channel
    (N == null ? void 0 : N.memberCount) === 2 && !(i != null && i.members.map((v) => v.userId).includes(BN)) ? Z(R.messageId) : Z(-1);
  }, [R == null ? void 0 : R.messageId]);
  const u = nn(
    () => une(r),
    [r.length]
  ), b = nn(() => pne(r, n.userId), [r.length]);
  return _e(() => {
    N == null || N.createMetaData({ bot_id: n.userId });
  }, [N]), /* @__PURE__ */ Y.jsxs(
    fne,
    {
      hidePlaceholder: W,
      height: "100%",
      botCategory: d,
      children: [
        /* @__PURE__ */ Y.jsx(
          eC,
          {
            renderChannelHeader: () => N && t && n ? /* @__PURE__ */ Y.jsx(
              yC,
              {
                botUser: n,
                channel: N,
                createGroupChannel: t
              }
            ) : /* @__PURE__ */ Y.jsx(UY, {}),
            renderMessage: ({ message: S }) => {
              const v = u.find(
                (w) => w.messageId == S.messageId
              ), G = !!b.find(
                (w) => w.messageId === S.messageId
              );
              return /* @__PURE__ */ Y.jsxs(Y.Fragment, { children: [
                /* @__PURE__ */ Y.jsx(
                  zne,
                  {
                    message: S,
                    activeSpinnerId: h,
                    botUser: n,
                    lastMessageRef: c,
                    chainTop: v == null ? void 0 : v.chaintop,
                    chainBottom: v == null ? void 0 : v.chainBottom,
                    isBotWelcomeMessage: G
                  }
                ),
                S.messageId === R.messageId && m.length > 0 && /* @__PURE__ */ Y.jsx(jne, { replyOptions: m })
              ] });
            },
            renderTypingIndicator: () => /* @__PURE__ */ Y.jsx(Y.Fragment, {}),
            renderMessageInput: () => d === "healthcare" ? /* @__PURE__ */ Y.jsx(
              l_,
              {
                setModalContent: U,
                setShowModal: s
              }
            ) : /* @__PURE__ */ Y.jsx(Iv, {})
          }
        ),
        V && /* @__PURE__ */ Y.jsxs(Y.Fragment, { children: [
          /* @__PURE__ */ Y.jsx(gne, { onClick: E }),
          /* @__PURE__ */ Y.jsxs(wne, { children: [
            /* @__PURE__ */ Y.jsxs(
              "div",
              {
                style: {
                  display: "flex",
                  justifyContent: "space-between",
                  height: "36px"
                },
                children: [
                  /* @__PURE__ */ Y.jsx(
                    Fe,
                    {
                      type: oe.H_1,
                      color: ie.ONBACKGROUND_1,
                      children: "Medical History"
                    }
                  ),
                  /* @__PURE__ */ Y.jsx(
                    Hne,
                    {
                      style: {
                        color: "black",
                        cursor: "pointer"
                      },
                      onClick: E
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ Y.jsxs(
              "div",
              {
                style: {
                  paddingTop: "12px",
                  display: "flex",
                  flexDirection: "column",
                  gap: "8px"
                },
                children: [
                  /* @__PURE__ */ Y.jsx(
                    "div",
                    {
                      style: {
                        color: "rgba(0, 0, 0, 0.5)"
                      },
                      children: o.date
                    }
                  ),
                  /* @__PURE__ */ Y.jsx(
                    "div",
                    {
                      style: {
                        height: "200px",
                        overflowY: "auto"
                      },
                      children: o.medicalHistory.split(`
`).map((S, v) => /* @__PURE__ */ Y.jsx(
                        "div",
                        {
                          style: {
                            paddingLeft: "10px",
                            textIndent: "-10px"
                          },
                          children: S
                        },
                        v
                      ))
                    }
                  )
                ]
              }
            )
          ] })
        ] })
      ]
    }
  );
}
const Lne = (e) => /* @__PURE__ */ z.createElement("svg", { width: 52, height: 52, viewBox: "0 0 52 52", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M26 51.6668C40.1754 51.6668 51.6667 40.1755 51.6667 26.0002C51.6667 11.8249 40.1754 0.333496 26 0.333496C11.8247 0.333496 0.333374 11.8249 0.333374 26.0002C0.333374 27.372 1.44544 28.484 2.81725 28.484C4.18905 28.484 5.30112 27.372 5.30112 26.0002C5.30112 14.5685 14.5683 5.30124 26 5.30124C37.4317 5.30124 46.699 14.5685 46.699 26.0002C46.699 37.4319 37.4317 46.6991 26 46.6991C24.6282 46.6991 23.5162 47.8112 23.5162 49.183C23.5162 50.5548 24.6282 51.6668 26 51.6668Z", fill: "#30308F" })), Cne = hk`
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}`, Kne = A.div`
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
  background-color: white;
  border-radius: 15px;
`, _ne = A.div`
  display: grid;
  justify-content: center;
  align-items: center;
  height: 70px;
  width: 70px;
  animation: ${Cne} 1.5s linear infinite;
`;
function Lv() {
  return /* @__PURE__ */ Y.jsx(Kne, { children: /* @__PURE__ */ Y.jsx(_ne, { children: /* @__PURE__ */ Y.jsx(Lne, { width: "50px", height: "50px" }) }) });
}
const Pne = A.div`
  padding: 4px 6px;
  border: 1px solid #1870f3;
  border-radius: 100px;
  font-weight: 700;
  font-size: 11px;
  line-height: 12px;
  color: #1870f3;
`, Ane = (e) => /* @__PURE__ */ z.createElement("svg", { width: 109, height: 20, viewBox: "0 0 109 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ z.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.98815 0.799927C15.0434 0.799927 19.1541 4.96963 19.1541 10.0323C19.1541 15.095 15.0287 19.2499 9.96601 19.2499C4.90333 19.2499 0.800049 15.1024 0.800049 10.0175H5.30185C2.80003 9.96589 0.800049 7.91425 0.800049 5.40505V0.799927H9.98815ZM69.2939 1.33881V16.6966H66.1131V15.1173C65.3456 16.2833 64.1501 16.9327 62.5929 16.9327C59.7516 16.9327 57.4638 14.3128 57.4638 11.1321C57.4638 7.95129 59.7368 5.36829 62.5929 5.36829C64.1132 5.36829 65.3087 6.01773 66.0762 7.13211L66.1131 7.18377V1.33881H69.2939ZM27.191 5.34602C29.5526 5.34602 31.678 6.5711 31.9806 8.97698V9.05078H28.785C28.7481 8.4899 28.143 7.98806 27.1245 7.98806C26.4087 7.98806 25.8699 8.23898 25.8699 8.76296C25.8699 10.5046 32.0913 8.6744 32.106 13.3459C32.106 15.3754 30.1946 16.94 27.6928 16.94C24.8515 16.94 22.8515 15.5009 22.5785 13.0212V12.9474H25.619C25.6928 13.6854 26.4751 14.1873 27.5304 14.1873C28.4751 14.1873 29.0138 13.8625 29.0138 13.3459C29.0138 11.5157 22.7925 13.1467 22.7925 8.99912C22.7999 6.91058 24.4751 5.34602 27.191 5.34602ZM108.017 1.33881V16.6818H104.858V15.1025C104.091 16.2685 102.895 16.918 101.338 16.918C98.4596 16.918 96.1939 14.2981 96.1939 11.1173C96.1939 7.93653 98.4669 5.35353 101.323 5.35353C102.843 5.35353 104.039 6.00297 104.806 7.11735L104.843 7.16901V1.33881H108.017ZM74.1719 1.33881V7.12473C74.9394 5.97345 76.1202 5.34615 77.6553 5.34615C80.5335 5.34615 82.7991 7.95129 82.7991 11.1321C82.7991 14.3128 80.5261 16.918 77.67 16.918C76.1867 16.918 74.9911 16.2907 74.2236 15.1763L74.1867 15.1247V16.6892H71.0059V1.33881H74.1719ZM38.9842 5.34602C41.9878 5.34602 44.438 7.715 44.438 10.7703C44.438 11.095 44.4232 11.4198 44.3863 11.7445L44.3716 11.9068H36.165C36.379 13.3459 37.486 14.2758 38.9694 14.2758C40.1871 14.2758 40.9546 13.7518 41.1465 12.9991L41.1613 12.9622H44.2683C43.914 15.3312 41.855 16.881 39.1392 16.9105H38.9104C35.7296 16.8736 33.213 14.2537 33.2425 11.0729C33.2499 7.8257 35.7665 5.34602 38.9842 5.34602ZM94.9025 5.32395C95.2272 5.33871 95.5298 5.37561 95.8324 5.44941L95.9579 5.46417V8.37189C95.5815 8.26119 95.2051 8.20953 94.814 8.20953C93.2937 8.20953 92.0834 9.10989 92.0465 11.1172V16.667H88.8657V5.56011H92.0465V6.81471C92.6738 5.89959 93.6701 5.33871 94.7623 5.32395H94.9025ZM51.7442 5.34602C54.556 5.34602 56.2681 7.22792 56.2829 10.298V16.6817H53.1021V10.7925C53.1021 9.3386 52.246 8.38658 50.925 8.38658C49.6187 8.38658 48.7627 9.3017 48.7479 10.726V16.6891H45.5671V5.56004H48.7479V6.99914C49.4416 5.95856 50.4748 5.34602 51.7442 5.34602ZM87.1313 5.56011V16.6596H83.9505V5.56011H87.1313ZM99.3674 11.0951C99.3527 12.5859 100.511 13.8257 101.995 13.8774H102.135C103.618 13.8405 104.814 12.6228 104.814 11.132C104.814 9.64123 103.618 8.41615 102.135 8.40139C100.652 8.36449 99.4043 9.56743 99.3674 11.0951ZM60.6593 11.0951C60.6446 12.5859 61.8032 13.8257 63.2866 13.8774H63.4268C64.9102 13.8405 66.1058 12.6228 66.1058 11.132C66.1058 9.64123 64.9102 8.41615 63.4268 8.40139C61.9287 8.36449 60.6815 9.56743 60.6593 11.0951ZM77.0354 8.3276H76.9247C75.4044 8.34236 74.1941 9.60434 74.2089 11.132C74.2089 12.6744 75.4266 13.8626 76.9985 13.8626C78.5188 13.8257 79.7291 12.5711 79.7143 11.0582C79.6922 9.56744 78.4966 8.3645 77.0354 8.3276ZM38.8441 7.95127C37.6485 7.95127 36.7186 8.54167 36.3275 9.80365L36.3127 9.87745H41.1171C41.0211 8.71879 40.0248 7.95127 38.8441 7.95127ZM85.5225 0.79994C86.5778 0.79994 87.4486 1.6634 87.4486 2.71874C87.4486 3.77408 86.6073 4.65968 85.5372 4.65968C84.4819 4.65968 83.611 3.81836 83.611 2.74088C83.6037 1.6634 84.445 0.79994 85.5225 0.79994Z", fill: "white" })), qne = A.div`
  width: 100%;
`, $ne = A.div`
  padding: 0 4px;
  width: calc(100% - 8px);
  min-height: 40px;
  display: flex;
  justify-content: center;
  align-items: center;
  background: ${(e) => e.chatBottomBackgroundColor || "linear-gradient(273.73deg, #4DCD90 -0.83%, #6210CC 48.04%, #6210CC 75.45%)"};
  color: rgba(255, 255, 255, 0.88);
  flex-wrap: wrap;
  font-size: 13px;
`, ele = A.a`
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
`;
function tle() {
  const { chatBottomContent: e } = jn();
  return /* @__PURE__ */ Y.jsx(qne, { children: /* @__PURE__ */ Y.jsxs(
    $ne,
    {
      chatBottomBackgroundColor: e == null ? void 0 : e.backgroundColor,
      children: [
        e == null ? void 0 : e.text,
        "   Powered by ",
        /* @__PURE__ */ Y.jsx(
          ele,
          {
            href: "https://sendbird.com/products/chatgpt-integration",
            target: "_blank",
            rel: "noopener noreferrer",
            children: /* @__PURE__ */ Y.jsx(Ane, { width: "75px" })
          }
        )
      ]
    }
  ) });
}
const nle = A.div`
  position: absolute;
  max-width: 400px;
`, lle = A.div`
  width: calc(100% - 64px);
  position: absolute;
  padding: 32px;
`, ale = A.div`
  position: relative;
  top: ${(e) => e.isStartingPage ? "0" : "-300px"};
  opacity: ${(e) => e.isStartingPage ? "1" : "0"};
  z-index: 20;
  width: 100%;
  transition: ${(e) => e.isStartingPage ? "none" : "all 0.5s ease"};
  text-align: start;
`, dle = A.div`
  color: #ffffff;
  opacity: 0.8;
  font-style: normal;
  font-weight: 600;
  font-size: 20px;
  line-height: 28px;
  font-family: 'Gellix', sans-serif;
`, rle = A.div`
  font-weight: 700;
  //font-size: 27px;
  margin-top: 2px;
  font-family: 'Gellix', sans-serif;
  color: #ffffff;
  //margin-top: 8px;
  font-size: 32px;
  line-height: 40px;
`, ile = A.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 14px 0 0;
`, TT = A.div`
  display: flex;
  align-items: flex-end;
  box-sizing: border-box;
  justify-content: ${({ outgoing: e }) => e ? "flex-end" : "flex-start"};
  padding-right: 12px;
  margin-bottom: 6px;
  flex-wrap: wrap;
  gap: 8px;
  position: relative;
  width: calc(100%);
`, FT = A.div`
  font-size: 14px;
  color: ${({ outgoing: e }) => e ? "#ffffff" : " rgba(0, 0, 0, 0.88)"};
  max-width: 225px;
  font-weight: normal;
  font-stretch: normal;
  font-style: normal;
  line-height: 1.43;
  letter-spacing: normal;

  @media (max-width: 350px) {
    max-width: 200px;
  }
`, Vle = A.div`
  font-style: normal;
  font-weight: 700;
  font-size: 12px;
  line-height: 12px;
  color: rgba(0, 0, 0, 0.5);
  transition: color 0.5s ease 0s;
  margin: 0px 0px 4px 12px;
`, HS = A.div`
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 8px 12px;
  gap: 8px;
  border-radius: 16px;
  background-color: ${({ outgoing: e }) => e ? "var(--sendbird-light-primary-300)" : "rgb(238, 238, 238)"};
`, fS = A.div`
  width: 100%;
  text-align: left;
  white-space: pre-line;
  word-break: break-word;
  line-height: 1.43;
`, cle = A.div`
  position: fixed;
  bottom: 0;
  width: 100%;
`;
function Cv(e) {
  const { isStartingPage: n } = e, { startingPageContent: t, betaMark: l, customBetaMarkText: a, botNickName: d } = jn(), {
    sbConnectionStatus: r,
    setSbConnectionStatus: i,
    firstMessage: c,
    setFirstMessage: V
  } = UU();
  return /* @__PURE__ */ Y.jsxs(ale, { isStartingPage: n, children: [
    /* @__PURE__ */ Y.jsxs(nle, { children: [
      /* @__PURE__ */ Y.jsx(
        t.backGroundContent.Component,
        {
          height: t == null ? void 0 : t.backGroundContent.height
        }
      ),
      /* @__PURE__ */ Y.jsxs(TT, { children: [
        /* @__PURE__ */ Y.jsx(
          "div",
          {
            style: {
              paddingLeft: "12px"
            },
            children: /* @__PURE__ */ Y.jsx(
              "img",
              {
                src: Nh,
                alt: "botProfileImage",
                style: {
                  height: "28px"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ Y.jsxs(FT, { children: [
          /* @__PURE__ */ Y.jsx(Vle, { children: t.messageContent.header === "" ? d : t.messageContent.header }),
          /* @__PURE__ */ Y.jsx(HS, { children: /* @__PURE__ */ Y.jsx(fS, { children: t.messageContent.body === "" ? `Hi~ I'm ${d}. Ask me anything!` : t.messageContent.body }) })
        ] })
      ] }),
      c !== "" && c != null && /* @__PURE__ */ Y.jsx(TT, { outgoing: !0, children: /* @__PURE__ */ Y.jsx(FT, { outgoing: !0, children: /* @__PURE__ */ Y.jsx(HS, { outgoing: !0, children: /* @__PURE__ */ Y.jsx(fS, { children: c }) }) }) }),
      r !== "INIT" && /* @__PURE__ */ Y.jsx(TT, { children: /* @__PURE__ */ Y.jsx(FT, { children: /* @__PURE__ */ Y.jsx("div", { style: { paddingLeft: 12 }, children: /* @__PURE__ */ Y.jsx(gv, {}) }) }) }),
      /* @__PURE__ */ Y.jsxs(cle, { children: [
        /* @__PURE__ */ Y.jsx(
          Iv,
          {
            onSendMessage: async (s) => {
              V(s), i("CONNECTING");
            }
          }
        ),
        /* @__PURE__ */ Y.jsx(tle, {})
      ] })
    ] }),
    /* @__PURE__ */ Y.jsxs(lle, { children: [
      /* @__PURE__ */ Y.jsx(
        t.logoContent.Component,
        {
          width: t.logoContent.width
        }
      ),
      /* @__PURE__ */ Y.jsxs(ile, { style: { alignItems: "flex-end" }, children: [
        /* @__PURE__ */ Y.jsx(dle, { children: t.headerContent.headerOne === "" ? `I'm ${d}` : t.headerContent.headerOne }),
        (l || a) && /* @__PURE__ */ Y.jsx(Pne, { style: { marginBottom: "3px" }, children: a })
      ] }),
      /* @__PURE__ */ Y.jsx(rle, { children: t.headerContent.headerTwo })
    ] })
  ] });
}
function sle(e, n) {
  const [t, l] = me(null), [a, d] = me(!1), r = zn(), i = r.stores.sdkStore.sdk, c = bY(r), { createGroupChannelParams: V, instantConnect: s, firstMessageData: o } = jn(), { setSbConnectionStatus: U, firstMessage: N } = UU(), R = Pt(async () => {
    if (!(!e || !n))
      try {
        d(!0);
        const h = s && o ? JSON.stringify({
          first_message_data: o
        }) : void 0, Z = {
          name: V == null ? void 0 : V.name,
          invitedUserIds: [e.userId, n.userId],
          isDistinct: !1,
          coverUrl: V == null ? void 0 : V.coverUrl,
          data: h
        }, W = await i.groupChannel.createChannel(Z).then((F) => (l(F), F));
        N !== "" && N != null && await c(W, {
          message: N
        });
      } catch (h) {
        console.error(h);
      } finally {
        d(!1), U("CONNECTED");
      }
  }, [e == null ? void 0 : e.userId, n == null ? void 0 : n.userId, N]);
  return _e(() => {
    e && n && i && R();
  }, [e == null ? void 0 : e.userId, n == null ? void 0 : n.userId, N]), [t, R, a];
}
const Kv = _l({
  hashedKey: null
}), ole = (e) => /* @__PURE__ */ Y.jsx(Kv.Provider, { value: { hashedKey: e.hashedKey }, children: e.children }), Ule = () => Gt(Kv);
function Nle(e, n) {
  const [t, l] = me(null), a = zn(), { hashedKey: d } = Ule(), r = a.stores.sdkStore.sdk;
  return _e(() => {
    if (e && n) {
      const i = r.createApplicationUserListQuery(
        {
          userIdsFilter: d != null ? [n, d] : [n]
        }
      );
      setTimeout(() => {
        i.next().then((c) => {
          c.length <= 0 || l(c[0]);
        }).catch((c) => {
          console.error("## useGetBotUser error: ", c);
        });
      }, 0);
    }
  }, [e == null ? void 0 : e.userId, n, d]), t;
}
function Rle(e) {
  const { instantConnect: n } = jn(), { sbConnectionStatus: t } = UU(), { setInitialTimeStamp: l } = fl(), [a, d] = me(!1);
  return _e(() => {
    t === "CONNECTED" && setTimeout(() => {
      d(!0), l(null);
    }, 500);
  }, [t]), a ? /* @__PURE__ */ Y.jsx(Ine, { ...e }) : n ? /* @__PURE__ */ Y.jsx(Lv, {}) : /* @__PURE__ */ Y.jsx(Cv, { isStartingPage: !0 });
}
function hle() {
  const { botId: e, instantConnect: n } = jn(), l = zn().stores.sdkStore.sdk;
  V1(e !== null, "botId must be provided");
  const a = Nle(l.currentUser, e), [d, r] = sle(
    l.currentUser,
    a
  );
  return n && !d ? /* @__PURE__ */ Y.jsx(Lv, {}) : /* @__PURE__ */ Y.jsx(
    $g,
    {
      channelUrl: d == null ? void 0 : d.url,
      scrollBehavior: "smooth",
      reconnectOnIdle: !1,
      children: /* @__PURE__ */ Y.jsx(Rle, { createGroupChannel: r, botUser: a })
    }
  );
}
const Zle = () => {
  const {
    apiHost: e,
    applicationId: n,
    botId: t,
    userId: l,
    userNickName: a,
    configureSession: d,
    enableEmojiFeedback: r,
    enableMention: i
  } = jn();
  V1(
    n !== null && t !== null,
    "applicationId and botId must be provided"
  );
  const { sbConnectionStatus: c } = UU(), V = nn(
    () => ({
      appStateToggleEnabled: !1
    }),
    []
  );
  mC(t), uC();
  const s = Wt({ "chat-ai-widget": "True" });
  return c === "INIT" ? /* @__PURE__ */ Y.jsx(Cv, { isStartingPage: !0 }) : /* @__PURE__ */ Y.jsx(
    fw,
    {
      appId: n,
      userId: l,
      nickname: a,
      customApiHost: e || `https://api-${n}.sendbird.com`,
      customWebSocketHost: `wss://ws-${n}.sendbird.com`,
      sdkInitParams: V,
      configureSession: d,
      customExtensionParams: s.current,
      breakPoint: NC,
      isReactionEnabled: r,
      isMentionEnabled: i,
      uikitOptions: {
        groupChannel: {
          input: {
            // To hide the file upload icon from the message input
            enableDocument: !1
          }
        }
      },
      children: /* @__PURE__ */ Y.jsxs(Y.Fragment, { children: [
        /* @__PURE__ */ Y.jsx(hle, {}),
        /* @__PURE__ */ Y.jsx("div", { id: "sb_chat_root_for_z_index" })
      ] })
    }
  );
}, Tle = ({
  apiHost: e,
  applicationId: n,
  botId: t,
  hashedKey: l,
  isOpen: a = !0,
  ...d
}) => {
  const r = {}.VITE_CHAT_WIDGET_APP_ID, i = {}.VITE_CHAT_WIDGET_BOT_ID;
  V1(
    n !== null && t !== null,
    "applicationId and botId must be provided"
  );
  const c = new qC({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: !1,
        refetchOnReconnect: !1,
        staleTime: 5e3
      }
    }
  });
  return /* @__PURE__ */ Y.jsx(lK, { client: c, children: /* @__PURE__ */ Y.jsx(
    ZC,
    {
      apiHost: e,
      applicationId: r ?? n,
      botId: i ?? t,
      ...d,
      children: /* @__PURE__ */ Y.jsx(ole, { hashedKey: l ?? null, children: /* @__PURE__ */ Y.jsx(TC, { children: a && /* @__PURE__ */ Y.jsx(Zle, {}) }) })
    }
  ) });
}, Fle = A.div`
  overscroll-behavior: none;
  -webkit-overflow-scrolling: auto;
  background-color: #fff;
  position: fixed;
  bottom: 84px;
  right: 20px;
  height: 640px;
  min-height: 80px;
  width: 400px;
  max-width: 80vw;
  max-height: 80vh;
  box-shadow: 0px 16px 24px 2px rgba(33, 33, 33, 0.12),
    0px 6px 30px 5px rgba(33, 33, 33, 0.08),
    0px 6px 10px -5px rgba(33, 33, 33, 0.04);
  border-radius: 16px;
  overflow: hidden;
  transform-origin: right bottom;
  transition: width 200ms ease 0s, height 200ms ease 0s,
    max-height 200ms ease 0s, transform 150ms cubic-bezier(0, 1.2, 1, 1) 0s,
    opacity 83ms ease-out 0s;
  transform: scale(0.15);
  opacity: 0;

  ${({ isOpen: e }) => e && aa`
        z-index: 10000;
        pointer-events: all;
        transform: scale(1);
        opacity: 1;
        transition: width 200ms ease 0s, height 200ms ease 0s,
          max-height 200ms ease 0s,
          transform 300ms cubic-bezier(0, 1.2, 1, 1) 0s,
          opacity 83ms ease-out 0s;
      `}
  /** widget close button for mobile version */
  .widget-close-button {
    display: none;
  }

  ${({ isExpanded: e }) => e && aa`
      width: 743px;
      height: 723px;
    `}
`, Wle = ({ isOpen: e, ...n }) => /* @__PURE__ */ Y.jsx(
  Fle,
  {
    isOpen: e,
    isExpanded: !1,
    id: "chat-widget-window",
    children: /* @__PURE__ */ Y.jsx(Tle, { ...n, isOpen: e })
  }
), mle = (e) => /* @__PURE__ */ z.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 16 16", ...e }, /* @__PURE__ */ z.createElement("path", { fill: "#A3A8C4", fillRule: "nonzero", d: "M8 9.586L2.707 4.293a1 1 0 1 0-1.414 1.414l6 6a1 1 0 0 0 1.414 0l6-6a1 1 0 0 0-1.414-1.414L8 9.586z" })), ule = A.button`
  position: fixed;
  z-index: 10000;
  bottom: 24px;
  right: 24px;
  width: 48px;
  height: 48px;
  background: conic-gradient(
    from 180deg at 50% 50%,
    #4dcd90 -17.35deg,
    #6210cc 80.63deg,
    #6210cc 176.25deg,
    #4dcd90 342.65deg,
    #6210cc 440.63deg
  );
  border-radius: 50%;
  color: white;
  transition: all 0.3s cubic-bezier(0.31, -0.105, 0.43, 1.4);
  border: none;
  display: flex;
  justify-content: center;
  align-items: center;
  box-shadow: 0px 16px 24px 2px rgba(33, 33, 33, 0.12),
    0px 6px 30px 5px rgba(33, 33, 33, 0.08),
    0px 6px 10px -5px rgba(33, 33, 33, 0.04);

  span {
    position: absolute;
    transition: transform 0.16s linear 0s, opacity 0.08s linear 0s;
    width: 32px;
    height: 32px;
    user-select: none;
    display: flex;
    justify-content: center;
    align-items: center;

    path {
      fill: white;
    }
  }

  &:hover {
    transition: transform 250ms cubic-bezier(0.33, 0, 0, 1);
    transform: scale(1.1);
  }

  &:active {
    transform: scale(0.8);
  }
`, ple = A.span`
  ${({ isOpen: e }) => e ? aa`
          opacity: 0;
          transform: rotate(30deg) scale(0);
        ` : aa`
          opacity: 1;
          transform: rotate(0deg);
        `}
`, Mle = A.span`
  ${({ isOpen: e }) => e ? aa`
          transform: rotate(0deg);
        ` : aa`
          transform: rotate(-90deg) scale(0);
        `}
`, Ele = (e) => {
  if (!document)
    return;
  const n = 36e5, t = /* @__PURE__ */ new Date(), a = t.getTime() + n * 48;
  t.setTime(a);
  const d = t.toUTCString();
  document.cookie = `${e}=true;expires=${d};path=/`;
}, Sle = (e) => document ? document.cookie.split(";").filter((t) => t.includes(`${e}=`)) : [], zle = (e) => {
  const [n, t] = me(e.autoOpen ?? !1), l = Wt(null), a = () => {
    l.current !== null && (clearTimeout(l.current), l.current = null), t((d) => !d);
  };
  return _e(() => {
    Sle("chatbot").length === 0 && (l.current = setTimeout(() => t(() => !0), 1e3), Ele("chatbot"));
  }, []), /* @__PURE__ */ Y.jsxs(ez, { children: [
    /* @__PURE__ */ Y.jsx(Wle, { isOpen: n, setIsOpen: t, ...e }),
    /* @__PURE__ */ Y.jsxs(ule, { onClick: a, children: [
      /* @__PURE__ */ Y.jsx(ple, { isOpen: n, children: /* @__PURE__ */ Y.jsx(PY, {}) }),
      /* @__PURE__ */ Y.jsx(Mle, { isOpen: n, children: /* @__PURE__ */ Y.jsx(mle, {}) })
    ] })
  ] });
};
export {
  zle as C,
  kk as H,
  D as L,
  FW as P,
  ue as R,
  Jle as V,
  _N as X,
  Ll as Y,
  Sc as a,
  Tle as b,
  Qle as c,
  j as g,
  Y as j
};
